9, 0xA4, 0x8C, 0xFB, 0x34, 0xF1, 0x70, 0x86, 0xF7, 0x71, 0xDE,
    0xE8, 0x80, 0x7D, 0x84, 0x36, 0x76, 0xA5, 0xB6, 0xD7, 0xFE, 0x0D, 0xE9, 0xB1,
    0x72, 0xC6, 0x7E, 0xCF, 0x1C, 0xEC, 0xCA, 0x89, 0x0E, 0x4F, 0xF8, 0x94, 0x13,
    0x1E, 0x7A, 0x43, 0xA6, 0x76, 0x97, 0x12, 0x41, 0x3E, 0x8A, 0x63, 0xD1, 0x09,
    0x6B, 0x3A, 0x45, 0x68, 0xA9, 0xC2, 0x8A, 0x5E, 0xA2, 0x00, 0x54, 0x59, 0x7D,
    0x8E, 0xAF, 0x15, 0xE1, 0x6C, 0x1B, 0x3F, 0x4E, 0x17, 0x92, 0xC2, 0xBC, 0x3A,
    0x78, 0x9B, 0x7B, 0xBB, 0x69, 0x9D, 0x65, 0x73, 0x43, 0xF9, 0xE0, 0xE6, 0x9D,
    0x11, 0xC4, 0xC9, 0x8A, 0xB0, 0x38, 0x5D, 0x59, 0x84, 0x6A, 0x78, 0x79, 0xAD,
    0x39, 0x65, 0x6D, 0x8B, 0xFD, 0xFA, 0x77, 0x42, 0x23, 0x96, 0x89, 0xF3, 0x56,
    0x98, 0x47, 0x43, 0x81, 0x7D, 0x89, 0x88, 0x7C, 0xE9, 0x49, 0x02, 0xCE, 0xBE,
    0x7D, 0x4C, 0x81, 0xBC, 0x23, 0xE4, 0x5E, 0x0B, 0xBD, 0x26, 0x33, 0xAE, 0x3E,
    0x89, 0x02, 0xBF, 0x45, 0xFC, 0x3A, 0x73, 0x11, 0xB2, 0xEF, 0xCF, 0x4E, 0xFC,
    0x03, 0xEE, 0x8A, 0xEC, 0x83, 0x4F, 0x1C, 0x05, 0xDF, 0x25, 0x17, 0xE8, 0xEC,
    0x8C, 0x0E, 0x1F, 0x41, 0x1A, 0x67, 0x09, 0xED, 0x2C, 0x1A, 0x32, 0x56, 0xDB,
    0x60, 0x07, 0xB0, 0xE0, 0xDF, 0x91, 0xFE, 0xD9, 0xDB, 0xBB, 0x64, 0x93, 0xE8,
    0x5E, 0x4D, 0xE9, 0x44, 0xF1, 0x29, 0x91, 0x15, 0x37, 0x94, 0xEC, 0x1C, 0x81,
    0x19, 0xA4, 0x86, 0xDA, 0xEA, 0x20, 0x1F, 0xA3, 0xD9, 0x12, 0x5E, 0x32, 0x36,
    0xC2, 0x73, 0xD4, 0x82, 0x33, 0xAA, 0x55, 0x83, 0x88, 0x4E, 0x74
};

#define SIZE_PRIVATE_KEY         sizeof(s_keyPrivate1)


#endif // PACKTHEM_SIGNING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\preview\preview.cpp ===
//----------------------------------------------------------------------------
//  Preview.cpp - image preview app for theme authoring
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "resource.h"
#include "shlwapip.h"
#include "themeldr.h"
//----------------------------------------------------------------------------
#define MAX_LOADSTRING 100
//----------------------------------------------------------------------------
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
HRESULT InitDib(HINSTANCE hInstance, LPCWSTR pszFileName);
void SetBackground(HWND hWnd, HINSTANCE hinst, int id, int iMenuId);
INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);
void OnFileOpen(HINSTANCE hInst, HWND hWnd);
void SetZoom(HWND hWnd, HINSTANCE hInstance, int iZoomPercent, int iMenuId);
//----------------------------------------------------------------------------
HINSTANCE hInst;	
HBITMAP hCenterDIB = NULL;
HBITMAP hbrBackground = NULL;
int iDibWidth;
int iDibHeight;
int iCurrentBgMenu = 0;
int iCurrentZoomMenu = 0;
int iZoomFactor = 100;
BOOL fAlpha;
//----------------------------------------------------------------------------
int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE, LPWSTR lpCmdLine, int nCmdShow)
{
	MSG msg;
	HACCEL hAccelTable;
    TCHAR szWindowClass[MAX_LOADSTRING];	
    TCHAR szTitle[MAX_LOADSTRING];				

    //---- initialize globals from themeldr.lib ----
    ThemeLibStartUp(FALSE);
    
	//---- Initialize global strings ----
    LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_PREVIEW, szWindowClass, MAX_LOADSTRING);

    //---- register window class ----
    WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

    wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_PREVIEW);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= NULL;
	wcex.lpszMenuName	= MAKEINTRESOURCE(IDC_PREVIEW);
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	RegisterClassEx(&wcex);
    
    if (*lpCmdLine)
        InitDib(hInstance, lpCmdLine);

    //---- create the main window ----
    HWND hWnd;
    hInst = hInstance; // Store instance handle in our global variable

    hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
    if (!hWnd)
        return 1;

    SetBackground(hWnd, hInstance, IDB_PINKGRAY, ID_BACKGROUND_GRAYPINK);
    SetZoom(hWnd, hInstance, 100, ID_ZOOM_100);

    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);
	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_PREVIEW);

    //---- initialize us as a drag target ----
    DragAcceptFiles(hWnd, TRUE);

    //---- main message loop ----
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return (int)msg.wParam;
}
//----------------------------------------------------------------------------
void SetBackground(HWND hWnd, HINSTANCE hInstance, int id, int iMenuId)
{
    if (hbrBackground)
        DeleteObject(hbrBackground);
    
    hbrBackground = LoadBitmap(hInstance, MAKEINTRESOURCE(id));

    InvalidateRect(hWnd, NULL, TRUE);

    //---- update menu items ----
    HMENU hMenu = GetMenu(hWnd);
    hMenu = GetSubMenu(hMenu, 1);

    if (iCurrentBgMenu)
        CheckMenuItem(hMenu, iCurrentBgMenu, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hMenu, iMenuId, MF_BYCOMMAND | MF_CHECKED);

    iCurrentBgMenu = iMenuId;
}
//----------------------------------------------------------------------------
HRESULT InitDib(HINSTANCE hInstance, LPCWSTR pszFileName)
{
    if (hCenterDIB)
    {
        DeleteObject(hCenterDIB);
        hCenterDIB = NULL;
    }

    int iRetVal = 0;
    fAlpha = FALSE;
    WCHAR *pszOutputName = L"$temp$.bmp";
    HRESULT hr = S_OK;
    HDC hdc = NULL;
    DWORD *pBits = NULL;

    //---- ensure file exists ----
    if (! FileExists(pszFileName))
    {
        hr = MakeError32(STG_E_FILENOTFOUND);       
        goto exit;
    }

    //---- convert file, if needed ----
    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBaseName[_MAX_FNAME], szExt[_MAX_EXT];
    _wsplitpath(pszFileName, szDrive, szDir, szBaseName, szExt);
    if (lstrcmpi(szExt, L".bmp") != 0)           // not a .bmp file
    {
        //---- protect ourselves from crashes ----
        try
        {
            hr = SHConvertGraphicsFile(pszFileName, pszOutputName, SHCGF_REPLACEFILE);
        }
        catch (...)
        {
            hr = MakeError32(E_FAIL);
        }

        if ((SUCCEEDED(hr)) && (! FileExists(pszOutputName)))
            hr = MakeError32(E_FAIL);

        if (FAILED(hr))
            goto exit;

        pszFileName = pszOutputName;
    }

    //---- load the specified center bitmap as a DIB ----
    hCenterDIB = (HBITMAP) LoadImage(hInstance, pszFileName, IMAGE_BITMAP,
        0, 0, LR_CREATEDIBSECTION | LR_LOADFROMFILE);
    if (! hCenterDIB)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    BITMAP bminfo;
    GetObject(hCenterDIB, sizeof(bminfo), &bminfo);

    iDibWidth = bminfo.bmWidth;
    iDibHeight = bminfo.bmHeight;

    if (bminfo.bmBitsPixel < 32)
        iRetVal = 1;
    else
    {
        pBits = new DWORD[(iDibWidth+20)*iDibHeight];
        if (! pBits)
        {
            hr = MakeError32(E_OUTOFMEMORY);
            goto exit;
        }

        BITMAPINFOHEADER BitMapHdr = {sizeof(BITMAPINFOHEADER), iDibWidth, iDibHeight, 1, 32, BI_RGB};
        hdc = GetWindowDC(NULL);
        if (! hdc)
        {
            hr = MakeErrorLast();
            goto exit;
        }

        iRetVal = GetDIBits(hdc, hCenterDIB, 0, iDibHeight, pBits, (BITMAPINFO *)&BitMapHdr, DIB_RGB_COLORS);
        if (! iRetVal)
        {
            hr = MakeErrorLast();
            goto exit;
        }

        DWORD *pdw = pBits;

        //---- pre-multiply bits - required by AlphaBlend() API ----
        for (int r=0; r < iDibHeight; r++)
        {
            for (int c=0; c < iDibWidth; c++)
            {
                COLORREF cr = *pdw;
                int iAlpha = ALPHACHANNEL(cr);
                if (iAlpha)
                {
                    int iRed = (RED(cr)*iAlpha)/255;
                    int iGreen = (GREEN(cr)*iAlpha)/255;
                    int iBlue = (BLUE(cr)*iAlpha)/255;

                    *pdw++ = (RGB(iRed, iGreen, iBlue) | (iAlpha << 24));
                    fAlpha = TRUE;
                }
                else
                    *pdw++ = 0;
            } 
        }

        if (fAlpha)
        {
            iRetVal = SetDIBits(NULL, hCenterDIB, 0, iDibHeight, pBits, (BITMAPINFO *)&BitMapHdr, DIB_RGB_COLORS);
            if (! iRetVal)
            {
                hr = MakeErrorLast();
                goto exit;
            }
        }
        else
            MessageBox(NULL, L"Alpha Channel of bitmap is all zero's", L"Warning", MB_OK);
    }

exit:
    if (hdc)
        ReleaseDC(NULL, hdc);
    
    if (pBits)
        delete [] pBits;

    if (FAILED(hr))
        MessageBox(NULL, L"Error loading bitmap", L"Error", MB_OK);

    return hr;
}
//----------------------------------------------------------------------------
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;

	switch (message) 
	{
        case WM_DROPFILES:
        {
            HDROP hDrop = (HDROP)wParam;
            WCHAR szFileName[_MAX_PATH+1];
            int iGot = DragQueryFile(hDrop, 0, szFileName, ARRAYSIZE(szFileName));
            DragFinish(hDrop);

            if (iGot)               // got a valid filename
            {
                HRESULT hr = InitDib(hInst, szFileName);
                if (SUCCEEDED(hr))
                    InvalidateRect(hWnd, NULL, TRUE);
            }
        }
        break;

		case WM_COMMAND:
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 
			// Parse the menu selections:
			switch (wmId)
			{
                case ID_FILE_OPEN:
                   OnFileOpen(hInst, hWnd);
                   break;

				case IDM_ABOUT:
				   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, About);
				   break;

				case IDM_EXIT:
				   DestroyWindow(hWnd);
				   break;

                case ID_BACKGROUND_GRAYPINK:
                   SetBackground(hWnd, hInst, IDB_PINKGRAY, wmId);
                   break;

                case ID_BACKGROUND_BLUEGRAY:
                   SetBackground(hWnd, hInst, IDB_BLUEGRAY, wmId);
                   break;

                case ID_BACKGROUND_WHITE:
                   SetBackground(hWnd, hInst, IDB_WHITE, wmId);
                   break;
                   
                case ID_BACKGROUND_GRAY:
                   SetBackground(hWnd, hInst, IDB_GRAY, wmId);
                   break;
                   
                case ID_ZOOM_50:
                   SetZoom(hWnd, hInst, 50, wmId);
                   break;
                   
                case ID_ZOOM_100:
                   SetZoom(hWnd, hInst, 100, wmId);
                   break;
                   
                case ID_ZOOM_200:
                   SetZoom(hWnd, hInst, 200, wmId);
                   break;
                   
                case ID_ZOOM_400:
                   SetZoom(hWnd, hInst, 400, wmId);
                   break;
                                   
                default:
				   return DefWindowProc(hWnd, message, wParam, lParam);
			}
			break;

		case WM_ERASEBKGND:
            HBRUSH hbr;
            hbr = CreatePatternBrush(hbrBackground);
            hdc = (HDC)wParam;
            if ((hbr) && (hdc))
            {
                RECT rect;
                GetClientRect(hWnd, &rect);
                FillRect(hdc, &rect, hbr);
                DeleteObject(hbr);
            }
            return 1;

		case WM_PAINT:
			hdc = BeginPaint(hWnd, &ps);

            XFORM xForm;

            xForm.eM11 = (FLOAT)(iZoomFactor/100.); 
            xForm.eM12 = (FLOAT) 0.0; 
            xForm.eM21 = (FLOAT) 0.0; 
            xForm.eM22 = (FLOAT)(iZoomFactor/100.); 
            xForm.eDx  = (FLOAT) 0.0; 
            xForm.eDy  = (FLOAT) 0.0; 

            SetGraphicsMode(hdc, GM_ADVANCED);
            SetWorldTransform(hdc, &xForm);

            //---- get scaled rect ----
			RECT rc;
			GetClientRect(hWnd, &rc);
            rc.right = (rc.right*100)/iZoomFactor;
            rc.bottom = (rc.bottom*100)/iZoomFactor;

            //---- paint the center bitmap ----
            HDC dc2;
            dc2 = CreateCompatibleDC(hdc);
            if ((dc2) && (hCenterDIB))
            {
                HBITMAP hOldBitmap2;
                hOldBitmap2 = (HBITMAP) SelectObject(dc2, hCenterDIB);

                int x = ((rc.right - rc.left) - iDibWidth)/2;
                int y = ((rc.bottom - rc.top) - iDibHeight)/2;
                BLENDFUNCTION bf = {AC_SRC_OVER, 0, 255, AC_SRC_ALPHA};

                if (fAlpha)
                {
                    AlphaBlend(hdc, x, y, iDibWidth, iDibHeight, 
                        dc2, 0, 0, iDibWidth, iDibHeight, bf);
                }
                else
                {
                    BitBlt(hdc, x, y, iDibWidth, iDibHeight, 
                        dc2, 0, 0, SRCCOPY);
                }

                SelectObject(dc2, hOldBitmap2);
                DeleteDC(dc2);
            }

			EndPaint(hWnd, &ps);
			break;

		case WM_DESTROY:
			PostQuitMessage(0);
			break;

		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}
//----------------------------------------------------------------------------
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
				return TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}
//----------------------------------------------------------------------------
void OnFileOpen(HINSTANCE hInst, HWND hWnd)
{
	const WCHAR *filter = 
		L"Bitmap Files (*.bmp)\0*.bmp\0"
		L"PNG Files (*.png)\0*.png\0"
		L"All Files (*.*)\0*.*\0\0";

    OPENFILENAME ofn = {sizeof(ofn)};  
    WCHAR szFile[_MAX_PATH+1] = {0};       

    //---- init ofn ----
    ofn.hwndOwner = hWnd;
    ofn.hInstance = hInst;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = ARRAYSIZE(szFile);
    ofn.lpstrFilter = filter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = L"Select an Image File to preview";
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    // Display the Open dialog box. 

    if (GetOpenFileName(&ofn)) 
    {
        HRESULT hr = InitDib(hInst, szFile);
        if (SUCCEEDED(hr))
            InvalidateRect(hWnd, NULL, TRUE);
    }
}
//----------------------------------------------------------------------------
void SetZoom(HWND hWnd, HINSTANCE hInstance, int iZoomPercent, int iMenuId)
{
    iZoomFactor = iZoomPercent;

    InvalidateRect(hWnd, NULL, TRUE);

    //---- update menu items ----
    HMENU hMenu = GetMenu(hWnd);
    hMenu = GetSubMenu(hMenu, 2);

    if (iCurrentZoomMenu)
        CheckMenuItem(hMenu, iCurrentZoomMenu, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hMenu, iMenuId, MF_BYCOMMAND | MF_CHECKED);

    iCurrentZoomMenu = iMenuId;
}
//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\preview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Preview.rc
//
#define IDC_MYICON                      2
#define IDB_PINKGRAY                    4
#define IDB_BLUEGRAY                    5
#define IDB_WHITE                       6
#define IDB_GRAY                        7
#define IDD_PREVIEW_DIALOG              102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_PREVIEW                     107
#define IDI_SMALL                       108
#define IDC_PREVIEW                     109
#define IDR_MAINFRAME                   128
#define ID_BACKGROUND_GRAYPINK          32771
#define ID_BACKGROUND_GRAY              32772
#define ID_BACKGROUND_WHITE             32773
#define ID_BACKGROUND_BLUEGRAY          32774
#define ID_FILE_OPEN                    32775
#define ID_ZOOM_50                      32776
#define ID_ZOOM_100                     32777
#define ID_ZOOM_200                     32778
#define ID_ZOOM_400                     32779
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32780
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\preview\stdafx.h ===
//---------------------------------------------------------------------------
//  StdAfx.h - defines precompiled hdr set 
//---------------------------------------------------------------------------
#ifndef _STDAFX_H_
#define _STDAFX_H_
//---------------------------------------------------------------------------
#define _iswupper(_c)    ( iswctype(_c,_UPPER) )
#define _iswlower(_c)    ( iswctype(_c,_LOWER) )
#define _iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define _iswxdigit(_c)   ( iswctype(_c,_HEX) )
//---------------------------------------------------------------------------
#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
//---------------------------------------------------------------------------
#define STRICT
#define _ATL_NO_ATTRIBUTES
//---------------------------------------------------------------------------
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <windows.h>
//---------------------------------------------------------------------------
#include "autos.h"
#include "log.h"
#include "errors.h"
#include "utils.h"
//---------------------------------------------------------------------------
#include <atlbase.h>
#define STRSAFE_LIB 
#include <strsafe.h>
//---------------------------------------------------------------------------
#endif //_STDAFX_H_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\candy\makefile.inc ===
Candy.mstheme : themes.ini default.ini
    packthem .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\empty\makefile.inc ===
$(O)\empty.mst : themes.ini default.ini
    packthem /o $(O)\empty.mst /k .
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\luna\makefile.inc ===
$(O)\luna.mst : themes.ini Blue\Blue.ini Metallic\Metallic.ini Homestead\Homestead.ini
    packthem /o $(O)\luna.mst /k .
     $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\mallard\makefile.inc ===
$(O)\Test.mst : themes.ini default.ini paler.ini
    packthem /o $(O)\Test.mst /k .
     $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\native\makefile.inc ===
Native.mstheme : themes.ini default.ini 
    packthem .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\professional\makefile.inc ===
$(O)\pro.mst : themes.ini default.ini
    packthem /o $(O)\pro.mst /k .
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\shellstyle\common.h ===
#ifndef _COMMON_H_
#define _COMMON_H_


//
// Strings
//

#define IDS_TAHOMA                     1
#define IDS_FRANKLIN_GOTHIC_MEDIUM     2

#define IDS_FONT_WEIGHT_BOLD          10
#define IDS_FONT_WEIGHT_LGTITLE       11
#define IDS_FONT_WEIGHT_LGTEXT        12

#define IDS_FONT_SIZE_8               15
#define IDS_FONT_SIZE_10              16
#define IDS_FONT_SIZE_14              17
#define IDS_FONT_SIZE_21              18


//
// Bitmaps
//
// ID's below 100 are defined in shell\inc\shstyle.h
// ID's above 499 are defined in the theme specific header files
//

#define IDB_UP                       100
#define IDB_UPHOT                    101
#define IDB_DOWN                     102
#define IDB_DOWNHOT                  103
#define IDB_UPMAIN                   104
#define IDB_UPHOTMAIN                105
#define IDB_DOWNMAIN                 106
#define IDB_DOWNHOTMAIN              107

#define IDB_HEADERMAIN               110
#define IDB_HEADERSECTION            112

#endif // _COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\shellstyle\makefile.inc ===
#
# cpstyle.uix is precompiled to include common Control Panel style information
# from shell\inc and theme-specific metrics information from the local project.
# This produces cpstyle.ui which is then included in shellstyle.rc
#
shellstyle.rc : $(O)\cpstyle.ui $(O)\style.ui

$(O)\cpstyle.ui : $(O)\cpstyle.uipp
    cleaninf -w $(O)\cpstyle.uipp $(O)\cpstyle.ui

$(O)\cpstyle.uipp : cpstyle.uix
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $@

cpstyle.uix : ..\cpstyle_common.uix

$(O)\style.ui : $(O)\style.uipp
    cleaninf -w $(O)\style.uipp $(O)\style.ui

$(O)\style.uipp : style.uix
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\shellstyle\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)
TARGETPATH      = obj
TARGETTYPE      = DYNLINK

INCLUDES        = $(INCLUDES);$(O);$(WINDOWS_INC_PATH)\duser

RESOURCE_ONLY_DLL=1
SUBSYSTEM_VERSION=$(SUBSYSTEM_VERSION_LATEST)

NTTARGETFILE0 = \
    $(O)\cpstyle.ui \
    $(O)\style.ui
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\shellstyle\blue\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\shellstyle\classic\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\shellstyle\homestead\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\shellstyle\metallic\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\shellstyle\classic\class_ss.h ===
// header file for classic theme specific elements
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themefiles\bla\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\shellstyle\blue\blue_ss.h ===
// header file for blue theme specific elements
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themefiles\common\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themefiles\dtc\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themefiles\ent\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themefiles\per\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themefiles\pro\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\shellstyle\homestead\home_ss.h ===
// header file for homestead theme specific elements
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themefiles\srv\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themefiles\makefile.inc ===
# files on the cd need to be 8.3 (rename is taken care of in shl_img.inf)

$(O)\luna.the : Luna.theme
    copy $** $@

$(O)\classic.the : classic.theme
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themedir\shellstyle\metallic\metal_ss.h ===
// header file for metallic theme specific elements
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeldr\stdafx.h ===
//---------------------------------------------------------------------------
//  StdAfx.h - defines precompiled hdr set (doesn't use CrtDbgReport)
//---------------------------------------------------------------------------
#ifndef _STDAFX_THEMELDR_
#define _STDAFX_THEMELDR_
//---------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//---------------------------------------------------------------------------
#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
//---------------------------------------------------------------------------
#define _ATL_NO_ATTRIBUTES
#define _ATL_APARTMENT_THREADED
//---------------------------------------------------------------------------
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <windows.h>
//---------------------------------------------------------------------------
#define _THEMELDR_
//---------------------------------------------------------------------------
#include <w4warn.h>
//---------------------------------------------------------------------------
#include "autos.h"
#include "log.h"
#include "Errors.h"
#include "Utils.h"
#include "SimpStr.h"
#include "stringtable.h"
//---------------------------------------------------------------------------
#include <atlbase.h> 
//---------------------------------------------------------------------------
#define   STRSAFE_LIB
#include <strsafe.h>
//---------------------------------------------------------------------------
#endif //_STDAFX_THEMELDR_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeldr\errors.cpp ===
//---------------------------------------------------------------------------
//    errors.cpp - support for error handling/reporting
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <time.h>
#include "utils.h"
#include "errors.h"
//---------------------------------------------------------------------------
DWORD _tls_ErrorInfoIndex = 0xffffffff;         // index to tls pObjectPool
//---------------------------------------------------------------------------
TMERRINFO *GetParseErrorInfo(BOOL fOkToCreate)
{
    TMERRINFO *ei = NULL;

    if (_tls_ErrorInfoIndex != 0xffffffff)     // init-ed in ProcessAttach()
    {
        ei = (TMERRINFO *)TlsGetValue(_tls_ErrorInfoIndex);
        if ((! ei) && (fOkToCreate))          // not yet initialized
        {
            //---- create a thread-local TMERRINFO ----
            ei = new TMERRINFO;
            TlsSetValue(_tls_ErrorInfoIndex, ei);
        }
    }

    return ei;
}
//---------------------------------------------------------------------------
HRESULT MakeParseError(DWORD dwParseErrCode, OPTIONAL LPCWSTR pszMsgParam1, 
    OPTIONAL LPCWSTR pszMsgParam2, OPTIONAL LPCWSTR pszSourceName, 
    OPTIONAL LPCWSTR pszSourceLine, int iLineNum)
{
    TMERRINFO *pErrInfo = GetParseErrorInfo(TRUE);

    if (pErrInfo)       // record err info for later use
    {
        pErrInfo->dwParseErrCode = dwParseErrCode;
        pErrInfo->iLineNum = iLineNum;

        SafeStringCchCopyW(pErrInfo->szMsgParam1, ARRAYSIZE(pErrInfo->szMsgParam1), pszMsgParam1);
        SafeStringCchCopyW(pErrInfo->szMsgParam2, ARRAYSIZE(pErrInfo->szMsgParam2), pszMsgParam2);

        SafeStringCchCopyW(pErrInfo->szFileName, ARRAYSIZE(pErrInfo->szFileName), pszSourceName);
        SafeStringCchCopyW(pErrInfo->szSourceLine, ARRAYSIZE(pErrInfo->szSourceLine), pszSourceLine);
    }

    return HRESULT_FROM_WIN32(ERROR_UNKNOWN_PROPERTY);      // special code for parse failed
}
//---------------------------------------------------------------------------
HRESULT MakeError32(HRESULT hr)
{
    return HRESULT_FROM_WIN32(hr);
}
//---------------------------------------------------------------------------
HRESULT MakeErrorLast()
{
    HRESULT hr = GetLastError();
    return HRESULT_FROM_WIN32(hr);
}
//---------------------------------------------------------------------------
HRESULT MakeErrorParserLast()
{
    return HRESULT_FROM_WIN32(ERROR_UNKNOWN_PROPERTY);      // parse error info has already been set
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeldr\scanner.cpp ===
//---------------------------------------------------------------------------
//  Scanner.cpp - supports parsing general text files & lines with
//                a ";" style comment (rest of line is comment)
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "scanner.h"
#include "utils.h"
//---------------------------------------------------------------------------
CScanner::CScanner(LPCWSTR pszTextToScan)
{
    ResetAll(FALSE);

    _p = pszTextToScan;
    _pSymbol = NULL;
}
//---------------------------------------------------------------------------
CScanner::~CScanner()
{
    ResetAll(TRUE);
}
//---------------------------------------------------------------------------
void CScanner::UseSymbol(LPCWSTR pszSymbol)
{
    if (pszSymbol == NULL)
    {
        if (_pSymbol && *_p)
        {
            _p = _pSymbol;
        }
        _pSymbol = NULL;
    }
    else
    {
        _pSymbol = _p;
        _p = pszSymbol;
    }
}
//---------------------------------------------------------------------------
BOOL CScanner::ReadNextLine()
{
    if ((! _pszMultiLineBuffer) || (! *_pszMultiLineBuffer))          // end of multiple lines
    {
        _fEndOfFile = TRUE;
        return FALSE;
    }

    WCHAR *q = _szLineBuff;
    while ((*_pszMultiLineBuffer) && (*_pszMultiLineBuffer != '\r') && (*_pszMultiLineBuffer != '\n'))
        *q++ = *_pszMultiLineBuffer++;

    *q = 0;

    if (*_pszMultiLineBuffer == '\r')
        _pszMultiLineBuffer++;

    if (*_pszMultiLineBuffer == '\n')
        _pszMultiLineBuffer++;

    _p = _szLineBuff;
    _fBlankSoFar = TRUE;
    _iLineNum++;

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::SkipSpaces()
{
    while (1)
    {
        while (IsSpace(*_p))
            _p++;

        if ((! *_p) || (*_p == ';'))      // end of line 
        {
            if ((_fBlankSoFar) && (! _fEndOfFile))
            {
                ReadNextLine();
                continue;
            }
        
            if (*_p == ';')              // comment
                _p += lstrlen(_p);         // skip to end of line

            return FALSE;
        }

        //---- good chars on this line ----
        _fBlankSoFar = FALSE;
        break;
    }

    return (*_p != 0);
}
//---------------------------------------------------------------------------
BOOL CScanner::GetId(LPWSTR pszIdBuff, DWORD cchIdBuff)
{
    if (! cchIdBuff)               // must have at least 1 space for NULL terminator
        return FALSE;

    SkipSpaces();

    WCHAR *v = pszIdBuff;

    while ((IsNameChar(FALSE)) && (--cchIdBuff))
        *v++ = *_p++;
    *v = 0;

    if (v == pszIdBuff)        // no chars found
        return FALSE;

    if (IsNameChar(FALSE))          // ran out of room
        return FALSE;

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::GetIdPair(LPWSTR pszIdBuff, LPWSTR pszValueBuff, DWORD cchValueBuff)
{
    if (! cchValueBuff)               // must have at least 1 space for NULL terminator
        return FALSE;

    if (!GetId(pszIdBuff, cchValueBuff))
        return FALSE;

    if (!GetChar('='))
        return FALSE;

    SkipSpaces();
    // Take everything until the end of line

    SafeStringCchCopyW(pszValueBuff, cchValueBuff, _p);

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::GetFileName(LPWSTR pszFileNameBuff, DWORD cchFileNameBuff)
{
    if (! cchFileNameBuff)               // must have at least 1 space for NULL terminator
        return FALSE;

    SkipSpaces();

    WCHAR *v = pszFileNameBuff;

    while ((IsFileNameChar(FALSE)) && (--cchFileNameBuff))
        *v++ = *_p++;
    *v = 0;

    if (v == pszFileNameBuff)        // no chars found
        return FALSE;

    if (IsFileNameChar(FALSE))          // ran out of room
        return FALSE;

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::GetNumber(int *piVal)
{
    SkipSpaces();

    if (! IsNumStart())
        return FALSE;

    *piVal = string2number(_p);
    if ((_p[0] == '0') && ((_p[1] == 'x') || (_p[1] == 'X')))      // hex num
        _p += 2;
    else
        _p++;            // skip over digit or sign

    //---- skip over number ---
    while (IsHexDigit(*_p))
        _p++;

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::IsNameChar(BOOL fOkToSkip)
{
    if (fOkToSkip)
        SkipSpaces();

    return ((IsCharAlphaNumericW(*_p)) || (*_p == '_') || (*_p == '-'));
}
//---------------------------------------------------------------------------
BOOL CScanner::IsFileNameChar(BOOL fOkToSkip)
{
    if (fOkToSkip)
        SkipSpaces();

    return ((IsCharAlphaNumericW(*_p)) || (*_p == '_') || (*_p == '-') ||
        (*_p == ':') || (*_p == '\\') || (*_p == '.'));
}
//---------------------------------------------------------------------------
BOOL CScanner::IsNumStart()
{
    SkipSpaces();

    return ((IsDigit(*_p)) || (*_p == '-') || (*_p == '+'));
}
//---------------------------------------------------------------------------
BOOL CScanner::GetChar(const WCHAR val)
{
    SkipSpaces();

    if (*_p != val)
        return FALSE;

    _p++;        // skip over WCHAR
    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::GetKeyword(LPCWSTR pszKeyword)
{
    BOOL fRet = FALSE;
    SkipSpaces();

    if( _p )
    {
        int cch = lstrlenW(pszKeyword);

        LPWSTR psz = new WCHAR[cch + 1];
        if (psz)
        {
            StringCchCopyW(psz, cch + 1, _p);

            if (AsciiStrCmpI(psz, pszKeyword)==0)
            {
                _p += cch;
                fRet = TRUE;
            }

            delete [] psz;
        }
    }
    
    return fRet;
}
//---------------------------------------------------------------------------
BOOL CScanner::EndOfLine()
{
    SkipSpaces();
    return (*_p == 0);
}
//---------------------------------------------------------------------------
BOOL CScanner::EndOfFile()
{
    return _fEndOfFile;
}
//---------------------------------------------------------------------------
BOOL CScanner::AttachLine(LPCWSTR pszLine)
{
    ResetAll(TRUE);
    _p = pszLine;

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL CScanner::AttachMultiLineBuffer(LPCWSTR pszBuffer, LPCWSTR pszFileName)
{
    ResetAll(TRUE);

    _p = _szLineBuff;
    _pszMultiLineBuffer = pszBuffer;

    SafeStringCchCopyW(_szFileName, ARRAYSIZE(_szFileName), pszFileName);

    return TRUE;
}
//---------------------------------------------------------------------------
HRESULT CScanner::AttachFile(LPCWSTR pszFileName)
{
    ResetAll(TRUE);

    HRESULT hr = AllocateTextFile(pszFileName, &_pszFileText, NULL);
    if (FAILED(hr))
        return hr;

    _pszMultiLineBuffer = _pszFileText;

    SafeStringCchCopyW(_szFileName, ARRAYSIZE(_szFileName), pszFileName);

    return S_OK;
}
//---------------------------------------------------------------------------
void CScanner::ResetAll(BOOL fPossiblyAllocated)
{
    _iLineNum = 0;
    _fEndOfFile = FALSE;
    _pszMultiLineBuffer = NULL;
    _fUnicodeInput = TRUE;
    _fBlankSoFar = TRUE;

    *_szFileName = 0;
    *_szLineBuff = 0;
    _p = _szLineBuff;

    if (fPossiblyAllocated)
    {
        if (_pszFileText)
        {
            LocalFree(_pszFileText);
            _pszFileText = NULL;
        }
    }
    else
        _pszFileText = NULL;
}
//---------------------------------------------------------------------------
BOOL CScanner::ForceNextLine()
{
    ReadNextLine();

    if (! SkipSpaces())
        return FALSE;

    return TRUE;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeldr\parser.cpp ===
//---------------------------------------------------------------------------
//  Parser.cpp - parses a "themes.ini" file and builds the ThemeInfo entries
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "scanner.h"
#include "Parser.h"
#include "Utils.h"
#include "TmUtils.h"
#include "TmSchema.h"
#include "TmReg.h"
//---------------------------------------------------------------------------
//#include "NtlParse.h"

#define SYSCOLOR_STRINGS
#include "SysColors.h"
//---------------------------------------------------------------------------
#define SCHEMA_STRINGS
#include "TmSchema.h"       // implements GetSchemaInfo()

static HBITMAP (*s_pfnSetBitmapAttributes)(HBITMAP, DWORD) = NULL;
static HBITMAP (*s_pfnClearBitmapAttributes)(HBITMAP, DWORD) = NULL;

//--------------------------------------------------------------------
CThemeParser::CThemeParser(BOOL fGlobalTheme)
{
    _pCallBackObj = NULL;
    _pNameCallBack = NULL;
    _fGlobalsDefined = FALSE;
    _fClassSectionDefined = FALSE;
    _fDefiningColorScheme = FALSE;
    _fUsingResourceProperties = FALSE;
    _fDefiningMetrics = FALSE;
    _fMetricsDefined = FALSE;
    _fGlobalTheme = FALSE;
    _crBlend = RGB(0, 0, 0xFF); // Hard code to blue
    
    *_szResPropValue = 0;       // not yet set

#ifdef DEBUG
    // Provide a means of disabling stock bitmaps
    BOOL fStock = TRUE;
    GetCurrentUserThemeInt(L"StockBitmaps", TRUE, &fStock);

    if (fStock && fGlobalTheme)
#else
    if (fGlobalTheme)
#endif
    {
        // Just don't use stock bitmaps when not running on Whistler
        if (s_pfnSetBitmapAttributes != NULL) 
        {
            _fGlobalTheme = TRUE;
        } else
        {
            HMODULE hMod = ::LoadLibrary(L"GDI32.DLL"); // No need to free
        
            if (hMod)
            {
                s_pfnSetBitmapAttributes = (HBITMAP (*)(HBITMAP, DWORD)) ::GetProcAddress(hMod, "SetBitmapAttributes");
                s_pfnClearBitmapAttributes = (HBITMAP (*)(HBITMAP, DWORD)) ::GetProcAddress(hMod, "ClearBitmapAttributes");

                if ((s_pfnSetBitmapAttributes != NULL) && (s_pfnClearBitmapAttributes != NULL))
                {
                    _fGlobalTheme = TRUE;
                }
            }
        }
    }
    
    *_szBaseSectionName = 0;
    *_szFullSectionName = 0;

    _iColorCount = 0;
    _iHueCount = 0;

    _uCharSet = DEFAULT_CHARSET;
    _iFontNumber = 0;
    _hinstThemeDll = NULL;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::SourceError(int iMsgResId, LPCWSTR pszParam1, LPCWSTR pszParam2)
{
    LPCWSTR pszSrcLine = _scan._szLineBuff;
    LPCWSTR pszFileName = _scan._szFileName;
    int iLineNum = _scan._iLineNum;

    if (*_szResPropValue)       // error in localizable property value
    {
        pszSrcLine = _szResPropValue;
        pszFileName = L"StringTable#";
        iLineNum = _iResPropId;
    }

    HRESULT hr = MakeParseError(iMsgResId, pszParam1, pszParam2, pszFileName, 
        pszSrcLine, iLineNum);
    
    return hr;
}
//---------------------------------------------------------------------------
int CThemeParser::GetSymbolIndex(LPCWSTR pszName)
{
    int symcnt = _Symbols.GetSize();

    for (int i=0; i < symcnt; i++)
    {
        if (AsciiStrCmpI(_Symbols[i].csName, pszName)==0)
            return i;
    }

    return -1;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::AddSymbol(LPCWSTR pszName, SHORT sTypeNum, PRIMVAL ePrimVal)
{
    //---- ensure symbol doesn't already exist ----
    for (int i = 0; i < _Symbols.m_nSize; i++)
    {
        if (AsciiStrCmpI(_Symbols.m_aT[i].csName, pszName)==0)
            return SourceError(PARSER_IDS_TYPE_DEFINED_TWICE, pszName);
    }

    if (sTypeNum == -1)
        sTypeNum = (SHORT)_Symbols.GetSize();

    SYMBOL symbol;
    symbol.csName = pszName;
    symbol.sTypeNum = sTypeNum;
    symbol.ePrimVal = ePrimVal;
    
    _Symbols.Add(symbol);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::InitializeSymbols()
{
    _Symbols.RemoveAll();
    _StockBitmapCleanupList.RemoveAll();
    
    //---- get tm & comctl symbols ----
    const TMSCHEMAINFO *si = GetSchemaInfo();
    int cnt = si->iPropCount;
    const TMPROPINFO *pi = si->pPropTable;

    //---- first pass - add all symbols except ENUM definitions ----
    for (int i=0; i < cnt; i++)
    {
        if (pi[i].bPrimVal == TMT_ENUMDEF)
            continue;

        if (pi[i].bPrimVal == TMT_ENUMVAL)
            continue;

        HRESULT hr = AddSymbol(pi[i].pszName, pi[i].sEnumVal, pi[i].bPrimVal);
        if (FAILED(hr))
            return hr;
    }

    //---- second pass - add ENUM definitions ----
    int iEnumPropNum = -1;

    for (int i=0; i < cnt; i++)
    {
        if (pi[i].bPrimVal == TMT_ENUMDEF)
        {
            int iSymIndex = GetSymbolIndex(pi[i].pszName);

            if (iSymIndex == -1)       // not found - add it as a non-property enum symbol
            {
                HRESULT hr = AddSymbol(pi[i].pszName, -1, TMT_ENUM);
                if (FAILED(hr))
                    return hr;
    
                iSymIndex = GetSymbolIndex(pi[i].pszName);
            }

            if (iSymIndex > -1)
                iEnumPropNum = _Symbols[iSymIndex].sTypeNum;
            else
                iEnumPropNum = -1;

        }
        else if (pi[i].bPrimVal == TMT_ENUMVAL)
        {
            ENUMVAL enumval;
            enumval.csName = pi[i].pszName;
            enumval.iSymbolIndex = iEnumPropNum;
            enumval.iValue = pi[i].sEnumVal;

            _EnumVals.Add(enumval);
        }
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseDocSection()
{
    _scan.ForceNextLine();        // get line after section line

    //---- just skip over all lines in this section ----
    while (1)
    {
        WCHAR szNameBuff[_MAX_PATH+1];

        if (_scan.GetChar('['))         // start of new section
            break;

        if (! _scan.GetId(szNameBuff))
            return SourceError(PARSER_IDS_EXPECTED_PROP_NAME);

        if (! _scan.GetChar('='))
            return SourceError(PARSER_IDS_EXPECTED_EQUALS_SIGN);

        int cnt = _Symbols.GetSize();

        for (int i=0; i < cnt; i++)
        {
            if (AsciiStrCmpI(_Symbols[i].csName, szNameBuff)==0)
                break;
        }

        int symtype;

        if (i == cnt)
            symtype = TMT_STRING;     // unknown string property
        else
            symtype = _Symbols[i].sTypeNum;

        HRESULT hr;

        //---- check to see if caller is querying for a doc property ----
        if ((_dwParseFlags & PTF_QUERY_DOCPROPERTY) && (lstrcmpi(_pszDocProperty, szNameBuff)==0))
            hr = ParseStringValue(symtype, _pszResult, _dwMaxResultChars);
        else
            hr = ParseStringValue(symtype);
    
        if (FAILED(hr))
            return hr;

        _scan.ForceNextLine();
    }

    //---- done with [documentation] section - turn off callback flag for properties ----
    _dwParseFlags &= (~PTF_CALLBACK_DOCPROPERTIES);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseClassSectionName(LPCWSTR pszFirstName, LPWSTR szAppSym, ULONG cchAppSym)
{
    //---- validate section name ----
    //
    // optional:    szAppSym::
    //              _szClassName
    // optional:    .partsym

    WCHAR szPartSym[_MAX_PATH+1];
    WCHAR szStateSym[_MAX_PATH+1];

    *szAppSym = 0;
    *szPartSym = 0;

    _iPartId = -1;
    _iStateId = -1;

    //---- copy the section name for callbacks ----
    StringCchPrintfW(_szFullSectionName, ARRAYSIZE(_szFullSectionName), L"%s%s", pszFirstName, _scan._p);
    WCHAR *p = wcschr(_szFullSectionName, ']');
    if (p)
        *p = 0;

    HRESULT hr;
    hr = SafeStringCchCopyW(_szClassName, ARRAYSIZE(_szClassName), pszFirstName);
    if (FAILED(hr))
        return hr;

    if (_scan.GetChar(':'))
    {
        hr = SafeStringCchCopyW(szAppSym, cchAppSym, _szClassName);
        if (FAILED(hr))
            return hr;

        if (! _scan.GetChar(':'))
            return SourceError(PARSER_IDS_EXPECTED_DOUBLE_COLON);
        
        if (! _scan.GetId(_szClassName))
            return SourceError(PARSER_IDS_MISSING_SECT_HDR_NAME);
    }
    else 
        *szAppSym = 0;

    _fDefiningMetrics = (AsciiStrCmpI(_szClassName, L"SysMetrics")==0);

    if ((_fDefiningMetrics) && (*szAppSym))
        return SourceError(PARSER_IDS_NOT_ALLOWED_SYSMETRICS);

    if (_scan.GetChar('.'))      // an optional part id
    {
        //---- ensure a enum exists: <classname>Parts ----
        WCHAR classparts[_MAX_PATH+1];
        StringCchPrintfW(classparts, ARRAYSIZE(classparts), L"%sParts", _szClassName);

        int iSymIndex = GetSymbolIndex(classparts);
        if (iSymIndex == -1)        // doesn't exist
            return SourceError(PARSER_IDS_PARTS_NOT_DEFINED, _szClassName);

        //---- _scan the part name ----
        if (! _scan.GetId(szPartSym))
            return SourceError(PARSER_IDS_MISSING_SECT_HDR_PART);

        //---- validate that it is a value for the <classname>Parts ----
        hr = ValidateEnumSymbol(szPartSym, iSymIndex, &_iPartId);
        if (FAILED(hr))
            return hr;
    }

    if (_scan.GetChar('('))      // an optional state
    {
        //---- ensure a enum exists: <class or part name>States ----
        WCHAR statesname[_MAX_PATH+1];
        WCHAR *pszBaseName;

        if (_iPartId == -1)
            pszBaseName = _szClassName;
        else
            pszBaseName = szPartSym;

        StringCchPrintfW(statesname, ARRAYSIZE(statesname), L"%sStates", pszBaseName);

        int iSymIndex = GetSymbolIndex(statesname);
        if (iSymIndex == -1)
            return SourceError(PARSER_IDS_STATES_NOT_DEFINED, pszBaseName);

        if (! _scan.GetId(szStateSym))
            return SourceError(PARSER_IDS_MISSING_SECT_HDR_STATE);

        hr = ValidateEnumSymbol(szStateSym, iSymIndex, &_iStateId);
        if (FAILED(hr))
            return hr;

        if (! _scan.GetChar(')'))
            return SourceError(PARSER_IDS_EXPECTED_RPAREN);
    }

    if (_iPartId > -1)
    {
        _iPartId = _EnumVals[_iPartId].iValue;
        StringCchCopyW(_szBaseSectionName, ARRAYSIZE(_szBaseSectionName), szPartSym);
    }
    else        // not specified
    {
        StringCchCopyW(_szBaseSectionName, ARRAYSIZE(_szBaseSectionName), _szClassName);
        _iPartId = 0;
    }

    if (_iStateId > -1)
        _iStateId = _EnumVals[_iStateId].iValue;
    else
        _iStateId = 0;
    
    if (! _scan.GetChar(']'))
        return SourceError(PARSER_IDS_EXPECTED_END_OF_SECTION);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ValidateEnumSymbol(LPCWSTR pszName, int iSymType,
     int *pIndex)
{
    for (int i = 0; i < _EnumVals.m_nSize; i++)
    {
        if (AsciiStrCmpI(_EnumVals.m_aT[i].csName, pszName)==0)
        {
            if (_EnumVals.m_aT[i].iSymbolIndex == iSymType)
            {
                if (pIndex)
                    *pIndex = i;
                return S_OK;
            }
        }
    }

    return SourceError(PARSER_IDS_NOT_ENUM_VALNAME, pszName, (LPCWSTR)_Symbols[iSymType].csName);
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::AddThemeData(int iTypeNum, PRIMVAL ePrimVal, 
   const void *pData, DWORD dwLen)
{
    //Log("AddThemeData: typenum=%d, len=%d, data=0x%x", iTypeNum, dwLen, pData);

    if (! _pCallBackObj)
        return S_FALSE;

    HRESULT hr = _pCallBackObj->AddData((SHORT)iTypeNum, ePrimVal, pData, dwLen);
    if (FAILED(hr))
        return SourceError(PARSER_IDS_THEME_TOO_BIG);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseEnumValue(int iSymType)
{
    WCHAR valbuff[_MAX_PATH+1];
    HRESULT hr;
    int value;

    if (! _scan.GetId(valbuff))
        return SourceError(PARSER_IDS_ENUM_VALNAME_EXPECTED);

    int index;
    hr = ValidateEnumSymbol(valbuff, iSymType, &index);
    if (FAILED(hr))
        return hr;

    value = _EnumVals[index].iValue;

    hr = AddThemeData(iSymType, TMT_ENUM, &value, sizeof(value));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseStringValue(int iSymType, LPWSTR pszBuff, DWORD cchBuff)
{
    HRESULT hr;

    //---- just store the raw string ----
    _scan.SkipSpaces();

    if (_fDefiningMetrics)        
    {
        if ((iSymType < TMT_FIRSTSTRING) || (iSymType > TMT_LASTSTRING))
            return SourceError(PARSER_IDS_NOT_ALLOWED_SYSMETRICS);   
    }

    if (pszBuff)           // special call
    {
        hr = SafeStringCchCopyW(pszBuff, cchBuff, _scan._p);
        if (FAILED(hr))
            return hr;
    }
    else
    {
        int len = 1 + lstrlen(_scan._p);

        hr = AddThemeData(iSymType, TMT_STRING, _scan._p, len*sizeof(WCHAR));
        if (FAILED(hr))
            return hr;
    }

    if ((iSymType >= TMT_FIRST_RCSTRING_NAME) && (iSymType <= TMT_LAST_RCSTRING_NAME))
    {
        if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_DOCPROPERTIES))
        {
            int index = iSymType - TMT_FIRST_RCSTRING_NAME;

            BOOL fContinue = (*_pNameCallBack)(TCB_DOCPROPERTY, _scan._p, NULL, 
                NULL, index, _lNameParam);

            if (! fContinue)
                return MakeErrorParserLast();
        }
    }

    //---- advance _scanner to end of line ----
    _scan._p += lstrlen(_scan._p);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseIntValue(int iSymType, int *piValue)
{
    int value;
    if (! _scan.GetNumber(&value))
        return SourceError(PARSER_IDS_INT_EXPECTED);

    if (piValue)        // special call
        *piValue = value;
    else
    {
        HRESULT hr = AddThemeData(iSymType, TMT_INT, &value, sizeof(value));
        if (FAILED(hr))
            return hr;
    }

    if (iSymType == TMT_CHARSET)
    {
        if (_iFontNumber)
            return SourceError(PARSER_IDS_CHARSETFIRST);

        if (_fGlobalsDefined)
            return SourceError(PARSER_IDS_CHARSET_GLOBALS_ONLY);

        _uCharSet = (UCHAR) value;
    }

    if (iSymType == TMT_MINCOLORDEPTH)
    {
        if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_MINCOLORDEPTH))
        {
            BOOL fContinue = (*_pNameCallBack)(TCB_MINCOLORDEPTH, _scan._szFileName, NULL, 
                NULL, value, _lNameParam);

            if (! fContinue)
                return MakeErrorParserLast();
        }
    }
        
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseBoolValue(int iSymType, LPCWSTR pszPropertyName)
{
    WCHAR valbuff[_MAX_PATH+1];
    BYTE bBoolVal;

    if (! _scan.GetId(valbuff))
        return SourceError(PARSER_IDS_BOOL_EXPECTED);

    if (AsciiStrCmpI(valbuff, L"true")==0)
        bBoolVal = 1;
    else if (AsciiStrCmpI(valbuff, L"false")==0)
        bBoolVal = 0;
    else
        return SourceError(PARSER_IDS_EXPECTED_TRUE_OR_FALSE);

    if (_fDefiningMetrics)        
    {
        if ((iSymType < TMT_FIRSTBOOL) || (iSymType > TMT_LASTBOOL))
            return SourceError(PARSER_IDS_NOT_ALLOWED_SYSMETRICS);     
    }

    //---- special handling for "MirrorImage" property ----
    if (iSymType == TMT_MIRRORIMAGE)
    {
        //---- handle MirrorImage callbacks (packtime) ----
        if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_LOCALIZATIONS))
        {
            BOOL fContinue = (*_pNameCallBack)(TCB_MIRRORIMAGE, _szClassName, 
                _szFullSectionName, pszPropertyName, _iPartId, (LPARAM)bBoolVal);

            if (! fContinue)
                return MakeErrorParserLast();
        }

        //---- handle getting value from string table (loadtime) ----
        if (_fUsingResourceProperties)        // substitute resource value
        {
            WCHAR szValue[MAX_PATH];

            HRESULT hr = GetResourceProperty(pszPropertyName, szValue, ARRAYSIZE(szValue));
            if (SUCCEEDED(hr))
            {
                bBoolVal = (*szValue == '1');
            }
            else
            {
                hr = S_OK;      // non-fatal error
            }
        }
    }

    HRESULT hr = AddThemeData(iSymType, TMT_BOOL, &bBoolVal, sizeof(bBoolVal));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
COLORREF CThemeParser::ApplyColorSubstitution(COLORREF crOld)
{
    //---- apply SOLID color substitutions ----
    for (int i=0; i < _iColorCount; i++)
    {
        if (crOld == _crFromColors[i])
            return _crToColors[i];
    }

    //---- apply HUE color substitutions ----
    WORD wHue, wLum, wSat;
    RGBtoHLS(crOld, &wHue, &wLum, &wSat);

    for (i=0; i < _iHueCount; i++)
    {
        if (wHue == _bFromHues[i])      // hues match
        {
            COLORREF crNew = HLStoRGB(_bToHues[i], wLum, wSat);  // substitute new hue
            return crNew;
        }
    }

    return crOld;
}
//---------------------------------------------------------------------------
void CThemeParser::CleanupStockBitmaps()
{
    if (s_pfnClearBitmapAttributes)
    {
        for (int i=0; i < _StockBitmapCleanupList.m_nSize; i++)
        {
            HBITMAP hbm = (*s_pfnClearBitmapAttributes)(_StockBitmapCleanupList[i], SBA_STOCK);
            if (hbm)
            {
                DeleteObject(hbm);
            }
            else
            {
                // We are totally out of luck today aren't we
                Log(LOG_TMBITMAP, L"Failed to clear stock bitmap on cleanup");
            }
        }
    }

    _StockBitmapCleanupList.RemoveAll();
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseColorValue(int iSymType, COLORREF *pcrValue, COLORREF *pcrValue2)
{
    COLORREF color;
    HRESULT hr = S_OK;

    {
        const WCHAR *parts[] = {L"r", L"g", L"b"};
        int ints[3] = {0};
        
        hr = GetIntList(ints, parts, ARRAYSIZE(ints), 0, 255);
        if (FAILED(hr))
        {
            hr = SourceError(PARSER_IDS_BAD_COLOR_VALUE);
            goto exit;
        }

        color = RGB(ints[0], ints[1], ints[2]);
    }

    if (! _fDefiningColorScheme)     
        color = ApplyColorSubstitution(color);

    if (_fDefiningMetrics)
    {
        if ((iSymType < TMT_FIRSTCOLOR) || (iSymType > TMT_LASTCOLOR))
        {
            hr = SourceError(PARSER_IDS_NOT_ALLOWED_SYSMETRICS);     
            goto exit;
        }
    }

    if (pcrValue2)
    {
        *pcrValue2 = color;
    }

    if (pcrValue)       // special call
        *pcrValue = color;
    else
    {
        hr = AddThemeData(iSymType, TMT_COLOR, &color, sizeof(color));
        if (FAILED(hr))
            goto exit;
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseMarginsValue(int iSymType)
{
    const WCHAR *parts[] = {L"lw", L"rw", L"th", L"bh"};
    int ints[4];

    HRESULT hr = GetIntList(ints, parts, ARRAYSIZE(ints), 0, 0);
    if (FAILED(hr))
        return SourceError(PARSER_IDS_BAD_MARGINS_VALUE);

    hr = AddThemeData(iSymType, TMT_MARGINS, ints, sizeof(ints));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseIntListValue(int iSymType)
{
    INTLIST IntList;
    HRESULT hr = S_OK;

    //---- unnamed parts ----
    for (int i=0; i < MAX_INTLIST_COUNT; i++)
    {
        if (! _scan.GetNumber(&IntList.iValues[i]))
        {
            if (_scan.EndOfLine())
                break;
         
            hr = SourceError(PARSER_IDS_NUMBER_EXPECTED, _scan._p);
            goto exit;
        }

        _scan.GetChar(',');      // optional comma
    }

    IntList.iValueCount = i;

    hr = AddThemeData(iSymType, TMT_INTLIST, &IntList, (1+i)*sizeof(int));
    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::PackageImageData(LPCWSTR szFileNameR, LPCWSTR szFileNameG, LPCWSTR szFileNameB, int iDibPropNum)
{
    HRESULT hr = S_OK;

    //---- add TMT_DIBDATA data ----
    WCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], fname[_MAX_FNAME], ext[_MAX_EXT];

    // The filename was parsed and validated before, so we're sure it's not longer than _MAX_PATH
    _wsplitpath(szFileNameR, drive, dir, fname, ext);
    WCHAR szResName[_MAX_PATH+1];
    DWORD len = lstrlen(dir);
    
    if ((len) && (dir[len-1] == L'\\'))
    {
        dir[len-1] = L'_';
    }
    StringCchPrintfW(szResName, ARRAYSIZE(szResName), L"%s%s_BMP", dir, fname);
    HBITMAP hBitmapR = (HBITMAP) LoadImage(_hinstThemeDll, szResName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

    if (!hBitmapR)
        return SourceError(PARSER_IDS_NOOPEN_IMAGE, szResName);

    //---- convert to DIBDATA ----
    CBitmapPixels pixels;
    DWORD *pPixelQuads;
    int iWidth, iHeight, iBytesPerPixel, iBytesPerRow, iPreviousBytesPerPixel;

    BOOL fUseDrawStream = TRUE;

    // Allocate a TMBITMAPHEADER in addition to the bitmap
    hr = pixels.OpenBitmap(NULL, hBitmapR, TRUE, &pPixelQuads, &iWidth, &iHeight, &iBytesPerPixel, 
        &iBytesPerRow, &iPreviousBytesPerPixel, TMBITMAPSIZE);
    if (FAILED(hr))
    {
        DeleteObject(hBitmapR);
        return hr;
    }

    BOOL fWasAlpha = (iPreviousBytesPerPixel == 4);

#if 0
    //---- apply loaded color scheme, if any ----
    if ((szFileNameG && szFileNameG[0]) && (szFileNameB && szFileNameB[0]))
    {
        _wsplitpath(szFileNameG, drive, dir, fname, ext);
        len = lstrlen(dir);
    
        if ((len) && (dir[len-1] == L'\\'))
        {
            dir[len-1] = L'_';
        }
        StringCchPrintfW(szResName, ARRAYSIZE(szResName), L"%s%s_BMP", dir, fname);
        HBITMAP hBitmapG = (HBITMAP) LoadImage(_hinstThemeDll, szResName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

        _wsplitpath(szFileNameB, drive, dir, fname, ext);
        len = lstrlen(dir);
    
        if ((len) && (dir[len-1] == L'\\'))
        {
            dir[len-1] = L'_';
        }
        StringCchPrintfW(szResName, ARRAYSIZE(szResName), L"%s%s_BMP", dir, fname);
        HBITMAP hBitmapB = (HBITMAP) LoadImage(_hinstThemeDll, szResName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

        DWORD dwRWeight = GetRValue(_crBlend);
        DWORD dwGWeight = GetGValue(_crBlend);
        DWORD dwBWeight = GetBValue(_crBlend);

        DWORD *pPixelQuadsG = NULL;
        DWORD *pPixelQuadsB = NULL;
        if (hBitmapG && hBitmapB)
        {
            HDC hdc = GetDC(NULL);
            if (hdc)
            {
                int dwLen = iWidth * iHeight;

                pPixelQuadsG = new DWORD[dwLen];
                if (pPixelQuadsG)
                {
                    pPixelQuadsB = new DWORD[dwLen];
                    if (pPixelQuadsB)
                    {
                        BITMAPINFO bi = {0};
                        bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                        bi.bmiHeader.biWidth = iWidth;
                        bi.bmiHeader.biHeight = iHeight;
                        bi.bmiHeader.biPlanes = 1;
                        bi.bmiHeader.biBitCount = 32;
                        bi.bmiHeader.biCompression = BI_RGB;

                        if (GetDIBits(hdc, hBitmapG, 0, iHeight, pPixelQuadsG, &bi, DIB_RGB_COLORS) &&
                            GetDIBits(hdc, hBitmapB, 0, iHeight, pPixelQuadsB, &bi, DIB_RGB_COLORS))
                        {
                            DWORD* pdwR = pPixelQuads;
                            DWORD* pdwG = pPixelQuadsG;
                            DWORD* pdwB = pPixelQuadsB;
                            for (int i = 0; i < dwLen; i++)
                            {
                                if ((*pdwR & 0xffffff) != RGB(255,0,255))
                                {
                                    *pdwR = (*pdwR & 0xff000000) |
                                            RGB(min(((GetRValue(*pdwR) * dwRWeight) + (GetRValue(*pdwG) * dwGWeight) + (GetRValue(*pdwB) * dwBWeight)) >> 8, 0xff),
                                                min(((GetGValue(*pdwR) * dwRWeight) + (GetGValue(*pdwG) * dwGWeight) + (GetGValue(*pdwB) * dwBWeight)) >> 8, 0xff),
                                                min(((GetBValue(*pdwR) * dwRWeight) + (GetBValue(*pdwG) * dwGWeight) + (GetBValue(*pdwB) * dwBWeight)) >> 8, 0xff));
                                }
                                pdwR++;
                                pdwG++;
                                pdwB++;
                            }
                        }

                        delete[] pPixelQuadsB;
                    }
                    delete[] pPixelQuadsG;
                }
                ReleaseDC(NULL, hdc);
            }
        }
        else
        {
            OutputDebugString(L"Failed to load bitmaps");
        }

        if (hBitmapG)
        {
            DeleteObject(hBitmapG);
            hBitmapG = NULL;
        }

        if (hBitmapB)
        {
            DeleteObject(hBitmapB);
            hBitmapB = NULL;
        }
    }
#endif

    BITMAPINFOHEADER *pBitmapHdr = pixels._hdrBitmap;


    //---- if alpha present, pre-multiply RGB values (as per AlphaBlend()) API ----
    BOOL fTrueAlpha = FALSE;

    // We keep per-pixel alpha bitmaps as 32 bits DIBs, not compatible bitmaps 
    if (fWasAlpha) 
    {
        fTrueAlpha = (PreMultiplyAlpha(pPixelQuads, pBitmapHdr->biWidth, pBitmapHdr->biHeight) != 0);
#ifdef DEBUG            
        if (!fTrueAlpha)
            Log(LOG_TMBITMAP, L"%s is 32 bits, but not true alpha", szFileNameR);
#endif
    }
    
    HBITMAP hbmStock = NULL;
    BOOL fFlipped = FALSE;

    if (fUseDrawStream && _fGlobalTheme)
    {
        HDC hdc = ::GetWindowDC(NULL);

        if (hdc)
        {
            typedef struct {
                BITMAPINFOHEADER    bmih;
                ULONG               masks[3];
            } BITMAPHEADER;
            
            BITMAPHEADER bmi;

            bmi.bmih.biSize = sizeof(bmi.bmih);
            bmi.bmih.biWidth = pBitmapHdr->biWidth;
            bmi.bmih.biHeight = pBitmapHdr->biHeight;
            bmi.bmih.biPlanes = 1;
            bmi.bmih.biBitCount = 32;
            bmi.bmih.biCompression = BI_BITFIELDS;
            bmi.bmih.biSizeImage = 0;
            bmi.bmih.biXPelsPerMeter = 0;
            bmi.bmih.biYPelsPerMeter = 0;
            bmi.bmih.biClrUsed = 3;
            bmi.bmih.biClrImportant = 0;
            bmi.masks[0] = 0xff0000;    // red
            bmi.masks[1] = 0x00ff00;    // green
            bmi.masks[2] = 0x0000ff;    // blue

            hbmStock = CreateDIBitmap(hdc, &bmi.bmih, CBM_INIT |  CBM_CREATEDIB , pPixelQuads, (BITMAPINFO*)&bmi.bmih, DIB_RGB_COLORS);

            // Need to Force 32-bit DIBs in Multi-mon mode
            // Make it match the screen resolution setting if it is not an AlphaBlended image

            ::ReleaseDC(NULL, hdc);
        }

        if (!hbmStock)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            ASSERT(s_pfnSetBitmapAttributes != NULL);
            ASSERT(s_pfnClearBitmapAttributes != NULL);

            HBITMAP hbmOld = hbmStock;
            hbmStock = (*s_pfnSetBitmapAttributes)(hbmStock, SBA_STOCK); 

            if (hbmStock == NULL)
            {
                DeleteObject(hbmOld);
                Log(LOG_ALWAYS, L"UxTheme: SetBitmapAttributes failed in CParser::PackageImageData");

                hr = E_FAIL;
            } 
            else
            {
                _StockBitmapCleanupList.Add(hbmStock);
            }
        }
    } 

    ::DeleteObject(hBitmapR);

    // Fill in the TMBITMAPHEADER structure
    if (SUCCEEDED(hr))
    {
        TMBITMAPHEADER *psbh = (TMBITMAPHEADER*) pixels.Buffer();

        psbh->dwSize = TMBITMAPSIZE;
        psbh->fFlipped = fFlipped;
        psbh->hBitmap = hbmStock;
        psbh->fTrueAlpha = fTrueAlpha;
        psbh->dwColorDepth = iBytesPerPixel * 8;

        if (hbmStock == NULL) // Pass DIB bits
        {
            int size = psbh->dwSize + sizeof(BITMAPINFOHEADER) + iHeight * iBytesPerRow;
            hr = AddThemeData(iDibPropNum, TMT_DIBDATA, psbh, size);
        } 
        else // Pass the TMBITMAPHEADER structure only
        {
            hr = AddThemeData(iDibPropNum, TMT_DIBDATA, psbh, psbh->dwSize);
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseFileNameValue(int iSymType, LPWSTR pszBuff, DWORD cchBuff)
{
    WCHAR szFileNameR[_MAX_PATH+1] = {0};
    WCHAR szFileNameG[_MAX_PATH+1] = {0};
    WCHAR szFileNameB[_MAX_PATH+1] = {0};
    HRESULT hr = S_OK;

    if (! _scan.GetFileName(szFileNameR, ARRAYSIZE(szFileNameR)))
    {
        hr = SourceError(PARSER_IDS_ENUM_VALNAME_EXPECTED);
        goto exit;
    }

    if (_scan.GetFileName(szFileNameG, ARRAYSIZE(szFileNameG)))
    {
        _scan.GetFileName(szFileNameB, ARRAYSIZE(szFileNameB));
    }

    if (pszBuff)        // special call
    {
        hr = SafeStringCchCopyW(pszBuff, cchBuff, szFileNameR);
        if (FAILED(hr))
            goto exit;
    }
    else if (_pCallBackObj)         // emit data
    {
        //---- add TMT_FILENAME data ----
        hr = AddThemeData(iSymType, TMT_FILENAME, &szFileNameR, sizeof(WCHAR)*(1+lstrlen(szFileNameR)));
        if (FAILED(hr))
            goto exit;
        if ((szFileNameG[0] != 0) && (szFileNameB[0] != 0))
        {
            hr = AddThemeData(iSymType, TMT_FILENAME, &szFileNameG, sizeof(WCHAR)*(1+lstrlen(szFileNameR)));
            if (FAILED(hr))
                goto exit;
            hr = AddThemeData(iSymType, TMT_FILENAME, &szFileNameB, sizeof(WCHAR)*(1+lstrlen(szFileNameR)));
            if (FAILED(hr))
                goto exit;
        }

        if (iSymType == TMT_IMAGEFILE)
        {
            hr = PackageImageData(szFileNameR, szFileNameG, szFileNameB, TMT_DIBDATA);
        }
        else if (iSymType == TMT_GLYPHIMAGEFILE)
        {
            hr = PackageImageData(szFileNameR, szFileNameG, szFileNameB, TMT_GLYPHDIBDATA);
        }
        else if (iSymType == TMT_STOCKIMAGEFILE)
        {
            hr = PackageImageData(szFileNameR, szFileNameG, szFileNameB, TMT_STOCKDIBDATA);
        }
        else if ((iSymType >= TMT_IMAGEFILE1) && (iSymType <= TMT_IMAGEFILE5))
        {
            hr = PackageImageData(szFileNameR, szFileNameG, szFileNameB, TMT_DIBDATA1 + (iSymType-TMT_IMAGEFILE1));
        }

        if (FAILED(hr))
            goto exit;
    }

    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_FILENAMES))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_FILENAME, szFileNameR, NULL, NULL, iSymType, _lNameParam);
        if (! fContinue)
        {
            hr = MakeErrorParserLast();
            goto exit;
        }

        if (szFileNameG[0] && szFileNameB[0])
        {
            fContinue = (*_pNameCallBack)(TCB_FILENAME, szFileNameG, NULL, NULL, iSymType, _lNameParam);
            if (! fContinue)
            {
                hr = MakeErrorParserLast();
                goto exit;
            }
            fContinue = (*_pNameCallBack)(TCB_FILENAME, szFileNameB, NULL, NULL, iSymType, _lNameParam);
            if (! fContinue)
            {
                hr = MakeErrorParserLast();
                goto exit;
            }
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseSizeValue(int iSymType)
{
    int val;
    if (! _scan.GetNumber(&val))   
        return SourceError(PARSER_IDS_INT_EXPECTED);

    int pixels;

    HRESULT hr = ParseSizeInfoUnits(val, L"pixels", &pixels);
    if (FAILED(hr))
        return hr;

    if (_fDefiningMetrics)        
    {
        if ((iSymType < TMT_FIRSTSIZE) || (iSymType > TMT_LASTSIZE))
            return SourceError(PARSER_IDS_NOT_ALLOWED_SYSMETRICS);  
    }

    hr = AddThemeData(iSymType, TMT_SIZE, &pixels, sizeof(pixels));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParsePositionValue(int iSymType)
{
    const WCHAR *parts[] = {L"x", L"y"};
    int ints[2];

    HRESULT hr = GetIntList(ints, parts, ARRAYSIZE(ints), 0, 0);
    if (FAILED(hr))
        return SourceError(PARSER_IDS_ILLEGAL_SIZE_VALUE);

    hr = AddThemeData(iSymType, TMT_POSITION, ints, sizeof(ints));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseRectValue(int iSymType, LPCWSTR pszPropertyName)
{
    const WCHAR *parts[] = {L"l", L"t", L"r", L"b"};
    LONG  rgl[4];

    HRESULT hr = GetIntList((int*)rgl, parts, ARRAYSIZE(rgl), 0, 0);
    if (FAILED(hr))
        return SourceError(PARSER_IDS_ILLEGAL_RECT_VALUE);

    //---- special handling for localizable RECT properties ----
    if (iSymType == TMT_DEFAULTPANESIZE)
    {
        //---- handle localizable callback (packtime) ----
        if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_LOCALIZATIONS))
        {
            BOOL fContinue = (*_pNameCallBack)(TCB_LOCALIZABLE_RECT, _szClassName, 
                _szFullSectionName, pszPropertyName, _iPartId, (LPARAM)(RECT *)rgl);

            if (! fContinue)
                return MakeErrorParserLast();
        }

        //---- handle getting value from string table (loadtime) ----
        if (_fUsingResourceProperties)        // substitute resource value
        {
            WCHAR szValue[MAX_PATH];

            HRESULT hr = GetResourceProperty(pszPropertyName, szValue, ARRAYSIZE(szValue));
            if (SUCCEEDED(hr))
            {
                RECT rc;

                int cnt = swscanf(szValue, L"%d, %d, %d, %d", 
                    &rc.left, &rc.top, &rc.right, &rc.bottom);

                if (cnt == 4)
                {
                    //---- override with localized values ----
                    CopyMemory(rgl, &rc, sizeof(rgl));
                }

            }
            else
            {
                hr = S_OK;      // non-fatal error
            }
        }
    }

    hr = AddThemeData(iSymType, TMT_RECT, rgl, sizeof(rgl));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseSizeInfoUnits(int iVal, LPCWSTR pszDefaultUnits, int *piPixels)
{
    WCHAR szUnits[_MAX_PATH+1];
    HRESULT hr;

    //---- NOTE: this uses the THEME_DPI (96) for all size conversions! ----
    //---- this gives us consistent LOGFONT, etc. across diff. resolution screens ----
    //---- with the promise that we will do just-in-time DPI scaling, when appropriate ----

    if (! _scan.GetId(szUnits))
    {
        hr = SafeStringCchCopyW(szUnits, ARRAYSIZE(szUnits), pszDefaultUnits);
        if (FAILED(hr))
            return hr;
    }

    if (AsciiStrCmpI(szUnits, L"pixels")==0)
        ;       // already correct
    else if (AsciiStrCmpI(szUnits, L"twips")==0)
    {
        iVal = -MulDiv(iVal, THEME_DPI, 20*72);  
    }
    else if (AsciiStrCmpI(szUnits, L"points")==0)
    {
        iVal = -MulDiv(iVal, THEME_DPI, 72);  
    }
    else
        return SourceError(PARSER_IDS_UNKNOWN_SIZE_UNITS, szUnits);

    *piPixels = iVal;
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseFontValue(int iSymType, LPCWSTR pszPropertyName)
{
    LOGFONT font;
    WCHAR szLineBuff[_MAX_PATH+1];
    HRESULT hr;

    _scan.SkipSpaces();     // trim leading blanks

    memset(&font, 0, sizeof(font));
    font.lfWeight = FW_NORMAL;
    font.lfCharSet = _uCharSet;

    _iFontNumber++;
    BOOL fGotFont = FALSE;

    if (_fUsingResourceProperties)        // substitute resource font string
    {
        hr = GetResourceProperty(pszPropertyName, szLineBuff, ARRAYSIZE(szLineBuff));
        if (SUCCEEDED(hr))
        {
            fGotFont = TRUE;
        }
        else
        {
            hr = S_OK;
        }
    }

    if (! fGotFont)
    {
        //---- copy font specs from scanner ----
        hr = SafeStringCchCopyW(szLineBuff, ARRAYSIZE(szLineBuff), _scan._p);
        if (FAILED(hr))
            return hr;
    }

    //---- handle font callback ----
    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_LOCALIZATIONS))
    {
        WCHAR *p = szLineBuff;
        while (IsSpace(*p))
                p++;

        BOOL fContinue = (*_pNameCallBack)(TCB_FONT, p, _szFullSectionName, 
            pszPropertyName, 0, _lNameParam);
        if (! fContinue)
            return MakeErrorParserLast();
    }

    //---- family name is required and must be first ----
    WCHAR *p;
    p = wcschr(szLineBuff, ',');
    if (! p)            // whole line is family name
    {
        hr = StringCchCopyW(font.lfFaceName, ARRAYSIZE(font.lfFaceName), szLineBuff);   
        return hr;
    }

    *p++ = 0;
    hr = StringCchCopyW(font.lfFaceName, ARRAYSIZE(font.lfFaceName), szLineBuff);
    if (FAILED(hr))
        return hr;

    _scan._p = p;

    int val;
    if (_scan.GetNumber(&val))       // font size
    {
        int pixels;

        hr = ParseSizeInfoUnits(val, L"points", &pixels);
        if (FAILED(hr))
            return hr;

        font.lfHeight = pixels;

        _scan.GetChar(',');      // optional comma
    }

    WCHAR flagname[_MAX_PATH+1];

    while (_scan.GetId(flagname))
    {
        if (AsciiStrCmpI(flagname, L"bold")==0)
            font.lfWeight = FW_BOLD;
        else if (AsciiStrCmpI(flagname, L"italic")==0)
            font.lfItalic = TRUE;
        else if (AsciiStrCmpI(flagname, L"underline")==0)
            font.lfUnderline = TRUE;
        else if (AsciiStrCmpI(flagname, L"strikeout")==0)
            font.lfStrikeOut = TRUE;
        else
            return SourceError(PARSER_IDS_UNKNOWN_FONT_FLAG, flagname);
    }

// addit:

    if (_fDefiningMetrics)        
    {
        if ((iSymType < TMT_FIRSTFONT) || (iSymType > TMT_LASTFONT))
            return SourceError(PARSER_IDS_NOT_ALLOWED_SYSMETRICS);     
    }

    hr = AddThemeData(iSymType, TMT_FONT, &font, sizeof(font));
    if (FAILED(hr))
        return hr;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseClassLine(int *piSymType, int *piValue, LPWSTR pszBuff, DWORD cchBuff)
{
    WCHAR szNameBuff[_MAX_PATH+1];
    WCHAR szSymbol[MAX_INPUT_LINE+1];

    if (! _scan.GetId(szNameBuff))
        return SourceError(PARSER_IDS_EXPECTED_PROP_NAME);

    if (! _scan.GetChar('='))
        return SourceError(PARSER_IDS_EXPECTED_EQUALS_SIGN);

    int cnt = _Symbols.GetSize();

    for (int i=0; i < cnt; i++)
    {
        if (AsciiStrCmpI(_Symbols[i].csName, szNameBuff)==0)
            break;
    }

    if (i == cnt)
        return SourceError(PARSER_IDS_UNKNOWN_PROP, szNameBuff);

    int symtype = _Symbols[i].sTypeNum;
    
    HRESULT hr;

    // Handle substituted symbols
    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTSYMBOLS))
    {
        if (wcschr(_scan._p, INI_MACRO_SYMBOL)) 
        {
            // Pass ##
            if (_scan.GetChar(INI_MACRO_SYMBOL) &&
                _scan.GetChar(INI_MACRO_SYMBOL))
            {
                WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBaseName[_MAX_FNAME], szExt[_MAX_EXT];

                _wsplitpath(_scan._szFileName, szDrive, szDir, szBaseName, szExt);

                BOOL fContinue = (*_pNameCallBack)(TCB_NEEDSUBST, szBaseName, _scan._p, szSymbol, 
                    0, _lNameParam);
                if (! fContinue)
                    return MakeErrorParserLast();

                _scan.UseSymbol(szSymbol);
            }
        }
    }

    switch (_Symbols[i].ePrimVal)
    {
        case TMT_ENUM:
            hr = ParseEnumValue(symtype);
            break;
            
        case TMT_STRING:
            hr = ParseStringValue(symtype, pszBuff, cchBuff);
            break;

        case TMT_INT:
            hr = ParseIntValue(symtype, piValue);
            break;

        case TMT_INTLIST:
            hr = ParseIntListValue(symtype);
            break;

        case TMT_BOOL:
            hr = ParseBoolValue(symtype, szNameBuff);
            break;

        case TMT_COLOR:
            {
                COLORREF cr;
                hr = ParseColorValue(symtype, (COLORREF *)piValue, &cr);
                if (SUCCEEDED(hr))
                {
                    if (lstrcmpi(_Symbols[i].csName, L"BLENDCOLOR") == 0)
                    {
                        _crBlend = cr;
                    }
                }
            }
            break;

        case TMT_MARGINS:
            hr = ParseMarginsValue(symtype);
            break;

        case TMT_FILENAME:
            hr = ParseFileNameValue(symtype, pszBuff, cchBuff);
            break;

        case TMT_SIZE:
            hr = ParseSizeValue(symtype);
            break;

        case TMT_POSITION:
            hr = ParsePositionValue(symtype);
            break;

        case TMT_RECT:
            hr = ParseRectValue(symtype, szNameBuff);
            break;

        case TMT_FONT:
            hr = ParseFontValue(symtype, szNameBuff);
            break;

        default:
            hr = E_FAIL;
            break;
    }

    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTSYMBOLS))
    {
        _scan.UseSymbol(NULL);
    }

    *_szResPropValue = 0;       // not yet set

    if (FAILED(hr))
        return hr;

    if (piSymType)              // special call
        *piSymType = symtype;

    if (! _scan.EndOfLine())
        return SourceError(PARSER_IDS_EXTRA_PROP_TEXT, _scan._p);

    _scan.ForceNextLine();
    
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseColorSchemeSection()
{
    HRESULT hr;
    WCHAR SchemeName[_MAX_PATH+1];
    WCHAR DisplayName[_MAX_PATH+1];
    WCHAR ToolTip[MAX_INPUT_LINE+1];    
    WCHAR szBuff[MAX_INPUT_LINE+1];

    if (! _scan.GetChar('.'))
        return SourceError(PARSER_IDS_EXPECTED_DOT_SN);

    if (! _scan.GetId(SchemeName, ARRAYSIZE(SchemeName)))
        return SourceError(PARSER_IDS_CS_NAME_EXPECTED);

    if (! _scan.GetChar(']'))
        return SourceError(PARSER_IDS_RBRACKET_EXPECTED);

    if (! _scan.EndOfLine())
        return SourceError(PARSER_IDS_END_OF_LINE_EXPECTED);

    _scan.ForceNextLine();        // get line after section line
    *ToolTip = 0;
    *DisplayName = 0;

    bool fCorrectScheme = (lstrcmpi(_ColorParam, SchemeName)==0);

    if (fCorrectScheme)     // initialize all subst. tables
    {
        hr = SafeStringCchCopyW(DisplayName, ARRAYSIZE(DisplayName), SchemeName);        // in case not specified
        if (FAILED(hr))
            return hr;


        for (int i=0; i < HUE_SUBCNT; i++)
        {
            _bFromHues[i] = 0;
            _bToHues[i] = 0;
        }

        for (i=0; i < COLOR_SUBCNT; i++)
        {
            _crFromColors[i] = 0;
            _crToColors[i] = 0;
        }
    }

    //----- put into vars to make coding/debugging easier ----
    int firstFromHue = TMT_FROMHUE1;
    int lastFromHue = TMT_FROMHUE1 + HUE_SUBCNT - 1;
    int firstToHue = TMT_TOHUE1;
    int lastToHue = TMT_TOHUE1 + HUE_SUBCNT - 1;

    int firstFromColor = TMT_FROMCOLOR1;
    int lastFromColor = TMT_FROMCOLOR1 + COLOR_SUBCNT - 1;
    int firstToColor = TMT_TOCOLOR1;
    int lastToColor = TMT_TOCOLOR1 + COLOR_SUBCNT - 1;

    while (1)       // parse each line
    {
        if (_scan.EndOfFile())
            break;

        if (_scan.GetChar('['))          // start of new section
            break;

        int iSymType, iValue;

        _fDefiningColorScheme = TRUE;

        //---- parse the COLOR or INT property line ----
        hr = ParseClassLine(&iSymType, &iValue, szBuff, ARRAYSIZE(szBuff));

        _fDefiningColorScheme = FALSE;

        if (FAILED(hr))
            return hr;

        //---- store the HUE or COLOR param in local tables ----
        if ((iSymType >= firstFromHue) && (iSymType <= lastFromHue))
        {
            if (fCorrectScheme)
                _bFromHues[iSymType-firstFromHue] = (BYTE)iValue;
        }
        else if ((iSymType >= firstToHue) && (iSymType <= lastToHue))
        {
            if (fCorrectScheme)
                _bToHues[iSymType-firstToHue] = (BYTE)iValue;
        }
        else if ((iSymType >= firstFromColor) && (iSymType <= lastFromColor))
        {
            if (fCorrectScheme)
                _crFromColors[iSymType-firstFromColor] = (COLORREF)iValue;
        }
        else if ((iSymType >= firstToColor) && (iSymType <= lastToColor))
        {
            if (fCorrectScheme)
                _crToColors[iSymType-firstToColor] = (COLORREF)iValue;
        }
        else if (iSymType == TMT_DISPLAYNAME)
        {
            hr = SafeStringCchCopyW(DisplayName, ARRAYSIZE(DisplayName), szBuff);
            if (FAILED(hr))
                return hr;
        }
        else if (iSymType == TMT_TOOLTIP)
        {
            hr = SafeStringCchCopyW(ToolTip, ARRAYSIZE(ToolTip), szBuff );
            if (FAILED(hr))
                return hr;
        }
        else
        {
            return SourceError(PARSER_IDS_ILLEGAL_CS_PROPERTY);
        }
    }

    if (fCorrectScheme)     // adjust counts
    {
        _iHueCount = HUE_SUBCNT;
        while (_iHueCount > 0)
        {
            if (_bFromHues[_iHueCount-1] == _bToHues[_iHueCount-1])
                _iHueCount--;
            else
                break;
        }

        _iColorCount = COLOR_SUBCNT;
        while (_iColorCount > 0)
        {
            if (_crFromColors[_iColorCount-1] == _crToColors[_iColorCount-1])
                _iColorCount--;
            else
                break;
        }
    }

    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_COLORSECTION))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_COLORSCHEME, SchemeName, 
            DisplayName, ToolTip, 0, _lNameParam);
        if (! fContinue)
            return MakeErrorParserLast();
    }

    // Create an empty subst table
    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTTABLE))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_SUBSTTABLE, SchemeName, 
            NULL, NULL, 0, _lNameParam);

        if (! fContinue)
            return MakeErrorParserLast();
    }
    
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseSizeSection()
{
    HRESULT hr;
    WCHAR szSizeName[_MAX_PATH+1];
    WCHAR szDisplayName[_MAX_PATH+1];
    WCHAR szToolTip[MAX_INPUT_LINE+1];    
    WCHAR szBuff[MAX_INPUT_LINE+1];

    if (! _scan.GetChar('.'))
        return SourceError(PARSER_IDS_EXPECTED_DOT_SN);

    if (! _scan.GetId(szSizeName, ARRAYSIZE(szSizeName)))
        return SourceError(PARSER_IDS_SS_NAME_EXPECTED);

    if (! _scan.GetChar(']'))
        return SourceError(PARSER_IDS_RBRACKET_EXPECTED);

    if (! _scan.EndOfLine())
        return SourceError(PARSER_IDS_END_OF_LINE_EXPECTED);

    _scan.ForceNextLine();        // get line after section line

    while (1)       // parse each line of section
    {
        if (_scan.EndOfFile())
            break;

        if (_scan.GetChar('['))          // start of new section
            break;

        int iSymType, iValue;

        //---- parse the property line ----
        hr = ParseClassLine(&iSymType, &iValue, szBuff, ARRAYSIZE(szBuff));
        if (FAILED(hr))
            return hr;

        if (iSymType == TMT_DISPLAYNAME)
        {
            hr = SafeStringCchCopyW(szDisplayName, ARRAYSIZE(szDisplayName), szBuff );
            if (FAILED(hr))
                return hr;
        }
        else if (iSymType == TMT_TOOLTIP)
        {
            hr = SafeStringCchCopyW(szToolTip, ARRAYSIZE(szToolTip), szBuff );
            if (FAILED(hr))
                return hr;
        }
        else
        {
            return SourceError(PARSER_IDS_ILLEGAL_SS_PROPERTY);
        }
    }

    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SIZESECTION))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_SIZENAME, szSizeName, 
            szDisplayName, szToolTip, 0, _lNameParam);
        if (! fContinue)
            return MakeErrorParserLast();
    }

    // Create an empty subst table
    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTTABLE))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_SUBSTTABLE, szSizeName, 
            NULL, NULL, 0, _lNameParam);

        if (! fContinue)
            return MakeErrorParserLast();
    }
    
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseFileSection()
{
    HRESULT hr;
    WCHAR szSizeName[_MAX_PATH+1];
    WCHAR szFileName[_MAX_PATH+1];
    WCHAR szColorSchemes[_MAX_PATH+1];
    WCHAR szSizes[MAX_INPUT_LINE+1];    
    WCHAR szBuff[MAX_INPUT_LINE+1];

    if (! _scan.GetChar('.'))
        return SourceError(PARSER_IDS_EXPECTED_DOT_SN);

    if (! _scan.GetId(szSizeName, ARRAYSIZE(szSizeName)))
        return SourceError(PARSER_IDS_FS_NAME_EXPECTED);

    if (! _scan.GetChar(']'))
        return SourceError(PARSER_IDS_RBRACKET_EXPECTED);

    if (! _scan.EndOfLine())
        return SourceError(PARSER_IDS_END_OF_LINE_EXPECTED);

    _scan.ForceNextLine();        // get line after section line

    while (1)       // parse each line of section
    {
        if (_scan.EndOfFile())
            break;

        if (_scan.GetChar('['))          // start of new section
            break;

        int iSymType, iValue;

        //---- parse the property line ----
        hr = ParseClassLine(&iSymType, &iValue, szBuff, ARRAYSIZE(szBuff));
        if (FAILED(hr))
            return hr;

        if (iSymType == TMT_FILENAME)
        {
            hr = StringCchCopyW(szFileName, ARRAYSIZE(szFileName), szBuff );
        }
        else if (iSymType == TMT_COLORSCHEMES)
        {
            hr = StringCchCopyW(szColorSchemes, ARRAYSIZE(szColorSchemes), szBuff );
        }
        else if (iSymType == TMT_SIZES)
        {
            hr = StringCchCopyW(szSizes, ARRAYSIZE(szSizes), szBuff );
        }
        else
        {
            return SourceError(PARSER_IDS_ILLEGAL_SS_PROPERTY);
        }

        if (FAILED(hr))
            return hr;
    }

    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_FILESECTION))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_CDFILENAME, szSizeName, 
            szFileName, NULL, 0, _lNameParam);

        if (! fContinue)
            return MakeErrorParserLast();
    
        fContinue = (*_pNameCallBack)(TCB_CDFILECOMBO, szSizeName, 
            szColorSchemes, szSizes, 0, _lNameParam);

        if (! fContinue)
            return MakeErrorParserLast();
    }
    if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTTABLE))
    {
        BOOL fContinue = (*_pNameCallBack)(TCB_SUBSTTABLE, szSizeName, 
            SUBST_TABLE_INCLUDE, szColorSchemes, 0, _lNameParam);
        if (! fContinue)
            return MakeErrorParserLast();

        fContinue = (*_pNameCallBack)(TCB_SUBSTTABLE, szSizeName, 
            SUBST_TABLE_INCLUDE, szSizes, 0, _lNameParam);

        if (! fContinue)
            return MakeErrorParserLast();
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseSubstSection()
{
    WCHAR szSubstTableName[_MAX_PATH+1];
    WCHAR szId[MAX_INPUT_LINE+1];    
    WCHAR szValue[MAX_INPUT_LINE+1];    
    BOOL  fFirst = TRUE;

    if (! _scan.GetChar('.'))
        return SourceError(PARSER_IDS_EXPECTED_DOT_SN);

    if (! _scan.GetId(szSubstTableName, ARRAYSIZE(szSubstTableName)))
        return SourceError(PARSER_IDS_FS_NAME_EXPECTED);

    if (! _scan.GetChar(']'))
        return SourceError(PARSER_IDS_RBRACKET_EXPECTED);

    if (! _scan.EndOfLine())
        return SourceError(PARSER_IDS_END_OF_LINE_EXPECTED);

    _scan.ForceNextLine();        // get line after section line

    while (1)       // parse each line of section
    {
        if (_scan.EndOfFile())
            break;

        if (_scan.GetChar('['))          // start of new section
        {
            // Call the callback once for creating the empty table
            if (fFirst && (_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTTABLE))
            {
                BOOL fContinue = (*_pNameCallBack)(TCB_SUBSTTABLE, szSubstTableName, 
                    NULL, NULL, 0, _lNameParam);

                if (! fContinue)
                    return MakeErrorParserLast();
            }
            break;
        }

        //---- parse the property line ----
        if (!_scan.GetIdPair(szId, szValue, ARRAYSIZE(szId)))
            return SourceError(PARSER_IDS_BAD_SUBST_SYMBOL);

        fFirst = FALSE;

        _scan.ForceNextLine();

        if ((_pNameCallBack) && (_dwParseFlags & PTF_CALLBACK_SUBSTTABLE))
        {
            BOOL fContinue = (*_pNameCallBack)(TCB_SUBSTTABLE, szSubstTableName, 
                szId, szValue, 0, _lNameParam);

            if (! fContinue)
                return MakeErrorParserLast();
        }
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::GenerateEmptySection(LPCWSTR pszSectionName, int iPartId, int iStateId)
{
    int iStartIndex = 0;

    if (_pCallBackObj)
        iStartIndex = _pCallBackObj->GetNextDataIndex();

    int index = 0;      // will be updated later
    HRESULT hr = AddThemeData(TMT_JUMPTOPARENT, TMT_JUMPTOPARENT, &index, sizeof(index));
    if (FAILED(hr))
        return hr;

    if (_pCallBackObj)
    {
        int iLen = _pCallBackObj->GetNextDataIndex() - iStartIndex;

        hr = _pCallBackObj->AddIndex(L"", pszSectionName, iPartId, iStateId,
            iStartIndex, iLen);
        if (FAILED(hr))
            return hr;
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseClassSection(LPCWSTR pszFirstName)
{
    HRESULT hr;
    int iStartIndex = 0;

    BOOL fGlobals = (AsciiStrCmpI(pszFirstName, GLOBALS_SECTION_NAME)==0);
    BOOL fMetrics = (AsciiStrCmpI(pszFirstName, SYSMETRICS_SECTION_NAME)==0);

    if (fGlobals)
    {
        if (_fClassSectionDefined)
            return SourceError(PARSER_IDS_GLOBALS_MUST_BE_FIRST);
    }
    else            // regular class section
    {
        if (_dwParseFlags & PTF_CLASSDATA_PARSE)
        {
            if (! _fGlobalsDefined)     // insert an empty [fGlobals] section
            {
                hr = GenerateEmptySection(GLOBALS_SECTION_NAME, 0, 0);
                if (FAILED(hr))
                    return hr;

                _fGlobalsDefined = true;
            }

            if ((! fMetrics) && (! _fMetricsDefined))   // insert an empty [sysmetrics] section
            {
                hr = GenerateEmptySection(SYSMETRICS_SECTION_NAME, 0, 0);
                if (FAILED(hr))
                    return hr;

                _fMetricsDefined = true;
            }
            else if ((fMetrics) && (_fClassSectionDefined))
                return SourceError(PARSER_IDS_METRICS_MUST_COME_BEFORE_CLASSES);
        }

        _fClassSectionDefined = TRUE;
    }

    WCHAR szAppSym[_MAX_PATH+1];

    if (_pCallBackObj)
        iStartIndex = _pCallBackObj->GetNextDataIndex();

    hr = ParseClassSectionName(pszFirstName, szAppSym, ARRAYSIZE(szAppSym));
    if (FAILED(hr))
        return hr;

    _scan.ForceNextLine();        // get line after section line

    while (1)       // parse each line
    {
        if (_scan.EndOfFile())
            break;

        if (_scan.GetChar('['))          // start of new section
            break;

        hr = ParseClassLine();
        if (FAILED(hr))
            return hr;
    }

    //---- end this section of theme data ----
    int index = 0;      // will be updated later

    hr = AddThemeData(TMT_JUMPTOPARENT, TMT_JUMPTOPARENT, &index, sizeof(index));
    if (FAILED(hr))
        return hr;

    if (_pCallBackObj)
    {
        int iLen = _pCallBackObj->GetNextDataIndex() - iStartIndex;

        hr = _pCallBackObj->AddIndex(szAppSym, _szClassName, _iPartId, 
            _iStateId, iStartIndex, iLen);
        if (FAILED(hr))
            return hr;
    }

    if (fGlobals)
        _fGlobalsDefined = true;
    else if (fMetrics)
        _fMetricsDefined = true;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseThemeFile(LPCTSTR pszFileName, LPCWSTR pszColorParam, 
     IParserCallBack *pCallBack, THEMEENUMPROC pNameCallBack, LPARAM lNameParam, DWORD dwParseFlags)
{
    _pszDocProperty = NULL;

    HRESULT hr = InitializeSymbols();
    if (FAILED(hr))
        goto exit;

    hr = _scan.AttachFile(pszFileName);        // "pszBuffer" contains the filename
    if (FAILED(hr))
        goto exit;

    if (pszColorParam)
    {
        hr = SafeStringCchCopyW(_ColorParam, ARRAYSIZE(_ColorParam), pszColorParam );
        if (FAILED(hr))
            return hr;
    }
    else
        *_ColorParam = 0;

    _hinstThemeDll = NULL;

    hr = ParseThemeScanner(pCallBack, pNameCallBack, lNameParam, dwParseFlags);

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseThemeBuffer(LPCWSTR pszBuffer, LPCWSTR pszFileName, 
     LPCWSTR pszColorParam, HINSTANCE hinstThemeDll,
     IParserCallBack *pCallBack, THEMEENUMPROC pNameCallBack, 
     LPARAM lNameParam, DWORD dwParseFlags, LPCWSTR pszDocProperty, OUT LPWSTR pszResult,
     DWORD dwMaxResultChars)
{
    _pszDocProperty = pszDocProperty;
    _pszResult = pszResult;

    //---- initialize in case not found ----
    if (_pszResult)
        *_pszResult = 0;

    _dwMaxResultChars = dwMaxResultChars;

    HRESULT hr = InitializeSymbols();
    if (FAILED(hr))
        goto exit;

    _hinstThemeDll = hinstThemeDll;

    _scan.AttachMultiLineBuffer(pszBuffer, pszFileName);

    if (pszColorParam)
    {
        hr = SafeStringCchCopyW(_ColorParam, ARRAYSIZE(_ColorParam), pszColorParam );
        if (FAILED(hr))
            return hr;
    }
    else
        *_ColorParam = 0;

    hr = ParseThemeScanner(pCallBack, pNameCallBack, lNameParam, dwParseFlags);

    //---- make error if doc property not found ----
    if ((SUCCEEDED(hr)) && (_dwParseFlags & PTF_QUERY_DOCPROPERTY) && (! *_pszResult))
    {
        hr = MakeError32(ERROR_NOT_FOUND);
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::LoadResourceProperties()
{
    WCHAR szFullString[2*MAX_PATH];
    WCHAR szBaseIniName[_MAX_PATH];  
    HRESULT hr = S_OK;

    //---- extract base .ini name ----
    WCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], ext[_MAX_EXT];
    _wsplitpath(_scan._szFileName, drive, dir, szBaseIniName, ext);

    //---- remove optional "_INI" part ----
    LPWSTR pszExt = wcsstr(szBaseIniName, L"_INI");
    if (pszExt)
        *pszExt = 0;

    //---- read all localizable property name/value pairs into memory ----
    for (int i=RES_BASENUM_PROPVALUEPAIRS; ; i++)
    {
        if (! LoadString(_hinstThemeDll, i, szFullString, ARRAYSIZE(szFullString)))
        {
            //---- no more properties avail ----
            break;
        }

        StringCchCopyW(_szResPropValue, ARRAYSIZE(_szResPropValue), szFullString);     // for proper error reporting
        _iResPropId = i;

        //---- does this property belong to current file? ----
        LPWSTR pszAtSign = wcschr(szFullString, '@');
        if (! pszAtSign)
        {
            hr = SourceError(PARSER_IDS_BAD_RES_PROPERTY);
            break;
        }

        //---- zero terminate ini name ----
        *pszAtSign = 0;

        if (lstrcmpi(szBaseIniName, szFullString) != 0)
            continue;

        //---- strip off the .ini name for faster comparing ----
        LPCWSTR pszName = pszAtSign+1;

        LPWSTR pszValue = wcschr(pszName, '=');
        if (pszValue)
        {
            pszValue++;     // skip over equals sign
        }
        else
        {
            hr = SourceError(PARSER_IDS_BAD_RES_PROPERTY);
            break;
        }

        //---- add the value ----
        CWideString cwValue(pszValue);
        _PropertyValues.Add(cwValue);

        //---- zero-terminate the name ----
        *pszValue = 0;

        //---- add the name ----
        CWideString cwName(pszName);
        _PropertyNames.Add(cwName);

        //---- add the id ----
        _iPropertyIds.Add(i);
    }

    return hr;
}
//---------------------------------------------------------------------------
void CThemeParser::EmptyResourceProperties()
{
    _PropertyNames.RemoveAll();
    _PropertyValues.RemoveAll();
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::GetResourceProperty(LPCWSTR pszPropName, LPWSTR pszValueBuff,
    int cchValueBuff)
{
    WCHAR szPropTarget[2*MAX_PATH];
    HRESULT hr = S_OK;
    BOOL fFound = FALSE;

    StringCchPrintfW(szPropTarget, ARRAYSIZE(szPropTarget), L"[%s]%s=", _szFullSectionName, pszPropName);

    for (int i=0; i < _PropertyNames.m_nSize; i++)
    {
        if (AsciiStrCmpI(szPropTarget, _PropertyNames[i])==0)
        {
            fFound = TRUE;

            hr = SafeStringCchCopyW(pszValueBuff, cchValueBuff, _PropertyValues[i]);
            if (SUCCEEDED(hr))
            {
                hr = SafeStringCchCopyW(_szResPropValue, ARRAYSIZE(_szResPropValue), _PropertyValues[i]);
                _iResPropId = _iPropertyIds[i];
            }
            break;
        }
    }

    if (! fFound)
        hr = E_FAIL;

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::ParseThemeScanner(IParserCallBack *pCallBack, 
     THEMEENUMPROC pNameCallBack, LPARAM lNameParam, DWORD dwParseFlags)
{
    HRESULT hr;

    _pCallBackObj = pCallBack;

    _pNameCallBack = pNameCallBack;
    _lNameParam = lNameParam;
    _dwParseFlags = dwParseFlags;
    _fClassSectionDefined = FALSE;

    //---- setup for properties in the .res file ----
    EmptyResourceProperties();

    _fUsingResourceProperties = (pCallBack != NULL);

    if (_fUsingResourceProperties)
    {
        hr = LoadResourceProperties();
        if (FAILED(hr))
            goto exit;

        //---- set the error context for normal .ini parsing ----
        *_szResPropValue = 0;       // not yet set
    }

    //---- scan the first, non-comment WCHAR ----
    if (! _scan.GetChar('['))
    {
        if (! _scan.EndOfFile())
        {
            hr = SourceError(PARSER_IDS_LBRACKET_EXPECTED);
            goto exit;
        }
    }

    while (! _scan.EndOfFile())           // process each section
    {

        WCHAR section[_MAX_PATH+1];
        _scan.GetId(section);

        if (AsciiStrCmpI(section, L"documentation")==0)
        {
            if (_dwParseFlags & PTF_CLASSDATA_PARSE)
                return SourceError(PARSER_IDS_BADSECT_CLASSDATA);

            hr = ParseDocSection();

            if (_dwParseFlags & PTF_QUERY_DOCPROPERTY)
                break;          // quicker to leave in middle of file

        }
        else if (AsciiStrCmpI(section, L"ColorScheme")==0)
        {
            if (_dwParseFlags & PTF_CLASSDATA_PARSE)
                return SourceError(PARSER_IDS_BADSECT_CLASSDATA);

            hr = ParseColorSchemeSection();
        }
        else if (AsciiStrCmpI(section, L"Size")==0)
        {
            if (_dwParseFlags & PTF_CLASSDATA_PARSE)
                return SourceError(PARSER_IDS_BADSECT_CLASSDATA);

            hr = ParseSizeSection();
        }
        else if (AsciiStrCmpI(section, L"File")==0)
        {
            if (_dwParseFlags & PTF_CLASSDATA_PARSE)
                return SourceError(PARSER_IDS_BADSECT_CLASSDATA);

            hr = ParseFileSection();
        }
        else if (AsciiStrCmpI(section, L"Subst")==0)
        {
            if (_dwParseFlags & PTF_CLASSDATA_PARSE)
                return SourceError(PARSER_IDS_BADSECT_CLASSDATA);

            hr = ParseSubstSection();
        }
        else        // "globals", "sysmetrics", or class section
        {
            if (_dwParseFlags & PTF_CONTAINER_PARSE)
                return SourceError(PARSER_IDS_BADSECT_THEMES_INI);

            hr = ParseClassSection(section);
        }

        if (FAILED(hr))
            goto exit;
    }

    //---- check for empty theme ----
    if (_dwParseFlags & PTF_CLASSDATA_PARSE)
    {
        if (! _fGlobalsDefined)     // insert an empty [fGlobals] section
        {
            hr = GenerateEmptySection(GLOBALS_SECTION_NAME, 0, 0);
            if (FAILED(hr))
                return hr;

            _fGlobalsDefined = true;
        }

        if (! _fMetricsDefined)   // insert an empty [sysmetrics] section
        {
            hr = GenerateEmptySection(SYSMETRICS_SECTION_NAME, 0, 0);
            if (FAILED(hr))
                return hr;
        }
    }

    hr = S_OK;

exit:
    _outfile.Close();

    _pCallBackObj = NULL;
    _pNameCallBack = NULL;
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::GetIntList(int *pInts, LPCWSTR *pParts, int iCount, 
    int iMin, int iMax)
{
    bool bSet[255];     // assume 255 max ints


    //---- ensure we set each one once ----
    for (int i=0; i < iCount; i++)
        bSet[i] = false;

    if (wcschr(_scan._p, ':')) 
    {
        //---- named parts ----
        for (int i=0; i < iCount; i++)
        {
            WCHAR idbuff[_MAX_PATH+1];

            if (! _scan.GetId(idbuff))
                return SourceError(PARSER_IDS_VALUE_NAME_EXPECTED, _scan._p);
        
            for (int j=0; j < iCount; j++)
            {
                if (AsciiStrCmpI(pParts[j], idbuff)==0)
                    break;
            }

            if (j == iCount)        // unknown part name
                return SourceError(PARSER_IDS_UNKNOWN_VALUE_NAME, idbuff);

            if (bSet[j])            // name set twice
                return SourceError(PARSER_IDS_VALUE_PART_SPECIFIED_TWICE, idbuff);

            if (! _scan.GetChar(':'))
                return SourceError(PARSER_IDS_COLOR_EXPECTED, _scan._p);

            if (! _scan.GetNumber(&pInts[j]))
                return SourceError(PARSER_IDS_NUMBER_EXPECTED, _scan._p);

            bSet[j] = true;

            _scan.GetChar(',');      // optional comma
        }
    }
    else
    {
        //---- unnamed parts ----
        for (int i=0; i < iCount; i++)
        {
            if (! _scan.GetNumber(&pInts[i]))
                return SourceError(PARSER_IDS_NUMBER_EXPECTED, _scan._p);

            _scan.GetChar(',');      // optional comma
        }
    }

    //---- range check ----
    if (iMin != iMax)
    {
        for (i=0; i < iCount; i++)
        {
            if ((pInts[i] < iMin) || (pInts[i] > iMax))
                return SourceError(PARSER_IDS_NUMBER_OUT_OF_RANGE);
        }
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeParser::GetPropertyNum(LPCWSTR pszName, int *piPropNum)
{
    //---- for perf, avoid loading all symbols each time this func is called ----
    //---- by using "GetSchemaInfo()" ----
  
    //---- get tm & comctl symbols ----
    const TMSCHEMAINFO *si = GetSchemaInfo();
    int cnt = si->iPropCount;
    const TMPROPINFO *pi = si->pPropTable;

    for (int i=0; i < cnt; i++)
    {
        if (pi[i].sEnumVal < TMT_FIRST_RCSTRING_NAME)
            continue;

        if (pi[i].sEnumVal > TMT_LAST_RCSTRING_NAME)
            break;

        if (AsciiStrCmpI(pszName, pi[i].pszName)==0)
        {
            *piPropNum = pi[i].sEnumVal - TMT_FIRST_RCSTRING_NAME;         // zero based
            return S_OK;
        }
    }

    return MakeError32(ERROR_NOT_FOUND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeldr\log.cpp ===
//---------------------------------------------------------------------------
//    log.cpp - theme logging routines (shared in "inc" directory)
//---------------------------------------------------------------------------
#include "stdafx.h"
//---------------------------------------------------------------------------
#include "log.h"
#include <time.h>
#include <psapi.h>
#include "cfile.h"
#include "tmreg.h"
//---------------------------------------------------------------------------
//---- undo the defines that turn these into _xxx ----
#undef Log    
#undef LogStartUp    
#undef LogShutDown   
#undef LogControl    
#undef TimeToStr     
#undef StartTimer    
#undef StopTimer     
#undef OpenLogFile   
#undef CloseLogFile  
#undef LogOptionOn
#undef GetMemUsage
#undef GetUserCount
#undef GetGdiCount
//---------------------------------------------------------------------------
#define DEFAULT_LOGNAME                 L"c:\\Themes.log"
//---------------------------------------------------------------------------
struct LOGNAMEINFO
{
    LPCSTR pszOption;
    LPCSTR pszDescription;
};
//---------------------------------------------------------------------------
#define MAKE_LOG_STRINGS
#include "logopts.h"        // log options as strings
//-----------------------------------------------------------------
static const WCHAR szDayOfWeekArray[7][4] = { L"Sun", L"Mon", L"Tue", L"Wed", 
    L"Thu", L"Fri", L"Sat" } ;

static const WCHAR szMonthOfYearArray[12][4] = { L"Jan", L"Feb", L"Mar", 
    L"Apr", L"May", L"Jun", L"Jul", L"Aug", L"Sep", L"Oct", L"Nov", L"Dec" } ;
//-----------------------------------------------------------------
#define OPTIONCNT  (ARRAYSIZE(LogNames))

#define LOGPROMPT   "enter log cmd here."
//-----------------------------------------------------------------
//---- unprotected vars (set on init) ----
static WCHAR _szUtilProcessName[MAX_PATH] = {0};
static WCHAR _szLogAppName[MAX_PATH]      = {0};
static CRITICAL_SECTION csLogFile         = {0};

static WCHAR szLogFileName[MAX_PATH+1];   
static BOOL fLogInitialized = FALSE;

//---- protected vars (thread safe) ----
static UCHAR uLogOptions[OPTIONCNT];        // protected by csLogFile
static UCHAR uBreakOptions[OPTIONCNT];      // protected by csLogFile
static DWORD dwLogStartTimer = 0;           // protected by csLogFile

static char szLastOptions[999] = {0};       // protected by csLogFile
static char szLogCmd[999] = {0};            // protected by csLogFile
static int iIndentCount = 0;                // protected by csLogFile

static WCHAR s_szWorkerBuffer[512];         // protected by csLogFile
static WCHAR s_szLogBuffer[512];            // protected by csLogFile
static CHAR s_szConBuffer[512];             // protected by csLogFile

static CSimpleFile *pLogFile = NULL;        // protected by csLogFile
//-----------------------------------------------------------------
void ParseLogOptions(UCHAR *uOptions, LPCSTR pszName, LPCSTR pszOptions, BOOL fEcho);
//-----------------------------------------------------------------
void RawCon(LPCSTR pszFormat, ...)
{
    CAutoCS cs(&csLogFile);

    va_list args;
    va_start(args, pszFormat);

    //---- format caller's string ----
    StringCchVPrintfA(s_szConBuffer, ARRAYSIZE(s_szConBuffer), pszFormat, args);

    OutputDebugStringA(s_szConBuffer);

    va_end(args);
}
//-----------------------------------------------------------------
void SetDefaultLoggingOptions()
{
    RESOURCE HKEY hklm = NULL;
    HRESULT hr = S_OK;

    //---- open hklm ----
    int code32 = RegOpenKeyEx(HKEY_LOCAL_MACHINE, THEMEMGR_REGKEY, 0,
        KEY_READ, &hklm);
    if (code32 != ERROR_SUCCESS)       
    {
        hr = MakeErrorLast();
        goto exit;
    }

    //---- read the "LogCmd" value ----
    WCHAR szValBuff[MAX_PATH];
    hr = RegistryStrRead(hklm, THEMEPROP_LOGCMD, szValBuff, ARRAYSIZE(szValBuff));
    if (SUCCEEDED(hr))
    {
        USES_CONVERSION;
        ParseLogOptions(uLogOptions, "Log", W2A(szValBuff), FALSE);
    }

    //---- read the "BreakCmd" value ----
    hr = RegistryStrRead(hklm, THEMEPROP_BREAKCMD, szValBuff, ARRAYSIZE(szValBuff));
    if (SUCCEEDED(hr))
    {
        USES_CONVERSION;
        ParseLogOptions(uBreakOptions, "Break", W2A(szValBuff), FALSE);
    }

    //---- read the "LogAppName" value ----
    RegistryStrRead(hklm, THEMEPROP_LOGAPPNAME, _szLogAppName, ARRAYSIZE(_szLogAppName));

exit:
    if (hklm)
        RegCloseKey(hklm);
}
//-----------------------------------------------------------------
BOOL LogStartUp()
{
    BOOL fInit = FALSE;

    dwLogStartTimer = StartTimer();

    pLogFile = new CSimpleFile;
    if (! pLogFile)
        goto exit;

    //---- reset all log options ----
    for (int i=0; i < OPTIONCNT; i++)
    {
        uLogOptions[i] = 0;
        uBreakOptions[i] = 0;
    }

    //---- turn on default OUTPUT options ----
    uLogOptions[LO_CONSOLE] = TRUE;
    uLogOptions[LO_APPID] = TRUE;
    uLogOptions[LO_THREADID] = TRUE;

    //---- turn on default FILTER options ----
    uLogOptions[LO_ERROR] = TRUE;
    uLogOptions[LO_ASSERT] = TRUE;
    uLogOptions[LO_BREAK] = TRUE;
    uLogOptions[LO_PARAMS] = TRUE;
    uLogOptions[LO_ALWAYS] = TRUE;

    //---- turn on default BREAK options ----
    uBreakOptions[LO_ERROR] = TRUE;
    uBreakOptions[LO_ASSERT] = TRUE;

    if( InitializeCriticalSectionAndSpinCount(&csLogFile, 0) )
    {
        //---- get process name (log has its own copy) ----
        WCHAR szPath[MAX_PATH];
        if (! GetModuleFileNameW( NULL, szPath, ARRAYSIZE(szPath) ))
            goto exit;

        WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szExt[_MAX_EXT];
        _wsplitpath(szPath, szDrive, szDir, _szUtilProcessName, szExt);

        StringCchCopyA(szLogCmd, ARRAYSIZE(szLogCmd), LOGPROMPT);
        StringCchCopyW(szLogFileName, ARRAYSIZE(szLogFileName), DEFAULT_LOGNAME);

        fLogInitialized = TRUE;

        SetDefaultLoggingOptions();
        fInit = TRUE;
    }

exit:
    return fInit;
}
//---------------------------------------------------------------------------
BOOL LogShutDown()
{
    fLogInitialized = FALSE;

    SAFE_DELETE(pLogFile);

    SAFE_DELETECRITICALSECTION(&csLogFile);

    return TRUE;
}
//---------------------------------------------------------------------------
void GetDateString(WCHAR *pszDateBuff, ULONG cchDateBuff)
{
    // Sent Date
    SYSTEMTIME stNow;
    WCHAR szMonth[10], szWeekDay[12] ; 

    GetLocalTime(&stNow);

    StringCchCopyW(szWeekDay, ARRAYSIZE(szWeekDay), szDayOfWeekArray[stNow.wDayOfWeek]) ;
    StringCchCopyW(szMonth, ARRAYSIZE(szMonth), szMonthOfYearArray[stNow.wMonth-1]) ;

    StringCchPrintfW(pszDateBuff, cchDateBuff, L"%s, %u %s %u %2d:%02d:%02d ", szWeekDay, stNow.wDay, 
                                szMonth, stNow.wYear, stNow.wHour, 
                                stNow.wMinute, stNow.wSecond) ;
}
//---------------------------------------------------------------------------
void LogMsgToFile(LPCWSTR pszMsg)
{
    CAutoCS autoCritSect(&csLogFile);

    HRESULT hr;
    BOOL fWasOpen = pLogFile->IsOpen();

    if (! fWasOpen)
    {
        BOOL fNewFile = !FileExists(szLogFileName);
    
        hr = pLogFile->Append(szLogFileName, TRUE);
        if (FAILED(hr))
            goto exit;

        //---- write hdr if new file ----
        if (fNewFile)
        {
            WCHAR pszBuff[100];
            GetDateString(pszBuff, ARRAYSIZE(pszBuff));
            pLogFile->Printf(L"Theme log - %s\r\n\r\n", pszBuff);
        }
    }

    pLogFile->Write((void*)pszMsg, lstrlen(pszMsg)*sizeof(WCHAR));

exit:
    if (! fWasOpen)
        pLogFile->Close();
}
//---------------------------------------------------------------------------
void SimpleFileName(LPCSTR pszNarrowFile, OUT LPWSTR pszSimpleBuff, ULONG cchSimpleBuff)
{
    USES_CONVERSION;
    WCHAR *pszFile = A2W(pszNarrowFile);

    //---- remove current dir marker for VS error navigation ----
    if ((pszFile[0] == L'.') && (pszFile[1] == L'\\'))
    {
        StringCchPrintfW(pszSimpleBuff, cchSimpleBuff, L"f:\\nt\\shell\\Themes\\UxTheme\\%s", pszFile+2);
        
        if (! FileExists(pszSimpleBuff))
            StringCchPrintfW(pszSimpleBuff, cchSimpleBuff, L"f:\\nt\\shell\\Themes\\ThemeSel\\%s", pszFile+2);

        if (! FileExists(pszSimpleBuff))
            StringCchPrintfW(pszSimpleBuff, cchSimpleBuff, L"f:\\nt\\shell\\Themes\\packthem\\%s", pszFile+2);

        if (! FileExists(pszSimpleBuff))
            StringCchPrintfW(pszSimpleBuff, cchSimpleBuff, L"%s", pszFile+2);
    }
    else
        StringCchCopyW(pszSimpleBuff, cchSimpleBuff, pszFile);
}
//-----------------------------------------------------------------
#ifdef DEBUG                // pulls in psapi.dll
int GetMemUsage()
{
    ULONG           ulReturnLength;
    VM_COUNTERS     vmCounters;

    if (!NT_SUCCESS(NtQueryInformationProcess(GetCurrentProcess(),
                                              ProcessVmCounters,
                                              &vmCounters,
                                              sizeof(vmCounters),
                                              &ulReturnLength)))
    {
        ZeroMemory(&vmCounters, sizeof(vmCounters));
    }
    return static_cast<int>(vmCounters.WorkingSetSize);
}
#else
int GetMemUsage()
{
    return 0;
}
#endif 
//-----------------------------------------------------------------
int GetUserCount()
{
    HANDLE hp = GetCurrentProcess();
    return GetGuiResources(hp, GR_USEROBJECTS);
}
//-----------------------------------------------------------------
int GetGdiCount()
{
    HANDLE hp = GetCurrentProcess();
    return GetGuiResources(hp, GR_GDIOBJECTS);
}
//-----------------------------------------------------------------
void LogWorker(UCHAR uLogOption, LPCSTR pszSrcFile, int iLineNum, int iEntryExitCode, LPCWSTR pszMsg)
{
    CAutoCS cs(&csLogFile);

    BOOL fBreaking = (uBreakOptions[uLogOption]);

    if (fBreaking)     
    {
        OutputDebugString(L"\r\n");     // blank line at beginning

        WCHAR fn[_MAX_PATH+1];
        SimpleFileName(pszSrcFile, fn, ARRAYSIZE(fn));

        StringCchPrintfW(s_szWorkerBuffer, ARRAYSIZE(s_szWorkerBuffer), L"%s [%d]: BREAK at %s(%d):\r\n", 
            _szUtilProcessName, GetCurrentThreadId(), fn, iLineNum);

        OutputDebugString(s_szWorkerBuffer);
    }

    //---- PRE API entry/exit indent adjustment ----
    if (iEntryExitCode == -1)
    {
        if (iIndentCount >= 2)
            iIndentCount -= 2;
    }

    WCHAR *p = s_szWorkerBuffer;
    ULONG cch = ARRAYSIZE(s_szWorkerBuffer);
    ULONG len;

    //---- apply indenting ----
    for (int i=0; i < iIndentCount; i++)
    {
        *p++ = ' ';
        cch--;
    }

    //---- POST API entry/exit indent adjustment ----
    if (iEntryExitCode == 1)
    {
        iIndentCount += 2;
    }

    //---- apply app id ----
    if (uLogOptions[LO_APPID] && cch > 0)
    {
        StringCchPrintfW(p, cch, L"%s ", _szUtilProcessName);

        len = lstrlen(p); 
        p += len;
        cch -= len;
    }

    //---- apply thread id ----
    if (uLogOptions[LO_THREADID] && cch > 0)
    {
        StringCchPrintfW(p, cch, L"[%d] ", GetCurrentThreadId());

        len = lstrlen(p); 
        p += len;
        cch -= len;
    }

    //---- apply src id ----
    if (uLogOptions[LO_SRCID] && cch > 0) 
    {
        WCHAR fn[_MAX_PATH+1];
        SimpleFileName(pszSrcFile, fn, ARRAYSIZE(fn));

        if (fBreaking)
            StringCchPrintfW(p, cch, L"BREAK at %s(%d) : ", fn, iLineNum);
        else
            StringCchPrintfW(p, cch, L"%s(%d) : ", fn, iLineNum);

        len = lstrlen(p); 
        p += len;
        cch -= len;
    }
    
    //---- apply timer id ----
    if (uLogOptions[LO_TIMERID] && cch > 0)
    {
        DWORD dwTicks = StopTimer(dwLogStartTimer);

        WCHAR buff[100];
        TimeToStr(dwTicks, buff, ARRAYSIZE(buff));

        StringCchPrintfW(p, cch, L"Timer: %s ", buff);

        len = lstrlen(p); 
        p += len;
        cch -= len;
    }

    //---- apply clock id ----
    if (uLogOptions[LO_CLOCKID] && cch > 0)
    {
        SYSTEMTIME stNow;
        GetLocalTime(&stNow);

        StringCchPrintfW(p, cch, L"Clock: %02d:%02d:%02d.%03d ", stNow.wHour, 
            stNow.wMinute, stNow.wSecond, stNow.wMilliseconds);

        len = lstrlen(p); 
        p += len;
        cch -= len;
    }

    //---- apply USER count ----
    if (uLogOptions[LO_USERCOUNT] && cch > 0)
    {
        StringCchPrintfW(p, cch, L"UserCount=%d ", GetUserCount());

        len = lstrlen(p); 
        p += len;
        cch -= len;
    }

    //---- apply GDI count ----
    if (uLogOptions[LO_GDICOUNT] && cch > 0)
    {
        StringCchPrintfW(p, cch, L"GDICount=%d ", GetGdiCount());

        len = lstrlen(p); 
        p += len;
        cch -= len;
    }

    //---- apply MEM usage ----
    if (uLogOptions[LO_MEMUSAGE] && cch > 0)
    {
        int iUsage = GetMemUsage();
        StringCchPrintfW(p, cch, L"MemUsage=%d ", iUsage);

        len = lstrlen(p); 
        p += len;
        cch -= len;
    }

    //---- add "Assert:" or "Error:" strings as needed ----
    if (uLogOption == LO_ASSERT && cch > 0) 
    {
        StringCchCopyW(p, cch, L"Assert: ");

        len = lstrlen(p); 
        p += len;
        cch -= len;
    }
    else if (uLogOption == LO_ERROR && cch > 0) 
    {
        StringCchCopyW(p, cch, L"Error: ");

        len = lstrlen(p); 
        p += len;
        cch -= len;
    }
    
    //---- apply caller's msg ----
    if( cch > 0 )
    {
        StringCchCopyW(p, cch, pszMsg);

        len = lstrlen(p); 
        p += len;
        cch -= len;
    }

    if( cch >= 3 )
    {
        *p++ = '\r';        // end with CR
        cch--;
    }
    if( cch >= 2 )
    {
        *p++ = '\n';        // end with newline
        cch--;
    }
    if( cch >= 1 )
    {
        *p = 0;
        cch--;
    }

    //---- log to CONSOLE and/or FILE ----
    if (uLogOptions[LO_CONSOLE])
        OutputDebugString(s_szWorkerBuffer);

    if (uLogOptions[LO_LOGFILE])
        LogMsgToFile(s_szWorkerBuffer);

    //---- process Heap Check ----
    if (uLogOptions[LO_HEAPCHECK])
    {
        HANDLE hh = GetProcessHeap();
        HeapValidate(hh, 0, NULL);
    }

    if (fBreaking)   
        OutputDebugString(L"\r\n");     // blank line at end

}
//-----------------------------------------------------------------
HRESULT OpenLogFile(LPCWSTR pszLogFileName)
{
    CAutoCS cs(&csLogFile);

    HRESULT hr = pLogFile->Create(pszLogFileName, TRUE);
    return hr;
}
//-----------------------------------------------------------------
void CloseLogFile()
{
    CAutoCS cs(&csLogFile);

    if (pLogFile)
        pLogFile->Close();
}
//-----------------------------------------------------------------
void Log(UCHAR uLogOption, LPCSTR pszSrcFile, int iLineNum, int iEntryExitCode, LPCWSTR pszFormat, ...)
{
    if (fLogInitialized)
    {
        CAutoCS cs(&csLogFile);

        //---- only log for a specified process? ----
        if (* _szLogAppName)
        {
            if (lstrcmpi(_szLogAppName, _szUtilProcessName) != 0)
                return;
        }

        while (1)
        {
            if (strncmp(szLogCmd, LOGPROMPT, 6)!=0)
            {
                LogControl(szLogCmd, TRUE);
                StringCchCopyA(szLogCmd, ARRAYSIZE(szLogCmd), LOGPROMPT);
            
                DEBUG_BREAK;
            }
            else
                break;
        }

        if ((uLogOption >= 0) || (uLogOption < OPTIONCNT))
        {
            if (uLogOptions[uLogOption])
            {
                //---- apply caller's msg ----
                va_list args;
                va_start(args, pszFormat);
                StringCchVPrintfW(s_szLogBuffer, ARRAYSIZE(s_szLogBuffer), pszFormat, args);
                va_end(args);
        
                LogWorker(uLogOption, pszSrcFile, iLineNum, iEntryExitCode, s_szLogBuffer);

            }

            if ((uBreakOptions[uLogOption]) && (uLogOption != LO_ASSERT))
                DEBUG_BREAK;
        }
    }
}
//-----------------------------------------------------------------
int MatchLogOption(LPCSTR lszOption)
{
    for (int i=0; i < OPTIONCNT; i++)
    {
        if (lstrcmpiA(lszOption, LogNames[i].pszOption)==0)
            return i;
    }

    return -1;      // not found
}
//-----------------------------------------------------------------
void ParseLogOptions(UCHAR *uOptions, LPCSTR pszName, LPCSTR pszOptions, BOOL fEcho)
{
    CAutoCS cs(&csLogFile);

    if (! fLogInitialized)
        return;

    //---- ignore debugger's multiple eval of same expression ----
    if (strcmp(pszOptions, szLastOptions)==0)
        return;

    //---- make a copy of options so we can put NULLs in it ----
    BOOL fErrors = FALSE;
    char szOptions[999];
    char *pszErrorText = NULL;
    StringCchCopyA(szOptions, ARRAYSIZE(szOptions), pszOptions);

    //---- process each option in szOption ----
    char *p = strchr(szOptions, '.');
    if (p)      // easy termination for NTSD users
        *p = 0;

    p = szOptions;
    while (*p == ' ')
        p++;

    while ((p) && (*p))
    {
        //---- find end of current option "p" ----
        char *q = strchr(p, ' ');
        if (q)
            *q = 0;

        UCHAR fSet = TRUE;
        if (*p == '+')
            p++;
        else if (*p == '-')
        {
            fSet = FALSE;
            p++;
        }
        
        if (! fErrors)          // point to first error in case one is found
            pszErrorText = p;  

        int iLogOpt = MatchLogOption(p);

        if (iLogOpt != -1)
        {
            if (iLogOpt == LO_ALL)
            {
                for (int i=0; i < OPTIONCNT; i++)
                    uOptions[i] = fSet;
            }
            else
                uOptions[iLogOpt] = fSet;
        }
        else
            fErrors = TRUE;

        //---- skip to next valid space ----
        if (! q)
            break;

        q++;
        while (*q == ' ')
            q++;
        p = q;
    }

    //---- fixup inconsistent option settings ----
    if (! uOptions[LO_LOGFILE])
        uOptions[LO_CONSOLE] = TRUE;

    if ((! fErrors) && (fEcho))         
    {
        //---- display active log options ----
        BOOL fNoneSet = TRUE;

        RawCon("Active %s Options:\n", pszName);

        for (int i=0; i < LO_ALL; i++)
        {
            if (uOptions[i])
            {
                RawCon("+%s ", LogNames[i].pszOption);
                fNoneSet = FALSE;
            }
        }

        if (fNoneSet)
            RawCon("<none>\n");
        else
            RawCon("\n");

        //---- display active log filters (except "all") ----
        RawCon("Active Msg Filters:\n  ");

        for (i=LO_ALL+1; i < OPTIONCNT; i++)
        {
            if (uOptions[i])
            {
                RawCon("+%s ", LogNames[i].pszOption);
                fNoneSet = FALSE;
            }
        }

        if (fNoneSet)
            RawCon("<none>\n");
        else
            RawCon("\n");
    }
    else if (fErrors)
    {
        //---- one or more bad options - display available options ----
        RawCon("Error - unrecognized %s option: %s\n", pszName, pszErrorText);

        if (fEcho)
        {
            RawCon("Available Log Options:\n");
            for (int i=0; i < LO_ALL; i++)
            {
                RawCon("  +%-12s %s\n", 
                    LogNames[i].pszOption, LogNames[i].pszDescription);
            }

            RawCon("Available Msg Filters:\n");
            for (i=LO_ALL; i < OPTIONCNT; i++)
            {
                RawCon("  +%-12s %s\n", 
                    LogNames[i].pszOption, LogNames[i].pszDescription);
            }
        }
    }

    StringCchCopyA(szLastOptions, ARRAYSIZE(szLastOptions), pszOptions);
}
//-----------------------------------------------------------------
void LogControl(LPCSTR pszOptions, BOOL fEcho)
{
    ParseLogOptions(uLogOptions, "Log", pszOptions, fEcho);
}
//---------------------------------------------------------------------------
DWORD StartTimer()
{
    LARGE_INTEGER now;
    QueryPerformanceCounter(&now);

    return DWORD(now.QuadPart);
}
//---------------------------------------------------------------------------
DWORD StopTimer(DWORD dwStartTime)
{
    LARGE_INTEGER now;
    QueryPerformanceCounter(&now);

    return DWORD(now.QuadPart) - dwStartTime;
}
//---------------------------------------------------------------------------
void TimeToStr(UINT uRaw, WCHAR *pszBuff, ULONG cchBuff)
{
    LARGE_INTEGER freq;
    QueryPerformanceFrequency(&freq);
    DWORD Freq = (UINT)freq.QuadPart;

    const _int64 factor6 = 1000000;
    _int64 secs = uRaw*factor6/Freq;

    StringCchPrintfW(pszBuff, cchBuff, L"%u.%04u secs", UINT(secs/factor6), UINT(secs%factor6)/100);    
}
//---------------------------------------------------------------------------
BOOL LogOptionOn(int iLogOption)
{
    if ((iLogOption < 0) || (iLogOption >= OPTIONCNT))
        return FALSE;

    return (uLogOptions[iLogOption] != 0);
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeldr\signing.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Signing.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  A class to handle signing on themes.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------

#include <stdafx.h>
#include "..\inc\signing.h"
#include <shlobj.h>

#define TBOOL(x)    (BOOL)(x)

//  --------------------------------------------------------------------------
//  CThemeSignature miscellaneous data and type declarations
//
//  Purpose:    These are private to the implementation of this class.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------

static  const DWORD VSSIGN_TAG  =   0x84692426;         //  Magic number so we can validate that it is our signature

#define SIZE_PE_HEADER              0x130       // This is the size of the .msstyles file header that contains the checksum, rebase address and other info we want to allow to change.

typedef struct
{
    char                    cSignature[128];
} SIGNATURE;

typedef struct
{
    DWORD                   dwTag;          //  This should be VSSIGN_TAG
    DWORD                   dwSigSize;      //  Normally 128 bytes, the size of just the sign
    ULARGE_INTEGER          ulFileSize;      //  This is the total file size, including signature and SIGNATURE_BLOB_TAIL
} SIGNATURE_BLOB_TAIL;

typedef struct
{
    SIGNATURE               signature;
    SIGNATURE_BLOB_TAIL     blob;
} SIGNATURE_ON_DISK;

#define HRESULT_FROM_CRYPTO(x) ((HRESULT)(x) <= 0 ? ((HRESULT)(x)) : ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_SSPI << 16) | 0x80000000)))


//  --------------------------------------------------------------------------
//  CThemeSignature::static class constants
//
//  Purpose:    Holds all the constant static information that is shared by
//              both the signer and the verifier. This is private information
//              known only to this class.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------

const WCHAR     CThemeSignature::s_szDescription[]      =   L"Microsoft Visual Style Signature";
const WCHAR     CThemeSignature::s_szThemeDirectory[]   =   L"Themes";


const BYTE s_keyPublic1[]     =   //  Public Key: #1
{
    0x06, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x52, 0x53, 0x41, 0x31, 0x00,
    0x04, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x73, 0xAA, 0xFD, 0xFE, 0x2E, 0x34,
    0x75, 0x3B, 0xC2, 0x20, 0x72, 0xFC, 0x50, 0xCC, 0xD4, 0xE0, 0xDE, 0xC7, 0xA6,
    0x46, 0xC6, 0xDC, 0xE6, 0x6B, 0xF0, 0x58, 0x11, 0x88, 0x66, 0x54, 0x5F, 0x3D,
    0x81, 0x8C, 0xEF, 0x5F, 0x89, 0x51, 0xE4, 0x9C, 0x3F, 0x57, 0xA6, 0x22, 0xA9,
    0xE7, 0x0F, 0x4B, 0x56, 0x81, 0xD1, 0xA6, 0xBA, 0x24, 0xFF, 0x93, 0x17, 0xFE,
    0x64, 0xEF, 0xE5, 0x11, 0x90, 0x00, 0xDC, 0x37, 0xC2, 0x84, 0xEE, 0x7B, 0x12,
    0x43, 0xA4, 0xAF, 0xC3, 0x69, 0x57, 0xD1, 0x92, 0x96, 0x8E, 0x55, 0x0F, 0xE1,
    0xCD, 0x0F, 0xAE, 0xEA, 0xE8, 0x01, 0x83, 0x65, 0x32, 0xF1, 0x80, 0xDB, 0x08,
    0xD6, 0x01, 0x84, 0xB1, 0x09, 0x80, 0x3C, 0x27, 0x83, 0x9F, 0x16, 0x92, 0x86,
    0x4C, 0x8E, 0x15, 0xC7, 0x94, 0xE4, 0x27, 0xFF, 0x2B, 0xA4, 0x28, 0xDE, 0x9C,
    0x43, 0x5B, 0x5E, 0x14, 0xB6
};

#define SIZE_PUBLIC_KEY         148         // sizeof(s_keyPublic1)



HRESULT FixCryptoError(DWORD dwError)
{
    HRESULT hr = dwError;

    // Sometimes the return value from GetLastError() after Crypto APIs returns HRESULTS and sometimes not.
    if (0 == HRESULT_SEVERITY(dwError))
    {
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


#define IS_DIGITW(x)   (((x) >= L'0') && ((x) <= L'9'))

BOOL StrToInt64ExInternalW(LPCWSTR pszString, DWORD dwFlags, LONGLONG *pllRet)
{
    BOOL bRet;

    if (pszString)
    {
        LONGLONG n;
        BOOL bNeg = FALSE;
        LPCWSTR psz;
        LPCWSTR pszAdj;

        // Skip leading whitespace
        //
        for (psz = pszString; *psz == L' ' || *psz == L'\n' || *psz == L'\t'; psz++)
            NULL;

        // Determine possible explicit signage
        //
        if (*psz == L'+' || *psz == L'-')
        {
            bNeg = (*psz == L'+') ? FALSE : TRUE;
            psz++;
        }

        // Or is this hexadecimal?
        //
        pszAdj = psz+1;
        if ((STIF_SUPPORT_HEX & dwFlags) &&
            *psz == L'0' && (*pszAdj == L'x' || *pszAdj == L'X'))
        {
            // Yes

            // (Never allow negative sign with hexadecimal numbers)
            bNeg = FALSE;
            psz = pszAdj+1;

            pszAdj = psz;

            // Do the conversion
            //
            for (n = 0; ; psz++)
            {
                if (IS_DIGITW(*psz))
                    n = 0x10 * n + *psz - L'0';
                else
                {
                    WCHAR ch = *psz;
                    int n2;

                    if (ch >= L'a')
                        ch -= L'a' - L'A';

                    n2 = ch - L'A' + 0xA;
                    if (n2 >= 0xA && n2 <= 0xF)
                        n = 0x10 * n + n2;
                    else
                        break;
                }
            }

            // Return TRUE if there was at least one digit
            bRet = (psz != pszAdj);
        }
        else
        {
            // No
            pszAdj = psz;

            // Do the conversion
            for (n = 0; IS_DIGITW(*psz); psz++)
                n = 10 * n + *psz - L'0';

            // Return TRUE if there was at least one digit
            bRet = (psz != pszAdj);
        }

        if (pllRet)
        {
            *pllRet = bNeg ? -n : n;
        }
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}


//  --------------------------------------------------------------------------
//  CThemeSignature::CThemeSignature
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CThemeSignature. Allocates required resources
//              to perform crypt functions. If these are expensive they can
//              be moved to a common initializing function to make the
//              constructor more lightweight. The destructor can still release
//              only the allocated resources.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------
CThemeSignature::CThemeSignature(OPTIONAL const BYTE * pvPrivateKey, OPTIONAL DWORD cbPrivateKeySize) :
    _hCryptProvider(NULL),
    _hCryptHash(NULL),
    _hCryptKey(NULL),
    _pvSignature(NULL),
    _dwSignatureSize(0)
{
    _Init(pvPrivateKey, cbPrivateKeySize);
}


//  --------------------------------------------------------------------------
//  CThemeSignature::CThemeSignature
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CThemeSignature. Allocates required resources
//              to perform crypt functions. If these are expensive they can
//              be moved to a common initializing function to make the
//              constructor more lightweight. The destructor can still release
//              only the allocated resources.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------
CThemeSignature::CThemeSignature() :
    _hCryptProvider(NULL),
    _hCryptHash(NULL),
    _hCryptKey(NULL),
    _pvSignature(NULL),
    _dwSignatureSize(0)
{
    _Init(NULL, 0);
}


void CThemeSignature::_Init(OPTIONAL const BYTE * pvPrivateKey, OPTIONAL DWORD cbPrivateKeySize)
{
    _pvPrivateKey = pvPrivateKey;           // Okay if NULL
    _cbPrivateKeySize = cbPrivateKeySize;

    // TODO: Use PROV_RSA_SIG
    if (CryptAcquireContext(&_hCryptProvider,
                            NULL,
                            NULL,
                            PROV_RSA_FULL,
                            CRYPT_SILENT | CRYPT_VERIFYCONTEXT) != FALSE)
    {
        TBOOL(CryptCreateHash(_hCryptProvider,
                              CALG_SHA,
                              0,
                              0,
                              &_hCryptHash));
    }
}

//  --------------------------------------------------------------------------
//  CThemeSignature::~CThemeSignature
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CThemeSignature. Release any allocated
//              resources used in the processing of this class.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------

CThemeSignature::~CThemeSignature (void)

{
    if (_pvSignature != NULL)
    {
        LocalFree(_pvSignature);
        _pvSignature = NULL;
    }
    if (_hCryptKey != NULL)
    {
        TBOOL(CryptDestroyKey(_hCryptKey));
        _hCryptKey = NULL;
    }
    if (_hCryptHash != NULL)
    {
        TBOOL(CryptDestroyHash(_hCryptHash));
        _hCryptHash = NULL;

    }
    if (_hCryptProvider != NULL)
    {
        TBOOL(CryptReleaseContext(_hCryptProvider, 0));
        _hCryptProvider = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CThemeSignature::Verify
//
//  Arguments:  pszFilename     =   File path to verify.
//              fNoSFCCheck     =   Bypass SFC check?
//
//  Returns:    HRESULT
//
//  Purpose:    Verifies the signature on the given file path. Allows the
//              caller to bypass the SFC check.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::Verify(const WCHAR *pszFilename, bool fNoSFCCheck)
{
    HRESULT hr = S_OK;

    //  Do we need to check with SFC?
    if (fNoSFCCheck || !IsProtected(pszFilename))
    {
        //  Did the constructor complete successfully?
        hr = (HasProviderAndHash() ? S_OK : E_FAIL);
        if (SUCCEEDED(hr))
        {
            //  Create a public key.
            hr = CreateKey(KEY_PUBLIC);
            if (SUCCEEDED(hr))
            {
                HANDLE  hFile;

                //  Open the file READ-ONLY.
                hFile = CreateFileW(pszFilename,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    0,
                                    OPEN_EXISTING,
                                    0,
                                    0);
                if (INVALID_HANDLE_VALUE != hFile)
                {
                    //  Calculate the hash on the file.
                    hr = CalculateHash(hFile, KEY_PUBLIC);
                    if (SUCCEEDED(hr))
                    {
                        SIGNATURE   signature;

                        //  Read the signature of the file.
                        hr = ReadSignature(hFile, &signature);
                        if (SUCCEEDED(hr))
                        {
                            //  Check the signature.
                            if (CryptVerifySignature(_hCryptHash,
                                                     reinterpret_cast<BYTE*>(&signature),
                                                     sizeof(signature),
                                                     _hCryptKey,
                                                     s_szDescription,
                                                     0) != FALSE)
                            {
                                hr = S_OK;
                            }
                            else
                            {
                                hr = FixCryptoError(GetLastError());
                            }
                        }
                    }
                    TBOOL(CloseHandle(hFile));
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::Sign
//
//  Arguments:  pszFilename     =   File path to sign.
//
//  Returns:    HRESULT
//
//  Purpose:    Signs the given file with a digital signature. Used by the
//              theme packer application.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::Sign(const WCHAR *pszFilename)
{
    HRESULT hr = E_FAIL;

    //  Did the constructor complete successfully?
    if (HasProviderAndHash())
    {
        hr = CreateKey(KEY_PRIVATE);
        if (SUCCEEDED(hr))
        {
            HANDLE  hFile;

            //  Open the file READ-ONLY. We will open it READ-WRITE when needed.
            hFile = CreateFileW(pszFilename,
                                GENERIC_READ,
                                0,
                                0,
                                OPEN_EXISTING,
                                0,
                                0);
            if (INVALID_HANDLE_VALUE != hFile)
            {
                //  Calculate the hash on the file.
                hr = CalculateHash(hFile, KEY_PRIVATE);
                TBOOL(CloseHandle(hFile));      // We need to close this now because other calls down below will want to open it.
                hFile = NULL;

                if (SUCCEEDED(hr))
                {
                    //  Sign the hash.
                    hr = SignHash();
                    if (SUCCEEDED(hr))
                    {
                        //  Write the signature.
                        hr = WriteSignature(pszFilename,
                                            _pvSignature,
                                            _dwSignatureSize);
                        if (S_OK == hr)
                        {
                            CThemeSignature themeSignature(_pvPrivateKey, _cbPrivateKeySize);

                            //  Verify the signature with a new instance of the verifier.
                            hr = themeSignature.Verify(pszFilename, true);
                        }
                    }
                }
            }
            else
            {
                DWORD   dwErrorCode;

                dwErrorCode = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErrorCode);
            }
        }
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::IsProtected
//
//  Arguments:  pszFilename     =   File path to check protection on.
//
//  Returns:    bool
//
//  Purpose:    Determines whether this file is a known theme. This used to
//              check for SFC but because this code is called before SFC has
//              started up this doesn't work.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-10  vtan        consolidated into a class
//              2000-09-10  vtan        removed SFC (bryanst delta)
//  --------------------------------------------------------------------------
bool CThemeSignature::IsProtected(const WCHAR *pszFilename)  const
{
    return false;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::HasProviderAndHash
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the constructor completed successfully.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------
bool CThemeSignature::HasProviderAndHash(void)   const
{
    return((_hCryptProvider != NULL) && (_hCryptHash != NULL));
}







const BYTE * CThemeSignature::_GetPublicKey(void)
{
    const BYTE * pKeyToReturn = NULL;

    pKeyToReturn = s_keyPublic1;

    return pKeyToReturn;
}


//  --------------------------------------------------------------------------
//  CThemeSignature::CreateKey
//
//  Arguments:  keyType     =   Key type to create.
//
//  Returns:    HRESULT
//
//  Purpose:    Creates the specified key type.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::CreateKey(KEY_TYPES keyType)
{
    HRESULT hr = S_OK;

    switch (keyType)
    {
        DWORD dwDataLength;
        const BYTE  *pData;

        case KEY_PUBLIC:
            pData = _GetPublicKey();
            dwDataLength = SIZE_PUBLIC_KEY;
            goto importKey;
        case KEY_PRIVATE:
            if (!_pvPrivateKey || (0 == _cbPrivateKeySize))
            {
                return E_INVALIDARG;
            }

            pData = _pvPrivateKey;
            dwDataLength = _cbPrivateKeySize;

importKey:
            if (pData)
            {
                if (!CryptImportKey(_hCryptProvider,
                                   pData,
                                   dwDataLength,
                                   0,
                                   0,
                                   &_hCryptKey))
                {
                    hr = FixCryptoError(GetLastError());
                }
            }
            else
            {
                hr = E_FAIL;
            }
            break;
        default:
            ASSERTMSG(false, "Unknown key type passed to CThemeSignature::CreateKey");
            hr = E_INVALIDARG;
            break;
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::CalculateHash
//
//  Arguments:  hFile       =   File to hash.
//              keyType     =   Type of hash to generate.
//
//  Returns:    HRESULT
//
//  Purpose:    Hashes the file contents. How much is hashed depends on
//              whether the public or private key is used. The public key
//              means that this is a verification so the signature and blob
//              are NOT hashed. Otherwise a private key means that this is a
//              signing and the whole file must be hashed (because the
//              signature and blob are not present).
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::CalculateHash(HANDLE hFile, KEY_TYPES keyType)
{
    HRESULT hr = S_OK;
    HANDLE hSection;

    //  Create a section object for this file.
    hSection = CreateFileMapping(hFile,
                                 NULL,
                                 PAGE_READONLY,
                                 0,
                                 0,
                                 NULL);
    if (hSection != NULL)
    {
        void * pV;

        //  Map the section into the address space.
        pV = MapViewOfFile(hSection,
                           FILE_MAP_READ,
                           0,
                           0,
                           0);
        if (pV != NULL)
        {
            ULARGE_INTEGER ulFileSize;

            //  Get the file's size
            ulFileSize.LowPart = GetFileSize(hFile, &ulFileSize.HighPart);
            if (ulFileSize.LowPart == INVALID_FILE_SIZE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            } 
            else
            {
                switch (keyType)
                {
                    case KEY_PUBLIC:
                        //  PUBLIC: do NOT has the signature and blob.
                        ulFileSize.QuadPart -= sizeof(SIGNATURE_ON_DISK);
                        break;
                    case KEY_PRIVATE:
                        //  PRIVATE: hash everything.
                        break;
                    default:
                        ASSERTMSG(false, "Unknown key type passed to CThemeSignature::CreateKey");
                        break;
                }

                // Skip the PE Header
                ulFileSize.QuadPart -= SIZE_PE_HEADER;
                pV = (void *) (((BYTE *) pV) + SIZE_PE_HEADER);

                //  Add the data to the hash object. Protect the access to the
                //  mapped view with __try and __except. If an exception is
                //  thrown it's caught here where it's mapped to ERROR_OUTOFMEMORY.

                __try
                {
                    if (!CryptHashData(_hCryptHash,
                                      reinterpret_cast<BYTE*>(pV),
                                      ulFileSize.LowPart, 0))
                    {
                        hr = FixCryptoError(GetLastError());
                    }
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            TBOOL(UnmapViewOfFile(pV));
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        TBOOL(CloseHandle(hSection));
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeSignature::SignHash
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Signs the hash and generates a signature. The signature is
//              allocated and released in the destructor.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::SignHash(void)
{
    HRESULT hr = S_OK;

    if (CryptSignHash(_hCryptHash,
                      AT_SIGNATURE,
                      s_szDescription,
                      0,
                      NULL,
                      &_dwSignatureSize))
    {
        _pvSignature = LocalAlloc(LMEM_FIXED, _dwSignatureSize);
        if (_pvSignature != NULL)
        {
            if (!CryptSignHash(_hCryptHash,
                              AT_SIGNATURE,
                              s_szDescription,
                              0,
                              reinterpret_cast<BYTE*>(_pvSignature),
                              &_dwSignatureSize))
            {
                hr = FixCryptoError(GetLastError());
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = FixCryptoError(GetLastError());
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::ReadSignature
//
//  Arguments:  hFile           =   File to read signature from.
//              pvSignature     =   Buffer to read signature to.
//
//  Returns:    HRESULT
//
//  Purpose:    Reads the signature from the given file. The format is known
//              and this function will move the file pointer accordingly.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::ReadSignature(HANDLE hFile, void *pvSignature)
{
    HRESULT hr;
    DWORD dwErrorCode;
    ULARGE_INTEGER ulFileSize;

    ulFileSize.LowPart = GetFileSize(hFile, &ulFileSize.HighPart);
    if (ulFileSize.LowPart == INVALID_FILE_SIZE)
    {
       hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        LARGE_INTEGER           iPosition;
        SIGNATURE_BLOB_TAIL     signatureBlobTail;
        DWORD                   dwPtr;

        //  Move the file pointer to the end of the file less the size of the
        //  signature's tail blob so that we read that to verify the signature
        //  is present.
        iPosition.QuadPart = -static_cast<int>(sizeof(signatureBlobTail));
        dwPtr = SetFilePointer(hFile,
                               iPosition.LowPart,
                               &iPosition.HighPart,
                               FILE_END);
        if ((dwPtr != INVALID_SET_FILE_POINTER) || ((dwErrorCode = GetLastError()) == ERROR_SUCCESS))
        {
            DWORD   dwNumberOfBytesRead;

            //  Read the signature blob in from the end of the file.
            if (ReadFile(hFile,
                         &signatureBlobTail,
                         sizeof(signatureBlobTail),
                         &dwNumberOfBytesRead,
                         NULL))
            {

                //  Verify that the blob is what we expect it to be.
                if ((sizeof(signatureBlobTail) == dwNumberOfBytesRead) &&                       //  we were able to read the correct size
                    (VSSIGN_TAG == signatureBlobTail.dwTag) &&                                  //  it has our signature
                    (ulFileSize.QuadPart == signatureBlobTail.ulFileSize.QuadPart))      //  it is the same size
                {
                    iPosition.QuadPart = -static_cast<int>(sizeof(signatureBlobTail) + signatureBlobTail.dwSigSize);

                    ASSERT(sizeof(SIGNATURE) == signatureBlobTail.dwSigSize); // If this doesn't match, we need to dynamically allocate the size of the signature.

                    //  Set the file pointer back past the signature AND the blob.
                    dwPtr = SetFilePointer(hFile,
                                           iPosition.LowPart,
                                           &iPosition.HighPart,
                                           FILE_END);
                    if ((dwPtr != INVALID_SET_FILE_POINTER) || ((dwErrorCode = GetLastError()) == ERROR_SUCCESS))
                    {
                        //  Read the signature to the given buffer.
                        if (ReadFile(hFile,
                                     pvSignature,
                                     sizeof(SIGNATURE),
                                     &dwNumberOfBytesRead,
                                     NULL) != FALSE)
                        {
                            if (dwNumberOfBytesRead == sizeof(SIGNATURE))
                            {
                                hr = S_OK;
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                        }
                        else
                        {
                            dwErrorCode = GetLastError();
                            hr = HRESULT_FROM_WIN32(dwErrorCode);
                        }
                    }
                    else
                    {
                        // already filled in dwErrorCode in the if statement
                        hr = HRESULT_FROM_WIN32(dwErrorCode);
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                dwErrorCode = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErrorCode);
            }
        }
        else
        {
            // already filled in dwErrorCode in the if statement
            hr = HRESULT_FROM_WIN32(dwErrorCode);
        }
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::WriteSignature
//
//  Arguments:  pszFilename         =   File path to write signature to.
//              pvSignature         =   Signature to write.
//              dwSignatureSize     =   Size of signature to write.
//
//  Returns:    HRESULT
//
//  Purpose:    Opens the file WRITE. Moves the file pointer to the end of the
//              file and writes the signature AND blob out.
//
//              DESCRIPTION:
//              This function will write the signature from the file.  This is
//              the layout of the blob we add to the file:
//
//              Layout:
//              Start       End     Contents
//              0 byte      n Byte  The original file
//              n           n+m     Our signature (m bytes long, normally 128)
//              n+m         n+4+m   Our tag (VSSIGN_TAG)
//              n+4+m       n+8+m   'm', the size of our Signature.
//              n+8+m       n+16+m  The file size (n+m+16)   n is normally 16 bytes.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::WriteSignature(const WCHAR *pszFilename, const void *pvSignature, DWORD dwSignatureSize)
{
    HRESULT     hr = S_OK;
    DWORD       dwErrorCode;
    HANDLE      hFile;

    hFile = CreateFileW(pszFilename,
                        GENERIC_WRITE,
                        0,
                        0,
                        OPEN_EXISTING,
                        0,
                        0);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        LARGE_INTEGER   iPosition;
        DWORD           dwPtr;

        iPosition.QuadPart = 0;
        dwPtr = SetFilePointer(hFile,
                               iPosition.LowPart,
                               &iPosition.HighPart,
                               FILE_END);
        if ((dwPtr != INVALID_SET_FILE_POINTER) || ((dwErrorCode = GetLastError()) == ERROR_SUCCESS))
        {
            SIGNATURE_BLOB_TAIL     signatureBlobTail;

            signatureBlobTail.dwTag = VSSIGN_TAG;
            signatureBlobTail.dwSigSize = dwSignatureSize;

            signatureBlobTail.ulFileSize.LowPart = GetFileSize(hFile, &signatureBlobTail.ulFileSize.HighPart);
            if (signatureBlobTail.ulFileSize.LowPart == INVALID_FILE_SIZE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
            {
                DWORD   dwNumberOfBytesWritten;

                signatureBlobTail.ulFileSize.QuadPart += (sizeof(signatureBlobTail) + dwSignatureSize);
                if (WriteFile(hFile,
                              pvSignature,
                              dwSignatureSize,
                              &dwNumberOfBytesWritten,
                              NULL) != FALSE)
                {
                    if (!WriteFile(hFile,
                                  &signatureBlobTail,
                                  sizeof(signatureBlobTail),
                                  &dwNumberOfBytesWritten,
                                  NULL))
                    {
                        dwErrorCode = GetLastError();
                        hr = HRESULT_FROM_WIN32(dwErrorCode);
                    }
                }
                else
                {
                    dwErrorCode = GetLastError();
                    hr = HRESULT_FROM_WIN32(dwErrorCode);
                }
            }
        }
        else
        {
            // dwErrorCode already filled by if statement
            hr = HRESULT_FROM_WIN32(dwErrorCode);
        }
        TBOOL(CloseHandle(hFile));
    }
    else
    {
        dwErrorCode = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErrorCode);
    }

    return(hr);
}

//  --------------------------------------------------------------------------
//  CThemeSignature::CreateExportKey
//
//  Arguments:  dwBlobType  =   Blob type.
//              pvKey       =   Key data (returned).
//              dwKeySize   =   Key size (returned).
//
//  Returns:    HRESULT
//
//  Purpose:    Creates export keys for the given blob type. The caller must
//              released the returned buffer allocated.
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//              2000-09-10  vtan        convert to HRESULT (bryanst request)
//  --------------------------------------------------------------------------
HRESULT CThemeSignature::CreateExportKey(DWORD dwBlobType, void*& pvKey, DWORD& dwKeySize)
{
    HRESULT hr = S_OK;

    pvKey = NULL;
    dwKeySize = 0;
    if (CryptExportKey(_hCryptKey,
                       NULL,
                       dwBlobType,
                       0,
                       NULL,
                       &dwKeySize))
    {
        pvKey = LocalAlloc(LMEM_FIXED, dwKeySize);
        if (pvKey != NULL)
        {
            if (!CryptExportKey(_hCryptKey,
                               NULL,
                               dwBlobType,
                               0,
                               reinterpret_cast<BYTE*>(pvKey),
                               &dwKeySize))
            {
                LocalFree(pvKey);
                pvKey = NULL;
                dwKeySize = 0;
                hr = FixCryptoError(GetLastError());
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = FixCryptoError(GetLastError());
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CThemeSignature::PrintKey
//
//  Arguments:  pvKey       =   Key data.
//              dwKeySize   =   Key data size.
//
//  Returns:    <none>
//
//  Purpose:    Prints the key information out (presumably for debugging).
//
//  History:    2000-08-01  bryanst     created
//              2000-09-09  vtan        consolidated into a class
//  --------------------------------------------------------------------------

void CThemeSignature::PrintKey(const void *pvKey, DWORD dwKeySize)

{
    DWORD   dwIndex;

    for (dwIndex = 0; dwIndex < dwKeySize; ++dwIndex)
    {
        if (dwIndex != 0)
        {
            wprintf(L", ");
            if (0 == (dwIndex % 13))
            {
                wprintf(L"\n");     // Next line
            }
        }
        wprintf(L"0x%02X", static_cast<const BYTE*>(pvKey)[dwIndex]);
    }
    wprintf(L"\nSize: %d\n", dwKeySize);
}

//  --------------------------------------------------------------------------
//  CheckThemeFileSignature
//
//  Arguments:  Theme filename to check signature on.
//
//  Returns:    HRESULT
//
//  Purpose:    Flat function to reference guts of this module
//
//  History:    2000-09-28  rfernand        created
//  --------------------------------------------------------------------------
HRESULT CheckThemeFileSignature(LPCWSTR pszName)
{
    CThemeSignature themeSignature;

    HRESULT hr = themeSignature.Verify(pszName, false);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeldr\tmreg.cpp ===
//---------------------------------------------------------------------------
//  TmReg.cpp - theme manager registry access routines
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "TmReg.h"
#include "Utils.h"
//---------------------------------------------------------------------------

//  --------------------------------------------------------------------------
//  CCurrentUser::CCurrentUser
//
//  Arguments:  samDesired  =   Desired access to the HKEY.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CCurrentUser. This class transparently allows
//              access to HKEY_CURRENT_USER while impersonating a user.
//
//  History:    2000-08-11  vtan        created
//  --------------------------------------------------------------------------

CCurrentUser::CCurrentUser (REGSAM samDesired) :
    _hKeyCurrentUser(NULL)

{
    (BOOL)RegOpenCurrentUser(samDesired, &_hKeyCurrentUser);
}

//  --------------------------------------------------------------------------
//  CCurrentUser::~CCurrentUser
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CCurrentUser. Close opened resources.
//
//  History:    2000-08-11  vtan        created
//  --------------------------------------------------------------------------

CCurrentUser::~CCurrentUser (void)

{
    if (_hKeyCurrentUser != NULL)
    {
        (LONG)RegCloseKey(_hKeyCurrentUser);
        _hKeyCurrentUser = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CCurrentUser::operator HKEY
//
//  Arguments:  <none>
//
//  Returns:    HKEY
//
//  Purpose:    Magical C++ operator to convert object to HKEY.
//
//  History:    2000-08-11  vtan        created
//  --------------------------------------------------------------------------

CCurrentUser::operator HKEY (void)  const

{
    return(_hKeyCurrentUser);
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
HRESULT SetCurrentUserThemeString(LPCWSTR pszValueName, LPCWSTR pszValue)
{
    return SetCurrentUserString(THEMEMGR_REGKEY, pszValueName, pszValue);
}

//---------------------------------------------------------------------------
HRESULT SetCurrentUserThemeStringExpand(LPCWSTR pszValueName, LPCWSTR pszValue)
{
    WCHAR szResult[_MAX_PATH + 1];
    LPCWSTR pszPath = pszValue;

    if (UnExpandEnvironmentString(pszValue, L"%SystemRoot%", szResult, ARRAYSIZE(szResult)))
        pszPath = szResult;
    return SetCurrentUserThemeString(pszValueName, pszPath);
}

//---------------------------------------------------------------------------
HRESULT GetCurrentUserThemeString(LPCWSTR pszValueName, LPCWSTR pszDefaultValue,
    LPWSTR pszBuff, DWORD cchBuff)
{
    return GetCurrentUserString(THEMEMGR_REGKEY, pszValueName, pszDefaultValue, pszBuff, cchBuff);
}

//---------------------------------------------------------------------------
HRESULT SetCurrentUserString(LPCWSTR pszKeyName, LPCWSTR pszValueName, LPCWSTR pszValue)
{
    CCurrentUser    hKeyCurrentUser(KEY_READ | KEY_WRITE);

    RESOURCE HKEY tmkey = NULL;
    LONG code32;
    HRESULT hr = S_OK;

    if (! pszValue)
        pszValue = L"";

    //---- create or open existing key ----
    code32 = RegCreateKeyEx(hKeyCurrentUser, pszKeyName, NULL, NULL, 
        REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &tmkey, NULL);
    WIN32_EXIT(code32);

    //---- write key value ----
    DWORD len;
    len = sizeof(WCHAR)*(1+lstrlen(pszValue));

    DWORD dwValType;
    dwValType = REG_SZ;
    if (wcschr(pszValue, '%'))
        dwValType = REG_EXPAND_SZ;

    code32 = RegSetValueEx(tmkey, pszValueName, NULL, dwValType, (BYTE *)pszValue, len);
    WIN32_EXIT(code32);

exit:
    RegCloseKey(tmkey);
    return hr;
}

//---------------------------------------------------------------------------
BOOL IsRemoteThemeDisabled()
{
    //---- has Terminal Server written a special key to turn themes off ----
    //---- for this session? ----

    CCurrentUser hKeyCurrentUser(KEY_READ | KEY_WRITE);
    BOOL fDisabled = FALSE;

    BOOL fRemote = GetSystemMetrics(SM_REMOTESESSION);
    if (fRemote)        // running TS remote session
    {
        //---- build the remote key name ----
        WCHAR szKeyName[MAX_PATH];

        StringCchPrintfW(szKeyName, ARRAYSIZE(szKeyName), L"%s\\Remote\\%d", THEMEMGR_REGKEY, NtCurrentPeb()->SessionId);

        //---- see if the root key exists ----
        HKEY tmkey;
        LONG code32 = RegOpenKeyEx(hKeyCurrentUser, szKeyName, NULL, KEY_QUERY_VALUE,
            &tmkey);
        if (code32 == ERROR_SUCCESS)
        {
            fDisabled = TRUE;     // key itself is sufficient
            RegCloseKey(tmkey);
        }
    }

    return fDisabled;
}
//---------------------------------------------------------------------------
HRESULT GetCurrentUserString(LPCWSTR pszKeyName, LPCWSTR pszValueName, LPCWSTR pszDefaultValue,
    LPWSTR pszBuff, DWORD cchBuff)
{
    CCurrentUser    hKeyCurrentUser(KEY_READ | KEY_WRITE);

    HRESULT hr = S_OK;
    LONG code32;
    RESOURCE HKEY tmkey = NULL;

    if (! pszBuff)
        return MakeError32(E_INVALIDARG);

    DWORD dwByteSize = cchBuff * sizeof(WCHAR);      
    DWORD dwValType = 0;

    code32 = RegOpenKeyEx(hKeyCurrentUser, pszKeyName, NULL, KEY_QUERY_VALUE,
        &tmkey);
    if (code32 == ERROR_SUCCESS)
    {
        code32 = RegQueryValueEx(tmkey, pszValueName, NULL, &dwValType, (BYTE *)pszBuff, 
            &dwByteSize);
    }

    if (code32 != ERROR_SUCCESS)        // error - use default value
    {
        hr = SafeStringCchCopyW(pszBuff, cchBuff, pszDefaultValue);
        if (FAILED(hr))
            goto exit;
    }

    if (dwValType == REG_EXPAND_SZ || wcschr(pszBuff, L'%'))
    {
        int cchTempBuff = (1 + lstrlen(pszBuff));
        LPWSTR pszTempBuff = new WCHAR[cchTempBuff];
        if (pszTempBuff)
        {
            StringCchCopyW(pszTempBuff, cchTempBuff, pszBuff);

            DWORD dwChars = ExpandEnvironmentStrings(pszTempBuff, pszBuff, cchBuff);
            if (dwChars > cchBuff)           // caller's buffer too small
            {
                hr = MakeError32(ERROR_INSUFFICIENT_BUFFER);
                goto exit;
            }

            delete [] pszTempBuff;
        }
    }

exit:
    RegCloseKey(tmkey);

    return hr;
}

//---------------------------------------------------------------------------
HRESULT GetCurrentUserThemeInt(LPCWSTR pszValueName, int iDefaultValue, int *piValue)
{
    CCurrentUser    hKeyCurrentUser(KEY_READ | KEY_WRITE);

    LONG code32;

    if (! piValue)
        return MakeError32(E_INVALIDARG);

    TCHAR valbuff[_MAX_PATH+1];
    DWORD dwByteSize = sizeof(valbuff);
    RESOURCE HKEY tmkey = NULL;

    code32 = RegOpenKeyEx(hKeyCurrentUser, THEMEMGR_REGKEY, NULL, KEY_QUERY_VALUE,
        &tmkey);
    if (code32 == ERROR_SUCCESS)
    {
        DWORD dwValType;
        code32 = RegQueryValueEx(tmkey, pszValueName, NULL, &dwValType, 
            (BYTE *)valbuff, &dwByteSize);
    }

    if (code32 != ERROR_SUCCESS)        // call failed - use default value
        *piValue = iDefaultValue;
    else
    {
        *piValue = string2number(valbuff);
    }

    RegCloseKey(tmkey);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT SetCurrentUserThemeInt(LPCWSTR pszValueName, int iValue)
{
    CCurrentUser    hKeyCurrentUser(KEY_READ | KEY_WRITE);

    TCHAR valbuff[_MAX_PATH+1];
    RESOURCE HKEY tmkey = NULL;
    LONG code32;
    HRESULT hr = S_OK;

    //---- create or open existing key ----
    code32 = RegCreateKeyEx(hKeyCurrentUser, THEMEMGR_REGKEY, NULL, NULL, 
        REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &tmkey, NULL);
    WIN32_EXIT(code32);

    //---- write key value ----
    StringCchPrintfW(valbuff, ARRAYSIZE(valbuff), L"%d", iValue);
    DWORD len;
    len = sizeof(TCHAR)*(1+lstrlen(valbuff));

    code32 = RegSetValueEx(tmkey, pszValueName, NULL, REG_SZ, 
        (BYTE *)valbuff, len);
    WIN32_EXIT(code32);

exit:
    RegCloseKey(tmkey);
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT DeleteCurrentUserThemeValue(LPCWSTR pszKeyName)
{
    CCurrentUser    hKeyCurrentUser(KEY_WRITE);

    RESOURCE HKEY tmkey = NULL;
    LONG code32;
    HRESULT hr = S_OK;

    //---- create or open existing key ----
    code32 = RegCreateKeyEx(hKeyCurrentUser, THEMEMGR_REGKEY, NULL, NULL, 
        REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &tmkey, NULL);
    WIN32_EXIT(code32);
    
    code32 = RegDeleteValue(tmkey, pszKeyName);
    WIN32_EXIT(code32);

exit:
    RegCloseKey(tmkey);
    return hr;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeldr\tmutils.cpp ===
//-------------------------------------------------------------------------
//	TmUtils.cpp - theme manager shared utilities
//-------------------------------------------------------------------------
#include "stdafx.h"
#include "TmUtils.h"
#include "ThemeFile.h"
#include "loader.h"
//-------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
CMemoryDC::CMemoryDC()
{
    _hBitmap = NULL;
    _hdc = NULL;
    _hOldBitmap = NULL;
}
//-------------------------------------------------------------------------
CMemoryDC::~CMemoryDC()
{
    CloseDC();
}
//-------------------------------------------------------------------------
HRESULT CMemoryDC::OpenDC(HDC hdcSource, int iWidth, int iHeight)
{
    HRESULT hr;
    BOOL fDeskDC = FALSE;

    if (! hdcSource)
    {
        hdcSource = GetWindowDC(NULL);
        if (! hdcSource)
        {
            hr = MakeErrorLast();
            goto exit;
        }
        fDeskDC = TRUE;
    }

    _hBitmap = CreateCompatibleBitmap(hdcSource, iWidth, iHeight);
    if (! _hBitmap)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    _hdc = CreateCompatibleDC(hdcSource);
    if (! _hdc)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    _hOldBitmap = (HBITMAP) SelectObject(_hdc, _hBitmap);
    if (! _hOldBitmap)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    hr = S_OK;

exit:
    if (fDeskDC)
        ReleaseDC(NULL, hdcSource);

    if (FAILED(hr))
        CloseDC();

    return hr;
}
//-------------------------------------------------------------------------
void CMemoryDC::CloseDC()
{
    if (_hOldBitmap)
    {
        SelectObject(_hdc, _hOldBitmap);
        _hOldBitmap = NULL;
    }

    if (_hdc)
    {
        DeleteDC(_hdc);
        _hdc = NULL;
    }

    if (_hBitmap)
    {
        DeleteObject(_hBitmap);
        _hBitmap = NULL;
    }
}
//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
CBitmapPixels::CBitmapPixels()
{
    _hdrBitmap = NULL;
    _buffer = NULL;
    _iWidth = 0;
    _iHeight = 0;
}
//-------------------------------------------------------------------------
CBitmapPixels::~CBitmapPixels()
{
    if (_buffer)
	    delete [] (BYTE *)_buffer;
}
//-------------------------------------------------------------------------
BYTE* CBitmapPixels::Buffer()
{
    return _buffer;
}
//-------------------------------------------------------------------------
HRESULT CBitmapPixels::OpenBitmap(HDC hdc, HBITMAP bitmap, BOOL fForceRGB32,
    DWORD OUT **pPixels, OPTIONAL OUT int *piWidth, OPTIONAL OUT int *piHeight, 
    OPTIONAL OUT int *piBytesPerPixel, OPTIONAL OUT int *piBytesPerRow, 
    OPTIONAL OUT int *piPreviousBytesPerPixel, OPTIONAL UINT cbBytesBefore)
{
    if (! pPixels)
        return MakeError32(E_INVALIDARG);

    bool fNeedRelease = false;

    if (! hdc)
    {
        hdc = GetWindowDC(NULL);
        if (! hdc)
        {
            return MakeErrorLast();
        }

        fNeedRelease = true;
    }

	BITMAP bminfo;
	
    GetObject(bitmap, sizeof(bminfo), &bminfo);
	_iWidth = bminfo.bmWidth;
	_iHeight = bminfo.bmHeight;

    int iBytesPerPixel;

    if (piPreviousBytesPerPixel != NULL)
    {
        *piPreviousBytesPerPixel = bminfo.bmBitsPixel / 8;
    }

    if ((fForceRGB32) || (bminfo.bmBitsPixel == 32)) 
        iBytesPerPixel = 4;
    else
        iBytesPerPixel = 3;
    
    int iRawBytes = _iWidth * iBytesPerPixel;
    int iBytesPerRow = 4*((iRawBytes+3)/4);

	int size = sizeof(BITMAPINFOHEADER) + _iHeight*iBytesPerRow;
	_buffer = new BYTE[size + cbBytesBefore + 100];    // avoid random GetDIBits() failures with 100 bytes padding (?)
    if (! _buffer)
        return MakeError32(E_OUTOFMEMORY);

	_hdrBitmap = (BITMAPINFOHEADER *)(_buffer + cbBytesBefore);
	memset(_hdrBitmap, 0, sizeof(BITMAPINFOHEADER));

	_hdrBitmap->biSize = sizeof(BITMAPINFOHEADER);
	_hdrBitmap->biWidth = _iWidth;
	_hdrBitmap->biHeight = _iHeight;
	_hdrBitmap->biPlanes = 1;
    _hdrBitmap->biBitCount = static_cast<WORD>(8*iBytesPerPixel);
	_hdrBitmap->biCompression = BI_RGB;     
	
#ifdef  DEBUG
    int linecnt = 
#endif
    GetDIBits(hdc, bitmap, 0, _iHeight, DIBDATA(_hdrBitmap), (BITMAPINFO *)_hdrBitmap, 
        DIB_RGB_COLORS);
    ATLASSERT(linecnt == _iHeight);

    if (fNeedRelease)
        ReleaseDC(NULL, hdc);

	*pPixels = (DWORD *)DIBDATA(_hdrBitmap);

    if (piWidth)
        *piWidth = _iWidth;
    if (piHeight)
        *piHeight = _iHeight;

    if (piBytesPerPixel)
        *piBytesPerPixel = iBytesPerPixel;
    if (piBytesPerRow)
        *piBytesPerRow = iBytesPerRow;

    return S_OK;
}
//-------------------------------------------------------------------------
void CBitmapPixels::CloseBitmap(HDC hdc, HBITMAP hBitmap)
{
    if (_hdrBitmap && _buffer)
    {
        if (hBitmap)        // rewrite bitmap
        {
            bool fNeedRelease = false;

            if (! hdc)
            {
                hdc = GetWindowDC(NULL);
                fNeedRelease = true;
            }

            SetDIBits(hdc, hBitmap, 0, _iHeight, DIBDATA(_hdrBitmap), (BITMAPINFO *)_hdrBitmap,
                DIB_RGB_COLORS);
        
            if ((fNeedRelease) && (hdc))
                ReleaseDC(NULL, hdc);
        }

	    delete [] (BYTE *)_buffer;
        _hdrBitmap = NULL;
        _buffer = NULL;
    }
}
//-------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
HRESULT LoadThemeLibrary(LPCWSTR pszThemeName, HINSTANCE *phInst)
{
    HRESULT hr = S_OK;
    HINSTANCE hInst = NULL;

    hInst = LoadLibraryEx(pszThemeName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (! hInst)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    //---- is this version supported? ----
    void *pvVersion;
    DWORD dwVersionLength;
    hr = GetPtrToResource(hInst, L"PACKTHEM_VERSION", MAKEINTRESOURCE(1), &pvVersion, &dwVersionLength);
    if (SUCCEEDED(hr))
    {
        if (dwVersionLength != sizeof(SHORT))
            hr = E_FAIL;
        else
        {
            SHORT sVersionNum = *(SHORT *)pvVersion;
            if (sVersionNum != PACKTHEM_VERSION)
                hr = E_FAIL;
        }
    }

    if (FAILED(hr))
    {
        hr = MakeError32(ERROR_BAD_FORMAT);
        goto exit;
    }

    *phInst = hInst;

exit:
    if (FAILED(hr))
    {
        if (hInst)
            FreeLibrary(hInst);
    }

    return hr;
}
//---------------------------------------------------------------------------
LPCWSTR ThemeString(CUxThemeFile *pThemeFile, int iOffset)
{
    LPCWSTR p = L"";

    if ((pThemeFile) && (pThemeFile->_pbThemeData) && (iOffset > 0))
    {
        p = (LPCWSTR) (pThemeFile->_pbThemeData + iOffset);
    }

    return p;
}
//---------------------------------------------------------------------------
int GetLoadIdFromTheme(CUxThemeFile *pThemeFile)
{
    int iLoadId = 0;

    if (pThemeFile)
    {
        THEMEHDR *hdr = (THEMEHDR *)pThemeFile->_pbThemeData;
        iLoadId = hdr->iLoadId;
    }

    return iLoadId;
}
//---------------------------------------------------------------------------
HRESULT GetThemeNameId(CUxThemeFile *pThemeFile, LPWSTR pszFileNameBuff, UINT cchFileNameBuff,
    LPWSTR pszColorParam, UINT cchColorParam, LPWSTR pszSizeParam, UINT cchSizeParam, int *piSysMetricsOffset, LANGID *pwLangID)
{
    HRESULT hr = S_OK;
    THEMEHDR *hdr = (THEMEHDR *)pThemeFile->_pbThemeData;

    if (piSysMetricsOffset)
        *piSysMetricsOffset = hdr->iSysMetricsOffset;

    if (pszFileNameBuff)
    {
        hr = SafeStringCchCopyW(pszFileNameBuff, cchFileNameBuff, ThemeString(pThemeFile, hdr->iDllNameOffset));
    }

    if (SUCCEEDED(hr) && pszColorParam)
    {
        hr = SafeStringCchCopyW(pszColorParam, cchColorParam, ThemeString(pThemeFile, hdr->iColorParamOffset));
    }

    if (SUCCEEDED(hr) && pszSizeParam)
    {
        hr = SafeStringCchCopyW(pszSizeParam, cchSizeParam, ThemeString(pThemeFile, hdr->iSizeParamOffset) );
    }

    if (SUCCEEDED(hr) && pwLangID)
        *pwLangID = (LANGID) hdr->dwLangID;

    return hr;
}
//---------------------------------------------------------------------------
BOOL ThemeMatch (CUxThemeFile *pThemeFile, LPCWSTR pszThemeName, LPCWSTR pszColorName, LPCWSTR pszSizeName, LANGID wLangID)
{
    WCHAR   szThemeFileName[MAX_PATH];
    WCHAR   szColorParam[MAX_PATH];
    WCHAR   szSizeParam[MAX_PATH];
    LANGID  wThemeLangID = 0;
    bool    bLangMatch = true;

    HRESULT hr = GetThemeNameId(pThemeFile, 
        szThemeFileName, ARRAYSIZE(szThemeFileName), 
        szColorParam, ARRAYSIZE(szColorParam),
        szSizeParam, ARRAYSIZE(szSizeParam), NULL, &wThemeLangID);

    if (wLangID != 0 && ((wThemeLangID != wLangID) || (wLangID != GetUserDefaultUILanguage())))
    {
        Log(LOG_TMLOAD, L"UxTheme: Reloading theme because of language change.");
        Log(LOG_TMLOAD, L"UxTheme: User LangID=0x%x, current theme=0x%x, LastUserLangID=0x%x", GetUserDefaultUILanguage(), wThemeLangID, wLangID);
        bLangMatch = false;
    }

    if( bLangMatch )
    {
        if( SUCCEEDED(hr) )
        {
            int iCmpTheme, iCmpColor, iCmpSize;

            if( SUCCEEDED(SafeStringCmpIW( pszThemeName, szThemeFileName, ARRAYSIZE(szThemeFileName), &iCmpTheme )) &&
                SUCCEEDED(SafeStringCmpIW( pszColorName, szColorParam, ARRAYSIZE(szColorParam), &iCmpColor )) &&
                SUCCEEDED(SafeStringCmpIW( pszSizeName,  szSizeParam, ARRAYSIZE(szSizeParam), &iCmpSize )) )
            {
                return 0 == iCmpTheme &&
                       0 == iCmpColor &&
                       0 == iCmpSize;
            }
        }
    }

    return FALSE;
}
//---------------------------------------------------------------------------
HRESULT GetColorSchemeIndex(HINSTANCE hInst, LPCWSTR pszColor, int *piIndex)
{
    HRESULT hr;
    WCHAR szColor[_MAX_PATH+1];

    for (int i=0; i < 1000; i++)
    {
        hr = GetResString(hInst, L"COLORNAMES", i, szColor, ARRAYSIZE(szColor));
        if (FAILED(hr))
            break;
        
        int iCmpColor;
        if( SUCCEEDED(SafeStringCmpIW( pszColor, szColor, ARRAYSIZE(szColor), &iCmpColor)) && 
            0 == iCmpColor )
        {
            *piIndex = i;
            return S_OK;
        }
    }

    return MakeError32(ERROR_NOT_FOUND);      // not found
}
//---------------------------------------------------------------------------
HRESULT GetSizeIndex(HINSTANCE hInst, LPCWSTR pszSize, int *piIndex)
{
    HRESULT hr;
    WCHAR szSize[_MAX_PATH+1];

    for (int i=0; i < 1000; i++)
    {
        hr = GetResString(hInst, L"SIZENAMES", i, szSize, ARRAYSIZE(szSize));
        if (FAILED(hr))
            break;

        int iCmpSize;
        if( SUCCEEDED(SafeStringCmpIW( pszSize, szSize, ARRAYSIZE(szSize), &iCmpSize)) && 
            0 == iCmpSize )
        {
            *piIndex = i;
            return S_OK;
        }
    }

    return MakeError32(ERROR_NOT_FOUND);      // not found
}
//---------------------------------------------------------------------------
HRESULT FindComboData(HINSTANCE hDll, COLORSIZECOMBOS **ppCombos)
{
    HRSRC hRsc = FindResource(hDll, L"COMBO", L"COMBODATA");
    if (! hRsc)
        return MakeErrorLast();

    HGLOBAL hGlobal = LoadResource(hDll, hRsc);
    if (! hGlobal)
        return MakeErrorLast();

    *ppCombos = (COLORSIZECOMBOS *)LockResource(hGlobal);
    if (! *ppCombos)
        return MakeErrorLast();

    return S_OK;
}
//---------------------------------------------------------------------------
BOOL FormatLocalMsg(HINSTANCE hInst, int iStringNum, 
    LPWSTR pszMessageBuff, DWORD cchMessageBuff, DWORD *pdwParams, TMERRINFO *pErrInfo)
{
    BOOL fGotMsg = FALSE;
    WCHAR szBuff[_MAX_PATH+1];
    WCHAR *p;

    //----- get string from string table ----
    if (LoadString(hInst, iStringNum, szBuff, ARRAYSIZE(szBuff)))
    {
        //---- repl %1 or %2 with %s ----
        p = szBuff;
        while (*p)
        {
            if (*p == '%')
            {
                p++;
                if ((*p == '1') || (*p == '2'))
                    *p = 's';
                p++;
            }
            else 
                p++;
        }

        int len = lstrlen(szBuff);
        if (len)
        {
            StringCchPrintfW(pszMessageBuff, cchMessageBuff, szBuff, pErrInfo->szMsgParam1, pErrInfo->szMsgParam2);
            fGotMsg = TRUE;
        }
    }

    return fGotMsg;
}
//---------------------------------------------------------------------------
HRESULT _FormatParseMessage(TMERRINFO *pErrInfo,
    OUT LPWSTR pszMessageBuff, DWORD cchMessageBuff)
{
    LogEntry(L"_FormatParseMessage");

    HRESULT hr = S_OK;

    DWORD dwParams[] = {PtrToInt(pErrInfo->szMsgParam1), PtrToInt(pErrInfo->szMsgParam2)};
    DWORD dwCode = pErrInfo->dwParseErrCode;
    BOOL fGotMsg = FALSE;

    int iStringNum = SCODE_CODE(dwCode);

    //---- get process name (see if we are "packthem.exe" ----
    WCHAR szPath[MAX_PATH];
    if (! GetModuleFileNameW( NULL, szPath, ARRAYSIZE(szPath) ))
        goto exit;

    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBase[_MAX_FNAME], szExt[_MAX_EXT];
    _wsplitpath(szPath, szDrive, szDir, szBase, szExt);

    if (lstrcmpi(szBase, L"packthem")==0)       // give packthem priority
    {
        fGotMsg = FormatLocalMsg(GetModuleHandle(NULL), iStringNum, 
            pszMessageBuff, cchMessageBuff, dwParams, pErrInfo);
    }

    if (! fGotMsg)      // try normal route: uxtheme.dll
    {
        HINSTANCE hInst = LoadLibrary(L"uxtheme.dll");
        if (! hInst)
        {
            Log(LOG_ALWAYS, L"_FormatParseMessage: Could not load uxtheme.dll");
            hr = E_FAIL;
            goto exit;
        }

        fGotMsg = FormatLocalMsg(hInst, iStringNum, 
            pszMessageBuff, cchMessageBuff, dwParams, pErrInfo);
        FreeLibrary(hInst);
    }

    if (! fGotMsg)
        hr = MakeErrorLast();

exit:
    LogExit(L"_FormatParseMessage");
    return hr;
}
//---------------------------------------------------------------------------
HRESULT _GetThemeParseErrorInfo(OUT PARSE_ERROR_INFO *pInfo)
{
    LogEntry(L"_GetThemeParseErrorInfo");

    HRESULT hr = S_OK;

    if (pInfo->dwSize != sizeof(PARSE_ERROR_INFO))        // unsupported size
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    TMERRINFO *pErrInfo = GetParseErrorInfo(TRUE);
    if (! pErrInfo)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    //---- convert code into msg using param strings ----
    hr = _FormatParseMessage(pErrInfo, pInfo->szMsg, ARRAYSIZE(pInfo->szMsg));
    if (FAILED(hr))
        goto exit;

    //---- transfer the other info ----
    pInfo->dwParseErrCode = pErrInfo->dwParseErrCode;
    pInfo->iLineNum = pErrInfo->iLineNum;

    StringCchCopyW(pInfo->szFileName, ARRAYSIZE(pInfo->szFileName), pErrInfo->szFileName);
    StringCchCopyW(pInfo->szSourceLine, ARRAYSIZE(pInfo->szSourceLine), pErrInfo->szSourceLine);

exit:
    LogExit(L"_GetThemeParseErrorInfo");
    return hr;
}
//---------------------------------------------------------------------------
HRESULT _ParseThemeIniFile(LPCWSTR pszFileName,  
    DWORD dwParseFlags, OPTIONAL THEMEENUMPROC pfnCallBack, OPTIONAL LPARAM lparam) 
{
    LogEntry(L"ParseThemeIniFile");
    HRESULT hr;

    CThemeParser *pParser = new CThemeParser;
    if (! pParser)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    hr = pParser->ParseThemeFile(pszFileName, NULL, NULL, pfnCallBack, lparam, 
        dwParseFlags);

    delete pParser;

exit:
    LogExit(L"ParseThemeIniFile");
    return hr; 
}
//---------------------------------------------------------------------------
BOOL ThemeLibStartUp(BOOL fThreadAttach)
{
    BOOL fInit = FALSE;

    if (fThreadAttach)
    {
        //---- nothing to do here ----
    }
    else        // process
    {
        _tls_ErrorInfoIndex = TlsAlloc();
        if (_tls_ErrorInfoIndex == (DWORD)-1)
            goto exit;

        if (! LogStartUp())
            goto exit;
        
        if (! UtilsStartUp())
            goto exit;
    }
    fInit = TRUE;

exit:
    return fInit;
}
//---------------------------------------------------------------------------
BOOL ThemeLibShutDown(BOOL fThreadDetach)
{
    if (fThreadDetach)
    {
        //---- destroy the thread-local Error Info ----
        TMERRINFO * ei = GetParseErrorInfo(FALSE);
        if (ei)
        {
            TlsSetValue(_tls_ErrorInfoIndex, NULL);
            delete ei;
        }
    }
    else            // process
    {
        UtilsShutDown();
        LogShutDown();

        if (_tls_ErrorInfoIndex != (DWORD)-1)
        {
            TlsFree(_tls_ErrorInfoIndex);
            _tls_ErrorInfoIndex = (DWORD)-1;
        }
    }

    return TRUE;
}
//---------------------------------------------------------------------------
HRESULT GetThemeSizeId(int iSysSizeId, int *piThemeSizeId)
{
    HRESULT hr = S_OK;
    
    *piThemeSizeId = 0;

    switch (iSysSizeId)
    {
        case SM_CXSIZEFRAME:
            *piThemeSizeId = TMT_SIZINGBORDERWIDTH;
            break;

        case SM_CYSIZEFRAME:
            *piThemeSizeId = TMT_SIZINGBORDERWIDTH;
            break;

        case SM_CXVSCROLL:
            *piThemeSizeId = TMT_SCROLLBARWIDTH;
            break;

        case SM_CYHSCROLL:
            *piThemeSizeId = TMT_SCROLLBARHEIGHT;
            break;

        case SM_CXSIZE:
            *piThemeSizeId = TMT_CAPTIONBARWIDTH;
            break;

        case SM_CYSIZE:
            *piThemeSizeId = TMT_CAPTIONBARHEIGHT;
            break;

        case SM_CXSMSIZE:
            *piThemeSizeId = TMT_SMCAPTIONBARWIDTH;
            break;

        case SM_CYSMSIZE:
            *piThemeSizeId = TMT_SMCAPTIONBARHEIGHT;
            break;

        case SM_CXMENUSIZE:
            *piThemeSizeId = TMT_MENUBARWIDTH;
            break;

        case SM_CYMENUSIZE:
            *piThemeSizeId = TMT_MENUBARHEIGHT;
            break;

        default:
            hr = MakeError32(E_INVALIDARG);
            break;
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT _EnumThemeSizes(HINSTANCE hInst, LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszColorScheme, DWORD dwSizeIndex, OUT THEMENAMEINFO *ptn, BOOL fCheckColorDepth)
{
    HRESULT hr;

    COLORSIZECOMBOS *combos;
    hr = FindComboData(hInst, &combos);
    if (FAILED(hr))
        goto exit;

    int iMinColor,  iMaxColor;
    iMinColor = 0;
    iMaxColor = combos->cColorSchemes-1;

    if (pszColorScheme)       // translate "pszColorScheme" into a color number
    {
        int index;

        hr = GetColorSchemeIndex(hInst, pszColorScheme, &index);
        if (FAILED(hr))
            goto exit;
        
        //---- restrict our search to just this color ----
        iMinColor = index;
        iMaxColor = index;
    }

    int s, c;
    DWORD dwSizeNum;
    dwSizeNum = 0;
    BOOL gotall;
    gotall = FALSE;

    DWORD dwCurMinDepth = 0;
        
    if (fCheckColorDepth)
    {
        dwCurMinDepth = MinimumDisplayColorDepth();
    }

    for (s=0; s < combos->cSizes; s++)
    {
        BOOL fFoundOne = FALSE;

        for (c=iMinColor; c <= iMaxColor; c++)
        {
            if (COMBOENTRY(combos, c, s) != -1)
            {
                fFoundOne = TRUE;
                break;
            }
        }

        if (fFoundOne && (!fCheckColorDepth || CheckMinColorDepth(hInst, dwCurMinDepth, COMBOENTRY(combos, c, s))))
        {
            if (dwSizeNum++ == dwSizeIndex)
            {
                hr = GetResString(hInst, L"SIZENAMES", s, ptn->szName, ARRAYSIZE(ptn->szName));
                if (FAILED(hr))
                    *ptn->szName = 0;
            
                if (! LoadString(hInst, s+RES_BASENUM_SIZEDISPLAYS, ptn->szDisplayName, ARRAYSIZE(ptn->szDisplayName)))
                    *ptn->szDisplayName = 0;

                if (! LoadString(hInst, s+RES_BASENUM_SIZETOOLTIPS, ptn->szToolTip, ARRAYSIZE(ptn->szToolTip)))
                    *ptn->szToolTip = 0;
        
                gotall = TRUE;
                break;
            }
        }
    }

    if ((SUCCEEDED(hr)) && (! gotall))
        hr = MakeError32(ERROR_NOT_FOUND);

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT _EnumThemeColors(HINSTANCE hInst, LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszSizeName, DWORD dwColorIndex, OUT THEMENAMEINFO *ptn, BOOL fCheckColorDepth)
{
    HRESULT hr;

    COLORSIZECOMBOS *combos;
    hr = FindComboData(hInst, &combos);
    if (FAILED(hr))
        goto exit;

    int iMinSize,  iMaxSize;
    iMinSize = 0;
    iMaxSize = combos->cSizes-1;

    if (pszSizeName)       // translate "pszSizeName" into a size number
    {
        int index;

        hr = GetSizeIndex(hInst, pszSizeName, &index);
        if (FAILED(hr))
            goto exit;

        //---- restrict our search to just this size ----
        iMinSize = index;
        iMaxSize = index;
    }

    int s, c;
    DWORD dwColorNum;
    dwColorNum = 0;

    BOOL gotall;
    gotall = FALSE;

    DWORD dwCurMinDepth = 0;
        
    if (fCheckColorDepth)
    {
        dwCurMinDepth = MinimumDisplayColorDepth();
    }

    for (c=0; c < combos->cColorSchemes; c++)
    {
        BOOL fFoundOne = FALSE;

        for (s=iMinSize; s <= iMaxSize; s++)
        {
            if (COMBOENTRY(combos, c, s) != -1)
            {
                fFoundOne = TRUE;
                break;
            }
        }

        if (fFoundOne && (!fCheckColorDepth || CheckMinColorDepth(hInst, dwCurMinDepth, COMBOENTRY(combos, c, s))))
        {
            if (dwColorNum++ == dwColorIndex)
            {
                hr = GetResString(hInst, L"COLORNAMES", c, ptn->szName, ARRAYSIZE(ptn->szName));
                if (FAILED(hr))
                    *ptn->szName = 0;

                if (! LoadString(hInst, c+RES_BASENUM_COLORDISPLAYS, ptn->szDisplayName, ARRAYSIZE(ptn->szDisplayName)))
                    *ptn->szDisplayName = 0;

                if (! LoadString(hInst, c+RES_BASENUM_COLORTOOLTIPS, ptn->szToolTip, ARRAYSIZE(ptn->szToolTip)))
                    *ptn->szToolTip = 0;

                gotall = true;
                break;
            }
        }
    }

    if ((SUCCEEDED(hr)) && (! gotall))
        hr = MakeError32(ERROR_NOT_FOUND);

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themesel\main.cpp ===
//-------------------------------------------------------------------------//
// main.cpp
//-------------------------------------------------------------------------//
#include "pch.h"
#include "resource.h"
#include "main.h"
#include "pageinfo.h"
#include "tmreg.h"
#include "themeldr.h"
//-------------------------------------------------------------------------//
#define MAX_LOADSTRING 100
#define THEMESEL_WNDCLASS   TEXT("ThemeSelWnd")

//-------------------------------------------------------------------------//
class CWndBase
//-------------------------------------------------------------------------//
{
public:
    CWndBase()             { Detach(); }
    virtual ~CWndBase()    { Detach(); }
    
    BOOL Attach( HWND hwnd );
    void Detach()   { _hwnd = NULL; }
    operator HWND() { return _hwnd; }

    virtual void RepositionChildren( BOOL fCalcScroll, int cx = -1, int cy = -1) {}

protected:
    HWND _hwnd;
};

//-------------------------------------------------------------------------//
inline BOOL CWndBase::Attach( HWND hwnd )  {
    if( IsWindow( hwnd ) ) {
        _hwnd = hwnd; 
        return TRUE;
    }
    return FALSE;
};

//-------------------------------------------------------------------------//
class CChildTabWnd : public CWndBase
//-------------------------------------------------------------------------//
{
public:
    CChildTabWnd()
        :   _prgPages(0), 
            _cPages(0), 
            _iCurPage(-1), 
            _rghwndPages(NULL), 
            _rgrcPages(NULL) {}

    ~CChildTabWnd() { delete [] _rghwndPages; delete [] _rgrcPages; }

    HWND Create( DWORD dwExStyle, DWORD dwStyle,
                 const RECT& rc, HWND  hwndParent, UINT nID,
                 HINSTANCE hInst, LPVOID pvParam );

    int  CreatePages( const PAGEINFO rgPages[], int cPages );
    BOOL ShowPage( int iPage );
    HWND GetCurPage();
    BOOL GetCurPageRect( LPRECT prc );
    BOOL GetExtent( SIZE* psizeExtent );

    BOOL HandleNotify( NMHDR* pnmh, LRESULT* plRet );

    BOOL TranslateAccelerator( HWND, LPMSG );
    virtual void RepositionChildren( BOOL fCalcScroll, int cx = -1, int cy = -1);

private:
    const PAGEINFO* _prgPages;
    HWND*           _rghwndPages;   // page HWNDs
    RECT*           _rgrcPages;     // native page window size
    int             _cPages;
    int             _iCurPage;
};

//-------------------------------------------------------------------------//
class CMainWnd : public CWndBase
//-------------------------------------------------------------------------//
{
public:
    CMainWnd()
    {
        ZeroMemory( &_siVert, sizeof(_siVert) ); 
        ZeroMemory( &_siHorz, sizeof(_siHorz) ); 
    }
    ~CMainWnd() {}
    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
    void                    RepositionChildren( BOOL fCalcScroll, int cx = -1, int cy = -1);
    void                    Scroll( WPARAM wParam, int nBar );
    BOOL                    TranslateAccelerator( HWND hwnd, LPMSG pmsg)    {
                                return _wndTab.TranslateAccelerator( hwnd, pmsg );
                            }

    CChildTabWnd _wndTab;
    SCROLLINFO   _siVert;
    SCROLLINFO   _siHorz;

} _wndMain;

//-------------------------------------------------------------------------//
// Foward declarations of functions included in this code module:
ATOM                _RegisterWndClasses(HINSTANCE hInstance);
BOOL                _InitInstance(HINSTANCE, int);
BOOL                _InitThemeOptions( HINSTANCE, LPCTSTR lpCmdLine, BOOL* pfDone );
BOOL                _FoundPrevInstance( LPCWSTR lpCmdLine );
LRESULT CALLBACK    _MainWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    _NilDlgProc( HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    _AboutDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    _SyntaxDlgProc(HWND, UINT, WPARAM, LPARAM);

//-------------------------------------------------------------------------//
// Global vars:
HINSTANCE        g_hInst = NULL;                    // module handle
TCHAR            g_szAppTitle[MAX_LOADSTRING] = {0};  // app title
int              g_iCurPage  = -1;
HWND             g_hwndMain = NULL;
THEMESEL_OPTIONS g_options = {0};
BOOL             g_fHide = FALSE;
BOOL             g_fMinimize = FALSE;

UINT             WM_THEMESEL_COMMUNICATION = 
                    RegisterWindowMessage(_TEXT("WM_THEMESEL_COMMUNICATION"));

// module static data
COLORREF         s_Colors[TM_COLORCOUNT];
BOOL             s_fFlatMenus;
BOOL             s_fDropShadows;

//-------------------------------------------------------------------------//
typedef BOOL (WINAPI *PFN_TMINIT)(HINSTANCE hInst);
//-------------------------------------------------------------------------//
BOOL InitThemeManager(BOOL fPreventInitTheme)
{
    if (fPreventInitTheme)
    {
        //---- easy way: just turn off reg key ----
        SetCurrentUserThemeInt(THEMEPROP_THEMEACTIVE, 0);
    }

    //---= if theme manager is already running, don't start our local guy ----
    if (FindWindow(L"ThemeManagerWindowClass", NULL))
        return TRUE;

    //---- load msgina (theme manager) ----
    HINSTANCE hInstMsgina = LoadLibraryW(L"msgina.dll");
    if (! hInstMsgina)
    {
        MessageBox(NULL, L"Could not load msgina.dll", L"Fatal Error", MB_OK);
        return FALSE;
    }

    //---- find TMInitialize() ----
    PFN_TMINIT pfnTmInit = (PFN_TMINIT) GetProcAddress(hInstMsgina, (LPCSTR)49);

    // TM_Initialize is only exported as ordinal 49 at this point (9/27/00)
    if (! pfnTmInit)
        pfnTmInit = (PFN_TMINIT) GetProcAddress(hInstMsgina, (LPCSTR) 49);

    if (! pfnTmInit)
    {
        MessageBox(NULL, L"Could not find msgina entrypoint: TM_Initialize", L"Fatal Error", MB_OK);
        return FALSE;
    }

    //---- initialize theme manager ----
    pfnTmInit(hInstMsgina);

    return TRUE;
}
//-------------------------------------------------------------------------//
EXTERN_C APIENTRY _tWinMain( 
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPTSTR    lpCmdLine,
    int       nCmdShow)
{
    //---- initialize globals in themeldr.lib ----
    ThemeLibStartUp(FALSE);

    //---- initialize our globals ----
    g_hInst = hInstance; // Store instance handle in our global variable

    MSG msg;
    HACCEL hAccelTable;

    if (_FoundPrevInstance( lpCmdLine ))
        return 0;

    _SaveSystemSettings( );

    // Perform application initialization:
    BOOL fDone;
    if( !_InitThemeOptions( hInstance, lpCmdLine, &fDone ) )
        return 1;

    //---- turn off theme mgr for now, until msgina supports this again ----
    //if (! InitThemeManager(g_options.fPreventInitTheming))
    //    return 1;

    if (fDone)  // completed cmdline task OK
        return 0;

    if (g_fHide)
        nCmdShow = SW_HIDE;    
    else if (g_fMinimize)
        nCmdShow = SW_MINIMIZE;  

    if( !_InitInstance( hInstance, nCmdShow )) 
        return 1;

    hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_THEMESEL));

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0)) 
    {
        if (TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
            continue;

        if (msg.message == WM_THEMECHANGED)
        {
            //Log(LOG_TMCHANGE, L"MessageLoop: WM_THEMECHANGED on hwnd=0x%x (IsWindow()=%d)", 
                //msg.hwnd, IsWindow(msg.hwnd));
        }

        //if( _wndMain.TranslateAccelerator( msg.hwnd, &msg ) )
        //    continue;
            
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int)msg.wParam;
}

//-------------------------------------------------------------------------//
ATOM _RegisterWndClasses(HINSTANCE hInstance)
{
    WNDCLASSEX wcex;

    INITCOMMONCONTROLSEX icc;
    icc.dwSize = sizeof(icc);
    icc.dwICC  = ICC_TAB_CLASSES;
    InitCommonControlsEx( &icc );

    wcex.cbSize         = sizeof(WNDCLASSEX); 

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = CMainWnd::WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_THEMESEL));
    wcex.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   = MAKEINTRESOURCE(IDC_THEMESEL);
    wcex.lpszClassName  = THEMESEL_WNDCLASS;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    return RegisterClassEx(&wcex);
}

//-------------------------------------------------------------------------//
HWND CChildTabWnd::Create(
    DWORD dwExStyle,
    DWORD dwStyle,
    const RECT& rc,
    HWND  hwndParent,
    UINT  nID,
    HINSTANCE hInst,
    LPVOID pvParam )
{
    _hwnd = CreateWindowEx( dwExStyle, WC_TABCONTROL, TEXT(""), 
                            dwStyle | (WS_CHILD|WS_CLIPSIBLINGS|WS_CLIPCHILDREN|TCS_MULTILINE|TCS_HOTTRACK), 
                            rc.left, rc.top, RECTWIDTH(&rc), RECTHEIGHT(&rc), 
                            hwndParent, IntToPtr_(HMENU, nID), hInst, pvParam );
    return _hwnd;
}

#define VALIDPAGE(iPage,cPages) (((iPage) >=0) && ((iPage) < (cPages)))
//-------------------------------------------------------------------------//
int CChildTabWnd::CreatePages( const PAGEINFO rgPages[], int cPages )
{
    _cPages = 0;
    _prgPages = NULL;
    delete [] _rghwndPages;
    delete [] _rgrcPages;
    _rghwndPages = NULL;
    _rgrcPages = NULL;
    
    for( int i = 0; i < cPages; i++ )
    {
        TCITEM tci;
        TCHAR  szText[MAX_LOADSTRING];

        ZeroMemory( &tci, sizeof(tci) );
        tci.mask = (rgPages[i].nIDSTitle ? TCIF_TEXT : 0);

        LoadString( g_hInst, rgPages[i].nIDSTitle, szText, ARRAYSIZE(szText) );
        tci.pszText = szText;

        if( SendMessage( _hwnd, TCM_INSERTITEM, _cPages, (LPARAM)&tci ) == _cPages )
            _cPages++;
    }

    if( _cPages )
        _prgPages = rgPages;

    if( (_rghwndPages = new HWND[_cPages]) != NULL )
        ZeroMemory( _rghwndPages, _cPages * sizeof(HWND) );
    if( (_rgrcPages = new RECT[_cPages]) != NULL )
        ZeroMemory( _rgrcPages, _cPages * sizeof(RECT) );

    return _cPages;
}

//-------------------------------------------------------------------------//
HWND CChildTabWnd::GetCurPage()
{
    if( VALIDPAGE( _iCurPage, _cPages ) && 
        IsWindow(_rghwndPages[_iCurPage]) )
        return _rghwndPages[_iCurPage];
    return NULL;
}

//-------------------------------------------------------------------------//
BOOL CChildTabWnd::GetCurPageRect( LPRECT prc )
{
    if( VALIDPAGE( _iCurPage, _cPages ) && 
        !IsRectEmpty(_rgrcPages + _iCurPage) )
    {
        *prc = _rgrcPages[_iCurPage];
        return TRUE;
    }
    return FALSE;        
}

//-------------------------------------------------------------------------//
BOOL CChildTabWnd::GetExtent( SIZE* pext )
{
    RECT rc;
    if( GetCurPageRect( &rc ) )
    {
        SendMessage( _hwnd, TCM_ADJUSTRECT, TRUE, (LPARAM)&rc );
        pext->cx = RECTWIDTH(&rc);
        pext->cy = RECTHEIGHT(&rc);
        return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL CChildTabWnd::ShowPage( int iPage )
{
    if( iPage == _iCurPage )
        return TRUE;

    HWND hwndCurPage = GetCurPage();
    BOOL bInit = FALSE;

    if( hwndCurPage )
    {
        ShowWindow( hwndCurPage, SW_HIDE );
        EnableWindow( hwndCurPage, FALSE );
    }
    else
        bInit = TRUE;

    if( VALIDPAGE( iPage, _cPages ) ) 
    {
        if( !IsWindow(_rghwndPages[iPage]) )
            _rghwndPages[iPage] = _prgPages[iPage].pfnCreateInstance( _hwnd );
            
        if( IsWindow( _rghwndPages[iPage] ) )
        {
            _iCurPage = iPage;
            hwndCurPage = GetCurPage();
            
            if( hwndCurPage )
            {
                if( bInit )
                {
                    //  Set tab font
                    HFONT hf = (HFONT)SendMessage( hwndCurPage, WM_GETFONT, 0, 0L );
                    if( hf )
                        SendMessage( _hwnd, WM_SETFONT, (WPARAM)hf, 0L );
                }

                if( IsRectEmpty( _rgrcPages + iPage ) )
                {
                    //  Initialize native page rect.
                    GetWindowRect( _rghwndPages[iPage], _rgrcPages + iPage );
                    OffsetRect( _rgrcPages + iPage, 
                                -_rgrcPages[iPage].left, -_rgrcPages[iPage].top );
                    
                    //  Position page using TCM_ADJUSTRECT.
                    //  note: ignore width, height when we reposition, as TCM_ADJUSTRECT 
                    //  might have clipped them to its current client area)
                    RECT rcPage ;
                    GetWindowRect( _hwnd, &rcPage );
                    OffsetRect( &rcPage, -rcPage.left, -rcPage.top );
                    SendMessage( _hwnd, TCM_ADJUSTRECT, FALSE, (LPARAM)&rcPage );

                    SetWindowPos( hwndCurPage, NULL, rcPage.left, rcPage.top,
                                  RECTWIDTH(_rgrcPages + iPage), RECTHEIGHT(_rgrcPages + iPage), 
                                  SWP_NOACTIVATE|SWP_NOZORDER );
                }
                
                //  Inform parent of new scroll limits
                _wndMain.RepositionChildren( TRUE );

                ShowWindow( hwndCurPage, SW_SHOW );
                EnableWindow( hwndCurPage, TRUE );
                SetFocus( hwndCurPage );
            }
        }
    }
    return _iCurPage == iPage;
}

//-------------------------------------------------------------------------//
void CChildTabWnd::RepositionChildren( BOOL fCalcScroll, int cx, int cy )
{
    SIZE sizeDlg;
    HWND hwndDlg = GetCurPage();
       
    if( IsWindow( hwndDlg ) && GetExtent( &sizeDlg ) )
    {
        RECT rcPage;
        
        if( cx < 0 || cy < 0 )
        {
            GetWindowRect( _hwnd, &rcPage );
            OffsetRect( &rcPage, -rcPage.left, -rcPage.top );
        }
        else
        {
            SetRect( &rcPage, 0, 0, cx, cy );
        }

        SendMessage( _hwnd, TCM_ADJUSTRECT, FALSE, (LPARAM)&rcPage );

        SetWindowPos( hwndDlg, NULL, rcPage.left, rcPage.top, 
                      min(RECTWIDTH(&rcPage), sizeDlg.cx),
                      min(RECTHEIGHT(&rcPage), sizeDlg.cy),
                      SWP_NOACTIVATE|SWP_NOZORDER );
    }
}

//-------------------------------------------------------------------------//
BOOL CChildTabWnd::TranslateAccelerator( HWND hwnd, LPMSG pmsg)
{
    HWND hwndCurPage = GetCurPage();
    if( hwndCurPage || IsChild( hwndCurPage, hwnd ) )
        return IsDialogMessage( hwndCurPage, pmsg );
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL CChildTabWnd::HandleNotify( NMHDR* pnmh, LRESULT* plRet )
{
    *plRet = 0;
    switch( pnmh->code )
    {
        case TCN_SELCHANGE:
        {
            ShowPage( TabCtrl_GetCurSel( _hwnd ) );
            return TRUE;
        }
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL _InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    if( _RegisterWndClasses(hInstance) )
    {
       if( LoadString(hInstance, IDS_APP_TITLE, g_szAppTitle, MAX_LOADSTRING) )
       {
           CreateWindowEx( WS_EX_CLIENTEDGE, 
                           THEMESEL_WNDCLASS, g_szAppTitle, 
                           WS_OVERLAPPEDWINDOW|WS_HSCROLL|WS_VSCROLL,
                           CW_USEDEFAULT, CW_USEDEFAULT, 800, 560, 
                           NULL, NULL, hInstance, NULL);
            
           if( IsWindow( _wndMain ) )
           {
                g_hwndMain = _wndMain;

                ShowWindow(_wndMain, nCmdShow);
                UpdateWindow(_wndMain);
           }
       }
    }
    return TRUE;
}

//-------------------------------------------------------------------------//
HRESULT _ProcessFileName( LPCTSTR pszThemeFile, LPCWSTR pszColor, LPCWSTR pszSize, BOOL* pfDone  )
{
    HRESULT hr;
    *pfDone = FALSE;

    hr = S_OK;

    if (pszThemeFile)
        hr = _ApplyTheme(pszThemeFile, pszColor, pszSize, pfDone);

    return hr;
}

//-------------------------------------------------------------------------//
void ShowThemeError(HRESULT hr)
{
    WCHAR szBuff[2*MAX_PATH];

    if (THEME_PARSING_ERROR(hr))
    {
        PARSE_ERROR_INFO Info = {sizeof(Info)};

        HRESULT hr2 = GetThemeParseErrorInfo(&Info);
        if (SUCCEEDED(hr2))
        {
            StringCchCopy(szBuff, ARRAYSIZE(szBuff), Info.szMsg);
        }
        else
        {
            StringCchPrintfW(szBuff, ARRAYSIZE(szBuff), L"Unknown parsing error");
        }
    }
    else
    {
        // normal win32 error
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr, 0, szBuff, ARRAYSIZE(szBuff), NULL);
    }

    MessageBoxW(NULL, szBuff, L"Error Loading Theme", MB_OK);
}
//-------------------------------------------------------------------------//
HRESULT _ApplyTheme( LPCTSTR pszThemeFile, LPCWSTR pszColor, LPCWSTR pszSize, BOOL* pfDone  )
{
    HRESULT hr = E_FAIL;
    if (pfDone)
        *pfDone = FALSE;

    if (pszThemeFile && *pszThemeFile)
    {
        HTHEMEFILE htf;

        //---- OpenThemeFile needs filename fully qualified ----
        TCHAR szFullName[MAX_PATH];

        GetFullPathName(pszThemeFile, ARRAYSIZE(szFullName), szFullName, NULL); 

        if (g_options.hwndPreviewTarget)      // if not preview
        {
            hr = OpenThemeFile(szFullName, pszColor, pszSize, &htf, TRUE);

            if (FAILED(hr))
                ShowThemeError(hr);
            else
            {
                //---- apply theme ----

                hr = ApplyTheme(htf, 0, g_options.hwndPreviewTarget);
                if (hr)
                    ShowThemeError(hr);

                CloseThemeFile(htf);       // we don't need to hold open anymore
            }
        }
        else
        {
            hr = SetSystemVisualStyle(szFullName, pszColor, pszSize, AT_LOAD_SYSMETRICS);

        }
    }

    return hr;
}

//-------------------------------------------------------------------------//
BOOL _FoundPrevInstance( LPCWSTR lpCmdLine )
{

    HWND hwndPrev = FindWindow(THEMESEL_WNDCLASS, NULL);
    if (! hwndPrev)
        return FALSE;

    //---- find out what we are trying to do with this 2nd version ----
    LPCWSTR p = lpCmdLine;
    BOOL fUnload = FALSE;

    if ((*p == '-') || (*p == '/'))
    {
        p++;
        if ((*p == 'u') || (*p == 'U'))
            fUnload = TRUE;
    }

    //---- send a special msg and exit ----
    BOOL fGotIt = (BOOL)SendMessage(hwndPrev, WM_THEMESEL_COMMUNICATION, fUnload, 0);
    return fGotIt;
}

//-------------------------------------------------------------------------//
BOOL _InitThemeOptions( HINSTANCE hInstance, LPCTSTR lpCmdLine, BOOL *pfDone )
{
    LPCTSTR pszThemeFile = NULL;

    if( 0 == g_options.cbSize )
    {
        g_options.cbSize = sizeof(g_options);
        g_options.fEnableFrame = TRUE;
        g_options.fEnableDialog = TRUE;
        g_options.fPreventInitTheming = FALSE;
        g_options.fUserSwitch = FALSE;
        g_options.fExceptTarget = FALSE;
        g_options.hwndPreviewTarget = NULL;
        *g_options.szTargetApp = 0;
    }

    //---- other cmd line switches ----
    // -a<appname> (to set targeted app)
    // -t (to set themesel as target app)
    // -l (to load "Professional" theme and exit)
    // -u (to clear theme and exit)


    while (*lpCmdLine)           // process cmd line args
    {
        while (isspace(*lpCmdLine))
            lpCmdLine++;

        if ((*lpCmdLine == '-') || (*lpCmdLine == '/'))
        {
            lpCmdLine++;
            WCHAR lowp = towlower(*lpCmdLine);

            if (lowp == '?')
            {
                DialogBox( g_hInst, MAKEINTRESOURCE(IDD_SYNTAX), NULL, _SyntaxDlgProc );
                return FALSE;
            }
            else if (lowp == 'f')
                g_options.fEnableFrame = FALSE;
            else if (lowp == 'd')
                g_options.fEnableDialog = FALSE;
            else if (lowp == 'p')
                g_options.fPreventInitTheming = TRUE;
            else if ((lowp == 'a') || (lowp == 'x'))
            {
                g_options.fExceptTarget = (lowp == 'x');
                lpCmdLine++;;
                LPCTSTR q = lpCmdLine;
                while ((*lpCmdLine) && (! isspace(*lpCmdLine)))
                    lpCmdLine++;
                
                *g_options.szTargetApp = 0;
                ULONG cch = (ULONG)(lpCmdLine - q);
                ULONG cchCopy = min( (ULONG)(ARRAYSIZE(g_options.szTargetApp) - 1), cch);

                if (cchCopy > 0)
                {
                    CopyMemory(g_options.szTargetApp, q, cchCopy * sizeof(WCHAR));
                }
                g_options.szTargetApp[cchCopy] = 0;
                continue;
            }
            else if (lowp == 't')
                StringCchCopy(g_options.szTargetApp, ARRAYSIZE(g_options.szTargetApp), L"ThemeSel");
            else if (lowp == 'l')           // load "business" theme and minimize
            {
                pszThemeFile = DEFAULT_THEME;
                g_fMinimize = TRUE;

            }
            else if (lowp == 'z')           // load "business" theme and hide
            {
                pszThemeFile = DEFAULT_THEME;
                g_fHide = TRUE;
            }
            else if (lowp == 'u')           // just unload theme & exit
            {
                //---- turn off theme from previous run, if any ----
                ApplyTheme(NULL, 0, NULL);
                return FALSE;               // exit
            }
            else
            {
                MessageBox(NULL, L"Unrecognized switch", L"Error", MB_OK);
                return FALSE;
            }
            lpCmdLine++;        // skip over switch letter
        }
        else
        {
            pszThemeFile = lpCmdLine;
            break;
        }
    }

    return SUCCEEDED(_ProcessFileName( pszThemeFile, NULL, NULL, pfDone ));
}

//-------------------------------------------------------------------------//
LRESULT CALLBACK CMainWnd::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0L;

    switch (uMsg) 
    {
        case WM_NCCREATE:
            lRet = DefWindowProc( hwnd, uMsg, wParam, lParam );
            _wndMain.Attach( hwnd );
            break;

        case WM_NCDESTROY:
            lRet = DefWindowProc( hwnd, uMsg, wParam, lParam );
            _wndMain.Detach();
            break;

        case WM_CREATE:
        {
            RECT rc;
            GetClientRect( hwnd, &rc );
            if( !_wndMain._wndTab.Create( 0, WS_VISIBLE, rc, _wndMain, 0, g_hInst, 0 ) )
                return -1;

            if( _wndMain._wndTab.CreatePages( g_rgPageInfo, g_cPageInfo ) )
                _wndMain._wndTab.ShowPage(0);

            break;
        }

        case WM_HSCROLL:
        case WM_VSCROLL:
            _wndMain.Scroll( wParam, uMsg == WM_VSCROLL ? SB_VERT : SB_HORZ );
            break;

        case WM_COMMAND:
        {
            int wmId    = LOWORD(wParam); 
            int wmEvent = HIWORD(wParam); 
            BOOL fFake;

            // Parse the menu selections:
            switch (wmId)
            {
                case IDM_ABOUT:
                   DialogBox(g_hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hwnd, _AboutDlgProc);
                   break;
                case IDM_APPLY:
                   GeneralPage_OnTestButton(g_hwndGeneralPage, 0, NULL, NULL, fFake);
                   break;
                case IDM_DUMP:
                   GeneralPage_OnDumpTheme();
                   break;
                case IDM_REMOVE:
                   GeneralPage_OnClearButton(g_hwndGeneralPage, 0, NULL, NULL, fFake);
                   break;
                case IDM_EXIT:
                   DestroyWindow(hwnd);
                   break;
                default:
                   lRet = DefWindowProc(hwnd, uMsg, wParam, lParam);
            }
            break;
        }

        case WM_ERASEBKGND:
            return 1L;

        case WM_DESTROY:
            _ShutDown( FALSE );
            PostQuitMessage(0);
            break;

        case WM_SIZE:
        {
            POINTS pts = MAKEPOINTS(lParam);
            lRet = DefWindowProc( hwnd, uMsg, wParam, lParam );
            _wndMain.RepositionChildren( TRUE, pts.x, pts.y );
            break;
        }

        case WM_NOTIFY:
        {
            if( ((NMHDR*)lParam)->hwndFrom == _wndMain._wndTab )
            {
                if( _wndMain._wndTab.HandleNotify( (NMHDR*)lParam, &lRet ) )
                   return lRet;
            }
            break;
        }
        
        default:
            if (uMsg == WM_THEMESEL_COMMUNICATION)      // msg from another instance of themesel
            {
                if (wParam == 1)            // exit
                    _ShutDown( TRUE );
                else
                    ShowWindow(g_hwndMain, SW_NORMAL);

                return 1;
            }

            lRet = DefWindowProc(hwnd, uMsg, wParam, lParam);
   }
   return lRet;
}

//-------------------------------------------------------------------------//
void CMainWnd::RepositionChildren( BOOL fCalcScroll, int cx, int cy )
{
    if( IsWindow( _wndTab ) )
    {
        RECT rcClient = {0};
        if( cx < 0 || cy < 0 )
        {
            GetClientRect( _hwnd, &rcClient );
            cx = RECTWIDTH(&rcClient);
            cy = RECTHEIGHT(&rcClient);
        }
        else
        {
            rcClient.right  = cx;
            rcClient.bottom = cy;
        }

        SIZE  sizeMin;
        if( _wndTab.GetExtent(&sizeMin) )
        {
            if( fCalcScroll )
            {
                POINT pos;
                pos.x = _siHorz.nPos;
                pos.y = _siVert.nPos;

                _siHorz.fMask = _siVert.fMask = (SIF_RANGE|SIF_PAGE);

                _siHorz.nPage = cx; // thumb width
                _siVert.nPage = cy; // thumb height

                SIZE sizeDelta; // difference between what we have to show and what is shown.
                sizeDelta.cx = sizeMin.cx - _siHorz.nPage;
                sizeDelta.cy = sizeMin.cy - _siVert.nPage;

                //  establish maximum scroll positions
                _siHorz.nMax = sizeDelta.cx > 0 ? sizeMin.cx - 1 : 0;
                _siVert.nMax = sizeDelta.cy > 0 ? sizeMin.cy - 1 : 0;

                //  establish horizontal scroll pos
                if( sizeDelta.cx <= 0 )   
                    _siHorz.nPos = 0;  // scroll to extreme left if we're removing scroll bar
                else if( sizeDelta.cx < _siHorz.nPos ) 
                    _siHorz.nPos = sizeDelta.cx; // remove right-hand vacancy

                if( _siHorz.nPos != pos.x )
                    _siHorz.fMask |= SIF_POS;

                //  establish vertical scroll pos
                if( sizeDelta.cy <= 0 )  
                    _siVert.nPos = 0; // scroll to top if we're removing scroll bar
                else if( sizeDelta.cy < _siVert.nPos ) 
                    _siVert.nPos = sizeDelta.cy; // remove lower-portion vacancy

                if( _siVert.nPos != pos.y )
                    _siVert.fMask |= SIF_POS; 

                //  Note: can't call SetScrollInfo here, as it may generate
                //  a WM_SIZE and recurse back to this function before we had a 
                //  chance to SetWindowPos() our subdlg.  So defer it until after 
                //  we've done this.
            }

            SetWindowPos( _wndTab, NULL, -_siHorz.nPos, -_siVert.nPos, 
                          _siHorz.nPos + max(cx, sizeMin.cx), 
                          _siVert.nPos + max(cy, sizeMin.cy),
                          SWP_NOZORDER|SWP_NOACTIVATE );

            _wndTab.RepositionChildren( FALSE );

            if( fCalcScroll )
            {
                SetScrollInfo( _hwnd, SB_HORZ, &_siHorz, TRUE );
                SetScrollInfo( _hwnd, SB_VERT, &_siVert, TRUE );
            }
        }
    }
}

//-------------------------------------------------------------------------//
void CMainWnd::Scroll( WPARAM wParam, int nBar )
{
    SCROLLINFO* psi = SB_VERT == nBar ? &_siVert : 
                      SB_HORZ == nBar ? &_siHorz : NULL;

    const LONG  nLine = 15;
    UINT uSBCode = LOWORD(wParam);
    int  nNewPos = HIWORD(wParam);
    int  nDeltaMax = (psi->nMax - psi->nPage) + 1;

    if( !psi )
    {
        _ASSERTE(FALSE);
        return;
    }

    switch( uSBCode )
    {
        case SB_LEFT:
            psi->nPos--;
            break;
        case SB_RIGHT:
            psi->nPos++;
            break;
        case SB_LINELEFT:
            psi->nPos = max( psi->nPos - nLine, 0 );
            break;
        case SB_LINERIGHT:
            psi->nPos = min( psi->nPos + nLine, nDeltaMax );
            break;
        case SB_PAGELEFT:
            psi->nPos = max( psi->nPos - (int)psi->nPage, 0 );
            break;
        case SB_PAGERIGHT:
            psi->nPos = min( psi->nPos + (int)psi->nPage, nDeltaMax );
            break;
        case SB_THUMBTRACK:
            psi->nPos = nNewPos;
            break;
        case SB_THUMBPOSITION:
            psi->nPos = nNewPos;
            break;
        case SB_ENDSCROLL:
            return;
    }
    psi->fMask = SIF_POS;
    
    SetScrollInfo( _hwnd, nBar, psi, TRUE );
    RepositionChildren( FALSE );
}

//-------------------------------------------------------------------------//
INT_PTR CALLBACK _NilDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
                return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
            break;
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
INT_PTR CALLBACK _AboutDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return _NilDlgProc( hDlg, uMsg, wParam, lParam );
}

//-------------------------------------------------------------------------//
INT_PTR CALLBACK _SyntaxDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return _NilDlgProc( hDlg, uMsg, wParam, lParam );
}

//---------------------------------------------------------------------------
void _SaveSystemSettings( )
{
    //---- save off system colors for later restoration ----
    for (int i=0; i < TM_COLORCOUNT; i++)
        s_Colors[i] = GetSysColor(i);

    //---- save off "flatmenu" and "dropshadows" settings ---
    SystemParametersInfo(SPI_GETFLATMENU, 0, (PVOID)&s_fFlatMenus, 0);
    SystemParametersInfo(SPI_GETDROPSHADOW, 0, (PVOID)&s_fDropShadows, 0);
} 

//---------------------------------------------------------------------------
void _RestoreSystemSettings(HWND hwndGeneralPage, BOOL fUnloadOneOnly)
{
    //---- turn off current Theme ----
    HWND hwndPreview = hwndGeneralPage ? GetPreviewHwnd(hwndGeneralPage) : NULL;

    if (fUnloadOneOnly)         // remove the "active" theme
    {
        if (hwndPreview)       
        {
            ApplyTheme(NULL, 0, hwndPreview);
            return;
        }
        else
        {
            //---- fall thru & restore sys metrics ----
            ApplyTheme(NULL, 0, NULL);
        }
    }
    else
    {
        ApplyTheme(NULL, 0, hwndPreview);
    }

    //---- restore system colors ----
    int iIndexes[TM_COLORCOUNT];

    for (int i=0; i < TM_COLORCOUNT; i++)
        iIndexes[i] = i;

    SetSysColors(TM_COLORCOUNT, iIndexes, s_Colors);

    //---- restore "flatmenu" and "dropshadows" settings ---
    SystemParametersInfo(SPI_SETFLATMENU, 0, IntToPtr(s_fFlatMenus), SPIF_SENDCHANGE);
    SystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(s_fFlatMenus), SPIF_SENDCHANGE);
}

//---------------------------------------------------------------------------
void _ShutDown( BOOL bQuit )
{
    if( bQuit )
        PostQuitMessage(0);
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themesel\main.h ===
//-------------------------------------------------------------------------//
//  main.h
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//  THEMESEL_OPTIONS
typedef struct {
    DWORD cbSize;
    BOOL  fEnableFrame;        // -f to disable
    BOOL  fEnableDialog;       // -d to enable
    BOOL  fPreventInitTheming; // -p to enable
    BOOL  fExceptTarget;       // -x<appname> (to omit app)
    BOOL  fUserSwitch;
    HWND  hwndPreviewTarget;        
    TCHAR szTargetApp[MAX_PATH];                    
} THEMESEL_OPTIONS ;

extern THEMESEL_OPTIONS g_options;

HRESULT _ApplyTheme( LPCTSTR pszThemeFile, LPCWSTR pszColor, LPCWSTR pszSize, BOOL *pfDone  );

HWND GetPreviewHwnd(HWND hwndGeneralPage);
LRESULT CALLBACK GeneralPage_OnTestButton( HWND hwndPage, UINT, WPARAM, HWND, BOOL&);
LRESULT CALLBACK GeneralPage_OnClearButton(HWND hwndPage, UINT, WPARAM, HWND, BOOL&);
LRESULT CALLBACK GeneralPage_OnDumpTheme();

extern HWND g_hwndGeneralPage;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themesel\genlpage.cpp ===
#include "pch.h"
#include "resource.h"
#include "main.h"
#include <stdio.h>

//-------------------------------------------------------------------------//
//  'General' page impl
//-------------------------------------------------------------------------//

//  CreateIntance, DlgProc
HWND    CALLBACK GeneralPage_CreateInstance( HWND hwndParent );
INT_PTR CALLBACK GeneralPage_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
//  Message Handlers
LRESULT CALLBACK GeneralPage_OnThemeSelected( HWND hwndPage, UINT, WPARAM, HWND, BOOL&);
LRESULT CALLBACK GeneralPage_OnColorSelected( HWND hwndPage, UINT, WPARAM, HWND, BOOL&);
LRESULT CALLBACK GeneralPage_OnEdit( HWND hwndPage, UINT, WPARAM, HWND, BOOL&);
LRESULT CALLBACK GeneralPage_OnInitDialog(HWND hwndPage, UINT, WPARAM, LPARAM, BOOL&);
LRESULT CALLBACK GeneralPage_OnDestroy( HWND hwndPage, UINT, WPARAM, LPARAM, BOOL&);

//  Misc
BOOL    CALLBACK GeneralPage_AddProccessNamesCB( HWND hwnd, LPARAM lParam );
void             GeneralPage_AddProcessNamesToCombos( HWND hwndPage );

//  Utility Methods
void GeneralPage_RefreshThemeName( HWND hwndPage ); 
BOOL GeneralPage_EnumProc( enum THEMECALLBACK tcbType, LPCWSTR pszName, LPCWSTR pszDisplayName, 
     LPCWSTR pszToolTip, int iIndex, LPARAM lParam  );
void GeneralPage_AddProcessNamesToCombos( HWND hwndPage );
void GeneralPage_EnableDlgButtons( HWND hwndPage );
void GeneralPage_RebuildThemes(HWND hwndPage, LPCWSTR pszCurrentTheme);

HWND g_hwndGeneralPage = NULL;
//-------------------------------------------------------------------------//
void ExpandDirIntoFullThemeFileName(LPCWSTR pszSubDir, LPWSTR pszFileName)
{
    //---- turn this into a real theme file name ----
    WCHAR szRelativeDir[_MAX_PATH+1];
    StringCchPrintfW(szRelativeDir, ARRAYSIZE(szRelativeDir), 
                     L"%s\\%s.msstyles", pszSubDir, pszSubDir);

    WCHAR *pszBaseName;
    GetFullPathName(szRelativeDir, MAX_PATH, pszFileName, &pszBaseName);
}
//-------------------------------------------------------------------------//
INT_PTR CALLBACK GeneralPage_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L;
    switch( uMsg )
    {
        case WM_INITDIALOG:
            lRet = GeneralPage_OnInitDialog( hwndPage, uMsg, wParam, lParam, bHandled );
            break;

        case WM_COMMAND:
        {
            HWND hwndCtl = (HWND)lParam;
            UINT uCode   = HIWORD(wParam);
            switch( LOWORD(wParam) )
            {
                case IDC_TESTBUTTON:
                    lRet = GeneralPage_OnTestButton( hwndPage, uMsg, wParam, hwndCtl, bHandled );
                    break;
    
                case IDC_CLEARBUTTON:
                    lRet = GeneralPage_OnClearButton( hwndPage, uMsg, wParam, hwndCtl, bHandled );
                    break;

                case IDC_DIRNAME:
                    lRet = GeneralPage_OnThemeSelected( hwndPage, uMsg, wParam, hwndCtl, bHandled );
                    break;

                case IDC_COLORCOMBO:
                    lRet = GeneralPage_OnColorSelected( hwndPage, uMsg, wParam, hwndCtl, bHandled );
                    break;

                case IDC_EDIT_THEME:
                    lRet = GeneralPage_OnEdit( hwndPage, uMsg, wParam, hwndCtl, bHandled );
                    break;

                case IDC_TARGET:
                case IDC_UNTARGET:
                    if( CBN_DROPDOWN == uCode )
                    {
                        //  Keep process names fresh.
                        GeneralPage_AddProcessNamesToCombos( hwndPage );
                    }
                    break;
            }
            GeneralPage_EnableDlgButtons( hwndPage );
            break;
        }

        case WM_DESTROY:
            lRet = GeneralPage_OnDestroy( hwndPage, uMsg, wParam, lParam, bHandled );
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}

//-------------------------------------------------------------------------//
HWND CALLBACK GeneralPage_CreateInstance( HWND hwndParent )
{
    g_hwndGeneralPage = CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_PAGE_GENERAL),
                         hwndParent,  GeneralPage_DlgProc );

    return g_hwndGeneralPage;
}

//---------------------------------------------------------------------------
BOOL ThemeEnumerator(enum THEMECALLBACK tcbType, LPCWSTR pszName, 
    LPCWSTR pszDisplayName, LPCWSTR pszToolTip, int iIndex, LPARAM lParam)
{
    HWND combo = (HWND)lParam;

    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szBase[_MAX_FNAME], szExt[_MAX_EXT];
    WCHAR szBaseName[MAX_PATH];
    _tsplitpath(pszName, szDrive, szDir, szBase, szExt);
    StringCchPrintfW(szBaseName, ARRAYSIZE(szBaseName), L".\\%s\\%s%s", szBase, szBase, szExt);

    int index = (int)SendMessage(combo, CB_ADDSTRING, 0, (LPARAM)szBaseName);

    if (! index)            // first one added
    {
        ::SetWindowText(combo, szBaseName);
        
        //---- simulate a selection change ----
        ::SendMessage(combo, CB_SETCURSEL, 0, 0);
    }

    return TRUE;
}

//---------------------------------------------------------------------------
void GeneralPage_RebuildThemes(HWND hwndPage, LPCWSTR pszCurrentTheme)
{
    HWND hwndCombo = GetDlgItem(hwndPage, IDC_DIRNAME);
    SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);

    WCHAR szFullDir[_MAX_PATH+1];
    WCHAR *pszBaseName;
    DWORD val = GetFullPathName(L".", ARRAYSIZE(szFullDir), szFullDir, &pszBaseName);
    if (! val)
    {
        MessageBox(NULL, L"GetFullPathName() failure", L"Error", MB_OK);
        return;
    }

    //---- enum actual theme DLL's ----
    HRESULT hr = EnumThemes(szFullDir, ThemeEnumerator, (LPARAM)hwndCombo);
    ATLASSERT(SUCCEEDED(hr));

    //---- enum theme subdirs ----
    HANDLE hFile = NULL;
    BOOL   bFile = TRUE;
    WIN32_FIND_DATA wfd;
    hr = S_FALSE;       // assume interrupted until we complete
    bFile = TRUE;

    for( hFile = FindFirstFile( TEXT("*.*"), &wfd ); hFile != INVALID_HANDLE_VALUE && bFile;
         bFile = FindNextFile( hFile, &wfd ) )
    {
        WCHAR *p = wfd.cFileName;

        if(! ( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ))
            continue;

        if ((lstrcmp(wfd.cFileName, TEXT("."))==0) || (lstrcmp(wfd.cFileName, TEXT(".."))==0))
            continue;

        if (_tcsicmp(p, _TEXT("obj"))==0)           // dev directory
            continue;

        SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)wfd.cFileName);
    }

    //---- select the first theme ----
    int index = (int)SendMessage(hwndCombo, CB_FINDSTRINGEXACT, 0, (LPARAM)pszCurrentTheme);
    if (index < 0)
        index = 0;
    
    SendMessage(hwndCombo, CB_SETCURSEL, index, NULL);
}
//---------------------------------------------------------------------------
LRESULT GeneralPage_OnInitDialog(HWND hwndPage, UINT, WPARAM wid, LPARAM, BOOL&)
{
    GeneralPage_RefreshThemeName( hwndPage );

#if 0       // testing SetWindowTheme()
    HWND hwndOK = GetDlgItem(hwndPage, IDC_TESTBUTTON);
    if (hwndOK)
        SetWindowTheme(hwndOK, L"themeok", NULL);

    HWND hwndCancel = GetDlgItem(hwndPage, IDC_CLEARBUTTON);
    if (hwndCancel)
        SetWindowTheme(hwndCancel, NULL, L"CancelButton");
#endif

    GeneralPage_RebuildThemes(hwndPage, DEFAULT_THEME);

    //---- simulate a selection ----
    BOOL mybool;
    GeneralPage_OnThemeSelected(hwndPage, 0, 0, 0, mybool);
    
    GeneralPage_AddProcessNamesToCombos( hwndPage );

    CheckDlgButton( hwndPage, IDC_THEME_ALL,     *g_options.szTargetApp == 0 );
    CheckDlgButton( hwndPage, IDC_THEME_PROCESS, *g_options.szTargetApp != 0 && !g_options.fExceptTarget);
    CheckDlgButton( hwndPage, IDC_THEME_EXEMPT,  *g_options.szTargetApp != 0 &&  g_options.fExceptTarget );
    CheckDlgButton( hwndPage, IDC_THEME_PREVIEW,  g_options.hwndPreviewTarget != 0 );
    CheckDlgButton( hwndPage, IDC_ENABLE_FRAME,   g_options.fEnableFrame );
    CheckDlgButton( hwndPage, IDC_ENABLE_DLG,     g_options.fEnableDialog );
    CheckDlgButton( hwndPage, IDC_USERSWITCH,     g_options.fUserSwitch );
    GeneralPage_EnableDlgButtons( hwndPage );

    //---- set preview edit text to hwndPage ----
    WCHAR szBuff[_MAX_PATH+1];
    StringCchPrintfW(szBuff, ARRAYSIZE(szBuff), L"%x", hwndPage);
    SetDlgItemText(hwndPage, IDC_PREVIEW, szBuff);

    return 0;
}

//---------------------------------------------------------------------------
void GeneralPage_EnableDlgButtons( HWND hwndPage )
{
    EnableWindow( GetDlgItem( hwndPage, IDC_TARGET ), IsDlgButtonChecked( hwndPage, IDC_THEME_PROCESS )!=0 );
    EnableWindow( GetDlgItem( hwndPage, IDC_UNTARGET ), IsDlgButtonChecked( hwndPage, IDC_THEME_EXEMPT )!=0 );
    EnableWindow( GetDlgItem( hwndPage, IDC_PREVIEW ), IsDlgButtonChecked( hwndPage, IDC_THEME_PREVIEW )!=0 );
}

//---------------------------------------------------------------------------
LRESULT GeneralPage_OnDumpTheme()
{
    HTHEME hTheme = OpenThemeData(NULL, L"globals");
    if (hTheme)
    {
        HTHEMEFILE hThemeFile;
        if (SUCCEEDED(OpenThemeFileFromData(hTheme, &hThemeFile)))
        {
            HRESULT hr = DumpLoadedThemeToTextFile(hThemeFile, L"theme.dmp", TRUE, TRUE);
            if (FAILED(hr))
                MessageBox(NULL, L"DumpLoadedThemeToTextFile() Failed", L"Error", MB_OK);

            CloseThemeFile(hThemeFile);
        }

        CloseThemeData(hTheme);
    }

    return 0;
}
//---------------------------------------------------------------------------
LRESULT GeneralPage_OnTestButton( HWND hwndPage, UINT, WPARAM, HWND, BOOL&)
{
    //---- get theme szFileName ----
    WCHAR szThemeFileName[_MAX_PATH+1];
    GetDlgItemText(hwndPage, IDC_DIRNAME, szThemeFileName, ARRAYSIZE(szThemeFileName));

    //---- is it a dir? ----
    DWORD dwMask = GetFileAttributes(szThemeFileName);
    BOOL fDir = ((dwMask != 0xffffffff) && (dwMask & FILE_ATTRIBUTE_DIRECTORY));

    if (fDir)               // do auto convert to a .msstyles file
    {
        //---- run "packthem" against the dir ----
        WCHAR szDirName[_MAX_PATH+1];
        StringCchCopyW(szDirName, ARRAYSIZE(szDirName), szThemeFileName);

        WCHAR szCmdLine[2*_MAX_PATH+1];
        StringCchPrintfW(szCmdLine, ARRAYSIZE(szCmdLine), L"/e %s", szDirName);

        HRESULT hr = SyncCmdLineRun(L"packthem.exe", szCmdLine);
        if (FAILED(hr))
        {
            LPWSTR szErrMsg;
            hr = AllocateTextFile(L"packthem.err", &szErrMsg, NULL);
            if (FAILED(hr))
            {
                MessageBox(NULL, L"Unknown Error", L"Error in packing Theme", MB_OK);
                return FALSE;
            }

            MessageBox(NULL, szErrMsg, L"Error in packing Theme", MB_OK);
            LocalFree(szErrMsg);

            return FALSE;
        }

        GeneralPage_RebuildThemes(hwndPage, szDirName);

        //---- convert into a DLL name ----
        ExpandDirIntoFullThemeFileName(szDirName, szThemeFileName);
    }

    WCHAR ColorParam[MAX_PATH+1];
    WCHAR SizeParam[MAX_PATH+1];

    *ColorParam = 0;
    *SizeParam = 0;

    //---- extract ColorParam ----
    HWND hwndCombo;
    hwndCombo = GetDlgItem(hwndPage, IDC_COLORCOMBO);
    int index;
    index = (int)SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (index > -1)
        SendMessage(hwndCombo, CB_GETLBTEXT, index, (LPARAM)ColorParam);

    //---- extract SizeParam ----
    hwndCombo = GetDlgItem(hwndPage, IDC_SIZECOMBO);
    index = (int)SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (index > -1)
        SendMessage(hwndCombo, CB_GETLBTEXT, index, (LPARAM)SizeParam);

    g_options.fExceptTarget = IsDlgButtonChecked( hwndPage, IDC_THEME_EXEMPT ) != 0;
    if( g_options.fExceptTarget )
    {
        GetDlgItemText( hwndPage, IDC_UNTARGET, 
                        g_options.szTargetApp, 
                        ARRAYSIZE(g_options.szTargetApp) );
    }
    else if( IsDlgButtonChecked( hwndPage, IDC_THEME_PROCESS ) != 0 )
    {
        GetDlgItemText( hwndPage, IDC_TARGET, 
                        g_options.szTargetApp, 
                        ARRAYSIZE(g_options.szTargetApp) );
    }
    else
        *g_options.szTargetApp = 0;

    //---- extract Preview info ----
    g_options.hwndPreviewTarget = GetPreviewHwnd(hwndPage);
    
    g_options.fEnableFrame = IsDlgButtonChecked( hwndPage, IDC_ENABLE_FRAME ) != 0;
    g_options.fEnableDialog = IsDlgButtonChecked( hwndPage, IDC_ENABLE_DLG ) != 0;
    g_options.fUserSwitch = IsDlgButtonChecked( hwndPage, IDC_USERSWITCH ) != 0;

    _ApplyTheme(szThemeFileName, ColorParam, SizeParam, NULL);

    GeneralPage_RefreshThemeName( hwndPage );

    return TRUE;
}

//---------------------------------------------------------------------------
HWND GetPreviewHwnd(HWND hwndGeneralPage)
{
    if (! hwndGeneralPage)
        return NULL;

    BOOL fPreview = IsDlgButtonChecked( hwndGeneralPage, IDC_THEME_PREVIEW ) != 0;
    if (! fPreview)
        return NULL;

    WCHAR szTempBuff[_MAX_PATH+1];

    GetDlgItemText(hwndGeneralPage, IDC_PREVIEW, szTempBuff, ARRAYSIZE(szTempBuff));

    LONG val;
    int cnt = swscanf(szTempBuff, L"%lx", &val);
    if (! cnt)
        val = 0;

    return (HWND)IntToPtr(val);
}

//---------------------------------------------------------------------------
LRESULT GeneralPage_OnClearButton(HWND hwndPage, UINT, WPARAM, HWND, BOOL&)
{   
#if 0       // testing SetWindowTheme()
    HWND hwndOK = GetDlgItem(hwndPage, IDC_TESTBUTTON);
    if (hwndOK)
        SetWindowTheme(hwndOK, NULL, NULL);

    HWND hwndCancel = GetDlgItem(hwndPage, IDC_CLEARBUTTON);
    if (hwndCancel)
        SetWindowTheme(hwndCancel, NULL, NULL);
#endif

    _RestoreSystemSettings(hwndPage, TRUE);
    
    GeneralPage_RefreshThemeName( hwndPage );
    return 0;
}

//---------------------------------------------------------------------------
LRESULT GeneralPage_OnThemeSelected( HWND hwndPage, UINT, WPARAM, HWND, BOOL&)
{
    //---- get theme szFileName ----
    WCHAR szFileName[MAX_PATH+1];
    WCHAR szSubDir[MAX_PATH+1];

    HWND hwndCombo = GetDlgItem(hwndPage, IDC_DIRNAME);
    int index = (int)SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (index == -1)
        *szFileName = 0;
    else
    {
        ::SendMessage(hwndCombo, CB_GETLBTEXT, index, (LPARAM)szSubDir);

        //---- turn this into a real theme file name ----
        ExpandDirIntoFullThemeFileName(szSubDir, szFileName);
    }

    //---- enum the theme colors ----
    HWND hwnd = GetDlgItem(hwndPage, IDC_COLORCOMBO);
    ::SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

    for (DWORD c=0; ; c++)
    {
        THEMENAMEINFO names;

        if (FAILED(EnumThemeColors(szFileName, NULL, c, &names)))
            break;

        ::SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)names.szName);
    }
    

    //---- remove choices if only 1 entry ----
    if (c < 2) 
    {
        ::SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
        ::EnableWindow(hwnd, FALSE);
    }
    else
    {
        ::EnableWindow(hwnd, TRUE);
        SendMessage(hwnd, CB_SETCURSEL, 0, 0);
    }

    BOOL fDummy;
    GeneralPage_OnColorSelected(hwndPage, 0, 0, 0, fDummy);

    WCHAR szBuff[MAX_PATH+1];
    HRESULT hr;

    //---- update DisplayName ----
    hr = GetThemeDocumentationProperty(szFileName, L"DisplayName", szBuff, ARRAYSIZE(szBuff));
    if (FAILED(hr))
        StringCchCopyW(szBuff, ARRAYSIZE(szBuff), L"<not available>");
    SetDlgItemText(hwndPage, IDC_DISPLAYNAME, szBuff);

    //---- update ToolTip ----
    hr = GetThemeDocumentationProperty(szFileName, L"Tooltip", szBuff, ARRAYSIZE(szBuff));
    if (FAILED(hr))
        StringCchCopyW(szBuff, ARRAYSIZE(szBuff), L"<not available>");
    SetDlgItemText(hwndPage, IDC_TOOLTIP, szBuff);

    //---- update Author ----
    hr = GetThemeDocumentationProperty(szFileName, L"author", szBuff, ARRAYSIZE(szBuff));
    if (FAILED(hr))
        StringCchCopyW(szBuff, ARRAYSIZE(szBuff), L"<not available>");
    SetDlgItemText(hwndPage, IDC_AUTHOR, szBuff);

    return 1;
}

//---------------------------------------------------------------------------
LRESULT GeneralPage_OnColorSelected( HWND hwndPage, UINT, WPARAM, HWND, BOOL&)
{
    //---- get theme szFileName ----
    WCHAR szFileName[MAX_PATH+1];
    HWND hwndCombo = GetDlgItem(hwndPage, IDC_DIRNAME);
    int index = (int)SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (index == -1)
        *szFileName = 0;
    else
        ::SendMessage(hwndCombo, CB_GETLBTEXT, index, (LPARAM)szFileName);

    //---- get the currently selected color ----
    WCHAR szColor[_MAX_PATH+1];
    HWND hwnd = GetDlgItem(hwndPage, IDC_COLORCOMBO);
    GetWindowText(hwnd, szColor, ARRAYSIZE(szColor));

    //---- get the current size name ----
    WCHAR szSizeName[MAX_PATH+1];
    HWND hwndSize = GetDlgItem(hwndPage, IDC_SIZECOMBO);
    GetWindowText(hwndSize, szSizeName, ARRAYSIZE(szSizeName));

    //---- enum the theme sizes for the specified color ----
    hwnd = GetDlgItem(hwndPage, IDC_SIZECOMBO);

    if (* szColor)      // only set size if a color is set
    {
        ::SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

        for (DWORD s=0; ; s++)              // enumerate sizes
        {
            THEMENAMEINFO names;

            if (FAILED(EnumThemeSizes(szFileName, szColor, s, &names)))
                break;

            ::SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)names.szName);
        }

        //---- remove choices if only 1 entry ----
        if (s < 2) 
        {
            ::SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
            ::EnableWindow(hwnd, FALSE);
        }
        else
        {
            ::EnableWindow(hwnd, TRUE);

            //---- try to select previously set size ----
            int index = (int)SendMessage(hwnd, CB_FINDSTRINGEXACT, 0, (LPARAM)szSizeName);
            if (index == -1)
                index = 0;
            SendMessage(hwnd, CB_SETCURSEL, index, 0);
        }
    }
    else
    {
        ::SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
        ::EnableWindow(hwnd, FALSE);
    }

    return 1;
}

//---------------------------------------------------------------------------
LRESULT GeneralPage_OnEdit( HWND hwndPage, UINT, WPARAM, HWND, BOOL&)
{
    //---- get theme szFileName ----
    WCHAR szBuff[1024];
    WCHAR szFileName[MAX_PATH+1];

    HWND hwndCombo = GetDlgItem(hwndPage, IDC_DIRNAME);
    int index = (int)SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (index == -1)
        *szFileName = 0;
    else
    {
        ::SendMessage(hwndCombo, CB_GETLBTEXT, index, (LPARAM)szBuff);
        
        WCHAR *p = wcschr(szBuff, L'.');
        if (p)
            *p = 0;     // remove file extension of DLL name

        WCHAR *pStart = wcsrchr(szBuff, L'\\');
        if (pStart)
            pStart++;
        else
            pStart = szBuff;

        //---- try for classdata file; fallback onto container file ----
        StringCchPrintfW(szFileName, ARRAYSIZE(szFileName), L"%s\\%s", pStart, USUAL_CLASSDATA_NAME);
        if (! FileExists(szFileName))
            StringCchPrintfW(szFileName, ARRAYSIZE(szFileName), L"%s\\%s", pStart, CONTAINER_NAME);
    }

    HANDLE hInst = CmdLineRun(L"notepad.exe", szFileName, FALSE);
    CloseHandle(hInst);

    return 1;
}

//---------------------------------------------------------------------------
LRESULT GeneralPage_OnDestroy( HWND hwndPage, UINT, WPARAM wid, LPARAM, BOOL&)
{
    return 0;
}

//---------------------------------------------------------------------------
void GeneralPage_RefreshThemeName( HWND hwndPage )
{
    WCHAR szName[MAX_PATH+1];
    WCHAR szColor[MAX_PATH+1];
    WCHAR szSize[MAX_PATH+1];
    WCHAR szTitle[1024];

    BOOL fThemeActive = IsThemeActive();

    if (fThemeActive)
    {
        HRESULT hr = GetCurrentThemeName(szName, ARRAYSIZE(szName), 
            szColor, ARRAYSIZE(szColor), szSize, ARRAYSIZE(szSize));

        if (FAILED(hr))
            StringCchCopyW(szName, ARRAYSIZE(szName), L"<unavailable>");
        else if (! *szName)
            StringCchCopyW(szTitle, ARRAYSIZE(szTitle), g_szAppTitle);
        else
        {
            //---- remove all dirs preceeding last backslash ----
            WCHAR *p = wcsrchr(szName, L'\\');
            if (p)                 
                StringCchPrintfW(szTitle, ARRAYSIZE(szTitle), L"%s - %s", p+1, g_szAppTitle);
            else
                StringCchPrintfW(szTitle, ARRAYSIZE(szTitle), L"%s - %s", szName, g_szAppTitle);
        }
    }
    else
        StringCchCopyW(szTitle, ARRAYSIZE(szTitle), g_szAppTitle);

    HWND hMain = GetParent(GetParent(hwndPage));
    SetWindowText(hMain, szTitle);
}

//---------------------------------------------------------------------------
BOOL GeneralPage_EnumProc( enum THEMECALLBACK tcbType, LPCWSTR pszName, 
    LPCWSTR pszDisplayName, LPCWSTR pszToolTip, int iIndex, LPARAM lParam )
{
    HWND hwnd = (HWND)lParam;
    ::SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)pszName);

    return TRUE;
}

//---------------------------------------------------------------------------
BOOL CALLBACK GeneralPage_AddProccessNamesCB( HWND hwnd, LPARAM lParam )
{
    HWND hwndPage = (HWND)lParam;
    _ASSERTE( IsWindow(hwndPage) );

    DWORD dwProcessID = 0;
    if( !GetWindowThreadProcessId( hwnd, &dwProcessID ) )
        return TRUE;
        
    HANDLE hProcess = OpenProcess( PROCESS_VM_READ|PROCESS_QUERY_INFORMATION, FALSE, dwProcessID );
    if( NULL == hProcess )
        return TRUE;

    HMODULE rghModules[64];
    DWORD   cbRet1 = 0;
    if( EnumProcessModules( hProcess, rghModules, sizeof(rghModules), &cbRet1 ) )
    {
        for( UINT j = 0; j < (min( cbRet1, sizeof(rghModules) ))/sizeof(DWORD); j++ )
        {
            TCHAR szModule[MAX_PATH];
            if( GetModuleFileNameEx( hProcess, rghModules[j], szModule, ARRAYSIZE(szModule) ) )
            {
                CharLower( szModule );
                TCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szApp[_MAX_FNAME], szExt[_MAX_EXT];
                _tsplitpath(szModule, szDrive, szDir, szApp, szExt);

                if( 0 == lstrcmp( szExt, TEXT(".exe") ) )
                {
                    if( SendDlgItemMessage( hwndPage, IDC_TARGET, CB_FINDSTRINGEXACT, -1, (LPARAM)szApp ) == CB_ERR )
                    {
                        INT_PTR iSel = (INT_PTR)SendDlgItemMessage( hwndPage, IDC_TARGET, CB_ADDSTRING, -1, (LPARAM)szApp );
                        if( 0 == lstrcmpi( szApp, g_options.szTargetApp ) )
                            SendDlgItemMessage( hwndPage, IDC_TARGET, CB_SETCURSEL, iSel, 0L );
                    }
                    
                    if( SendDlgItemMessage( hwndPage, IDC_UNTARGET, CB_FINDSTRINGEXACT, -1, (LPARAM)szApp ) == CB_ERR )
                    {
                        INT_PTR iSel = (INT_PTR)SendDlgItemMessage( hwndPage, IDC_UNTARGET, CB_ADDSTRING, -1, (LPARAM)szApp );
                        if( 0 == lstrcmpi( szApp, g_options.szTargetApp ) )
                            SendDlgItemMessage( hwndPage, IDC_UNTARGET, CB_SETCURSEL, iSel, 0L );
                    }
                }

            }
        }
    }
    CloseHandle( hProcess );
    return TRUE;
}

//---------------------------------------------------------------------------
void GeneralPage_AddProcessNamesToCombos( HWND hwndPage )
{ 
    //---- this will enum all windows (top level & all child levels) ----
    EnumChildWindows( GetDesktopWindow(), GeneralPage_AddProccessNamesCB, (LPARAM)hwndPage );
    
    if( *g_options.szTargetApp )
    {
        if( CB_ERR == SendDlgItemMessage( hwndPage, IDC_TARGET, CB_GETCURSEL, 0, 0L ) )
        {
            INT_PTR iSel = SendDlgItemMessage( hwndPage, IDC_TARGET, CB_ADDSTRING, -1, 
                                              (LPARAM)g_options.szTargetApp );
            SendDlgItemMessage( hwndPage, IDC_TARGET, CB_SETCURSEL, iSel, 0L );
        }

        if( CB_ERR == SendDlgItemMessage( hwndPage, IDC_UNTARGET, CB_GETCURSEL, 0, 0L ) )
        {
            INT_PTR iSel = SendDlgItemMessage( hwndPage, IDC_UNTARGET, CB_ADDSTRING, -1, 
                                               (LPARAM)g_options.szTargetApp );
            SendDlgItemMessage( hwndPage, IDC_UNTARGET, CB_SETCURSEL, iSel, 0L );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeldr\utils.cpp ===
//---------------------------------------------------------------------------
//    utils.cpp - theme code utilities (shared in "inc" directory)
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <time.h>
#include "utils.h"
#include "cfile.h"
#include "stringtable.h"
//---------------------------------------------------------------------------
HINSTANCE hinstUxCtrl = NULL;               // protected by _csUtils

IMAGE_DRAWPROC ImageList_DrawProc = NULL;       // protected by _csUtils
IMAGE_LOADPROC ImageList_LoadProc = NULL;       // protected by _csUtils
PFNDRAWSHADOWTEXT CCDrawShadowText = NULL;
IMAGE_DESTROYPROC ImageList_DestroyProc = NULL; // protected by _csUtils

int g_iScreenDpi = THEME_DPI;               // only initialized 
//---------------------------------------------------------------------------
CRITICAL_SECTION _csUtils = {0};            // unprotected (set during init)
//---------------------------------------------------------------------------
#define __ascii_towlower(c)     ( (((c) >= L'A') && ((c) <= L'Z')) ? ((c) - L'A' + L'a') : (c) )

// A string compare that explicitely only works on english characters
// This avoids locale problems like Hungarian, without a performance hit.
// NOTE: Intended for theme schema properties. Theme file names, colors styles and size styles 
// shouldn't be passed to this function, nor any display name.
int AsciiStrCmpI(const WCHAR *dst, const WCHAR *src)
{
    WCHAR f,l;

    if (dst == NULL)
    {
        return src == NULL ? 0 : -1;
    }
    if (src == NULL)
    {
        return 1;
    }

    do {
#ifdef DEBUG
        if (*dst > 127 || *src > 127)
        {
            Log(LOG_ERROR, L"AsciiStrCmpI: Non-Ascii comparing %s and %s", dst, src);
        }
#endif
        f = (WCHAR)__ascii_towlower(*dst);
        l = (WCHAR)__ascii_towlower(*src);
        dst++;
        src++;
    } while ( (f) && (f == l) );

    return (int)(f - l);
}
//---------------------------------------------------------------------------
BOOL lstrtoken(LPWSTR psz, WCHAR wch)
{
    ATLASSERT(psz != NULL);

    LPWSTR p = psz;
    while (*p)
    {
        if (*p == wch)
        {
            *p = 0;
            return TRUE;
        }
        p = CharNextW(p);
    }
    return FALSE;
}
//---------------------------------------------------------------------------
BOOL FileExists(LPCWSTR pszFileName)
{
    DWORD dwMask = GetFileAttributes(pszFileName);
    return (dwMask != 0xffffffff);
}
//---------------------------------------------------------------------------
BOOL UtilsStartUp()
{
    BOOL fRet = FALSE;
    hinstUxCtrl = NULL;

    if( InitializeCriticalSectionAndSpinCount(&_csUtils, 0) )
    {
        //---- set screen dpi (per session) ----
        HDC hdc = GetWindowDC(NULL);
        if (hdc)
        {
            g_iScreenDpi = GetDeviceCaps(hdc, LOGPIXELSX);
            ReleaseDC(NULL, hdc);
            fRet = TRUE;
        }
        else
        {
            SAFE_DELETECRITICALSECTION(&_csUtils);
        }
    }

    return fRet;
}
//---------------------------------------------------------------------------
BOOL UtilsShutDown()
{
    SAFE_DELETECRITICALSECTION(&_csUtils);

    if (hinstUxCtrl)
    {
        FreeLibrary(hinstUxCtrl);
        hinstUxCtrl = NULL;
    }

    return FALSE;
}
//---------------------------------------------------------------------------
HANDLE CmdLineRun(LPCTSTR pszExeName, LPCTSTR pszParams, BOOL fHide)
{
    STARTUPINFO si;
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(STARTUPINFO);
    si.dwFlags = STARTF_FORCEOFFFEEDBACK;       // don't mess with our cursor

    if (fHide)
    {
        si.dwFlags |= STARTF_USESHOWWINDOW;         // hide window
        si.wShowWindow = SW_HIDE;
    }

    PROCESS_INFORMATION pi;
    TCHAR szExeBuff[_MAX_PATH];
    TCHAR szParmsBuff[_MAX_PATH];

    // Copy to buffers to avoid AVs
    if (pszParams)
    {
        szParmsBuff[0] = L'"';

        // -1 for trailing NULL, -2 for quotation marks, -1 for space between EXE and args
        HRESULT hr = SafeStringCchCopyW(szParmsBuff+1, ARRAYSIZE(szParmsBuff) - 4, pszExeName);
        if (FAILED(hr))
            return NULL;

        int cchUsed = lstrlen(szParmsBuff);
        szParmsBuff[cchUsed++] = L'"'; // closing quotation mark
        szParmsBuff[cchUsed++] = L' '; // We need a space before the cmd line
        hr = SafeStringCchCopyW(szParmsBuff + cchUsed, ARRAYSIZE(szParmsBuff) - cchUsed - 1, pszParams);
        if (FAILED(hr))
            return NULL;
    }

    LPTSTR lpFilePart;

    if (0 == SearchPath(NULL, pszExeName, NULL, ARRAYSIZE(szExeBuff), szExeBuff, &lpFilePart))
        return NULL;

    BOOL bSuccess = CreateProcess(szExeBuff, pszParams ? szParmsBuff : NULL, NULL, NULL,
        FALSE, 0, NULL, NULL, &si, &pi);
    if (! bSuccess)
        return NULL;

    return pi.hProcess;
}
//---------------------------------------------------------------------------
HRESULT SyncCmdLineRun(LPCTSTR pszExeName, LPCTSTR pszParams)
{
    HANDLE hInst;

    hInst = CmdLineRun(pszExeName, pszParams);
    if (! hInst)
    {
        Log(LOG_ALWAYS, L"CmdLineRun failed to create hInst.  Cmd=%s", pszExeName);
        return MakeError32(E_FAIL);      // could not run program
    }

    HRESULT hr = S_OK;

    //---- wait for packthem to terminate ----
    DWORD dwVal;
    dwVal = WaitForSingleObject(hInst, INFINITE);

    if (dwVal != WAIT_OBJECT_0)
    {
        Log(LOG_ERROR, L"CmdLineRun timed out.  Cmd=%s", pszExeName);
        hr = MakeError32(E_FAIL);            // timed out
        goto exit;
    }

    DWORD dwExitCode;
    if (! GetExitCodeProcess(hInst, &dwExitCode))
    {
        Log(LOG_ALWAYS, L"CmdLineRun failed to get exit code.  Cmd=%s", pszExeName);
        hr = MakeError32(E_FAIL);          // could not get exit code
        goto exit;
    }

    if (dwExitCode)
    {
        Log(LOG_ALWAYS, L"CmdLineRun returned error.  Cmd=%s, ExitCode=%d", pszExeName, dwExitCode);
        hr = MakeError32(E_FAIL);          // did not complete successfully
        goto exit;
    }

exit:

    CloseHandle(hInst);
    return hr;
}
//---------------------------------------------------------------------------
BOOL TokenHasPrivilege( IN OPTIONAL HANDLE hToken, DWORD dwPrivilege )
{
    BOOL    fRet = FALSE;
    HANDLE  hTokenRelease = NULL;

    if( NULL == hToken )
    {
        if( !OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hTokenRelease) )
        {
            return FALSE;
        }
        hToken = hTokenRelease;
    }

    ASSERT(hToken != NULL);

    DWORD cbRet = 0;

    GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &cbRet );
    if( cbRet > 0 )
    {
        PVOID pvPrivs = LocalAlloc(LMEM_FIXED, cbRet);
        if( pvPrivs )
        {
            if( GetTokenInformation(hToken, TokenPrivileges, pvPrivs, cbRet, &cbRet) )
            {
                TOKEN_PRIVILEGES*   pTokenPrivs = (TOKEN_PRIVILEGES*)pvPrivs;
                LUID                luidPrivilege;

                luidPrivilege.LowPart = dwPrivilege;
                luidPrivilege.HighPart = 0;

                for (UINT i = 0; i < pTokenPrivs->PrivilegeCount; i++)
                {
                    if( RtlEqualLuid(&pTokenPrivs->Privileges[i].Luid, &luidPrivilege) )
                    {
                        fRet = TRUE;
                        break;
                    }
                }
            }

            LocalFree(pvPrivs);
        }
    }

    if( hTokenRelease )
    {
        CloseHandle(hTokenRelease);
    }
    return fRet;
}
//---------------------------------------------------------------------------
//  color conversion routines copied from comdlg\color2.c
//---------------------------------------------------------------------------
#define HLSMAX  240
#define RGBMAX  255
#define UNDEFINED (HLSMAX * 2 / 3)
//---------------------------------------------------------------------------
void RGBtoHLS(COLORREF rgb, WORD *pwHue, WORD *pwLum, WORD *pwSat)
{
    WORD R, G, B;                 // input RGB values
    WORD cMax,cMin;               // max and min RGB values
    WORD cSum,cDif;
    SHORT Rdelta, Gdelta, Bdelta; // intermediate value: % of spread from max

    WORD bHue, bLum, bSat;
    //
    //  get R, G, and B out of DWORD.
    //
    R = GetRValue(rgb);
    G = GetGValue(rgb);
    B = GetBValue(rgb);

    //
    //  Calculate lightness.
    //
    cMax = max(max(R, G), B);
    cMin = min(min(R, G), B);
    cSum = cMax + cMin;
    bLum = (WORD)(((cSum * (DWORD)HLSMAX) + RGBMAX) / (2 * RGBMAX));

    cDif = cMax - cMin;
    if (!cDif)
    {
        //
        //  r = g = b --> Achromatic case.
        //
        bSat = 0;                         // saturation
        bHue = UNDEFINED;                 // hue
    }
    else
    {
        //
        //  Chromatic case.
        //

        //
        //  Saturation.
        //
        //  Note: Division by cSum is not a problem, as cSum can only
        //        be 0 if the RGB value is 0L, and that is achromatic.
        //
        if (bLum <= (HLSMAX / 2))
        {
            bSat = (WORD)(((cDif * (DWORD) HLSMAX) + (cSum / 2) ) / cSum);
        }
        else
        {
            bSat = (WORD)((DWORD)((cDif * (DWORD)HLSMAX) +
                               (DWORD)((2 * RGBMAX - cSum) / 2)) /
                       (2 * RGBMAX - cSum));
        }

        //
        //  Hue.
        //
        Rdelta = (SHORT)((((cMax - R) * (DWORD)(HLSMAX / 6)) + (cDif / 2) ) / cDif);
        Gdelta = (SHORT)((((cMax - G) * (DWORD)(HLSMAX / 6)) + (cDif / 2) ) / cDif);
        Bdelta = (SHORT)((((cMax - B) * (DWORD)(HLSMAX / 6)) + (cDif / 2) ) / cDif);

        if (R == cMax)
        {
            bHue = Bdelta - Gdelta;
        }
        else if (G == cMax)
        {
            bHue = (WORD)((HLSMAX / 3) + Rdelta - Bdelta);
        }
        else  // (B == cMax)
        {
            bHue = (WORD)(((2 * HLSMAX) / 3) + Gdelta - Rdelta);
        }

        if ((short)bHue < 0)
        {
            //
            //  This can occur when R == cMax and G is > B.
            //
            bHue += HLSMAX;
        }
        if (bHue >= HLSMAX)
        {
            bHue -= HLSMAX;
        }
    }

    if (pwHue)
        *pwHue = bHue;

    if (pwLum)
        *pwLum = bLum;

    if (pwSat)
        *pwSat = bSat;
}
//---------------------------------------------------------------------------
WORD HueToRGB(WORD n1, WORD n2, WORD hue)
{
    if (hue >= HLSMAX)
    {
        hue -= HLSMAX;
    }

    //
    //  Return r, g, or b value from this tridrant.
    //
    if (hue < (HLSMAX / 6))
    {
        return ((WORD)(n1 + (((n2 - n1) * hue + (HLSMAX / 12)) / (HLSMAX / 6))));
    }
    if (hue < (HLSMAX/2))
    {
        return (n2);
    }
    if (hue < ((HLSMAX*2)/3))
    {
        return ((WORD)(n1 + (((n2 - n1) * (((HLSMAX * 2) / 3) - hue) +
                       (HLSMAX / 12)) / (HLSMAX / 6))));
    }
    else
    {
        return (n1);
    }
}
//---------------------------------------------------------------------------
DWORD HLStoRGB(WORD hue, WORD lum, WORD sat)
{
    WORD R, G, B;                      // RGB component values
    WORD Magic1, Magic2;               // calculated magic numbers

    if (sat == 0)
    {
        //
        //  Achromatic case.
        //
        R = G = B = (WORD)((lum * RGBMAX) / HLSMAX);
    }
    else
    {
        //
        //  Chromatic case
        //

        //
        //  Set up magic numbers.
        //
        if (lum <= (HLSMAX / 2))
        {
            Magic2 = (WORD)((lum * ((DWORD)HLSMAX + sat) + (HLSMAX / 2)) / HLSMAX);
        }
        else
        {
            Magic2 = lum + sat -
                     (WORD)(((lum * sat) + (DWORD)(HLSMAX / 2)) / HLSMAX);
        }
        Magic1 = (WORD)(2 * lum - Magic2);

        //
        //  Get RGB, change units from HLSMAX to RGBMAX.
        //
        R = (WORD)(((HueToRGB(Magic1, Magic2, (WORD)(hue + (HLSMAX / 3))) *
                     (DWORD)RGBMAX + (HLSMAX / 2))) / HLSMAX);
        G = (WORD)(((HueToRGB(Magic1, Magic2, hue) *
                     (DWORD)RGBMAX + (HLSMAX / 2))) / HLSMAX);
        B = (WORD)(((HueToRGB(Magic1, Magic2, (WORD)(hue - (HLSMAX / 3))) *
                     (DWORD)RGBMAX + (HLSMAX / 2))) / HLSMAX);
    }
    return (RGB(R, G, B));
}
//---------------------------------------------------------------------------
HRESULT GetPtrToResource(HINSTANCE hInst, LPCWSTR pszResType, LPCWSTR pszResName,
    OUT void **ppBytes, OPTIONAL OUT DWORD *pdwBytes)
{
    HRSRC hRsc = FindResource(hInst, pszResName, pszResType);
    if (! hRsc)
        return MakeErrorLast();

    DWORD dwBytes = SizeofResource(hInst, hRsc);
    if (! dwBytes)
        return MakeErrorLast();

    HGLOBAL hGlobal = LoadResource(hInst, hRsc);
    if (! hGlobal)
        return MakeErrorLast();

    void *v = (WCHAR *)LockResource(hGlobal);
    if (! v)
        return MakeErrorLast();

    *ppBytes = v;

    if (pdwBytes)
        *pdwBytes = dwBytes;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT GetResString(HINSTANCE hInst, LPCWSTR pszResType, int id, LPWSTR pszBuff,
    DWORD cchBuff)
{
    WCHAR *p;

    HRESULT hr = GetPtrToResource(hInst, pszResType, MAKEINTRESOURCE(1), (void **)&p);
    if (SUCCEEDED(hr))
    {
        while ((*p) && (id))
        {
            p += (1 + lstrlen(p));
            id--;
        }

        if (*p)
        {
            hr = SafeStringCchCopyW(pszBuff, cchBuff, p);
        }
        else
        {
            hr = MakeError32(ERROR_NOT_FOUND);
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT AllocateTextResource(HINSTANCE hInst, LPCWSTR pszResName, WCHAR **ppszText)
{
    WCHAR *p, *q;
    DWORD dwBytes, dwChars;
    HRESULT hr;

    //---- allocate so that we can add a NULL at the end of the file string ----

    hr = GetPtrToResource(hInst, L"TEXTFILE", pszResName, (void **)&p, &dwBytes);
    if (FAILED(hr))
        goto exit;

    dwChars = (dwBytes+1)/2;

    if ((dwChars) && (p[0] == 0xfeff))       // remove UNICODE hdr
    {
        dwChars--;
        p++;
    }

    q = new WCHAR[dwChars+1];
    if (!q)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    CopyMemory(q, p, dwChars*sizeof(WCHAR));
    q[dwChars] = 0;

    *ppszText = q;

exit:
    return hr;
}
//---------------------------------------------------------------------------
void ApplyStringProp(HWND hwnd, LPCWSTR pszStringVal, ATOM atom)
{
    if (hwnd)
    {
        //---- remove previous value ----
        ATOM atomStringVal = (ATOM)GetProp(hwnd, (LPCTSTR)atom);
        if (atomStringVal)
        {
            DeleteAtom(atomStringVal);      // decrement refcnt
            RemoveProp(hwnd, (LPCTSTR)atom);
        }

        //---- add new string as an atom ----
        if (pszStringVal)
        {
            //---- if string is empty, change it since AddAtom() doesn't ----
            //---- support empty strings (returns NULL) ----
            if (! *pszStringVal)
                pszStringVal = L"$";       // should never compare equal to a class name

            atomStringVal = AddAtom(pszStringVal);
            if (atomStringVal)
                SetProp(hwnd, (LPCTSTR)atom, (void *)atomStringVal);
        }
    }
}
//---------------------------------------------------------------------------
HRESULT EnsureUxCtrlLoaded()
{
    CAutoCS cs(&_csUtils);

    if (! hinstUxCtrl)
    {
        TCHAR szPath[MAX_PATH];
        GetModuleFileName(GetModuleHandle(TEXT("UxTheme.dll")), szPath, ARRAYSIZE(szPath));

        ACTCTX act = {0};
        act.cbSize = sizeof(act);
        act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
        act.lpResourceName = MAKEINTRESOURCE(1);
        act.lpSource = szPath;
        HANDLE hActCtx = CreateActCtx(&act);
        ULONG_PTR ulCookie = 0;
        if (hActCtx != INVALID_HANDLE_VALUE)
            ActivateActCtx(hActCtx, &ulCookie);

        hinstUxCtrl = LoadLibrary(L"comctl32.dll");

        if (ulCookie)
            DeactivateActCtx(0, ulCookie);

        if (hActCtx != INVALID_HANDLE_VALUE)
            ReleaseActCtx(hActCtx);
    }

    if ((hinstUxCtrl) && (! ImageList_DrawProc))
    {
        ImageList_DrawProc = (IMAGE_DRAWPROC)GetProcAddress(hinstUxCtrl, "ImageList_DrawIndirect");
#if 1           // testing DrawThemeIcon()
        ImageList_LoadProc = (IMAGE_LOADPROC)GetProcAddress(hinstUxCtrl, "ImageList_LoadImage");
        ImageList_DestroyProc = (IMAGE_DESTROYPROC)GetProcAddress(hinstUxCtrl, "ImageList_Destroy");
#endif

        CCDrawShadowText = (PFNDRAWSHADOWTEXT)GetProcAddress(hinstUxCtrl, "DrawShadowText");
    }

    if ((ImageList_DrawProc) && (CCDrawShadowText))
        return S_OK;

    return MakeError32(E_FAIL);      // something went wrong
}
//---------------------------------------------------------------------------
BOOL IsUnicode(LPCSTR pszBuff, int *piUnicodeStartOffset)
{
    int iOffset = 0;
    BOOL fUnicode = FALSE;

    if ((pszBuff[0] == 0xff) && (pszBuff[1] == 0xfe))       // unicode marker
    {
        iOffset = 2;
        fUnicode = TRUE;
    }
    else if (! pszBuff[1])
    {
        // this check works well for .ini files because of the limited
        // legal chars it can start with
        fUnicode = TRUE;
    }

    if (piUnicodeStartOffset)
        *piUnicodeStartOffset = iOffset;

    return fUnicode;
}
//---------------------------------------------------------------------------
HRESULT AnsiToUnicode(LPSTR pszSource, LPWSTR pszDest, DWORD cchDest)
{
    int len = 1 + static_cast<int>(strlen(pszSource));

    int retval = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszSource, len,
        pszDest, cchDest);
    if (! retval)
        return MakeErrorLast();

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT AllocateTextFile(LPCWSTR szFileName, OUT LPWSTR *ppszFileText,
   OUT OPTIONAL BOOL *pfWasAnsi)
{
    HRESULT hr;
    CSimpleFile infile;

    hr = infile.Open(szFileName);
    if (FAILED(hr))
        return hr;

    //---- read the file ----
    DWORD len = infile.GetFileSize();

    //---- assume ANSI; adjust if UNICODE ----
    DWORD dw;
    LPSTR pOrig = (LPSTR) LocalAlloc(0, 2+len);          // space for 2-byte UNICODE NULL
    if (! pOrig)
        return MakeErrorLast();

    if (len)
    {
        hr = infile.Read((LPSTR)pOrig, len, &dw);
        if (FAILED(hr))
        {
            LocalFree(pOrig);
            return hr;
        }

        if (dw != len)
        {
            LocalFree(pOrig);
            return MakeError32(E_FAIL);
        }
    }

    infile.Close();

    //---- null terminate for both cases ----
    pOrig[len] = 0;
    pOrig[len+1] = 0;

    int iOffset;

    if (IsUnicode(pOrig, &iOffset))
    {
        if ((iOffset) && (len))     // shift away the UNICODE signature bits
            memmove(pOrig, pOrig+iOffset, len-iOffset);

        *ppszFileText = (LPWSTR)pOrig;

        if (pfWasAnsi)
            *pfWasAnsi = FALSE;

        return S_OK;
    }

    //---- need to translate to UNICODE ----
    LPWSTR pUnicode = (LPWSTR) LocalAlloc(0, sizeof(WCHAR)*(len+1));
    if (! pUnicode)
    {
        hr = MakeErrorLast();
        LocalFree(pOrig);
        return hr;
    }

    hr = AnsiToUnicode((LPSTR)pOrig, pUnicode, len+1);
    if (FAILED(hr))
    {
        LocalFree(pOrig);
        LocalFree(pUnicode);
        return hr;
    }

    LocalFree(pOrig);
    *ppszFileText = pUnicode;

    if (pfWasAnsi)
        *pfWasAnsi = TRUE;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT TextToFile(LPCWSTR szFileName, LPCWSTR szText)
{
    CSimpleFile outfile;
    HRESULT hr = outfile.Create(szFileName);
    if (FAILED(hr))
        return hr;

    hr = outfile.Write((void*)szText, lstrlenW(szText)*sizeof(WCHAR));
    if (FAILED(hr))
        return hr;

    outfile.Close();

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT AddPathIfNeeded(
    LPCWSTR pszFileName, 
    LPCWSTR pszPath, 
    LPWSTR pszFullName,
    ULONG cchFullName)
{
    HRESULT hr;

    if (! pszFileName)
        return MakeError32(E_FAIL);

    DWORD len = lstrlen(pszFileName);
    BOOL fQualified = ((*pszFileName == L'\\') || ((len > 1) && (pszFileName[1] == ':')));

    if (fQualified)
    {
        if (cchFullName < len+1)
            return MakeError32(E_FAIL);

        hr = SafeStringCchCopyW(pszFullName, cchFullName, pszFileName);
        if (FAILED(hr))
            return hr;
    }
    else
    {
        DWORD len2 = lstrlen(pszPath);
        if (cchFullName < len+len2+2)
            return MakeError32(E_FAIL);

        if ((len2) && (pszPath[len2-1] == '\\'))
            StringCchPrintfW(pszFullName, cchFullName, L"%s%psz", pszPath, pszFileName);
        else
            StringCchPrintfW(pszFullName, cchFullName, L"%s\\%s", pszPath, pszFileName);
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HICON _GetWindowIcon(HWND hwnd, BOOL fPerferLargeIcon)
{
    const WPARAM rgGetIconParam[] = { ICON_SMALL2, ICON_SMALL, ICON_BIG };
    const WPARAM rgGetIconParamLarge[] = { ICON_BIG, ICON_SMALL2, ICON_SMALL };
    const int    rgClassIconParam[] = { GCLP_HICONSM, GCLP_HICON };
    HICON hicon = NULL;
    const WPARAM * pIcons = (fPerferLargeIcon ? rgGetIconParamLarge : rgGetIconParam);
    int   i;

    //  try WM_GETICON
    for( i = 0; i < ARRAYSIZE(rgGetIconParam) && NULL == hicon; i++ )
    {
        SendMessageTimeout(hwnd, WM_GETICON, pIcons[i], 0, SMTO_ABORTIFHUNG | SMTO_BLOCK,
            500, (PULONG_PTR)&hicon);
    }

    //  try GetClassLong
    for( i = 0; i < ARRAYSIZE(rgClassIconParam) && NULL == hicon; i++ )
    {
        // next we try the small class icon
        hicon = (HICON)GetClassLongPtr(hwnd, rgClassIconParam[i]);
    }

    return hicon;
}
//---------------------------------------------------------------------------
HRESULT SafeStringCchCopyW( LPWSTR pszDest, ULONG cchDest, LPCWSTR pszSrc )
{
    HRESULT hr = E_INVALIDARG;

    if( pszDest )
    {
        if( cchDest ) 
        {
            if( pszSrc )
            {
                hr = StringCchCopyW(pszDest, cchDest, pszSrc);
            }
            else
            {
                *pszDest = 0;
                hr = S_OK;
            }
        }
        else
        {
            hr = S_OK;
        }
    }
    ASSERT(hr != E_INVALIDARG);
    return hr;
}
//---------------------------------------------------------------------------
HRESULT SafeStringCmpIW( LPCWSTR psz1, LPCWSTR psz2, UINT cchMax, OUT int* piCompare )
{
    *piCompare = 0;
    size_t cch;

    HRESULT hr = StringCchLengthW((LPWSTR)psz1, cchMax, &cch);
    if( FAILED(hr) )
    {
        *piCompare = 1;
        return hr;
    }

    hr = StringCchLengthW((LPWSTR)psz2, cchMax, &cch);
    if( FAILED(hr) )
    {
        *piCompare = -1;
        return hr;
    }

    *piCompare = lstrcmpiW(psz1, psz2);
    return S_OK;
}
//---------------------------------------------------------------------------
int string2number(LPCWSTR psz)
{
    int temp = 0, base = 10;
    int nNeg = 1;

    if (*psz == L'-')
    {
        nNeg = -1;
        psz++;
    }
    else if (*psz == L'+')
        psz++;
    if (*psz == '0')
    {
        ++psz;
        switch(*psz)
        {
        case L'X':
        case L'x':
            ++psz;
            base = 16;
            break;
        }
    }
    while (*psz)
    {
        switch (*psz)
        {
        case L'0': case L'1': case L'2': case L'3': case L'4':
        case L'5': case L'6': case L'7': case L'8': case L'9':
            temp = (temp * base) + (*psz++ - L'0');
            break;
        case L'a': case L'b': case L'c': case L'd': case L'e': case L'f':
            if (base == 10)
                return (nNeg*temp);
            temp = (temp * base) + (*psz++ - L'a' + 10);
            break;
        case L'A': case L'B': case L'C': case L'D': case L'E': case L'F':
            if (base == 10)
                return (nNeg*temp);
            temp = (temp * base) + (*psz++ - L'A' + 10);
            break;
        default:
            return (nNeg*temp);
        }
    }
    return (nNeg*temp);
}
//---------------------------------------------------------------------------
BOOL AsciiScanStringList(
    LPCWSTR pwszString,
    LPCWSTR* rgpwszList,
    int cStrings,
    BOOL fIgnoreCase )
{
    int (* pfnCompare)( LPCWSTR, LPCWSTR ) =
        fIgnoreCase ? AsciiStrCmpI : lstrcmp;

    for( int i = 0; i < cStrings; i++ )
    {
        if( 0 == pfnCompare( pwszString, rgpwszList[i] ) )
        {
            return TRUE;
        }
    }
    return FALSE;
}
//---------------------------------------------------------------------------
BOOL UnExpandEnvironmentString(LPCWSTR pszPath, LPCWSTR pszEnvVar, LPWSTR pszResult, UINT cchResult)
{
    DWORD nToCmp;
    WCHAR szEnvVar[MAX_PATH];
    szEnvVar[0] = 0;

    ExpandEnvironmentStringsW(pszEnvVar, szEnvVar, ARRAYSIZE(szEnvVar)); // don't count the NULL
    nToCmp = lstrlenW(szEnvVar);
   
    if (CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar, nToCmp, pszPath, nToCmp))
    {
        if (lstrlenW(pszPath) - (int)nToCmp  + lstrlenW(pszEnvVar) < (int)cchResult)
        {
            StringCchCopyW(pszResult, cchResult, pszEnvVar);
            StringCchCopyW(pszResult + lstrlenW(pszResult), cchResult, pszPath + nToCmp);
            return TRUE;
        }
    }
    return FALSE;
}
//---------------------------------------------------------------------------
HRESULT RegistryIntWrite(HKEY hKey, LPCWSTR pszValueName, int iValue)
{
    HRESULT hr = S_OK;
    WCHAR valbuff[_MAX_PATH+1];

    StringCchPrintfW(valbuff, ARRAYSIZE(valbuff), L"%d", iValue);
    int len = (1 + lstrlen(valbuff)) * sizeof(WCHAR);

    int code32 = RegSetValueEx(hKey, pszValueName, NULL, REG_SZ,
        (BYTE *)valbuff, len);

    if (code32 != ERROR_SUCCESS)
        hr = MakeError32(code32);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT RegistryStrWrite(HKEY hKey, LPCWSTR pszValueName, LPCWSTR pszValue)
{
    HRESULT hr = S_OK;
    int len = (1 + lstrlen(pszValue)) * (sizeof(WCHAR));

    int code32 = RegSetValueEx(hKey, pszValueName, NULL, REG_SZ,
        (BYTE *)pszValue, len);

    if (code32 != ERROR_SUCCESS)
        hr = MakeError32(code32);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT RegistryStrWriteExpand(HKEY hKey, LPCWSTR pszValueName, LPCWSTR pszValue)
{
    HRESULT hr = S_OK;
    int len;
    WCHAR szResult[_MAX_PATH + 1];
    LPCWSTR pszPath = pszValue;

    if (UnExpandEnvironmentString(pszValue, L"%SystemRoot%", szResult, ARRAYSIZE(szResult)))
        pszPath = szResult;

    len = (1 + lstrlen(pszPath)) * (sizeof(WCHAR));

    int code32 = RegSetValueEx(hKey, pszValueName, NULL, REG_EXPAND_SZ,
        (BYTE *)pszPath, len);

    if (code32 != ERROR_SUCCESS)
        hr = MakeError32(code32);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT RegistryIntRead(HKEY hKey, LPCWSTR pszValueName, int *piValue)
{
    HRESULT hr = S_OK;
    DWORD dwValType;
    WCHAR valbuff[_MAX_PATH+1];
    DWORD dwByteSize = sizeof(valbuff);         // bytes, not chars

    int code32 = RegQueryValueEx(hKey, pszValueName, NULL, &dwValType,
        (BYTE *)valbuff, &dwByteSize);

    if (code32 == ERROR_SUCCESS)
    {
        *piValue = string2number(valbuff);
    }
    else
        hr = MakeError32(code32);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT RegistryStrRead(HKEY hKey, LPCWSTR pszValueName, LPWSTR pszBuff, DWORD cchMax)
{
    HRESULT hr = S_OK;
    DWORD dwValType = 0;
    DWORD dwByteSize = cchMax * sizeof(WCHAR);      // in bytes

    int code32 = RegQueryValueEx(hKey, pszValueName, NULL, &dwValType,
        (BYTE *)pszBuff, &dwByteSize);

    if (code32 != ERROR_SUCCESS)
    {
        hr = MakeError32(code32);
        goto exit;
    }

    if (dwValType == REG_EXPAND_SZ || wcschr(pszBuff, L'%'))
    {
        int cch = sizeof(WCHAR) * (1 + lstrlen(pszBuff));
        LPWSTR pszTemp = new WCHAR[cch];
        if (pszTemp)
        {
            StringCchCopyW(pszTemp, cch, pszBuff);

            DWORD cchExpanded = ExpandEnvironmentStrings(pszTemp, pszBuff, cchMax);
            if (cchExpanded > cchMax)           // caller's buffer too small
            {
                hr = MakeError32(ERROR_INSUFFICIENT_BUFFER);
            }

            delete [] pszTemp;
        }
    }

exit:
    return hr;
}

//---------------------------------------------------------------------------
BOOL PreMultiplyAlpha(DWORD *pPixelBuff, UINT iWidth, UINT iHeight)
{
    BOOL fTrueAlpha = FALSE;

    DWORD *pdw = pPixelBuff;

    for (int i = iWidth * iHeight - 1; i >= 0; i--)
    {
        COLORREF cr = *pdw;
        int iAlpha = ALPHACHANNEL(cr);

        if ((iAlpha != 255) && (iAlpha != 0))
            fTrueAlpha = TRUE;

        pdw++;
    }

    pdw = pPixelBuff;
    
    if (fTrueAlpha)
    {
        for (UINT r=0; r < iHeight; r++)
        {
            for (UINT c=0; c < iWidth; c++)
            {
                COLORREF cr = *pdw;
                int iAlpha = ALPHACHANNEL(cr);

                int iRed = (RED(cr)*iAlpha)/255;
                int iGreen = (GREEN(cr)*iAlpha)/255;
                int iBlue = (BLUE(cr)*iAlpha)/255;

                *pdw++ = (RGB(iRed, iGreen, iBlue) | (iAlpha << 24));
            }
        }
    }

    return fTrueAlpha;
}

//---------------------------------------------------------------------------
// IsBiDiLocalizedSystem is taken from stockthk.lib and simplified
//  (it's only a wrapper for GetUserDefaultUILanguage and GetLocaleInfo)
//---------------------------------------------------------------------------
typedef struct {
    LANGID LangID;
    BOOL   bInstalled;
    } MUIINSTALLLANG, *LPMUIINSTALLLANG;

/***************************************************************************\
* ConvertHexStringToIntW
*
* Converts a hex numeric string into an integer.
*
* History:
* 14-June-1998 msadek    Created
\***************************************************************************/
BOOL ConvertHexStringToIntW( WCHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    WCHAR  *psz=pszHexNum;

    for(n=0 ; ; psz=CharNextW(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            WCHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}

/***************************************************************************\
* Mirror_EnumUILanguagesProc
*
* Enumerates MUI installed languages on W2k
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/

BOOL CALLBACK Mirror_EnumUILanguagesProc(LPTSTR lpUILanguageString, LONG_PTR lParam)
{
    int langID = 0;

    ConvertHexStringToIntW(lpUILanguageString, &langID);

    if((LANGID)langID == ((LPMUIINSTALLLANG)lParam)->LangID)
    {
        ((LPMUIINSTALLLANG)lParam)->bInstalled = TRUE;
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* Mirror_IsUILanguageInstalled
*
* Verifies that the User UI language is installed on W2k
*
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/
BOOL Mirror_IsUILanguageInstalled( LANGID langId )
{
    MUIINSTALLLANG MUILangInstalled = {0};
    MUILangInstalled.LangID = langId;
    
    EnumUILanguagesW(Mirror_EnumUILanguagesProc, 0, (LONG_PTR)&MUILangInstalled);

    return MUILangInstalled.bInstalled;
}

/***************************************************************************\
* IsBiDiLocalizedSystemEx
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5 or Memphis.
* Should be called whenever SetProcessDefaultLayout is to be called.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL IsBiDiLocalizedSystemEx( LANGID *pLangID )
{
    int           iLCID=0L;
    static BOOL   bRet = (BOOL)(DWORD)-1;
    static LANGID langID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    if (bRet != (BOOL)(DWORD)-1)
    {
        if (bRet && pLangID)
        {
            *pLangID = langID;
        }
        return bRet;
    }

    bRet = FALSE;
    /*
     * Need to use NT5 detection method (Multiligual UI ID)
     */
    langID = GetUserDefaultUILanguage();

    if( langID )
    {
        WCHAR wchLCIDFontSignature[16];
        iLCID = MAKELCID( langID , SORT_DEFAULT );

        /*
         * Let's verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
         * convert to decimal value and call GetLocaleInfo afterwards.
         * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
         */

        if( GetLocaleInfoW( iLCID , 
                            LOCALE_FONTSIGNATURE , 
                            (WCHAR *) &wchLCIDFontSignature[0] ,
                            (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
        {
  
            /* Let's verify the bits we have a BiDi UI locale */
            if(( wchLCIDFontSignature[7] & (WCHAR)0x0800) && Mirror_IsUILanguageInstalled(langID) )
            {
                bRet = TRUE;
            }
        }
    }

    if (bRet && pLangID)
    {
        *pLangID = langID;
    }
    return bRet;
}
//---------------------------------------------------------------------------

BOOL IsBiDiLocalizedSystem( void )
{
    return IsBiDiLocalizedSystemEx(NULL);
}
//---------------------------------------------------------------------------

BOOL GetWindowDesktopName(HWND hwnd, LPWSTR pszName, DWORD cchMax)
{
    BOOL fGotName = FALSE;

    DWORD dwThreadId = GetWindowThreadProcessId(hwnd, NULL);
    HDESK hDesk = GetThreadDesktop(dwThreadId);
    if (hDesk)
    {
        fGotName = GetUserObjectInformation(hDesk, UOI_NAME, pszName, cchMax*sizeof(WCHAR), NULL);
    }

    return fGotName;
}
//---------------------------------------------------------------------------
void SafeSendMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DWORD dwFlags = SMTO_BLOCK | SMTO_ABORTIFHUNG;
    DWORD dwTimeout = 250;          // .25 secs
    ULONG_PTR puRetVal;

    if (! SendMessageTimeout(hwnd, uMsg, wParam, lParam, dwFlags, dwTimeout, &puRetVal))
    {
        Log(LOG_TMLOAD, L"SEND TIMEOUT: msg=0x%x being POSTED to hwnd=0x%x",
            uMsg, hwnd);

        PostMessage(hwnd, uMsg, wParam, lParam);
    }
}
//---------------------------------------------------------------------------
int FontPointSize(int iFontHeight)
{
    return -MulDiv(iFontHeight, 72, THEME_DPI);
}
//---------------------------------------------------------------------------
void ScaleFontForHdcDpi(HDC hdc, LOGFONT *plf)
{
    if (plf->lfHeight < 0)          // specified in points
    {
        if (! hdc)
        {
            ScaleFontForScreenDpi(plf);
        }
        else
        {
            int iDpi = GetDeviceCaps(hdc, LOGPIXELSX);
            plf->lfHeight = MulDiv(plf->lfHeight, iDpi, THEME_DPI);
        }
    }
}

//---------------------------------------------------------------------------
int ScaleSizeForHdcDpi(HDC hdc, int iValue)
{
    int iScaledValue;

    if (! hdc)
    {
        iScaledValue = ScaleSizeForScreenDpi(iValue);
    }
    else
    {
        int iDpi = GetDeviceCaps(hdc, LOGPIXELSX);
        iScaledValue = MulDiv(iValue, iDpi, THEME_DPI);
    }

    return iScaledValue;
}
//---------------------------------------------------------------------------
//  --------------------------------------------------------------------------
//  MinimumDisplayColorDepth
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//              
//  Purpose:    Iterates all monitors attached to the system and finds those
//              that are active. Returns the lowest bit depth availabe. This
//              is the lowest common denominator.
//
//  History:    2001-04-11  lmouton     moved from services.cpp
//              2000-11-11  vtan        created (rewritten from themeldr.cpp)
//  --------------------------------------------------------------------------

DWORD   MinimumDisplayColorDepth (void)

{
    DWORD           dwMinimumDepth, dwIndex;
    bool            fContinue;
    DISPLAY_DEVICE  displayDevice;

    dwMinimumDepth = 0;
    ZeroMemory(&displayDevice, sizeof(displayDevice));
    dwIndex = 0;
    do
    {
        displayDevice.cb = sizeof(displayDevice);
        fContinue = (EnumDisplayDevices(NULL, dwIndex++, &displayDevice, 0) != FALSE);
        if (fContinue)
        {
            if ((displayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) != 0)
            {
                DEVMODE     devMode;

                ZeroMemory(&devMode, sizeof(devMode));
                devMode.dmSize = sizeof(devMode);
                devMode.dmDriverExtra = 0;
                if (EnumDisplaySettings(displayDevice.DeviceName, ENUM_CURRENT_SETTINGS, &devMode) != FALSE)
                {
                    if ((dwMinimumDepth == 0) || (dwMinimumDepth > devMode.dmBitsPerPel))
                    {
                        dwMinimumDepth = devMode.dmBitsPerPel;
                    }
                }
            }
        }
    } while (fContinue);
    
    // Note: We can fail here (return 0) because when a session is disconnected, the desktop is attached to 
    // a hidden display. OK to fail silently then.

    return(dwMinimumDepth);
}

//  --------------------------------------------------------------------------
//  CheckMinColorDepth
//
//  Arguments:  hInst           msstyle module handle
//              dwCurMinDepth   current minimum active screen resolution
//              iIndex          index to the color/size combo to test, or
//                              -1 to enumerate them all        
//
//  Returns:    bool            true if at least a color/size combo supports
//                              the current screen resolution
//              
//  History:    2001-04-11  lmouton     created
//  --------------------------------------------------------------------------
bool CheckMinColorDepth(HINSTANCE hInst, DWORD dwCurMinDepth, int iIndex)
{
    BYTE *pBytes = NULL;
    DWORD dwBytes = 0;

    bool bMatch = true; // OK if the resource doesn't exist

    if (SUCCEEDED(GetPtrToResource(hInst, L"MINDEPTH", MAKEINTRESOURCE(1), (void**) &pBytes, &dwBytes)) && dwBytes > 0)
    {
        bMatch = false;

        if (iIndex != -1)
        {
            if (*((WORD*) pBytes + iIndex) <= dwCurMinDepth)
                bMatch = true;
        }
        else
        {
            WORD wDepth = *((WORD*) pBytes);

            while (wDepth != 0)
            {
                if (wDepth <= (WORD) dwCurMinDepth)
                {
                    bMatch = true;
                    break;
                }
                pBytes += sizeof(WORD);
                wDepth = *((WORD*) pBytes);
            }
        }
    }

    return bMatch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themesel\pch.cpp ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themesel\pch.h ===
// pch.h

#ifndef __PCH_H__
#define __PCH_H__

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

//  CRT headers
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//#include <crtdbg.h>
#include <stdlib.h>
#include <stddef.h>
//#include <tchar.h>

// Windows Header Files:
#include <windows.h>
#include <winuser.h>
#include <winnls.h>
#include <uxthemep.h>

#include <psapi.h>
#include <commctrl.h>
#include <prsht.h>
//#include <ole2.h>
#include <port32.h>

#include "log.h"
#include <atlbase.h>

#define STRSAFE_LIB
#include <strsafe.h>

//  UxTheme proj common headers
#include "autos.h"
#include "errors.h"
#include "utils.h"
#include "tmreg.h"



//---- keep this for a while (allows building on win2000 for home development) ----
#ifndef SPI_GETDROPSHADOW
#define SPI_GETDROPSHADOW                   0x1024
#define SPI_SETDROPSHADOW                   0x1025
#endif

extern HINSTANCE      g_hInst;
extern HWND           g_hwndMain;
extern TCHAR          g_szAppTitle[];
extern UINT           WM_THEMESEL_COMMUNICATION;

void _ShutDown( BOOL bQuit );
void _RestoreSystemSettings( HWND hwndGeneralPage, BOOL fUnloadOneOnly );
void _SaveSystemSettings( );

#endif // __PCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themesel\pageinfo.h ===
#ifndef __PAGEINFO_H__
#define __PAGEINFO_H__

typedef HWND (CALLBACK *PAGECREATEINSTANCEPROC)(HWND hwndParent); 
//-------------------------------------------------------------------------//
typedef struct
{
    PAGECREATEINSTANCEPROC pfnCreateInstance;
    UINT                   nIDSTitle;

} PAGEINFO;

extern const int        g_cPageInfo;
extern const PAGEINFO   g_rgPageInfo[];

#endif __PAGEINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themesel\pageinfo.cpp ===
#include "pch.h"
#include "resource.h"
#include "pageinfo.h"

//-------------------------------------------------------------------------//
//  Page boot; Add your page info here...
//-------------------------------------------------------------------------//

//  (1) Add CreateInstance forward:
HWND CALLBACK GeneralPage_CreateInstance( HWND hwndParent );
HWND CALLBACK StylesPage_CreateInstance( HWND hwndParent );
HWND CALLBACK SBPage_CreateInstance( HWND hwndParent );

HWND CALLBACK StaticsPage_CreateInstance( HWND hwndParent );
HWND CALLBACK ButtonsPage_CreateInstance( HWND hwndParent );
HWND CALLBACK EditPage_CreateInstance( HWND hwndParent );
HWND CALLBACK ListsPage_CreateInstance( HWND hwndParent );
HWND CALLBACK MoversPage_CreateInstance( HWND hwndParent );
HWND CALLBACK ListViewPage_CreateInstance( HWND hwndParent );
HWND CALLBACK TreeViewPage_CreateInstance( HWND hwndParent );
HWND CALLBACK PickersPage_CreateInstance( HWND hwndParent );
HWND CALLBACK BarsPage_CreateInstance( HWND hwndParent );
//-------------------------------------------------------------------------//
//  (2) Add PageInfo entry
const PAGEINFO g_rgPageInfo[] =
{
    { GeneralPage_CreateInstance, IDS_PAGE_GENERAL },
    { StylesPage_CreateInstance,  IDS_PAGE_STYLES },
    { SBPage_CreateInstance,      IDS_PAGE_SCROLLBARS },
    { StaticsPage_CreateInstance, IDS_PAGE_STATICS },
    { ButtonsPage_CreateInstance, IDS_PAGE_BUTTONS },
    { EditPage_CreateInstance, IDS_PAGE_EDIT },
    { ListsPage_CreateInstance, IDS_PAGE_LISTS },
    { MoversPage_CreateInstance, IDS_PAGE_MOVERS },
    { ListViewPage_CreateInstance, IDS_PAGE_LISTVIEW },
    { TreeViewPage_CreateInstance, IDS_PAGE_TREEVIEW },
    { PickersPage_CreateInstance, IDS_PAGE_PICKERS },
    { BarsPage_CreateInstance, IDS_PAGE_BARS },
};
const int g_cPageInfo = ARRAYSIZE(g_rgPageInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themesel\sample.h ===
//---------------------------------------------------------------------------
//  Sample.h - dialog for sampling the active theme
//---------------------------------------------------------------------------
#pragma once
#include "resource.h"
//---------------------------------------------------------------------------
class CSample : public CDialogImpl<CSample>
{
public:
    CSample();

BEGIN_MSG_MAP(CSample)
    COMMAND_HANDLER(IDC_MSGBOXBUTTON, BN_CLICKED, OnMsgBox)
    COMMAND_HANDLER(IDC_EDITTHEME, BN_CLICKED, OnEditTheme)

    MESSAGE_HANDLER(WM_CLOSE, OnClose);
END_MSG_MAP()

enum {IDD = THEME_SAMPLE};

protected:
    //---- helpers ----
    LRESULT OnMsgBox(UINT, UINT, HWND, BOOL&);
    LRESULT OnEditTheme(UINT, UINT, HWND, BOOL&);

    LRESULT OnClose(UINT, WPARAM, LPARAM, BOOL&);
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themesel\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ThemeSel.rc
//
#define IDC_MYICON                      2
#define IDD_PAGE_GENERAL                101
#define IDD_THEMESEL_DIALOG             102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDS_PAGE_GENERAL                104
#define IDD_SYNTAX                      104
#define IDM_EXIT                        105
#define IDS_PAGE_SAMPLE                 105
#define IDS_PAGE_STYLES                 105
#define IDM_APPLY                       106
#define IDS_HELLO                       106
#define IDS_PAGE_SCROLLBARS             106
#define IDM_REMOVE                      107
#define IDI_THEMESEL                    107
#define IDI_SMALL                       108
#define IDC_THEMESEL                    109
#define IDS_PAGE_STATICS                110
#define IDS_PAGE_BUTTONS                111
#define IDS_PAGE_EDIT                   112
#define IDS_PAGE_LISTS                  113
#define IDS_PAGE_MOVERS                 114
#define IDS_PAGE_LISTVIEW               115
#define IDS_PAGE_TREEVIEW               116
#define IDS_PAGE_PICKERS                117
#define IDS_PAGE_BARS                   118
#define IDR_MAINFRAME                   128
#define IDD_SCROLLBARS                  129
#define IDD_EDIT                        130
#define IDD_PICKERS                     131
#define IDD_LISTVIEW                    132
#define IDD_BUTTONS                     133
#define IDD_TREEVIEW                    134
#define IDD_LISTS                       136
#define IDD_MOVERS                      138
#define IDD_STATICS                     139
#define IDD_BARS                        140
#define IDR_TOOLBAR1                    141
#define IDD_PAGE_STYLES                 142
#define IDB_BACKGROUND                  143
#define IDC_TESTBUTTON                  1000
#define IDC_WS_MINIMIZEBOX              1000
#define IDC_SBHORZ                      1000
#define IDC_MSGBOXBUTTON                1001
#define IDC_CLEARBUTTON                 1001
#define IDC_WS_MAXIMIZEBOX              1001
#define IDC_VERTICAL                    1001
#define IDC_EDIT3                       1001
#define IDC_EDITTHEME                   1002
#define IDC_WS_CAPTION                  1002
#define IDC_EDIT_THEME                  1002
#define IDC_HORIZONTAL                  1002
#define IDC_WS_BORDER                   1003
#define IDC_WS_DLGFRAME                 1004
#define IDC_THEME_ALL                   1004
#define IDC_WS_VSCROLL                  1005
#define IDC_SBCTL_PORT                  1005
#define IDC_WS_HSCROLL                  1006
#define IDC_THEME_PROCESS               1006
#define IDC_WINDOW_SB                   1006
#define IDC_WS_SYSMENU                  1007
#define IDC_TARGET                      1007
#define IDC_SBCTL_PORT2                 1007
#define IDC_SBCTL_STANDARD              1007
#define IDC_WS_THICKFRAME               1008
#define IDC_ENABLEHOOK                  1008
#define IDC_ENABLE_TEMPCTL              1008
#define IDC_WS_OVERLAPPEDWINDOW         1009
#define IDC_ENABLE_FRAME                1009
#define IDC_WS_MINIMIZEBOX2             1009
#define IDC_WS_POPUPWINDOW              1010
#define IDC_ENABLE_DLG                  1010
#define IDC_MIN                         1010
#define IDC_WS_MAXIMIZEBOX2             1010
#define IDC_THEME_EXEMPT                1011
#define IDC_MAX                         1011
#define IDC_WS_CAPTION2                 1011
#define IDC_UNTARGET                    1012
#define IDC_PAGE                        1012
#define IDC_WS_BORDER2                  1012
#define IDC_POS                         1013
#define IDC_WS_DLGFRAME2                1013
#define IDC_THEME_EXEMPT2               1013
#define IDC_USERSWITCH                  1013
#define IDC_TRACKPOS                    1014
#define IDC_WS_VSCROLL2                 1014
#define IDC_WS_HSCROLL2                 1015
#define IDC_WS_SYSMENU2                 1016
#define IDC_MSGLIST                     1017
#define IDC_WS_THICKFRAME2              1017
#define IDC_SBVERT                      1019
#define IDC_EDIT1                       1024
#define IDC_BUTTON1                     1025
#define IDC_EDIT2                       1026
#define IDC_CHECK1                      1027
#define IDC_RADIO1                      1028
#define IDC_BUTTON4                     1029
#define IDC_COMBO1                      1030
#define IDC_LIST1                       1031
#define IDC_BUTTON5                     1032
#define IDC_LIST2                       1033
#define IDC_RADIO2                      1034
#define IDC_COMBO2                      1035
#define IDC_SPIN1                       1036
#define IDC_RADIO3                      1037
#define IDC_COMBO3                      1038
#define IDC_WS_EX_DLGMODALFRAME         1050
#define IDC_SBVERTP                     1051
#define IDC_WS_EX_DLGMODALFRAME2        1051
#define IDC_CHECK2                      1052
#define IDC_PROGRESS1                   1053
#define IDC_WS_EX_TOOLWINDOW            1060
#define IDC_SBHORZP                     1061
#define IDC_WS_EX_TOOLWINDOW2           1061
#define IDC_CHECK3                      1062
#define IDC_PROGRESS2                   1063
#define IDC_HOTKEY1                     1064
#define IDC_WS_EX_WINDOWEDGE            1065
#define IDC_SLIDER1                     1066
#define IDC_WS_EX_WINDOWEDGE2           1066
#define IDC_WS_EX_CLIENTEDGE            1067
#define IDC_TAB1                        1068
#define IDC_WS_EX_CLIENTEDGE2           1068
#define IDC_SLIDER2                     1069
#define IDC_ANIMATE1                    1080
#define IDC_WS_EX_CONTEXTHELP           1081
#define IDC_BUTTON2                     1082
#define IDC_WS_EX_CONTEXTHELP2          1082
#define IDC_SPIN3                       1083
#define IDC_TAB2                        1084
#define IDC_WS_EX_RIGHT                 1085
#define IDC_RICHEDIT2                   1086
#define IDC_WS_EX_RIGHT2                1086
#define IDC_BUTTON6                     1087
#define IDC_WS_EX_LEFT                  1088
#define IDC_DATETIMEPICKER1             1089
#define IDC_WS_EX_LEFT2                 1089
#define IDC_BUTTON3                     1100
#define IDC_WS_EX_RTLREADING            1101
#define IDC_MONTHCALENDAR1              1102
#define IDC_WS_EX_RTLREADING2           1102
#define IDC_BUTTON7                     1103
#define IDC_WS_EX_LEFTSCROLLBAR         1104
#define IDC_BUTTON8                     1105
#define IDC_WS_EX_LEFTSCROLLBAR2        1105
#define IDC_IPADDRESS1                  1106
#define IDC_WS_EX_RIGHTSCROLLBAR        1107
#define IDC_COMBOBOXEX1                 1108
#define IDC_WS_EX_RIGHTSCROLLBAR2       1108
#define IDC_WS_EX_STATICEDGE            1109
#define IDC_WS_EX_STATICEDGE2           1110
#define IDC_TREE1                       1120
#define IDC_COMBOBOXEX2                 1121
#define IDC_WS_EX_APPWINDOW             1122
#define IDC_TREE2                       1123
#define IDC_WS_EX_APPWINDOW2            1123
#define IDC_COMBOBOXEX3                 1124
#define IDC_WS_EX_OVERLAPPEDWINDOW      1125
#define IDC_SCROLLBAR1                  1126
#define IDC_WS_EX_OVERLAPPEDWINDOW2     1126
#define IDC_WS_EX_PALETTEWINDOW         1127
#define IDC_SCROLLBAR2                  1128
#define IDC_WS_EX_PALETTEWINDOW2        1128
#define IDC_RICHEDIT3                   1129
#define IDC_TOOLBAR1                    1140
#define IDC_WS_EX_LAYOUTRTL             1141
#define IDC_REBAR1                      1142
#define IDC_WS_EX_LAYOUTRTL2            1142
#define IDC_HEADER1                     1143
#define IDC_SPIN4                       1144
#define IDC_CUSTOM5                     1145
#define IDC_STATUS1                     1146
#define IDC_THEME_PREVIEW               1147
#define IDC_TARGETGROUP                 1148
#define IDC_TEST_WINDOW                 1200
#define IDC_PREVIEW                     1200
#define IDC_TEST_DIALOG                 1201
#define IDC_DISPLAYNAME                 1201
#define IDC_CLOSE_TEST_WINDOW           1202
#define IDC_TOOLTIP                     1202
#define IDC_WS_OVERLAPPED2              1203
#define IDC_AUTHOR                      1203
#define IDC_WS_POPUP2                   1205
#define IDC_WS_CHILD2                   1206
#define ID_BUTTON32774                  32774
#define ID_BUTTON32775                  32775
#define ID_BUTTON32776                  32776
#define ID_BUTTON32777                  32777
#define IDM_DUMP                        32778
#define IDC_DIRPROMPT                   35001
#define IDC_DIRNAME                     35002
#define IDC_COLORCOMBO                  35005
#define IDC_FONTCOMBO                   35006
#define IDC_SIZECOMBO                   35007
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        250
#define _APS_NEXT_COMMAND_VALUE         32779
#define _APS_NEXT_CONTROL_VALUE         1204
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themesel\samples.cpp ===
#include "pch.h"
#include "resource.h"
#include "main.h"

//-------------------------------------------------------------------------//
//  impl for all Samples pages
//-------------------------------------------------------------------------//

INT_PTR CALLBACK Shared_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );

INT_PTR CALLBACK Pickers_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
INT_PTR CALLBACK Movers_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
INT_PTR CALLBACK Lists_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
INT_PTR CALLBACK ListView_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
INT_PTR CALLBACK TreeView_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
INT_PTR CALLBACK Bars_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );

void Pickers_Init(HWND hwndPage);
void Movers_Init(HWND hwndPage);
void Lists_Init(HWND hwndPage);
void ListView_Init(HWND hwndPage, int iControlId);
void TreeView_Init(HWND hwndPage, int iControlId);

//---- init routines for "bars" dialog ----
void Header_Init(HWND hwndPage, int iControlId);
void Status_Init(HWND hwndPage, int iControlId);
void Toolbar_Init(HWND hwndPage, int iControlId, int iMaxButtons);
void Rebar_Init(HWND hwndPage, int iControlId);
//-------------------------------------------------------------------------//
// shared sample data

static WCHAR *Names[] = {L"One", L"Two", L"Three", L"Four", L"Five", L"Six",
    L"Seven", L"Eight", L"Nine", L"Ten", L"Eleven", L"Twelve", 
    L"Thirteen", L"Fourteen", L"Fifteen", L"Sixteen"};

static WCHAR *Buttons[] = {L"New", L"Open", L"Save", L"Cut",  L"Copy", L"Delete", 
    L"Undo", L"Redo", L"Print", L"Help\0"};

static int ButtonIndexes[] = {STD_FILENEW, STD_FILEOPEN, STD_FILESAVE, 
    STD_CUT, STD_COPY, STD_DELETE, STD_UNDO, STD_REDOW, STD_PRINT, STD_HELP};

static WCHAR *Columns[] = {L"Name", L"Phone", L"City", L"State"};

static WCHAR *Col1Items[] = {L"Chris", L"Lou", L"Richard", L"Mark", L"Roland", L"Paul",
    L"Scott", L"Aaron", L"Greg", L"Ken"};

static WCHAR *Col2Items[] = {L"555-1212", L"567-3434", L"656-4432", L"343-7788", L"706-0225", L"828-3043",
    L"706-4433", L"882-8080", L"334-3434", L"333-5430"};

static WCHAR *Col3Items[] = {L"Seattle", L"Redmond", L"Bellevue", L"Seattle", L"Woodinville", L"Kirkland",
    L"Kirkland", L"Woodinville", L"Redmond", L"Redmond"};
//-------------------------------------------------------------------------//
INT_PTR CALLBACK Shared_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            //Log(LOG_TMCHANGE, L"Creating hwnd=0x%x", hwndPage);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}
//-------------------------------------------------------------------------//
INT_PTR CALLBACK Pickers_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            Pickers_Init(hwndPage);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}

//-------------------------------------------------------------------------//
INT_PTR CALLBACK Movers_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            Movers_Init(hwndPage);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}

//-------------------------------------------------------------------------//
INT_PTR CALLBACK Lists_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            Lists_Init(hwndPage);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}
//-------------------------------------------------------------------------//
INT_PTR CALLBACK ListView_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            ListView_Init(hwndPage, IDC_LIST1);
            ListView_Init(hwndPage, IDC_LIST2);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}
//-------------------------------------------------------------------------//
INT_PTR CALLBACK TreeView_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            TreeView_Init(hwndPage, IDC_TREE1);
            TreeView_Init(hwndPage, IDC_TREE2);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}

//-------------------------------------------------------------------------//
INT_PTR CALLBACK Bars_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            Header_Init(hwndPage, IDC_HEADER1);
            Status_Init(hwndPage, IDC_STATUS1);
            // Toolbar_Init(hwndPage, IDC_TOOLBAR1);
            Rebar_Init(hwndPage, IDC_REBAR1);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}

//-------------------------------------------------------------------------//
void Pickers_Init(HWND hwndPage)
{
    HWND hwnd1 = GetDlgItem(hwndPage, IDC_TAB1);
    HWND hwnd2 = GetDlgItem(hwndPage, IDC_TAB2);
    TCITEM item;
    item.mask = TCIF_TEXT;

    for (int i=0; i < 4; i++)
    {
        item.pszText = Names[i];
        SendMessage(hwnd1, TCM_INSERTITEM, i, (LPARAM)&item);
        SendMessage(hwnd2, TCM_INSERTITEM, i, (LPARAM)&item);
    }
}

//-------------------------------------------------------------------------//
void Movers_Init(HWND hwndPage)
{
    HWND hwnd1 = GetDlgItem(hwndPage, IDC_PROGRESS1);
    HWND hwnd2 = GetDlgItem(hwndPage, IDC_PROGRESS2);
 
    SendMessage(hwnd1, PBM_SETRANGE, 0, MAKELPARAM(0, 100));
    SendMessage(hwnd2, PBM_SETRANGE, 0, MAKELPARAM(0, 100));

    SendMessage(hwnd1, PBM_SETPOS, 33, 0);
    SendMessage(hwnd2, PBM_SETPOS, 33, 0);
}
//-------------------------------------------------------------------------//
void Lists_Init(HWND hwndPage)
{
    HWND hwnds[7];

    hwnds[0] = GetDlgItem(hwndPage, IDC_LIST1);
    hwnds[1] = GetDlgItem(hwndPage, IDC_COMBO1);
    hwnds[2] = GetDlgItem(hwndPage, IDC_COMBO2);
    hwnds[3] = GetDlgItem(hwndPage, IDC_COMBO3);
    hwnds[4] = GetDlgItem(hwndPage, IDC_COMBOBOXEX1);
    hwnds[5] = GetDlgItem(hwndPage, IDC_COMBOBOXEX2);
    hwnds[6] = GetDlgItem(hwndPage, IDC_COMBOBOXEX3);

    //---- listbox ----
    SendMessage(hwnds[0], LB_RESETCONTENT, 0, 0);
    for (int j=0; j < ARRAYSIZE(Names); j++)
        SendMessage(hwnds[0], LB_ADDSTRING, 0, (LPARAM)Names[j]);
    SendMessage(hwnds[0], LB_SETCURSEL, 0, 0);

    //---- comboboxes ----
    for (int i=1; i < 4; i++)
    {
        SendMessage(hwnds[i], CB_RESETCONTENT, 0, 0);

        for (int j=0; j < ARRAYSIZE(Names); j++)
            SendMessage(hwnds[i], CB_ADDSTRING, 0, (LPARAM)Names[j]);

        SendMessage(hwnds[i], CB_SETCURSEL, 0, 0);
    }

    //---- combo EX boxes ----
    COMBOBOXEXITEM exitem;
    exitem.mask = CBEIF_TEXT ;

    for (i=4; i < 7; i++)
    {
        SendMessage(hwnds[i], CB_RESETCONTENT, 0, 0);

        for (int j=0; j < ARRAYSIZE(Names); j++)
        {
            exitem.iItem = j;
            exitem.pszText = Names[j];
            SendMessage(hwnds[i], CBEM_INSERTITEM, 0, (LPARAM)&exitem);
        }

        SendMessage(hwnds[i], CB_SETCURSEL, 0, 0);
    }

}
//-------------------------------------------------------------------------//
void ListView_Init(HWND hwndPage, int iControlId) 
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- initialize the colums ----
    LVCOLUMN lvc; 
    memset(&lvc, 0, sizeof(lvc));
 
    lvc.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT | LVCF_WIDTH; 
    lvc.fmt = LVCFMT_LEFT; 
    lvc.cx = 100; 
 
    // Add the columns. 
    for (int c=0; c < ARRAYSIZE(Columns); c++)
    {
        lvc.iSubItem = c;
        lvc.pszText = Columns[c];
        SendMessage(hwnd, LVM_INSERTCOLUMN, c, (LPARAM)&lvc);
    } 

    //---- initialize the items ----
    LVITEM item;
    memset(&item, 0, sizeof(item));
    item.mask = LVIF_TEXT;

    //---- add the items ----
    for (int i=0; i < ARRAYSIZE(Col1Items); i++)  
    {
        item.pszText = Col1Items[i];
        item.iItem = i;
        item.iSubItem = 0;
        SendMessage(hwnd, LVM_INSERTITEM, 0, (LPARAM)&item);

        item.iSubItem = 1;
        item.pszText = Col2Items[i];
        SendMessage(hwnd, LVM_SETITEM, 0, (LPARAM)&item);

        item.iSubItem = 2;
        item.pszText = Col3Items[i];
        SendMessage(hwnd, LVM_SETITEM, 0, (LPARAM)&item);
    }
}
//-------------------------------------------------------------------------//
void TreeView_Init(HWND hwndPage, int iControlId)
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- initialize the item ----
    TVINSERTSTRUCT tvs;
    memset(&tvs, 0, sizeof(tvs));
    tvs.itemex.mask = TVIF_TEXT;
    tvs.hInsertAfter = TVI_LAST;    

    tvs.itemex.pszText = L"Root";
    HTREEITEM hRoot = (HTREEITEM) SendMessage(hwnd, TVM_INSERTITEM, 0, (LPARAM)&tvs);

    //---- add the items ----
    for (int i=0; i < ARRAYSIZE(Col1Items); i++)  
    {
        tvs.itemex.pszText = Col1Items[i];
        tvs.hParent = hRoot;
        HTREEITEM hItem = (HTREEITEM) SendMessage(hwnd, TVM_INSERTITEM, 0, (LPARAM)&tvs);

        if (hItem)
        {
            TVINSERTSTRUCT tvchild;
            memset(&tvchild, 0, sizeof(tvchild));
            tvchild.itemex.mask = TVIF_TEXT;
            tvchild.hInsertAfter = TVI_LAST;    
            tvchild.hParent = hItem;

            tvchild.itemex.pszText = Col2Items[i];
            SendMessage(hwnd, TVM_INSERTITEM, 0, (LPARAM)&tvchild);

            tvchild.itemex.pszText = Col3Items[i];
            SendMessage(hwnd, TVM_INSERTITEM, 0, (LPARAM)&tvchild);
        }
    }
}
//-------------------------------------------------------------------------//
void Header_Init(HWND hwndPage, int iControlId)
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- initialize the item ----
    HDITEM item;
    memset(&item, 0, sizeof(item));
    item.mask = HDI_WIDTH | HDI_TEXT;
    item.cxy = 60;

    //---- add the items ----
    for (int i=0; i < ARRAYSIZE(Columns); i++)  
    {
        item.pszText = Columns[i];
        HTREEITEM hItem = (HTREEITEM) SendMessage(hwnd, HDM_INSERTITEM, i, (LPARAM)&item);
    }
}

//-------------------------------------------------------------------------//
void Status_Init(HWND hwndPage, int iControlId)
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- setup the different sections ----
    int Widths[] = {200, 400, 600};
    SendMessage(hwnd, SB_SETPARTS, ARRAYSIZE(Widths), (LPARAM)Widths);

    //---- write some text ----
    SendMessage(hwnd, SB_SETTEXT, 0, (LPARAM)L"First Section");
    SendMessage(hwnd, SB_SETTEXT, 1, (LPARAM)L"Second Section");
    SendMessage(hwnd, SB_SETTEXT, 2, (LPARAM)L"Third Section");
}
//-------------------------------------------------------------------------//
void Toolbar_Init(HWND hwndPage, int iControlId, int iMaxButtons)
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- send require toolbar init msg ----
    SendMessage(hwnd, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0); 

    //---- setup the bitmap images for buttons ----
    TBADDBITMAP abm = {HINST_COMMCTRL, IDB_STD_LARGE_COLOR};
    SendMessage(hwnd, TB_ADDBITMAP, 15, (LPARAM)&abm);

    TBBUTTON button;
    memset(&button, 0, sizeof(button));
    button.fsState = TBSTATE_ENABLED; 
    
    //int index = (int)SendMessage(hwnd, TB_ADDSTRING, NULL, (LPARAM)Buttons);

    int cnt = (int)min(iMaxButtons, ARRAYSIZE(Buttons));

    for (int i=0; i < cnt; i++)
    {
        button.fsStyle = TBSTYLE_BUTTON; 
        button.iBitmap = ButtonIndexes[i];
        button.idCommand = i;
        button.iString = 0; // index + i;
        SendMessage(hwnd, TB_ADDBUTTONS, 1, LPARAM(&button));

        if ((i == 2) || (i == 5) || (i == 7) || (i == 9))
        {
            button.fsStyle = BTNS_SEP;
            SendMessage(hwnd, TB_ADDBUTTONS, 1, LPARAM(&button));
        }
    }

    SendMessage(hwnd, TB_AUTOSIZE, 0, 0); 
    ShowWindow(hwnd, SW_SHOW); 
}
//-------------------------------------------------------------------------//
void Rebar_Init(HWND hwndPage, int iControlId)
{
    HWND hwndRB = GetDlgItem(hwndPage, iControlId);
    if (! hwndRB)
        return;
 
   //---- initialize the rebar ----
   REBARINFO rbi;
   rbi.cbSize = sizeof(rbi); 
   rbi.fMask  = 0;
   rbi.himl   = (HIMAGELIST)NULL;
   SendMessage(hwndRB, RB_SETBARINFO, 0, (LPARAM)&rbi);
   
   //---- initialize the band ----
   REBARBANDINFO rbBand;   
   rbBand.cbSize = sizeof(REBARBANDINFO);  
   rbBand.fMask  = RBBIM_TEXT | RBBIM_STYLE | RBBIM_CHILD  | RBBIM_CHILDSIZE | RBBIM_SIZE;
   rbBand.fStyle = RBBS_GRIPPERALWAYS | RBBS_BREAK;
   // rbBand.hbmBack= LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BACKGROUND));   
   
   RECT rc;
   HWND hwndCB, hwndTB;

   // Create the combo box control to be added.
   hwndCB = CreateWindowEx(0, L"Combobox", L"Combo Text", WS_VISIBLE | WS_CHILD | WS_BORDER,
       0, 0, 100, 30, hwndRB, (HMENU)51, g_hInst, 0);
   
   // Set values unique to the band with the combo box.
   GetWindowRect(hwndCB, &rc);
   rbBand.lpText     = L"Combo Box";
   rbBand.hwndChild  = hwndCB;
   rbBand.cxMinChild = 20;
   rbBand.cyMinChild = HEIGHT(rc);
   rbBand.cx         = 120; // WIDTH(rc) + 20;

   // Add the band that has the combo box.
   LRESULT val = SendMessage(hwndRB, RB_INSERTBAND, (WPARAM)-1, (LPARAM)&rbBand);

#if 1
   // Create the toolbar control to be added.
   hwndTB = CreateWindowEx(0, L"SysToolBar32", L"", WS_VISIBLE | WS_CHILD | WS_BORDER,
       0, 0, 500, 30, hwndRB, (HMENU)52, g_hInst, 0);
   Toolbar_Init(hwndRB, 52, 3);

   // Set values unique to the band with the toolbar.
   rbBand.lpText     = L"Tool Bar";
   rbBand.hwndChild  = hwndTB;
   rbBand.cxMinChild = 20;

   DWORD dwBtnSize = (DWORD) SendMessage(hwndTB, TB_GETBUTTONSIZE, 0,0);
   rbBand.cyMinChild = HIWORD(dwBtnSize);
   
   GetWindowRect(hwndTB, &rc);
   rbBand.cx         = 450;     // WIDTH(rc) + 20;

   // Add the band that has the toolbar.
   val = SendMessage(hwndRB, RB_INSERTBAND, (WPARAM)-1, (LPARAM)&rbBand);
#endif
}

//-------------------------------------------------------------------------//
HWND CALLBACK StaticsPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_STATICS),
                         hwndParent,  Shared_DlgProc );
}

//---------------------------------------------------------------------------
HWND CALLBACK ButtonsPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_BUTTONS),
                         hwndParent,  Shared_DlgProc );
}

//-------------------------------------------------------------------------//
HWND CALLBACK EditPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_EDIT),
                         hwndParent,  Shared_DlgProc );
}

//-------------------------------------------------------------------------//
HWND CALLBACK TreeViewPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_TREEVIEW),
                         hwndParent,  TreeView_DlgProc );
}

//-------------------------------------------------------------------------//
HWND CALLBACK ListViewPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_LISTVIEW),
                         hwndParent,  ListView_DlgProc );
}

//-------------------------------------------------------------------------//
HWND CALLBACK PickersPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_PICKERS),
                         hwndParent,  Pickers_DlgProc );
}

//-------------------------------------------------------------------------//
HWND CALLBACK MoversPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_MOVERS),
                         hwndParent,  Movers_DlgProc );
}

//-------------------------------------------------------------------------//
HWND CALLBACK ListsPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_LISTS),
                         hwndParent,  Lists_DlgProc );
}

//---------------------------------------------------------------------------
HWND CALLBACK BarsPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_BARS),
                         hwndParent,  Bars_DlgProc );
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themesel\sample.cpp ===
//---------------------------------------------------------------------------
//  Sample.cpp - dialog for sampling the active theme
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Sample.h"
//---------------------------------------------------------------------------
CSample::CSample()
{
}
//---------------------------------------------------------------------------
LRESULT CSample::OnMsgBox(UINT, UINT, HWND, BOOL&)
{
    MessageBox(L"This is what a Themed MessageBox() window looks like", 
        L"A message!", MB_OK);

    return 1;
}
//---------------------------------------------------------------------------
LRESULT CSample::OnEditTheme(UINT, UINT, HWND, BOOL&)
{
    WCHAR szName[_MAX_PATH+1];
    WCHAR szParams[_MAX_PATH+1];

    *szName = 0;

    HRESULT hr = GetCurrentThemeName(szName, ARRAYSIZE(szName));
    if ((FAILED(hr)) || (! *szName))
    {
        GetDlgItemText(IDC_DIRNAME, szName, ARRAYSIZE(szName));
        if (! *szName)
        {
            MessageBox(L"No theme selected", L"Error", MB_OK);
            return 0;
        }

        StringCchPrintfW(szParams, ARRAYSIZE(szParams), L"%s\\%s", szName, CONTAINER_NAME);
    }
    else
        StringCchPrintfW(szParams, ARRAYSIZE(szParams), L"%s", szName);

    InternalRun(L"notepad.exe", szParams);

    return 1;
}
//---------------------------------------------------------------------------
LRESULT CSample::OnClose(UINT, WPARAM wid, LPARAM, BOOL&)
{
    EndDialog(IDOK);
    return 0;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themesel\sbpage.cpp ===
#include "pch.h"
#include "resource.h"
#include "main.h"

INT_PTR CALLBACK SBPage_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
UINT SBPage_GetScrollBarID();
void SBPage_UpdateControls( HWND hwnd );
void SBPage_UpdateStyle( HWND hwnd, DWORD dw, BOOL bRemove );
BOOL SBPage_OnInitDlg( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
void SBPage_Scroll( HWND hwnd, WPARAM wParam );
void SBPage_AddMessage( HWND hwnd, LPCTSTR pszMsg );
void SBPage_AddScrollMessage( HWND hwnd, LPCTSTR pszMsg, WPARAM wParam, LPARAM lParam );
void SBPage_UpdateStyle( HWND hwnd, DWORD dw, BOOL bRemove );

//-------------------------------------------------------------------------//
//  'ScrollBars' page impl
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
HWND CALLBACK SBPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_SCROLLBARS),
                         hwndParent,  SBPage_DlgProc );
}

//-------------------------------------------------------------------------//
static BOOL       s_fVert = TRUE;
static BOOL       s_fPort = TRUE;
static SCROLLINFO s_siVert = {0};
static SCROLLINFO s_siHorz = {0};
static SCROLLINFO s_siVertP = {0};
static SCROLLINFO s_siHorzP = {0};

//-------------------------------------------------------------------------//
INT_PTR CALLBACK SBPage_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
        case WM_CREATE:
            Log(LOG_TM, L"WM_CREATE\n");
            break;

		case WM_INITDIALOG:
            return SBPage_OnInitDlg( hwnd, uMsg, wParam, lParam );

		case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDC_VERTICAL:
                    s_fVert = TRUE;
                    SBPage_UpdateControls( hwnd );
                    break;
                
                case IDC_HORIZONTAL:
                    s_fVert = FALSE;
                    SBPage_UpdateControls( hwnd );
                    break;

                case IDC_SBCTL_PORT:
                    s_fPort = TRUE;
                    SBPage_UpdateControls( hwnd );
                    break;

                case IDC_SBCTL_STANDARD:
                    s_fPort = FALSE;
                    SBPage_UpdateControls( hwnd );
                    break;

                default:
                    break;
            }
			break;

        case WM_HSCROLL:
            s_fVert = FALSE;
            SBPage_Scroll( hwnd, wParam );
            SBPage_AddScrollMessage( hwnd, TEXT("WM_HSCROLL"), wParam, lParam );
            SBPage_UpdateControls( hwnd );
            break;

        case WM_VSCROLL:
            s_fVert = TRUE;
            SBPage_Scroll( hwnd, wParam );
            SBPage_AddScrollMessage( hwnd, TEXT("WM_VSCROLL"), wParam, lParam );
            SBPage_UpdateControls( hwnd );
            break;

	}
    return FALSE;
}

UINT SBPage_GetScrollBarID()
{
    if( s_fPort )
        return s_fVert ? IDC_SBVERTP : IDC_SBHORZP;
    return s_fVert ? IDC_SBVERT : IDC_SBHORZ;
}

void SBPage_UpdateControls( HWND hwnd )
{
    UINT nPortShow = s_fPort ? SW_SHOW : SW_HIDE;
    UINT nUserShow = s_fPort ? SW_HIDE : SW_SHOW;

    ShowWindow( GetDlgItem( hwnd, IDC_SBHORZ ),  nUserShow );
    ShowWindow( GetDlgItem( hwnd, IDC_SBVERT ),  nUserShow );
    ShowWindow( GetDlgItem( hwnd, IDC_SBHORZP ), nPortShow );
    ShowWindow( GetDlgItem( hwnd, IDC_SBVERTP ), nPortShow );

    HWND  hwndSB  = GetDlgItem( hwnd, SBPage_GetScrollBarID() );
    DWORD dwStyle = GetWindowLong( hwndSB, GWL_STYLE );
    DWORD dwExStyle = GetWindowLong( hwndSB, GWL_EXSTYLE );

    CheckDlgButton( hwnd, IDC_VERTICAL,         s_fVert );
    CheckDlgButton( hwnd, IDC_HORIZONTAL,       !s_fVert );
    CheckDlgButton( hwnd, IDC_SBCTL_PORT,       s_fPort );
    CheckDlgButton( hwnd, IDC_SBCTL_STANDARD,   !s_fPort );

    SCROLLINFO* psi = s_fPort ? (s_fVert ? &s_siVertP : &s_siHorzP) :
                                (s_fVert ? &s_siVert : &s_siHorz);
    psi->fMask = -1;

    if( SendMessage( hwndSB, SBM_GETSCROLLINFO, 0, (LPARAM)psi ) )
    {
        SetDlgItemInt( hwnd, IDC_MIN,      psi->nMin, TRUE );
        SetDlgItemInt( hwnd, IDC_MAX,      psi->nMax, TRUE );
        SetDlgItemInt( hwnd, IDC_PAGE,     psi->nPage, FALSE );
        SetDlgItemInt( hwnd, IDC_POS,      psi->nPos, TRUE );
        SetDlgItemInt( hwnd, IDC_TRACKPOS, psi->nTrackPos, TRUE );
    }
    else
    {
        SetDlgItemText( hwnd, IDC_MIN,      NULL );
        SetDlgItemText( hwnd, IDC_MAX,      NULL );
        SetDlgItemText( hwnd, IDC_PAGE,     NULL );
        SetDlgItemText( hwnd, IDC_POS,      NULL );
        SetDlgItemText( hwnd, IDC_TRACKPOS, NULL );
    }
}

BOOL SBPage_OnInitDlg( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    DWORD dwStyleV   = GetWindowLong( GetDlgItem( hwnd, IDC_SBVERTP ), GWL_STYLE );
    DWORD dwExStyleV = GetWindowLong( GetDlgItem( hwnd, IDC_SBVERTP ), GWL_EXSTYLE );
    DWORD dwStyleH   = GetWindowLong( GetDlgItem( hwnd, IDC_SBHORZP ), GWL_STYLE );
    DWORD dwExStyleH = GetWindowLong( GetDlgItem( hwnd, IDC_SBHORZP ), GWL_EXSTYLE );

    s_fVert = TRUE;
    s_siVert.cbSize = sizeof(s_siVert);
    s_siVert.fMask     = -1;
    s_siVert.nMin      = 0;
    s_siVert.nMax      = 300;
    s_siVert.nPage     = 60;
    s_siVert.nPos      = 0;
    s_siVert.nTrackPos = 0;
    s_siVertP = s_siHorzP = s_siHorz = s_siVert;

    SetScrollInfo( GetDlgItem( hwnd, IDC_SBVERT ), SB_CTL,  &s_siVert, FALSE );
    SetScrollInfo( GetDlgItem( hwnd, IDC_SBHORZ ), SB_CTL,  &s_siHorz, FALSE );
    SetScrollInfo( GetDlgItem( hwnd, IDC_SBVERTP ), SB_CTL, &s_siVertP, FALSE );
    SetScrollInfo( GetDlgItem( hwnd, IDC_SBHORZP ), SB_CTL, &s_siHorzP, FALSE );

    SBPage_UpdateControls( hwnd );

    return TRUE;
}

void SBPage_Scroll( HWND hwnd, WPARAM wParam )
{
    HWND hwndSB = GetDlgItem( hwnd, SBPage_GetScrollBarID() );
    SCROLLINFO* psi = s_fVert ? &s_siVert : &s_siHorz;
    const LONG  nLine = 15;
    UINT        uSBCode = LOWORD(wParam);
    int         nNewPos = HIWORD(wParam);
    
    int nDeltaMax = (s_siVert.nMax - s_siVert.nPage) + 1;
    
    switch( uSBCode )
    {
        case SB_LEFT:
            psi->nPos--;
            break;
        case SB_RIGHT:
            psi->nPos++;
            break;
        case SB_LINELEFT:
            psi->nPos = max( psi->nPos - nLine, 0 );
            break;
        case SB_LINERIGHT:
            psi->nPos = min( psi->nPos + nLine, nDeltaMax );
            break;
        case SB_PAGELEFT:
            psi->nPos = max( psi->nPos - (int)psi->nPage, 0 );
            break;
        case SB_PAGERIGHT:
            psi->nPos = min( psi->nPos + (int)psi->nPage, nDeltaMax );
            break;
        case SB_THUMBTRACK:
            psi->nPos = nNewPos;
            break;
        case SB_THUMBPOSITION:
            psi->nPos = nNewPos;
            break;
        case SB_ENDSCROLL:
            return;
    }
    psi->fMask = SIF_POS;
    SetScrollInfo( hwndSB, SB_CTL, psi, TRUE );
}

void SBPage_AddMessage( HWND hwnd, LPCTSTR pszMsg )
{
    INT_PTR i = SendDlgItemMessage( hwnd, IDC_MSGLIST, LB_ADDSTRING, 0, (LPARAM)pszMsg );
    SendDlgItemMessage( hwnd, IDC_MSGLIST, LB_SETCURSEL, i, 0 );
}

void SBPage_AddScrollMessage( HWND hwnd, LPCTSTR pszMsg, WPARAM wParam, LPARAM lParam )
{
    TCHAR szMsg[MAX_PATH];
    LPCTSTR pszWparam = NULL;
    LPCTSTR pszLparam = NULL;

    switch( LOWORD(wParam) )
    {
        #define ASL_ASSIGN_WPARAM(m)    case m: pszWparam = TEXT(#m); break
        ASL_ASSIGN_WPARAM(SB_ENDSCROLL);
        ASL_ASSIGN_WPARAM(SB_LEFT);
        ASL_ASSIGN_WPARAM(SB_RIGHT);
        ASL_ASSIGN_WPARAM(SB_LINELEFT);
        ASL_ASSIGN_WPARAM(SB_LINERIGHT);
        ASL_ASSIGN_WPARAM(SB_PAGELEFT);
        ASL_ASSIGN_WPARAM(SB_PAGERIGHT);
        ASL_ASSIGN_WPARAM(SB_THUMBPOSITION);
        ASL_ASSIGN_WPARAM(SB_THUMBTRACK);
        default:
            pszWparam = TEXT("");
            break;
    }

    StringCchPrintf( szMsg, ARRAYSIZE(szMsg), TEXT("%s [%s]"), pszMsg, pszWparam );
    SBPage_AddMessage( hwnd, szMsg );
}

void SBPage_UpdateStyle( HWND hwnd, DWORD dw, BOOL bRemove )
{
    HWND hwndSB = GetDlgItem( hwnd, SBPage_GetScrollBarID() );
    DWORD dwStyle, dwStyleOld;
    dwStyle = dwStyleOld = GetWindowLong( hwndSB, GWL_STYLE );
    if( bRemove )
        dwStyle &= ~dw;
    else
        dwStyle |= dw;

    if( dwStyle != dwStyleOld )
    {
        SetWindowLong( hwndSB, GWL_STYLE, dwStyle );
        InvalidateRect( hwndSB, NULL, TRUE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themesel\stylespage.cpp ===
#include "pch.h"
#include "resource.h"

//-------------------------------------------------------------------------//
//  'Styles' page impl
//-------------------------------------------------------------------------//
//
//  CreateIntance, DlgProc
HWND    CALLBACK StylesPage_CreateInstance( HWND hwndParent );
INT_PTR CALLBACK StylesPage_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
//
//  Message handlers
LRESULT CALLBACK StylesPage_OnInitDialog( HWND hwndPage, UINT, WPARAM, LPARAM );
void    CALLBACK StylesPage_OnCommand( HWND, UINT uCtlID, UINT uCode, HWND hwndCtl );

//  Utility methods
void StylesPage_AddRemoveStyle( HWND hwnd, BOOL bAdd, DWORD dwStyle );
void StylesPage_AddRemoveExStyle( HWND hwnd, BOOL bAdd, DWORD dwStyle );
void StylesPage_CreateTestWindow( HWND hwndParent );
void StylesPage_CreateTestDialog( HWND hwndParent );
void StylesPage_SetTestStyles( HWND hwndPage );

#define WMU_TESTWINDOWDIED  (WM_USER + 0x301) // arbitrary.

HWND _hwndTest = NULL;
HWND _hwndPage = NULL;


//-------------------------------------------------------------------------//
INT_PTR CALLBACK StylesPage_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L;
    _hwndPage = hwndPage;

    switch( uMsg )
    {
        case WM_INITDIALOG:
            lRet = StylesPage_OnInitDialog( hwndPage, uMsg, wParam, lParam );
            break;

        case WM_COMMAND:
            StylesPage_OnCommand( hwndPage, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );
            break;

        case WM_NCDESTROY:
            _hwndPage = NULL;
            break;

        case WMU_TESTWINDOWDIED:
            StylesPage_OnCommand( hwndPage, 0, 0, NULL );
            break;

        default: 
            bHandled = FALSE;
            break;
    }
    return bHandled;
}

//-------------------------------------------------------------------------//
HWND CALLBACK StylesPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_PAGE_STYLES),
                         hwndParent,  StylesPage_DlgProc );
}

//-------------------------------------------------------------------------//
LRESULT CALLBACK StylesPage_OnInitDialog(
    HWND hwndPage, UINT, WPARAM, LPARAM )
{
    DWORD dwStyle = GetWindowLong( g_hwndMain, GWL_STYLE );
    DWORD dwExStyle = GetWindowLong( g_hwndMain, GWL_EXSTYLE );

    CheckDlgButton( hwndPage, IDC_WS_MINIMIZEBOX, (dwStyle & WS_MINIMIZEBOX) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_MAXIMIZEBOX, (dwStyle & WS_MAXIMIZEBOX) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_CAPTION, (dwStyle & WS_CAPTION) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_BORDER, (dwStyle & WS_BORDER) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_DLGFRAME, (dwStyle & WS_DLGFRAME) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_VSCROLL, (dwStyle & WS_VSCROLL) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_HSCROLL, (dwStyle & WS_HSCROLL) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_SYSMENU, (dwStyle & WS_SYSMENU) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_THICKFRAME, (dwStyle & WS_THICKFRAME) != 0 );


    CheckDlgButton( hwndPage, IDC_WS_EX_DLGMODALFRAME, (dwExStyle & WS_EX_DLGMODALFRAME) );
    CheckDlgButton( hwndPage, IDC_WS_EX_TOOLWINDOW, (dwExStyle & WS_EX_TOOLWINDOW) );
    CheckDlgButton( hwndPage, IDC_WS_EX_WINDOWEDGE, (dwExStyle & WS_EX_WINDOWEDGE) );
    CheckDlgButton( hwndPage, IDC_WS_EX_CLIENTEDGE, (dwExStyle & WS_EX_CLIENTEDGE) );
    CheckDlgButton( hwndPage, IDC_WS_EX_CONTEXTHELP, (dwExStyle & WS_EX_CONTEXTHELP) );
    CheckDlgButton( hwndPage, IDC_WS_EX_RIGHT, (dwExStyle & WS_EX_RIGHT) );
    CheckDlgButton( hwndPage, IDC_WS_EX_LEFT, (dwExStyle & WS_EX_LEFT) );
    CheckDlgButton( hwndPage, IDC_WS_EX_RTLREADING, (dwExStyle & WS_EX_RTLREADING) );
    CheckDlgButton( hwndPage, IDC_WS_EX_LEFTSCROLLBAR, (dwExStyle & WS_EX_LEFTSCROLLBAR) );
    CheckDlgButton( hwndPage, IDC_WS_EX_RIGHTSCROLLBAR, (dwExStyle & WS_EX_RIGHTSCROLLBAR) );
    CheckDlgButton( hwndPage, IDC_WS_EX_STATICEDGE, (dwExStyle & WS_EX_STATICEDGE) );
    CheckDlgButton( hwndPage, IDC_WS_EX_APPWINDOW, (dwExStyle & WS_EX_APPWINDOW) );
#ifdef WS_EX_LAYOUTRTL
    CheckDlgButton( hwndPage, IDC_WS_EX_LAYOUTRTL, (dwExStyle & WS_EX_LAYOUTRTL) );
#endif WS_EX_LAYOUTRTL

    CheckDlgButton( hwndPage, IDC_WS_OVERLAPPED2, TRUE );
    StylesPage_SetTestStyles( hwndPage );

    return TRUE;
}

//-------------------------------------------------------------------------//
void CALLBACK StylesPage_OnCommand( 
    HWND hwndPage, UINT uCtlID, UINT uCode, HWND hwndCtl )
{
    BOOL bChecked = IsDlgButtonChecked( hwndPage, uCtlID );

    switch( uCtlID )
    {
        case IDC_WS_MINIMIZEBOX:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_MINIMIZEBOX );
            break;

        case IDC_WS_MAXIMIZEBOX:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_MAXIMIZEBOX );
            break;

        case IDC_WS_CAPTION:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_CAPTION );
            break;

        case IDC_WS_BORDER:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_BORDER );
            break;

        case IDC_WS_DLGFRAME:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_DLGFRAME );
            break;

        case IDC_WS_VSCROLL:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_VSCROLL );
            break;

        case IDC_WS_HSCROLL:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_HSCROLL );
            break;

        case IDC_WS_SYSMENU:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_SYSMENU );
            break;

        case IDC_WS_THICKFRAME:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_THICKFRAME );
            break;

        case IDC_TEST_WINDOW:
            StylesPage_CreateTestWindow( hwndPage );
            break;

        case IDC_TEST_DIALOG:
            StylesPage_CreateTestDialog( hwndPage );
            break;

        case IDC_CLOSE_TEST_WINDOW:
            if( IsWindow( _hwndTest ) )
            {
                DestroyWindow( _hwndTest );
                _hwndTest = NULL;
            }
            break;

        case IDC_WS_OVERLAPPED2:
        case IDC_WS_POPUP2:
        case IDC_WS_CHILD2:
            StylesPage_SetTestStyles( hwndPage );
            break;
    }

    EnableWindow( GetDlgItem( hwndPage, IDC_TEST_WINDOW ), !IsWindow( _hwndTest ) );
    EnableWindow( GetDlgItem( hwndPage, IDC_TEST_DIALOG ), !IsWindow( _hwndTest ) );
    EnableWindow( GetDlgItem( hwndPage, IDC_CLOSE_TEST_WINDOW ), IsWindow( _hwndTest ) );
}

//  Utility methods
void StylesPage_AddRemoveStyle( HWND hwnd, BOOL bAdd, DWORD dwStyle )
{
    DWORD style = GetWindowLong( hwnd, GWL_STYLE );
    if( bAdd )
        SetWindowLong( hwnd, GWL_STYLE, style | dwStyle );
    else
        SetWindowLong( hwnd, GWL_STYLE, style & ~dwStyle );
    SetWindowPos( hwnd, NULL, 0, 0, 0, 0, 
        SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE|SWP_DRAWFRAME );
}

void StylesPage_AddRemoveExStyle( HWND hwnd, BOOL bAdd, DWORD dwStyle )
{
    DWORD style = GetWindowLong( hwnd, GWL_EXSTYLE );
    if( bAdd )
        SetWindowLong( hwnd, GWL_EXSTYLE, style | dwStyle );
    else
        SetWindowLong( hwnd, GWL_EXSTYLE, style & ~dwStyle );

    SetWindowPos( hwnd, NULL, 0, 0, 0, 0, 
        SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE|SWP_DRAWFRAME );
}

void StylesPage_ClearTestStyles( HWND hwndPage )
{
    CheckDlgButton( hwndPage, IDC_WS_MINIMIZEBOX2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_MAXIMIZEBOX2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_CAPTION2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_BORDER2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_DLGFRAME2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_VSCROLL2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_HSCROLL2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_SYSMENU2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_THICKFRAME2, 0 );
}

void StylesPage_SetTestStyles( HWND hwndPage )
{
    StylesPage_ClearTestStyles( hwndPage );
    if( IsDlgButtonChecked( hwndPage, IDC_WS_OVERLAPPED2 ) )
    {
        CheckDlgButton( hwndPage, IDC_WS_CAPTION2, TRUE );
        CheckDlgButton( hwndPage, IDC_WS_SYSMENU2, TRUE );
        CheckDlgButton( hwndPage, IDC_WS_THICKFRAME2, TRUE );
        CheckDlgButton( hwndPage, IDC_WS_CAPTION2, TRUE );
        CheckDlgButton( hwndPage, IDC_WS_MINIMIZEBOX2, TRUE );
        CheckDlgButton( hwndPage, IDC_WS_MAXIMIZEBOX2, TRUE );
    }
    else if ( IsDlgButtonChecked( hwndPage, IDC_WS_POPUP2 ) )
    {
        CheckDlgButton( hwndPage, IDC_WS_BORDER2, TRUE );
        CheckDlgButton( hwndPage, IDC_WS_SYSMENU2, TRUE );
    }
}


BOOL StylesPage_GetTestStyles( 
    HWND hwndPage, 
    OUT LPDWORD pdwStyle, 
    OUT LPDWORD pdwExStyle )
{
    *pdwStyle = *pdwExStyle = 0;
    #define ASSIGN_TEST_STYLE(uID, dwStyle) if( IsDlgButtonChecked(hwndPage, uID) ) {(*pdwStyle) |= dwStyle;}
    #define ASSIGN_TEST_EXSTYLE(uID, dwStyle) if( IsDlgButtonChecked(hwndPage, uID) ) {(*pdwExStyle) |= dwStyle;}

    ASSIGN_TEST_STYLE( IDC_WS_OVERLAPPED2, WS_OVERLAPPED );
    ASSIGN_TEST_STYLE( IDC_WS_POPUP2, WS_POPUP );
    ASSIGN_TEST_STYLE( IDC_WS_CHILD2,  WS_CHILD );

    ASSIGN_TEST_STYLE( IDC_WS_MINIMIZEBOX2, WS_MINIMIZEBOX );
    ASSIGN_TEST_STYLE( IDC_WS_MAXIMIZEBOX2, WS_MAXIMIZEBOX );
    ASSIGN_TEST_STYLE( IDC_WS_CAPTION2, WS_CAPTION );
    ASSIGN_TEST_STYLE( IDC_WS_BORDER2, WS_BORDER );
    ASSIGN_TEST_STYLE( IDC_WS_DLGFRAME2, WS_DLGFRAME );
    ASSIGN_TEST_STYLE( IDC_WS_VSCROLL2, WS_VSCROLL );
    ASSIGN_TEST_STYLE( IDC_WS_HSCROLL2, WS_HSCROLL );
    ASSIGN_TEST_STYLE( IDC_WS_SYSMENU2, WS_SYSMENU );
    ASSIGN_TEST_STYLE( IDC_WS_THICKFRAME2, WS_THICKFRAME );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_DLGMODALFRAME2, WS_EX_DLGMODALFRAME );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_TOOLWINDOW2, WS_EX_TOOLWINDOW );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_WINDOWEDGE2, WS_EX_WINDOWEDGE );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_CLIENTEDGE2, WS_EX_CLIENTEDGE );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_CONTEXTHELP2, WS_EX_CONTEXTHELP );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_RIGHT2, WS_EX_RIGHT );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_LEFT2, WS_EX_LEFT );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_RTLREADING2, WS_EX_RTLREADING );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_LEFTSCROLLBAR2, WS_EX_LEFTSCROLLBAR );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_RIGHTSCROLLBAR2, WS_EX_RIGHTSCROLLBAR );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_STATICEDGE2, WS_EX_STATICEDGE );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_APPWINDOW2, WS_EX_APPWINDOW );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_OVERLAPPEDWINDOW2, WS_EX_OVERLAPPEDWINDOW );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_PALETTEWINDOW2, WS_EX_PALETTEWINDOW );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_LAYOUTRTL2, WS_EX_LAYOUTRTL );
    return TRUE;
}

LRESULT CALLBACK StylesPage_TestWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch(uMsg)
    {
        case WM_NCDESTROY:
            PostMessage( _hwndPage, WMU_TESTWINDOWDIED, 0, 0 );
            break;
    }
    return DefWindowProc( hwnd, uMsg, wParam, lParam );
}

void StylesPage_CreateTestWindow( HWND hwndParent )
{
    DWORD dwStyle, dwExStyle;

    WNDCLASSEX wc;
    ZeroMemory( &wc, sizeof(wc) );
    wc.cbSize        = sizeof(wc);
    wc.style         = CS_HREDRAW|CS_VREDRAW;
    wc.lpfnWndProc   = StylesPage_TestWndProc;
    wc.hInstance     = g_hInst;
    wc.hIcon         = NULL;
    wc.hCursor       = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName  = 0; //MAKEINTRESOURCE(pszTestMenu)
    wc.lpszClassName = TEXT("ThemeSelTestWindow");
    wc.hIconSm       = NULL;

    RegisterClassEx( &wc );

    StylesPage_GetTestStyles( hwndParent, &dwStyle, &dwExStyle );

    int x = CW_USEDEFAULT, y = CW_USEDEFAULT, cx = CW_USEDEFAULT, cy = CW_USEDEFAULT;
    
    if( dwStyle & WS_CHILD|WS_POPUP )
    {
        x = y = 25;
        cx = cy = 250;
    }

    _hwndTest = CreateWindowEx( dwExStyle, wc.lpszClassName, TEXT("Theme Test Window"), 
                                dwStyle|WS_VISIBLE,
                                x, y, cx, cy, hwndParent, 0, g_hInst, NULL );

    if( IsWindow( _hwndTest ) )
    {
        if( dwStyle & WS_CHILD )
        {
            //SetWindowPos( _hwndTest, HWND_TOP, 0, 0, 0, 0,
            //              SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE );
            //InvalidateRect( _hwndTest, NULL, TRUE );
        }
    }
}

void StylesPage_CreateTestDialog( HWND hwndParent )
{
    StylesPage_CreateTestWindow( hwndParent );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\advappearpg.cpp ===
/*****************************************************************************\
    FILE: AdvAppearPg.cpp

    DESCRIPTION:
        This code will display a "Advanced Appearances" tab in the
    "Advanced Display Properties" dialog.

    ??????? ?/??/1993    Created
    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "PreviewSM.h"
#include "AdvAppearPg.h"
#include "BaseAppearPg.h"
#include "regutil.h"
#include "CoverWnd.h"
#include "fontfix.h"





// The following are the indices into the above array.
#define COLORFLAG_SOLID         0x0001
#define COLOR_MAX_400           (COLOR_INFOBK + 1)
#define CURRENT_ELEMENT_NONE    -2          // This means that no element is selected.





// used by ChooseColor dialog
COLORREF g_CustomColors[16];    // This is the user customized palette.  We could put this into the class.

CAdvAppearancePage * g_pAdvAppearancePage = NULL;


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//this order has to match the enum order in look.h
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
LOOK_ELEMENT g_elements[] = {
/* ELEMENT_APPSPACE        */   {COLOR_APPWORKSPACE,    SIZE_NONE,      FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_APPSPACE, -1,       COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_DESKTOP         */   {COLOR_BACKGROUND,      SIZE_NONE,      FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_DESKTOP, -1,        COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_INACTIVEBORDER  */   {COLOR_INACTIVEBORDER,  SIZE_FRAME,     FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_INACTIVEBORDER, -1, COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ACTIVEBORDER    */   {COLOR_ACTIVEBORDER,    SIZE_FRAME,     FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_ACTIVEBORDER, -1,   COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_INACTIVECAPTION */   {COLOR_INACTIVECAPTION, SIZE_CAPTION,   TRUE,    COLOR_INACTIVECAPTIONTEXT,FONT_CAPTION,ELNAME_INACTIVECAPTION, -1,COLOR_GRADIENTINACTIVECAPTION, {-1,-1,-1,-1}},
/* ELEMENT_INACTIVESYSBUT1 */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_ACTIVESYSBUT1, COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_INACTIVESYSBUT2 */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_ACTIVESYSBUT1, COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ACTIVECAPTION   */   {COLOR_ACTIVECAPTION,   SIZE_CAPTION,   TRUE,    COLOR_CAPTIONTEXT,      FONT_CAPTION,  ELNAME_ACTIVECAPTION, -1,  COLOR_GRADIENTACTIVECAPTION, {-1,-1,-1,-1}},
/* ELEMENT_ACTIVESYSBUT1   */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_CAPTIONBUTTON, -1,  COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ACTIVESYSBUT2   */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_ACTIVESYSBUT1, COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_MENUNORMAL      */   {COLOR_MENU,            SIZE_MENU,      TRUE,    COLOR_MENUTEXT,         FONT_MENU,     ELNAME_MENU, -1,           COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_MENUSELECTED    */   {COLOR_HIGHLIGHT,       SIZE_MENU,      TRUE,    COLOR_HIGHLIGHTTEXT,    FONT_MENU,     ELNAME_MENUSELECTED, -1,   COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_MENUDISABLED    */   {COLOR_MENU,            SIZE_MENU,      TRUE,    COLOR_NONE,             FONT_MENU,     -1, ELEMENT_MENUNORMAL,    COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_WINDOW          */   {COLOR_WINDOW,          SIZE_NONE,      FALSE,   COLOR_WINDOWTEXT,       FONT_NONE,     ELNAME_WINDOW, -1,         COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_MSGBOX          */   {COLOR_NONE,            SIZE_NONE,      TRUE,    COLOR_WINDOWTEXT,       FONT_MSGBOX,   ELNAME_MSGBOX, -1,         COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_MSGBOXCAPTION   */   {COLOR_ACTIVECAPTION,   SIZE_CAPTION,   TRUE,    COLOR_CAPTIONTEXT,      FONT_CAPTION,  -1, ELEMENT_ACTIVECAPTION, COLOR_GRADIENTACTIVECAPTION, {-1,-1,-1,-1}},
/* ELEMENT_MSGBOXSYSBUT    */   {COLOR_3DFACE,          SIZE_CAPTION,   TRUE,    COLOR_BTNTEXT,          FONT_CAPTION,  -1, ELEMENT_ACTIVESYSBUT1, COLOR_NONE, {-1,-1,-1,-1}},
// do not even try to set a scrollbar color the system will ignore you
/* ELEMENT_SCROLLBAR       */   {COLOR_NONE,            SIZE_SCROLL,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_SCROLLBAR, -1,      COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_SCROLLUP        */   {COLOR_NONE,            SIZE_SCROLL,    FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_SCROLLBAR,     COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_SCROLLDOWN      */   {COLOR_NONE,            SIZE_SCROLL,    FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_SCROLLBAR,     COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_BUTTON          */   {COLOR_3DFACE,          SIZE_NONE,      FALSE,   COLOR_BTNTEXT,          FONT_NONE,     ELNAME_BUTTON, -1,         COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_SMCAPTION       */   {COLOR_NONE,            SIZE_SMCAPTION, TRUE,    COLOR_NONE,             FONT_SMCAPTION,ELNAME_SMALLCAPTION, -1,   COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ICON            */   {COLOR_NONE,            SIZE_ICON,      FALSE,   COLOR_NONE,             FONT_ICONTITLE,ELNAME_ICON, -1,           COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ICONHORZSPACING */   {COLOR_NONE,            SIZE_DXICON,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_DXICON, -1,         COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ICONVERTSPACING */   {COLOR_NONE,            SIZE_DYICON,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_DYICON, -1,         COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_INFO            */   {COLOR_INFOBK,          SIZE_NONE,      TRUE,    COLOR_INFOTEXT,         FONT_STATUS,   ELNAME_INFO, -1,           COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_HOTTRACKAREA    */   {COLOR_HOTLIGHT,        SIZE_NONE,      FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_HOTTRACKAREA, -1,   COLOR_NONE, {-1,-1,-1,-1}}
};
#if 0
// go fix look.h if you decide to add this back in
/* ELEMENT_SMICON          */   {COLOR_NONE,            SIZE_SMICON,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_SMICON, -1,         COLOR_NONE, {-1,-1,-1,-1}},
#endif

#define ELCUR           (g_elements[m_iCurElement])
#define ELCURFONT       (m_fonts[ELCUR.iFont])



void LoadCustomColors(void);
BOOL Font_GetNameFromList(HWND hwndList, INT iItem, LPTSTR pszFace, INT cchFaceMax, LPTSTR pszScript, INT cchScriptMax);
void Font_AddSize(HWND hwndPoints, int iNewPoint, BOOL bSort);
int CALLBACK Font_EnumSizes(LPENUMLOGFONT lpelf, LPNEWTEXTMETRIC lpntm, int Type, LPARAM lData);


//============================================================================================================
// *** Globals ***
//============================================================================================================
const static DWORD aAdvAppearanceHelpIds[] = {
    IDC_ADVAP_LOOKPREV,             IDH_DISPLAY_APPEARANCE_GRAPHIC,
    IDC_ADVAP_ELEMENTSLABEL,        IDH_DISPLAY_APPEARANCE_ITEM_LIST,
    IDC_ADVAP_ELEMENTS,             IDH_DISPLAY_APPEARANCE_ITEM_LIST,
    IDC_ADVAP_MAINSIZE,             IDH_DISPLAY_APPEARANCE_ITEM_SIZE,
    IDC_ADVAP_SIZELABEL,            IDH_DISPLAY_APPEARANCE_ITEM_SIZE,
    IDC_ADVAP_SIZEARROWS,           IDH_DISPLAY_APPEARANCE_ITEM_SIZE,
    IDC_ADVAP_COLORLABEL,           IDH_DISPLAY_APPEARANCE_ITEM_COLOR,
    IDC_ADVAP_MAINCOLOR,            IDH_DISPLAY_APPEARANCE_ITEM_COLOR,
    IDC_ADVAP_GRADIENTLABEL,        IDH_DISPLAY_APPEARANCE_ITEM_COLOR2,
    IDC_ADVAP_GRADIENT,             IDH_DISPLAY_APPEARANCE_ITEM_COLOR2,
    IDC_ADVAP_FONTLABEL,            IDH_DISPLAY_APPEARANCE_FONT_LIST,
    IDC_ADVAP_FONTNAME,             IDH_DISPLAY_APPEARANCE_FONT_LIST,
    IDC_ADVAP_FONTSIZELABEL,        IDH_DISPLAY_APPEARANCE_FONT_SIZE,
    IDC_ADVAP_FONTSIZE,             IDH_DISPLAY_APPEARANCE_FONT_SIZE,
    IDC_ADVAP_FNCOLORLABEL,         IDH_DISPLAY_APPEARANCE_FONT_COLOR,
    IDC_ADVAP_TEXTCOLOR,            IDH_DISPLAY_APPEARANCE_FONT_COLOR,
    IDC_ADVAP_FONTBOLD,             IDH_DISPLAY_APPEARANCE_FONT_BOLD,
    IDC_ADVAP_FONTITAL,             IDH_DISPLAY_APPEARANCE_FONT_ITALIC,
    0, 0
};

#define SZ_HELPFILE_ADVAPPEARANCE           TEXT("display.hlp")


//===========================
// *** Class Internals & Helpers ***
//===========================
// a new font name was chosen.  build a new point size list.
void CAdvAppearancePage::_SelectName(HWND hDlg, int iSel)
{
    INT dwItemData;
    HWND hwndFontSize = GetDlgItem(hDlg, IDC_ADVAP_FONTSIZE);
    HDC hdc;

    // build the approriate point size list
    SendMessage(hwndFontSize, CB_RESETCONTENT, 0, 0L);
    dwItemData = LOWORD(SendDlgItemMessage(hDlg, IDC_ADVAP_FONTNAME, CB_GETITEMDATA, (WPARAM)iSel, 0L));
    if (LOWORD(dwItemData) == TRUETYPE_FONTTYPE)
    {
        INT i;
        for (i = 6; i <= 24; i++)
            Font_AddSize(hwndFontSize, i, FALSE);
    }
    else
    {
        LOGFONT lf;

        Font_GetNameFromList(GetDlgItem(hDlg, IDC_ADVAP_FONTNAME),
                             iSel,
                             lf.lfFaceName,
                             ARRAYSIZE(lf.lfFaceName),
                             NULL,
                             0);
        hdc = GetDC(NULL);
        lf.lfCharSet = (BYTE)(HIWORD(dwItemData));
        lf.lfPitchAndFamily = 0;

        EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)Font_EnumSizes, (LPARAM)this, 0);
        ReleaseDC(NULL, hdc);
    }
}


// new font was chosen.  select the proper point size
// return: actual point size chosen
int Font_SelectSize(HWND hDlg, int iCurPoint)
{
    int i, iPoint = 0;
    HWND hwndFontSize = GetDlgItem(hDlg, IDC_ADVAP_FONTSIZE);

    i = (int)SendMessage(hwndFontSize, CB_GETCOUNT, 0, 0L);

    // the loop stops with i=0, so we get some selection for sure
    for (i--; i > 0; i--)
    {
        iPoint = LOWORD(SendMessage(hwndFontSize, CB_GETITEMDATA, (WPARAM)i, 0L));
        // walking backwards through list, find equal or next smallest
        if (iCurPoint >= iPoint)
            break;
    }
    SendMessage(hwndFontSize, CB_SETCURSEL, (WPARAM)i, 0L);

    return iPoint;
}


int CAdvAppearancePage::_HeightToPoint(int nHeight)
{
    if (nHeight < 0)
    {
        nHeight = -nHeight;
    }

    return MulDiv(nHeight, 72, m_nCachedNewDPI);
}


int CAdvAppearancePage::_PointToHeight(int nPoints)
{
    if (nPoints > 0)
    {
        nPoints = -nPoints;
    }

    // Heights must always be negative.  NTUSER is full of bugs when
    // the values are positive.
    return MulDiv(nPoints, m_nCachedNewDPI, 72);
}


/*
** initialize the constant dialog components
**
** initialize the list of element names.  this stays constant with the
** possible exception that some items might be added/removed depending
** on some special case conditions.
*/
void Look_InitDialog(HWND hDlg)
{
    int iEl, iName;
    TCHAR szName[CCH_MAX_STRING];
    HWND hwndElements;
    LOGFONT lf;
    HFONT hfont;
    int oldWeight;

    LoadCustomColors();

    hwndElements = GetDlgItem(hDlg, IDC_ADVAP_ELEMENTS);
    for (iEl = 0; iEl < ARRAYSIZE(g_elements); iEl++)
    {
        if ((g_elements[iEl].iResId != -1) &&
                LoadString(HINST_THISDLL, g_elements[iEl].iResId, szName, ARRAYSIZE(szName)))
        {
            iName = (int)SendMessage(hwndElements, CB_FINDSTRINGEXACT, 0, (LPARAM)szName);

            if (iName == CB_ERR)
                iName = (int)SendMessage(hwndElements, CB_ADDSTRING, 0, (LPARAM)szName);

            // reference back to item in array
            if (iName != CB_ERR)
                SendMessage(hwndElements, CB_SETITEMDATA, (WPARAM)iName, (LPARAM)iEl);
        }
    }

    // make bold button have bold text
    hfont = (HFONT)SendDlgItemMessage(hDlg, IDC_ADVAP_FONTBOLD, WM_GETFONT, 0, 0L);
    GetObject(hfont, sizeof(lf), &lf);
    oldWeight = lf.lfWeight;
    lf.lfWeight = FW_BOLD;
    hfont = CreateFontIndirect(&lf);
    if (hfont)
        SendDlgItemMessage(hDlg, IDC_ADVAP_FONTBOLD, WM_SETFONT, (WPARAM)hfont, 0L);

    // make italic button have italic text
    lf.lfWeight = oldWeight;
    lf.lfItalic = TRUE;
    hfont = CreateFontIndirect(&lf);
    if (hfont)
    {
        SendDlgItemMessage(hDlg, IDC_ADVAP_FONTITAL, WM_SETFONT, (WPARAM)hfont, 0L);
    }
}


HRESULT CAdvAppearancePage::_OnFontNameChanged(HWND hDlg)
{
    HRESULT hr = E_NOTIMPL;
    TCHAR szBuf[MAX_PATH];

    int nIndex = (int)SendDlgItemMessage(hDlg, IDC_ADVAP_FONTNAME, CB_GETCURSEL,0,0L);
    DWORD dwItemData = (DWORD)SendDlgItemMessage(hDlg, IDC_ADVAP_FONTNAME, CB_GETITEMDATA, (WPARAM)nIndex, 0);

    _SelectName(hDlg, nIndex);
    Font_SelectSize(hDlg, _HeightToPoint(ELCURFONT.lf.lfHeight));
    Font_GetNameFromList(GetDlgItem(hDlg, IDC_ADVAP_FONTNAME), nIndex, szBuf, ARRAYSIZE(szBuf), NULL, 0);

    // Change font to currently selected name and charset.
    _ChangeFontName(hDlg, szBuf, HIWORD(dwItemData));

    return hr;
}


HRESULT CAdvAppearancePage::_OnSizeChange(HWND hDlg, WORD wEvent)
{
    HRESULT hr = E_NOTIMPL;
    int nIndex;

    if ((wEvent == EN_CHANGE) && (m_iCurElement >= 0) && (ELCUR.iSize >= 0))
    {
        nIndex = (int)LOWORD(SendDlgItemMessage(hDlg, IDC_ADVAP_SIZEARROWS, UDM_GETPOS,0,0L));
        _ChangeSize(hDlg, nIndex, TRUE);
    }
    else if (wEvent == EN_KILLFOCUS)
    {
        nIndex = (int)SendDlgItemMessage(hDlg, IDC_ADVAP_SIZEARROWS, UDM_GETPOS,0,0L);
        if (HIWORD(nIndex) != 0)
        {
            SetDlgItemInt(hDlg, IDC_ADVAP_MAINSIZE, (UINT)LOWORD(nIndex), FALSE);
        }
    }

    return hr;
}


HRESULT CAdvAppearancePage::_OnInitAdvAppearanceDlg(HWND hDlg)
{
    m_fInUserEditMode = FALSE;

    // initialize some globals
    _hwnd = hDlg;

    m_cyBorderSM = ClassicGetSystemMetrics(SM_CYBORDER);
    m_cxBorderSM = ClassicGetSystemMetrics(SM_CXBORDER);
    m_cxEdgeSM = ClassicGetSystemMetrics(SM_CXEDGE);
    m_cyEdgeSM = ClassicGetSystemMetrics(SM_CYEDGE);

    Look_InitDialog(hDlg);
    _InitSysStuff();
    _InitFontList(hDlg);

    // paint the preview
    _Repaint(hDlg, TRUE);
    _SelectElement(hDlg, ELEMENT_DESKTOP, LSE_SETCUR);

    m_fInUserEditMode = TRUE;

    // theme ownerdrawn color picker button
    m_hTheme = OpenThemeData(GetDlgItem(hDlg, IDC_ADVAP_MAINCOLOR), WC_BUTTON);
    return S_OK;
}


HRESULT CAdvAppearancePage::_LoadState(IN const SYSTEMMETRICSALL * pState)
{
    HRESULT hr = E_INVALIDARG;

    if (pState)
    {
        _SetMyNonClientMetrics((const LPNONCLIENTMETRICS)&(pState->schemeData.ncm));
        m_dwChanged = pState->dwChanged;

        // Set Sizes
        m_sizes[SIZE_DXICON].CurSize = pState->nDXIcon;
        m_sizes[SIZE_DYICON].CurSize = pState->nDYIcon;
        m_sizes[SIZE_ICON].CurSize = pState->nIcon;
        m_sizes[SIZE_SMICON].CurSize = pState->nSmallIcon;
        
        // Set Fonts
        m_fonts[FONT_ICONTITLE].lf = pState->schemeData.lfIconTitle;
        m_fModifiedScheme = pState->fModifiedScheme;

        for (int nIndex = 0; nIndex < ARRAYSIZE(m_rgb); nIndex++)
        {
            m_rgb[nIndex] = pState->schemeData.rgb[nIndex];
        }

        hr = S_OK;
    }

    return hr;
}


HRESULT CAdvAppearancePage::_OnDestroy(HWND hDlg)
{
    _DestroySysStuff();
    HFONT hfont, hfontOther;

    hfontOther = (HFONT)SendDlgItemMessage(hDlg, IDC_ADVAP_MAINSIZE, WM_GETFONT, 0, 0L);
    hfont = (HFONT)SendDlgItemMessage(hDlg, IDC_ADVAP_FONTBOLD, WM_GETFONT, 0, 0L);
    if (hfont && (hfont != hfontOther))
    {
        DeleteObject(hfont);
    }

    hfont = (HFONT)SendDlgItemMessage(hDlg, IDC_ADVAP_FONTITAL, WM_GETFONT, 0, 0L);
    if (hfont && (hfont != hfontOther))
    {
        DeleteObject(hfont);
    }

    if (m_hTheme)
    {
        CloseThemeData(m_hTheme);
        m_hTheme = NULL;
    }

    _hwnd = NULL;

    return S_OK;
}


INT_PTR CAdvAppearancePage::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);
    WORD wEvent = GET_WM_COMMAND_CMD(wParam, lParam);
    int nIndex;
    TCHAR szBuf[100];

    switch (idCtrl)
    {
    case IDOK:
        EndDialog(hDlg, IDOK);
        break;

    case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;

    case IDC_ADVAP_ELEMENTS:
        if(wEvent == CBN_SELCHANGE)
        {
            nIndex = (int)SendDlgItemMessage(hDlg, IDC_ADVAP_ELEMENTS, CB_GETCURSEL,0,0L);
            nIndex = LOWORD(SendDlgItemMessage(hDlg, IDC_ADVAP_ELEMENTS, CB_GETITEMDATA, (WPARAM)nIndex, 0L));
            _SelectElement(hDlg, nIndex, LSE_NONE);
        }

        break;
    case IDC_ADVAP_FONTNAME:
        if(wEvent == CBN_SELCHANGE)
        {
            _OnFontNameChanged(hDlg);
        }
        break;


    case IDC_ADVAP_FONTSIZE:
        switch (wEvent)
        {
            case CBN_SELCHANGE:
                nIndex = (int)SendDlgItemMessage(hDlg, IDC_ADVAP_FONTSIZE, CB_GETCURSEL,0,0L);
                nIndex = LOWORD(SendDlgItemMessage(hDlg, IDC_ADVAP_FONTSIZE, CB_GETITEMDATA, (WPARAM)nIndex, 0L));
                _ChangeFontSize(hDlg, nIndex);
                break;

            case CBN_EDITCHANGE:
                GetWindowText(GetDlgItem(hDlg, IDC_ADVAP_FONTSIZE), szBuf, ARRAYSIZE(szBuf));
                _ChangeFontSize(hDlg, StrToInt(szBuf));
                break;
        }
        break;

    case IDC_ADVAP_FONTBOLD:
    case IDC_ADVAP_FONTITAL:
        if (wEvent == BN_CLICKED)
        {
            BOOL fCheck = !IsDlgButtonChecked(hDlg, LOWORD(wParam));
            CheckDlgButton(hDlg, LOWORD(wParam), fCheck);
            _ChangeFontBI(hDlg, LOWORD(wParam), fCheck);
        }
        break;

    case IDC_ADVAP_MAINSIZE:
        _OnSizeChange(hDlg, wEvent);
        break;

    case IDC_ADVAP_GRADIENT:
    case IDC_ADVAP_MAINCOLOR:
    case IDC_ADVAP_TEXTCOLOR:
        if (wEvent == BN_CLICKED)
            _PickAColor(hDlg, idCtrl);
        break;

    default:
        break;
    }

    return fHandled;
}


INT_PTR CALLBACK CAdvAppearancePage::AdvAppearDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CAdvAppearancePage * pThis = (CAdvAppearancePage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CAdvAppearancePage *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
        return pThis->_AdvAppearDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


// This Property Sheet appear in the top level of the "Display Control Panel".
INT_PTR CAdvAppearancePage::_AdvAppearDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_NOTIFY:
        break;

    case WM_INITDIALOG:
        _OnInitAdvAppearanceDlg(hDlg);
        break;

    case WM_DESTROY:
        _OnDestroy(hDlg);
        break;

    case WM_DRAWITEM:
        switch (wParam)
        {
            case IDC_ADVAP_GRADIENT:
            case IDC_ADVAP_MAINCOLOR:
            case IDC_ADVAP_TEXTCOLOR:
                _DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam);
                return TRUE;
        }
        break;

    case WM_SETTINGCHANGE:
    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
        _PropagateMessage(hDlg, message, wParam, lParam);
        break;

    case WM_QUERYNEWPALETTE:
    case WM_PALETTECHANGED:
        SendDlgItemMessage(hDlg, IDC_ADVAP_LOOKPREV, message, wParam, lParam);
        return TRUE;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_ADVAPPEARANCE, HELP_WM_HELP, (DWORD_PTR)  aAdvAppearanceHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, SZ_HELPFILE_ADVAPPEARANCE, HELP_CONTEXTMENU, (DWORD_PTR)  aAdvAppearanceHelpIds);
        break;

    case WM_COMMAND:
        _OnCommand(hDlg, message, wParam, lParam);
        break;

    case WM_THEMECHANGED:
        if (m_hTheme)
        {
            CloseThemeData(m_hTheme);
        }

        m_hTheme = OpenThemeData(GetDlgItem(hDlg, IDC_ADVAP_MAINCOLOR), WC_BUTTON);
        break;
    }

    return FALSE;
}


const UINT g_colorFlags[COLOR_MAX] = {
/* COLOR_SCROLLBAR           */ 0,
/* COLOR_DESKTOP             */ 0,
/* COLOR_ACTIVECAPTION       */ COLORFLAG_SOLID,
/* COLOR_INACTIVECAPTION     */ COLORFLAG_SOLID,
/* COLOR_MENU                */ COLORFLAG_SOLID,
/* COLOR_WINDOW              */ COLORFLAG_SOLID,
/* COLOR_WINDOWFRAME         */ COLORFLAG_SOLID,
/* COLOR_MENUTEXT            */ COLORFLAG_SOLID,
/* COLOR_WINDOWTEXT          */ COLORFLAG_SOLID,
/* COLOR_CAPTIONTEXT         */ COLORFLAG_SOLID,
/* COLOR_ACTIVEBORDER        */ 0,
/* COLOR_INACTIVEBORDER      */ 0,
/* COLOR_APPWORKSPACE        */ 0,
/* COLOR_HIGHLIGHT           */ COLORFLAG_SOLID,
/* COLOR_HIGHLIGHTTEXT       */ COLORFLAG_SOLID,
/* COLOR_3DFACE              */ COLORFLAG_SOLID,
/* COLOR_3DSHADOW            */ COLORFLAG_SOLID,
/* COLOR_GRAYTEXT            */ COLORFLAG_SOLID,
/* COLOR_BTNTEXT             */ COLORFLAG_SOLID,
/* COLOR_INACTIVECAPTIONTEXT */ COLORFLAG_SOLID,
/* COLOR_3DHILIGHT           */ COLORFLAG_SOLID,
/* COLOR_3DDKSHADOW          */ COLORFLAG_SOLID,
/* COLOR_3DLIGHT             */ COLORFLAG_SOLID,
/* COLOR_INFOTEXT            */ COLORFLAG_SOLID,
/* COLOR_INFOBK              */ 0,
/* COLOR_3DALTFACE           */ 0,
/* COLOR_HOTLIGHT            */ COLORFLAG_SOLID,
/* COLOR_GRADIENTACTIVECAPTION   */ COLORFLAG_SOLID,
/* COLOR_GRADIENTINACTIVECAPTION */ COLORFLAG_SOLID,
/* COLOR_MENUHILIGHT         */ 0,
/* COLOR_MENUBAR             */ 0
};


#define RGB_PALETTE 0x02000000

//  make the color a solid color if it needs to be.
//  on a palette device make is a palette relative color, if we need to.
COLORREF CAdvAppearancePage::_NearestColor(int iColor, COLORREF rgb)
{
    rgb &= 0x00FFFFFF;

    // if we are on a palette device, we need to do special stuff...
    if (m_bPalette)
    {
        if (g_colorFlags[iColor] & COLORFLAG_SOLID)
        {
            if (IsPaletteColor(m_hpal3D, rgb))
                rgb |= RGB_PALETTE;
            else
                rgb = GetNearestPaletteColor(m_hpalVGA, rgb);
        }
        else
        {
            if (IsPaletteColor(m_hpal3D, rgb))
                rgb |= RGB_PALETTE;

            else if (IsPaletteColor((HPALETTE)GetStockObject(DEFAULT_PALETTE), rgb))
                rgb ^= 0x000001;    // force a dither
        }
    }
    else
    {
        // map color to nearest color if we need to for this UI element.
        if (g_colorFlags[iColor] & COLORFLAG_SOLID)
        {
            HDC hdc = GetDC(NULL);
            rgb = GetNearestColor(hdc, rgb);
            ReleaseDC(NULL, hdc);
        }
    }

    return rgb;
}


void CAdvAppearancePage::_PickAColor(HWND hDlg, int CtlID)
{
    COLORPICK_INFO cpi;
    int iColor;

    switch (CtlID)
    {
        case IDC_ADVAP_GRADIENT:
            iColor = ELCUR.iGradientColor;
            break;

        case IDC_ADVAP_MAINCOLOR:
            iColor = ELCUR.iMainColor;
            break;

        case IDC_ADVAP_TEXTCOLOR:
            iColor = ELCUR.iTextColor;
            break;

        default:
            return;

    }

    cpi.hwndParent = GetDlgItem(hDlg, CtlID);       
    cpi.hwndOwner = GetDlgItem(hDlg, CtlID);        // Color button
    cpi.hpal = m_hpal3D;
    cpi.rgb = m_rgb[iColor];
    cpi.flags = CC_RGBINIT | CC_FULLOPEN;

    if ((iColor == COLOR_3DFACE) && m_bPalette)
    {
        cpi.flags |= CC_ANYCOLOR;
    }
    else if (g_colorFlags[iColor] & COLORFLAG_SOLID)
    {
        cpi.flags |= CC_SOLIDCOLOR;
    }

    if (ChooseColorMini(&cpi) && _ChangeColor(hDlg, iColor, cpi.rgb))
    {
        _SetColor(hDlg, CtlID, m_brushes[iColor]);
        _Repaint(hDlg, FALSE);
    }
}


// ------------------------ magic color utilities --------------------------
/*
** set a color in the 3D palette.
*/
void CAdvAppearancePage::_Set3DPaletteColor(COLORREF rgb, int iColor)
{
    int iPalette;
    PALETTEENTRY pe;

    if (!m_hpal3D)
        return;

    switch (iColor)
    {
        case COLOR_3DFACE:
            iPalette = 16;
            break;
        case COLOR_3DSHADOW:
            iPalette = 17;
            break;
        case COLOR_3DHILIGHT:
            iPalette = 18;
            break;
        default:
            return;
    }

    pe.peRed    = GetRValue(rgb);
    pe.peGreen  = GetGValue(rgb);
    pe.peBlue   = GetBValue(rgb);
    pe.peFlags  = 0;
    SetPaletteEntries(m_hpal3D, iPalette, 1, (LPPALETTEENTRY)&pe);
}
// ------------end--------- magic color utilities --------------------------


void CAdvAppearancePage::_InitUniqueCharsetArray(void)
{
    UINT    uiCharsets[MAX_CHARSETS];

    Font_GetCurrentCharsets(uiCharsets, ARRAYSIZE(uiCharsets));
    // Find the unique Charsets and save that in a global array.
    Font_GetUniqueCharsets(uiCharsets, m_uiUniqueCharsets, MAX_CHARSETS, &m_iCountCharsets);    
}


HRESULT CAdvAppearancePage::_InitFonts(void)
{
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_fonts); nIndex++)
    {
        if (m_fonts[nIndex].hfont)
        {
            DeleteObject(m_fonts[nIndex].hfont);
            m_fonts[nIndex].hfont = NULL;
        }
        m_fonts[nIndex].hfont = CreateFontIndirect(&m_fonts[nIndex].lf);
    }

    return S_OK;
}


HRESULT CAdvAppearancePage::_FreeFonts(void)
{
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_fonts); nIndex++)
    {
        if (m_fonts[nIndex].hfont)
        {
            DeleteObject(m_fonts[nIndex].hfont);
            m_fonts[nIndex].hfont = NULL;
        }
    }

    return S_OK;
}


// new data has been set.  flush out current objects and rebuild
void CAdvAppearancePage::_RebuildSysStuff(BOOL fInit)
{
    int i;

    SelectObject(g_hdcMem, GetStockObject(BLACK_BRUSH));
    SelectObject(g_hdcMem, GetStockObject(SYSTEM_FONT));

    _InitFonts();
    if (fInit)
    {
        HPALETTE hpal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);

        if (hpal)
        {
            PALETTEENTRY pal[4];

            // get current magic colors
            pal[0].peFlags = 0;
            pal[1].peFlags = 0;
            pal[2].peFlags = 0;
            pal[3].peFlags = 0;
            if (GetPaletteEntries(hpal, 8,  4, pal))
            {
                SetPaletteEntries(m_hpal3D, 16,  4, pal);

                // set up magic colors in the 3d palette
                if (!IsPaletteColor(hpal, m_rgb[COLOR_3DFACE]))
                    _Set3DPaletteColor(m_rgb[COLOR_3DFACE], COLOR_3DFACE);

                if (!IsPaletteColor(hpal, m_rgb[COLOR_3DSHADOW]))
                    _Set3DPaletteColor(m_rgb[COLOR_3DSHADOW],  COLOR_3DSHADOW);

                if (!IsPaletteColor(hpal, m_rgb[COLOR_3DHILIGHT]))
                    _Set3DPaletteColor(m_rgb[COLOR_3DHILIGHT], COLOR_3DHILIGHT);
            }
        }
    }

    for (i = 0; i < COLOR_MAX; i++)
    {
        if (m_brushes[i])
            DeleteObject(m_brushes[i]);

        m_brushes[i] = CreateSolidBrush(_NearestColor(i, m_rgb[i]));
    }

    if (m_iCurElement >= 0)
    {
        // we changed the brushes out from under the buttons...
        _SetColor(NULL, IDC_ADVAP_MAINCOLOR, ((ELCUR.iMainColor != COLOR_NONE) ? m_brushes[ELCUR.iMainColor] : NULL));
        _SetColor(NULL, IDC_ADVAP_GRADIENT, ((ELCUR.iGradientColor != COLOR_NONE) ? m_brushes[ELCUR.iGradientColor] : NULL));
        _SetColor(NULL, IDC_ADVAP_TEXTCOLOR, ((ELCUR.iTextColor != COLOR_NONE) ? m_brushes[ELCUR.iTextColor] : NULL));
    }
}


HRESULT CAdvAppearancePage::_InitColorAndPalette(void)
{
    m_bPalette = FALSE;
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        m_bPalette = GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE;
        ReleaseDC(NULL, hdc);
    }

    DWORD pal[21];
    HPALETTE hpal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);

    pal[1]  = RGB(255, 255, 255);
    pal[2]  = RGB(0,   0,   0  );
    pal[3]  = RGB(192, 192, 192);
    pal[4]  = RGB(128, 128, 128);
    pal[5]  = RGB(255, 0,   0  );
    pal[6]  = RGB(128, 0,   0  );
    pal[7]  = RGB(255, 255, 0  );
    pal[8]  = RGB(128, 128, 0  );
    pal[9]  = RGB(0  , 255, 0  );
    pal[10] = RGB(0  , 128, 0  );
    pal[11] = RGB(0  , 255, 255);
    pal[12] = RGB(0  , 128, 128);
    pal[13] = RGB(0  , 0,   255);
    pal[14] = RGB(0  , 0,   128);
    pal[15] = RGB(255, 0,   255);
    pal[16] = RGB(128, 0,   128);

    if (GetPaletteEntries(hpal, 11, 1, (LPPALETTEENTRY)&pal[17]))
    {
        pal[0]  = MAKELONG(0x300, 17);
        m_hpalVGA = CreatePalette((LPLOGPALETTE)pal);

        // get magic colors
        if (GetPaletteEntries(hpal, 8,  4, (LPPALETTEENTRY)&pal[17]))
        {
            pal[0]  = MAKELONG(0x300, 20);
            m_hpal3D = CreatePalette((LPLOGPALETTE)pal);
        }
    }

    return S_OK;
}


// get all of the interesting system information and put it in the tables
HRESULT CAdvAppearancePage::_InitSysStuff(void)
{
    int nIndex;

    _InitColorAndPalette();

    // clean out the memory
    for (nIndex = 0; nIndex < ARRAYSIZE(m_fonts); nIndex++)
    {
        m_fonts[nIndex].hfont = NULL;
    }

    // build all the brushes/fonts we need
    _RebuildSysStuff(TRUE);

    // Get the current System and User charsets based on locales and UI languages.
    _InitUniqueCharsetArray();

    return S_OK;
}

/*
** clean up any mess made in maintaining system information
** also, write out any global changes in our setup.
*/
void CAdvAppearancePage::_DestroySysStuff(void)
{
    int i;
    HKEY hkAppear;

    SelectObject(g_hdcMem, GetStockObject(BLACK_BRUSH));
    SelectObject(g_hdcMem, GetStockObject(SYSTEM_FONT));

    _FreeFonts();
    for (i = 0; i < COLOR_MAX; i++)
    {
        if (m_brushes[i])
        {
            DeleteObject(m_brushes[i]);
            m_brushes[i] = NULL;
        }
    }

    m_hbrGradientColor = m_hbrMainColor = m_hbrTextColor = NULL;
    // save out possible changes to custom color table
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_APPEARANCE, 0, KEY_WRITE, &hkAppear) == ERROR_SUCCESS)
    {
        RegSetValueEx(hkAppear, REGSTR_VAL_CUSTOMCOLORS, 0L, REG_BINARY,
                                (LPBYTE)g_CustomColors, sizeof(g_CustomColors));
        RegCloseKey(hkAppear);
    }

    // reset these so they init properly
    m_iCurElement = CURRENT_ELEMENT_NONE;
    m_iPrevSize = SIZE_NONE;
    m_bPalette = FALSE;
    m_fInUserEditMode = FALSE;
}



//------------------------ mini font picker controls --------------------------
// Add a facename/script combination to the font dropdown combo list.
//
// The strings are formatted as "FaceName (ScriptName)"
INT Font_AddNameToList(HWND hwndList, LPTSTR pszFace, LPTSTR pszScript)
{
    // Create temp buffer to hold a face name, a script name, one space
    // two parens and a NUL char.
    // 
    //  i.e.: "Arial (Western)"
#ifdef DEBUG
    TCHAR szFaceAndScript[LF_FACESIZE + LF_FACESIZE + 4];
#endif //DEBUG
    LPTSTR pszDisplayName = pszFace;
    INT iItem;

// We decided not to show the scriptnames; Only facenames will be shown.
// For the purpose of debugging, I leave the script name in debug versions only.
#ifdef DEBUG
    if (NULL != pszScript && TEXT('\0') != *pszScript)
    {
        //
        // Font has a script name.  Append it to the facename in parens.
        // This format string controls the appearance of the font names
        // in the list.  If you change this, you must also change the
        // extraction logic in Font_GetNameFromList().
        //
        StringCchPrintf(szFaceAndScript, ARRAYSIZE(szFaceAndScript), TEXT("%s(%s)"), pszFace, pszScript);
    
        pszDisplayName = szFaceAndScript;
    }
#endif //DEBUG

    //
    // Add the display name string to the listbox.
    //
    iItem = (INT)SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM)pszDisplayName);
    if (CB_ERR != iItem)
    {
        //
        // Ensure the drop-down combo list will show the entire string.
        //
        HDC hdc = GetDC(hwndList);
        if (NULL != hdc)
        {
            SIZE sizeItem;
            //
            // Make sure the list's font is selected into the DC before
            // calculating the text extent.
            //
            HFONT hfontList = (HFONT)SendMessage(hwndList, WM_GETFONT, 0, 0);
            HFONT hfontOld  = (HFONT)SelectObject(hdc, hfontList);

            if (GetTextExtentPoint32(hdc, pszDisplayName, lstrlen(pszDisplayName), &sizeItem))
            {
                //
                // Get the current width of the dropped list.
                //
                INT cxList = (int)SendMessage(hwndList, CB_GETDROPPEDWIDTH, 0, 0);
                //
                // We need the length of this string plus two
                // widths of a vertical scroll bar.
                //
                sizeItem.cx += (ClassicGetSystemMetrics(SM_CXVSCROLL) * 2);
                if (sizeItem.cx > cxList)
                {
                    //
                    // List is not wide enough.  Increase the width.
                    //
                    SendMessage(hwndList, CB_SETDROPPEDWIDTH, (WPARAM)sizeItem.cx, 0);
                }
            }
            SelectObject(hdc, hfontOld);
            ReleaseDC(hwndList, hdc);
        }
    }
    return iItem;
}


// Retrieve a font name from the font dropdown combo list.
// Optionally, retrieve the script name string.
BOOL Font_GetNameFromList(
    HWND hwndList,      // HWND of combo.
    INT iItem,          // Index of item in list.
    LPTSTR pszFace,     // Destination for face name.
    INT cchFaceMax,     // Chars in face name buffer.
    LPTSTR pszScript,   // Optional. Can be NULL
    INT cchScriptMax    // Optional. Ignored if pszScript is NULL
    )
{
    BOOL bResult = FALSE;
    TCHAR szItemText[LF_FACESIZE + LF_FACESIZE + 4];

    if (pszScript)
    {
        pszScript[0] = L'\0';
    }

    if (CB_ERR != SendMessage(hwndList, CB_GETLBTEXT, (WPARAM)iItem, (LPARAM)szItemText))
    {
        LPTSTR pszEnd, pszParen;                            // Lookahead pointer
        LPCTSTR pszStart = pszEnd = pszParen = szItemText;  // "Start" anchor pointer.

        //
        // Find the left paren.
        //
        for ( ; *pszEnd; pszEnd++) {
             if (TEXT('(') == *pszEnd)
                 pszParen = pszEnd;
        }
        
        if(pszParen > pszStart) //Did we find a parenthis?
            pszEnd = pszParen;  // Then that is the end of the facename.

        if (pszEnd > pszStart)
        {
            // Found it.  Copy face name.
            INT cchCopy = (int)(pszEnd - pszStart) + 1; //Add one for the null terminator
            if (cchCopy > cchFaceMax)
                cchCopy = cchFaceMax;

            StringCchCopy(pszFace, cchCopy, pszStart); //(cchCopy-1) bytes are copies followed by a null
            bResult = TRUE;

            if (*pszEnd && (NULL != pszScript))
            {
                // Caller wants the script part also.
                pszStart = ++pszEnd;
                
                // Find the right paren.
                while(*pszEnd && TEXT(')') != *pszEnd)
                    pszEnd++;

                if (*pszEnd && pszEnd > pszStart)
                {
                    // Found it.  Copy script name.
                    cchCopy = (int)(pszEnd - pszStart) + 1;
                    if (cchCopy > cchScriptMax)
                        cchCopy = cchScriptMax;

                    StringCchCopy(pszScript, cchCopy, pszStart);
                }
            }
        }
    }
    return bResult;
}


// Locate a facename/charset pair in the font list.
INT Font_FindInList(HWND hwndList, LPCTSTR pszFaceName)
{
    INT cItems = (int)SendMessage(hwndList, CB_GETCOUNT, 0, 0);
    INT i;

    for (i = 0; i < cItems; i++)
    {
        // All items in the fontlist have the same charset (SYSTEM_LOCALE_CHARSET).So, no point
        // in checking for the charset.
        //
        // Let's just get the facename and see if it matches.
        TCHAR szFaceName[LF_FACESIZE + 1];
        
        Font_GetNameFromList(hwndList, i, szFaceName, ARRAYSIZE(szFaceName), NULL, 0);

        if (0 == lstrcmpi(szFaceName, pszFaceName))
        {
            //
            // Face name matches.
            //
            return i;
        }
    }

    // No match found.
    return -1;
}


// Determine if a given font should be included in the font list.
// 
// dwType arg is DEVICE_FONTTYPE, RASTER_FONTTYPE, TRUETYPE_FONTTYPE.
//               EXTERNAL_FONTTYPE is a private code.  These are the
//               values returned to the enumproc from GDI.
BOOL Font_IncludeInList(
    LPENUMLOGFONTEX lpelf,
    DWORD dwType
    )
{
    BOOL bResult   = TRUE; // Assume it's OK to include.
    BYTE lfCharSet = lpelf->elfLogFont.lfCharSet;

#define EXTERNAL_FONTTYPE 8

    // Exclusions:
    //
    // 1. Don't display WIFE font for appearance because WIFE fonts are not 
    //    allowed to be any system use font such as menu/caption as it 
    //    realizes the font before WIFE gets initialized. B#5427
    //
    // 2. Exclude SYMBOL fonts.
    //
    // 3. Exclude OEM fonts.
    //
    // 4. Exclude vertical fonts.
    if (EXTERNAL_FONTTYPE & dwType ||
        lfCharSet == SYMBOL_CHARSET ||
        lfCharSet == OEM_CHARSET ||
        TEXT('@') == lpelf->elfLogFont.lfFaceName[0])
    {
        bResult = FALSE;
    }
    return bResult;
}


int CALLBACK Font_EnumNames(LPENUMLOGFONTEX lpelf, LPNEWTEXTMETRIC lpntm, DWORD dwType, LPARAM lData)
{
    ENUMFONTPARAM * pEnumFontParam = (ENUMFONTPARAM *)lData;
    return pEnumFontParam->pThis->_EnumFontNames(lpelf, lpntm, dwType, pEnumFontParam);
}


int CAdvAppearancePage::_EnumFontNames(LPENUMLOGFONTEX lpelf, LPNEWTEXTMETRIC lpntm, DWORD Type, ENUMFONTPARAM * pEnumFontParam)
{
    // Should font be included in the "Font" list?
    if (Font_IncludeInList(lpelf, Type))
    {
        int j;
        LOGFONT lf = lpelf->elfLogFont;             //Make a local copy of the given font
        BYTE    bSysCharset = lf.lfCharSet;         //Preserve the system charset we got.
        BOOL    fSupportsAllCharsets = TRUE;
        
        //The given font supports the system charset; Let's check if it supports the other charsets
        for(j = 1; j < m_iCountCharsets; j++)
        {
            lf.lfCharSet = (BYTE)m_uiUniqueCharsets[j];  //Let's try the next charset in the array.
            if(EnumFontFamiliesEx(pEnumFontParam->hdc, &lf, (FONTENUMPROC)Font_EnumValidCharsets, (LPARAM)0, 0) != 0)
            {
                // EnumFontFamiliesEx would have returned a zero if Font_EnumValidCharsets was called
                // even once. In other words, it returned a non-zero because not even a single font existed
                // that supported the given charset. Therefore, we need to skip this font.
                fSupportsAllCharsets = FALSE;
                break;
            }
        }

        if(fSupportsAllCharsets)
        {
            int i;

            // Yep. Add it to the list.
            i = Font_AddNameToList(pEnumFontParam->hwndFontName, lpelf->elfLogFont.lfFaceName, lpelf->elfScript);
            if (i != CB_ERR)
            {
                // Remember the font type and charset in the itemdata.
                //
                // LOWORD = Type
                // HIWORD = System Charset
                SendMessage(pEnumFontParam->hwndFontName, CB_SETITEMDATA, (WPARAM)i, MAKELPARAM(Type, bSysCharset));
            }
        }
    }
    return 1;
}


void CAdvAppearancePage::_InitFontList(HWND hDlg)
{
    LOGFONT lf;
    ENUMFONTPARAM EnumFontParam;

    // Enumerate all fonts on the system.
    // _EnumFontNames will filter out ones we don't want to show.
    lf.lfFaceName[0] = TEXT('\0') ;
    lf.lfCharSet     = (BYTE)m_uiUniqueCharsets[SYSTEM_LOCALE_CHARSET]; //Use charset from the System Locale.
    lf.lfPitchAndFamily = 0;
    EnumFontParam.hwndFontName = GetDlgItem(hDlg, IDC_ADVAP_FONTNAME);
    EnumFontParam.hdc = GetDC(NULL);
    EnumFontParam.pThis = this;
    EnumFontFamiliesEx(EnumFontParam.hdc, &lf, (FONTENUMPROC)Font_EnumNames, (LPARAM)&EnumFontParam, 0);

    ReleaseDC(NULL, EnumFontParam.hdc);
}


void Font_AddSize(HWND hwndPoints, int iNewPoint, BOOL bSort)
{
    TCHAR szBuf[10];
    int i, iPoint, count;

    // find the sorted place for this point size
    if (bSort)
    {
        count = (int)SendMessage(hwndPoints, CB_GETCOUNT, 0, 0L);
        for (i=0; i < count; i++)
        {
            iPoint = LOWORD(SendMessage(hwndPoints, CB_GETITEMDATA, (WPARAM)i, 0L));

            // don't add duplicates
            if (iPoint == iNewPoint)
                return;

            // belongs before this one
            if (iPoint > iNewPoint)
                break;
        }
    }
    else
        i = -1;

    StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT("%d"), iNewPoint);
    i = (int)SendMessage(hwndPoints, CB_INSERTSTRING, (WPARAM)i, (LPARAM)szBuf);
    if (i != CB_ERR)
        SendMessage(hwndPoints, CB_SETITEMDATA, (WPARAM)i, (LPARAM)iNewPoint);
}


// enumerate sizes for a non-TrueType font
int CALLBACK Font_EnumSizes(LPENUMLOGFONT lpelf, LPNEWTEXTMETRIC lpntm, int Type, LPARAM lData)
{
    CAdvAppearancePage * pThis = (CAdvAppearancePage *) lData;

    if (pThis)
    {
        return pThis->_EnumSizes(lpelf, lpntm, Type);
    }

    return 1;
}


int CAdvAppearancePage::_EnumSizes(LPENUMLOGFONT lpelf, LPNEWTEXTMETRIC lpntm, int Type)
{
    if (lpntm && _hwnd)
    {
        HWND hwndFontSize = GetDlgItem(_hwnd, IDC_ADVAP_FONTSIZE);

        Font_AddSize(hwndFontSize, _HeightToPoint(lpntm->tmHeight - lpntm->tmInternalLeading), TRUE);
    }

    return 1;
}


// a new element was picked, resulting in needing to set up a new font.
void CAdvAppearancePage::_NewFont(HWND hDlg, int iFont)
{
    int iSel;
    BOOL bBold;

    // find the name in the list and select it
    iSel = Font_FindInList(GetDlgItem(hDlg, IDC_ADVAP_FONTNAME), m_fonts[iFont].lf.lfFaceName);

    SendDlgItemMessage(hDlg, IDC_ADVAP_FONTNAME, CB_SETCURSEL, (WPARAM)iSel, 0L);
    _SelectName(hDlg, iSel);

    Font_SelectSize(hDlg, _HeightToPoint(m_fonts[iFont].lf.lfHeight));

    // REVIEW: should new size (returned above) be set in logfont?
    CheckDlgButton(hDlg, IDC_ADVAP_FONTITAL, m_fonts[iFont].lf.lfItalic);

    if (m_fonts[iFont].lf.lfWeight > FW_MEDIUM)
        bBold = TRUE;
    else
        bBold = FALSE;
    CheckDlgButton(hDlg, IDC_ADVAP_FONTBOLD, bBold);
}


// enable/disable the font selection controls.
// also involves blanking out anything meaningful if disabling.
void Font_EnableControls(HWND hDlg, BOOL bEnable)
{
    if (!bEnable)
    {
        SendDlgItemMessage(hDlg, IDC_ADVAP_FONTNAME, CB_SETCURSEL, (WPARAM)-1, 0L);
        SendDlgItemMessage(hDlg, IDC_ADVAP_FONTSIZE, CB_SETCURSEL, (WPARAM)-1, 0L);
        CheckDlgButton(hDlg, IDC_ADVAP_FONTITAL, 0);
        CheckDlgButton(hDlg, IDC_ADVAP_FONTBOLD, 0);
    }

    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FONTNAME), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FONTSIZE), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FONTSIZELABEL), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FONTLABEL), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FONTBOLD), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FONTITAL), bEnable);
}
//--------end------------- mini font picker controls --------------------------


void CAdvAppearancePage::_SetColor(HWND hDlg, int id, HBRUSH hbrColor)
{
    HWND hwndItem;
    switch (id)
    {
        case IDC_ADVAP_GRADIENT:
            m_hbrGradientColor = hbrColor;
            break;

        case IDC_ADVAP_MAINCOLOR:
            m_hbrMainColor = hbrColor;
            break;

        case IDC_ADVAP_TEXTCOLOR:
            m_hbrTextColor = hbrColor;
            break;

        default:
            return;

    }

    hwndItem = GetDlgItem(hDlg, id);
    if (hwndItem)
    {
        InvalidateRect(hwndItem, NULL, FALSE);
        UpdateWindow(hwndItem);
    }
}


void CAdvAppearancePage::_DrawDownArrow(HDC hdc, LPRECT lprc, BOOL bDisabled)
{
    HBRUSH hbr;
    int x, y;

    x = lprc->right - m_cxEdgeSM - 5;
    y = lprc->top + ((lprc->bottom - lprc->top)/2 - 1);

    if (bDisabled)
    {
        hbr = GetSysColorBrush(COLOR_3DHILIGHT);
        hbr = (HBRUSH) SelectObject(hdc, hbr);

        x++;
        y++;
        PatBlt(hdc, x, y, 5, 1, PATCOPY);
        PatBlt(hdc, x+1, y+1, 3, 1, PATCOPY);
        PatBlt(hdc, x+2, y+2, 1, 1, PATCOPY);

        SelectObject(hdc, hbr);
        x--;
        y--;
    }
    hbr = GetSysColorBrush(bDisabled ? COLOR_3DSHADOW : COLOR_BTNTEXT);
    hbr = (HBRUSH) SelectObject(hdc, hbr);

    PatBlt(hdc, x, y, 5, 1, PATCOPY);
    PatBlt(hdc, x+1, y+1, 3, 1, PATCOPY);
    PatBlt(hdc, x+2, y+2, 1, 1, PATCOPY);

    SelectObject(hdc, hbr);
    lprc->right = x;
}


// draw the color combobox thing
//
// also, if button was depressed, popup the color picker
//
void CAdvAppearancePage::_DrawButton(HWND hDlg, LPDRAWITEMSTRUCT lpdis)
{
    SIZE thin = { m_cxEdgeSM / 2, m_cyEdgeSM / 2 };
    RECT rc = lpdis->rcItem;
    HDC hdc = lpdis->hDC;
    BOOL bFocus = ((lpdis->itemState & ODS_FOCUS) &&
        !(lpdis->itemState & ODS_DISABLED));

    if (!thin.cx) thin.cx = 1;
    if (!thin.cy) thin.cy = 1;

    if (!m_hTheme)
    {
        if (lpdis->itemState & ODS_SELECTED)
        {
            DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
            OffsetRect(&rc, 1, 1);
        }
        else
        {
            DrawEdge(hdc, &rc, EDGE_RAISED, BF_RECT | BF_ADJUST);
        }

        FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));
    }
    else
    {
        int iStateId;

        if (lpdis->itemState & ODS_SELECTED)
        {
            iStateId = PBS_PRESSED;
        }
        else if (lpdis->itemState & ODS_HOTLIGHT)
        {
            iStateId = PBS_HOT;
        }
        else if (lpdis->itemState & ODS_DISABLED)
        {
            iStateId = PBS_DISABLED;
        }
        else if (lpdis->itemState & ODS_FOCUS)
        {
            iStateId = PBS_DEFAULTED;
        }
        else
        {
            iStateId = PBS_NORMAL;
        }

        DrawThemeBackground(m_hTheme, hdc, BP_PUSHBUTTON, iStateId, &rc, 0);
        GetThemeBackgroundContentRect(m_hTheme, hdc, BP_PUSHBUTTON, iStateId, &rc, &rc);
    }

    if (bFocus)
    {
        InflateRect(&rc, -thin.cx, -thin.cy);
        DrawFocusRect(hdc, &rc);
        InflateRect(&rc, thin.cx, thin.cy);
    }

    InflateRect(&rc, 1-thin.cx, -m_cyEdgeSM);

    rc.left += m_cxEdgeSM;
    _DrawDownArrow(hdc, &rc, lpdis->itemState & ODS_DISABLED);

    InflateRect(&rc, -thin.cx, 0);
    DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RIGHT);

    rc.right -= ( 2 * m_cxEdgeSM ) + thin.cx;

    // color sample
    if ( !(lpdis->itemState & ODS_DISABLED) )
    {
        HPALETTE hpalOld = NULL;
        HBRUSH hbr = 0;

        switch (lpdis->CtlID)
        {
            case IDC_ADVAP_GRADIENT:
                hbr = m_hbrGradientColor;
                break;

            case IDC_ADVAP_MAINCOLOR:
                hbr = m_hbrMainColor;
                break;

            case IDC_ADVAP_TEXTCOLOR:
                hbr = m_hbrTextColor;
                break;

        }

        FrameRect(hdc, &rc, GetSysColorBrush(COLOR_BTNTEXT));
        InflateRect(&rc, -thin.cx, -thin.cy);

        if (m_hpal3D)
        {
            hpalOld = SelectPalette(hdc, m_hpal3D, FALSE);
            RealizePalette(hdc);
        }

        if (hbr)
        {
            hbr = (HBRUSH) SelectObject(hdc, hbr);
            PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY);
            SelectObject(hdc, hbr);
        }
        
        if (hpalOld)
        {
            SelectPalette(hdc, hpalOld, TRUE);
            RealizePalette(hdc);
        }
    }
}


//--------end------------- color stuff --------------------------------------
void LoadCustomColors(void)
{
    HKEY hkSchemes;
    DWORD dwType, dwSize;

    // if no colors are there, initialize to all white
    for (int nIndex = 0; nIndex < ARRAYSIZE(g_CustomColors); nIndex++)
    {
        g_CustomColors[nIndex] = RGB(255, 255, 255);
    }

    // select the current scheme
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_APPEARANCE, 0, KEY_READ, &hkSchemes) == ERROR_SUCCESS)
    {
        // also, since this key is already open, get the custom colors
        dwSize = sizeof(g_CustomColors);
        dwType = REG_BINARY;

        // It's okay if this call fails.  We handle the case where the user
        // didn't create custom colors.
        RegQueryValueEx(hkSchemes, REGSTR_VAL_CUSTOMCOLORS, NULL, &dwType, (LPBYTE)g_CustomColors, &dwSize);

        RegCloseKey(hkSchemes);
    }
}


HRESULT CAdvAppearancePage::_SelectElement(HWND hDlg, int iElement, DWORD dwFlags)
{
    BOOL bEnable;
    int i;
    BOOL bEnableGradient;
    BOOL bGradient = FALSE;

    if ((iElement == m_iCurElement) && !(dwFlags & LSE_ALWAYS))
    {
        return S_OK;
    }

    ClassicSystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, (PVOID)&bGradient, 0);

    m_iCurElement = iElement;

    // if needed, find this element in the combobox and select it
    if (dwFlags & LSE_SETCUR)
    {
        i = (int)SendDlgItemMessage(hDlg, IDC_ADVAP_ELEMENTS, CB_GETCOUNT,0,0L);
        for (i--; i >=0 ; i--)
        {
            // if this is the one that references our element, stop
            if (iElement == (int)LOWORD(SendDlgItemMessage(hDlg, IDC_ADVAP_ELEMENTS, CB_GETITEMDATA, (WPARAM)i, 0L)))
                break;
        }
        SendDlgItemMessage(hDlg, IDC_ADVAP_ELEMENTS, CB_SETCURSEL, (WPARAM)i,0L);
    }

    bEnable = (ELCUR.iMainColor != COLOR_NONE);
    if (bEnable)
        _SetColor(hDlg, IDC_ADVAP_MAINCOLOR, m_brushes[ELCUR.iMainColor]);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_MAINCOLOR), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_COLORLABEL), bEnable);

    bEnableGradient = ((ELCUR.iGradientColor != COLOR_NONE));

    if (bEnableGradient)
        _SetColor(hDlg, IDC_ADVAP_GRADIENT, m_brushes[ELCUR.iGradientColor]);
   
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_GRADIENT), (bEnableGradient && bGradient));
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_GRADIENTLABEL), (bEnableGradient && bGradient));

    bEnable = (ELCUR.iFont != FONT_NONE);
    if (bEnable)
    {
        _NewFont(hDlg, ELCUR.iFont);
    }
    Font_EnableControls(hDlg, bEnable);

    // size may be based on font
    _DoSizeStuff(hDlg, FALSE);

    bEnable = (ELCUR.iSize != SIZE_NONE);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_MAINSIZE), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_SIZEARROWS), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_SIZELABEL), bEnable);

    bEnable = (ELCUR.iTextColor != COLOR_NONE);
    if (bEnable)
        _SetColor(hDlg, IDC_ADVAP_TEXTCOLOR, m_brushes[ELCUR.iTextColor]);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_TEXTCOLOR), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FNCOLORLABEL), bEnable);

    return S_OK;
}


void CAdvAppearancePage::_Repaint(HWND hDlg, BOOL bRecalc)
{
    HWND hwndLookPrev;

    hwndLookPrev = GetDlgItem(hDlg, IDC_ADVAP_LOOKPREV);
    if (bRecalc)
    {
        _SyncSize(hDlg);
        RECT rc;
        GetClientRect(hwndLookPrev, &rc);
        _Recalc(&rc);
    }

    _RepaintPreview(hwndLookPrev);
}


void CAdvAppearancePage::_SetCurSizeAndRange(HWND hDlg)
{
    if (ELCUR.iSize == SIZE_NONE)
        SetDlgItemText(hDlg, IDC_ADVAP_MAINSIZE, TEXT(""));
    else
    {
        SendDlgItemMessage(hDlg, IDC_ADVAP_SIZEARROWS, UDM_SETRANGE, 0,
            MAKELPARAM(m_elCurrentSize.MaxSize, m_elCurrentSize.MinSize));
        SetDlgItemInt(hDlg, IDC_ADVAP_MAINSIZE, m_elCurrentSize.CurSize, TRUE);
    }
}


void CAdvAppearancePage::_SyncSize(HWND hDlg)
{
    if (m_iPrevSize != SIZE_NONE)
        m_sizes[m_iPrevSize].CurSize = m_elCurrentSize.CurSize;

    if (m_iCurElement >= 0)
        m_iPrevSize = ELCUR.iSize;
}


void CAdvAppearancePage::_UpdateSizeBasedOnFont(HWND hDlg, BOOL fComputeIdeal)
{
    if ((ELCUR.iSize != SIZE_NONE) && (ELCUR.iFont != FONT_NONE))
    {
        TEXTMETRIC tm;
        HFONT hfontOld = (HFONT) SelectObject(g_hdcMem, ELCURFONT.hfont);

        GetTextMetrics(g_hdcMem, &tm);
        if (ELCUR.iSize == SIZE_MENU)
        {
            // Include external leading for menus
            tm.tmHeight += tm.tmExternalLeading;
        }

        if (hfontOld)
        {
            SelectObject(g_hdcMem, hfontOld);
        }

        m_elCurrentSize.MinSize = tm.tmHeight + 2 * m_cyBorderSM;
        if (fComputeIdeal)
        {
            if ((ELCUR.iSize == SIZE_CAPTION || ELCUR.iSize == SIZE_MENU) &&
                (m_elCurrentSize.MinSize < (ClassicGetSystemMetrics(SM_CYICON)/2 + 2 * m_cyBorderSM)))
            {
                m_elCurrentSize.CurSize = ClassicGetSystemMetrics(SM_CYICON)/2 + 2 * m_cyBorderSM;
            }
            else
            {
                m_elCurrentSize.CurSize = m_elCurrentSize.MinSize;
            }
        }
        else if (m_elCurrentSize.CurSize < m_elCurrentSize.MinSize)
        {
            m_elCurrentSize.CurSize = m_elCurrentSize.MinSize;
        }
    }
}


void CAdvAppearancePage::_DoSizeStuff(HWND hDlg, BOOL fCanSuggest)
{
    _SyncSize(hDlg);

    if (ELCUR.iSize != SIZE_NONE)
    {
        m_elCurrentSize = m_sizes[ELCUR.iSize];

        if (ELCUR.fLinkSizeToFont)
        {
            _UpdateSizeBasedOnFont(hDlg, fCanSuggest);
        }

        if (m_elCurrentSize.CurSize < m_elCurrentSize.MinSize)
        {
            m_elCurrentSize.CurSize = m_elCurrentSize.MinSize;
        }
        else if (m_elCurrentSize.CurSize > m_elCurrentSize.MaxSize)
        {
            m_elCurrentSize.CurSize = m_elCurrentSize.MaxSize;
        }
    }

    _SetCurSizeAndRange(hDlg);
}


void CAdvAppearancePage::_RebuildCurFont(HWND hDlg)
{
     if (ELCURFONT.hfont)
        DeleteObject(ELCURFONT.hfont);
    ELCURFONT.hfont = CreateFontIndirect(&ELCURFONT.lf);

    _DoSizeStuff(hDlg, TRUE);
    _Repaint(hDlg, TRUE);
}


void CAdvAppearancePage::_Changed(HWND hDlg, DWORD dwChange)
{
    if (m_fInUserEditMode)
    {
        if ((dwChange != SCHEME_CHANGE) && (dwChange != DPI_CHANGE))
        {
            // We keep track if we have customized settings from the stock Scheme.
            m_fModifiedScheme = TRUE;
        }
        else
        {
            dwChange = METRIC_CHANGE | COLOR_CHANGE;
        }

        m_dwChanged |= dwChange;
    }
}


void CAdvAppearancePage::_ChangeFontName(HWND hDlg, LPCTSTR szBuf, INT iCharSet)
{
    if (lstrcmpi(ELCURFONT.lf.lfFaceName, szBuf) == 0 &&
        ELCURFONT.lf.lfCharSet == iCharSet)
    {
        return;
    }

    StringCchCopy(ELCURFONT.lf.lfFaceName, ARRAYSIZE(ELCURFONT.lf.lfFaceName), szBuf);
    ELCURFONT.lf.lfCharSet = (BYTE)iCharSet;

    _RebuildCurFont(hDlg);
    _Changed(hDlg, METRIC_CHANGE);
}


void CAdvAppearancePage::_ChangeFontSize(HWND hDlg, int Points)
{
    if (ELCURFONT.lf.lfHeight != _PointToHeight(Points))
    {
        ELCURFONT.lf.lfHeight = _PointToHeight(Points);
        _RebuildCurFont(hDlg);
        _Changed(hDlg, METRIC_CHANGE);
    }
}


void CAdvAppearancePage::_ChangeFontBI(HWND hDlg, int id, BOOL bCheck)
{
    if (id == IDC_ADVAP_FONTBOLD) // bold
    {
        if (bCheck)
            ELCURFONT.lf.lfWeight = FW_BOLD;
        else
            ELCURFONT.lf.lfWeight = FW_NORMAL;
    }
    else   // italic
    {
        ELCURFONT.lf.lfItalic = (BYTE)bCheck;
    }

    _RebuildCurFont(hDlg);
    _Changed(hDlg, METRIC_CHANGE);
}


void CAdvAppearancePage::_ChangeSize(HWND hDlg, int NewSize, BOOL bRepaint)
{
    if (m_elCurrentSize.CurSize != NewSize)
    {
        m_elCurrentSize.CurSize = NewSize;
        if (bRepaint)
        {
            _Repaint(hDlg, TRUE);
        }

        _Changed(hDlg, METRIC_CHANGE);
    }
}


BOOL CAdvAppearancePage::_ChangeColor(HWND hDlg, int iColor, COLORREF rgb)
{
    COLORREF rgbShadow, rgbHilight, rgbWatermark;

    if ((rgb & 0x00FFFFFF) == (m_rgb[iColor] & 0x00FFFFFF))
        return FALSE;

    if (iColor == COLOR_3DFACE)
    {
        rgbShadow    = AdjustLuma(rgb, m_i3DShadowAdj,  m_fScale3DShadowAdj);
        rgbHilight   = AdjustLuma(rgb, m_i3DHilightAdj, m_fScale3DHilightAdj);
        rgbWatermark = AdjustLuma(rgb, m_iWatermarkAdj, m_fScaleWatermarkAdj);


        _Set3DPaletteColor(rgb, COLOR_3DFACE);
        _Set3DPaletteColor(rgbShadow, COLOR_3DSHADOW);
        _Set3DPaletteColor(rgbHilight, COLOR_3DHILIGHT);

        // update colors tagged to 3DFACE
        m_rgb[COLOR_3DFACE] = rgb;
        m_rgb[COLOR_3DLIGHT] =  rgb; // BOGUS TEMPORARY
        m_rgb[COLOR_ACTIVEBORDER] =  rgb;
        m_rgb[COLOR_INACTIVEBORDER] =  rgb;
        m_rgb[COLOR_MENU] =  rgb;

        // update colors tagged to 3DSHADOW
        m_rgb[COLOR_GRAYTEXT] = rgbShadow;
        m_rgb[COLOR_APPWORKSPACE] = rgbShadow;
        m_rgb[COLOR_3DSHADOW] = rgbShadow;
        m_rgb[COLOR_INACTIVECAPTION] = rgbShadow;

        // update colors tagged to 3DHIGHLIGHT
        m_rgb[COLOR_3DHILIGHT] = rgbHilight;
        m_rgb[COLOR_SCROLLBAR] = rgbHilight;

        if ((m_rgb[COLOR_SCROLLBAR] & 0x00FFFFFF) ==
            (m_rgb[COLOR_WINDOW] & 0x00FFFFFF))
        {
            m_rgb[COLOR_SCROLLBAR] = RGB( 192, 192, 192 );
        }
    }
    else
    {
        m_rgb[iColor] = rgb;
    }

    _RebuildSysStuff(FALSE);
    _Changed(hDlg, COLOR_CHANGE);
    return TRUE;
}


void CAdvAppearancePage::_PropagateMessage(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    HWND hwndChild;

    // Don't propagate during exit since this is only for good looks, and the Up/Down's
    // get confused if they get a WM_SETTINGSHCANGED while they are getting destroyed
    if (m_fProprtySheetExiting)
        return;

    for (hwndChild = ::GetWindow(hwnd, GW_CHILD); hwndChild != NULL;
        hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT))
    {
#ifdef DBG_PRINT
        TCHAR szTmp[256];
        GetClassName(hwndChild, szTmp, 256);

        TraceMsg(TF_GENERAL, "desk (PropagateMessage): SendingMessage( 0x%08lX cls:%s, 0x%08X, 0x%08lX, 0x%08lX )\n", hwndChild, szTmp, uMessage, wParam, lParam ));
#endif
        SendMessage(hwndChild, uMessage, wParam, lParam);
        TraceMsg(TF_GENERAL,"desk (PropagateMessage): back from SendingMessage\n");
    }
}


//--------end------------- manage system settings --------------------------




// Fill in a NONCLIENTMETRICS structure with latest preview stuff
void CAdvAppearancePage::_GetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm)
{
    lpncm->iBorderWidth = (LONG)m_sizes[SIZE_FRAME].CurSize;
    lpncm->iScrollWidth = lpncm->iScrollHeight = (LONG)m_sizes[SIZE_SCROLL].CurSize;
    lpncm->iSmCaptionWidth = lpncm->iSmCaptionHeight = (LONG)m_sizes[SIZE_SMCAPTION].CurSize;
    lpncm->iMenuWidth = lpncm->iMenuHeight = (LONG)m_sizes[SIZE_MENU].CurSize;

    // #355378: 
    // PRE-WHISTLER: Caption Height always matched Width.  They were authored this way and
    // the UI forced them to be the same.  I don't know if apps rely on this behavior but they
    // could have.  The Status Bar icon is equal to the min(CaptionWidth, CaptionHeight).
    // The user really wants their caption buttons to be square, so that also wants
    // them to be equal.  A caption width of 18 makes the icon be 16, anything else causes
    // icon stretch and looks really bad.
    // 
    // WHISTLER: In Whistler, our designers want a height of 25 so it looks nicer.  They
    // want the width to remain 18 so the icon is 16 pixels (inctlpan.c) in each direction.  This means that
    // this code can no longer force them to be even.  ScottHan forces the captionbar buttons to
    // be square solving that problem.  I will now keep the aspect ratio so I scale them correctly.
    // If we are close, I will snap to 18 to fix rounding errors.
    lpncm->iCaptionHeight = (LONG)m_sizes[SIZE_CAPTION].CurSize;
    lpncm->iCaptionWidth = (int) (m_fCaptionRatio * lpncm->iCaptionHeight);

    // Don't shrink the caption width below 18 point until the caption height also gets below 18.
    if (lpncm->iCaptionWidth < 18 && lpncm->iCaptionHeight >= 18)
    {
        lpncm->iCaptionWidth = 18;
    }

    if ((lpncm->iCaptionWidth <= 19) && (lpncm->iCaptionWidth >= 17) &&
        (1.0f != m_fCaptionRatio))
    {
        // Icons only really look good at 16 pixels, so we need to set lpncm->iCaptionWidth to make the
        // Caption bar icon 16 pixels. (#355378)
        lpncm->iCaptionWidth = 18;
    }

    LFtoLF32(&(m_fonts[FONT_CAPTION].lf), &(lpncm->lfCaptionFont));
    LFtoLF32(&(m_fonts[FONT_SMCAPTION].lf), &(lpncm->lfSmCaptionFont));
    LFtoLF32(&(m_fonts[FONT_MENU].lf), &(lpncm->lfMenuFont));
    LFtoLF32(&(m_fonts[FONT_STATUS].lf), &(lpncm->lfStatusFont));
    LFtoLF32(&(m_fonts[FONT_MSGBOX].lf), &(lpncm->lfMessageFont));
}


// given a NONCLIENTMETRICS structure, make it preview's current setting
void CAdvAppearancePage::_SetMyNonClientMetrics(const LPNONCLIENTMETRICS lpncm)
{
    m_sizes[SIZE_FRAME].CurSize = (int)lpncm->iBorderWidth;
    m_sizes[SIZE_SCROLL].CurSize = (int)lpncm->iScrollWidth;
    m_sizes[SIZE_SMCAPTION].CurSize = (int)lpncm->iSmCaptionHeight;
    m_sizes[SIZE_MENU].CurSize = (int)lpncm->iMenuHeight;

    m_sizes[SIZE_CAPTION].CurSize = (int)lpncm->iCaptionHeight;
    m_fCaptionRatio = ((float) lpncm->iCaptionWidth / (float) lpncm->iCaptionHeight);

    LF32toLF(&(lpncm->lfCaptionFont), &(m_fonts[FONT_CAPTION].lf));
    LF32toLF(&(lpncm->lfSmCaptionFont), &(m_fonts[FONT_SMCAPTION].lf));
    LF32toLF(&(lpncm->lfMenuFont), &(m_fonts[FONT_MENU].lf));
    LF32toLF(&(lpncm->lfStatusFont), &(m_fonts[FONT_STATUS].lf));
    LF32toLF(&(lpncm->lfMessageFont), &(m_fonts[FONT_MSGBOX].lf));
}

//--------end------------- scheme stuff --------------------------------------


HRESULT CAdvAppearancePage::_IsDirty(IN BOOL * pIsDirty)
{
    HRESULT hr = E_INVALIDARG;

    if (pIsDirty)
    {
        *pIsDirty = (NO_CHANGE != m_dwChanged);
        hr = S_OK;
    }

    return hr;
}





//===========================
// *** IAdvancedDialog Interface ***
//===========================
HRESULT CAdvAppearancePage::DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply)
{
    HRESULT hr = E_INVALIDARG;

    if (hwndParent && pBasePage && pfEnableApply)
    {
        // Load State Into Advanced Dialog 
        ATOMICRELEASE(g_pAdvAppearancePage);
        g_pAdvAppearancePage = this;
        AddRef();
        *pfEnableApply = FALSE;

        if (FAILED(SHPropertyBag_ReadInt(pBasePage, SZ_PBPROP_DPI_MODIFIED_VALUE, &m_nCachedNewDPI)))
        {
            m_nCachedNewDPI = DPI_PERSISTED;    // Default to the default DPI.
        }

        // Display Advanced Dialog
        if (IDOK == DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_APPEARANCE_ADVANCEDPG), hwndParent, CAdvAppearancePage::AdvAppearDlgProc, (LPARAM)this))
        {
            // The user clicked OK, so merge modified state back into base dialog
            _IsDirty(pfEnableApply);

            // The user clicked Okay in the dialog so merge the dirty state from the
            // advanced dialog into the base dialog.
            int nIndex;
            SYSTEMMETRICSALL state = {0};

            state.dwChanged = m_dwChanged;
            state.schemeData.version = SCHEME_VERSION;
            state.schemeData.wDummy = 0;
            state.schemeData.ncm.cbSize = sizeof(state.schemeData.ncm);

            for (nIndex = 0; nIndex < ARRAYSIZE(m_rgb); nIndex++)
            {
                state.schemeData.rgb[nIndex] = m_rgb[nIndex];
            }

            _GetMyNonClientMetrics(&state.schemeData.ncm);

            // Set Sizes
            state.nDXIcon = m_sizes[SIZE_DXICON].CurSize;
            state.nDYIcon = m_sizes[SIZE_DYICON].CurSize;
            state.nIcon = m_sizes[SIZE_ICON].CurSize;
            state.nSmallIcon = m_sizes[SIZE_SMICON].CurSize;
            state.fModifiedScheme = m_fModifiedScheme;

            // Set Fonts
            state.schemeData.lfIconTitle = m_fonts[FONT_ICONTITLE].lf;

            VARIANT var = {0};
            hr = pBasePage->Read(SZ_PBPROP_SYSTEM_METRICS, &var, NULL);
            if (SUCCEEDED(hr) && (VT_BYREF == var.vt) && var.byref)
            {
                SYSTEMMETRICSALL * pCurrent = (SYSTEMMETRICSALL *) var.byref;
                state.fFlatMenus = pCurrent->fFlatMenus;        // Maintain this value.
                state.fHighContrast = pCurrent->fHighContrast;        // Maintain this value.
            }

            hr = SHPropertyBag_WriteByRef(pBasePage, SZ_PBPROP_SYSTEM_METRICS, (void *)&state);
        }

        ATOMICRELEASE(g_pAdvAppearancePage);
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
ULONG CAdvAppearancePage::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CAdvAppearancePage::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CAdvAppearancePage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAdvAppearancePage, IPersist),
        QITABENT(CAdvAppearancePage, IObjectWithSite),
        QITABENT(CAdvAppearancePage, IAdvancedDialog),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}



int g_nSizeInitArray[9][3] = 
{
    {0, 0, 50},         // SIZE_FRAME
    {0, 8, 100},        // SIZE_SCROLL
    {0, 8, 100},        // SIZE_CAPTION
    {0, 4, 100},        // SIZE_SMCAPTION
    {0, 8, 100},        // SIZE_MENU
    {0, 0, 150},        // SIZE_DXICON - x spacing
    {0, 0, 150},        // SIZE_DYICON - y spacing
    {0, 16, 72},        // SIZE_ICON - shell icon size
    {0, 8, 36},
};

//===========================
// *** Class Methods ***
//===========================
CAdvAppearancePage::CAdvAppearancePage(IN const SYSTEMMETRICSALL * pState) : CObjectCLSID(&PPID_AdvAppearance), m_cRef(1)
{
    int nIndex;
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hpal3D);
    ASSERT(!m_hpalVGA);
    ASSERT(!m_hbrMainColor);
    ASSERT(!m_hbrTextColor);
    ASSERT(!m_hbrGradientColor);

    m_dwChanged = NO_CHANGE;
    m_iCurElement = CURRENT_ELEMENT_NONE;         // start off as not even "not set"
    m_iPrevSize = SIZE_NONE;

    m_bPalette = FALSE;
    m_fInUserEditMode = FALSE;
    m_fProprtySheetExiting = FALSE;

    m_i3DShadowAdj = -333;
    m_i3DHilightAdj = 500;
    m_iWatermarkAdj = -50;

    m_fScale3DShadowAdj  = TRUE;
    m_fScale3DHilightAdj = TRUE;
    m_fScaleWatermarkAdj = TRUE;

    m_hTheme = NULL;

    m_iCountCharsets = 0;
    for (nIndex = 0; nIndex < ARRAYSIZE(m_uiUniqueCharsets); nIndex++)
    {
        m_uiUniqueCharsets[nIndex] = DEFAULT_CHARSET;
    }

    for (int nIndex1 = 0; nIndex1 < ARRAYSIZE(g_nSizeInitArray); nIndex1++)
    {
        m_sizes[nIndex1].CurSize = g_nSizeInitArray[nIndex1][0];
        m_sizes[nIndex1].MinSize = g_nSizeInitArray[nIndex1][1];
        m_sizes[nIndex1].MaxSize = g_nSizeInitArray[nIndex1][2];
    }

    CreateGlobals();

    _LoadState(pState);
}


CAdvAppearancePage::~CAdvAppearancePage()
{
    if (m_hpal3D)
    {
        DeleteObject(m_hpal3D);
        m_hpal3D = NULL;
    }

    if (m_hpalVGA)
    {
        DeleteObject(m_hpalVGA);
        m_hpalVGA = NULL;
    }

    if (g_hdcMem)
    {
        DeleteDC(g_hdcMem);
        g_hdcMem = NULL;
    }

    DllRelease();
}




HRESULT CAdvAppearancePage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog, IN const SYSTEMMETRICSALL * pState)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        CAdvAppearancePage * ptsp = new CAdvAppearancePage(pState);

        if (ptsp)
        {
            hr = ptsp->QueryInterface(IID_PPV_ARG(IAdvancedDialog, ppAdvDialog));
            ptsp->Release();
        }
        else
        {
            *ppAdvDialog = NULL;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\advdlg.h ===
/*****************************************************************************\
    FILE: AdvDlg.h

    DESCRIPTION:
        This code will display the "Advanced Display Properties" dialog.

    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _ADVDLG_H
#define _ADVDLG_H


#define MAX_ADVDLG_PAGES            10

HRESULT CThemeManager_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
HRESULT CThemeUIPages_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);

class CThemeManager             : public IThemeUIPages
                                , public CImpIDispatch
                                , public CObjectWithSite
                                , public IThemeManager
                                , public IPropertyBag
                                , public IPreviewSystemMetrics
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeManager ***
    virtual STDMETHODIMP get_SelectedTheme(OUT ITheme ** ppTheme);
    virtual STDMETHODIMP put_SelectedTheme(IN ITheme * pTheme);
    virtual STDMETHODIMP get_SelectedScheme(OUT IThemeScheme ** ppThemeScheme);
    virtual STDMETHODIMP put_SelectedScheme(IN IThemeScheme * pThemeStyle);
    virtual STDMETHODIMP get_WebviewCSS(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT ITheme ** ppTheme);
    virtual STDMETHODIMP get_schemeLength(OUT long * pnLength);
    virtual STDMETHODIMP get_schemeItem(IN VARIANT varIndex, OUT IThemeScheme ** ppThemeScheme);

    virtual STDMETHODIMP GetSelectedSchemeProperty(IN BSTR bstrName, OUT BSTR * pbstrValue);
    virtual STDMETHODIMP GetSpecialTheme(IN BSTR bstrName, OUT ITheme ** ppTheme);
    virtual STDMETHODIMP SetSpecialTheme(IN BSTR bstrName, IN ITheme * pTheme);
    virtual STDMETHODIMP GetSpecialScheme(IN BSTR bstrName, OUT IThemeScheme ** ppThemeScheme, OUT IThemeStyle ** ppThemeStyle, OUT IThemeSize ** ppThemeSize);
    virtual STDMETHODIMP SetSpecialScheme(IN BSTR bstrName, IN IThemeScheme * pThemeScheme, IThemeStyle * pThemeStyle, IThemeSize * pThemeSize);
    virtual STDMETHODIMP ApplyNow(void);

    // *** IThemeUIPages ***
    virtual STDMETHODIMP AddPage(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam, IN long nPageID);
    virtual STDMETHODIMP AddBasePage(IN IBasePropPage * pBasePage);
    virtual STDMETHODIMP ApplyPressed(IN DWORD dwFlags);
    virtual STDMETHODIMP GetBasePagesEnum(OUT IEnumUnknown ** ppEnumUnknown);
    virtual STDMETHODIMP UpdatePreview(IN DWORD dwFlags);
    virtual STDMETHODIMP AddFakeSettingsPage(IN LPVOID pVoid);
    virtual STDMETHODIMP SetExecMode(IN DWORD dwEM);
    virtual STDMETHODIMP GetExecMode(OUT DWORD* pdwEM);
    virtual STDMETHODIMP LoadMonitorBitmap(IN BOOL fFillDesktop, OUT HBITMAP* phbmMon);
    virtual STDMETHODIMP DisplaySaveSettings(IN PVOID pContext, IN HWND hwnd, OUT int* piRet);

    // *** IObjectWithSite ***
    virtual STDMETHODIMP SetSite(IUnknown *punkSite);

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IPreviewSystemMetrics ***
    virtual STDMETHODIMP RefreshColors(void);
    virtual STDMETHODIMP UpdateDPIchange(void);
    virtual STDMETHODIMP UpdateCharsetChanges(void);
    virtual STDMETHODIMP DeskSetCurrentScheme(IN LPCWSTR pwzSchemeName);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_NOTIMPL; }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return E_NOTIMPL; }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr);

protected:
    HRESULT _Initialize(void);

private:
    CThemeManager();
    virtual ~CThemeManager(void);

    // Private Member Variables
    long                    m_cRef;

    HWND                    m_hwndParent;                               // hwnd of parent.
    IBasePropPage *         m_pBasePages[MAX_ADVDLG_PAGES];             // These are the tabs on the Base dlg that want to add tabs to the Adv dlg.
    IThemePreview *         m_pPreview1;                                // 
    IThemePreview *         m_pPreview2;                                // 
    IThemePreview *         m_pPreview3;                                // 
    DWORD                   _dwEM;                                      // Stores the Execution mode in a center location
    LPWSTR                  _pszSelectTheme;                            // This is the selected .Theme file.
    IThemeScheme *          _pThemeSchemeSelected;                      // This is the selected .msstyles file.
    LONG                    m_cSpiThreads;
    BOOL                    m_fForceTimeout;

    HDPA                    m_hdpaThemeDirs;        // This contains LPWSTRs that contain theme (*.theme) files.
    HDPA                    m_hdpaSkinDirs;         // This contains LPWSTRs that contain skins (*.msstyles) files.

    // Private Member Functions
    HRESULT _GetPropertyBagByCLSID(IN const GUID * pClsid, IN IPropertyBag ** ppPropertyBag);
    HRESULT _SaveCustomValues(void);

    HRESULT _InitThemeDirs(void);
    HRESULT _AddThemesFromDir(LPCTSTR pszPath, BOOL fFirstLevel, int nInsertLoc);
    HRESULT _saveGetSelectedScheme(OUT IThemeScheme ** ppThemeScheme);

    HRESULT _InitSkinDirs(void);
    HRESULT _EnumSkinCB(THEMECALLBACK tcbType, LPCWSTR pszFileName, OPTIONAL LPCWSTR pszDisplayName, OPTIONAL LPCWSTR pszToolTip, OPTIONAL int iIndex);
    HRESULT _EnumSkinsFromKey(HKEY hKey);

    HRESULT _InitSelectedThemeFile(void);
    HRESULT _SetSelectedThemeEntree(LPCWSTR pszPath);

    // Friend Functions
    friend HRESULT CThemeManager_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
    friend HRESULT CThemeUIPages_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
    static BOOL EnumSkinCB(THEMECALLBACK tcbType, LPCWSTR pszFileName, OPTIONAL LPCWSTR pszDisplayName, OPTIONAL LPCWSTR pszToolTip, OPTIONAL int iIndex, LPARAM lParam);
};



#endif // _ADVDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\advdlg.cpp ===
/*****************************************************************************\
    FILE: AdvDlg.cpp

    DESCRIPTION:
        This code will display the "Advanced Display Properties" dialog.

    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "BaseAppearPg.h"
#include "ThemePg.h"
#include "EnumUnknown.h"
#include "AdvDlg.h"
#include "AdvAppearPg.h"
#include "ThSettingsPg.h"
#include "ScreenSaverPg.h"
#include "fontfix.h"
#include <themeid.h>








//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CThemeManager::_Initialize(void)
{
    HRESULT hr = E_OUTOFMEMORY;

    CThemePage * pThemesPage = new CThemePage();
    if (pThemesPage)
    {
        CBaseAppearancePage * pAppearancePage = new CBaseAppearancePage();
        if (pAppearancePage)
        {
            hr = pThemesPage->QueryInterface(IID_PPV_ARG(IBasePropPage, &(m_pBasePages[PAGE_DISPLAY_THEMES])));
            if (SUCCEEDED(hr))
            {
                IUnknown_SetSite(m_pBasePages[PAGE_DISPLAY_THEMES], SAFECAST(this, IThemeUIPages *));
                hr = pAppearancePage->QueryInterface(IID_PPV_ARG(IBasePropPage, &(m_pBasePages[PAGE_DISPLAY_APPEARANCE])));
                if (SUCCEEDED(hr))
                {
                    IUnknown_SetSite(m_pBasePages[PAGE_DISPLAY_APPEARANCE], SAFECAST(this, IThemeUIPages *));
                    hr = CoCreateInstance(CLSID_SettingsPage, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBasePropPage, &(m_pBasePages[PAGE_DISPLAY_SETTINGS])));
                    if (SUCCEEDED(hr))
                    {
                        IUnknown_SetSite(m_pBasePages[PAGE_DISPLAY_SETTINGS], SAFECAST(this, IThemeUIPages *));
                    }
                }
            }
            pAppearancePage->Release();
        }
        pThemesPage->Release();
    }

    return hr;
}



//===========================
// *** IThemeUIPages Interface ***
//===========================
HRESULT CThemeManager::AddPage(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam, IN long nPageID)
{
    HRESULT hr = E_INVALIDARG;
    IShellPropSheetExt * pspse = NULL;

    RegisterPreviewSystemMetricClass(HINST_THISDLL);
    if ((PAGE_DISPLAY_THEMES <= nPageID) && (PAGE_DISPLAY_SETTINGS >= nPageID))
    {
        if (m_pBasePages[nPageID])
        {
            hr = m_pBasePages[nPageID]->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &pspse));
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = pspse->AddPages(pfnAddPage, lParam);
        if (SUCCEEDED(hr))
        {
            // We give the page a pointer back to use so they can call
            // IThemeUIPages::DisplayAdvancedDialog() in order to display
            // the Advanced Dlg.
            hr = IUnknown_SetSite(pspse, (IThemeUIPages *)this);
        }
    }

    ATOMICRELEASE(pspse);
    return hr;
}


HRESULT CThemeManager::AddBasePage(IN IBasePropPage * pBasePage)
{
    int nIndex;

    for (nIndex = (PAGE_DISPLAY_APPEARANCE + 1); nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
    {
        if (NULL == m_pBasePages[nIndex])   // Did we find an empty spot?
        {
            // Yes, so look no longer.
            IUnknown_Set((IUnknown **)&(m_pBasePages[nIndex]), (IUnknown *)pBasePage);
            if (m_pBasePages[nIndex])
            {
                // We give the page a pointer back to use so they can call
                // IThemeUIPages::DisplayAdvancedDialog() in order to display
                // the Advanced Dlg.
                IUnknown_SetSite(m_pBasePages[nIndex], (IThemeUIPages *)this);
            }
            break;
        }
    }

    return S_OK;
}


HRESULT CThemeManager::ApplyPressed(IN DWORD dwFlags)
{
    // We need to set the base pages' site pointers to NULL
    // in order to break the ref-count cycle.
    if (m_pBasePages[PAGE_DISPLAY_SETTINGS])
    {
        m_pBasePages[PAGE_DISPLAY_SETTINGS]->OnApply(PPOAACTION_APPLY);
    }

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
    {
        if ((nIndex != PAGE_DISPLAY_SETTINGS) && m_pBasePages[nIndex])
        {
            m_pBasePages[nIndex]->OnApply(PPOAACTION_APPLY);
        }
    }

    if (TUIAP_WAITFORAPPLY & dwFlags)
    {
        m_fForceTimeout = TRUE;
    }

    // If nobody sent the message to the HWND to simulate an apply,
    // do so now.
    if (TUIAP_CLOSE_DIALOG & dwFlags)
    {
        HWND hwndBasePropDlg = GetParent(m_hwndParent);

        PropSheet_PressButton(hwndBasePropDlg, PSBTN_OK);
    }

    return S_OK;
}


HRESULT CThemeManager::GetBasePagesEnum(OUT IEnumUnknown ** ppEnumUnknown)
{
    return CEnumUnknown_CreateInstance(SAFECAST(this, IThemeUIPages *), (IUnknown **)m_pBasePages, ARRAYSIZE(m_pBasePages), 0, ppEnumUnknown);
}


HRESULT CThemeManager::UpdatePreview(IN DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (m_pPreview1)  // It's okay if this is NULL because it will update when it's created.
    {
        hr = m_pPreview1->UpdatePreview(SAFECAST(this, IPropertyBag *));
    }

    if (m_pPreview2)
    {
        HRESULT hr2 = m_pPreview2->UpdatePreview(SAFECAST(this, IPropertyBag *));

        if (FAILED(hr)) // return the best error
        {
            hr = hr2;
        }
    }

    if (m_pPreview3)
    {
        HRESULT hr2 = m_pPreview3->UpdatePreview(SAFECAST(this, IPropertyBag *));

        if (FAILED(hr)) // return the best error
        {
            hr = hr2;
        }
    }

    return hr;
}


HRESULT CThemeManager::AddFakeSettingsPage(IN LPVOID pVoid)
{
    if (pVoid)
    {
        ::AddFakeSettingsPage(this, (PROPSHEETHEADER *)pVoid);
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CThemeManager::SetExecMode(IN DWORD dwEM)
{
    _dwEM = dwEM;
    return S_OK;
}

HRESULT CThemeManager::GetExecMode(OUT DWORD* pdwEM)
{
    if (pdwEM)
    {
        *pdwEM = _dwEM;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CThemeManager::LoadMonitorBitmap(IN BOOL fFillDesktop, OUT HBITMAP* phbmMon)
{
    if (phbmMon)
    {
        *phbmMon = ::LoadMonitorBitmap(fFillDesktop);
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CThemeManager::DisplaySaveSettings(IN PVOID pContext, IN HWND hwnd, OUT int* piRet)
{
    if (piRet)
    {
        *piRet = ::DisplaySaveSettings(pContext, hwnd);
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

//===========================
// *** IPreviewSystemMetrics Interface ***
//===========================
HRESULT CThemeManager::RefreshColors(void)
{
    HRESULT hr = S_OK;

    // We should tell the base pages that they should reload the colors.
    // They are welcome to ignore the event if they don't use the system
    // colors.
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
    {
        if (m_pBasePages[nIndex])
        {
            IPreviewSystemMetrics * ppsm;

            hr = m_pBasePages[nIndex]->QueryInterface(IID_PPV_ARG(IPreviewSystemMetrics, &ppsm));
            if (SUCCEEDED(hr))
            {
                hr = ppsm->RefreshColors();
                ppsm->Release();
            }
        }
    }

    return S_OK;
}


HRESULT CThemeManager::UpdateDPIchange(void)
{
    HRESULT hr = S_OK;

    LogStatus("DPI: CALLED asking to SCALE DPI");

    // We should tell the base pages that they should reload the colors.
    // They are welcome to ignore the event if they don't use the system
    // colors.
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
    {
        if (m_pBasePages[nIndex])
        {
            IPreviewSystemMetrics * ppsm;

            hr = m_pBasePages[nIndex]->QueryInterface(IID_PPV_ARG(IPreviewSystemMetrics, &ppsm));
            if (SUCCEEDED(hr))
            {
                hr = ppsm->UpdateDPIchange();
                ppsm->Release();
            }
        }
    }

    return S_OK;
}


HRESULT CThemeManager::UpdateCharsetChanges(void)
{
    // CHARSET: In Win2k, fontfix.cpp was used as a hack to change the CHARSET from one language to another.
    // That doesn't work for many reasons: a) not called on roaming, b) not called for OS lang changes, 
    // c) won't fix the problem for strings with multiple languages, d) etc.
    // Therefore, the SHELL team (BryanSt) had the NTUSER team (MSadek) agree to use DEFAULT_CHARSET all the time.
    // If some app has bad logic testing the charset parameter, then the NTUSER team will shim that app to fix it.
    // The shim would be really simple, on the return from a SystemParametersInfo(SPI_GETNONCLIENTMETRICS or ICONFONTS)
    // just patch the lfCharSet param to the current charset.

    return S_OK;
}


HRESULT CThemeManager::DeskSetCurrentScheme(IN LPCWSTR pwzSchemeName)
{
    HRESULT hr = S_OK;

    // We should tell the base pages that they should reload the colors.
    // They are welcome to ignore the event if they don't use the system
    // colors.
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
    {
        if (m_pBasePages[nIndex])
        {
            IPreviewSystemMetrics * ppsm;

            hr = m_pBasePages[nIndex]->QueryInterface(IID_PPV_ARG(IPreviewSystemMetrics, &ppsm));
            if (SUCCEEDED(hr))
            {
                hr = ppsm->DeskSetCurrentScheme(pwzSchemeName);
                ppsm->Release();
            }
        }
    }

    return S_OK;
}




HRESULT CThemeManager::_GetPropertyBagByCLSID(IN const GUID * pClsid, IN IPropertyBag ** ppPropertyBag)
{
    HRESULT hr = E_INVALIDARG;

    if (pClsid && ppPropertyBag)
    {
        IEnumUnknown * pEnumUnknown;

        hr = GetBasePagesEnum(&pEnumUnknown);
        if (SUCCEEDED(hr))
        {
            IUnknown * punk;

            hr = IEnumUnknown_FindCLSID(pEnumUnknown, *pClsid, &punk);
            if (SUCCEEDED(hr))
            {
                hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, ppPropertyBag));
                punk->Release();
            }

            pEnumUnknown->Release();
        }
    }

    return hr;
}


HRESULT CThemeManager::_SaveCustomValues(void)
{
    HRESULT hr = E_FAIL;

    if (m_pBasePages[0])
    {
        TCHAR szDisplayName[MAX_PATH];

        hr = GetCurrentUserCustomName(szDisplayName, ARRAYSIZE(szDisplayName));
        if (SUCCEEDED(hr))
        {
            IPropertyBag * pPropertyBag = NULL;

            hr = QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                TCHAR szPath[MAX_PATH];

                if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_APPDATA, TRUE))
                {
                    ITheme * pTheme;

                    if (PathAppend(szPath, TEXT("Microsoft\\Windows\\Themes\\Custom.theme")))
                    {
                        hr = SnapShotLiveSettingsToTheme(pPropertyBag, szPath, &pTheme);
                        if (SUCCEEDED(hr))
                        {
                            CComBSTR bstrDisplayName(szDisplayName);

                            hr = pTheme->put_DisplayName(bstrDisplayName);
                            pTheme->Release();
                        }
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }

                pPropertyBag->Release();
            }
        }
    }

    return hr;
}


//===========================
// *** IObjectWithSite Interface ***
//===========================
HRESULT CThemeManager::SetSite(IN IUnknown *punkSite)
{
    if (!punkSite)
    {
        // This is a hint from up the chain that we are shutting down.
        // We need to use this cue to release my children objects so
        // they release me and we don't all leak.
        for (int nIndex = 0; nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
        {
            if (m_pBasePages[nIndex])
            {
                IUnknown_SetSite(m_pBasePages[nIndex], NULL);
            }
        }
    }

    return CObjectWithSite::SetSite(punkSite);
}


//===========================
// *** IPropertyBag Interface ***
//===========================
#define SZ_PROPERTY_ICONHEADER          L"CLSID\\{"

HRESULT CThemeManager::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    // We don't contain any settings our self, but we need to reflect down into our pages to get
    // the correct settings.
    if (pszPropName && pVar)
    {
        IPropertyBag * pPropertyBag = NULL;

        if (!StrCmpIW(pszPropName, SZ_PBPROP_BACKGROUND_PATH) ||
            !StrCmpIW(pszPropName, SZ_PBPROP_BACKGROUNDSRC_PATH) ||
            !StrCmpIW(pszPropName, SZ_PBPROP_BACKGROUND_TILE) ||
            !StrCmpNIW(pszPropName, SZ_PROPERTY_ICONHEADER, ARRAYSIZE(SZ_PROPERTY_ICONHEADER) - 1))
        {
            hr = _GetPropertyBagByCLSID(&PPID_Background, &pPropertyBag);
            if (SUCCEEDED(hr))
            {
                hr = pPropertyBag->Read(pszPropName, pVar, pErrorLog);
            }
        }
        else if (!StrCmpIW(pszPropName, SZ_PBPROP_SCREENSAVER_PATH))
        {
            hr = _GetPropertyBagByCLSID(&PPID_ScreenSaver, &pPropertyBag);
            if (SUCCEEDED(hr))
            {
                hr = pPropertyBag->Read(pszPropName, pVar, pErrorLog);
            }
        }
        else if (!StrCmpIW(pszPropName, SZ_PBPROP_VISUALSTYLE_PATH) ||
                 !StrCmpIW(pszPropName, SZ_PBPROP_VISUALSTYLE_COLOR) ||
                 !StrCmpIW(pszPropName, SZ_PBPROP_VISUALSTYLE_SIZE) ||
                 !StrCmpIW(pszPropName, SZ_PBPROP_SYSTEM_METRICS) ||
                 !StrCmpIW(pszPropName, SZ_PBPROP_BACKGROUND_COLOR) ||
                 !StrCmpIW(pszPropName, SZ_PBPROP_DPI_MODIFIED_VALUE) ||
                 !StrCmpIW(pszPropName, SZ_PBPROP_DPI_APPLIED_VALUE))
        {
            hr = _GetPropertyBagByCLSID(&PPID_BaseAppearance, &pPropertyBag);
            if (SUCCEEDED(hr))
            {
                hr = pPropertyBag->Read(pszPropName, pVar, pErrorLog);
            }
        }
        else if (!StrCmpNIW(pszPropName, SZ_PBPROP_THEME_FILTER, SIZE_THEME_FILTER_STR))
        {
            hr = _GetPropertyBagByCLSID(&PPID_Theme, &pPropertyBag);
            if (SUCCEEDED(hr))
            {
                hr = pPropertyBag->Read(pszPropName, pVar, pErrorLog);
            }
        }

        ATOMICRELEASE(pPropertyBag);
    }

    return hr;
}


HRESULT CThemeManager::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName)
    {
        if (pVar)
        {
            if ((VT_UNKNOWN == pVar->vt))
            {
                if (!StrCmpW(pszPropName, SZ_PBPROP_PREVIEW1))
                {
                    IUnknown_Set((IUnknown **)&m_pPreview1, pVar->punkVal);
                    hr = S_OK;
                }
                else if (!StrCmpW(pszPropName, SZ_PBPROP_PREVIEW2))
                {
                    IUnknown_Set((IUnknown **)&m_pPreview2, pVar->punkVal);
                    hr = S_OK;
                }
                else if (!StrCmpW(pszPropName, SZ_PBPROP_PREVIEW3))
                {
                    IUnknown_Set((IUnknown **)&m_pPreview3, pVar->punkVal);
                    hr = S_OK;
                }
            }
            else if (!StrCmpIW(pszPropName, SZ_PBPROP_CUSTOMIZE_THEME) ||
                     !StrCmpIW(pszPropName, SZ_PBPROP_THEME_LAUNCHTHEME))
            {
                IPropertyBag * pPropertyBag = NULL;

                hr = _GetPropertyBagByCLSID(&PPID_Theme, &pPropertyBag);
                if (SUCCEEDED(hr))
                {
                    hr = pPropertyBag->Write(pszPropName, pVar);
                    pPropertyBag->Release();
                }
            }
            else if (!StrCmpIW(pszPropName, SZ_PBPROP_APPEARANCE_LAUNCHMSTHEME) ||
                     !StrCmpIW(pszPropName, SZ_PBPROP_VISUALSTYLE_PATH) ||
                     !StrCmpIW(pszPropName, SZ_PBPROP_VISUALSTYLE_COLOR) ||
                     !StrCmpIW(pszPropName, SZ_PBPROP_VISUALSTYLE_SIZE) ||
                     !StrCmpIW(pszPropName, SZ_PBPROP_DPI_MODIFIED_VALUE) ||
                     !StrCmpIW(pszPropName, SZ_PBPROP_DPI_APPLIED_VALUE))
            {
                IPropertyBag * pPropertyBag = NULL;

                hr = _GetPropertyBagByCLSID(&PPID_BaseAppearance, &pPropertyBag);
                if (SUCCEEDED(hr))
                {
                    hr = pPropertyBag->Write(pszPropName, pVar);
                    pPropertyBag->Release();
                }
            }
            else if (!StrCmpIW(pszPropName, SZ_PBPROP_BACKGROUND_COLOR))
            {
                IPropertyBag * pPropertyBag = NULL;

                hr = _GetPropertyBagByCLSID(&PPID_BaseAppearance, &pPropertyBag);
                if (SUCCEEDED(hr))
                {
                    hr = pPropertyBag->Write(pszPropName, pVar);
                    pPropertyBag->Release();
                }
            }
            else if (!StrCmpIW(pszPropName, SZ_PBPROP_THEME_SETSELECTION) &&
                (VT_BSTR == pVar->vt))
            {
                hr = _SetSelectedThemeEntree(pVar->bstrVal);
            }
        }
        else
        {
            if (!StrCmpW(pszPropName, SZ_PBPROP_PREOPEN))
            {
                hr = _SaveCustomValues();
            }
        }
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
ULONG CThemeManager::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CThemeManager::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CThemeManager::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CThemeManager, IObjectWithSite),
        QITABENT(CThemeManager, IThemeUIPages),
        QITABENT(CThemeManager, IPropertyBag),
        QITABENT(CThemeManager, IPreviewSystemMetrics),
        QITABENT(CThemeManager, IThemeManager),
        QITABENT(CThemeManager, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


STDMETHODIMP CThemeManager::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid)
{
    HRESULT hr;
    
    if ((cNames > 0) && (0 == StrCmpIW(*rgszNames, L"GetSelectedSchemeProperty")))
    {
        hr = CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); 
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CThemeManager::Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) 
{ 
    HRESULT hr;

    if (dispidMember == DISPIDTHTM_GETSELSCHPROPERTY)
    {
        hr = CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); 
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

//===========================
// *** Class Methods ***
//===========================
CThemeManager::CThemeManager() : CImpIDispatch(LIBID_Theme, 1, 0, IID_IThemeManager), m_cRef(1)
{
    DllAddRef();

    _dwEM = EM_NORMAL;
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pBasePages[0]);
    ASSERT(!m_pPreview1);
    ASSERT(!m_pPreview2);
    ASSERT(!m_pPreview3);
    ASSERT(!m_hdpaThemeDirs);
    ASSERT(!m_hdpaSkinDirs);
    ASSERT(!_pThemeSchemeSelected);
    ASSERT(!m_fForceTimeout);
    ASSERT(!m_cSpiThreads);
    
    SPISetThreadCounter(&m_cSpiThreads);

    _InitComCtl32();
}


int CALLBACK DPALocalFree_Callback(LPVOID p, LPVOID pData)
{
    LocalFree(p);       // NULLs will be ignored.
    return 1;
}


CThemeManager::~CThemeManager()
{
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
    {
        if (m_pBasePages[nIndex])
        {
            IUnknown_SetSite(m_pBasePages[nIndex], NULL);
        }

        ATOMICRELEASE(m_pBasePages[nIndex]);
    }

    if (m_hdpaThemeDirs)
    {
        DPA_DestroyCallback(m_hdpaThemeDirs, DPALocalFree_Callback, NULL);
    }

    if (m_hdpaSkinDirs)
    {
        DPA_DestroyCallback(m_hdpaSkinDirs, DPALocalFree_Callback, NULL);
    }

    Str_SetPtr(&_pszSelectTheme, NULL);

    ATOMICRELEASE(_pThemeSchemeSelected);
    ATOMICRELEASE(m_pPreview1);
    ATOMICRELEASE(m_pPreview2);
    ATOMICRELEASE(m_pPreview3);

    if (m_fForceTimeout)
    {
        LONG lWait = 30 * 1000;
        LONG lEnd = (LONG) GetTickCount() + lWait;
        //  this will wait until all SPICreateThreads() have returned
        while (m_cSpiThreads && lWait > 0)
        {
            DWORD dwReturn = MsgWaitForMultipleObjects(0, NULL, FALSE, lWait, QS_ALLINPUT);
            if (dwReturn == -1 || dwReturn == WAIT_TIMEOUT)
                break;

            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            lWait = lEnd - GetTickCount();
        }
    }
    SPISetThreadCounter(NULL);
    DllRelease();
}


/*****************************************************************************\
    DESCRIPTION:
        When the object is created this way, it's used privately by the Display
    Control Panel.  The CLSID is private so we don't need to worry about external
    components using it this way.
\*****************************************************************************/
HRESULT CThemeUIPages_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    if (punkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    HRESULT hr = E_INVALIDARG;

    if (ppvObj)
    {
        CThemeManager * pObject = new CThemeManager();

        *ppvObj = NULL;
        if (pObject)
        {
            hr = pObject->_Initialize();
            if (SUCCEEDED(hr))
            {
                hr = pObject->QueryInterface(riid, ppvObj);
            }
            else
            {
                IUnknown_SetSite(SAFECAST(pObject, IThemeManager *), NULL);

                // HACK: The display CPL is opening so see if the language changed
                // and the fonts need to be "fixed".
                FixFontsOnLanguageChange();
            }

            pObject->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        External components can create the ThemeManager object this way.  In this
    case we need to add the pages ourselves.
\*****************************************************************************/
HRESULT CThemeManager_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    IThemeUIPages * pThemeUIPages;
    HRESULT hr = CThemeUIPages_CreateInstance(NULL, IID_PPV_ARG(IThemeUIPages, &pThemeUIPages));

    if (SUCCEEDED(hr))
    {
        IBasePropPage * pBasePage;

        hr = CoCreateInstance(CLSID_CDeskHtmlProp, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBasePropPage, &pBasePage));
        if (SUCCEEDED(hr))
        {
            hr = pThemeUIPages->AddBasePage(pBasePage);
            pBasePage->Release();
        }

        if (SUCCEEDED(hr))
        {
            hr = CScreenSaverPage_CreateInstance(NULL, IID_PPV_ARG(IBasePropPage, &pBasePage));
            if (SUCCEEDED(hr))
            {
                hr = pThemeUIPages->AddBasePage(pBasePage);
                pBasePage->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pThemeUIPages->QueryInterface(riid, ppvObj);
        }
        else
        {
            IUnknown_SetSite(pThemeUIPages, NULL);
        }

        pThemeUIPages->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\advappearpg.h ===
/*****************************************************************************\
    FILE: AdvAppearPg.h

    DESCRIPTION:
        This code will display a "Advanced Appearances" tab in the
    "Advanced Display Properties" dialog.

    ??????? ?/??/1993    Created
    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#ifndef _ADVAPPEAR_H
#define _ADVAPPEAR_H


// Public
HRESULT CAdvAppearancePage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog, IN const SYSTEMMETRICSALL * pState);

class CAdvAppearancePage;

typedef struct  {
    HWND    hwndFontName;
    HDC     hdc;
    CAdvAppearancePage * pThis;
}  ENUMFONTPARAM;


#define MAX_CHARSETS    4



//============================================================================================================
// Class
//============================================================================================================
class CAdvAppearancePage        : public CObjectWithSite
                                , public CObjectWindow
                                , public CObjectCLSID
                                , public IAdvancedDialog
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAdvancedDialog ***
    virtual STDMETHODIMP DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply);


    HRESULT Draw(HDC hdc, LPRECT prc, BOOL fOnlyShowActiveWindow, BOOL fRTL);
    int _EnumSizes(LPENUMLOGFONT lpelf, LPNEWTEXTMETRIC lpntm, int Type);

    CAdvAppearancePage(IN const SYSTEMMETRICSALL * pState);
    virtual ~CAdvAppearancePage(void);

private:
    // Private Member Variables
    long                    m_cRef;

    // Members for State
    BOOL                    m_fDirty;
    DWORD                   m_dwChanged;                        // These are the categories of state that are dirty. (SCHEME_CHANGE, DPI_CHANGE, COLOR_CHANGE, METRIC_CHANGE)

    // Members for UI Controls
    int                     m_iCurElement;                      // start off as not even "not set"
    LOOK_SIZE               m_elCurrentSize;                    // this one kept separately for range purposes
    int                     m_iPrevSize;

    BOOL                    m_bPalette;                         // is this a palette device?
    BOOL                    m_fInUserEditMode;                  // Are refreshes coming from the user edits?
    BOOL                    m_fProprtySheetExiting;             // See _PropagateMessage for description

    int                     m_nCachedNewDPI;                    // Cached DPI for scaling
    int                     m_i3DShadowAdj;
    int                     m_i3DHilightAdj;
    int                     m_iWatermarkAdj;
    BOOL                    m_fScale3DShadowAdj;
    BOOL                    m_fScale3DHilightAdj;
    BOOL                    m_fScaleWatermarkAdj;
    BOOL                    m_fModifiedScheme;

    int                     m_cyBorderSM;                       // Cached SystemMetrics
    int                     m_cxBorderSM;                       // Cached SystemMetrics
    int                     m_cxEdgeSM;                         // Cached SystemMetrics
    int                     m_cyEdgeSM;                         // Cached SystemMetrics
    float                   m_fCaptionRatio;                    // Save the ratio

    LOOK_SIZE               m_sizes[NUM_SIZES];                 // These are the sizes
    LOOK_FONT               m_fonts[NUM_FONTS];                 // These are the fonts installed that the user can choose from.
    COLORREF                m_rgb[COLOR_MAX];                   // These are the colors the user can choose from.
    HBRUSH                  m_brushes[COLOR_MAX];               // These are created from m_rgb and used when painting the UI.
    HPALETTE                m_hpal3D;                           // only exist if palette device
    HPALETTE                m_hpalVGA;                          // only exist if palette device

    HBRUSH                  m_hbrMainColor;
    HBRUSH                  m_hbrTextColor;
    HBRUSH                  m_hbrGradientColor;

    HTHEME                  m_hTheme;                           // theme the ownerdrawn color picker button

    // The following array will hold the "unique" Charsets corresponding to System Locale, 
    // User Locale, System UI lang and User UI Lang. Note: Only unique charsets are kept
    // here. So, the variable g_iCountCharsets contains the number of valid items in this array.
    UINT    m_uiUniqueCharsets[MAX_CHARSETS];
    int     m_iCountCharsets; // number of charsets stored in m_uiUniqueCharsets.  Minimum value is 1; Maximum is 4

    // Private Member Functions
    // Init/Destroy/State functions
    INT_PTR _AdvAppearDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    INT_PTR _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnDestroy(HWND hDlg);
    HRESULT _OnSetActive(HWND hDlg);
    HRESULT _OnApply(HWND hDlg, LPARAM lParam);
    HRESULT _OnInitAdvAppearanceDlg(HWND hDlg);
    HRESULT _InitSysStuff(void);
    HRESULT _InitColorAndPalette(void);
    HRESULT _LoadState(IN const SYSTEMMETRICSALL * pState);
    HRESULT _IsDirty(IN BOOL * pIsDirty);

    // On User Action
    HRESULT _OnFontNameChanged(HWND hDlg);
    HRESULT _OnSizeChange(HWND hDlg, WORD wEvent);
    void _SelectName(HWND hDlg, int iSel);

    HRESULT _InitFonts(void);
    HRESULT _FreeFonts(void);

    // Classic Look_ functions
    HRESULT _SelectElement(HWND hDlg, int iElement, DWORD dwFlags);
    COLORREF _NearestColor(int iColor, COLORREF rgb);
    int _EnumFontNames(LPENUMLOGFONTEX lpelf, LPNEWTEXTMETRIC lpntm, DWORD Type, ENUMFONTPARAM * pEnumFontParam);
    BOOL _ChangeColor(HWND hDlg, int iColor, COLORREF rgb);
    void _Recalc(LPRECT prc);
    void _Repaint(HWND hDlg, BOOL bRecalc);
    void _RebuildCurFont(HWND hDlg);
    void _ChangeFontSize(HWND hDlg, int Points);
    void _ChangeFontBI(HWND hDlg, int id, BOOL bCheck);
    void _ChangeFontName(HWND hDlg, LPCTSTR szBuf, INT iCharSet);
    void _ChangeSize(HWND hDlg, int NewSize, BOOL bRepaint);
    void _PickAColor(HWND hDlg, int CtlID);
    void _DrawPreview(HDC hdc, LPRECT prc, BOOL fOnlyShowActiveWindow, BOOL fShowBack);
    void _DrawButton(HWND hDlg, LPDRAWITEMSTRUCT lpdis);
    void _RebuildSysStuff(BOOL fInit);
    void _Set3DPaletteColor(COLORREF rgb, int iColor);
    void _InitUniqueCharsetArray(void);
    void _DestroySysStuff(void);
    void _InitFontList(HWND hDlg);
    void _NewFont(HWND hDlg, int iFont);
    void _SetColor(HWND hDlg, int id, HBRUSH hbrColor);
    void _DrawDownArrow(HDC hdc, LPRECT lprc, BOOL bDisabled);
    void _SetCurSizeAndRange(HWND hDlg);
    void _DoSizeStuff(HWND hDlg, BOOL fCanSuggest);
    void _UpdateSizeBasedOnFont(HWND hDlg, BOOL fComputeIdeal);
    void _SyncSize(HWND hDlg);
    void _Changed(HWND hDlg, DWORD dwChange);
    void _SetSysStuff(UINT nChanged);
    void _GetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm);
    void _SetMyNonClientMetrics(const LPNONCLIENTMETRICS lpncm);
    void _UpdateGradientButton(HWND hDlg);
    void _PropagateMessage(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

    int _PointToHeight(int Points);
    int _HeightToPoint(int Height);

    static INT_PTR CALLBACK AdvAppearDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend int CALLBACK Font_EnumNames(LPENUMLOGFONTEX lpelf, LPNEWTEXTMETRIC lpntm, DWORD dwType, LPARAM lData);

    // Preview Methods
    // Classic LookPrev_ functions
    void _RepaintPreview(HWND hwnd);
    void _MyDrawBorderBelow(HDC hdc, LPRECT prc);
    void _ShowBitmap(HWND hWnd, HDC hdc);
    HRESULT _OnReCreateBitmap(HWND hWnd);
    HRESULT _OnButtonDownOrDblClick(HWND hWnd, int nCoordX, int nCoordY);
    HRESULT _OnCreatePreviewSMDlg(LPRECT prc, BOOL fRTL);
    HRESULT _OnNCCreate(HWND hWnd);
    HRESULT _OnDestroyPreview(HWND hWnd);
    HRESULT _OnPaintPreview(HWND hWnd);
    void _InitPreview(LPRECT prc, BOOL fRTL);

    LRESULT _PreviewSystemMetricsWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK PreviewSystemMetricsWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend BOOL RegisterPreviewSystemMetricClass(HINSTANCE hInst);
};


extern CAdvAppearancePage * g_pAdvAppearancePage;




// Shared between AdvAppearPg & BaseAppearPage

extern BOOL g_fProprtySheetExiting;


// a new element has been chosen.
//
// iElement - index into g_elements of the chosen one
// bSetCur - if TRUE, need to find element in elements combobox, too
#define LSE_NONE   0x0000
#define LSE_SETCUR 0x0001
#define LSE_ALWAYS 0x0002

#define EnableApplyButton(hdlg) PropSheet_Changed(GetParent(hdlg), hdlg)

#endif // _ADVAPPEAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\appscheme.cpp ===
/*****************************************************************************\
    FILE: appScheme.cpp

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "theme.h"
#include "appstyle.h"
#include "appscheme.h"



//===========================
// *** Class Internals & Helpers ***
//===========================

APPEARANCESCHEME_UPGRADE_MAPPINGS g_UpgradeMapping[MAX_LEGACY_UPGRADE_SCENARIOS] = {0};


HRESULT LoadConversionMappings(void)
{
    if (0 == g_UpgradeMapping[0].szLegacyName[0])   // Only set the settings if it's the first time.
    {
        // This is custom user created scheme.
        TCHAR szTempState[10];

        for (int nIndex = 0; nIndex < ARRAYSIZE(g_UpgradeMapping); nIndex++)
        {
            LoadString(HINST_THISDLL, IDS_LEGACYSCHEME_NAME + nIndex, g_UpgradeMapping[nIndex].szLegacyName, ARRAYSIZE(g_UpgradeMapping[nIndex].szLegacyName));
            LoadString(HINST_THISDLL, IDS_LOCALIZATIONPOINTER + nIndex, g_UpgradeMapping[nIndex].szNewColorSchemeName, ARRAYSIZE(g_UpgradeMapping[nIndex].szNewColorSchemeName));
            LoadString(HINST_THISDLL, IDS_NEWSIZE_NAME + nIndex, g_UpgradeMapping[nIndex].szNewSizeName, ARRAYSIZE(g_UpgradeMapping[nIndex].szNewSizeName));
            LoadString(HINST_THISDLL, IDS_NEWCONTRASTFLAGS + nIndex, szTempState, ARRAYSIZE(szTempState));

            g_UpgradeMapping[nIndex].ContrastLevel = (enumThemeContrastLevels) StrToInt(szTempState);
        }
    }

    return S_OK;
}


HRESULT MapLegacyAppearanceSchemeToIndex(LPCTSTR pszOldSchemeName, int * pnIndex)
{
    HRESULT hr = E_FAIL;        // Failure means, FALSE, we didn't convert.

    *pnIndex = 0;
    for (int nIndex = 0; nIndex < ARRAYSIZE(g_UpgradeMapping); nIndex++)
    {
        // Did we find that pszSchemeName is one of the legacy settings?
        if (!StrCmpI(pszOldSchemeName, g_UpgradeMapping[nIndex].szLegacyName))
        {
            hr = S_OK;
            *pnIndex = nIndex;
            break;
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::_IsLegacyUpgradeConvert(LPCTSTR pszSchemeName, SYSTEMMETRICSALL * pState, IN BOOL fSetAsDefault)
{
    int nIndex = 0;
    HRESULT hr = MapLegacyAppearanceSchemeToIndex(pszSchemeName, &nIndex);

    if (SUCCEEDED(hr))
    {
        hr = _ConvertScheme(pszSchemeName, g_UpgradeMapping[nIndex].szNewColorSchemeName, g_UpgradeMapping[nIndex].szNewSizeName, pState, g_UpgradeMapping[nIndex].ContrastLevel, fSetAsDefault, FALSE);
    }

    return hr;
}


HRESULT CAppearanceScheme::_CustomConvert(LPCTSTR pszSchemeName, SYSTEMMETRICSALL * pState, IN BOOL fSetAsDefault, IN BOOL fSetRegKeyTitle)
{
    // This is custom user created scheme.
    TCHAR szSizeName[MAX_PATH];

    LoadString(HINST_THISDLL, IDS_SIZE_NORMAL, szSizeName, ARRAYSIZE(szSizeName));
    return _ConvertScheme(pszSchemeName, pszSchemeName, szSizeName, pState, CONTRAST_NORMAL, fSetAsDefault, fSetRegKeyTitle);
}


HRESULT CAppearanceScheme::_getSizeIndex(IN IThemeStyle * pThemeStyle, IN IThemeSize * pThemeSize, IN BSTR bstrSizeDisplayName, IN long * pnSizeIndex)
{
    // This is horrible from a perf perspective, but we only do it once on upgrade.
    long nCount;
    HRESULT hr = E_FAIL;

    *pnSizeIndex = 0;
    if (SUCCEEDED(pThemeStyle->get_length(&nCount)))
    {
        IThemeSize * pThemeSize2;

        for (long nIndex = 0; nIndex < nCount; nIndex++)
        {
            VARIANT var;
            
            var.vt = VT_I4;
            var.lVal = nIndex;
            if (SUCCEEDED(pThemeStyle->get_item(var, &pThemeSize2)))
            {
                CComBSTR bstrSize2;

                if (SUCCEEDED(pThemeSize2->get_DisplayName(&bstrSize2)))
                {
                    CComBSTR bstrName;

                    if (!StrCmpIW(bstrSizeDisplayName, bstrSize2) ||
                        (SUCCEEDED(pThemeSize2->get_Name(&bstrName)) &&
                        !StrCmpIW(bstrSizeDisplayName, bstrName)))
                    {
                        hr = S_OK;
                        *pnSizeIndex = nIndex;
                        nIndex = nCount;        // End looping now.
                    }
                }

                pThemeSize2->Release();
            }
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::_getIndex(IN IThemeStyle * pThemeStyle, IN BSTR bstrStyleDisplayName, IN long * pnStyleIndex, IN IThemeSize * pThemeSize, IN BSTR bstrSizeDisplayName, IN long * pnSizeIndex)
{
    // This is horrible from a perf perspective, but we only do it once on upgrade.
    long nCount;
    HRESULT hr = E_FAIL;

    *pnStyleIndex = 0;
    *pnSizeIndex = 0;
    if (SUCCEEDED(get_length(&nCount)))
    {
        IThemeStyle * pThemeStyle2;

        for (long nIndex = 0; nIndex < nCount; nIndex++)
        {
            VARIANT var;
            
            var.vt = VT_I4;
            var.lVal = nIndex;
            if (SUCCEEDED(get_item(var, &pThemeStyle2)))
            {
                CComBSTR bstrStyle2;

                if (SUCCEEDED(pThemeStyle2->get_DisplayName(&bstrStyle2)))
                {
                    CComBSTR bstrName;

                    if (!StrCmpIW(bstrStyleDisplayName, bstrStyle2) ||
                        (SUCCEEDED(pThemeStyle2->get_Name(&bstrName)) &&
                        !StrCmpIW(bstrStyleDisplayName, bstrName)))
                    {
                        *pnStyleIndex = nIndex;
                        hr = _getSizeIndex(pThemeStyle, pThemeSize, bstrSizeDisplayName, pnSizeIndex);
                        nIndex = nCount;        // End the search.
                    }
                }

                pThemeStyle2->Release();
            }
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::_ConvertScheme(LPCTSTR pszLegacyName,        // This is the Legacy Name
                                          LPCTSTR pszStyleName, LPCTSTR pszSizeName, SYSTEMMETRICSALL * pState,
                                          IN enumThemeContrastLevels ContrastLevel, IN BOOL fSetAsDefault, IN BOOL fSetRegKeyTitle)
{
    // This is custom user created scheme.
    IThemeStyle * pThemeStyle;
    CComVariant varDisplayNameBSTR(pszStyleName);
    HRESULT hr = get_item(varDisplayNameBSTR, &pThemeStyle);

    if (FAILED(hr))
    {
        // If it doesn't exist, create one.
        hr = _AddStyle((fSetRegKeyTitle ? pszStyleName : NULL), &pThemeStyle);
    }

    if (SUCCEEDED(hr))
    {
        CComBSTR bstrStyleDisplayName(pszStyleName);

        hr = pThemeStyle->put_DisplayName(bstrStyleDisplayName);
        if (SUCCEEDED(hr))
        {
            IThemeSize * pThemeSize;

            hr = pThemeStyle->AddSize(&pThemeSize);
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrSizeDisplayName(pszSizeName);

                hr = pThemeSize->put_DisplayName(bstrSizeDisplayName);
                if (SUCCEEDED(hr))
                {
                    hr = SystemMetricsAll_Save(pState, pThemeSize, FALSE);

                    if (SUCCEEDED(hr))
                    {
                        // Set the contrast level.
                        hr = pThemeSize->put_ContrastLevel(ContrastLevel);
                        if (SUCCEEDED(hr))
                        {
                            IPropertyBag * pPropertyBag;

                            hr = pThemeSize->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
                            if (SUCCEEDED(hr))
                            {
                                hr = SHPropertyBag_WriteStr(pPropertyBag, SZ_PBPROP_COLORSCHEME_LEGACYNAME, pszLegacyName);
                                pPropertyBag->Release();
                            }
                        }
                    }
                }

                if (fSetAsDefault && SUCCEEDED(hr))
                {
                    long nStyleIndex;
                    long nSizeIndex;

                    hr = _getIndex(pThemeStyle, bstrStyleDisplayName, &nStyleIndex, pThemeSize, bstrSizeDisplayName, &nSizeIndex);
                    if (SUCCEEDED(hr))
                    {
                        TCHAR szData[10];

                        StringCchPrintf(szData, ARRAYSIZE(szData), TEXT("%d"), nStyleIndex);

                        DWORD cbSize = ((lstrlen(szData) + 1) * sizeof(szData[0]));
                        hr = HrSHSetValue(m_hKeyScheme, NULL, SZ_REGVALUE_SELECTEDSTYLE, REG_SZ, (LPVOID) szData, cbSize);
                        if (SUCCEEDED(hr))
                        {
                            TCHAR szData2[10];

                            StringCchPrintf(szData2, ARRAYSIZE(szData2), TEXT("%d"), nSizeIndex);
                            DWORD cbSize = ((lstrlen(szData2) + 1) * sizeof(szData2[0]));
                            hr = HrSHSetValue(m_hKeyScheme, szData, SZ_REGVALUE_SELECTEDSIZE, REG_SZ, (LPVOID) szData2, cbSize);
                        }
                    }
                }

                pThemeSize->Release();
            }
        }

        pThemeStyle->Release();
    }

    return hr;
}


HRESULT LoadCurrentStyle(LPTSTR pszCurrentStyle, int cchSize)
{
    HKEY hkey;
    HRESULT hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_APPEARANCE, 0, KEY_READ, &hkey);

    if (SUCCEEDED(hr))
    {
        DWORD dwSize = (DWORD)(cchSize * sizeof(pszCurrentStyle[0]));

        hr = HrRegQueryValueEx(hkey, REGSTR_KEY_CURRENT, NULL, NULL, (LPBYTE)pszCurrentStyle, &dwSize);
        RegCloseKey(hkey);
    }

    return hr;
}


// This function will do nothing if an upgrade isn't needed.
HRESULT CAppearanceScheme::_InitReg(void)
{
    HRESULT hr = S_OK;

    if (!m_hKeyScheme)
    {
        hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, SZ_APPEARANCE_NEWSCHEMES, 0, (KEY_WRITE | KEY_READ),  &m_hKeyScheme);
        if (FAILED(hr))
        {
            // Here is where we need to do the upgrade.
            hr = HrRegCreateKeyEx(HKEY_CURRENT_USER, SZ_APPEARANCE_NEWSCHEMES, 0, NULL, REG_OPTION_NON_VOLATILE, 
                        (KEY_WRITE | KEY_READ), NULL, &m_hKeyScheme, 0);
            if (SUCCEEDED(hr))
            {
                HKEY hKeyOld;

                hr = HrRegCreateKeyEx(HKEY_CURRENT_USER, SZ_APPEARANCE_SCHEMES, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ, NULL, &hKeyOld, 0);
                if (SUCCEEDED(hr))
                {
                    TCHAR szCurrentStyle[MAX_PATH];
                    TCHAR szSchemeName[MAX_PATH];
                    TCHAR szDefaultScheme[MAX_PATH];
                    DWORD dwIndex = 0;

                    // Load in the upgrade mappings.
                    hr = LoadConversionMappings();

                    LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szDefaultScheme, ARRAYSIZE(szDefaultScheme));
                    hr = LoadCurrentStyle(szCurrentStyle, ARRAYSIZE(szCurrentStyle));
                    if (FAILED(hr))
                    {
                        // This will fail if the user never changed the legacy "Appearance Scheme".
                        LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szCurrentStyle, ARRAYSIZE(szCurrentStyle));
                        hr = S_OK;
                    }

                    // Now let's walk thru each one and convert it.
                    while (SUCCEEDED(hr))
                    {
                        DWORD dwType;
                        DWORD cchSize = ARRAYSIZE(szSchemeName);

                        hr = HrRegEnumValue(hKeyOld, dwIndex, szSchemeName, &cchSize, NULL, &dwType, NULL, NULL);
                        if (SUCCEEDED(hr) && (REG_BINARY == dwType))
                        {
                            BOOL fSetAsDefault = !StrCmpI(szCurrentStyle, szSchemeName);
                            SYSTEMMETRICSALL state = {0};

                            hr = Look_GetSchemeData(hKeyOld, szSchemeName, &state.schemeData);
                            if (SUCCEEDED(hr))
                            {
                                state.schemeData.rgb[COLOR_MENUBAR] = state.schemeData.rgb[COLOR_MENU];
                                state.schemeData.rgb[COLOR_MENUHILIGHT] = state.schemeData.rgb[COLOR_HIGHLIGHT];
                                // See if this is one of the shipping Appearance Schemes, so we want to create it
                                // special.
                                hr = _IsLegacyUpgradeConvert(szSchemeName, &state, fSetAsDefault);
                                if (FAILED(hr))
                                {
                                    // No, so we will upgrade it as a custom item.
                                    hr = _CustomConvert(szSchemeName, &state, fSetAsDefault, FALSE);
                                }

                                // On Upgrade, we need to copy "Windows Standard" to "Current Settings SaveNoVisualStyle".
                                // That way, when the user toggles from "Professional VS" to "Windows Classic VS", we
                                // load those colors as the first alternative to visual styles off.  Win #151831
                                if (!StrCmpI(szDefaultScheme, szSchemeName))
                                {
                                    hr = _CustomConvert(SZ_SAVEGROUP_NOSKIN_TITLE, &state, FALSE, TRUE);
                                }
                            }
                        }

                        dwIndex++;
                    }

                    hr = S_OK;
                    RegCloseKey(hKeyOld);
                }
            }
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::_getStyleByIndex(IN long nIndex, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = _InitReg();

    if (SUCCEEDED(hr))
    {
        HKEY hKeyStyle;
        TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];

        StringCchPrintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%d"), nIndex);

        hr = HrRegOpenKeyEx(m_hKeyScheme, szKeyName, 0, (KEY_WRITE | KEY_READ), &hKeyStyle);
        if (SUCCEEDED(hr))
        {
            hr = CAppearanceStyle_CreateInstance(hKeyStyle, ppThemeStyle);  // This function takes ownership of hKey
            if (FAILED(hr))
            {
                RegCloseKey(hKeyStyle);
            }
        }
    }
 
    return hr;
}


HRESULT CAppearanceScheme::_getCurrentSettings(IN LPCWSTR pszSettings, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = _InitReg();

    if (SUCCEEDED(hr))
    {
        WCHAR szRegValue[MAXIMUM_VALUE_NAME_LENGTH];
        HKEY hKeyStyle;

        StringCchCopy(szRegValue, ARRAYSIZE(szRegValue), SZ_REGVALUE_CURRENT_SETTINGS);
        StringCchCat(szRegValue, ARRAYSIZE(szRegValue), &pszSettings[2]);

        hr = HrRegCreateKeyEx(m_hKeyScheme, szRegValue, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &hKeyStyle, NULL);
        if (SUCCEEDED(hr))
        {
            hr = CAppearanceStyle_CreateInstance(hKeyStyle, ppThemeStyle);  // This function takes ownership of hKey
            if (FAILED(hr))
            {
                RegCloseKey(hKeyStyle);
            }
        }
    }
 
    return hr;
}






//===========================
// *** ITheme Interface ***
//===========================
HRESULT CAppearanceScheme::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    WCHAR szDisplayName[MAX_PATH];

    LoadString(HINST_THISDLL, IDS_NO_SKIN_DISPLAYNAME, szDisplayName, ARRAYSIZE(szDisplayName));
    return HrSysAllocStringW(szDisplayName, pbstrDisplayName);
}


HRESULT CAppearanceScheme::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pnLength)
    {
        *pnLength = 0;
        hr = _InitReg();
        if (SUCCEEDED(hr))
        {
            DWORD dwValues = 0;

            hr = HrRegQueryInfoKey(m_hKeyScheme, NULL, NULL, NULL, &dwValues, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                HKEY hKeyTemp;

                if (SUCCEEDED(HrRegOpenKeyEx(m_hKeyScheme, SZ_REGVALUE_CURRENT_SETTINGS, 0, KEY_READ, &hKeyTemp)))
                {
                    dwValues--; // We want to subtract one for the "Current Settings" key.
                    RegCloseKey(hKeyTemp);
                }
            }

            *pnLength = (long) dwValues;
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::get_item(IN VARIANT varIndex, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        long nCount = 0;

        get_length(&nCount);
        *ppThemeStyle = NULL;

        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
            varIndex = *(varIndex.pvarVal);

        switch (varIndex.vt)
        {
        case VT_I2:
            varIndex.lVal = (long)varIndex.iVal;
            // And fall through...

        case VT_I4:
        if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount))
        {
            hr = _getStyleByIndex(varIndex.lVal, ppThemeStyle);
        }
        break;
        case VT_BSTR:
        if (varIndex.bstrVal)
        {
            if ((L':' == varIndex.bstrVal[0]) && (L':' == varIndex.bstrVal[1]))
            {
                // This is a "Custom" settings so look in that key.
                hr = _getCurrentSettings(varIndex.bstrVal, ppThemeStyle);
            }
            else
            {
                for (int nIndex = 0; FAILED(hr) && (nIndex < nCount); nIndex++)
                {
                    IThemeStyle * pThemeStyle;

                    if (SUCCEEDED(_getStyleByIndex(nIndex, &pThemeStyle)))
                    {
                        CComBSTR bstrDisplayName;

                        if (SUCCEEDED(pThemeStyle->get_DisplayName(&bstrDisplayName)))
                        {
                            if (!StrCmpIW(bstrDisplayName, varIndex.bstrVal))
                            {
                                // They match, so this is the one.
                                *ppThemeStyle = pThemeStyle;
                                pThemeStyle = NULL;
                                hr = S_OK;
                            }
                        }

                        if (FAILED(hr))
                        {
                            if (bstrDisplayName)
                            {
                                bstrDisplayName.Empty();
                            }

                            if (SUCCEEDED(pThemeStyle->get_Name(&bstrDisplayName)))
                            {
                                if (!StrCmpIW(bstrDisplayName, varIndex.bstrVal))
                                {
                                    // They match, so this is the one.
                                    *ppThemeStyle = pThemeStyle;
                                    pThemeStyle = NULL;
                                    hr = S_OK;
                                }
                            }
                        }

                        ATOMICRELEASE(pThemeStyle);
                    }
                }
            }
        }
        break;

        default:
            hr = E_NOTIMPL;
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::get_SelectedStyle(OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        hr = _InitReg();
        if (SUCCEEDED(hr))
        {
            TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];
            DWORD cbSize = sizeof(szKeyName);

            *ppThemeStyle = NULL;
            hr = HrSHGetValue(m_hKeyScheme, NULL, SZ_REGVALUE_SELECTEDSTYLE, NULL, szKeyName, &cbSize);
            if (FAILED(hr))
            {
                // "21" is the Appearance Scheme of "Windows Classic".
                StringCchCopy(szKeyName, ARRAYSIZE(szKeyName), TEXT("21"));
                hr = S_OK;
            }

            if (SUCCEEDED(hr))
            {
                HKEY hKeyStyle;

                // Let's find the next empty slot
                hr = HrRegOpenKeyEx(m_hKeyScheme, szKeyName, 0, (KEY_WRITE | KEY_READ), &hKeyStyle);
                if (SUCCEEDED(hr))
                {
                    hr = CAppearanceStyle_CreateInstance(hKeyStyle, ppThemeStyle);  // This function takes ownership of hKeyStyle
                    if (FAILED(hr))
                    {
                        RegCloseKey(hKeyStyle);
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::put_SelectedStyle(IN IThemeStyle * pThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (pThemeStyle)
    {
        hr = _InitReg();
        if (SUCCEEDED(hr))
        {
            TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];
            CComBSTR bstrDisplayNameSource;

            hr = pThemeStyle->get_DisplayName(&bstrDisplayNameSource);
            if (SUCCEEDED(hr))
            {
                for (int nIndex = 0; SUCCEEDED(hr); nIndex++)
                {
                    IThemeStyle * pThemeStyleInList;

                    hr = _getStyleByIndex(nIndex, &pThemeStyleInList);
                    if (SUCCEEDED(hr))
                    {
                        CComBSTR bstrDisplayName;

                        hr = pThemeStyleInList->get_DisplayName(&bstrDisplayName);
                        ATOMICRELEASE(pThemeStyleInList);
                        if (SUCCEEDED(hr))
                        {
                            if (!StrCmpIW(bstrDisplayName, bstrDisplayNameSource))
                            {
                                // They match, so this is the one.
                                StringCchPrintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%d"), nIndex);
                                break;
                            }
                        }
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                DWORD cbSize = ((lstrlen(szKeyName) + 1) * sizeof(szKeyName[0]));

                hr = HrSHSetValue(m_hKeyScheme, NULL, SZ_REGVALUE_SELECTEDSTYLE, REG_SZ, szKeyName, cbSize);
            }
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::_AddStyle(IN LPCWSTR pszTitle, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        *ppThemeStyle = NULL;

        hr = _InitReg();
        if (SUCCEEDED(hr))
        {
            if (pszTitle)
            {
                HKEY hKeyStyle;

                hr = HrRegCreateKeyEx(m_hKeyScheme, pszTitle, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &hKeyStyle, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = CAppearanceStyle_CreateInstance(hKeyStyle, ppThemeStyle);  // This function takes ownership of hKey
                    if (FAILED(hr))
                    {
                        RegCloseKey(hKeyStyle);
                    }
                }
            }
            else
            {
                // Find an empty Scheme Name.
                for (int nIndex = 0; nIndex < 10000; nIndex++)
                {
                    HKEY hKeyStyle;
                    TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];

                    StringCchPrintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%d"), nIndex);

                    // Let's find the next empty spot
                    hr = HrRegOpenKeyEx(m_hKeyScheme, szKeyName, 0, KEY_READ, &hKeyStyle);
                    if (SUCCEEDED(hr))
                    {
                        RegCloseKey(hKeyStyle);
                    }
                    else
                    {
                        hr = HrRegCreateKeyEx(m_hKeyScheme, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &hKeyStyle, NULL);
                        if (SUCCEEDED(hr))
                        {
                            hr = CAppearanceStyle_CreateInstance(hKeyStyle, ppThemeStyle);  // This function takes ownership of hKey
                            if (FAILED(hr))
                            {
                                RegCloseKey(hKeyStyle);
                            }
                        }

                        break;
                    }
                }
            }
        }
    }

    return hr;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CAppearanceScheme::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CAppearanceScheme::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CAppearanceScheme::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAppearanceScheme, IPersist),
        QITABENT(CAppearanceScheme, IThemeScheme),
        QITABENT(CAppearanceScheme, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CAppearanceScheme::CAppearanceScheme(void) : CObjectCLSID(&CLSID_LegacyAppearanceScheme), m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hKeyScheme);
}


CAppearanceScheme::~CAppearanceScheme()
{
    if (m_hKeyScheme)
    {
        RegCloseKey(m_hKeyScheme);
    }

    DllRelease();
}



HRESULT CAppearanceScheme_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (punkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    if (ppvObj)
    {
        CAppearanceScheme * pObject = new CAppearanceScheme();

        *ppvObj = NULL;
        if (pObject)
        {
            hr = pObject->QueryInterface(riid, ppvObj);
            pObject->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\appstyle.h ===
/*****************************************************************************\
    FILE: appStyle.h

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_APPSTYLE
#define _FILE_H_APPSTYLE

#include <cowsite.h>
#include <atlbase.h>



HRESULT CAppearanceStyle_CreateInstance(IN HKEY hkeyStyle, OUT IThemeStyle ** ppThemeStyle);


class CAppearanceStyle          : public IThemeStyle
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeStyle ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName);
    virtual STDMETHODIMP get_Name(OUT BSTR * pbstrName);
    virtual STDMETHODIMP put_Name(IN BSTR bstrName);
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT IThemeSize ** ppThemeSize);
    virtual STDMETHODIMP get_SelectedSize(OUT IThemeSize ** ppThemeSize);
    virtual STDMETHODIMP put_SelectedSize(IN IThemeSize * pThemeSize);
    virtual STDMETHODIMP AddSize(OUT IThemeSize ** ppThemeSize);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return E_ACCESSDENIED; }

private:
    CAppearanceStyle(IN HKEY hkeyStyle);
    virtual ~CAppearanceStyle(void);


    // Private Member Variables
    long                    m_cRef;

    HKEY                    m_hKeyStyle;


    // Private Member Functions
    HRESULT _getSizeByIndex(IN long nIndex, OUT IThemeSize ** ppThemeSize);

    // Friend Functions
    friend HRESULT CAppearanceStyle_CreateInstance(IN HKEY hkeyStyle, OUT IThemeStyle ** ppThemeStyle);
};


#endif // _FILE_H_APPSTYLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\appsize.cpp ===
/*****************************************************************************\
    FILE: appSize.cpp

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "theme.h"
#include "appsize.h"




//===========================
// *** Class Internals & Helpers ***
//===========================


//===========================
// *** IThemeSize Interface ***
//===========================
HRESULT CAppearanceSize::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrDisplayName)
    {
        CComBSTR bstrDisplayName;

        *pbstrDisplayName = NULL;
        hr = HrBStrRegQueryValue(m_hkeySize, SZ_REGVALUE_DISPLAYNAME, &bstrDisplayName);
        if (SUCCEEDED(hr))
        {
            WCHAR szDisplayName[MAX_PATH];
            if (SUCCEEDED(SHLoadIndirectString(bstrDisplayName, szDisplayName, ARRAYSIZE(szDisplayName), NULL)))
            {
                hr = HrSysAllocStringW(szDisplayName, pbstrDisplayName);
            }
            else
            {
                hr = HrSysAllocStringW(bstrDisplayName, pbstrDisplayName);
            }
        }
    }


    return hr;
}


HRESULT CAppearanceSize::put_DisplayName(IN BSTR bstrDisplayName)
{
    return HrRegSetValueString(m_hkeySize, NULL, SZ_REGVALUE_DISPLAYNAME, bstrDisplayName);
}


HRESULT CAppearanceSize::get_Name(OUT BSTR * pbstrName)
{
    return HrBStrRegQueryValue(m_hkeySize, SZ_REGVALUE_DISPLAYNAME, pbstrName);
}


HRESULT CAppearanceSize::put_Name(IN BSTR bstrName)
{
    return HrRegSetValueString(m_hkeySize, NULL, SZ_REGVALUE_DISPLAYNAME, bstrName);
}


HRESULT CAppearanceSize::get_SystemMetricColor(IN int nSysColorIndex, OUT COLORREF * pColorRef)
{
    HRESULT hr = E_INVALIDARG;

    if (pColorRef)
    {
        TCHAR szFontRegValue[MAXIMUM_SUB_KEY_LENGTH];
        DWORD dwType;
        DWORD cbSize = sizeof(*pColorRef);

        StringCchPrintf(szFontRegValue, ARRAYSIZE(szFontRegValue), TEXT("Color #%d"), nSysColorIndex);
        hr = HrRegQueryValueEx(m_hkeySize, szFontRegValue, 0, &dwType, (BYTE *)pColorRef, &cbSize);
        if (SUCCEEDED(hr))
        {
            if (cbSize != sizeof(*pColorRef))
            {
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


HRESULT CAppearanceSize::put_SystemMetricColor(IN int nSysColorIndex, IN COLORREF ColorRef)
{
    HRESULT hr = E_INVALIDARG;

    TCHAR szFontRegValue[MAXIMUM_SUB_KEY_LENGTH];

    StringCchPrintf(szFontRegValue, ARRAYSIZE(szFontRegValue), TEXT("Color #%d"), nSysColorIndex);
    hr = HrRegSetValueEx(m_hkeySize, szFontRegValue, 0, REG_DWORD, (BYTE *)&ColorRef, sizeof(ColorRef));

    return hr;
}


HRESULT CAppearanceSize::GetSystemMetricFont(IN enumSystemMetricFont nFontIndex, IN LOGFONTW * pLogFontW)
{
    HRESULT hr = E_INVALIDARG;

    if (pLogFontW)
    {
        TCHAR szFontRegValue[MAXIMUM_SUB_KEY_LENGTH];
        DWORD dwType;
        DWORD cbSize = sizeof(*pLogFontW);

        StringCchPrintf(szFontRegValue, ARRAYSIZE(szFontRegValue), TEXT("Font #%d"), nFontIndex);
        hr = HrRegQueryValueEx(m_hkeySize, szFontRegValue, 0, &dwType, (BYTE *)pLogFontW, &cbSize);
        if (SUCCEEDED(hr))
        {
            if (cbSize != sizeof(*pLogFontW))
            {
                hr = E_FAIL;
            }
            else
            {
                // CHARSET: In Win2k, fontfix.cpp was used as a hack to change the CHARSET from one language to another.
                // That doesn't work for many reasons: a) not called on roaming, b) not called for OS lang changes, 
                // c) won't fix the problem for strings with multiple languages, d) etc.
                // Therefore, the SHELL team (BryanSt) had the NTUSER team (MSadek) agree to use DEFAULT_CHARSET all the time.
                // If some app has bad logic testing the charset parameter, then the NTUSER team will shim that app to fix it.
                // The shim would be really simple, on the return from a SystemParametersInfo(SPI_GETNONCLIENTMETRICS or ICONFONTS)
                // just patch the lfCharSet param to the current charset.

                // For all CHARSETs to DEFAULT_CHARSET
                pLogFontW->lfCharSet = DEFAULT_CHARSET;
            }
        }
    }

    return hr;
}


HRESULT CAppearanceSize::PutSystemMetricFont(IN enumSystemMetricFont nFontIndex, IN LOGFONTW * pLogFontW)
{
    HRESULT hr = E_INVALIDARG;

    if (pLogFontW)
    {
        TCHAR szFontRegValue[MAXIMUM_SUB_KEY_LENGTH];

        StringCchPrintf(szFontRegValue, ARRAYSIZE(szFontRegValue), TEXT("Font #%d"), nFontIndex);
        hr = HrRegSetValueEx(m_hkeySize, szFontRegValue, 0, REG_BINARY, (BYTE *)pLogFontW, sizeof(*pLogFontW));
    }

    return hr;
}


HRESULT CAppearanceSize::get_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, OUT int * pnSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pnSize)
    {
        TCHAR szFontRegValue[MAXIMUM_SUB_KEY_LENGTH];
        DWORD dwType;
        INT64 nSize64;
        DWORD cbSize = sizeof(nSize64);

        *pnSize = 0;
        StringCchPrintf(szFontRegValue, ARRAYSIZE(szFontRegValue), TEXT("Size #%d"), nSystemMetricIndex);
        hr = HrRegQueryValueEx(m_hkeySize, szFontRegValue, 0, &dwType, (BYTE *)&nSize64, &cbSize);
        if (SUCCEEDED(hr))
        {
            if (cbSize != sizeof(nSize64))
            {
                hr = E_FAIL;
            }
            else
            {
                *pnSize = (int)nSize64;
            }
        }
    }

    return hr;
}


HRESULT CAppearanceSize::put_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, IN int nSize)
{
    HRESULT hr = E_INVALIDARG;
    TCHAR szFontRegValue[MAXIMUM_SUB_KEY_LENGTH];
    INT64 nSize64 = (INT64)nSize;

    StringCchPrintf(szFontRegValue, ARRAYSIZE(szFontRegValue), TEXT("Size #%d"), nSystemMetricIndex);
    hr = HrRegSetValueEx(m_hkeySize, szFontRegValue, 0, REG_QWORD, (BYTE *)&nSize64, sizeof(nSize64));

    return hr;
}


#define SZ_WEBVW_NOSKIN_NORMAL_DIR           L"NormalContrast"
#define SZ_WEBVW_NOSKIN_HIBLACK_DIR          L"HighContrastBlack"
#define SZ_WEBVW_NOSKIN_HIWHITE_DIR          L"HighContrastWhite"
#define SZ_DIR_RESOURCES_THEMES              L"Themes"

HRESULT CAppearanceSize::get_WebviewCSS(OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath)
    {
        WCHAR szPath[MAX_PATH];

        *pbstrPath = NULL;
        hr = SHGetResourcePath(TRUE, szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            if (PathAppend(szPath, SZ_DIR_RESOURCES_THEMES))
            {
                enumThemeContrastLevels ContrastLevel = CONTRAST_NORMAL;
                get_ContrastLevel(&ContrastLevel);
                BOOL bResult;

                switch (ContrastLevel)
                {
                case CONTRAST_HIGHBLACK:
                    bResult = PathAppend(szPath, SZ_WEBVW_NOSKIN_HIBLACK_DIR);
                    break;
                case CONTRAST_HIGHWHITE:
                    bResult = PathAppend(szPath, SZ_WEBVW_NOSKIN_HIWHITE_DIR);
                    break;
                default:
                case CONTRAST_NORMAL:
                    bResult = PathAppend(szPath, SZ_WEBVW_NOSKIN_NORMAL_DIR);
                    break;
                }

                if (bResult)
                {
                    if (PathAppend(szPath, SZ_WEBVW_SKIN_FILE))
                    {
                        hr = HrSysAllocString(szPath, pbstrPath);
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


HRESULT CAppearanceSize::get_ContrastLevel(OUT enumThemeContrastLevels * pContrastLevel)
{
    HRESULT hr = E_INVALIDARG;

    if (pContrastLevel)
    {
        DWORD dwType;
        DWORD cbSize = sizeof(*pContrastLevel);

        *pContrastLevel = CONTRAST_NORMAL;
        hr = HrRegQueryValueEx(m_hkeySize, SZ_REGVALUE_CONTRASTLEVEL, 0, &dwType, (BYTE *)pContrastLevel, &cbSize);
        if (SUCCEEDED(hr))
        {
            if (REG_DWORD != dwType)
            {
                *pContrastLevel = CONTRAST_NORMAL;
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


HRESULT CAppearanceSize::put_ContrastLevel(IN enumThemeContrastLevels ContrastLevel)
{
    return HrRegSetValueEx(m_hkeySize, SZ_REGVALUE_CONTRASTLEVEL, 0, REG_DWORD, (BYTE *)&ContrastLevel, sizeof(ContrastLevel));
}






//===========================
// *** IPropertyBag Interface ***
//===========================
HRESULT CAppearanceSize::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_VSBEHAVIOR_FLATMENUS))
        {
            pVar->vt = VT_BOOL;
            hr = S_OK;
            // We default to zero because that's what non-visual styles will have.
            pVar->boolVal = (HrRegGetDWORD(m_hkeySize, NULL, SZ_REGVALUE_FLATMENUS, 0x00000001) ? VARIANT_TRUE : VARIANT_FALSE);
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_COLORSCHEME_LEGACYNAME))
        {
            TCHAR szLegacyName[MAX_PATH];

            hr = HrRegGetValueString(m_hkeySize, NULL, SZ_REGVALUE_LEGACYNAME, szLegacyName, ARRAYSIZE(szLegacyName));
            if (SUCCEEDED(hr))
            {
                pVar->vt = VT_BSTR;
                hr = HrSysAllocString(szLegacyName, &pVar->bstrVal);
            }
        }
    }

    return hr;
}


HRESULT CAppearanceSize::Write(IN LPCOLESTR pszPropName, IN VARIANT * pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_VSBEHAVIOR_FLATMENUS) &&
            (VT_BOOL == pVar->vt))
        {
            DWORD dwData = ((VARIANT_TRUE == pVar->boolVal) ? 0x00000001 : 0x000000);

            hr = HrRegSetDWORD(m_hkeySize, NULL, SZ_REGVALUE_FLATMENUS, dwData);
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_COLORSCHEME_LEGACYNAME) &&
            (VT_BSTR == pVar->vt))
        {
            hr = HrRegSetValueString(m_hkeySize, NULL, SZ_REGVALUE_LEGACYNAME, pVar->bstrVal);
        }
    }

    return hr;
}






//===========================
// *** IUnknown Interface ***
//===========================
ULONG CAppearanceSize::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CAppearanceSize::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CAppearanceSize::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAppearanceSize, IThemeSize),
        QITABENT(CAppearanceSize, IDispatch),
        QITABENT(CAppearanceSize, IPropertyBag),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CAppearanceSize::CAppearanceSize(IN HKEY hkeyStyle, IN HKEY hkeySize) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_hkeyStyle = hkeyStyle;
    m_hkeySize = hkeySize;
}


CAppearanceSize::~CAppearanceSize()
{
    if (m_hkeyStyle)
    {
        RegCloseKey(m_hkeyStyle);
    }

    if (m_hkeySize)
    {
        RegCloseKey(m_hkeySize);
    }

    DllRelease();
}



HRESULT CAppearanceSize_CreateInstance(IN HKEY hkeyStyle, IN HKEY hkeySize, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        CAppearanceSize * pObject = new CAppearanceSize(hkeyStyle, hkeySize);

        *ppThemeSize = NULL;
        if (pObject)
        {
            hr = pObject->QueryInterface(IID_PPV_ARG(IThemeSize, ppThemeSize));
            pObject->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\appscheme.h ===
/*****************************************************************************\
    FILE: appScheme.h

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_APPSCHEME
#define _FILE_H_APPSCHEME

#include <cowsite.h>
#include <atlbase.h>


static const GUID CLSID_LegacyAppearanceScheme = { 0xb41910f6, 0xab9f, 0x4768, { 0x94, 0x5c, 0x3c, 0x42, 0x37, 0xf2, 0xe2, 0x5c } };// {B41910F6-AB9F-4768-945C-3C4237F2E25C}
HRESULT CAppearanceScheme_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);

HRESULT LoadConversionMappings(void);
HRESULT MapLegacyAppearanceSchemeToIndex(LPCTSTR pszOldSchemeName, int * pnIndex);

typedef struct
{
    TCHAR szLegacyName[MAX_PATH];
    TCHAR szNewColorSchemeName[MAX_PATH];
    TCHAR szNewSizeName[MAX_PATH];
    enumThemeContrastLevels ContrastLevel;
} APPEARANCESCHEME_UPGRADE_MAPPINGS;

extern APPEARANCESCHEME_UPGRADE_MAPPINGS g_UpgradeMapping[MAX_LEGACY_UPGRADE_SCENARIOS];


class CAppearanceScheme         : public CObjectCLSID
                                , public IThemeScheme
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeScheme ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName) {return E_NOTIMPL;}
    virtual STDMETHODIMP get_Path(OUT BSTR * pbstrPath) { if (pbstrPath) {*pbstrPath = NULL;} return E_NOTIMPL;}
    virtual STDMETHODIMP put_Path(IN BSTR bstrPath) {return E_NOTIMPL;}
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT IThemeStyle ** ppThemeStyle);
    virtual STDMETHODIMP get_SelectedStyle(OUT IThemeStyle ** ppThemeStyle);
    virtual STDMETHODIMP put_SelectedStyle(IN IThemeStyle * pThemeStyle);
    virtual STDMETHODIMP AddStyle(OUT IThemeStyle ** ppThemeStyle) {return _AddStyle(NULL, ppThemeStyle);};

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return E_ACCESSDENIED; }

private:
    CAppearanceScheme(void);
    virtual ~CAppearanceScheme(void);


    // Private Member Variables
    long                    m_cRef;

    HKEY                    m_hKeyScheme;

    // Private Member Functions
    HRESULT _InitReg(void);
    HRESULT _ConvertScheme(LPCTSTR pszLegacyName, LPCTSTR pszStyleName, LPCTSTR pszSizeName, SYSTEMMETRICSALL * pState, IN enumThemeContrastLevels ContrastLevel, IN BOOL fSetAsDefault, IN BOOL fSetRegKeyTitle);
    HRESULT _LoadConversionMappings(void);
    HRESULT _CustomConvert(LPCTSTR pszSchemeName, SYSTEMMETRICSALL * pState, IN BOOL fSetAsDefault, IN BOOL fSetRegKeyTitle);
    HRESULT _IsLegacyUpgradeConvert(LPCTSTR pszSchemeName, SYSTEMMETRICSALL * pState, IN BOOL fSetAsDefault);
    HRESULT _getStyleByIndex(IN long nIndex, OUT IThemeStyle ** ppThemeStyle);
    HRESULT _getCurrentSettings(IN LPCWSTR pszSettings, OUT IThemeStyle ** ppThemeStyle);
    HRESULT _AddStyle(IN LPCWSTR pszTitle, OUT IThemeStyle ** ppThemeStyle);

    HRESULT _getIndex(IN IThemeStyle * pThemeStyle, IN BSTR bstrStyleDisplayName, IN long * pnStyleIndex, IN IThemeSize * pThemeSize, IN BSTR bstrSizeDisplayName, IN long * pnSizeIndex);
    HRESULT _getSizeIndex(IN IThemeStyle * pThemeStyle, IN IThemeSize * pThemeSize, IN BSTR bstrSizeDisplayName, IN long * pnSizeIndex);

    // Friend Functions
    friend HRESULT CAppearanceScheme_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
};


#endif // _FILE_H_APPSCHEME
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\appsize.h ===
/*****************************************************************************\
    FILE: appSize.h

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_APPSIZE
#define _FILE_H_APPSIZE

#include <cowsite.h>
#include <atlbase.h>
#include <theme.h>



HRESULT CAppearanceSize_CreateInstance(IN HKEY hkeyStyle, IN HKEY hkeySize, OUT IThemeSize ** ppThemeSize);


class CAppearanceSize           : public IThemeSize
                                , public IPropertyBag
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeSize ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName);
    virtual STDMETHODIMP get_Name(OUT BSTR * pbstrName);
    virtual STDMETHODIMP put_Name(IN BSTR bstrName);
    virtual STDMETHODIMP get_SystemMetricColor(IN int nSysColorIndex, OUT COLORREF * pColorRef);
    virtual STDMETHODIMP put_SystemMetricColor(IN int nSysColorIndex, IN COLORREF ColorRef);
    virtual STDMETHODIMP get_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, OUT int * pnSize);
    virtual STDMETHODIMP put_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, IN int nSize);
    virtual STDMETHODIMP get_WebviewCSS(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP get_ContrastLevel(OUT enumThemeContrastLevels * pContrastLevel);
    virtual STDMETHODIMP put_ContrastLevel(IN enumThemeContrastLevels ContrastLevel);
    virtual STDMETHODIMP GetSystemMetricFont(IN enumSystemMetricFont nSPIFontIndex, IN LOGFONTW * pParamW);
    virtual STDMETHODIMP PutSystemMetricFont(IN enumSystemMetricFont nSPIFontIndex, IN LOGFONTW * pParamW);

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return E_ACCESSDENIED; }

private:
    CAppearanceSize(IN HKEY hkeyStyle, IN HKEY hkeySize);
    virtual ~CAppearanceSize(void);


    // Private Member Variables
    long                    m_cRef;

    HKEY                    m_hkeyStyle;
    HKEY                    m_hkeySize;


    // Private Methods

    // Friend Functions
    friend HRESULT CAppearanceSize_CreateInstance(IN HKEY hkeyStyle, IN HKEY hkeySize, OUT IThemeSize ** ppThemeSize);
};


#endif // _FILE_H_APPSIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\appstyle.cpp ===
/*****************************************************************************\
    FILE: appStyle.cpp

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "theme.h"
#include "appsize.h"
#include "appstyle.h"




//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CAppearanceStyle::_getSizeByIndex(IN long nIndex, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        HKEY hKeyStyle;

        *ppThemeSize = NULL;
        hr = HrRegOpenKeyEx(m_hKeyStyle, NULL, 0, (KEY_WRITE | KEY_READ), &hKeyStyle);      // Clone the key.
        if (SUCCEEDED(hr))
        {
            HKEY kKeySizes;

            hr = HrRegCreateKeyEx(m_hKeyStyle, SZ_REGKEY_SIZES, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &kKeySizes, NULL);
            if (SUCCEEDED(hr))
            {
                HKEY kKeyTheSize;
                TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];

                StringCchPrintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%d"), nIndex);
                hr = HrRegOpenKeyEx(kKeySizes, szKeyName, 0, (KEY_WRITE | KEY_READ), &kKeyTheSize);
                if (SUCCEEDED(hr))
                {
                   hr = CAppearanceSize_CreateInstance(hKeyStyle, kKeyTheSize, ppThemeSize);  // This function takes ownership of hKeyStyle and kKeyTheSize
                }

                RegCloseKey(kKeySizes);
            }

            if (FAILED(hr))
            {
                RegCloseKey(hKeyStyle);
            }
        }
    }

    return hr;
}




#define SZ_APPEARANCE_SCHEME_NAME         L"NoVisualStyle"

//===========================
// *** ITheme Interface ***
//===========================
HRESULT CAppearanceStyle::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrDisplayName)
    {
        CComBSTR bstrDisplayName;

        *pbstrDisplayName = NULL;
        hr = HrBStrRegQueryValue(m_hKeyStyle, SZ_REGVALUE_DISPLAYNAME, &bstrDisplayName);
        if (SUCCEEDED(hr))
        {
            WCHAR szDisplayName[MAX_PATH];
            if (SUCCEEDED(SHLoadIndirectString(bstrDisplayName, szDisplayName, ARRAYSIZE(szDisplayName), NULL)))
            {
                hr = HrSysAllocStringW(szDisplayName, pbstrDisplayName);
            }
            else
            {
                hr = HrSysAllocStringW(bstrDisplayName, pbstrDisplayName);
            }
        }
    }


    return hr;
}


HRESULT CAppearanceStyle::put_DisplayName(IN BSTR bstrDisplayName)
{
    return HrRegSetValueString(m_hKeyStyle, NULL, SZ_REGVALUE_DISPLAYNAME, bstrDisplayName);
}


HRESULT CAppearanceStyle::get_Name(OUT BSTR * pbstrName)
{
    // This will be connonical.  And it will be language independent if it is one that
    // we could upgrade to MUI compat strings.
    return HrBStrRegQueryValue(m_hKeyStyle, SZ_REGVALUE_DISPLAYNAME, pbstrName);
}


HRESULT CAppearanceStyle::put_Name(IN BSTR bstrName)
{
    return E_NOTIMPL;
}


HRESULT CAppearanceStyle::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pnLength)
    {
        HKEY hKeyStyle;

        *pnLength = 0;

        hr = HrRegOpenKeyEx(m_hKeyStyle, SZ_REGKEY_SIZES, 0, KEY_READ, &hKeyStyle);
        if (SUCCEEDED(hr))
        {
            DWORD dwValues = 0;

            hr = HrRegQueryInfoKey(hKeyStyle, NULL, NULL, NULL, &dwValues, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            *pnLength = (long) dwValues;

            RegCloseKey(hKeyStyle);
        }
    }

    return hr;
}


HRESULT CAppearanceStyle::get_item(IN VARIANT varIndex, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        long nCount = 0;

        get_length(&nCount);
        *ppThemeSize = NULL;

        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
            varIndex = *(varIndex.pvarVal);

        switch (varIndex.vt)
        {
        case VT_I2:
            varIndex.lVal = (long)varIndex.iVal;
            // And fall through...

        case VT_I4:
            if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount))
            {
                hr = _getSizeByIndex(varIndex.lVal, ppThemeSize);
            }
        break;
        case VT_BSTR:
        if (varIndex.bstrVal)
        {
            for (int nIndex = 0; FAILED(hr) && (nIndex < nCount); nIndex++)
            {
                IThemeSize * pThemeSize;

                if (SUCCEEDED(_getSizeByIndex(nIndex, &pThemeSize)))
                {
                    CComBSTR bstrDisplayName;

                    if (SUCCEEDED(pThemeSize->get_DisplayName(&bstrDisplayName)))
                    {
                        if (!StrCmpIW(bstrDisplayName, varIndex.bstrVal))
                        {
                            // They match, so this is the one.
                            *ppThemeSize = pThemeSize;
                            pThemeSize = NULL;
                            hr = S_OK;
                        }
                    }

                    if (FAILED(hr))
                    {
                        if (bstrDisplayName)
                        {
                            bstrDisplayName.Empty();
                        }

                        if (SUCCEEDED(pThemeSize->get_Name(&bstrDisplayName)))
                        {
                            if (!StrCmpIW(bstrDisplayName, varIndex.bstrVal))
                            {
                                // They match, so this is the one.
                                *ppThemeSize = pThemeSize;
                                pThemeSize = NULL;
                                hr = S_OK;
                            }
                        }
                    }

                    ATOMICRELEASE(pThemeSize);
                }
            }
        }
        break;

        default:
            hr = E_NOTIMPL;
        }
    }

    return hr;
}


HRESULT CAppearanceStyle::get_SelectedSize(OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        HKEY hKeyStyle;

        *ppThemeSize = NULL;
        AssertMsg((NULL != m_hKeyStyle), TEXT("If this isn't set, then someone didn't construct us correctly"));
        hr = HrRegOpenKeyEx(m_hKeyStyle, NULL, 0, (KEY_WRITE | KEY_READ), &hKeyStyle);      // Clone the key.
        if (SUCCEEDED(hr))
        {
            TCHAR szSelectedSize[MAXIMUM_SUB_KEY_LENGTH];
            DWORD cbSize = sizeof(szSelectedSize);

            hr = HrSHGetValue(m_hKeyStyle, NULL, SZ_REGVALUE_SELECTEDSIZE, NULL, szSelectedSize, &cbSize);
            if (FAILED(hr))
            {
                StringCchCopy(szSelectedSize,  ARRAYSIZE(szSelectedSize), TEXT("0"));  // Select the first one in the list when in doubt.
                hr = S_OK;
            }

            if (SUCCEEDED(hr))
            {
                TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];
                HKEY hKeyTheSize;

                StringCchPrintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%s\\%s"), SZ_REGKEY_SIZES, szSelectedSize);

                // Let's find the next empty slot
                hr = HrRegOpenKeyEx(m_hKeyStyle, szKeyName, 0, (KEY_WRITE | KEY_READ), &hKeyTheSize);
                if (SUCCEEDED(hr))
                {
                    hr = CAppearanceSize_CreateInstance(hKeyStyle, hKeyTheSize, ppThemeSize);  // This function takes ownership of hKeyStyle and kKeySizes
                    if (FAILED(hr))
                    {
                        RegCloseKey(hKeyTheSize);
                    }
                }
            }

            if (FAILED(hr))
            {
                RegCloseKey(hKeyStyle);
            }
        }
    }

    return hr;
}


HRESULT CAppearanceStyle::put_SelectedSize(IN IThemeSize * pThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pThemeSize)
    {
        TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];
        CComBSTR bstrDisplayNameSource;

        szKeyName[0] = 0;
        hr = pThemeSize->get_DisplayName(&bstrDisplayNameSource);
        if (SUCCEEDED(hr))
        {
            for (int nIndex = 0; SUCCEEDED(hr); nIndex++)
            {
                IThemeSize * pThemeSizeInList;

                hr = _getSizeByIndex(nIndex, &pThemeSizeInList);
                if (SUCCEEDED(hr))
                {
                    CComBSTR bstrDisplayName;

                    hr = pThemeSizeInList->get_DisplayName(&bstrDisplayName);
                    if (SUCCEEDED(hr))
                    {
                        ATOMICRELEASE(pThemeSizeInList);
                        if (!StrCmpIW(bstrDisplayName, bstrDisplayNameSource))
                        {
                            // They match, so this is the one.
                            StringCchPrintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%d"), nIndex);
                            break;
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && szKeyName[0])
        {
            DWORD cbSize = ((lstrlen(szKeyName) + 1) * sizeof(szKeyName[0]));

            hr = HrSHSetValue(m_hKeyStyle, NULL, SZ_REGVALUE_SELECTEDSIZE, REG_SZ, szKeyName, cbSize);
        }
    }

    return hr;
}


HRESULT CAppearanceStyle::AddSize(OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        HKEY kKeySizes;
        *ppThemeSize = NULL;

        hr = HrRegCreateKeyEx(m_hKeyStyle, SZ_REGKEY_SIZES, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &kKeySizes, NULL);
        if (SUCCEEDED(hr))
        {
            for (int nIndex = 0; nIndex < 10000; nIndex++)
            {
                HKEY hKeyTheSize;
                TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];

                StringCchPrintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%d"), nIndex);

                // Let's find the next empty slot
                hr = HrRegOpenKeyEx(kKeySizes, szKeyName, 0, (KEY_WRITE | KEY_READ), &hKeyTheSize);
                if (SUCCEEDED(hr))
                {
                    RegCloseKey(hKeyTheSize);
                }
                else
                {
                    hr = HrRegCreateKeyEx(kKeySizes, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &hKeyTheSize, NULL);
                    if (SUCCEEDED(hr))
                    {
                        HKEY hKeyStyle;

                        hr = HrRegOpenKeyEx(m_hKeyStyle, NULL, 0, (KEY_WRITE | KEY_READ), &hKeyStyle);      // Clone the key.
                        if (SUCCEEDED(hr))
                        {
                            hr = CAppearanceSize_CreateInstance(hKeyStyle, hKeyTheSize, ppThemeSize);  // This function takes ownership of hKeyStyle and kKeySizes
                            if (FAILED(hr))
                            {
                                RegCloseKey(hKeyStyle);
                            }
                        }

                        if (FAILED(hr))
                        {
                            RegCloseKey(hKeyTheSize);
                        }
                    }

                    break;
                }
            }

            RegCloseKey(kKeySizes);
        }
    }

    return hr;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CAppearanceStyle::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CAppearanceStyle::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CAppearanceStyle::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAppearanceStyle, IThemeStyle),
        QITABENT(CAppearanceStyle, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CAppearanceStyle::CAppearanceStyle(IN HKEY hkeyStyle) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_hKeyStyle = hkeyStyle;
}


CAppearanceStyle::~CAppearanceStyle()
{
    if (m_hKeyStyle)
    {
        RegCloseKey(m_hKeyStyle);
    }

    DllRelease();
}



HRESULT CAppearanceStyle_CreateInstance(IN HKEY hkeyStyle, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        CAppearanceStyle * pObject = new CAppearanceStyle(hkeyStyle);

        *ppThemeStyle = NULL;
        if (pObject)
        {
            hr = pObject->QueryInterface(IID_PPV_ARG(IThemeStyle, ppThemeStyle));
            pObject->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\baseappearpg.cpp ===
/*****************************************************************************\
    FILE: BaseAppearPg.cpp

    DESCRIPTION:
        This code will display a "Appearances" tab in the
    "Display Properties" dialog (the base dialog, not the advanced dlg).

    ??????? ?/??/1993    Created
    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "BaseAppearPg.h"
#include "AdvAppearPg.h"
#include "CoverWnd.h"
#include "AppScheme.h"
#include "AdvDlg.h"
#include "fontfix.h"

//============================================================================================================
// *** Globals ***
//============================================================================================================
const static DWORD FAR aBaseAppearanceHelpIds[] =
{
        IDC_APPG_APPEARPREVIEW,         IDH_DISPLAY_APPEARANCE_PREVIEW,
        IDC_APPG_LOOKFEEL,              IDH_DISPLAY_APPEARANCE_LOOKFEEL,
        IDC_APPG_LOOKFEEL_LABLE,        IDH_DISPLAY_APPEARANCE_LOOKFEEL,
        IDC_APPG_COLORSCHEME_LABLE,     IDH_DISPLAY_APPEARANCE_COLORSCHEME,
        IDC_APPG_COLORSCHEME,           IDH_DISPLAY_APPEARANCE_COLORSCHEME,
        IDC_APPG_WNDSIZE_LABLE,         IDH_DISPLAY_APPEARANCE_WNDSIZE,
        IDC_APPG_WNDSIZE,               IDH_DISPLAY_APPEARANCE_WNDSIZE,
        IDC_APPG_EFFECTS,               IDH_DISPLAY_APPEARANCE_EFFECTS,
        IDC_APPG_ADVANCED,              IDH_DISPLAY_APPEARANCE_ADVANCED,
        0, 0
};

#define SZ_HELPFILE_BASEAPPEARANCE      TEXT("display.hlp")

// EnableApplyButton() fails in WM_INITDIALOG so we need to do it later.
#define WMUSER_DELAYENABLEAPPLY            (WM_USER + 1)
#define DelayEnableApplyButton(hDlg)    PostMessage(hDlg, WMUSER_DELAYENABLEAPPLY, 0, 0)




//===========================
// *** Class Internals & Helpers ***
//===========================
#ifdef DEBUG
void _TestFault(void)
{
    DWORD dwTemp = 3;
    DWORD * pdwDummy = NULL;        // This is NULL in order that it causes a fault.

    for (int nIndex = 0; nIndex < 1000000; nIndex++)
    {
        // This will definitely fault sooner or later.
        dwTemp += pdwDummy[nIndex];
    }
}
#endif // DEBUG


BOOL CBaseAppearancePage::_IsDirty(void)
{
    BOOL fIsDirty = m_advDlgState.dwChanged;

    if (m_fIsDirty ||   // We need to check this because we may have gotten dirty from another page before our UI was displayed.
        (ComboBox_GetCurSel(m_hwndSchemeDropDown) != m_nSelectedScheme) ||
        (ComboBox_GetCurSel(m_hwndStyleDropDown) != m_nSelectedStyle) ||
        (ComboBox_GetCurSel(m_hwndSizeDropDown) != m_nSelectedSize) ||
        (m_nNewDPI != m_nAppliedDPI))
    {
        fIsDirty = TRUE;
    }

    return fIsDirty;
}


INT_PTR CALLBACK CBaseAppearancePage::BaseAppearanceDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CBaseAppearancePage * pThis = (CBaseAppearancePage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

        if (pPropSheetPage)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
            pThis = (CBaseAppearancePage *)pPropSheetPage->lParam;
        }
    }

    if (pThis)
        return pThis->_BaseAppearanceDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


//============================================================================================================
// *** Dialog Functions ***
//============================================================================================================
HRESULT CBaseAppearancePage::_OnAdvancedOptions(HWND hDlg)
{
    HRESULT hr = E_FAIL;
    IAdvancedDialog * pAdvAppearDialog;

    hr = GetAdvancedDialog(&pAdvAppearDialog);
    if (SUCCEEDED(hr))
    {
        BOOL fEnableApply = FALSE;

        IUnknown_SetSite(pAdvAppearDialog, SAFECAST(this, IObjectWithSite *));
        hr = pAdvAppearDialog->DisplayAdvancedDialog(hDlg, SAFECAST(this, IPropertyBag *), &fEnableApply);
        IUnknown_SetSite(pAdvAppearDialog, NULL);
        if (SUCCEEDED(hr) && fEnableApply)
        {
            EnableApplyButton(hDlg);

            // We pass TRUE because we want to switch to Custom if:
            // 1) visual styles are off, and 2) some of the system metrics changed.  Then we need to update the previews.
            _UpdatePreview(TRUE);
        }

        pAdvAppearDialog->Release();
    }

    return hr;
}


HRESULT CBaseAppearancePage::_OnEffectsOptions(HWND hDlg)
{
    HRESULT hr = E_FAIL;

    if (_punkSite)
    {
        IThemeUIPages * pThemesUIPages;

        // Let's get the Effects base page.
        hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemesUIPages));
        if (SUCCEEDED(hr))
        {
            IEnumUnknown * pEnumUnknown;

            hr = pThemesUIPages->GetBasePagesEnum(&pEnumUnknown);
            if (SUCCEEDED(hr))
            {
                IUnknown * punk;

                hr = IEnumUnknown_FindCLSID(pEnumUnknown, PPID_Effects, &punk);
                if (SUCCEEDED(hr))
                {
                    IBasePropPage * pEffects;

                    hr = punk->QueryInterface(IID_PPV_ARG(IBasePropPage, &pEffects));
                    if (SUCCEEDED(hr))
                    {
                        IAdvancedDialog * pEffectsDialog;

                        hr = pEffects->GetAdvancedDialog(&pEffectsDialog);
                        if (SUCCEEDED(hr))
                        {
                            IPropertyBag * pEffectsBag;

                            hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, &pEffectsBag));
                            if (SUCCEEDED(hr))
                            {
                                BOOL fEnableApply = FALSE;

                                IUnknown_SetSite(pEffectsDialog, SAFECAST(this, IObjectWithSite *));
                                hr = pEffectsDialog->DisplayAdvancedDialog(hDlg, pEffectsBag, &fEnableApply);
                                IUnknown_SetSite(pEffectsDialog, NULL);
                                if (SUCCEEDED(hr) && fEnableApply)
                                {
                                    EnableApplyButton(hDlg);

                                    // We pass TRUE because we want to switch to Custom if:
                                    // 1) visual styles are off, and 2) some of the system metrics changed.  Then we need to update the previews.
                                    _UpdatePreview(TRUE);
                                }

                                pEffectsBag->Release();
                            }

                            pEffectsDialog->Release();
                        }

                        pEffects->Release();
                    }

                    punk->Release();
                }

                pEnumUnknown->Release();
            }

            pThemesUIPages->Release();
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_PopulateSchemeDropdown(void)
{
    HRESULT hr = E_FAIL;

    _FreeSchemeDropdown();    // Purge any existing items.
    if (m_pThemeManager && m_pSelectedThemeScheme)
    {
        CComBSTR bstrSelectedName;

        m_nSelectedStyle = -1;
        // This will fail if someone deleted the .msstyles file.
        if (FAILED(m_pSelectedThemeScheme->get_DisplayName(&bstrSelectedName)))
        {
            bstrSelectedName = (BSTR)NULL;
        }

        VARIANT varIndex;
#ifndef ENABLE_IA64_VISUALSTYLES
        // We use a different regkey for 64bit because we need to leave it off until the pre-Whistler
        // 64-bit release forks from the Whistler code base.
        BOOL fSkinsFeatureEnabled = SHRegGetBoolUSValue(SZ_REGKEY_APPEARANCE, SZ_REGVALUE_DISPLAYSCHEMES64, FALSE, FALSE);
#else // ENABLE_IA64_VISUALSTYLES
        BOOL fSkinsFeatureEnabled = SHRegGetBoolUSValue(SZ_REGKEY_APPEARANCE, SZ_REGVALUE_DISPLAYSCHEMES, FALSE, TRUE);
#endif // ENABLE_IA64_VISUALSTYLES

        varIndex.vt = VT_I4;
        varIndex.lVal = 0;
        do
        {
            hr = E_FAIL;

            // Only add the Skins if the policy doesn't lock it.
            if ((0 == varIndex.lVal) || fSkinsFeatureEnabled)
            {
                // Only add the Skins if the policy doesn't lock it.
                IThemeScheme * pThemeScheme;
                VARIANT varIndex2;

                varIndex2.vt = VT_I4;
                varIndex2.lVal = 0;

                // If a Theme can have more than one Scheme (Skin), then we should enum.
                hr = m_pThemeManager->get_schemeItem(varIndex, &pThemeScheme);
                if (SUCCEEDED(hr))
                {
                    CComBSTR bstrDisplayName;

                    hr = pThemeScheme->get_DisplayName(&bstrDisplayName);
                    if (SUCCEEDED(hr) && m_hwndSchemeDropDown)
                    {
                        int nAddIndex = ComboBox_AddString(m_hwndSchemeDropDown, bstrDisplayName);

                        if (-1 != nAddIndex)
                        {
                            ComboBox_SetItemData(m_hwndSchemeDropDown, nAddIndex, pThemeScheme);
                            pThemeScheme = NULL;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    ATOMICRELEASE(pThemeScheme);
                }
            }

            varIndex.lVal++;
        }
        while (SUCCEEDED(hr));

        //---- now that sorted list is built, find index of "bstrSelectedName" ----
        if (bstrSelectedName)
        {
            int nIndex = (int)ComboBox_FindStringExact(m_hwndSchemeDropDown, 0, bstrSelectedName);
            if (nIndex != -1)       // got a match
            {
                ComboBox_SetCurSel(m_hwndSchemeDropDown, nIndex);
                m_nSelectedScheme = nIndex;
            }
        }

        hr = S_OK;
    }

    if (-1 == m_nSelectedScheme)
    {
        m_nSelectedScheme = 0;
        ComboBox_SetCurSel(m_hwndSchemeDropDown, m_nSelectedScheme);
    }

    return hr;
}


HRESULT CBaseAppearancePage::_FreeSchemeDropdown(void)
{
    HRESULT hr = S_OK;
    LPARAM lParam;

    if (m_hwndSchemeDropDown)
    {
        do
        {
            lParam = ComboBox_GetItemData(m_hwndSchemeDropDown, 0);

            if (CB_ERR != lParam)
            {
                IThemeScheme * pThemeScheme = (IThemeScheme *) lParam;

                ATOMICRELEASE(pThemeScheme);
                ComboBox_DeleteString(m_hwndSchemeDropDown, 0);
            }
        }
        while (CB_ERR != lParam);
    }

    return hr;
}


HRESULT CBaseAppearancePage::_PopulateStyleDropdown(void)
{
    HRESULT hr = E_FAIL;

    _FreeStyleDropdown();    // Purge any existing items.
    if (m_pSelectedStyle)
    {
        CComBSTR bstrSelectedName;

        m_nSelectedStyle = -1;
        hr = m_pSelectedStyle->get_DisplayName(&bstrSelectedName);
        if (SUCCEEDED(hr))
        {
            VARIANT varIndex;

            varIndex.vt = VT_I4;
            varIndex.lVal = 0;
            do
            {
                // Only add the Skins if the policy doesn't lock it.
                IThemeStyle * pThemeStyle;

                hr = m_pSelectedThemeScheme->get_item(varIndex, &pThemeStyle);
                if (SUCCEEDED(hr))
                {
                    CComBSTR bstrDisplayName;

                    hr = pThemeStyle->get_DisplayName(&bstrDisplayName);
                    if (SUCCEEDED(hr) && m_hwndSchemeDropDown)
                    {
                        int nAddIndex = ComboBox_AddString(m_hwndStyleDropDown, bstrDisplayName);

                        if (-1 != nAddIndex)
                        {
                            ComboBox_SetItemData(m_hwndStyleDropDown, nAddIndex, pThemeStyle);
                            pThemeStyle = NULL;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    ATOMICRELEASE(pThemeStyle);
                }

                varIndex.lVal++;
            }
            while (SUCCEEDED(hr));
            
            //---- now that sorted list is built, find index of "bstrSelectedName" ----
            if (bstrSelectedName)
            {
                int nIndex = (int)ComboBox_FindStringExact(m_hwndStyleDropDown, 0, bstrSelectedName);
                if (nIndex != -1)       // got a match
                {
                    ComboBox_SetCurSel(m_hwndStyleDropDown, nIndex);
                    m_nSelectedStyle = nIndex;
                }
            }

            hr = S_OK;
        }
    }

    if (-1 == m_nSelectedStyle)
    {
        m_nSelectedStyle = 0;
        ComboBox_SetCurSel(m_hwndStyleDropDown, m_nSelectedStyle);
    }

    return hr;
}


HRESULT CBaseAppearancePage::_FreeStyleDropdown(void)
{
    HRESULT hr = S_OK;
    LPARAM lParam;

    if (m_hwndStyleDropDown)
    {
        do
        {
            lParam = ComboBox_GetItemData(m_hwndStyleDropDown, 0);

            if (CB_ERR != lParam)
            {
                IThemeStyle * pThemeStyle = (IThemeStyle *) lParam;

                ATOMICRELEASE(pThemeStyle);
                ComboBox_DeleteString(m_hwndStyleDropDown, 0);
            }
        }
        while (CB_ERR != lParam);
    }

    return hr;
}


HRESULT CBaseAppearancePage::_PopulateSizeDropdown(void)
{
    HRESULT hr = E_FAIL;

    _FreeSizeDropdown();    // Purge any existing items.
    if (m_pSelectedSize)
    {
        CComBSTR bstrSelectedName;

        m_nSelectedSize = -1;
        hr = m_pSelectedSize->get_DisplayName(&bstrSelectedName);
        if (SUCCEEDED(hr))
        {
            VARIANT varIndex;

            varIndex.vt = VT_I4;
            varIndex.lVal = 0;
            do
            {
                // Only add the Skins if the policy doesn't lock it.
                IThemeSize * pThemeSize;

                hr = m_pSelectedStyle->get_item(varIndex, &pThemeSize);
                if (SUCCEEDED(hr))
                {
                    CComBSTR bstrDisplayName;

                    hr = pThemeSize->get_DisplayName(&bstrDisplayName);
                    if (SUCCEEDED(hr) && m_hwndSchemeDropDown)
                    {
                        int nAddIndex = ComboBox_AddString(m_hwndSizeDropDown, bstrDisplayName);

                        if (-1 != nAddIndex)
                        {
                            ComboBox_SetItemData(m_hwndSizeDropDown, nAddIndex, pThemeSize);
                            pThemeSize = NULL;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    ATOMICRELEASE(pThemeSize);
                }

                varIndex.lVal++;
            }
            while (SUCCEEDED(hr));
            
            //---- now that sorted list is built, find index of "bstrSelectedName" ----
            if (bstrSelectedName)
            {
                int nIndex = (int)ComboBox_FindStringExact(m_hwndSizeDropDown, 0, bstrSelectedName);
                if (nIndex != -1)       // got a match
                {
                    ComboBox_SetCurSel(m_hwndSizeDropDown, nIndex);
                    m_nSelectedSize = nIndex;
                }
            }

            hr = S_OK;
        }
    }

    if (-1 == m_nSelectedSize)
    {
        m_nSelectedSize = 0;
        ComboBox_SetCurSel(m_hwndSizeDropDown, m_nSelectedSize);
    }

    return hr;
}


HRESULT CBaseAppearancePage::_FreeSizeDropdown(void)
{
    HRESULT hr = S_OK;
    LPARAM lParam;

    if (m_hwndSizeDropDown)
    {
        do
        {
            lParam = ComboBox_GetItemData(m_hwndSizeDropDown, 0);

            if (CB_ERR != lParam)
            {
                IThemeSize * pThemeSize = (IThemeSize *) lParam;

                ATOMICRELEASE(pThemeSize);
                ComboBox_DeleteString(m_hwndSizeDropDown, 0);
            }
        }
        while (CB_ERR != lParam);
    }

    return hr;
}


HRESULT CBaseAppearancePage::_OnInitAppearanceDlg(HWND hDlg)
{
    HRESULT hr = S_OK;

    _OnInitData();
    _hwnd = hDlg;

#ifdef DEBUG
    if (!SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\TaskManager"), TEXT("Enable Test Faults"), FALSE, FALSE))
    {
        // Disable the feature.
        DestroyWindow(GetDlgItem(hDlg, IDC_APPG_TESTFAULT));
    }
#endif // DEBUG

    m_hwndSchemeDropDown = GetDlgItem(hDlg, IDC_APPG_LOOKFEEL);
    m_hwndStyleDropDown = GetDlgItem(hDlg, IDC_APPG_COLORSCHEME);
    m_hwndSizeDropDown = GetDlgItem(hDlg, IDC_APPG_WNDSIZE);

    hr = _OnInitData();
    if (SUCCEEDED(hr))
    {
        hr = _PopulateSchemeDropdown();
        if (SUCCEEDED(hr))
        {
            hr = _PopulateStyleDropdown();
            if (SUCCEEDED(hr))
            {
                hr = _PopulateSizeDropdown();
                if (SUCCEEDED(hr))
                {
                    hr = _UpdatePreview(FALSE);
                }
            }
        }
    }

    TCHAR szTemp[MAX_PATH];
    DWORD dwType;
    DWORD cbSize = sizeof(szTemp);

    if (SHRestricted(REST_NOVISUALSTYLECHOICE) ||
        (ERROR_SUCCESS == SHRegGetUSValue(SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_POLICY_SETVISUALSTYLE, &dwType, (void *) szTemp, &cbSize, FALSE, NULL, 0)))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_APPG_LOOKFEEL_LABLE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_APPG_LOOKFEEL), FALSE);
        m_fLockVisualStylePolicyEnabled = TRUE;
        LogStatus("POLICY ENABLED: Either NoVisualChoice or SetVisualStyle policy is set, locking the visual style selection.");
    }

    if (SHRestricted(REST_NOCOLORCHOICE))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_APPG_COLORSCHEME_LABLE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_APPG_COLORSCHEME), FALSE);
    }

    if (SHRestricted(REST_NOSIZECHOICE))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_APPG_WNDSIZE_LABLE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_APPG_WNDSIZE), FALSE);
    }

    if (m_pszLoadMSTheme)
    {
        hr = _LoadVisaulStyleFile(m_pszLoadMSTheme);
    }

    _EnableAdvancedButton();

    return S_OK;
}


HRESULT CBaseAppearancePage::_OnInitData(void)
{
    HRESULT hr = S_OK;

    if (!m_fInitialized)
    {
        // Load DPI Value
        HDC hdc = GetDC(NULL);
        int nDefault = GetDeviceCaps(hdc, LOGPIXELSY);          // Get the default value;
        ReleaseDC(NULL, hdc);

        m_nAppliedDPI = HrRegGetDWORD(HKEY_CURRENT_USER, SZ_WINDOWMETRICS, SZ_APPLIEDDPI, DPI_PERSISTED);
        if (!m_nAppliedDPI)
        {
            m_nAppliedDPI = nDefault;
        }
        m_nNewDPI = m_nAppliedDPI;
        LogStatus("DPI: SYSTEMMETRICS currently at %d DPI  CBaseAppearancePage::_OnInitData\r\n", m_nAppliedDPI);

        // Load everything else.
        AssertMsg((NULL != _punkSite), TEXT("I need my punkSite!!!"));
        if (!m_pThemeManager && _punkSite)
        {
            hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeManager, &m_pThemeManager));
        }

        if (SUCCEEDED(hr) && !m_pSelectedThemeScheme)
        {
            hr = m_pThemeManager->get_SelectedScheme(&m_pSelectedThemeScheme);
            if (SUCCEEDED(hr) && !m_pSelectedStyle)
            {
                hr = m_pSelectedThemeScheme->get_SelectedStyle(&m_pSelectedStyle);
                if (SUCCEEDED(hr) && !m_pSelectedSize)
                {
                    hr = m_pSelectedStyle->get_SelectedSize(&m_pSelectedSize);
                    if (SUCCEEDED(hr))
                    {
                        // We want to load whatever system metrics the users have now.
                        hr = _LoadLiveSettings(SZ_SAVEGROUP_ALL);
                    }
                }
            }
        }
        m_fInitialized = TRUE;
    }

    return hr;
}


HRESULT CBaseAppearancePage::_OnDestroy(HWND hDlg)
{
    _FreeSchemeDropdown();
    _FreeStyleDropdown();
    _FreeSizeDropdown();

    return S_OK;
}


HRESULT CBaseAppearancePage::_EnableAdvancedButton(void)
{
    HRESULT hr = S_OK;
#ifdef FEATURE_ENABLE_ADVANCED_WITH_SKINSON
    BOOL fTurnOn = TRUE;
#else // FEATURE_ENABLE_ADVANCED_WITH_SKINSON
    BOOL fTurnOn = (m_pSelectedThemeScheme ? IUnknown_CompareCLSID(m_pSelectedThemeScheme, CLSID_LegacyAppearanceScheme) : FALSE);

    if (SHRegGetBoolUSValue(SZ_REGKEY_APPEARANCE, L"AlwaysAllowAdvanced", FALSE, FALSE))
    {
        fTurnOn = TRUE;
    }

#endif // FEATURE_ENABLE_ADVANCED_WITH_SKINSON
    EnableWindow(GetDlgItem(_hwnd, IDC_APPG_ADVANCED), fTurnOn);

    return hr;
}


HRESULT CBaseAppearancePage::_UpdatePreview(IN BOOL fUpdateThemePage)
{
    HRESULT hr = S_OK;

    if (!m_pThemePreview)
    {
        // We won't execute the following code if our dialog hasn't
        // been created yet.  That's fine because the preview will
        // obtain the correct state when we first initialize.
        if (_punkSite && m_hwndSchemeDropDown)
        {
            hr = CThemePreview_CreateInstance(NULL, IID_PPV_ARG(IThemePreview, &m_pThemePreview));

            if (SUCCEEDED(hr))
            {
                IPropertyBag * pPropertyBag;

                hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
                if (SUCCEEDED(hr))
                {
                    HWND hwndParent = GetParent(m_hwndSchemeDropDown);
                    HWND hwndPlaceHolder = GetDlgItem(hwndParent, IDC_APPG_APPEARPREVIEW);
                    RECT rcPreview;

                    AssertMsg((NULL != m_hwndSchemeDropDown), TEXT("We should have this window at this point.  -BryanSt"));
                    GetClientRect(hwndPlaceHolder, &rcPreview);
                    MapWindowPoints(hwndPlaceHolder, hwndParent, (LPPOINT)&rcPreview, 2);

                    if (SUCCEEDED(m_pThemePreview->CreatePreview(hwndParent, TMPREV_SHOWVS, WS_VISIBLE | WS_CHILDWINDOW | WS_BORDER | WS_OVERLAPPED, WS_EX_CLIENTEDGE, rcPreview.left, rcPreview.top, RECTWIDTH(rcPreview), RECTHEIGHT(rcPreview), pPropertyBag, IDC_APPG_APPEARPREVIEW)))
                    {
                        // If we succeeded, remove the dummy window.
                        DestroyWindow(hwndPlaceHolder);
                        hr = SHPropertyBag_WritePunk(pPropertyBag, SZ_PBPROP_PREVIEW3, m_pThemePreview);
                        if (SUCCEEDED(hr) && fUpdateThemePage)
                        {
                            // Tell the theme that we have customized the values.
                            hr = SHPropertyBag_WriteInt(pPropertyBag, SZ_PBPROP_CUSTOMIZE_THEME, 0);
                        }
                    }

                    pPropertyBag->Release();
                }
            }
        }
    }
    else if (_punkSite)
    {
        IThemeUIPages * pThemeUIPages;

        hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUIPages));
        if (SUCCEEDED(hr))
        {
            hr = pThemeUIPages->UpdatePreview(0);
        }
        pThemeUIPages->Release();
    }

    if (_punkSite && fUpdateThemePage)
    {
        IPropertyBag * pPropertyBag;

        hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            // Tell the theme that we have customized the values.
            hr = SHPropertyBag_WriteInt(pPropertyBag, SZ_PBPROP_CUSTOMIZE_THEME, 0);
            pPropertyBag->Release();
        }
    }

    return hr;
}


INT_PTR CBaseAppearancePage::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idCtrl)
    {
        case IDC_APPG_COLORSCHEME:
            if(HIWORD(wParam) == CBN_SELCHANGE)
            {
                _OnStyleChange(hDlg);
            }
            break;

        case IDC_APPG_WNDSIZE:
            if(HIWORD(wParam) == CBN_SELCHANGE)
            {
                _OnSizeChange(hDlg);
            }
            break;

        case IDC_APPG_LOOKFEEL:
            if(HIWORD(wParam) == CBN_SELCHANGE)
            {
                _OnSchemeChange(hDlg, TRUE);    // Display Error dialogs since the user is picking the visual style.
            }
            break;

        case IDC_APPG_EFFECTS:     // This is the Effects button.
            _OnEffectsOptions(hDlg);
            break;

        case IDC_APPG_ADVANCED:     // This is the Advanced button.
            _OnAdvancedOptions(hDlg);
            break;

#ifdef DEBUG
        case IDC_APPG_TESTFAULT:
            _TestFault();
            break;
#endif // DEBUG

        default:
            break;
    }

    return fHandled;
}


HRESULT CBaseAppearancePage::_OnSchemeChange(HWND hDlg, BOOL fDisplayErrors)
{
    HRESULT hr = E_FAIL;
    int nIndex = ComboBox_GetCurSel(m_hwndSchemeDropDown);
    BOOL fPreviousSelectionIsVS = (!IUnknown_CompareCLSID(m_pSelectedThemeScheme, CLSID_LegacyAppearanceScheme));

    if (-1 == nIndex)
    {
        nIndex = 0; // The caller may NOT select nothing.
    }

    IThemeScheme * pThemeScheme = (IThemeScheme *) ComboBox_GetItemData(m_hwndSchemeDropDown, nIndex);
    m_fLoadedAdvState = FALSE;       // Forget the state we previously loaded.
    m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
    PropSheet_Changed(GetParent(hDlg), hDlg);

    if (pThemeScheme)
    {
        IUnknown_Set((IUnknown **)&m_pSelectedThemeScheme, pThemeScheme);
    }

    hr = _SetScheme(TRUE, TRUE, fPreviousSelectionIsVS);
    if (FAILED(hr))
    {
        if (fDisplayErrors)
        {
            // Displaying an error dialog when the visual style is selected is very important because
            // this is where we catch parse errors in the visual style.
            hr = DisplayThemeErrorDialog(hDlg, hr, IDS_ERROR_TITLE_LOAD_MSSTYLES_FAIL, IDS_ERROR_LOAD_MSSTYLES_FAIL);
        }
    }

    _EnableAdvancedButton();

    return hr;
}


HRESULT CBaseAppearancePage::_OutsideSetScheme(BSTR bstrScheme)
{
    HRESULT hr = E_ACCESSDENIED;
 
    if (!m_fLockVisualStylePolicyEnabled)
    {
        hr = E_FAIL;
        BOOL fPreviousSelectionIsVS = !IUnknown_CompareCLSID(m_pSelectedThemeScheme, CLSID_LegacyAppearanceScheme);

        ATOMICRELEASE(m_pSelectedThemeScheme);
        if (bstrScheme && bstrScheme[0])
        {
            BOOL fVisualStylesSupported = (QueryThemeServicesWrap() & QTS_AVAILABLE);

            LogStatus("QueryThemeServices() returned %hs.  In CBaseAppearancePage::_OutsideSetScheme\r\n", (fVisualStylesSupported ? "TRUE" : "FALSE"));

            // Do not load a visual style of themes do not work.
            if (fVisualStylesSupported)
            {
                if (PathFileExists(bstrScheme))
                {
                    hr = CSkinScheme_CreateInstance(bstrScheme, &m_pSelectedThemeScheme);
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);    // Them the caller that the theme service was not running.
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE);    // Them the caller that the theme service was not running.
            }
        }
        else
        {
            hr = CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, &m_pSelectedThemeScheme));
        }

        if (SUCCEEDED(hr))
        {
            // If we are displaying UI, update it.
            if (m_hwndSchemeDropDown)
            {
                CComBSTR bstrSelectedName;

                m_fIsDirty = TRUE;
                hr = m_pSelectedThemeScheme->get_DisplayName(&bstrSelectedName);
                if (SUCCEEDED(hr))
                {
                    int nIndex = ComboBox_FindString(m_hwndSchemeDropDown, 0, bstrSelectedName);

                    ComboBox_SetCurSel(m_hwndSchemeDropDown, nIndex);
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = _SetScheme(FALSE, FALSE, fPreviousSelectionIsVS);
            }
        }
    }

    return hr;
}



/*****************************************************************************\
    DESCRIPTION:
        The caller just loaded a new value into m_pSelectedThemeScheme.  Now
    load good default values into m_pSelectedStyle and m_pSelectedSize.

      Then this is called, the UI may or may not be displayed.  Either the user made a change in
    the dropdown in this tab or the Theme page is setting our values.

    PARAMETERS:
        fLoadSystemMetrics: If true, we load the system metrics from the scheme. If false,
                we simply select that as the name for the drop down when we let the caller
                push the system metrics into us.
        fLoadLiveSettings: When the user switches from Skin->NoSkin, do we want to
                load custom settings they had before they switched?
\*****************************************************************************/
HRESULT CBaseAppearancePage::_SetScheme(IN BOOL fLoadSystemMetrics, IN BOOL fLoadLiveSettings, IN BOOL fPreviousSelectionIsVS)
{
    HRESULT hr = E_FAIL;

    if (m_pSelectedThemeScheme)
    {
        // Now that they choose a different VisualStyle (Scheme), we want to select the new Color Style
        // and Size in that Scheme.

        // will fall back to the first ColorStyle.
        CComBSTR bstrSelectedStyle;
        CComBSTR bstrSelectedSize;

        if (m_pSelectedStyle)   // This will be empty if someone deletes the current .msstyles file.
        {
            hr = m_pSelectedStyle->get_DisplayName(&bstrSelectedStyle);
        }
        if (m_pSelectedSize)
        {
            hr = m_pSelectedSize->get_DisplayName(&bstrSelectedSize);
        }

        ATOMICRELEASE(m_pSelectedStyle);
        ATOMICRELEASE(m_pSelectedSize);

        CComVariant varNameBSTR(bstrSelectedStyle);

        // We prefer to get the ColorStyle with the same name as the previously selected one.
        hr = m_pSelectedThemeScheme->get_item(varNameBSTR, &m_pSelectedStyle);
        if (FAILED(hr))
        {
            // If that failed to return a value, then we will try to get the default ColorStyle.
            hr = m_pSelectedThemeScheme->get_SelectedStyle(&m_pSelectedStyle);
            if (FAILED(hr))
            {
                // If that failed then we will just pick the first ColorStyles.  (Beggers can't be choosers)
                VARIANT varIndex;

                varIndex.vt = VT_I4;
                varIndex.lVal = 0;
                hr = m_pSelectedThemeScheme->get_item(varIndex, &m_pSelectedStyle);
            }
        }

        if (m_pSelectedStyle)
        {
            varNameBSTR = bstrSelectedSize;

            // Now we want to repeat this process with the size.
            // We prefer to get the ColorStyle with the same name as the previously selected one.
            hr = m_pSelectedStyle->get_item(varNameBSTR, &m_pSelectedSize);
            if (FAILED(hr))
            {
                // If that failed to return a value, then we will try to get the default ColorStyle.
                hr = m_pSelectedStyle->get_SelectedSize(&m_pSelectedSize);
                if (FAILED(hr))
                {
                    // If that failed then we will just pick the first ColorStyles.  (Beggers can't be choosers)
                    VARIANT varIndex;

                    varIndex.vt = VT_I4;
                    varIndex.lVal = 0;
                    hr = m_pSelectedStyle->get_item(varIndex, &m_pSelectedSize);
                }
            }
        }

        hr = _PopulateStyleDropdown();
        hr = _PopulateSizeDropdown();

        BOOL fStateLoaded = FALSE;
        BOOL fIsThemeActive = IsThemeActive();
        LogStatus("IsThemeActive() returned %hs.  In CBaseAppearancePage::_SetScheme\r\n", (fIsThemeActive ? "TRUE" : "FALSE"));

        // If the user switched from a skin to "NoSkin", then we want to load the settings from the settings
        // chosen before the user chose the skin.
        if (fIsThemeActive &&                                       // Was a skin last applied?
            fLoadLiveSettings &&                                    // Do we want to load live settings?
            IUnknown_CompareCLSID(m_pSelectedThemeScheme, CLSID_LegacyAppearanceScheme) &&  // Is the new selection a "No Skin"?
            !m_fLoadedAdvState)                                     // Have we not yet loaded these setting?
        {
            // We want to load the last set of customized settings....
            if (SUCCEEDED(_LoadLiveSettings(SZ_SAVEGROUP_NOSKIN)))
            {
                fStateLoaded = TRUE;
            }
        }

        // We don't want to load the state if the change came from the outside
        // because they will load the state themselves.
        if (fLoadSystemMetrics && !fStateLoaded)
        {
            hr = SystemMetricsAll_Load(m_pSelectedSize, &m_advDlgState, &m_nNewDPI);
            if (SUCCEEDED(hr))
            {
                m_fLoadedAdvState = TRUE;
            }
        }
        m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);

        if (SUCCEEDED(hr))
        {
            hr = _UpdatePreview(fLoadSystemMetrics);

            if (!fPreviousSelectionIsVS && 
                !IUnknown_CompareCLSID(m_pSelectedThemeScheme, CLSID_LegacyAppearanceScheme))
            {
                IPropertyBag * pEffectsBag;

                // Whenever we turn on a visual style and a visual style was previously off,
                // turn on "Menu Drop Shadows".
                if (SUCCEEDED(_GetPageByCLSID(&PPID_Effects, &pEffectsBag)))
                {
                    SHPropertyBag_WriteBOOL(pEffectsBag, SZ_PBPROP_EFFECTS_MENUDROPSHADOWS, VARIANT_TRUE);
                    pEffectsBag->Release();
                }
            }
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_OnStyleChange(HWND hDlg)
{
    int nIndex = ComboBox_GetCurSel(m_hwndStyleDropDown);

    m_fLoadedAdvState = FALSE;       // Forget the state we previously loaded.
    m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
    PropSheet_Changed(GetParent(hDlg), hDlg);
    if (-1 == nIndex)
    {
        nIndex = 0; // The caller may NOT select nothing.
    }

    IThemeStyle * pThemeStyle = (IThemeStyle *) ComboBox_GetItemData(m_hwndStyleDropDown, nIndex);
    AssertMsg((NULL != pThemeStyle), TEXT("We need pThemeStyle"));
    if (pThemeStyle)
    {
        IUnknown_Set((IUnknown **)&m_pSelectedStyle, pThemeStyle);
    }

    return _SetStyle(TRUE);
}


HRESULT CBaseAppearancePage::_OutsideSetStyle(BSTR bstrStyle)
{
    HRESULT hr = E_FAIL;

    AssertMsg((NULL != m_pSelectedThemeScheme), TEXT("We need m_pSelectedThemeScheme"));
    if (m_pSelectedThemeScheme)
    {
        IThemeStyle * pSelectedStyle;
        CComVariant varNameBSTR(bstrStyle);

        m_fIsDirty = TRUE;
        hr = m_pSelectedThemeScheme->get_item(varNameBSTR, &pSelectedStyle);
        if (SUCCEEDED(hr))
        {
            ATOMICRELEASE(m_pSelectedStyle);
            m_pSelectedStyle = pSelectedStyle;

            // If we are displaying UI, update it.
            if (m_hwndStyleDropDown)
            {
                CComBSTR bstrSelectedName;

                hr = m_pSelectedStyle->get_DisplayName(&bstrSelectedName);
                if (SUCCEEDED(hr))
                {
                    int nIndex = ComboBox_FindString(m_hwndStyleDropDown, 0, bstrSelectedName);

                    ComboBox_SetCurSel(m_hwndStyleDropDown, nIndex);
                }
            }

            hr = _SetStyle(FALSE);
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_SetStyle(IN BOOL fUpdateThemePage)
{
    HRESULT hr = E_FAIL;

    AssertMsg((m_pSelectedSize && m_pSelectedSize), TEXT("We need m_pSelectedSize && m_pSelectedSize"));
    if (m_pSelectedSize && m_pSelectedSize)
    {
        // Now that they choose a different style, we want to select the new size
        // in that style.  We prefer to get the size with the same name but will
        // will fall back to the first style.
        CComBSTR bstrSelectedSize;
        hr = m_pSelectedSize->get_DisplayName(&bstrSelectedSize);
        ATOMICRELEASE(m_pSelectedSize);

        CComVariant varNameBSTR(bstrSelectedSize);
        hr = m_pSelectedStyle->get_item(varNameBSTR, &m_pSelectedSize);
        if (FAILED(hr))
        {
            VARIANT varIndex;

            varIndex.vt = VT_I4;
            varIndex.lVal = 0;
            hr = m_pSelectedStyle->get_item(varIndex, &m_pSelectedSize);
        }

        hr = _PopulateSizeDropdown();
        if (fUpdateThemePage && SUCCEEDED(SystemMetricsAll_Load(m_pSelectedSize, &m_advDlgState, &m_nNewDPI)))
        {
            m_fLoadedAdvState = TRUE;
            m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
        }

        if (SUCCEEDED(hr))
        {
            hr = _UpdatePreview(fUpdateThemePage);
        }
    }

    return hr;
}




HRESULT CBaseAppearancePage::_OnSizeChange(HWND hDlg)
{
    int nIndex = ComboBox_GetCurSel(m_hwndSizeDropDown);

    PropSheet_Changed(GetParent(hDlg), hDlg);
    if (-1 == nIndex)
    {
        nIndex = 0; // The caller may NOT select nothing.
    }

    IThemeSize * pThemeSize = (IThemeSize *) ComboBox_GetItemData(m_hwndSizeDropDown, nIndex);
    AssertMsg((NULL != pThemeSize), TEXT("We need pThemeSize"));
    if (pThemeSize)
    {
        IUnknown_Set((IUnknown **)&m_pSelectedSize, pThemeSize);
    }

    return _SetSize(TRUE, TRUE);
}


HRESULT CBaseAppearancePage::_OutsideSetSize(BSTR bstrSize)
{
    HRESULT hr = E_FAIL;

    AssertMsg((m_pSelectedThemeScheme && m_pSelectedStyle), TEXT("We need m_pSelectedThemeScheme && m_pSelectedStyle"));
    if (m_pSelectedThemeScheme && m_pSelectedStyle)
    {
        IThemeSize * pSelectedSize;
        CComVariant varNameBSTR(bstrSize);

        m_fIsDirty = TRUE;
        hr = m_pSelectedStyle->get_item(varNameBSTR, &pSelectedSize);
        if (SUCCEEDED(hr))
        {
            ATOMICRELEASE(m_pSelectedSize);
            m_pSelectedSize = pSelectedSize;

            // If we are displaying UI, update it.
            if (m_hwndSizeDropDown)
            {
                CComBSTR bstrSelectedName;

                hr = m_pSelectedSize->get_DisplayName(&bstrSelectedName);
                if (SUCCEEDED(hr))
                {
                    int nIndex = ComboBox_FindString(m_hwndSizeDropDown, 0, bstrSelectedName);

                    ComboBox_SetCurSel(m_hwndSizeDropDown, nIndex);
                }
            }

            hr = _SetSize(TRUE, FALSE);
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_SetSize(IN BOOL fLoadSystemMetrics, IN BOOL fUpdateThemePage)
{
    HRESULT hr = E_FAIL;

    AssertMsg((NULL != m_pSelectedSize), TEXT("We need m_pSelectedSize"));
    if (m_pSelectedSize)
    {
        hr = S_OK;
        
        // SystemMetricsAll_Load() will fail if m_pSelectedSize is a .msstyles file.
        if (fLoadSystemMetrics)
        {
            if (SUCCEEDED(SystemMetricsAll_Load(m_pSelectedSize, &m_advDlgState, &m_nNewDPI)))
            {
                m_fLoadedAdvState = TRUE;
                m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
            }
            else
            {
                m_fLoadedAdvState = FALSE;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = _UpdatePreview(fUpdateThemePage);
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_GetPageByCLSID(const GUID * pClsid, IPropertyBag ** ppPropertyBag)
{
    HRESULT hr = E_FAIL;

    *ppPropertyBag = NULL;
    if (_punkSite)
    {
        IThemeUIPages * pThemeUI;

        hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUI));
        if (SUCCEEDED(hr))
        {
            IEnumUnknown * pEnumUnknown;

            hr = pThemeUI->GetBasePagesEnum(&pEnumUnknown);
            if (SUCCEEDED(hr))
            {
                IUnknown * punk;

                // This may not exit due to policy
                hr = IEnumUnknown_FindCLSID(pEnumUnknown, *pClsid, &punk);
                if (SUCCEEDED(hr))
                {
                    hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, ppPropertyBag));
                    punk->Release();
                }

                pEnumUnknown->Release();
            }

            pThemeUI->Release();
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_OnSetActive(HWND hDlg)
{
#ifdef READ_3D_RULES_FROM_REGISTRY
    Look_Reset3DRatios();
#endif
    _LoadState();

    _EnableAdvancedButton();

    _ScaleSizesSinceDPIChanged();  // We want to update our settings if someone changed the DPI
    return S_OK;
}


HRESULT CBaseAppearancePage::_OnApply(HWND hDlg, LPARAM lParam)
{
    // Our parent dialog will be notified of the Apply event and will call our
    // IBasePropPage::OnApply() to do the real work.
    return S_OK;
}


// This Property Sheet appear in the top level of the "Display Control Panel".
INT_PTR CBaseAppearancePage::_BaseAppearanceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
            case PSN_SETACTIVE:
                _OnSetActive(hDlg);
                break;
            case PSN_APPLY:
                _OnApply(hDlg, lParam);
                break;

            case PSN_RESET:
                break;
        }
        break;

    case WM_INITDIALOG:
        _OnInitAppearanceDlg(hDlg);
        break;

    case WM_DESTROY:
        _OnDestroy(hDlg);
        break;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_BASEAPPEARANCE, HELP_WM_HELP, (DWORD_PTR) aBaseAppearanceHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, SZ_HELPFILE_BASEAPPEARANCE, HELP_CONTEXTMENU, (DWORD_PTR) aBaseAppearanceHelpIds);
        break;

    case WM_COMMAND:
        _OnCommand(hDlg, message, wParam, lParam);
        break;

    case WMUSER_DELAYENABLEAPPLY:
        EnableApplyButton(hDlg);
        break;
    }

    return FALSE;
}


HRESULT CBaseAppearancePage::_LoadState(void)
{
    HRESULT hr = S_OK;

    if (!m_fLoadedAdvState)
    {
        m_advDlgState.dwChanged = NO_CHANGE;

        if (m_pSelectedThemeScheme && m_pSelectedStyle && m_pSelectedSize)
        {
            hr = SystemMetricsAll_Load(m_pSelectedSize, &m_advDlgState, &m_nNewDPI);
            if (SUCCEEDED(hr))
            {
                m_fLoadedAdvState = TRUE;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


BOOL IsSkinScheme(IN IThemeScheme * pThemeScheme)
{
    BOOL fIsSkin = !IUnknown_CompareCLSID(pThemeScheme, CLSID_LegacyAppearanceScheme);
    return fIsSkin;
}


/*****************************************************************************\
    DESCRIPTION:
        This method will turn on or off the visual style.
\*****************************************************************************/
HRESULT CBaseAppearancePage::_ApplyScheme(IThemeScheme * pThemeScheme, IThemeStyle * pColorStyle, IThemeSize * pThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pThemeScheme && pColorStyle && pThemeSize)
    {
        hr = pColorStyle->put_SelectedSize(pThemeSize);
        if (SUCCEEDED(hr))
        {
            hr = pThemeScheme->put_SelectedStyle(pColorStyle);
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrPath;

                if (IsSkinScheme(pThemeScheme) &&
                    SUCCEEDED(hr = pThemeScheme->get_Path(&bstrPath)) &&
                    SUCCEEDED(CheckThemeSignature(bstrPath)))
                {
                    CComBSTR bstrStyle;

                    hr  = pColorStyle->get_Name(&bstrStyle);
                    if (SUCCEEDED(hr))
                    {
                        CComBSTR bstrSize;

                        hr = pThemeSize->get_Name(&bstrSize);
                        if (SUCCEEDED(hr))
                        {
                            hr = ApplyVisualStyle(bstrPath, bstrStyle, bstrSize);

                            if (FAILED(hr))
                            {
                                HWND hwndParent = NULL;

                                // We want to display UI if an error occured here.  We want to do
                                // it instead of our parent because THEMELOADPARAMS contains
                                // extra error information that we can't pass back to the caller.
                                // However, we will only display error UI if our caller wants us
                                // to.  We determine that by the fact that they make an hwnd available
                                // to us.  We get the hwnd by getting our site pointer and getting
                                // the hwnd via ::GetWindow().
                                if (_punkSite && SUCCEEDED(IUnknown_GetWindow(_punkSite, &hwndParent)))
                                {
                                    hr = DisplayThemeErrorDialog(hwndParent, hr, IDS_ERROR_TITLE_APPLYBASEAPPEARANCE, IDS_ERROR_APPLYBASEAPPEARANCE_LOADTHEME);
                                }
                            }
                        }
                    }
                }
                else
                {
                    // Unload any existing skin.
                    ApplyVisualStyle(NULL, NULL, NULL);

                    // Ignore the error value, the service could be down
                    hr = S_OK;
                }

                IPropertyBag * pPropertyBag;

                if (SUCCEEDED(pThemeSize->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag))))
                {
                    TCHAR szLegacyName[MAX_PATH];

                    // Here, we need to update a regkey with the selected legacy name. That way we can tell if
                    // 3rd party UI or downlevel OSs change the Win2k "Appearance Scheme".  If they do, uxtheme (LMouton)
                    // will disable visual styles on the next login.  This will make sure we don't get someone else's
                    // NONCLIENTMETRICS and our visual style.
                    if (FAILED(SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_COLORSCHEME_LEGACYNAME, szLegacyName, ARRAYSIZE(szLegacyName))))
                    {
                        szLegacyName[0] = 0;
                    }

                    HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_APPEARANCE, THEMEPROP_NEWCURRSCHEME, szLegacyName);
                    HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_APPEARANCE, SZ_REGVALUE_CURRENT, szLegacyName);
                    pPropertyBag->Release();
                }
            }
        }
    }

    return hr;
}



HRESULT CBaseAppearancePage::_SaveState(CDimmedWindow* pDimmedWindow)
{
    HRESULT hr = S_OK;

    BOOL fIsSkinApplied = IsThemeActive();      // This will keep track if a skin was applied before this apply action.
    LogStatus("IsThemeActive() returned %hs in CBaseAppearancePage::_SaveState.\r\n", (fIsSkinApplied ? "TRUE" : "FALSE"));

    // If we are switching from NoSkin->Skin, we want to save the live settings before
    // we turn on the skin (now & here).  We do this so we can reload these settings
    // if the user turns Skins off later.  This acts like a "Custom" settings option.
    if (!fIsSkinApplied && !IUnknown_CompareCLSID(m_pSelectedThemeScheme, CLSID_LegacyAppearanceScheme))
    {
        hr = _SaveLiveSettings(SZ_SAVEGROUP_NOSKIN);        // If we are switching from "NoSkin" to "Skin", we want to save the custom settings now.
    }

    hr = _ApplyScheme(m_pSelectedThemeScheme, m_pSelectedStyle, m_pSelectedSize);
    if (SUCCEEDED(hr))
    {
        m_nSelectedScheme = ComboBox_GetCurSel(m_hwndSchemeDropDown);
        m_nSelectedStyle = ComboBox_GetCurSel(m_hwndStyleDropDown);
        m_nSelectedSize = ComboBox_GetCurSel(m_hwndSizeDropDown);
    }

    if (SUCCEEDED(hr))
    {
        // Here we save the settings no matter which direction we are going.  These
        // settings will be loaded when the Display Control Panel is opened next time.
        hr = _SaveLiveSettings(SZ_SAVEGROUP_ALL);
    }

    // We normally want the call to IThemeManager->put_SelectedScheme() to not only 
    // store the selection but to also update the live system metrics.  We special case
    // the Legacy "Appearance Schemes" because the user could have customized the
    // settings in the Advanced Appearance dialog.  If they did, then m_advDlgState.dwChanged
    // will have dirty bits set and we need to apply that state ourselves.
    if (m_advDlgState.dwChanged)
    {
        hr = SystemMetricsAll_Set(&m_advDlgState, pDimmedWindow);
        LogSystemMetrics("CBaseAppearancePage::_SaveState() pushing to live", &m_advDlgState);
    }

    if (SUCCEEDED(hr))
    {
        m_advDlgState.dwChanged = NO_CHANGE;
        m_fIsDirty = FALSE;
    }

    return hr;
}


// If we are switching from "NoSkin" to "Skin", we want to save the custom settings now.
HRESULT CBaseAppearancePage::_LoadLiveSettings(IN LPCWSTR pszSaveGroup)
{
    HRESULT hr = S_OK;

    if (!m_fLoadedAdvState)
    {
#ifndef FEATURE_SAVECUSTOM_APPEARANCE
        if (!StrCmpI(pszSaveGroup, SZ_SAVEGROUP_ALL))
        {
            SystemMetricsAll_Get(&m_advDlgState);
            LogSystemMetrics("LOADING SYSMETRICS: ", &m_advDlgState);
            m_fLoadedAdvState = TRUE;
        }
        else
        {
            hr = E_FAIL;        // The caller needs to get their own system metrics.
        }

#else // FEATURE_SAVECUSTOM_APPEARANCE
        AssertMsg((NULL != m_pSelectedThemeScheme), TEXT("_LoadLiveSettings() can't get it's job done without m_pSelectedThemeScheme"));
        if (m_pSelectedThemeScheme)
        {
            IThemeScheme * pThemeScheme;

            hr = CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, &pThemeScheme));
            if (SUCCEEDED(hr))
            {
                CComVariant varCurrentNameBSTR(pszSaveGroup);
                IThemeStyle * pSelectedStyle;

                // The next call may fail because we may have never saved the settings yet.
                hr = pThemeScheme->get_item(varCurrentNameBSTR, &pSelectedStyle);
                if (FAILED(hr))
                {
                    // So, let's save the settings now.
                    hr = _SaveLiveSettings(pszSaveGroup);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_pSelectedThemeScheme->get_item(varCurrentNameBSTR, &pSelectedStyle);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    IThemeSize * pSelectedSize;
                    VARIANT varIndex;

                    varIndex.vt = VT_I4;
                    varIndex.lVal = 0;
                    hr = pSelectedStyle->get_item(varIndex, &pSelectedSize);

                    if (FAILED(hr))
                    {
                        HKEY hKeyTemp;

                        if (SUCCEEDED(HrRegOpenKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_UPGRADE_KEY, 0, KEY_READ, &hKeyTemp)))
                        {
                            RegCloseKey(hKeyTemp);
                        }
                        else
                        {
                            // If this happens, we may not have saved the previous settings.  So do that now
                            // and retry.
                            _SaveLiveSettings(pszSaveGroup);
                            hr = pSelectedStyle->get_item(varIndex, &pSelectedSize);
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        if (SUCCEEDED(SystemMetricsAll_Load(pSelectedSize, &m_advDlgState, &m_nNewDPI)))
                        {
                            LogSystemMetrics("LOADING SYSMETRICS: ", &m_advDlgState);
                            m_fLoadedAdvState = TRUE;
                        }

                        pSelectedSize->Release();
                    }

                    pSelectedStyle->Release();
                }

                pThemeScheme->Release();
            }
        }
        else
        {
            hr = E_FAIL;
        }
#endif // FEATURE_SAVECUSTOM_APPEARANCE
    }

    return hr;
}


HRESULT CBaseAppearancePage::_SaveLiveSettings(IN LPCWSTR pszSaveGroup)
{
    HRESULT hr = S_OK;

    // Now, get the current (possibly custom) settings and save them.
    SYSTEMMETRICSALL state = {0};

    hr = SystemMetricsAll_Get(&state);
    if (SUCCEEDED(hr))
    {
        IThemeScheme * pThemeScheme;

        LogSystemMetrics("CBaseAppearancePage::_SaveLiveSettings() getting live", &state);
        hr = CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, &pThemeScheme));
        if (SUCCEEDED(hr))
        {
            CComVariant varCurrentNameBSTR(pszSaveGroup);        // The "Customized Live" item
            IThemeStyle * pSelectedStyle;

            hr = pThemeScheme->get_item(varCurrentNameBSTR, &pSelectedStyle);
            if (SUCCEEDED(hr))
            {
                IThemeSize * pSelectedSize;
                VARIANT varIndex;

                varIndex.vt = VT_I4;
                varIndex.lVal = 0;
                hr = pSelectedStyle->get_item(varIndex, &pSelectedSize);
                if (FAILED(hr))
                {
                    hr = pSelectedStyle->AddSize(&pSelectedSize);
                }

                if (SUCCEEDED(hr))
                {
                    hr = SystemMetricsAll_Save(&state, pSelectedSize, &m_nNewDPI);
                    
                    CHAR szTemp[MAX_PATH];
                    StringCchPrintfA(szTemp, ARRAYSIZE(szTemp), "CBaseAppearancePage::_SaveLiveSettings() Grp=\"%ls\", new DPI=%d", pszSaveGroup, m_nNewDPI);
                    LogSystemMetrics(szTemp, &state);

                    pSelectedSize->Release();
                }

                pSelectedStyle->Release();
            }

            pThemeScheme->Release();
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_LoadVisaulStyleFile(IN LPCWSTR pszPath)
{
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(CheckThemeSignature(pszPath)))
    {
        // Now we want to:
        int nSlot = -1;
        int nCount = ComboBox_GetCount(m_hwndSchemeDropDown);

        hr = S_OK;

        // 1. Is it in the list already?
        for (int nIndex = 0; nIndex < nCount; nIndex++)
        {
            IThemeScheme * pThemeScheme = (IThemeScheme *) ComboBox_GetItemData(m_hwndSchemeDropDown, nIndex);

            if (pThemeScheme)
            {
                CComBSTR bstrPath;

                hr = pThemeScheme->get_Path(&bstrPath);
                if (SUCCEEDED(hr))
                {
                    if (!StrCmpIW(bstrPath, pszPath))
                    {
                        bstrPath.Empty();
                        // We found it, so stop looking.
                        nSlot = nIndex;
                        break;
                    }
                }
            }
        }

        // 2. If it is not in the list, add it.  We put it on the bottom, right above "Other...".
        if (-1 == nSlot)
        {
            IThemeScheme * pThemeSchemeNew;

            hr = CSkinScheme_CreateInstance(pszPath, &pThemeSchemeNew);
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrDisplayName;

                hr = pThemeSchemeNew->get_DisplayName(&bstrDisplayName);
                if (SUCCEEDED(hr))
                {
                    nIndex = ComboBox_GetCount(m_hwndSchemeDropDown);

                    if (nIndex > 1)
                    {
                        nIndex -= 1;
                    }

                    nSlot = nIndex = ComboBox_InsertString(m_hwndSchemeDropDown, nIndex, bstrDisplayName);
                    if ((CB_ERR != nIndex) && (CB_ERRSPACE != nIndex))
                    {
                        if (CB_ERR == ComboBox_SetItemData(m_hwndSchemeDropDown, nIndex, pThemeSchemeNew))
                        {
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if (FAILED(hr))
                {
                    pThemeSchemeNew->Release();
                }
            }
        }

        if (-1 != nSlot)
        {
            ComboBox_SetCurSel(m_hwndSchemeDropDown, nIndex);

            // 3. Select the theme from the list.
            if (CB_ERR != ComboBox_GetItemData(m_hwndSchemeDropDown, ComboBox_GetCurSel(m_hwndSchemeDropDown)))
            {
                // Okay, we now know we won't recurse infinitely, so let's recurse.
                hr = _OnSchemeChange(_hwnd, FALSE);     // FALSE means don't display error dialogs
                if (SUCCEEDED(hr))
                {
                    // Since this happens during WM_INITDIALOG, we need to delay enabling the Apply button.
                    DelayEnableApplyButton(_hwnd);
                }
            }
            else
            {
                hr = E_FAIL;
                AssertMsg(0, TEXT("We should have correctly selected the item.  Please investiate.  -BryanSt"));
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}



//===========================
// *** IObjectWithSite Interface ***
//===========================
HRESULT CBaseAppearancePage::SetSite(IN IUnknown *punkSite)
{
    if (!punkSite)
    {
        ATOMICRELEASE(m_pThemeManager);     // This is a copy of our _punkSite and we need to break the cycle.
    }

    HRESULT hr = CObjectWithSite::SetSite(punkSite);
    if (punkSite)
    {
        // Load the defaults so we will have them if another base tab opens the advanced dlg.
        _OnInitData();
    }
    return hr;
}



//===========================
// *** IPreviewSystemMetrics Interface ***
//===========================
HRESULT CBaseAppearancePage::RefreshColors(void)
{
    UINT i;
    HKEY hk;
    TCHAR szColor[15];
    DWORD dwSize, dwType;
    int iColors[COLOR_MAX];
    COLORREF rgbColors[COLOR_MAX];

    // Open the Colors key in the registry
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_COLORS, 0, KEY_READ, &hk) != ERROR_SUCCESS)
    {
       return S_OK;
    }

    // Query for the color information
    for (i = 0; i < ARRAYSIZE(s_pszColorNames); i++)
    {
        dwSize = 15 * sizeof(TCHAR);

        if ((RegQueryValueEx(hk, s_pszColorNames[i], NULL, &dwType, (LPBYTE) szColor, &dwSize) == ERROR_SUCCESS) &&
            (REG_SZ == dwType))
        {
            m_advDlgState.schemeData.rgb[i] = ConvertColor(szColor);
        }
        else
        {
            m_advDlgState.schemeData.rgb[i] = GetSysColor(i);
        }
    }

    RegCloseKey(hk);

    // This call causes user to send a WM_SYSCOLORCHANGE
    for (i=0; i < ARRAYSIZE(rgbColors); i++)
    {
        iColors[i] = i;
        rgbColors[i] = m_advDlgState.schemeData.rgb[i] & 0x00FFFFFF;
    }

    SetSysColors(ARRAYSIZE(rgbColors), iColors, rgbColors);
    return S_OK;
}


// When another tab in the Display Control Panel changes the DPI, this tab needs
// to update any state that was based on the old DPI.  For us, this could be
// the cached data in m_advDlgState.
HRESULT CBaseAppearancePage::_ScaleSizesSinceDPIChanged(void)
{
    HRESULT hr = _LoadState();

    //Check if the DPI value has really changed since the last time we applied a DPI change.
    if (SUCCEEDED(hr) && (m_nNewDPI != m_nAppliedDPI))
    {
        CHAR szTemp[MAX_PATH];

        StringCchPrintfA(szTemp, ARRAYSIZE(szTemp), "CBaseAppear::_ScaleSizesSinceDPIChanged() BEFORE Apply(%d)->New(%d) on DPI chang", m_nAppliedDPI, m_nNewDPI);
        LogSystemMetrics(szTemp, &m_advDlgState);

        // Cycle through all the UI fonts and change their sizes.
        DPIConvert_SystemMetricsAll(FALSE, &m_advDlgState, m_nAppliedDPI, m_nNewDPI);

        StringCchPrintfA(szTemp, ARRAYSIZE(szTemp), "CBaseAppear::_ScaleSizesSinceDPIChanged() AFTER Apply(%d)->New(%d) on DPI chang", m_nAppliedDPI, m_nNewDPI);
        LogSystemMetrics(szTemp, &m_advDlgState);

        m_nAppliedDPI = m_nNewDPI;
        m_fIsDirty = TRUE;
        m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
        _UpdatePreview(FALSE);
    }

    return hr;
}


HRESULT CBaseAppearancePage::UpdateCharsetChanges(void)
{
    return FixFontsOnLanguageChange();
}


/**************************************************************\
    DESCRIPTION:
        We shipped this API long ago.  The goal is to:
    1. Set the current "Appearance Scheme".
    2. If the UI is displayed, update the UI.
    3. Apply the changes.
\**************************************************************/
HRESULT CBaseAppearancePage::DeskSetCurrentScheme(IN LPCWSTR pwzSchemeName)
{
    int nIndex;
    HRESULT hr = E_INVALIDARG;

    if (pwzSchemeName)
    {
        TCHAR szTemp[MAX_PATH];

        if (!pwzSchemeName[0])
        {
            if (LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szTemp, ARRAYSIZE(szTemp)))
            {
                pwzSchemeName = szTemp;
            }
        }

        LoadConversionMappings();   // Load theme if needed.
        hr = MapLegacyAppearanceSchemeToIndex(pwzSchemeName, &nIndex);        // Failure means, FALSE, we didn't convert.
        if (SUCCEEDED(hr) && _punkSite)
        {
            IThemeManager * pThemeManager;

            hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeManager, &pThemeManager));
            if (SUCCEEDED(hr))
            {
                hr = InstallVisualStyle(pThemeManager, L"", g_UpgradeMapping[nIndex].szNewColorSchemeName, g_UpgradeMapping[nIndex].szNewSizeName);
                if (SUCCEEDED(hr))
                {
                    // This ApplyNow() call will take a little while in normal situation (~10-20 seconds) in order
                    // to broadcast the message to all open apps.  If a top level window is hung, it may take the
                    // full 30 seconds to timeout.
                    hr = pThemeManager->ApplyNow();

                    // We need to delete the "Live settings" because they are no longer valid.
                    SHDeleteKey(HKEY_CURRENT_USER, SZ_SAVEGROUP_NOSKIN_KEY);
                    SHDeleteKey(HKEY_CURRENT_USER, SZ_SAVEGROUP_ALL_KEY);
                }

                IUnknown_SetSite(pThemeManager, NULL);      // Break the ref-count cycle.
                pThemeManager->Release();
            }
        }
    }

    LogStatus("DeskSetCurrentScheme(\"%ls\") returned hr=%#08lx.\r\n", pwzSchemeName, hr);
    return hr;
}





//===========================
// *** IPropertyBag Interface ***
//===========================
HRESULT CBaseAppearancePage::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    _OnInitData();
    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_VISUALSTYLE_PATH) && m_pSelectedThemeScheme)
        {
            CComBSTR bstrPath;

            hr = m_pSelectedThemeScheme->get_Path(&bstrPath);
            if (FAILED(hr))
            {
                bstrPath = L"";
                hr = S_OK;          // We return an empty string for "Windows Classic" since they ask for the path.
            }

            pVar->vt = VT_BSTR;
            hr = HrSysAllocString(bstrPath, &pVar->bstrVal);
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_VISUALSTYLE_COLOR) && m_pSelectedStyle)
        {
            CComBSTR bstrName;

            hr = m_pSelectedStyle->get_Name(&bstrName);
            if (SUCCEEDED(hr))
            {
                pVar->vt = VT_BSTR;
                hr = HrSysAllocString(bstrName, &pVar->bstrVal);
            }
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_VISUALSTYLE_SIZE) && m_pSelectedSize)
        {
            CComBSTR bstrName;

            hr = m_pSelectedSize->get_Name(&bstrName);
            if (SUCCEEDED(hr))
            {
                pVar->vt = VT_BSTR;
                hr = HrSysAllocString(bstrName, &pVar->bstrVal);
            }
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_SYSTEM_METRICS))
        {
            hr = _LoadState();

            // This is pretty ugly.
            pVar->vt = VT_BYREF;
            pVar->byref = &m_advDlgState;
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_BACKGROUND_COLOR))
        {
            hr = _LoadState();

            // This is pretty ugly.
            pVar->vt = VT_UI4;
            pVar->ulVal = m_advDlgState.schemeData.rgb[COLOR_BACKGROUND];
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_DPI_MODIFIED_VALUE))
        {
            pVar->vt = VT_I4;
            pVar->lVal = m_nNewDPI;
            hr = S_OK;
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_DPI_APPLIED_VALUE))
        {
            pVar->vt = VT_I4;
            pVar->lVal = m_nAppliedDPI;
            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    _OnInitData();
    if (pszPropName && pVar)
    {
        if (VT_BSTR == pVar->vt)
        {
            if (!StrCmpW(pszPropName, SZ_PBPROP_VISUALSTYLE_PATH))
            {
                hr = _OutsideSetScheme(pVar->bstrVal);
            }
            else if (!StrCmpW(pszPropName, SZ_PBPROP_VISUALSTYLE_COLOR))
            {
                hr = _OutsideSetStyle(pVar->bstrVal);
            }
            else if (!StrCmpW(pszPropName, SZ_PBPROP_VISUALSTYLE_SIZE))
            {
                hr = _OutsideSetSize(pVar->bstrVal);
            }
        }
        else if ((VT_BYREF == pVar->vt) && pVar->byref)
        {
            if (!StrCmpW(pszPropName, SZ_PBPROP_SYSTEM_METRICS))
            {
                hr = S_OK;
                if (!m_fLoadedAdvState)
                {
                    AssertMsg((NULL != m_pSelectedSize), TEXT("m_pSelectedSize should have already been loaded by now or we shouldn't be showing the Adv Appearance page. -BryanSt"));
                    hr = SystemMetricsAll_Load(m_pSelectedSize, &m_advDlgState, &m_nNewDPI);
                    if (SUCCEEDED(hr))
                    {
                        m_fLoadedAdvState = TRUE;
                    }
                }

                SystemMetricsAll_Copy((SYSTEMMETRICSALL *) pVar->byref, &m_advDlgState);
                m_fIsDirty = TRUE;
                m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
            }
        }
        else if ((VT_UI4 == pVar->vt) &&
            !StrCmpW(pszPropName, SZ_PBPROP_BACKGROUND_COLOR))
        {
            hr = S_OK;
            if (!m_fLoadedAdvState)
            {
                AssertMsg((NULL != m_pSelectedSize), TEXT("m_pSelectedSize should have already been loaded by now or we shouldn't be showing the Adv Appearance page. -BryanSt"));
                hr = SystemMetricsAll_Load(m_pSelectedSize, &m_advDlgState, &m_nNewDPI);
                if (SUCCEEDED(hr))
                {
                    m_fLoadedAdvState = TRUE;
                }
            }

            // This is pretty ugly.
            m_advDlgState.schemeData.rgb[COLOR_BACKGROUND] = pVar->ulVal;
            m_fIsDirty = TRUE;
            m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
        }
        else if ((VT_LPWSTR == pVar->vt) &&
            !StrCmpW(pszPropName, SZ_PBPROP_APPEARANCE_LAUNCHMSTHEME))
        {
            Str_SetPtrW(&m_pszLoadMSTheme, pVar->bstrVal);
            hr = S_OK;
        }
        else if (VT_I4 == pVar->vt)
        {
            if (!StrCmpW(pszPropName, SZ_PBPROP_DPI_MODIFIED_VALUE))
            {
                m_nNewDPI = pVar->lVal;
                hr = _ScaleSizesSinceDPIChanged(); // Scale all the values.
            }
            else if (!StrCmpW(pszPropName, SZ_PBPROP_DPI_APPLIED_VALUE))
            {
                m_nAppliedDPI = pVar->lVal;
                hr = S_OK;
            }
        }
    }

    return hr;
}


//===========================
// *** IBasePropPage Interface ***
//===========================
HRESULT CBaseAppearancePage::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        *ppAdvDialog = NULL;
        hr = _LoadState();
        if (SUCCEEDED(hr))
        {
            _ScaleSizesSinceDPIChanged();  // We want to update our settings if someone changed the DPI
            hr = CAdvAppearancePage_CreateInstance(ppAdvDialog, &m_advDlgState);
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    HRESULT hr = S_OK;

    if (PPOAACTION_CANCEL != oaAction)
    {
        HCURSOR old = SetCursor(LoadCursor(NULL, IDC_WAIT));

        if (_IsDirty())
        {
            //Check to see if there is a change in the DPI value due to "Advanced->General" tab.
            _ScaleSizesSinceDPIChanged();
            // Update the "AppliedDPI" value in the registry.
            HrRegSetDWORD(HKEY_CURRENT_USER, SZ_WINDOWMETRICS, SZ_APPLIEDDPI, m_nNewDPI);
            LogStatus("DPI: SYSTEMMETRICS saved at %d DPI  CBaseAppearancePage::OnApply\r\n", m_nNewDPI);

            CDimmedWindow* pDimmedWindow = NULL;
            if (!g_fInSetup)
            {
                pDimmedWindow = new CDimmedWindow(HINST_THISDLL);
                if (pDimmedWindow)
                {
                    pDimmedWindow->Create(30000);
                }
            }

            hr = _SaveState(pDimmedWindow);

            if (pDimmedWindow)
            {
                pDimmedWindow->Release();
            }

            if (FAILED(hr) && !g_fInSetup && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
            {
                // We want to display UI here.  Especially if we fail.
                HWND hwndParent = GetParent(m_hwndSchemeDropDown);
                WCHAR szTitle[MAX_PATH];

                LoadString(HINST_THISDLL, IDS_ERROR_TITLE_APPLYBASEAPPEARANCE2, szTitle, ARRAYSIZE(szTitle));
                ErrorMessageBox(hwndParent, szTitle, IDS_ERROR_APPLYBASEAPPEARANCE, hr, NULL, (MB_OK | MB_ICONEXCLAMATION));

                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
        }

        SetCursor(old);
    }

    if (PPOAACTION_OK == oaAction)
    {
    }
    
    return hr;
}




//===========================
// *** IShellPropSheetExt Interface ***
//===========================
HRESULT CBaseAppearancePage::AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam)
{
    HRESULT hr = E_INVALIDARG;
    PROPSHEETPAGE psp = {0};

    psp.dwSize = sizeof(psp);
    psp.hInstance = HINST_THISDLL;
    psp.dwFlags = PSP_DEFAULT;
    psp.lParam = (LPARAM) this;

    psp.pszTemplate = MAKEINTRESOURCE(DLG_APPEARANCEPG);
    psp.pfnDlgProc = CBaseAppearancePage::BaseAppearanceDlgProc;

    HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);
    if (hpsp)
    {
        if (pfnAddPage(hpsp, lParam))
        {
            hr = S_OK;
        }
        else
        {
            DestroyPropertySheetPage(hpsp);
            hr = E_FAIL;
        }
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
ULONG CBaseAppearancePage::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CBaseAppearancePage::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CBaseAppearancePage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CBaseAppearancePage, IObjectWithSite),
        QITABENT(CBaseAppearancePage, IOleWindow),
        QITABENT(CBaseAppearancePage, IPersist),
        QITABENT(CBaseAppearancePage, IPropertyBag),
        QITABENT(CBaseAppearancePage, IPreviewSystemMetrics),
        QITABENT(CBaseAppearancePage, IBasePropPage),
        QITABENTMULTI(CBaseAppearancePage, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CBaseAppearancePage::CBaseAppearancePage() : m_cRef(1), CObjectCLSID(&PPID_BaseAppearance)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pThemeManager);
    ASSERT(!m_pSelectedThemeScheme);
    ASSERT(!m_pSelectedStyle);
    ASSERT(!m_pSelectedSize);
    ASSERT(!m_hwndSchemeDropDown);
    ASSERT(!m_hwndStyleDropDown);
    ASSERT(!m_hwndSizeDropDown);
    ASSERT(!m_pThemePreview);
    ASSERT(!m_fIsDirty);

    m_fInitialized = FALSE;
}


CBaseAppearancePage::~CBaseAppearancePage()
{
    Str_SetPtrW(&m_pszLoadMSTheme, NULL);

    ATOMICRELEASE(m_pThemeManager);
    ATOMICRELEASE(m_pSelectedThemeScheme);
    ATOMICRELEASE(m_pSelectedStyle);
    ATOMICRELEASE(m_pSelectedSize);
    ATOMICRELEASE(m_pThemePreview);

    DllRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\classfactory.cpp ===
/*****************************************************************************\
    FILE: classfactory.cpp

    DESCRIPTION:
       This file will be the Class Factory.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "classfactory.h"
#include "EffectsBasePg.h"
#include "ScreenSaverPg.h"
#include "store.h"


/*****************************************************************************
 *
 *  CClassFactory
 *
 *
 *****************************************************************************/

HRESULT CSettingsPage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
HRESULT CDisplaySettings_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
HRESULT CScreenResFixer_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);

class CClassFactory       : public IClassFactory
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IClassFactory ***
    virtual STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    virtual STDMETHODIMP LockServer(BOOL fLock);

public:
    CClassFactory(REFCLSID rclsid);
    ~CClassFactory(void);

    // Friend Functions
    friend HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);

protected:
    long                    m_cRef;
    CLSID                   m_rclsid;
};



/*****************************************************************************
 *  IClassFactory::CreateInstance
 *****************************************************************************/

HRESULT CClassFactory::CreateInstance(IUnknown * punkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != ppvObj)
    {
        if (!punkOuter)
        {
            if (IsEqualCLSID(m_rclsid, CLSID_ThemeManager))
            {
                hr = CThemeManager_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_ThemeUIPages))
            {
                hr = CThemeUIPages_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_ThemePreview))
            {
                hr = CThemePreview_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_EffectsPage))
            {
                hr = CEffectsBasePage_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_SettingsPage))
            {
                hr = CSettingsPage_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_DisplaySettings))
            {
                hr = CDisplaySettings_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_ScreenResFixer))
            {
                hr = CScreenResFixer_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_ScreenSaverPage))
            {
                hr = CScreenSaverPage_CreateInstance(punkOuter, riid, ppvObj);
            }
            else
            {
                TCHAR szGuid[GUIDSTR_MAX];

                SHStringFromGUID(m_rclsid, szGuid, ARRAYSIZE(szGuid));
                AssertMsg(0, TEXT("CClassFactory::CreateInstance(%s) failed because we don't support that CLSID.  This is because someone made a registration bug."), szGuid);  // What are you looking for?
                hr = E_NOINTERFACE;
            }
        }
        else
        {   // Does anybody support aggregation any more?
            hr = ResultFromScode(CLASS_E_NOAGGREGATION);
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  IClassFactory::LockServer
 *
 *  What a poor function.  Locking the server is identical to
 *  creating an object and not releasing it until you want to unlock
 *  the server.
 *
 *****************************************************************************/

HRESULT CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}

/*****************************************************************************
 *
 *  CClassFactory_Create
 *
 *****************************************************************************/

/****************************************************\
    Constructor
\****************************************************/
CClassFactory::CClassFactory(REFCLSID rclsid) : m_cRef(1)
{
    m_rclsid = rclsid;
    DllAddRef();
}


/****************************************************\
    Destructor
\****************************************************/
CClassFactory::~CClassFactory()
{
    DllRelease();
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CClassFactory::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualCLSID(riid, IID_IUnknown) || IsEqualCLSID(riid, IID_IClassFactory))
    {
        *ppvObj = SAFECAST(this, IClassFactory *);
    }
    else
    {
        TraceMsg(TF_WMTHEME, "CClassFactory::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}



HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    if (IsEqualCLSID(riid, IID_IClassFactory))
    {
        *ppvObj = (LPVOID) new CClassFactory(rclsid);
        hres = (*ppvObj) ? S_OK : E_OUTOFMEMORY;
    }
    else
        hres = ResultFromScode(E_NOINTERFACE);

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\classfactory.h ===
/*****************************************************************************\
    FILE: classfactory.h

    DESCRIPTION:
       This file will be the Class Factory.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/


HRESULT CThemeManager_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
HRESULT CThemePreview_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\baseappearpg.h ===
/*****************************************************************************\
    FILE: BaseAppearPg.h

    DESCRIPTION:
        This code will display a "Appearances" tab in the
    "Display Properties" dialog (the base dialog, not the advanced dlg).

    ??????? ?/??/1993    Created
    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#ifndef _BASEAPPEAR_H
#define _BASEAPPEAR_H

#include <cowsite.h>
#include "PreviewTh.h"


class CBaseAppearancePage       : public CObjectWithSite
                                , public CObjectWindow
                                , public CObjectCLSID
                                , public IPropertyBag
                                , public IPreviewSystemMetrics
                                , public IBasePropPage
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IBasePropPage ***
    virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
    virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam) {return E_NOTIMPL;}

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IObjectWithSite ***
    virtual STDMETHODIMP SetSite(IUnknown *punkSite);

    // *** IPreviewSystemMetrics ***
    virtual STDMETHODIMP RefreshColors(void);
    virtual STDMETHODIMP UpdateDPIchange(void) {return E_NOTIMPL;}
    virtual STDMETHODIMP UpdateCharsetChanges(void);
    virtual STDMETHODIMP DeskSetCurrentScheme(IN LPCWSTR pwzSchemeName);

    CBaseAppearancePage();
protected:

private:
    virtual ~CBaseAppearancePage(void);

    // Private Member Variables
    long                    m_cRef;

    BOOL                    m_fIsDirty;                         // We need to keep track of this in case another tab dirties out bit.
    BOOL                    m_fInitialized;                     // Have we been initialized yet?
    BOOL                    m_fLockVisualStylePolicyEnabled;    // Do we lock visual styles because of a policy?
    int                     m_nSelectedScheme;
    int                     m_nSelectedStyle;
    int                     m_nSelectedSize;
    HWND                    m_hwndSchemeDropDown;
    HWND                    m_hwndStyleDropDown;
    HWND                    m_hwndSizeDropDown;
    IThemeManager *         m_pThemeManager;
    IThemeScheme *          m_pSelectedThemeScheme;
    IThemeStyle *           m_pSelectedStyle;
    IThemeSize *            m_pSelectedSize;
    IThemePreview *         m_pThemePreview;
    LPWSTR                  m_pszLoadMSTheme;                   // When we open up, load this theme.

    SYSTEMMETRICSALL        m_advDlgState;                      // This is the state we modify in the Advanced Appearance page.
    BOOL                    m_fLoadedAdvState;                  // Has the state been loaded?

    int                     m_nNewDPI;                          // This is the dirty DPI.  It equals m_nAppliedDPI if it isn't dirty.
    int                     m_nAppliedDPI;                      // This is the currently active DPI (last applied).

    // Private Member Functions
    INT_PTR _BaseAppearanceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnInitAppearanceDlg(HWND hDlg);
    HRESULT _OnInitData(void);
    HRESULT _OnDestroy(HWND hDlg);
    INT_PTR _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnSetActive(HWND hDlg);
    HRESULT _OnApply(HWND hDlg, LPARAM lParam);
    HRESULT _UpdatePreview(IN BOOL fUpdateThemePage);
    HRESULT _EnableAdvancedButton(void);                    // See if we want the Advanced button enabled.

    HRESULT _LoadState(void);
    HRESULT _SaveState(CDimmedWindow* pDimmedWindow);
    HRESULT _LoadLiveSettings(IN LPCWSTR pszSaveGroup);
    HRESULT _SaveLiveSettings(IN LPCWSTR pszSaveGroup);

    HRESULT _OnSchemeChange(HWND hDlg, BOOL fDisplayErrors);
    HRESULT _OnStyleChange(HWND hDlg);
    HRESULT _OnSizeChange(HWND hDlg);
    HRESULT _OnAdvancedOptions(HWND hDlg);
    HRESULT _OnEffectsOptions(HWND hDlg);

    HRESULT _PopulateSchemeDropdown(void);
    HRESULT _PopulateStyleDropdown(void);
    HRESULT _PopulateSizeDropdown(void);
    HRESULT _FreeSchemeDropdown(void);
    HRESULT _FreeStyleDropdown(void);
    HRESULT _FreeSizeDropdown(void);

    BOOL _IsDirty(void);
    HRESULT _SetScheme(IN BOOL fLoadSystemMetrics, IN BOOL fLoadLiveSettings, IN BOOL fPreviousSelectionIsVS);
    HRESULT _OutsideSetScheme(BSTR bstrScheme);
    HRESULT _SetStyle(IN BOOL fUpdateThemePage);
    HRESULT _OutsideSetStyle(BSTR bstrStyle);
    HRESULT _SetSize(IN BOOL fLoadSystemMetrics, IN BOOL fUpdateThemePage);
    HRESULT _OutsideSetSize(BSTR bstrSize);
    HRESULT _LoadVisaulStyleFile(IN LPCWSTR pszPath);
    HRESULT _ApplyScheme(IThemeScheme * pThemeScheme, IThemeStyle * pColorStyle, IThemeSize * pThemeSize);
    HRESULT _GetPageByCLSID(const GUID * pClsid, IPropertyBag ** ppPropertyBag);
    HRESULT _ScaleSizesSinceDPIChanged(void);

    static INT_PTR CALLBACK BaseAppearanceDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
};




#endif // _BASEAPPEAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\color2.cpp ===
/*  COLOR2.C
**
**  Copyright (C) Microsoft, 1993, All Rights Reserved.
**
**
**  History:
**
*/

#include "priv.h"

int H,L,S;                         /* Hue, Lightness, Saturation */
#define  RANGE   240                 /* range of values for HLS scrollbars */
                                     /* HLS-RGB conversions work best when
                                        RANGE is divisible by 6 */
#define  HLSMAX   RANGE
#define  RGBMAX   255
#define MIN(a, b) ((a) < (b) ? (a) : (b))

/* Color conversion routines --

   RGBtoHLS() takes a DWORD RGB value, translates it to HLS, and stores the
   results in the global vars H, L, and S.  HLStoRGB takes the current values
   of H, L, and S and returns the equivalent value in an RGB DWORD.  The vars
   H, L and S are written to only by 1) RGBtoHLS (initialization) or 2) the
   scrollbar handlers.

   A point of reference for the algorithms is Foley and Van Dam, pp. 618-19.
   Their algorithm is in floating point.  CHART implements a less general
   (hardwired ranges) integral algorithm.

*/

/* There are potential roundoff errors lurking throughout here.
   (0.5 + x/y) without floating point,
      (x/y) phrased ((x + (y/2))/y)
   yields very small roundoff error.
   This makes many of the following divisions look funny.
*/

                        /* H,L, and S vary over 0-HLSMAX */
                        /* R,G, and B vary over 0-RGBMAX */
                        /* HLSMAX BEST IF DIVISIBLE BY 6 */
                        /* RGBMAX, HLSMAX must each fit in a byte. */

#define UNDEFINED (HLSMAX*2/3)/* Hue is undefined if Saturation is 0 (grey-scale) */
                           /* This value determines where the Hue scrollbar is */
                           /* initially set for achromatic colors */

static  void   RGBtoHLS(DWORD lRGBColor)
{
   int R,G,B;                /* input RGB values */
   WORD cMax,cMin;        /* max and min RGB values */
   WORD cSum,cDif;
   int  Rdelta,Gdelta,Bdelta;  /* intermediate value: % of spread from max */

   /* get R, G, and B out of DWORD */
   R = GetRValue(lRGBColor);
   G = GetGValue(lRGBColor);
   B = GetBValue(lRGBColor);

   /* calculate lightness */
   cMax = (WORD)max( max(R,G), B);
   cMin = (WORD)min( min(R,G), B);
   cSum = cMax + cMin;
   L = (WORD)(((cSum * (DWORD)HLSMAX) + RGBMAX )/(2*RGBMAX));

   cDif = cMax - cMin;
   if (!cDif)       /* r=g=b --> achromatic case */
     {
       S = 0;                         /* saturation */
       H = UNDEFINED;                 /* hue */
     }
   else                           /* chromatic case */
     {
       /* saturation */
       if (L <= (HLSMAX/2))
           S = (WORD) (((cDif * (DWORD) HLSMAX) + (cSum / 2) ) / cSum);
       else
           S = (WORD) ((DWORD) ((cDif * (DWORD) HLSMAX) + (DWORD)((2*RGBMAX-cSum)/2) )
                                                 / (2*RGBMAX-cSum));
      /* hue */
      Rdelta = (int) (( ((cMax-R)*(DWORD)(HLSMAX/6)) + (cDif / 2) ) / cDif);
      Gdelta = (int) (( ((cMax-G)*(DWORD)(HLSMAX/6)) + (cDif / 2) ) / cDif);
      Bdelta = (int) (( ((cMax-B)*(DWORD)(HLSMAX/6)) + (cDif / 2) ) / cDif);

      if ((WORD) R == cMax)
         H = Bdelta - Gdelta;
      else if ((WORD) G == cMax)
         H = (HLSMAX/3) + Rdelta - Bdelta;
      else /* B == cMax */
         H = ((2*HLSMAX)/3) + Gdelta - Rdelta;

      if (H < 0)
         H += HLSMAX;
      if (H > HLSMAX)
         H -= HLSMAX;
   }
}

/* utility routine for HLStoRGB */
static  WORD NEAR PASCAL HueToRGB(WORD n1, WORD n2, WORD hue)
{

   /* range check: note values passed add/subtract thirds of range */

   /* The following is redundant for WORD (unsigned int) */
   if (hue > HLSMAX)
      hue -= HLSMAX;

   /* return r,g, or b value from this tridrant */
   if (hue < (HLSMAX/6))
      return ( n1 + (((n2-n1)*hue+(HLSMAX/12))/(HLSMAX/6)) );
   if (hue < (HLSMAX/2))
      return ( n2 );
   if (hue < ((HLSMAX*2)/3))
      return ( n1 + (((n2-n1)*(((HLSMAX*2)/3)-hue)+(HLSMAX/12)) / (HLSMAX/6)) );
   else
      return ( n1 );
}


static  DWORD NEAR PASCAL HLStoRGB(WORD hue, WORD lum, WORD sat)
{
  WORD R,G,B;                      /* RGB component values */
  WORD  Magic1,Magic2;       /* calculated magic numbers (really!) */

  if (sat == 0)                /* achromatic case */
    {
      R = G = B = (lum * RGBMAX) / HLSMAX;
      if (hue != UNDEFINED)
        {
         /* ERROR */
        }
    }
  else                         /* chromatic case */
    {
      /* set up magic numbers */
      if (lum <= (HLSMAX/2))
          Magic2 = (WORD)((lum * ((DWORD)HLSMAX + sat) + (HLSMAX/2))/HLSMAX);
      else
          Magic2 = lum + sat - (WORD)(((lum*sat) + (DWORD)(HLSMAX/2))/HLSMAX);
      Magic1 = 2*lum-Magic2;

      /* get RGB, change units from HLSMAX to RGBMAX */
      R = (WORD)((HueToRGB(Magic1,Magic2,(WORD)(hue+(WORD)(HLSMAX/3)))*(DWORD)RGBMAX + (HLSMAX/2))) / (WORD)HLSMAX;
      G = (WORD)((HueToRGB(Magic1,Magic2,hue)*(DWORD)RGBMAX + (HLSMAX/2))) / HLSMAX;
      B = (WORD)((HueToRGB(Magic1,Magic2,(WORD)(hue-(WORD)(HLSMAX/3)))*(DWORD)RGBMAX + (HLSMAX/2))) / (WORD)HLSMAX;
    }
  return(RGB(R,G,B));
}

DWORD FAR PASCAL AdjustLuma(DWORD rgb, int n, BOOL fScale)
{
    if (n == 0)
        return rgb;

    RGBtoHLS(rgb);

    if (fScale)
    {
        if (n > 0)
        {
            return HLStoRGB((WORD)H, (WORD)(((long)L * (1000 - n) + (RANGE + 1l) * n) / 1000), (WORD)S);
        }
        else
        {
            return HLStoRGB((WORD)H, (WORD)(((long)L * (n + 1000)) / 1000), (WORD)S);
        }
    }

    L += (int)((long)n * RANGE / 1000);

    if (L < 0)
        L = 0;
    if (L > HLSMAX)
        L = HLSMAX;

    return HLStoRGB((WORD)H, (WORD)L, (WORD)S);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\colorpic.cpp ===
/*****************************************************************************\
    FILE: colorpic.cpp

    DESCRIPTION:
        This code will display a color picker UI.

    ??????? ?/??/1993    Created
    BryanSt 3/23/2000    Updated and Converted to C++ (Bryan Starbuck)

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "AdvAppearPg.h"
#include "PreviewSM.h"

#define NUM_COLORSMAX    64
#define NUM_COLORSPERROW 4

typedef struct {
    LPCOLORPICK_INFO lpcpi;
    int dxColor;
    int dyColor;
    int iCurColor;
    int iNumColors;
    BOOL capturing;
    BOOL justdropped;
    COLORREF Colors[NUM_COLORSMAX];
} MYDATA, * PMYDATA, FAR * LPMYDATA;

BOOL g_bCursorHidden;

INT_PTR CALLBACK  ColorPickDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);

BOOL NEAR PASCAL UseColorPicker( LPCOLORPICK_INFO lpcpi )
{
    CHOOSECOLOR cc;
    extern COLORREF g_CustomColors[16];

    cc.lStructSize = sizeof(cc);
    cc.hwndOwner = lpcpi->hwndParent; // NOT lpcpi->hwndOwner
    cc.hInstance = NULL;
    cc.rgbResult = lpcpi->rgb;
    cc.lpCustColors = g_CustomColors;
    cc.Flags = CC_RGBINIT | lpcpi->flags;
    cc.lCustData = 0L;
    cc.lpfnHook = NULL;
    cc.lpTemplateName = NULL;

    if (ChooseColor(&cc))
    {
        lpcpi->rgb = cc.rgbResult;
        return TRUE;
    }

    return FALSE;
}

void NEAR PASCAL DrawColorSquare(HDC hdc, int iColor, PMYDATA pmd)
{
    RECT rc;
    COLORREF rgb;
    HPALETTE hpalOld = NULL;
    HBRUSH hbr;

    // custom color
    if (iColor == pmd->iNumColors)
    {
        rc.left = 0;
        rc.top = 0;
        rgb = pmd->lpcpi->rgb;
    }
    else
    {
        rc.left = (iColor % NUM_COLORSPERROW) * pmd->dxColor;
        rc.top = (iColor / NUM_COLORSPERROW) * pmd->dyColor;
        rgb = pmd->Colors[iColor];
    }
    rc.right = rc.left + pmd->dxColor;
    rc.bottom = rc.top + pmd->dyColor;

    // focused one
    if (iColor == pmd->iCurColor)
    {
        PatBlt(hdc, rc.left, rc.top, pmd->dxColor, 3, BLACKNESS);
        PatBlt(hdc, rc.left, rc.bottom - 3, pmd->dxColor, 3, BLACKNESS);
        PatBlt(hdc, rc.left, rc.top + 3, 3, pmd->dyColor - 6, BLACKNESS);
        PatBlt(hdc, rc.right - 3, rc.top + 3, 3, pmd->dyColor - 6, BLACKNESS);
        InflateRect(&rc, -1, -1);
        HBRUSH hBrushWhite = (HBRUSH) GetStockObject(WHITE_BRUSH);
        if (hBrushWhite)
        {
            FrameRect(hdc, &rc, hBrushWhite);
        }
        InflateRect(&rc, -2, -2);
    }
    else
    {
        // clean up possible focus thing from above
        FrameRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));

        InflateRect(&rc, -cxBorder, -cyBorder);
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
    }

    if ((pmd->lpcpi->flags & CC_SOLIDCOLOR) && !(rgb & 0xFF000000))
        rgb = GetNearestColor(hdc, rgb);

    hbr = CreateSolidBrush(rgb);
    if (pmd->lpcpi->hpal)
    {
        hpalOld = SelectPalette(hdc, pmd->lpcpi->hpal, FALSE);
        RealizePalette(hdc);
    }
    hbr = (HBRUSH) SelectObject(hdc, hbr);
    PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY);
    hbr = (HBRUSH) SelectObject(hdc, hbr);

    if (hpalOld)
    {
        hpalOld = SelectPalette(hdc, hpalOld, TRUE);
        RealizePalette(hdc);
    }

    if (hbr)
    {
        DeleteObject(hbr);
    }
}

/*
** set the focus to the given color.
**
** in the process, also take the focus off of the old focus color.
*/
void NEAR PASCAL FocusColor(HWND hDlg, int iNewColor, PMYDATA pmd)
{
    int i;
    HDC hdc = NULL;
    HWND hwnd;

    if (iNewColor == pmd->iCurColor)
        return;

    i = pmd->iCurColor;
    pmd->iCurColor = iNewColor;

    // unfocus the old one
    if( i >= 0 )
    {
        if (i == pmd->iNumColors)
            hwnd = GetDlgItem(hDlg, IDC_CPDLG_COLORCUST);
        else
            hwnd = GetDlgItem(hDlg, IDC_CPDLG_16COLORS);
        hdc = GetDC(hwnd);
        DrawColorSquare(hdc, i, pmd);
        ReleaseDC(hwnd, hdc);
    }

    // focus the new one
    if( iNewColor >= 0 )
    {
        if (iNewColor == pmd->iNumColors)
            hwnd = GetDlgItem(hDlg, IDC_CPDLG_COLORCUST);
        else
            hwnd = GetDlgItem(hDlg, IDC_CPDLG_16COLORS);
        hdc = GetDC(hwnd);
        DrawColorSquare(hdc, iNewColor, pmd);
        ReleaseDC(hwnd, hdc);
    }
}

void NEAR PASCAL Color_TrackMouse(HWND hDlg, POINT pt, PMYDATA pmd)
{
    HWND hwndKid;
    int id;

    hwndKid = ChildWindowFromPoint(hDlg, pt);
    if (hwndKid == NULL || hwndKid == hDlg)
        return;

    id = GetWindowLong(hwndKid, GWL_ID);
    switch (id)
    {
        case IDC_CPDLG_16COLORS:
            MapWindowPoints(hDlg, GetDlgItem(hDlg, IDC_CPDLG_16COLORS), &pt, 1);
            pt.x /= pmd->dxColor;
            pt.y /= pmd->dyColor;
            FocusColor(hDlg, pt.x + (pt.y * NUM_COLORSPERROW), pmd);
            break;

        case IDC_CPDLG_COLORCUST:
            if (IsWindowVisible(hwndKid))
                FocusColor(hDlg, pmd->iNumColors, pmd);
            break;

        case IDC_CPDLG_COLOROTHER:
            FocusColor(hDlg, -1, pmd);
            break;
    }
}

void NEAR PASCAL Color_DrawItem(HWND hDlg, LPDRAWITEMSTRUCT lpdis, PMYDATA pmd)
{
    int i;

    if (lpdis->CtlID == IDC_CPDLG_COLORCUST)
    {
        DrawColorSquare(lpdis->hDC, pmd->iNumColors, pmd);
    }
    else
    {
        for (i = 0; i < pmd->iNumColors; i++)
            DrawColorSquare(lpdis->hDC, i, pmd);
    }
}

/*
** init the mini-color-picker
**
** the dialog is pretending to be a menu, so figure out where to pop
** it up so that it is visible all around.
**
** also because this dialog is pretty darn concerned with its look,
** hand-align the components in pixel units.  THIS IS GROSS!
*/
void NEAR PASCAL Color_InitDialog(HWND hDlg, PMYDATA pmd)
{
    RECT rcOwner;
    RECT rc, rc2;
    int dx, dy;
    int x, y;
    int i;
    HWND hwndColors, hwnd;
    HWND hwndEtch, hwndCust;
    int  width, widthCust, widthEtch;
    int cyEdge = ClassicGetSystemMetrics(SM_CYEDGE);
    HPALETTE hpal = pmd->lpcpi->hpal;
    MONITORINFO mi;
    TCHAR szBuf[50];
    LONG cbBuf = ARRAYSIZE( szBuf );
    HDC hDC;
    SIZE size;

    if (hpal == NULL)
        hpal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);

    pmd->iNumColors = 0;
    GetObject(hpal, sizeof(int), &pmd->iNumColors);

    if (pmd->iNumColors > NUM_COLORSMAX)
        pmd->iNumColors = NUM_COLORSMAX;

    if (GetPaletteEntries(hpal,0, pmd->iNumColors, (LPPALETTEENTRY)pmd->Colors))
    {
        for (i = 0; i < pmd->iNumColors; i++)
        {
            pmd->Colors[i] &= 0x00FFFFFF;
            pmd->Colors[i] |= 0x02000000;
        }

        for (i = 0; i < pmd->iNumColors; i++)
        {
            if ((pmd->Colors[i] & 0x00FFFFFF) == (pmd->lpcpi->rgb & 0x00FFFFFF))
            {
                ShowWindow(GetDlgItem(hDlg, IDC_CPDLG_COLORCUST), SW_HIDE);
                break;
            }
        }
        // current is either one of 16 or the custom color (== pmd->iNumColors
        pmd->iCurColor = i;

        // size the 16 colors to be square
        hwndColors = GetDlgItem(hDlg, IDC_CPDLG_16COLORS);
        GetClientRect(hwndColors, &rc);

        // To make localization easy..
        //
        hwndEtch=GetDlgItem(hDlg, IDC_CPDLG_COLORETCH);
        GetClientRect(hwndEtch, &rc2);
        widthEtch = rc2.right-rc2.left;

        hwndCust=GetDlgItem(hDlg, IDC_CPDLG_COLORCUST);
        GetClientRect(hwndCust, &rc2);
        widthCust = rc2.right-rc2.left;

        hwnd = GetDlgItem(hDlg, IDC_CPDLG_COLOROTHER);
        GetWindowRect(hwnd, &rc2); // we must initialize rc2 with this control.

        // Make sure the button is big enough to contain its text
        width = rc.right - rc.left;
        if( GetDlgItemText( hDlg, IDC_CPDLG_COLOROTHER, szBuf, cbBuf ) )
        {
            RECT rcTemp;
            int iRet;
            HFONT hfont, hfontOld;  

            // Get the font for the button
            hDC = GetDC( hwnd );
            if( hDC )
            {
                hfont = (HFONT)SendMessage( hwnd, WM_GETFONT, 0, 0 );
                ASSERT(hfont);
                hfontOld = (HFONT) SelectObject( hDC, hfont );

                // Get the size of the text
                iRet = DrawTextEx( hDC, szBuf, lstrlen(szBuf), &rcTemp, DT_CALCRECT | DT_SINGLELINE, NULL );
                ASSERT( iRet );
                size.cx = rcTemp.right - rcTemp.left + 7;  //account for the button border
                size.cy = rcTemp.bottom - rcTemp.top;

                // Adjust the button size if the text needs more space
                if( size.cx > width )
                {              
                    rc2.right = rc2.left + size.cx;
                    rc2.bottom = rc2.top + size.cy;
                    MoveWindow( hwnd, rc2.left, rc2.top, rc2.right - rc2.left, rc2.bottom - rc2.top, FALSE );
                }
                SelectObject( hDC, hfontOld );
                ReleaseDC( hwnd, hDC );
            }
        }

        // Take possible biggest width to calculate sels
        //
        width = (widthEtch > widthCust+(rc2.right-rc2.left)) ? widthEtch : widthCust+(rc2.right-rc2.left);
        width = (width > rc.right-rc.left) ? width: rc.right-rc.left;

    #define NUM_COLORSPERCOL (pmd->iNumColors / NUM_COLORSPERROW)

        pmd->dxColor = pmd->dyColor
        = ((rc.bottom - rc.top) / NUM_COLORSPERCOL > width / NUM_COLORSPERROW )
          ?  (rc.bottom - rc.top) / NUM_COLORSPERCOL : width / NUM_COLORSPERROW;

        // Make sure custum color can fit
        //
        if (pmd->dxColor*(NUM_COLORSPERROW-1) < rc2.right-rc2.left )
            pmd->dxColor = pmd->dyColor = (rc2.right-rc2.left)/(NUM_COLORSPERROW-1);

        // make each color square's width the same as the height
        SetWindowPos(hwndColors, NULL, 0, 0, pmd->dxColor * NUM_COLORSPERROW,
                     pmd->dyColor * NUM_COLORSPERCOL,
                     SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER |  SWP_NOREDRAW);
        rc.right = rc.left + pmd->dxColor * NUM_COLORSPERROW;
        rc.bottom = rc.top + pmd->dyColor * NUM_COLORSPERCOL;

        MapWindowPoints(hwndColors, hDlg, (LPPOINT)(LPRECT)&rc, 2);

        // move/size the etch to the right place
        // (compensate for the colors being "inset" by one)
        MoveWindow(hwndEtch, rc.left + 1, rc.bottom + cyEdge,
                                    rc.right - rc.left - 2, cyEdge, FALSE);

        y = rc.bottom + 3 * cyEdge;

        // size the custom color to the same square and right-align
        MoveWindow(hwndCust, rc.right - pmd->dxColor, y,
                                    pmd->dxColor, pmd->dyColor, FALSE);

        // do same for button
        MapWindowPoints(NULL, hDlg, (LPPOINT)(LPRECT)&rc2, 2);
        // base the width of the custom button on the remaining space to 
        // the left of the custom color.  Also move the custom button one pix right
        // of the left edge.  This only is done if a custom color is selected...
        if (pmd->iCurColor != pmd->iNumColors) {
            // no custom color
            MoveWindow(hwnd, rc2.left, y, rc2.right-rc2.left, pmd->dyColor, FALSE);
        }
        else {
            // custom color, adjust the Other... button
            dx = rc2.right - rc2.left++;
            if (rc2.left + dx >= rc.right - pmd->dxColor - 2) 
                MoveWindow(hwnd, rc2.left, y, rc.right - pmd->dxColor - 2 , pmd->dyColor, FALSE);
            else 
                MoveWindow(hwnd, rc2.left, y, dx, pmd->dyColor, FALSE);
        }

        // now figure out the size for the dialog itself
        rc.left = rc.top = 0;
        rc.right = rc.left + pmd->dxColor * NUM_COLORSPERROW;
        // (compensate for the colors being "inset" by one)
        rc.bottom = y + pmd->dyColor + 1;

        AdjustWindowRect(&rc, GetWindowLong(hDlg, GWL_STYLE), FALSE);
        dx = rc.right - rc.left;
        dy = rc.bottom - rc.top;

        GetWindowRect(pmd->lpcpi->hwndOwner, &rcOwner);

        // Make sure the window is entirely on the monitor
        mi.cbSize = sizeof(mi);
        GetMonitorInfo(MonitorFromRect(&rcOwner, MONITOR_DEFAULTTONEAREST), &mi);

        if (rcOwner.left < mi.rcMonitor.left) { // overlap left side
            x = mi.rcMonitor.left;
        }
        else if (rcOwner.left + dx >= mi.rcMonitor.right) { // overlap right side
            x = mi.rcMonitor.right  - dx - 1;
        }
        else {                                  // no overlap
            x = rcOwner.left;
        }

        if (rcOwner.top < mi.rcMonitor.top) {   // overlap top side
            y = rcOwner.bottom;
        }
        else if (rcOwner.bottom + dy >= mi.rcMonitor.bottom) {// overlap bottom side
            y = rcOwner.top  - dy;
        }
        else {                                  // no overlap
            y = rcOwner.bottom;
        }
        MoveWindow(hDlg, x, y, dx, dy, FALSE);
    }
}

INT_PTR CALLBACK  ColorPickDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    PMYDATA pmd = (PMYDATA)GetWindowLongPtr(hDlg, DWLP_USER);
    HWND hwndKid;
    int wRet;
    int id;
    POINT pt;
    BOOL fEnd = FALSE;

    if (!pmd && (WM_INITDIALOG != message))
    {
        return FALSE;
    }

    switch(message)
    {
        case WM_INITDIALOG:
            pmd = (PMYDATA)LocalAlloc(LPTR, sizeof(MYDATA));
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pmd);
            if (pmd)
            {
                pmd->lpcpi = (LPCOLORPICK_INFO)lParam;
                pmd->capturing = FALSE;
                pmd->justdropped = TRUE;

                Color_InitDialog(hDlg, pmd);
                SetFocus(GetDlgItem(hDlg, IDC_CPDLG_16COLORS));

                // post self a message to setcapture after painting
                PostMessage(hDlg, WM_APP+1, 0, 0L);
            }
            else
            {
                EndDialog(hDlg, IDCANCEL);
            }

            return FALSE;

        case WM_APP+1:
            if (g_bCursorHidden)
            {
                ShowCursor(TRUE);
                g_bCursorHidden = FALSE;
            }
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            pmd->capturing = TRUE;
            SetCapture(hDlg);
            pmd->capturing = FALSE;
            break;

        case WM_DESTROY:
            LocalFree((HLOCAL)pmd);
            break;

        case WM_CAPTURECHANGED:
            if( pmd->capturing )
                return TRUE;   // ignore if we're doing this on purpose

            // if this wasn't a button in the dialog, dismiss ourselves
            if( !pmd->justdropped || (HWND)lParam == NULL || GetParent((HWND)lParam) != hDlg)
            {
                EndDialog(hDlg, IDCANCEL);
                return TRUE;
            }
            break;

        case WM_MOUSEMOVE:
            LPARAM2POINT(lParam, &pt );

            Color_TrackMouse(hDlg, pt, pmd);
            break;

        // if button up is on the parent, leave picker up and untrammeled.
        // otherwise, we must have "menu-tracked" to get here, so select.
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
            LPARAM2POINT(lParam, &pt);
            MapWindowPoints(hDlg, pmd->lpcpi->hwndOwner, &pt, 1);
            if (ChildWindowFromPoint(pmd->lpcpi->hwndOwner, pt))
                return 0;
            pmd->capturing = TRUE;
            pmd->justdropped = FALSE;  // user could not be dragging from owner
            ReleaseCapture();
            pmd->capturing = FALSE;
            fEnd = TRUE;
        // || fall    ||
        // || through ||
        // \/         \/
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            LPARAM2POINT(lParam, &pt);
            hwndKid = ChildWindowFromPoint(hDlg, pt);
            // assume it's a dismissal if we're going to close...
            wRet = IDCANCEL;

            // if not on parent, dismiss picker
            if (hwndKid != NULL && hwndKid != hDlg)
            {
                id = GetWindowLong(hwndKid, GWL_ID);
                switch (id)
                {
                    case IDC_CPDLG_16COLORS:
                        // make sure that iCurColor is valid
                        Color_TrackMouse(hDlg, pt, pmd);
                        pmd->lpcpi->rgb = pmd->Colors[pmd->iCurColor] & 0x00FFFFFF;

                        wRet = IDOK;
                        break;

                    case IDC_CPDLG_COLOROTHER:
                        FocusColor(hDlg, -1, pmd);
                        wRet = id;   // this will fall thru to use the picker
                        fEnd = TRUE; // we have capture, the button won't click
                        break;

                    default:
                        // if this is a down, we will track until the up
                        // if this is an up, we will close with no change
                        break;
                }
            }

            if( fEnd )
            {
                EndDialog(hDlg, wRet);
                return TRUE;
            }

            // make sure we have the capture again since we didn't close
            pmd->capturing = TRUE;
            SetCapture(hDlg);
            pmd->capturing = FALSE;
            break;

        case WM_DRAWITEM:
            Color_DrawItem(hDlg, (LPDRAWITEMSTRUCT)lParam, pmd);
            break;

        case WM_COMMAND:
            // all commands close the dialog
            // note IDC_CPDLG_COLOROTHER will fall through to the caller...
            // cannot pass ok with no color selected
            if( LOWORD(wParam) == IDOK && pmd->iCurColor < 0 )
                *((WORD *)(&wParam)) = IDCANCEL;

            EndDialog( hDlg, LOWORD(wParam) );
            break;
    }
    return FALSE;
}

BOOL WINAPI ChooseColorMini(LPCOLORPICK_INFO lpcpi)
{
    INT_PTR iAnswer;

    ShowCursor(FALSE);
    g_bCursorHidden = TRUE;

    iAnswer = DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_COLORPICK),
                        lpcpi->hwndOwner, ColorPickDlgProc, (LPARAM)lpcpi);

    if (g_bCursorHidden)
    {
        ShowCursor(TRUE);
        g_bCursorHidden = FALSE;
    }

    switch( iAnswer )
    {
        case IDC_CPDLG_COLOROTHER:  // the user picked the "Other..." button
            return UseColorPicker( lpcpi );

        case IDOK:            // the user picked a color in our little window
            return TRUE;

        default:
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\deskcplext.h ===
#define DESKCPLEXT_DISPLAY_DEVICE       TEXT("Display Device")  // "\DisplayX"
#define DESKCPLEXT_DISPLAY_NAME         TEXT("Display Name")    // " ATI Mach64 Turbo 3 "
#define DESKCPLEXT_MONITOR_DEVICE       TEXT("Monitor Device")  // " \DisplayX\MonitorX "
#define DESKCPLEXT_MONITOR_NAME         TEXT("Monitor Name")    // " NEC Multi-sync II "
#define DESKCPLEXT_PRUNING_MODE         TEXT("Pruning Mode")    // 1 = on (default value), 0 = off

#define DESKCPLEXT_DISPLAY_DEVICE_KEY   TEXT("Display Key")     // "\REGISTRY\MACHINE\SYSTEM\ControlSet00X\Services\<driver>\DeviceY"
#define DESKCPLEXT_DISPLAY_ID           TEXT("Display ID")      // "ROOT\*PNP0F03\1-0-21-0-31-0"
#define DESKCPLEXT_DISPLAY_STATE_FLAGS  TEXT("Display State Flags")
#define DESKCPLEXT_MONITOR_ID           TEXT("Monitor ID")      // "ROOT\*PNP0F04\1-0-21-0-31-0"
#define DESKCPLEXT_INTERFACE            TEXT("Desk.cpl extension interface")

typedef
LPDEVMODEW
(*LPDESKCPLEXT_ENUM_ALL_MODES) (
    LPVOID pContext,
    DWORD iMode
    );

typedef
LPDEVMODEW
(*LPDESKCPLEXT_GET_SELECTED_MODE) (
    LPVOID pContext
    );

typedef
BOOL
(*LPDESKCPLEXT_SET_SELECTED_MODE) (
    LPVOID pContext,
    LPDEVMODEW lpdm
    );

typedef
VOID 
(*LPDESKCPLEXT_GET_PRUNING_MODE) (
    LPVOID pContext,
    BOOL*  pbCanBePruned,
    BOOL*  pbIsReadOnly,
    BOOL*  pbIsPruningOn
    );
    
typedef
VOID 
(*LPDESKCPLEXT_SET_PRUNING_MODE) (
    LPVOID pContext,
    BOOL   bIsPruningOn
    );


typedef struct _DISPLAY_REGISTRY_HARDWARE_INFO {

    WCHAR MemSize[128];
    WCHAR ChipType[128];
    WCHAR DACType[128];
    WCHAR AdapString[128];
    WCHAR BiosString[128];

} DISPLAY_REGISTRY_HARDWARE_INFO, *PDISPLAY_REGISTRY_HARDWARE_INFO;




typedef struct _DESK_EXTENSION_INTERFACE {

    DWORD   cbSize;
    LPVOID  pContext;

    LPDESKCPLEXT_ENUM_ALL_MODES    lpfnEnumAllModes;
    LPDESKCPLEXT_SET_SELECTED_MODE lpfnSetSelectedMode;
    LPDESKCPLEXT_GET_SELECTED_MODE lpfnGetSelectedMode;
    LPDESKCPLEXT_SET_PRUNING_MODE  lpfnSetPruningMode;
    LPDESKCPLEXT_GET_PRUNING_MODE  lpfnGetPruningMode;
    
    DISPLAY_REGISTRY_HARDWARE_INFO Info;

} DESK_EXTENSION_INTERFACE, *PDESK_EXTENSION_INTERFACE;

#define NORMAL_TIMEOUT  7000
#define SLOW_TIMEOUT   12000

typedef
int
(*LPDISPLAY_SAVE_SETTINGS)   (
    LPVOID pContext,
    HWND   hwnd
    );

typedef
DWORD
(*LPDISPLAY_TEST_SETTINGS) (
    LPDEVMODEW lpDevMode,
    LPWSTR     pwszDevice,
    DWORD      dwTimeout
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\coverwnd.cpp ===
#include "priv.h"
#include "CoverWnd.h"
#include <ginarcid.h>

#undef IDB_BACKGROUND_24
#define IDB_BACKGROUND_24                 0x3812
#undef IDB_FLAG_24
#define IDB_FLAG_24                       0x3813

const TCHAR g_szWindowClassName[] = TEXT("CoverWindowClass");
const TCHAR g_szPleaseWaitName[] = TEXT("PleaseWaitWindowClass");

#define CHUNK_SIZE           20
#define IDT_KILLYOURSELF     1
#define IDT_UPDATE           2
#define WM_DESTORYYOURSELF      (WM_USER + 0)

void DimPixels(ULONG* pulSrc, int cLen, int Amount)
{
    for (int i = cLen - 1; i >= 0; i--)
    {
        ULONG ulR = GetRValue(*pulSrc);
        ULONG ulG = GetGValue(*pulSrc);
        ULONG ulB = GetBValue(*pulSrc);
        ULONG ulGray = (54 * ulR + 183 * ulG + 19 * ulB) >> 8;
        ULONG ulTemp = ulGray * (0xff - Amount);
        ulR = (ulR * Amount + ulTemp) >> 8;
        ulG = (ulG * Amount + ulTemp) >> 8;
        ulB = (ulB * Amount + ulTemp) >> 8;
        *pulSrc = (*pulSrc & 0xff000000) | RGB(ulR, ulG, ulB);

        pulSrc++;
    }
}

LRESULT CALLBACK PleaseWaitWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lParam)
{
    switch ( msg )
    {
    case WM_CREATE:
        {
            CREATESTRUCT* pCS = (CREATESTRUCT*)lParam;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (LPARAM) pCS->lpCreateParams );
            HBITMAP hbmBackground = (HBITMAP) pCS->lpCreateParams;
            BITMAP bm;
            if ( GetObject( hbmBackground, sizeof(bm), &bm ) )
            {
                RECT rc;
                HWND hwndParent = GetParent( hwnd );
                GetClientRect( hwndParent, &rc );

                POINT pt = {0,0};
                HMONITOR hmon = MonitorFromPoint(pt, MONITOR_DEFAULTTOPRIMARY);
                if (hmon)
                {
                    MONITORINFO mi = {sizeof(mi)};
                    GetMonitorInfo(hmon, &mi);
                    rc = mi.rcMonitor;
                    MapWindowPoints(HWND_DESKTOP, hwndParent, (LPPOINT)&rc, 2);
                }

                // Center dialog in the center of the virtual screen
                int x = ( rc.right - rc.left - bm.bmWidth ) / 2;
                int y = ( rc.bottom - rc.top - bm.bmHeight ) / 2;

                SetWindowPos( hwnd, NULL, x, y, bm.bmWidth, bm.bmHeight, SWP_NOZORDER | SWP_NOACTIVATE );
            }
        }
        return TRUE;

    case WM_PAINT:
        {
            HBITMAP hbmBackground = (HBITMAP) GetWindowLongPtr( hwnd, GWLP_USERDATA );

            PAINTSTRUCT ps;
            HDC hdc = BeginPaint( hwnd, &ps );

            BITMAP bm;

            if ( hbmBackground )
            {
                DWORD dwLayout = SetLayout(hdc, LAYOUT_BITMAPORIENTATIONPRESERVED);
                if ( GetObject( hbmBackground, sizeof(bm), &bm ) )
                {
                    HDC hdcBackground = CreateCompatibleDC( hdc );
                    if (hdcBackground)
                    {
                        HBITMAP hbmOld = (HBITMAP) SelectObject( hdcBackground, hbmBackground );
                        BitBlt(hdc, 0, 0, bm.bmWidth, bm.bmHeight, hdcBackground, 0, 0, SRCCOPY);
                        SelectObject( hdcBackground, hbmOld );
                        DeleteDC( hdcBackground );
                    }
                }
                SetLayout(hdc, dwLayout);

                // Don't draw more the once, no one will be on top of us
                DeleteObject(hbmBackground);
                SetWindowLongPtr( hwnd, GWLP_USERDATA, NULL );

                HFONT hfntSelected = NULL;
                HFONT hfntButton = NULL;
                HINSTANCE hMsGina = LoadLibrary( L"msgina.dll" );
                if ( hMsGina )
                {
                    CHAR szPixelSize[ 32 ];
                    if (LoadStringA(hMsGina,
                                    IDS_TURNOFF_TITLE_FACESIZE,
                                    szPixelSize,
                                    ARRAYSIZE(szPixelSize)) != 0)
                    {
                        LOGFONT logFont = { 0 };
                        logFont.lfHeight = -MulDiv(atoi(szPixelSize), GetDeviceCaps(hdc, LOGPIXELSY), 72);

                        if (LoadString(hMsGina,
                                       IDS_TURNOFF_TITLE_FACENAME,
                                       logFont.lfFaceName,
                                       LF_FACESIZE) != 0)
                        {
                            logFont.lfWeight = FW_BOLD;
                            logFont.lfQuality = DEFAULT_QUALITY;
                            hfntButton = CreateFontIndirect(&logFont);

                            hfntSelected = static_cast<HFONT>(SelectObject(hdc, hfntButton));
                        }
                    }                
                }

                COLORREF colorButtonText = RGB(255, 255, 255);
                COLORREF colorText = SetTextColor(hdc, colorButtonText);
                int iBkMode = SetBkMode(hdc, TRANSPARENT);

                WCHAR szText[MAX_PATH];
                szText[0] = 0;
                LoadString((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE), IDS_PLEASEWAIT, szText, ARRAYSIZE(szText));
                RECT  rcText;
                RECT  rcClient;
                RECT  rc;

                TBOOL(GetClientRect( hwnd, &rcClient ));
                TBOOL(CopyRect(&rcText, &rcClient));
                DWORD dwFlags = DT_HIDEPREFIX | (IS_MIRRORING_ENABLED() ? DT_RTLREADING : 0);
                int iPixelHeight = DrawText( hdc, szText, -1, &rcText, DT_CALCRECT | dwFlags);
                TBOOL(CopyRect(&rc, &rcClient));
                TBOOL(InflateRect(&rc, -((rc.right - rc.left - (rcText.right - rcText.left)) / 2), -((rc.bottom - rc.top - iPixelHeight) / 2)));
                (int)DrawText(hdc, szText, -1, &rc, dwFlags );
                (int)SetBkMode(hdc, iBkMode);
                (COLORREF)SetTextColor(hdc, colorText);

                if ( hfntButton )
                {
                    (HGDIOBJ)SelectObject(hdc, hfntSelected);
                    DeleteObject( hfntButton  );
                }
            }

            EndPaint( hwnd, &ps );
        }
        break;

    case WM_ERASEBKGND:
        return TRUE;

    default:
        return DefWindowProc( hwnd, msg, wp, lParam );
        break;
    }

    return 0;
}


CDimmedWindow::CDimmedWindow (HINSTANCE hInstance) :
    _lReferenceCount(1),
    _hInstance(hInstance)
{
    WNDCLASSEX  wndClassEx;

    ZeroMemory(&wndClassEx, sizeof(wndClassEx));
    wndClassEx.cbSize = sizeof(wndClassEx);
    wndClassEx.lpfnWndProc = WndProc;
    wndClassEx.hInstance = hInstance;
    wndClassEx.lpszClassName = g_szWindowClassName;
    wndClassEx.hCursor = LoadCursor(NULL, IDC_WAIT);
    _atom = RegisterClassEx(&wndClassEx);

    wndClassEx.lpszClassName = g_szPleaseWaitName;
    wndClassEx.lpfnWndProc = PleaseWaitWndProc;
    _atomPleaseWait = RegisterClassEx(&wndClassEx);
}

CDimmedWindow::~CDimmedWindow (void)
{
    if (_hwnd)
    {
        PostMessage(_hwnd, WM_DESTORYYOURSELF, 0, 0);
    }

    if (_atom != 0)
    {
        TBOOL(UnregisterClass(MAKEINTRESOURCE(_atom), _hInstance));
    }

    if (_atomPleaseWait != 0 )
    {
        TBOOL(UnregisterClass(MAKEINTRESOURCE(_atomPleaseWait), _hInstance));
    }
}

ULONG CDimmedWindow::AddRef (void)
{
    return(InterlockedIncrement(&_lReferenceCount));
}

ULONG CDimmedWindow::Release (void)
{
    ASSERTMSG(_lReferenceCount != 0, "Reference count zero in CDimmedWindow::Release");

    ULONG cRef = InterlockedDecrement(&_lReferenceCount);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

DWORD CDimmedWindow::WorkerThread(IN void *pv)
{
    ASSERT(pv);
    HWND hwnd = NULL;
    CDimmedWindow* pDimmedWindow = (CDimmedWindow*)pv;
    BOOL    fScreenReader;
    bool    fNoDebuggerPresent, fNoScreenReaderPresent;
    BOOL fUserTurnedOffWindow = SHRegGetBoolUSValue(SZ_THEMES, L"NoCoverWindow", FALSE, FALSE);     // Needed for perf testing

    fNoDebuggerPresent = !IsDebuggerPresent();
    fNoScreenReaderPresent = ((SystemParametersInfo(SPI_GETSCREENREADER, 0, &fScreenReader, 0) == FALSE) || (fScreenReader == FALSE));
    if (fNoDebuggerPresent &&
        fNoScreenReaderPresent &&
        !fUserTurnedOffWindow)
    {
        int xVirtualScreen = GetSystemMetrics(SM_XVIRTUALSCREEN);
        int yVirtualScreen = GetSystemMetrics(SM_YVIRTUALSCREEN);
        int cxVirtualScreen = GetSystemMetrics(SM_CXVIRTUALSCREEN);
        int cyVirtualScreen = GetSystemMetrics(SM_CYVIRTUALSCREEN);
        HWND hwnd = CreateWindowEx(WS_EX_TOPMOST,
                               g_szWindowClassName,
                               NULL,
                               WS_POPUP | WS_CLIPCHILDREN,
                               xVirtualScreen, yVirtualScreen,
                               cxVirtualScreen, cyVirtualScreen,
                               NULL, NULL, pDimmedWindow->_hInstance, NULL);
        if (hwnd != NULL)
        {
            bool    fDimmed;
            HBITMAP hbmBackground = NULL;

            fDimmed = false;
            (BOOL)ShowWindow(hwnd, SW_SHOW);
            TBOOL(SetForegroundWindow(hwnd));

            (BOOL)EnableWindow(hwnd, FALSE);

            SetTimer(hwnd, IDT_KILLYOURSELF, pDimmedWindow->_ulKillTimer, NULL);

            // Now create bitmap with background image and the windows flag
            HINSTANCE hShell32 = LoadLibrary( L"shell32.dll" );
            if ( NULL != hShell32 )
            {
                hbmBackground = (HBITMAP) LoadImage( hShell32, MAKEINTRESOURCE( IDB_BACKGROUND_24 ), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_DEFAULTSIZE );

                if (hbmBackground)
                {
                    HDC hdcMem1 = CreateCompatibleDC(NULL);
                    if (hdcMem1)
                    {
                        HDC hdcMem2 = CreateCompatibleDC(NULL);
                        if (hdcMem2)
                        {
                            HBITMAP hbmFlag = (HBITMAP) LoadImage( hShell32, MAKEINTRESOURCE( IDB_FLAG_24 ), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_DEFAULTSIZE );
                            if (hbmFlag)
                            {
                                HBITMAP hbmOld1 = (HBITMAP)SelectObject(hdcMem1, hbmBackground);
                                HBITMAP hbmOld2 = (HBITMAP)SelectObject(hdcMem2, hbmFlag);

                                BITMAP bm1;
                                if (GetObject(hbmBackground, sizeof(bm1), &bm1))
                                {
                                    BITMAP bm2;
                                    if (GetObject(hbmFlag, sizeof(bm2), &bm2))
                                    {
                                        BitBlt(hdcMem1, bm1.bmWidth - bm2.bmWidth - 8, 0, bm2.bmWidth, bm2.bmHeight, hdcMem2, 0, 0, SRCCOPY);
                                    }
                                }

                                SelectObject(hdcMem1, hbmOld1);
                                SelectObject(hdcMem2, hbmOld2);
                                DeleteObject(hbmFlag);
                            }
                            DeleteDC(hdcMem2);
                        }
                        DeleteDC(hdcMem1);
                    }
                }

                FreeLibrary( hShell32 );
            }

            HWND hwndPleaseWait = CreateWindowEx( 0
                                                , g_szPleaseWaitName
                                                , NULL
                                                , WS_CHILD | WS_VISIBLE | WS_BORDER
                                                , 0
                                                , 0
                                                , 100
                                                , 100
                                                , hwnd
                                                , NULL
                                                , pDimmedWindow->_hInstance
                                                , hbmBackground   // the window is responsible for freeing it.
                                                );
            if ( NULL == hwndPleaseWait )
            {
                DeleteObject( hbmBackground );
            }

            pDimmedWindow->_hwnd = hwnd;
            // This Release matches the addref during ::Create to guarantee that the object does not die before the HWND
            // is created.
            pDimmedWindow->Release();

            MSG msg;
            while (GetMessage(&msg, NULL, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
                if ((msg.message == WM_DESTORYYOURSELF) && (msg.hwnd == hwnd))
                {
                    break;
                }
            }
        }
    }

    return (hwnd == NULL ? E_FAIL : S_OK);
}

HRESULT CDimmedWindow::Create (UINT ulKillTimer)
{
    BOOL fSucceeded = FALSE;
    
    if (!_hwnd)
    {
        _ulKillTimer = ulKillTimer;
        AddRef();
        fSucceeded = SHCreateThread(CDimmedWindow::WorkerThread, (void *)this, CTF_INSIST, NULL);
        if (!fSucceeded)
        {
            Release();
        }
    }

    return fSucceeded ? S_OK : E_FAIL;
}

typedef struct
{
    HDC     hdcDimmed;
    HBITMAP hbmDimmed;
    HBITMAP hbmOldDimmed;
    HDC     hdcTemp;
    HBITMAP hbmTemp;
    HBITMAP hbmOldTemp;
    ULONG*  pulSrc;
    int     idxSaturation;
    int     idxChunk;
    int     idxProgress;
} DIMMEDWINDOWDATA;

LRESULT     CALLBACK    CDimmedWindow::WndProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT           lResult = 0;
    DIMMEDWINDOWDATA *pData;

    pData = (DIMMEDWINDOWDATA *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
        case WM_CREATE:
        {
            CREATESTRUCT* pCS = (CREATESTRUCT*)lParam;
            if (pCS)
            {
                pData = new DIMMEDWINDOWDATA;
                if (pData)
                {
                    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pData);
                    // On remote session we don't gray out the screen, yeah :-)
                    if (!GetSystemMetrics(SM_REMOTESESSION))
                    {
                        HDC hdcWindow = GetDC(hwnd);
                        if (hdcWindow != NULL )
                        {
                            pData->hdcDimmed = CreateCompatibleDC(hdcWindow);
                            if (pData->hdcDimmed)
                            {
                                BITMAPINFO  bmi;

                                ZeroMemory(&bmi, sizeof(bmi));
                                bmi.bmiHeader.biSize = sizeof(bmi);
                                bmi.bmiHeader.biWidth =  pCS->cx;
                                bmi.bmiHeader.biHeight = pCS->cy;
                                bmi.bmiHeader.biPlanes = 1;
                                bmi.bmiHeader.biBitCount = 32;
                                bmi.bmiHeader.biCompression = BI_RGB;
                                bmi.bmiHeader.biSizeImage = 0;

                                pData->hbmDimmed = CreateDIBSection(pData->hdcDimmed, &bmi, DIB_RGB_COLORS, (LPVOID*)&pData->pulSrc, NULL, 0);
                                if (pData->hbmDimmed != NULL)
                                {
                                    pData->hbmOldDimmed = (HBITMAP) SelectObject(pData->hdcDimmed, pData->hbmDimmed);
                                    pData->idxSaturation = 8;
                                    pData->idxChunk = pCS->cy / CHUNK_SIZE;
                                }
                                else
                                {
                                    DeleteDC(pData->hdcDimmed);
                                    pData->hdcDimmed = NULL;
                                }
                            }

                            pData->hdcTemp = CreateCompatibleDC(hdcWindow);
                            if (pData->hdcTemp)
                            {
                                pData->hbmTemp = CreateCompatibleBitmap(hdcWindow, pCS->cx, pCS->cy);
                                if (pData->hbmTemp)
                                {
                                    pData->hbmOldTemp = (HBITMAP) SelectObject(pData->hdcTemp, pData->hbmTemp);
                                }
                                else
                                {
                                    DeleteDC(pData->hdcTemp);
                                    pData->hdcTemp = NULL;
                                }
                            }

                            ReleaseDC(hwnd, hdcWindow);
                        }
                    }

                    if (pData->hdcDimmed)
                    {
                        SetTimer(hwnd, IDT_UPDATE, 30, NULL);
                    }
                }
            }
            break;
        }

        case WM_DESTORYYOURSELF:
        {
            DestroyWindow(hwnd);
            break;
        }

        case WM_DESTROY:
        {
            if (pData)
            {
                SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
                KillTimer(hwnd, IDT_UPDATE);
                KillTimer(hwnd, IDT_KILLYOURSELF);

                if (pData->hdcDimmed)
                {
                    SelectObject(pData->hdcDimmed, pData->hbmOldDimmed);
                    DeleteDC(pData->hdcDimmed);
                    pData->hdcDimmed = NULL;
                }

                if (pData->hbmDimmed)
                {
                    DeleteObject(pData->hbmDimmed);
                    pData->hbmDimmed = NULL;
                }

                if (pData->hdcTemp)
                {
                    SelectObject(pData->hdcTemp, pData->hbmOldTemp);
                    DeleteDC(pData->hdcTemp);
                    pData->hdcTemp = NULL;
                }

                if (pData->hbmTemp)
                {
                    DeleteObject(pData->hbmTemp);
                    pData->hbmTemp = NULL;
                }

                delete pData;
            }
            break;
        }

        case WM_TIMER:
            if (pData)
            {
                BOOL fDestroyBitmaps = FALSE;

                if (wParam == IDT_KILLYOURSELF)
                {
                    ShowWindow(hwnd, SW_HIDE);

                    fDestroyBitmaps = TRUE;
                }
                else if (pData->hdcDimmed && pData->hbmDimmed)
                {
                    HDC hdcWindow = GetDC(hwnd);

                    BITMAP bm;
                    GetObject(pData->hbmDimmed, sizeof(BITMAP), &bm);

                    if (pData->idxChunk >= 0 )
                    {
                        //
                        //  In the first couple of passes, we slowly collect the screen 
                        //  into our bitmap. We do this because Blt-ing the whole thing
                        //  causes the system to hang. By doing it this way, we continue
                        //  to pump messages, the UI stays responsive and it keeps the 
                        //  mouse alive.
                        //

                        int y  = pData->idxChunk * CHUNK_SIZE;
                        if (pData->hdcTemp)
                        {
                            BitBlt(pData->hdcTemp, 0, y, bm.bmWidth, CHUNK_SIZE, hdcWindow, 0, y, SRCCOPY);
                            BitBlt(pData->hdcDimmed, 0, y, bm.bmWidth, CHUNK_SIZE, pData->hdcTemp, 0, y, SRCCOPY);
                        }
                        else
                        {
                            BitBlt(pData->hdcDimmed, 0, y, bm.bmWidth, CHUNK_SIZE, hdcWindow, 0, y, SRCCOPY);
                        }

                        pData->idxChunk--;
                        if (pData->idxChunk < 0)
                        {
                            //
                            //  We're done getting the bitmap, now reset the timer
                            //  so we slowly fade to grey.
                            //

                            SetTimer(hwnd, IDT_UPDATE, 250, NULL);
                            pData->idxSaturation = 16;
                        }
                    }
                    else
                    {
                        //
                        //  In these passes, we are making the image more and more grey and
                        //  then Blt-ing the result to the screen.
                        //

                        DimPixels(pData->pulSrc, bm.bmWidth * bm.bmHeight, 0xd5);
                        BitBlt(hdcWindow, 0, 0, bm.bmWidth, bm.bmHeight, pData->hdcDimmed, 0, 0, SRCCOPY);

                        pData->idxSaturation--;

                        if (pData->idxSaturation <= 0) // when we hit zero, kill the timer.
                        {
                            KillTimer(hwnd, IDT_UPDATE);
                            fDestroyBitmaps = TRUE;
                        }
                    }
                }

                if (fDestroyBitmaps)
                {
                    if (pData->hdcDimmed)
                    {
                        SelectObject(pData->hdcDimmed, pData->hbmOldDimmed);
                        DeleteDC(pData->hdcDimmed);
                        pData->hdcDimmed = NULL;
                    }

                    if (pData->hbmDimmed)
                    {
                        DeleteObject(pData->hbmDimmed);
                        pData->hbmDimmed = NULL;
                    }

                    if (pData->hdcTemp)
                    {
                        SelectObject(pData->hdcTemp, pData->hbmOldTemp);
                        DeleteDC(pData->hdcTemp);
                        pData->hdcTemp = NULL;
                    }

                    if (pData->hbmTemp)
                    {
                        DeleteObject(pData->hbmTemp);
                        pData->hbmTemp = NULL;
                    }
                }
            }
            break;

        case WM_WINDOWPOSCHANGING:
            {
                LPWINDOWPOS pwp = (LPWINDOWPOS) lParam;
                pwp->flags |= SWP_NOSIZE | SWP_NOMOVE;
            }
            break;

        case WM_PAINT:
        {
            HDC             hdcPaint;
            PAINTSTRUCT     ps;

            hdcPaint = BeginPaint(hwnd, &ps);
            TBOOL(EndPaint(hwnd, &ps));
            lResult = 0;
            break;
        }
        default:
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
    }

    return(lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\coverwnd.h ===
//  --------------------------------------------------------------------------
//  Module Name: DimmedWindow.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements the dimmed window when displaying logoff / shut down
//  dialog.
//
//  History:    2000-05-18  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _DimmedWindow_
#define     _DimmedWindow_

class CDimmedWindow
{
public:
    explicit CDimmedWindow (HINSTANCE hInstance);
    ~CDimmedWindow (void);
    
    //  IUnknown methods
    ULONG STDMETHODCALLTYPE   AddRef (void);
    ULONG STDMETHODCALLTYPE   Release (void);
    
    HRESULT Create (UINT ulKillTimer);

private:
    static LRESULT CALLBACK WndProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static DWORD WorkerThread(IN void *pv);

    LONG            _lReferenceCount;
    const HINSTANCE _hInstance;
    ATOM            _atom;
    ATOM            _atomPleaseWait;
    HWND            _hwnd;
    ULONG           _ulKillTimer;
};

#endif  /*  _DimmedWindow_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\debug.cpp ===
/*****************************************************************************\
    FILE: debug.cpp

    DESCRIPTION:
       Debug information.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "THEMEUI"
#define SZ_MODULE           "THEMEUI"
#define DECLARE_DEBUG

#include <ccstock.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\custfont.cpp ===
/*  CUSTFONT.C
**
**  Copyright (C) Microsoft, 1993, All Rights Reserved.
**
**  History:
**
*/

#include "priv.h"
#pragma hdrstop

static struct
{
        UINT wWidth;
        UINT wHeight;
        UINT wSizeFontId;

        UINT wStartPos;
        UINT wStartPix;
} g;

static UINT g_iCurPercent;
static RECT g_rcRuler;
static TCHAR g_szRulerDirections[200];
static TCHAR g_szSample[100];
static TCHAR g_szSampleFace[32];

static int g_cxRulerDirections;

static BOOL g_bTypeTimer = FALSE;

static TCHAR szPctD[] = TEXT("%d");
static TCHAR szPercentNum[] = TEXT("%d%%");

#define NUM_DEFPERCENTS 5
static UINT g_DefaultPercents[NUM_DEFPERCENTS] = {75, 100, 125, 150, 200};

#define MAX_PERCENT     500
#define MIN_PERCENT     20

#define GETPERCENT(dpi) ((dpi * 100 + 50) / 96)
#define GETDPI(percent) ((percent * 96 + 48) /100)

#define UPDATE_CURPER   0x0001
#define UPDATE_COMBO    0x0002
#define UPDATE_SAMPLE   0x0004
#define UPDATE_RULER    0x0008
#define UPDATE_ALL      0x000F

void NEAR PASCAL DrawRuler(HWND hDlg, LPDRAWITEMSTRUCT lpdis)
{
    int nFact;
    RECT rc;
    HDC hdc;
    int nPixInch;
    int i, j;
    TCHAR szTemp[10];
    int nOldMode;

    hdc = lpdis->hDC;
    nOldMode = SetBkMode(hdc, TRANSPARENT);
    // use g_rcRuler to draw the ruler.  it's already been spaced
    rc = g_rcRuler;

    // first, draw the directions
    i = rc.left + ((rc.right - rc.left) - g_cxRulerDirections)/2;

    nPixInch = GETDPI(g_iCurPercent);

    // draw the top and left edge of the ruler
    DrawEdge(hdc, &rc, EDGE_ETCHED, BF_TOPLEFT);
    // rest of drawing happens just below the top
    rc.top += ClassicGetSystemMetrics(SM_CYEDGE);

    nFact = 1;
    // draw one of the etch heights (1", 1/2", 1/4") per iteration
    for (j=0; j<3; ++j)
    {
        for (i=0; ; ++i)
        {
            rc.left = g_rcRuler.left + (j==0 ? i*nPixInch : (2*i+1)*nPixInch/nFact);
            if (rc.left >= g_rcRuler.right)
            {
                break;
            }
            DrawEdge(hdc, &rc, EDGE_ETCHED, BF_LEFT | BF_ADJUST);

            // dominant etch deserves a number
            if (j == 0)
            {
                StringCchPrintf(szTemp, ARRAYSIZE(szTemp), szPctD, i);
                TextOut(hdc, rc.left+1, rc.bottom-g.wHeight,
                                        szTemp, lstrlen(szTemp));
            }
        }

        rc.bottom -= (rc.bottom - rc.top)/2;
        nFact *= 2;
    }

    SetBkMode(hdc, nOldMode);
}

void NEAR PASCAL CF_UpdateRuler(HWND hDlg)
{
    RECT rc;
    HWND hwnd;

    /* Don't do this stuff if the dialog is not
    ** visible yet, or other windows will flash.
    */
    if (IsWindowVisible(hDlg))
    {
        // don't invalidate top and left because they never change.
        rc = g_rcRuler;
        rc.left += ClassicGetSystemMetrics(SM_CXEDGE);
        rc.top += ClassicGetSystemMetrics(SM_CYEDGE);

        hwnd = GetDlgItem(hDlg, IDC_CUSTOMRULER);
        InvalidateRect(hwnd, &rc, TRUE);
        UpdateWindow(hwnd);
    }
}
void NEAR PASCAL CF_ShowNewPercent(HWND hDlg, UINT uPer)
{
    TCHAR szBuf[10];

    g_iCurPercent = uPer;

    StringCchPrintf(szBuf, ARRAYSIZE(szBuf), szPercentNum, uPer);
    SetWindowText(GetDlgItem(hDlg, IDC_CUSTOMCOMBO), szBuf);
    UpdateWindow(GetDlgItem(hDlg, IDC_CUSTOMCOMBO));
}

// Build lf with given face and height
//
int CALLBACK EnumProc(CONST LOGFONT *lplf, CONST TEXTMETRIC *lptm, DWORD nType, LPARAM lpData )
{
    *(LPLOGFONT)lpData = *lplf;
    return FALSE;
}

HFONT CreateFontWithFace(HWND hwnd, int nHeight, LPCTSTR lpszFace)
{
    LOGFONT lf;
    HDC     hdc;

    hdc = GetDC(hwnd);
    if(hdc)
    {
        EnumFontFamilies(hdc, lpszFace, EnumProc, (LPARAM)&lf);
        ReleaseDC(hwnd,hdc);
    }

    lf.lfHeight = nHeight;
    lf.lfWidth = lf. lfEscapement = lf.lfOrientation = 0;

    return CreateFontIndirect(&lf);
}

void NEAR PASCAL CF_UpdateData(HWND hDlg, UINT uPer, UINT flags)
{
    TCHAR szBuf[100];
    HFONT hfont;
    int i;
    HWND hwnd;
    int iDPI;

    if (flags & UPDATE_CURPER)
    {
        if (uPer == g_iCurPercent)
            return;

        if (uPer < MIN_PERCENT)
            uPer = MIN_PERCENT;
        else if (uPer > MAX_PERCENT)
            uPer = MAX_PERCENT;

        g_iCurPercent = uPer;
    }
    if (flags & UPDATE_COMBO)
    {
        hwnd = GetDlgItem(hDlg, IDC_CUSTOMCOMBO);
        StringCchPrintf(szBuf, ARRAYSIZE(szBuf), szPercentNum, g_iCurPercent);
        i = (int)SendMessage(hwnd, CB_FINDSTRINGEXACT, 0, (LPARAM)szBuf);
        SendMessage(hwnd, CB_SETCURSEL, (WPARAM)i, 0L);
        if (i == -1)
        {
            SetWindowText(hwnd, szBuf);
            UpdateWindow(hwnd);
        }
    }
    if (flags & UPDATE_RULER)
        CF_UpdateRuler(hDlg);

    if (flags & UPDATE_SAMPLE)
    {
        iDPI = GETDPI(g_iCurPercent);

        // build and set string with DPI info
        hwnd = GetDlgItem(hDlg, IDC_CUSTOMSAMPLE);
        StringCchPrintf(szBuf, ARRAYSIZE(szBuf), g_szSample, (LPTSTR)g_szSampleFace, iDPI);
        SetWindowText(hwnd, szBuf);

        hfont = CreateFontWithFace(hwnd, -10 * iDPI / 72, g_szSampleFace);
        if (hfont)
        {
            hfont = (HFONT)SendMessage(hwnd, WM_SETFONT, (WPARAM)hfont, 1L);
            if (hfont)
                DeleteObject(hfont);
        }
    }
}

void NEAR PASCAL CF_ReadNewPercent(HWND hDlg)
{
    TCHAR szBuf[10];
    LPTSTR pstr;
    UINT uPer = 0;

    GetWindowText(GetDlgItem(hDlg, IDC_CUSTOMCOMBO), szBuf, ARRAYSIZE(szBuf));

    pstr = szBuf;
    while (*pstr && (*pstr != TEXT('%')))
    {
        if (*pstr >= TEXT('0') && *pstr <= TEXT('9'))
            uPer = uPer * 10 + (*pstr - TEXT('0'));

        pstr++;
    }

    CF_UpdateData(hDlg, uPer, UPDATE_ALL);
}

void NEAR PASCAL CF_InitDialog(HWND hDlg, UINT uDPI)
{
    HWND hwnd;
    HDC hdc;
    HFONT hfont;
    SIZE  szSize;
    int i;
    TCHAR szBuf[10];
    int iCurSel;

    g_iCurPercent = GETPERCENT(uDPI);

    hwnd = GetDlgItem(hDlg, IDC_CUSTOMCOMBO);
    iCurSel = -1;               // assume not in list
    for (i = 0; i < NUM_DEFPERCENTS; i++)
    {
        StringCchPrintf(szBuf, ARRAYSIZE(szBuf), szPercentNum, g_DefaultPercents[i]);
        SendMessage(hwnd, CB_INSERTSTRING, (WPARAM)i, (LPARAM)szBuf);
        SendMessage(hwnd, CB_SETITEMDATA, (WPARAM)i, g_DefaultPercents[i]);

        if (g_iCurPercent == g_DefaultPercents[i])
            iCurSel = i;
    }
    SendMessage(hwnd, CB_SETCURSEL, (WPARAM)iCurSel, 0L);
    if (iCurSel == -1)
    {
        StringCchPrintf(szBuf, ARRAYSIZE(szBuf), szPercentNum, g_iCurPercent);
        SetWindowText(hwnd, szBuf);
    }

    hdc = GetDC(hDlg);
    hfont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0L);
    if (hfont)
        hfont = (HFONT) SelectObject(hdc, hfont);

    GetTextExtentPoint32(hdc, TEXT("0"), 1, &szSize);

    g.wWidth = szSize.cx;
    g.wHeight = szSize.cy;

    LoadString(HINST_THISDLL, IDS_RULERDIRECTION, g_szRulerDirections, ARRAYSIZE(g_szRulerDirections));

    GetTextExtentPoint32(hdc, g_szRulerDirections, lstrlen(g_szRulerDirections), &szSize);
    g_cxRulerDirections = szSize.cx;

    if (hfont)
        SelectObject(hdc, hfont);
    ReleaseDC(hDlg, hdc);

    // calculate the rectangle for the actual ruler drawing in relation
    // to its window
    GetClientRect(GetDlgItem(hDlg, IDC_CUSTOMRULER), &g_rcRuler);
    g_rcRuler.left += g.wWidth;
    g_rcRuler.right -= g.wWidth;

    // bottom offset like the sides
    g_rcRuler.bottom -= g.wWidth;

    LoadString(HINST_THISDLL, IDS_10PTSAMPLE, g_szSample, ARRAYSIZE(g_szSample));
    LoadString(HINST_THISDLL, IDS_10PTSAMPLEFACENAME, g_szSampleFace, ARRAYSIZE(g_szSampleFace));
    CF_UpdateData(hDlg, 0, UPDATE_SAMPLE);
}

/////////////////////////////////////////////////////////////////////////////

const static DWORD FAR aCustFontHelpIds[] = {
        IDC_CUSTOMCOMBO, IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_CUSTOMFONT_LISTBOX,
        IDC_CUSTOMRULER, IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_CUSTOMFONT_RULER,
        IDC_CUSTOMSAMPLE,IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_CUSTOMFONT_SAMPLE,
        0, 0
};


INT_PTR CALLBACK CustomFontDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    HFONT hfont;
    int i;

    switch (uMessage)
    {
        case WM_CREATE:
            break;

        case WM_INITDIALOG:
            CF_InitDialog(hDlg, (UINT)lParam);
            break;

        case WM_DESTROY:
            hfont = (HFONT)SendDlgItemMessage(hDlg, IDC_CUSTOMSAMPLE, WM_GETFONT, 0, 0L);
            if (hfont)
                DeleteObject(hfont);
            break;

        case WM_DRAWITEM:
            if (wParam == IDC_CUSTOMRULER)
                DrawRuler(hDlg, (LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_TIMER:
            if (g_bTypeTimer)
            {
                KillTimer(hDlg, 13);
                g_bTypeTimer = FALSE;
                CF_ReadNewPercent(hDlg);
            }
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("display.hlp"), HELP_WM_HELP,
                (DWORD_PTR)(LPTSTR)aCustFontHelpIds);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, TEXT("display.hlp"), HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR)aCustFontHelpIds);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    EndDialog(hDlg, GETDPI(g_iCurPercent));
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    break;

                case IDC_CUSTOMRULER:
                    switch (HIWORD(wParam))
                    {
                        case DSN_NCCREATE:
                            SetWindowLong((HWND)lParam, GWL_EXSTYLE,
                                    GetWindowLong((HWND)lParam, GWL_EXSTYLE) | WS_EX_WINDOWEDGE);
                            break;

                        case DSN_BEGINDRAG:
                            // Set the focus to the corresponding edit ctl
                            SendMessage(hDlg, WM_NEXTDLGCTL,
                                        (WPARAM)GetDlgItem(hDlg, IDC_CUSTOMCOMBO), 1L);

                            SendMessage((HWND)lParam, DSM_DRAGPOS, 0, (LPARAM)&(g.wStartPos));

                            if ((int)g.wStartPos < g_rcRuler.left)
                            {
                                g.wStartPos = g_rcRuler.left;
                            }
                            g.wStartPix = g_iCurPercent;
                            break;

                        case DSN_DRAGGING:
                        {
                            UINT wNow, wPix;
                            POINT pt;

                            //wNow = LOWORD(SendMessage((HWND)lParam, DSM_DRAGPOS, 0, 0L));
                            SendMessage((HWND)lParam, DSM_DRAGPOS, 0, (LPARAM)&pt);
                            wNow = pt.x;

                            if ((int)wNow < g_rcRuler.left)
                            {
                                wNow = g_rcRuler.left;
                            }

                            wPix = LOWORD((DWORD)wNow*g.wStartPix/g.wStartPos);
                            if (wPix < MIN_PERCENT)
                            {
                                wPix = MIN_PERCENT;
                            }
                            if (wPix > MAX_PERCENT)
                            {
                                wPix = MAX_PERCENT;
                            }

                            if (wPix != g_iCurPercent)
                            {
                                CF_ShowNewPercent(hDlg, wPix);
                                CF_UpdateRuler(hDlg);
                            }
                            break;
                        }

                        case DSN_ENDDRAG:
                            CF_UpdateData(hDlg, 0, UPDATE_COMBO | UPDATE_SAMPLE);
                            break;

                        default:
                            break;
                        }
                    break;

                case IDC_CUSTOMCOMBO:
                    switch(HIWORD(wParam))
                    {
                        case CBN_SELCHANGE:
                            i = (int)SendDlgItemMessage(hDlg, IDC_CUSTOMCOMBO, CB_GETCURSEL, 0, 0L);
                            if (i != CB_ERR)
                            {
                                i = LOWORD(SendDlgItemMessage(hDlg, IDC_CUSTOMCOMBO, CB_GETITEMDATA, (WPARAM)i, 0L));
                                CF_UpdateData(hDlg, (UINT)i, UPDATE_CURPER | UPDATE_SAMPLE | UPDATE_RULER);
                            }
                            break;

                        case CBN_EDITCHANGE:
                            if (g_bTypeTimer)
                            {
                                KillTimer(hDlg, 13);
                            }
                            g_bTypeTimer = TRUE;
                            SetTimer(hDlg, 13, 500, NULL);
                            break;
                    }
                    break;

                default:
                        return(FALSE);
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\deskcmmn.cpp ===
#include "priv.h"
#include "deskcmmn.h"
#include <regstr.h>
#include <ccstock.h>


static const TCHAR sc_szDeskAppletSoftwareKey[] = REGSTR_PATH_CONTROLSFOLDER TEXT("\\Display");

LPTSTR SubStrEnd(LPTSTR pszTarget, LPTSTR pszScan)
    {
    int i;
    for (i = 0; pszScan[i] != TEXT('\0') && pszTarget[i] != TEXT('\0') &&
            CharUpperChar(pszScan[i]) == CharUpperChar(pszTarget[i]); i++);

    if (pszTarget[i] == TEXT('\0'))
        {
        // we found the substring
        return pszScan + i;
        }

    return pszScan;
    }


BOOL GetDeviceRegKey(LPCTSTR pstrDeviceKey, HKEY* phKey, BOOL* pbReadOnly)
    {
    if(lstrlen(pstrDeviceKey) >= MAX_PATH)
        return FALSE;

    BOOL bRet = FALSE;

    // copy to local string
    TCHAR szBuffer[MAX_PATH];
    StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), pstrDeviceKey);

    //
    // At this point, szBuffer has something like:
    //  \REGISTRY\Machine\System\ControlSet001\Services\Jazzg300\Device0
    //
    // To use the Win32 registry calls, we have to strip off the \REGISTRY
    // and convert \Machine to HKEY_LOCAL_MACHINE
    //

    LPTSTR pszRegistryPath = SubStrEnd(SZ_REGISTRYMACHINE, szBuffer);

    if(pszRegistryPath)
        {
        // Open the registry key
        bRet = (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             pszRegistryPath,
                             0,
                             KEY_WRITE | KEY_READ,
                             phKey) == ERROR_SUCCESS);
        if(bRet)
            {
            *pbReadOnly = FALSE;
            }
        else
            {
            bRet = (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 pszRegistryPath,
                                 0,
                                 KEY_READ,
                                 phKey) == ERROR_SUCCESS);
            if (bRet)
                {
                *pbReadOnly = TRUE;
                }
            }
        }

    return bRet;
    }


int GetDisplayCPLPreference(LPCTSTR szRegVal)
{
    int val = -1;
    HKEY hk;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, sc_szDeskAppletSoftwareKey, 0, KEY_READ, &hk) == ERROR_SUCCESS)
    {
        TCHAR sz[64];
        DWORD cb = sizeof(sz);

        *sz = 0;
        if ((RegQueryValueEx(hk, szRegVal, NULL, NULL,
            (LPBYTE)sz, &cb) == ERROR_SUCCESS) && *sz)
        {
            val = StrToInt(sz);
        }

        RegCloseKey(hk);
    }

    if (val == -1 && RegOpenKeyEx(HKEY_LOCAL_MACHINE, sc_szDeskAppletSoftwareKey, 0, KEY_READ, &hk) == ERROR_SUCCESS)
    {
        TCHAR sz[64];
        DWORD cb = sizeof(sz);

        *sz = 0;
        if ((RegQueryValueEx(hk, szRegVal, NULL, NULL,
            (LPBYTE)sz, &cb) == ERROR_SUCCESS) && *sz)
        {
            val = StrToInt(sz);
        }

        RegCloseKey(hk);
    }

    return val;
}


int GetDynaCDSPreference()
{
    int iRegVal = GetDisplayCPLPreference(REGSTR_VAL_DYNASETTINGSCHANGE);
    if (iRegVal == -1)
        iRegVal = DCDSF_DYNA; // Apply dynamically
    return iRegVal;
}


void SetDisplayCPLPreference(LPCTSTR szRegVal, int val)
{
    HKEY hk;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, sc_szDeskAppletSoftwareKey, 0, TEXT(""), 0, KEY_WRITE, NULL, &hk, NULL) ==
        ERROR_SUCCESS)
    {
        TCHAR sz[64];

        StringCchPrintf(sz, ARRAYSIZE(sz), TEXT("%d"), val);
        RegSetValueEx(hk, szRegVal, NULL, REG_SZ,
            (LPBYTE)sz, lstrlen(sz) + 1);

        RegCloseKey(hk);
    }
}


BOOL
AllocAndReadInterfaceName(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInterfaceName
    )

/*

    Note: If this function retuns success, the caller is responsible
          to free the memory pointed by *ppInterfaceName

*/

{
    BOOL bSuccess = FALSE;
    LPTSTR pszPath = NULL;
    HKEY hkDevice = 0;
    HKEY hkVolatileSettings = 0;

    //ASSERT (pDeviceKey != NULL);

    pszPath = SubStrEnd(SZ_REGISTRYMACHINE, pDeviceKey);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pszPath,
                     0,
                     KEY_READ,
                     &hkDevice) != ERROR_SUCCESS) {

        hkDevice = 0;
        goto Cleanup;
    }

    if (RegOpenKeyEx(hkDevice,
                     SZ_VOLATILE_SETTINGS,
                     0,
                     KEY_READ,
                     &hkVolatileSettings) != ERROR_SUCCESS) {

        hkVolatileSettings = 0;
        goto Cleanup;
    }

    bSuccess = AllocAndReadValue(hkVolatileSettings,
                                 SZ_DISPLAY_ADAPTER_INTERFACE_NAME,
                                 ppInterfaceName);

Cleanup:

    if (hkVolatileSettings) {
        RegCloseKey(hkVolatileSettings);
    }

    if (hkDevice) {
        RegCloseKey(hkDevice);
    }

    return bSuccess;
}


BOOL
AllocAndReadInstanceID(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInstanceID
    )

/*

    Note: If this function retuns success, the caller is responsible
          to free the memory pointed by *ppInstanceID

*/

{
    LPTSTR pDeviceKeyCopy = NULL, pDeviceKeyCopy2 = NULL;
    LPTSTR pTemp = NULL, pX = NULL;
    BOOL bSuccess = FALSE;
    HKEY hkEnum = 0;
    HKEY hkService = 0;
    HKEY hkCommon = 0;
    DWORD Count = 0;
    DWORD cb = 0, len = 0;

    //
    // Make a copy of pDeviceKey
    //

    len = (DWORD)max (256, (lstrlen(pDeviceKey) + 6) * sizeof(TCHAR));
    pDeviceKeyCopy2 = pDeviceKeyCopy = (LPTSTR)LocalAlloc(LPTR, len);

    if (pDeviceKeyCopy == NULL) {
        goto Cleanup;
    }

    StringCbCopy(pDeviceKeyCopy, len, pDeviceKey);
    pTemp = SubStrEnd(SZ_REGISTRYMACHINE, pDeviceKeyCopy);
    pDeviceKeyCopy = pTemp;

    //
    // Open the service key
    //

    pTemp = pDeviceKeyCopy + lstrlen(pDeviceKeyCopy);

    while ((pTemp != pDeviceKeyCopy) && (*pTemp != TEXT('\\'))) {
        pTemp--;
    }

    if (pTemp == pDeviceKeyCopy) {
        goto Cleanup;
    }

    pX = SubStrEnd(SZ_DEVICE, pTemp);

    if (pX == pTemp) {

        //
        // The new key is used: CCS\Control\Video\[GUID]\000X
        //

        *pTemp = UNICODE_NULL;

        StringCbCat(pDeviceKeyCopy, len, SZ_COMMON_SUBKEY);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         pDeviceKeyCopy,
                         0,
                         KEY_READ,
                         &hkCommon) != ERROR_SUCCESS) {
            
            hkCommon = 0;
            goto Cleanup;
        }
    
        pDeviceKeyCopy = pDeviceKeyCopy2;

        ZeroMemory(pDeviceKeyCopy, len);
        
        StringCbCopy(pDeviceKeyCopy, len, SZ_SERVICES_PATH);

        cb = len - (lstrlen(pDeviceKeyCopy) + 1) * sizeof(TCHAR);

        if (RegQueryValueEx(hkCommon,
                            SZ_SERVICE,
                            NULL,
                            NULL,
                            (LPBYTE)(pDeviceKeyCopy + lstrlen(pDeviceKeyCopy)),
                            &cb) != ERROR_SUCCESS) {
            
            goto Cleanup;
        }

    } else {

        //
        // The old key is used: CCS\Services\[SrvName]\DeviceX
        //

        *pTemp = UNICODE_NULL;
    }

    //
    // Open the ServiceName key
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pDeviceKeyCopy,
                     0,
                     KEY_READ,
                     &hkService) != ERROR_SUCCESS) {

        hkService = 0;
        goto Cleanup;
    }
    
    //
    // Open the "Enum" key under the devicename
    //

    if (RegOpenKeyEx(hkService,
                     SZ_ENUM,
                     0,
                     KEY_READ,
                     &hkEnum) != ERROR_SUCCESS) {
        hkEnum = 0;
        goto Cleanup;
    }

    cb = sizeof(Count);
    if ((RegQueryValueEx(hkEnum,
                         SZ_VU_COUNT,
                         NULL,
                         NULL,
                         (LPBYTE)&Count,
                         &cb) != ERROR_SUCCESS) ||
        (Count != 1)) {

        //
        // Igonore the case when there are at least 2 devices.
        //

        goto Cleanup;
    }

    bSuccess = AllocAndReadValue(hkEnum, TEXT("0"), ppInstanceID);

Cleanup:

    if (hkEnum != 0) {
        RegCloseKey(hkEnum);
    }

    if (hkService != 0) {
        RegCloseKey(hkService);
    }

    if (hkCommon != 0) {
        RegCloseKey(hkCommon);
    }
    
    if (pDeviceKeyCopy2 != NULL) {
        LocalFree(pDeviceKeyCopy2);
    }

    return bSuccess;
}


BOOL
AllocAndReadValue(
    IN  HKEY hkKey,
    IN  LPTSTR pValueName,
    OUT LPWSTR* ppwValueData
    )

/*

    Note: If this function retuns success, the caller is responsible
          to free the memory pointed by *ppwValueData

*/

{
    LPWSTR pwValueData = NULL;
    DWORD AllocUnit = 64;
    DWORD cBytes = 0;
    BOOL bSuccess = FALSE;
    LONG Error = ERROR_SUCCESS;

    while (!bSuccess) {

        AllocUnit *= 2;
        cBytes = AllocUnit * sizeof(WCHAR);

        pwValueData = (LPWSTR)(LocalAlloc(LPTR, cBytes));
        if (pwValueData == NULL)
            break;

        Error = RegQueryValueEx(hkKey,
                                pValueName,
                                NULL,
                                NULL,
                                (LPBYTE)pwValueData,
                                &cBytes);

        bSuccess = (Error == ERROR_SUCCESS);

        if (!bSuccess) {

            LocalFree(pwValueData);
            pwValueData = NULL;

            if (Error != ERROR_MORE_DATA)
                break;
        }
    }

    if (bSuccess) {
        *ppwValueData = pwValueData;
    }

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\deskcmmn.h ===
#ifndef _DESKCMMN_H
#define _DESKCMMN_H


//==========================================================================
//                              Guids
//==========================================================================

DEFINE_GUID(GUID_DISPLAY_ADAPTER_INTERFACE, 
            0x5b45201d, 
            0xf2f2, 0x4f3b, 
            0x85, 0xbb, 0x30, 0xff, 0x1f, 0x95, 0x35, 0x99);

#define SZ_DISPLAY_ADAPTER_INTERFACE_NAME TEXT("{5b45201d-f2f2-4f3b-85bb-30ff1f953599}")

//==========================================================================
//                              Macros
//==========================================================================

#define SZ_REGISTRYMACHINE  TEXT("\\REGISTRY\\MACHINE\\")
#define SZ_PRUNNING_MODE    TEXT("PruningMode")

#define SZ_GUID                TEXT("VideoID")
#define SZ_VIDEO_DEVICES       TEXT("System\\CurrentControlSet\\Control\\Video\\")
#define SZ_COMMON_SUBKEY       TEXT("\\Video")
#define SZ_SERVICES_PATH       TEXT("System\\CurrentControlSet\\Services\\")
#define SZ_SERVICE             TEXT("Service")

#define DCDSF_DYNA (0x0001)
#define DCDSF_ASK  (0x0002)

#define DCDSF_PROBABLY      (DCDSF_ASK  | DCDSF_DYNA)
#define DCDSF_PROBABLY_NOT  (DCDSF_ASK  |          0)
#define DCDSF_YES           (0          | DCDSF_DYNA)
#define DCDSF_NO            (0          |          0)


#define REGSTR_VAL_DYNASETTINGSCHANGE    TEXT("DynaSettingsChange")
#define SZ_UPGRADE_FROM_PLATFORM         TEXT("PlatformId")
#define SZ_UPGRADE_FROM_MAJOR_VERSION    TEXT("MajorVersion")
#define SZ_UPGRADE_FROM_MINOR_VERSION    TEXT("MinorVersion")
#define SZ_UPGRADE_FROM_BUILD_NUMBER     TEXT("BuildNumber")
#define SZ_UPGRADE_FROM_VERSION_DESC     TEXT("CSDVersion")
#define SZ_UPGRADE_FROM_PELS_WIDTH       TEXT("PelsWidth")
#define SZ_UPGRADE_FROM_PELS_HEIGHT      TEXT("PelsHeight")
#define SZ_UPGRADE_FROM_BITS_PER_PEL     TEXT("BPP")
#define SZ_UPGRADE_FROM_PLANES           TEXT("Planes")
#define SZ_UPGRADE_FROM_DISPLAY_FREQ     TEXT("VRefresh")
#define SZ_UPGRADE_FAILED_ALLOW_INSTALL  TEXT("FailedAllowInstall")
#define SZ_VIDEOMAP                      TEXT("HARDWARE\\DEVICEMAP\\VIDEO")
#define SZ_DEVICE                        TEXT("\\Device")
#define SZ_ENUM                          TEXT("Enum")

#define SZ_UPDATE_SETTINGS               TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\VideoUpgradeDisplaySettings")
#define SZ_UPDATE_SETTINGS_PATH          TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")
#define SZ_UPDATE_SETTINGS_KEY           TEXT("VideoUpgradeDisplaySettings")

#define SZ_VU_COUNT                      TEXT("Count")
#define SZ_VU_PHYSICAL                   TEXT("Physical")
#define SZ_VU_LOGICAL                    TEXT("Logical")
#define SZ_VU_BUS_NUMBER                 TEXT("BusNumber")
#define SZ_VU_ADDRESS                    TEXT("Address")
#define SZ_VU_PREFERRED_MODE             TEXT("UsePreferredMode")
#define SZ_VU_ATTACHED_TO_DESKTOP        TEXT("Attach.ToDesktop")
#define SZ_VU_RELATIVE_X                 TEXT("Attach.RelativeX")
#define SZ_VU_RELATIVE_Y                 TEXT("Attach.RelativeY")
#define SZ_VU_BITS_PER_PEL               TEXT("DefaultSettings.BitsPerPel")
#define SZ_VU_X_RESOLUTION               TEXT("DefaultSettings.XResolution")
#define SZ_VU_Y_RESOLUTION               TEXT("DefaultSettings.YResolution")
#define SZ_VU_VREFRESH                   TEXT("DefaultSettings.VRefresh")
#define SZ_VU_FLAGS                      TEXT("DefaultSettings.Flags")

#define SZ_HW_ACCELERATION               TEXT("Acceleration.Level")


#define SZ_VOLATILE_SETTINGS             TEXT("VolatileSettings")

#define SZ_DETECT_DISPLAY                TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\DetectDisplay")
#define SZ_NEW_DISPLAY                   TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\NewDisplay")

//==========================================================================
//                              Functions
//==========================================================================

// LPTSTR SubStrEnd(LPTSTR pszTarget, LPTSTR pszScan )
//
// If pszScan starts with pszTarget, then the function returns the first
// char of pszScan that follows the pszTarget; other wise it returns pszScan.
//
// eg: SubStrEnd("abc", "abcdefg" ) ==> "defg"
//     SubStrEnd("abc", "abZQRT" ) ==> "abZQRT"
LPTSTR SubStrEnd(LPTSTR pszTarget, LPTSTR pszScan);


BOOL GetDeviceRegKey(LPCTSTR pstrDeviceKey, HKEY* phKey, BOOL* pbReadOnly);


int GetDisplayCPLPreference(LPCTSTR szRegVal);


int GetDynaCDSPreference();


void SetDisplayCPLPreference(LPCTSTR szRegVal, int val);


LONG WINAPI MyStrToLong(LPCTSTR sz);

BOOL 
AllocAndReadInterfaceName(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInterfaceName
    );

BOOL 
AllocAndReadInstanceID(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInstanceID
    );

BOOL 
AllocAndReadValue(
    IN  HKEY hkKey,
    IN  LPTSTR pValueName,
    OUT LPWSTR* ppwValueData
    );

#endif // _DESKCMMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\dragsize.h ===
#define SETWINDOWPOINTER(hwnd, name, p) SetWindowLongPtr(hwnd, 0, (LONG_PTR)p)
#define GETWINDOWPOINTER(hwnd, name)	((name)GetWindowLongPtr(hwnd, 0))

#define ALLOCWINDOWPOINTER(name, size)	((name)LocalAlloc(LPTR, size))
#define FREEWINDOWPOINTER(p)		LocalFree((HLOCAL)p)

#define GETWINDOWID(hwnd)               GetWindowLong(hwnd, GWLP_ID)

#define DRAGSIZECLASSNAME               TEXT("DragSizeWindow")

BOOL FAR PASCAL InitDragSizeClass(void);

#define DSM_DRAGPOS	(WM_USER)

#define DSN_BEGINDRAG	(0)
#define DSN_DRAGGING	(1)
#define DSN_ENDDRAG	(2)
#define DSN_NCCREATE	(3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\displaysettings.h ===
/**************************************************************************\
* Module Name: settings.hxx
*
* CDeviceSettings class
*
*  This class is in charge of all the settings specific to one display
*  device. Including Screen Size, Color Depth, Font size.  
*
* Copyright (c) Microsoft Corp.  1992-1998 All Rights Reserved
*
\**************************************************************************/


#ifndef SETTINGS_HXX
#define SETTINGS_HXX

#define MAKEXYRES(p,xval,yval)  ((p)->x = xval, (p)->y = yval)

#define _CURXRES  ((_pCurDevmode != NULL) ? (int)_pCurDevmode->dmPelsWidth : -1)
#define _CURYRES  ((_pCurDevmode != NULL) ? (int)_pCurDevmode->dmPelsHeight : -1)
#define _ORGXRES  ((_pOrgDevmode != NULL) ? (int)_pOrgDevmode->dmPelsWidth : -1)
#define _ORGYRES  ((_pOrgDevmode != NULL) ? (int)_pOrgDevmode->dmPelsHeight : -1)

#define _CURCOLOR ((_pCurDevmode != NULL) ? (int)_pCurDevmode->dmBitsPerPel : -1)
#define _ORGCOLOR ((_pOrgDevmode != NULL) ? (int)_pOrgDevmode->dmBitsPerPel : -1)

#define _CURFREQ  ((_pCurDevmode != NULL) ? (int)_pCurDevmode->dmDisplayFrequency : -1)
#define _ORGFREQ  ((_pOrgDevmode != NULL) ? (int)_pOrgDevmode->dmDisplayFrequency : -1)

#define MODE_INVALID    0x00000001
#define MODE_RAW        0x00000002

typedef struct _MODEARRAY {

    DWORD     dwFlags;
    LPDEVMODE lpdm;

} MODEARRAY, *PMODEARRAY;

HRESULT CDisplaySettings_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);

class CDisplaySettings :    public IDataObject, 
                            public IDisplaySettings
{
public:

    CDisplaySettings();
    ~CDisplaySettings();

    // General Settings support
    BOOL InitSettings(LPDISPLAY_DEVICE pDisplay);
    int  SaveSettings(DWORD dwSet);
    int  RestoreSettings();
    BOOL ConfirmChangeSettings();
    BOOL IsKnownSafe();
    BOOL bIsModeChanged()               {return _pCurDevmode != _pOrgDevmode;}

    // Device Settings
    void SetPrimary(BOOL fPrimary)      { _fPrimary     = fPrimary; };
    void SetAttached(BOOL fAttached)    { _fCurAttached = fAttached; };
    BOOL IsPrimary()                    { return _fPrimary; };
    BOOL IsAttached()                   { return _fCurAttached; };
    BOOL IsOrgAttached()                { return _fOrgAttached; };
    BOOL IsSmallFontNecessary();
    
    BOOL IsRemovable() 
    { 
        return ((_pDisplayDevice->StateFlags & DISPLAY_DEVICE_REMOVABLE) != 0);
    }
    
    // Color information
    int  GetColorList(LPPOINT Res, PLONGLONG *ppColor);
    void SetCurColor(int Color)         { _BestMatch(NULL, Color, FALSE); }
    int  GetCurColor()                  { return _CURCOLOR;}
    BOOL IsColorChanged()
    {
        return (_ORGCOLOR == -1) ? FALSE : (_CURCOLOR != _ORGCOLOR);
    }

    // Resolution information
    int  GetResolutionList(int Color, PPOINT *ppRes);
    void SetCurResolution(LPPOINT ppt, IN BOOL fAutoSetColorDepth)  { _BestMatch(ppt, -1, fAutoSetColorDepth); }
    void GetCurResolution(LPPOINT ppt)  
    { 
        ppt->x = _CURXRES;
        ppt->y = _CURYRES; 
    }
    BOOL IsResolutionChanged()
    {
        if (_ORGXRES == -1)
            return FALSE;
        else
            return ((_CURXRES != _ORGXRES) && (_CURYRES != _ORGYRES));
    }

    int  GetFrequencyList(int Color, LPPOINT Res, PLONGLONG *ppFreq);
    int  GetCurFrequency()              { return _CURFREQ; }
    BOOL IsFrequencyChanged()
    {
        return (_ORGFREQ == -1) ? FALSE : (_CURFREQ != _ORGFREQ);
    }

    // Position information
    void SetCurPosition(LPPOINT ppt) {_ptCurPos = *ppt;}
    void SetOrgPosition(LPPOINT ppt) {_ptOrgPos = *ppt;}
    void GetCurPosition(PRECT prc)
    {
        prc->left   = _ptCurPos.x;
        prc->top    = _ptCurPos.y;
        prc->right  = _ptCurPos.x + _CURXRES;
        prc->bottom = _ptCurPos.y + _CURYRES;
    }
    void GetOrgPosition(PRECT prc)
    {
        prc->left   = _ptOrgPos.x;
        prc->top    = _ptOrgPos.y;
        prc->right  = _ptOrgPos.x + _ORGXRES;
        prc->bottom = _ptOrgPos.y + _ORGYRES;
    }

    void GetPreviewPosition(PRECT prc)
    {
        *prc = _rcPreview;
    }

    void SetPreviewPosition(PRECT prc)
    {
        _rcPreview = *prc;
    }

    // Adapter & Monitor information
    BOOL GetMonitorName(LPTSTR pszName, DWORD cchSize);
    BOOL GetMonitorDevice(LPTSTR pszDevice, DWORD cchSize);

    // *** IUnknown methods
    STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IDataObject methods
    STDMETHODIMP GetData(FORMATETC *pfmtetcIn, STGMEDIUM *pstgmed);
    STDMETHODIMP GetDataHere(FORMATETC *pfmtetc, STGMEDIUM *pstgpmed);
    STDMETHODIMP QueryGetData(FORMATETC *pfmtetc);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pfmtetcIn, FORMATETC *pfmtetcOut);
    STDMETHODIMP SetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed, BOOL bRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppienumFormatEtc);
    STDMETHODIMP DAdvise(FORMATETC *pfmtetc, DWORD dwAdviseFlags, IAdviseSink * piadvsink, PDWORD pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppienumStatData);

    // Helper functions
    STDMETHODIMP CopyDataToStorage(STGMEDIUM *pstgmed, LPTSTR pszOut);

    // *** IDisplaySettings methods
    STDMETHODIMP SetMonitor(DWORD dwMonitor);
    STDMETHODIMP GetModeCount(DWORD* pdwCount, BOOL fOnlyPreferredModes);
    STDMETHODIMP GetMode(DWORD dwMode, BOOL fOnlyPreferredModes, DWORD* pdwWidth, DWORD* pdwHeight, DWORD* pdwColor);
    STDMETHODIMP SetSelectedMode(HWND hwnd, DWORD dwWidth, DWORD dwHeight, DWORD dwColor, BOOL* pfApplied, DWORD dwFlags);
    STDMETHODIMP GetSelectedMode(DWORD* pdwWidth, DWORD* pdwHeight, DWORD* pdwColor);
    STDMETHODIMP GetAttached(BOOL* pfAttached);
    STDMETHODIMP SetPruningMode(BOOL fIsPruningOn);
    STDMETHODIMP GetPruningMode(BOOL* pfCanBePruned, BOOL* pfIsPruningReadOnly, BOOL* pfIsPruningOn);

protected:
    // The Display Device we are currently working with.

    LPDISPLAY_DEVICE _pDisplayDevice;

    ULONG       _cpdm;
    PMODEARRAY  _apdm;

    // The current system settings
    POINT       _ptOrgPos;
    LPDEVMODE   _pOrgDevmode;
    BOOL        _fOrgAttached;

    // The current CPL settings.
    POINT       _ptCurPos;
    LPDEVMODE   _pCurDevmode;
    BOOL        _fCurAttached;
    RECT        _rcPreview;

    // If the current device is attached to the desktop
    BOOL        _fUsingDefault;
    BOOL        _fPrimary;

    // Pruning 
    BOOL        _bCanBePruned;       // true if raw mode list != pruned mode list
    BOOL        _bIsPruningReadOnly; // true if can be pruned and pruning mode can be written
    BOOL        _bIsPruningOn;       // true if can be pruned and pruning mode is on
    HKEY        _hPruningRegKey;
    
    // Orientation
    BOOL        _bFilterOrientation;
    DWORD       _dwOrientation;
    BOOL        _bFilterFixedOutput;
    DWORD       _dwFixedOutput;
        
    // Ref count for IDataObject
    LONG       _cRef;

    // Private functions
#ifdef DEBUG
    void _Dump_CDisplaySettings(BOOL bAll);
    void _Dump_CDevmodeList(VOID);
    void _Dump_CDevmode(LPDEVMODE pdm);
#endif

    int  _InsertSortedDwords(int val1, int val2, int cval, int **ppval);
    BOOL _AddDevMode(LPDEVMODE lpdm);
    void _BestMatch(LPPOINT Res, int Color, IN BOOL fAutoSetColorDepth);
    BOOL _ExactMatch(LPDEVMODE lpdm, BOOL bForceVisible);
    BOOL _PerfectMatch(LPDEVMODE lpdm);
    void _SetCurrentValues(LPDEVMODE lpdm);
    int  _GetCurrentModeFrequencyList(int Color, LPPOINT Res, PLONGLONG *ppFrequency);
    BOOL _MarkMode(LPDEVMODE lpdm);
    BOOL _IsCurDevmodeRaw();
    BOOL _IsModeVisible(int i);
    BOOL _IsModePreferred(int i);
    static BOOL _IsModeVisible(CDisplaySettings* pSettings, int i);

    // OLE support for extensibility.
    void _InitClipboardFormats();
    void _FilterModes();

    static LPDEVMODEW _lpfnEnumAllModes(LPVOID pContext, DWORD iMode);
    static BOOL       _lpfnSetSelectedMode(LPVOID pContext, LPDEVMODEW lpdm);
    static LPDEVMODEW _lpfnGetSelectedMode(LPVOID pContext);
    static VOID       _lpfnSetPruningMode(LPVOID pContext, BOOL bIsPruningOn);
    static VOID       _lpfnGetPruningMode(LPVOID pContext, 
                                          BOOL* pbCanBePruned,
                                          BOOL* pbIsPruningReadOnly,
                                          BOOL* pbIsPruningOn);

private:
    HRESULT _GetRegKey(LPDEVMODE pDevmode, int * pnIndex, LPTSTR pszRegKey, DWORD cchSize, LPTSTR pszRegValue, DWORD cchValueSize);
};

#endif // SETTINGS_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\dragsize.cpp ===
/*
**  DRAGSIZE.C
**
**  Drag size bar code
**
*/

#include "priv.h"

#pragma hdrstop


typedef struct tagDRAGSIZEINFO
{
    DWORD_PTR lpData;
    BOOL bDragging;
    POINT ptNow;
    HFONT hFont;
} DRAGSIZEINFO, *PDRAGSIZEINFO;

static TCHAR szDragSizeClass[] = DRAGSIZECLASSNAME;

LRESULT NEAR PASCAL InitDragSizeWnd(HWND hWnd, LPCREATESTRUCT lpCreate)
{
    PDRAGSIZEINFO pDragSizeInfo;

    /* Create the status info struct; abort if it does not exist,
    ** otherwise save it in the window structure
    */
    pDragSizeInfo = ALLOCWINDOWPOINTER(PDRAGSIZEINFO, sizeof(DRAGSIZEINFO));
    if (!pDragSizeInfo)
    {
        return(-1);
    }
    SETWINDOWPOINTER(hWnd, PDRAGSIZEINFO, pDragSizeInfo);
    pDragSizeInfo->lpData = (DWORD_PTR)lpCreate->lpCreateParams;
    pDragSizeInfo->bDragging = FALSE;

    return(0);
}


/* Track the mouse and send messages to the parent whenever it moves.
*/
void NEAR PASCAL DragSize(HWND hWnd, PDRAGSIZEINFO pDragSizeInfo, POINT ptStart)
{
    MSG msg;
    HWND hwndParent;
    LONG wID;

    if (!pDragSizeInfo || pDragSizeInfo->bDragging)
    {
        return;
    }

    pDragSizeInfo->bDragging = TRUE;
    pDragSizeInfo->ptNow     = ptStart;

    SetCapture(hWnd);

    hwndParent = GetParent(hWnd);
    wID = GETWINDOWID(hWnd);

    SendMessage(hwndParent, WM_COMMAND, MAKEWPARAM(wID, DSN_BEGINDRAG), (LPARAM)hWnd);

    for ( ; ; )
    {
        if (GetCapture() != hWnd)
        {
EndAbort:
            /* Abort the process.
            */
            pDragSizeInfo->ptNow = ptStart;
                        SendMessage(hwndParent, WM_COMMAND, MAKEWPARAM(wID, DSN_DRAGGING), (LPARAM)hWnd);
            goto EndAdjust;
        }

        if (!PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            continue;
        }

        switch (msg.message)
        {
        case WM_KEYDOWN:
            switch (msg.wParam)
            {
            case VK_ESCAPE:
AbortAdjust:
                SetCapture(NULL);
                goto EndAbort;

            default:
                break;
            }
            break;

        case WM_KEYUP:
        case WM_CHAR:
            break;

        case WM_LBUTTONDOWN:
            /* This shouldn't happen.
            */
            goto AbortAdjust;

        case WM_MOUSEMOVE:
            LPARAM2POINT( msg.lParam, &(pDragSizeInfo->ptNow) );
            
            TraceMsg(TF_GENERAL, "DragSize: ptNow = (%d, %d)\n", pDragSizeInfo->ptNow.x, pDragSizeInfo->ptNow.y);
            
            SendMessage(hwndParent, WM_COMMAND, MAKEWPARAM(wID, DSN_DRAGGING), (LPARAM)hWnd);
            break;

        case WM_LBUTTONUP:
            /* All done.
            */
            SetCapture(NULL);
            goto EndAdjust;

        case WM_RBUTTONDOWN:
            goto AbortAdjust;

        default:
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            break;
        }
    }

EndAdjust:
    SendMessage(hwndParent, WM_COMMAND, MAKEWPARAM(wID, DSN_ENDDRAG), (LPARAM)hWnd);
    pDragSizeInfo->bDragging = FALSE;
}


/* Ask the parent to paint the window.
*/
void NEAR PASCAL PaintDragSizeWnd(HWND hWnd, PDRAGSIZEINFO pDragSizeInfo)
{
    PAINTSTRUCT ps;
    DRAWITEMSTRUCT dis;
    HDC hDC;
    HFONT hOldFont = NULL;

    if (!pDragSizeInfo)
    {
        return;
    }

    hDC = BeginPaint(hWnd, &ps);

    if (pDragSizeInfo->hFont)
    {
        hOldFont = (HFONT) SelectObject(hDC, pDragSizeInfo->hFont);
    }

    /* Fill in the DRAWITEMSTRUCT.  Note that some of the fields are
    ** undefined.
    */
    dis.CtlID    = GetDlgCtrlID(hWnd);
    dis.hwndItem = hWnd;
    dis.hDC      = hDC;
    GetClientRect(hWnd, &dis.rcItem);
    dis.itemData = pDragSizeInfo->lpData;

    SendMessage(GetParent(hWnd), WM_DRAWITEM, GetDlgCtrlID(hWnd),
        (LPARAM)(LPDRAWITEMSTRUCT)&dis);

    if (hOldFont)
    {
        SelectObject(hDC, hOldFont);
    }

    EndPaint(hWnd, &ps);
}


LRESULT CALLBACK DragSizeWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
#define lpCreate ((LPCREATESTRUCT)lParam)

    PDRAGSIZEINFO pDragSizeInfo;

    pDragSizeInfo = GETWINDOWPOINTER(hWnd, PDRAGSIZEINFO);

    switch (uMessage)
    {
    case WM_NCCREATE:
        SendMessage(lpCreate->hwndParent, WM_COMMAND,
                        MAKEWPARAM((SHORT)(lpCreate->hMenu), DSN_NCCREATE), (LPARAM)hWnd);
        break;

    case WM_CREATE:
        InitDragSizeWnd(hWnd, (LPCREATESTRUCT)lParam);
        break;

    case WM_DESTROY:
        if (pDragSizeInfo)
        {
            FREEWINDOWPOINTER(pDragSizeInfo);
            SETWINDOWPOINTER(hWnd, PDRAGSIZEINFO, NULL);
        }
        break;

    case WM_LBUTTONDOWN: 
        {
            POINT pt;
            LPARAM2POINT( lParam, &pt );
            DragSize(hWnd, pDragSizeInfo, pt);
        }
        break;

    case WM_PAINT:
        PaintDragSizeWnd(hWnd, pDragSizeInfo);
        return(0);

    case WM_SETFONT:
        if (!pDragSizeInfo)
        {
            return(1L);
        }
        pDragSizeInfo->hFont = (HFONT)wParam;

        if (LOWORD(lParam))
        {
            InvalidateRect(hWnd, NULL, TRUE);
            UpdateWindow(hWnd);
        }
        return(0L);

    case WM_GETFONT:
        if (!pDragSizeInfo)
        {
            return(LRESULT)(NULL);
        }
        return(MAKELRESULT(pDragSizeInfo->hFont, 0));

    case DSM_DRAGPOS: 
        {
            LPPOINT lppt = (LPPOINT)lParam;

            if (!pDragSizeInfo || !pDragSizeInfo->bDragging || lppt == NULL)
            {
                return(-1L);
            }

            *lppt = pDragSizeInfo->ptNow;

            return(0);
        }
        break;

    default:
        break;
    }

    return(DefWindowProc(hWnd, uMessage, wParam, lParam));
}


BOOL FAR PASCAL InitDragSizeClass(void)
{
    WNDCLASS rClass;

    if (GetClassInfo(HINST_THISDLL, szDragSizeClass, &rClass))
    {
        return(TRUE);
    }

    rClass.style         = 0;
    rClass.lpfnWndProc   = DragSizeWndProc;
    rClass.cbClsExtra    = 0;
    rClass.cbWndExtra    = sizeof(PDRAGSIZEINFO);
    rClass.hInstance     = HINST_THISDLL;
    rClass.hIcon         = NULL;
    rClass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    rClass.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    rClass.lpszMenuName  = NULL;
    rClass.lpszClassName = szDragSizeClass;

    return(RegisterClass(&rClass));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\dllmain.cpp ===
/*****************************************************************************\
    FILE: dllmain.cpp

    DESCRIPTION:
       This file will take care of the DLL lifetime.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"

extern HANDLE g_hLogFile;

/*****************************************************************************
 *
 *  Dynamic Globals.  There should be as few of these as possible.
 *
 *  All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

ULONG g_cRef = 0;           // Global reference count
CRITICAL_SECTION g_csDll;   // The shared critical section


#ifdef DEBUG
DWORD g_TlsMem = 0xffffffff;
#endif // DEBUG

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

/*****************************************************************************
 *
 *  DllAddRef / DllRelease
 *
 *  Maintain the DLL reference count.
 *
 *****************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

void DllRelease(void)
{
    ASSERT( 0 != g_cRef );
    InterlockedDecrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *  DllGetClassObject
 *
 *  OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *  The artificial refcount inside DllGetClassObject helps to
 *  avoid the race condition described in DllCanUnloadNow.  It's
 *  not perfect, but it makes the race window much smaller.
 *
 *****************************************************************************/

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    DllAddRef();
    
    hres = CClassFactory_Create(rclsid, riid, ppvObj);
    
    DllRelease();
    return hres;
}

/*****************************************************************************
 *
 *  DllCanUnloadNow
 *
 *  OLE entry point.  Fail iff there are outstanding refs.
 *
 *  There is an unavoidable race condition between DllCanUnloadNow
 *  and the creation of a new IClassFactory:  Between the time we
 *  return from DllCanUnloadNow() and the caller inspects the value,
 *  another thread in the same process may decide to call
 *  DllGetClassObject, thus suddenly creating an object in this DLL
 *  when there previously was none.
 *
 *  It is the caller's responsibility to prepare for this possibility;
 *  there is nothing we can do about it.
 *
 *****************************************************************************/

STDMETHODIMP DllCanUnloadNow(void)
{
    HRESULT hres;

    ENTERCRITICAL;

    hres = g_cRef ? S_FALSE : S_OK;

    if (S_OK == hres)
    {
        hres = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    }

    TraceMsg(TF_WMTHEME, "DllCanUnloadNow() returning hres=%#08lx. (S_OK means yes)", hres);

    LEAVECRITICAL;

    return hres;
}

/*****************************************************************************
 *
 *  Entry32
 *
 *  DLL entry point.
 *
 *****************************************************************************/
STDAPI_(BOOL) DllEntry(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    static s_hresOle = E_FAIL;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef DEBUG
            CcshellGetDebugFlags();
#endif

            InitializeCriticalSection(&g_csDll);

            g_hinst = hinst;
            DisableThreadLibraryCalls(hinst);

            SHFusionInitializeFromModuleID(hinst, 124);
            break;
        }

        case DLL_PROCESS_DETACH:
        {
            DeleteCriticalSection(&g_csDll);
            if (INVALID_HANDLE_VALUE != g_hLogFile)
            {
                CloseHandle(g_hLogFile);
            }

            SHFusionUninitialize();

            break;
        }
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\displaysettings.cpp ===
/**************************************************************************\
* Module Name: settings.cpp
*
* Contains Implementation of the CDisplaySettings class who is in charge of
* the settings of a single display. This is the data base class who does the
* real change display settings work
*
* Copyright (c) Microsoft Corp.  1992-1998 All Rights Reserved
*
\**************************************************************************/


#include "priv.h"

#include "DisplaySettings.h"
#include "ntreg.hxx"

extern int AskDynaCDS(HWND hDlg);
INT_PTR CALLBACK KeepNewDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);

UINT g_cfDisplayDevice = 0;
UINT g_cfDisplayName = 0;
UINT g_cfDisplayDeviceID = 0;
UINT g_cfMonitorDevice = 0;
UINT g_cfMonitorName = 0;
UINT g_cfMonitorDeviceID = 0;
UINT g_cfExtensionInterface = 0;
UINT g_cfDisplayDeviceKey = 0;
UINT g_cfDisplayStateFlags = 0;
UINT g_cfDisplayPruningMode = 0;

#define TF_DISPLAYSETTINGS      0

/*****************************************************************\
*
* helper routine
*
\*****************************************************************/

int CDisplaySettings::_InsertSortedDwords(
    int val1,
    int val2,
    int cval,
    int **ppval)
{
    int *oldpval = *ppval;
    int *tmppval;
    int  i;

    for (i=0; i<cval; i++)
    {
        tmppval = (*ppval) + (i * 2);

        if (*tmppval == val1)
        {
            if (*(tmppval + 1) == val2)
            {
                return cval;
            }
            else if (*(tmppval + 1) > val2)
            {
                break;
            }
        }
        else if (*tmppval > val1)
        {
            break;
        }
    }

    TraceMsg(TF_FUNC,"_InsertSortedDword, vals = %d %d, cval = %d, index = %d", val1, val2, cval, i);

    *ppval = (int *) LocalAlloc(LPTR, (cval + 1) * 2 * sizeof(DWORD));

    if (*ppval)
    {
        //
        // Insert the items at the right location in the array
        //
        if (oldpval) {
            CopyMemory(*ppval,
                       oldpval,
                       i * 2 * sizeof(DWORD));
        }

        *(*ppval + (i * 2))     = val1;
        *(*ppval + (i * 2) + 1) = val2;

        if (oldpval) {
            CopyMemory((*ppval) + 2 * (i + 1),
                        oldpval+ (i * 2),
                        (cval-i) * 2 * sizeof(DWORD));

            LocalFree(oldpval);
        }

        return (cval + 1);
    }

    return 0;
}

/*****************************************************************\
*
* debug routine
*
\*****************************************************************/

#ifdef DEBUG

void CDisplaySettings::_Dump_CDisplaySettings(BOOL bAll)
{
    TraceMsg(TF_DUMP_CSETTINGS,"Dump of CDisplaySettings structure");
    TraceMsg(TF_DUMP_CSETTINGS,"\t _DisplayDevice  = %s",     _pDisplayDevice->DeviceName);
    TraceMsg(TF_DUMP_CSETTINGS,"\t _cpdm           = %d",     _cpdm     );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _apdm           = %08lx",  _apdm     );

    TraceMsg(TF_DUMP_CSETTINGS,"\t OrgResolution   = %d, %d", _ORGXRES, _ORGYRES    );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _ptOrgPos       = %d, %d", _ptOrgPos.x ,_ptOrgPos.y);
    TraceMsg(TF_DUMP_CSETTINGS,"\t OrgColor        = %d",     _ORGCOLOR      );
    TraceMsg(TF_DUMP_CSETTINGS,"\t OrgFrequency    = %d",     _ORGFREQ  );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _pOrgDevmode    = %08lx",  _pOrgDevmode   );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _fOrgAttached   = %d",     _fOrgAttached  );

    TraceMsg(TF_DUMP_CSETTINGS,"\t CurResolution   = %d, %d", _CURXRES, _CURYRES     );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _ptCurPos       = %d, %d", _ptCurPos.x ,_ptCurPos.y);
    TraceMsg(TF_DUMP_CSETTINGS,"\t CurColor        = %d",     _CURCOLOR      );
    TraceMsg(TF_DUMP_CSETTINGS,"\t CurFrequency    = %d",     _CURFREQ  );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _pCurDevmode    = %08lx",  _pCurDevmode   );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _fCurAttached   = %d",     _fCurAttached  );

    TraceMsg(TF_DUMP_CSETTINGS,"\t _fUsingDefault  = %d",     _fUsingDefault );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _fPrimary       = %d",     _fPrimary      );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _cRef           = %d",     _cRef          );

    if (bAll)
    {
        _Dump_CDevmodeList();
    }
}

void CDisplaySettings::_Dump_CDevmodeList(VOID)
{
    ULONG i;

    for (i=0; _apdm && (i<_cpdm); i++)
    {
        LPDEVMODE lpdm = (_apdm + i)->lpdm;

        TraceMsg(TF_DUMP_CSETTINGS,"\t\t mode %d, %08lx, Flags %08lx, X=%d Y=%d C=%d F=%d O=%d FO=%d",
                 i, lpdm, (_apdm + i)->dwFlags, 
                 lpdm->dmPelsWidth, lpdm->dmPelsHeight, lpdm->dmBitsPerPel, lpdm->dmDisplayFrequency,
                 lpdm->dmDisplayOrientation, lpdm->dmDisplayFixedOutput);
    }
}

void CDisplaySettings::_Dump_CDevmode(LPDEVMODE pdm)
{
    TraceMsg(TF_DUMP_DEVMODE,"  Size        = %d",    pdm->dmSize);
    TraceMsg(TF_DUMP_DEVMODE,"  Fields      = %08lx", pdm->dmFields);
    TraceMsg(TF_DUMP_DEVMODE,"  XPosition   = %d",    pdm->dmPosition.x);
    TraceMsg(TF_DUMP_DEVMODE,"  YPosition   = %d",    pdm->dmPosition.y);
    TraceMsg(TF_DUMP_DEVMODE,"  XResolution = %d",    pdm->dmPelsWidth);
    TraceMsg(TF_DUMP_DEVMODE,"  YResolution = %d",    pdm->dmPelsHeight);
    TraceMsg(TF_DUMP_DEVMODE,"  Bpp         = %d",    pdm->dmBitsPerPel);
    TraceMsg(TF_DUMP_DEVMODE,"  Frequency   = %d",    pdm->dmDisplayFrequency);
    TraceMsg(TF_DUMP_DEVMODE,"  Flags       = %d",    pdm->dmDisplayFlags);
    TraceMsg(TF_DUMP_DEVMODE,"  XPanning    = %d",    pdm->dmPanningWidth);
    TraceMsg(TF_DUMP_DEVMODE,"  YPanning    = %d",    pdm->dmPanningHeight);
    TraceMsg(TF_DUMP_DEVMODE,"  DPI         = %d",    pdm->dmLogPixels);
    TraceMsg(TF_DUMP_DEVMODE,"  DriverExtra = %d",    pdm->dmDriverExtra);
    TraceMsg(TF_DUMP_DEVMODE,"  Orientation = %d",    pdm->dmDisplayOrientation);
    TraceMsg(TF_DUMP_DEVMODE,"  FixedOutput = %d",    pdm->dmDisplayFixedOutput);
    if (pdm->dmDriverExtra)
    {
        TraceMsg(TF_DUMP_CSETTINGS,"\t - %08lx %08lx",
        *(PULONG)(((PUCHAR)pdm)+pdm->dmSize),
        *(PULONG)(((PUCHAR)pdm)+pdm->dmSize + 4));
    }
}

#endif  // DEBUG

//
// Lets perform the following operations on the list
//
// (1) Remove identical modes
// (2) Remove 16 color modes for which there is a 256
//     color equivalent.
// (3) Remove modes with any dimension less than 640x480
//

void CDisplaySettings::_FilterModes()
{
    DWORD      i, j;
    LPDEVMODE  pdm, pdm2;
    PMODEARRAY pMode, pMode2;

    for (i = 0; _apdm && i < _cpdm; i++)
    {
        pMode = _apdm + i;
        pdm = pMode->lpdm;

        // Skip any invalid modes
        if (pMode->dwFlags & MODE_INVALID)
        {
            continue;
        }

        //
        // If any of the following conditions are true, then we want to
        // remove the current mode.
        //

        // Remove any modes that are too small
        if (pdm->dmPelsHeight < 480 || pdm->dmPelsWidth < 640)
        {
            TraceMsg(TF_DUMP_CSETTINGS,"_FilterModes: Mode %d - resolution too small", i);
            pMode->dwFlags |= MODE_INVALID;
            continue;
        }

        // Remove any modes that would change the orientation
        if (_bFilterOrientation)
        {
            if (pdm->dmFields & DM_DISPLAYORIENTATION && 
                pdm->dmDisplayOrientation != _dwOrientation)
            {
                pMode->dwFlags |= MODE_INVALID;
                TraceMsg(TF_DUMP_CSETTINGS,"_FilterModes: Mode %d - Wrong Orientation", i);
                continue;
            }
        }

        // Remove any modes that would change fixed output unless our current mode is 
        // native resolution
        if (_bFilterFixedOutput && _dwFixedOutput != DMDFO_DEFAULT)
        {
            if (pdm->dmFields & DM_DISPLAYFIXEDOUTPUT &&
                pdm->dmDisplayFixedOutput != _dwFixedOutput)
            {
                pMode->dwFlags |= MODE_INVALID;
                TraceMsg(TF_DUMP_CSETTINGS,"_FilterModes: Mode %d - Wrong FixedOutput", i);
                continue;
            }
        }
                
        // Remove any duplicate modes
        for (j = i + 1; j < _cpdm; j++)
        {
            pMode2 = _apdm + j;
            pdm2 = pMode2->lpdm;

            if (!(pMode2->dwFlags & MODE_INVALID) &&
                pdm2->dmBitsPerPel == pdm->dmBitsPerPel &&
                pdm2->dmPelsWidth == pdm->dmPelsWidth &&
                pdm2->dmPelsHeight == pdm->dmPelsHeight &&
                pdm2->dmDisplayFrequency == pdm->dmDisplayFrequency)
            {
                TraceMsg(TF_DUMP_CSETTINGS,"_FilterModes: Mode %d - Duplicate Mode", i);
                pMode2->dwFlags |= MODE_INVALID;
            }
        }
    }
}


//
// _AddDevMode method
//
//  This method builds the index lists for the matrix.  There is one
//  index list for each axes of the three dimemsional matrix of device
//  modes.
//
// The entry is also automatically added to the linked list of modes if
// it is not alreay present in the list.
//

BOOL CDisplaySettings::_AddDevMode(LPDEVMODE lpdm)
{
    if (lpdm)
    {
        PMODEARRAY newapdm, tempapdm;

        newapdm = (PMODEARRAY) LocalAlloc(LPTR, (_cpdm + 1) * sizeof(MODEARRAY));
        if (newapdm)
        {
            CopyMemory(newapdm, _apdm, _cpdm * sizeof(MODEARRAY));

            (newapdm + _cpdm)->dwFlags &= ~MODE_INVALID;
            (newapdm + _cpdm)->dwFlags |= MODE_RAW;
            (newapdm + _cpdm)->lpdm     = lpdm;

        }

        tempapdm = _apdm;
        _apdm = newapdm;
        _cpdm++;

        if (tempapdm)
        {
            LocalFree(tempapdm);
        }
    }

    return TRUE;
}

//
// Return a list of Resolutions supported, given a color depth
//

int CDisplaySettings::GetResolutionList(
    int Color,
    PPOINT *ppRes)
{
    DWORD      i;
    int        cRes = 0;
    int       *pResTmp = NULL;
    LPDEVMODE  pdm;

    *ppRes = NULL;

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        if(!_IsModeVisible(i))
        {
            continue;
        }

        if(!_IsModePreferred(i))
        {
            continue;
        }

        pdm = (_apdm + i)->lpdm;

        if ((Color == -1) ||
            (Color == (int)pdm->dmBitsPerPel))
        {
            cRes = _InsertSortedDwords(pdm->dmPelsWidth,
                                       pdm->dmPelsHeight,
                                       cRes,
                                       &pResTmp);
        }
    }

    *ppRes = (PPOINT) pResTmp;

    return cRes;
}

//
//
// Return a list of color depths supported
//

int CDisplaySettings::GetColorList(
    LPPOINT Res,
    PLONGLONG *ppColor)
{
    DWORD      i;
    int        cColor = 0;
    int       *pColorTmp = NULL;
    LPDEVMODE  pdm;

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        if(!_IsModeVisible(i))
        {
            continue;
        }

        if(!_IsModePreferred(i))
        {
            continue;
        }

        pdm = (_apdm + i)->lpdm;

        if ((Res == NULL) ||
            (Res->x == -1)                    ||
            (Res->y == -1)                    ||
            (Res->x == (int)pdm->dmPelsWidth) ||
            (Res->y == (int)pdm->dmPelsHeight))
        {
            cColor = _InsertSortedDwords(pdm->dmBitsPerPel,
                                         0,
                                         cColor,
                                         &pColorTmp);
        }
    }

    *ppColor = (PLONGLONG) pColorTmp;

    return cColor;
}

int CDisplaySettings::GetFrequencyList(int Color, LPPOINT Res, PLONGLONG *ppFreq)
{
    DWORD      i;
    int        cFreq = 0;
    int       *pFreqTmp = NULL;
    LPDEVMODE  pdm;
    POINT      res;

    if (Color == -1) {
        Color = _CURCOLOR;
    }

    if (Res == NULL) 
    {
        MAKEXYRES(&res, _CURXRES, _CURYRES);
    }
    else
    {
        res = *Res;
    }

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        if(!_IsModeVisible(i))
        {
            continue;
        }

        pdm = (_apdm + i)->lpdm;

        if (res.x == (int)pdm->dmPelsWidth  &&
            res.y == (int)pdm->dmPelsHeight &&
            Color == (int)pdm->dmBitsPerPel) 
        {
            cFreq = _InsertSortedDwords(pdm->dmDisplayFrequency,
                                         0,
                                         cFreq,
                                         &pFreqTmp);
        }
    }

    *ppFreq = (PLONGLONG) pFreqTmp;

    return cFreq;
}

void CDisplaySettings::_SetCurrentValues(LPDEVMODE lpdm)
{
    _pCurDevmode = lpdm;

    //
    // Don't save the other fields (like position) as they are programmed by
    // the UI separately.
    //
    // This should only save hardware specific fields.
    //
#ifdef DEBUG
    TraceMsg(TF_DUMP_CSETTINGS,"");
    TraceMsg(TF_DUMP_CSETTINGS,"_SetCurrentValues complete");
    _Dump_CDisplaySettings(FALSE);
#endif
}


BOOL CDisplaySettings::_PerfectMatch(LPDEVMODE lpdm)
{
    for (DWORD i = 0; _apdm && (i < _cpdm); i++)
    {
        if(!_IsModeVisible(i))
        {
            continue;
        }

        if ((_apdm + i)->lpdm == lpdm)
        {
            _SetCurrentValues((_apdm + i)->lpdm);

            TraceMsg(TF_DISPLAYSETTINGS, "_PerfectMatch -- return TRUE");

            return TRUE;
        }
    }

    TraceMsg(TF_DISPLAYSETTINGS, "_PerfectMatch -- return FALSE");

    return FALSE;
}

BOOL CDisplaySettings::_ExactMatch(LPDEVMODE lpdm, BOOL bForceVisible)
{
    LPDEVMODE pdm;
    ULONG i;

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        pdm = (_apdm + i)->lpdm;

        if (
            ((lpdm->dmFields & DM_BITSPERPEL) &&
             (pdm->dmBitsPerPel != lpdm->dmBitsPerPel))

            ||

            ((lpdm->dmFields & DM_PELSWIDTH) &&
             (pdm->dmPelsWidth != lpdm->dmPelsWidth))

            ||

            ((lpdm->dmFields & DM_PELSHEIGHT) &&
             (pdm->dmPelsHeight != lpdm->dmPelsHeight))

            ||

            ((lpdm->dmFields & DM_DISPLAYFREQUENCY) &&
             (pdm->dmDisplayFrequency != lpdm->dmDisplayFrequency))
           )
        {
           continue;
        }

        if (!_IsModeVisible(i))
        {
            if (bForceVisible &&
                ((((_apdm + i)->dwFlags) & MODE_INVALID) == 0) &&
                _bIsPruningOn &&
                ((((_apdm + i)->dwFlags) & MODE_RAW) == MODE_RAW))
            {
                (_apdm + i)->dwFlags &= ~MODE_RAW;
            }
            else
            {
                continue;
            }
        }

        _SetCurrentValues(pdm);

        TraceMsg(TF_DISPLAYSETTINGS, "_ExactMatch -- return TRUE");

        return TRUE;
    }

    TraceMsg(TF_DISPLAYSETTINGS, "_ExactMatch -- return FALSE");

    return FALSE;
}


// JoelGros defined a feature where we prefer to give the user
// a color depth of at least 32-bit, or as close to that as the
// display supports.  Bryan Starbuck (BryanSt) 3/9/2000
#define MAX_PREFERED_COLOR_DEPTH        32

void CDisplaySettings::_BestMatch(LPPOINT Res, int Color, IN BOOL fAutoSetColorDepth)
{
    // -1 means match loosely, based on current _xxx value
    LPDEVMODE pdm;
    LPDEVMODE pdmMatch = NULL;
    ULONG i;

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        if(!_IsModeVisible(i))
        {
            continue;
        }

        pdm = (_apdm + i)->lpdm;

        // Take care of exact matches
        if ((Color != -1) &&
            (Color != (int)pdm->dmBitsPerPel))
        {
            continue;
        }

        if ((Res != NULL)  &&
            (Res->x != -1) &&
            ( (Res->x != (int)pdm->dmPelsWidth) ||
              (Res->y != (int)pdm->dmPelsHeight)) )
        {
            continue;
        }

        // Find Best Match
        if (pdmMatch == NULL)
        {
            pdmMatch = pdm;
        }

        // Find best Color.
        if (Color == -1)        // Do they want best color matching?
        {
            if (fAutoSetColorDepth)
            {
                // This will use the "auto-set a good color depth" feature.

                // The best match color depth will not equal the current color depth if
                // we are going to need to work closer and closer to our desired color depth.
                // (We may never reach it because the user may just have increased the resolution
                //  so the current color depth isn't supported)

                // We prefer keep increasing the color depth to at least the current color depth.
                // That may not be possible if that depth isn't supported at this resolution. 
                // We also would like to keep increasing it until we hit MAX_PREFERED_COLOR_DEPTH
                // because colors of at least that deep benefit users.

                // Do we need to decrease the color depth?  Yes if
                if (((int)pdmMatch->dmBitsPerPel > _CURCOLOR) &&               // the match is more than the current, and
                    ((int)pdmMatch->dmBitsPerPel > MAX_PREFERED_COLOR_DEPTH))   // the match is more than the prefered max
                {
                    // We will want to decrease it if this entry is smaller than our match.
                    if ((int)pdm->dmBitsPerPel < (int)pdmMatch->dmBitsPerPel)
                    {
                        pdmMatch = pdm;
                    }
                }
                else
                {
                    // We want to increase it if:
                    if (((int)pdm->dmBitsPerPel > (int)pdmMatch->dmBitsPerPel) &&   // this entry is larger than our match, and
                        ((int)pdm->dmBitsPerPel <= max(_CURCOLOR, MAX_PREFERED_COLOR_DEPTH))) // this doesn't take us over our prefered max or current depth (which ever is higher).
                    {
                        pdmMatch = pdm;
                    }
                }
            }
            else
            {
                // This falls back to the old behavior.
                if ((int)pdmMatch->dmBitsPerPel > _CURCOLOR)
                {
                    if ((int)pdm->dmBitsPerPel < (int)pdmMatch->dmBitsPerPel)
                    {
                        pdmMatch = pdm;
                    }
                }
                else
                {
                    if (((int)pdm->dmBitsPerPel > (int)pdmMatch->dmBitsPerPel) &&
                        ((int)pdm->dmBitsPerPel <= _CURCOLOR))
                    {
                        pdmMatch = pdm;
                    }
                }
            }
        }

        // Find best Resolution.
        if (((Res == NULL) || (Res->x == -1)) &&
            (((int)pdmMatch->dmPelsWidth  != _CURXRES) ||
             ((int)pdmMatch->dmPelsHeight != _CURYRES)))
        {
            if (((int)pdmMatch->dmPelsWidth   >  _CURXRES) ||
                (((int)pdmMatch->dmPelsWidth  == _CURXRES) &&
                 ((int)pdmMatch->dmPelsHeight >  _CURYRES)))
            {
                if (((int)pdm->dmPelsWidth  <  (int)pdmMatch->dmPelsWidth) ||
                    (((int)pdm->dmPelsWidth  == (int)pdmMatch->dmPelsWidth) &&
                     ((int)pdm->dmPelsHeight <  (int)pdmMatch->dmPelsHeight)))
                {
                    pdmMatch = pdm;
                }
            }
            else
            {
                if (((int)pdm->dmPelsWidth  >  (int)pdmMatch->dmPelsWidth) ||
                    (((int)pdm->dmPelsWidth  == (int)pdmMatch->dmPelsWidth) &&
                     ((int)pdm->dmPelsHeight >  (int)pdmMatch->dmPelsHeight)))
                {
                    if (((int)pdm->dmPelsWidth  <= _CURXRES) ||
                        (((int)pdm->dmPelsWidth  == _CURXRES) &&
                         ((int)pdm->dmPelsHeight <= _CURYRES)))
                    {
                        pdmMatch = pdm;
                    }
                }
            }
        }

        // Find best Frequency.
        if (((int)pdmMatch->dmDisplayFrequency != _CURFREQ) &&
            (!((Res == NULL) && 
               ((int)pdmMatch->dmPelsWidth  == _CURXRES) &&
               ((int)pdmMatch->dmPelsHeight == _CURYRES) &&
               (((int)pdm->dmPelsWidth  != _CURXRES) ||
                ((int)pdm->dmPelsHeight != _CURYRES)))) &&
            (!((Color == -1) && 
               ((int)pdmMatch->dmBitsPerPel == _CURCOLOR) &&
               ((int)pdm->dmBitsPerPel != _CURCOLOR))))
        {
            if ((int)pdmMatch->dmDisplayFrequency > _CURFREQ)
            {
                if ((int)pdm->dmDisplayFrequency < (int)pdmMatch->dmDisplayFrequency)
                {
                    pdmMatch = pdm;
                }
            }
            else
            {
                if (((int)pdm->dmDisplayFrequency > (int)pdmMatch->dmDisplayFrequency) &&
                    ((int)pdm->dmDisplayFrequency <= _CURFREQ))
                {
                    pdmMatch = pdm;
                }
            }
        }
    }

    _SetCurrentValues(pdmMatch);
}


BOOL CDisplaySettings::GetMonitorName(LPTSTR pszName, DWORD cchSize)
{
    DISPLAY_DEVICE ddTmp;
    DWORD cAttachedMonitors = 0, nMonitor = 0;

    ZeroMemory(&ddTmp, sizeof(ddTmp));
    ddTmp.cb = sizeof(DISPLAY_DEVICE);

    while (EnumDisplayDevices(_pDisplayDevice->DeviceName, nMonitor, &ddTmp, 0))
    {
        if (ddTmp.StateFlags & DISPLAY_DEVICE_ATTACHED) 
        {
            ++cAttachedMonitors;
            if (cAttachedMonitors > 1)
                break;

            // Single monitor
            StringCchCopy(pszName, cchSize, (LPTSTR)ddTmp.DeviceString);
        }
        
        ++nMonitor;

        ZeroMemory(&ddTmp, sizeof(ddTmp));
        ddTmp.cb = sizeof(DISPLAY_DEVICE);
    }

    if (cAttachedMonitors == 0) 
    {
        // No monitors
        LoadString(HINST_THISDLL, IDS_UNKNOWNMONITOR, pszName, cchSize);
    }
    else if (cAttachedMonitors > 1) 
    {
        // Multiple monitors
        LoadString(HINST_THISDLL, IDS_MULTIPLEMONITORS, pszName, cchSize);
    }

    return (cAttachedMonitors != 0);
}

BOOL CDisplaySettings::GetMonitorDevice(LPTSTR pszDevice, DWORD cchSize)
{
    DISPLAY_DEVICE ddTmp;

    ZeroMemory(&ddTmp, sizeof(ddTmp));
    ddTmp.cb = sizeof(DISPLAY_DEVICE);

    if (EnumDisplayDevices(_pDisplayDevice->DeviceName, 0, &ddTmp, 0))
    {
        StringCchCopy(pszDevice, cchSize, (LPTSTR)ddTmp.DeviceName);

        return TRUE;
    }

    return FALSE;
}

STDMETHODIMP CDisplaySettings::GetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    HRESULT hr;

    ASSERT(this);
    ASSERT(pfmtetc);
    ASSERT(pstgmed);

    // Ignore pfmtetc.ptd.  All supported data formats are device-independent.

    ZeroMemory(pstgmed, sizeof(*pstgmed));

    if ((hr = QueryGetData(pfmtetc)) == S_OK)
    {
        LPTSTR pszOut = NULL;
        TCHAR szMonitorName[130];
        TCHAR szMonitorDevice[40];

        if (pfmtetc->cfFormat == g_cfExtensionInterface)
        {
            //
            // Get the array of information back to the device
            //
            // Allocate a buffer large enough to store all of the information
            //

            PDESK_EXTENSION_INTERFACE pInterface;

            pInterface = (PDESK_EXTENSION_INTERFACE)
                GlobalAlloc(GPTR, sizeof(DESK_EXTENSION_INTERFACE));

            if (pInterface)
            {
                CRegistrySettings * RegSettings = new CRegistrySettings(_pDisplayDevice->DeviceKey);

                if (RegSettings)
                {
                    pInterface->cbSize    = sizeof(DESK_EXTENSION_INTERFACE);
                    pInterface->pContext  = this;

                    pInterface->lpfnEnumAllModes    = CDisplaySettings::_lpfnEnumAllModes;
                    pInterface->lpfnSetSelectedMode = CDisplaySettings::_lpfnSetSelectedMode;
                    pInterface->lpfnGetSelectedMode = CDisplaySettings::_lpfnGetSelectedMode;
                    pInterface->lpfnSetPruningMode = CDisplaySettings::_lpfnSetPruningMode;
                    pInterface->lpfnGetPruningMode = CDisplaySettings::_lpfnGetPruningMode;

                    RegSettings->GetHardwareInformation(&pInterface->Info);

                    pstgmed->tymed = TYMED_HGLOBAL;
                    pstgmed->hGlobal = pInterface;
                    pstgmed->pUnkForRelease = NULL;

                    hr = S_OK;

                    delete RegSettings;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else if (pfmtetc->cfFormat == g_cfMonitorDeviceID)
        {
            hr = E_UNEXPECTED;
        }
        else if (pfmtetc->cfFormat == g_cfDisplayStateFlags)
        {
            DWORD* pdwStateFlags = (DWORD*)GlobalAlloc(GPTR, sizeof(DWORD));
            if (pdwStateFlags)
            {
                *pdwStateFlags = _pDisplayDevice->StateFlags;
                pstgmed->tymed = TYMED_HGLOBAL;
                pstgmed->hGlobal = pdwStateFlags;
                pstgmed->pUnkForRelease = NULL;
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else if (pfmtetc->cfFormat == g_cfDisplayPruningMode)
        {
            BYTE* pPruningMode = (BYTE*)GlobalAlloc(GPTR, sizeof(BYTE));
            if (pPruningMode)
            {
                *pPruningMode = (BYTE)(_bCanBePruned && _bIsPruningOn ? 1 : 0);
                pstgmed->tymed = TYMED_HGLOBAL;
                pstgmed->hGlobal = pPruningMode;
                pstgmed->pUnkForRelease = NULL;
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else if (pfmtetc->cfFormat == g_cfDisplayDeviceID)
        {
            {
                CRegistrySettings *pRegSettings = new CRegistrySettings(_pDisplayDevice->DeviceKey);
                if (pRegSettings)
                {
                    pszOut = pRegSettings->GetDeviceInstanceId();
                    hr = CopyDataToStorage(pstgmed, pszOut);
                    delete pRegSettings;
                }
                else 
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            
        }
        else
        {
            if (pfmtetc->cfFormat == g_cfMonitorName)
            {
                GetMonitorName(szMonitorName, ARRAYSIZE(szMonitorName));
                pszOut = szMonitorName;
            }
            else if (pfmtetc->cfFormat == g_cfMonitorDevice)
            {
                GetMonitorDevice(szMonitorDevice, ARRAYSIZE(szMonitorDevice));
                pszOut = szMonitorDevice;
            }
            else if (pfmtetc->cfFormat == g_cfDisplayDevice)
            {
                pszOut = (LPTSTR)_pDisplayDevice->DeviceName;
            }
            else if (pfmtetc->cfFormat == g_cfDisplayDeviceKey)
            {
                pszOut = (LPTSTR)_pDisplayDevice->DeviceKey;
            }
            else 
            {
                ASSERT(pfmtetc->cfFormat == g_cfDisplayName);
                
                pszOut = (LPTSTR)_pDisplayDevice->DeviceString;
            }

            hr = CopyDataToStorage(pstgmed, pszOut);
        }
    }

    return(hr);
}

STDMETHODIMP CDisplaySettings::CopyDataToStorage(STGMEDIUM *pstgmed, LPTSTR pszOut)
{
    HRESULT hr = E_UNEXPECTED;
    int cch;

    if (NULL != pszOut) 
    {
        cch = lstrlen(pszOut) + 1;

        LPWSTR pwszDevice = (LPWSTR)GlobalAlloc(GPTR, cch * sizeof(WCHAR));
        if (pwszDevice)
        {
            //
            // We always return UNICODE string
            //
            StringCchCopy(pwszDevice, cch, pszOut);
            pstgmed->tymed = TYMED_HGLOBAL;
            pstgmed->hGlobal = pwszDevice;
            pstgmed->pUnkForRelease = NULL;

            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


STDMETHODIMP CDisplaySettings::GetDataHere(FORMATETC *pfmtetc, STGMEDIUM *pstgpmed)
{
    ZeroMemory(pfmtetc, sizeof(*pfmtetc));
    return E_NOTIMPL;
}

//
// Check that all the parameters to the interface are appropriately
//

STDMETHODIMP CDisplaySettings::QueryGetData(FORMATETC *pfmtetc)
{
    CLIPFORMAT cfFormat;

    if (pfmtetc->dwAspect != DVASPECT_CONTENT)
    {
        return DV_E_DVASPECT;
    }

    if ((pfmtetc->tymed & TYMED_HGLOBAL) == 0)
    {
        return  DV_E_TYMED;
    }

    cfFormat = pfmtetc->cfFormat;

    if ((cfFormat != g_cfDisplayDevice) &&
        (cfFormat != g_cfDisplayName)   &&
        (cfFormat != g_cfDisplayDeviceID)   &&
        (cfFormat != g_cfMonitorDevice) &&
        (cfFormat != g_cfMonitorName)   &&
        (cfFormat != g_cfMonitorDeviceID)   &&
        (cfFormat != g_cfExtensionInterface) &&
        (cfFormat != g_cfDisplayDeviceKey) &&
        (cfFormat != g_cfDisplayStateFlags) &&
        (cfFormat != g_cfDisplayPruningMode))
    {
        return DV_E_FORMATETC;
    }

    if (pfmtetc->lindex != -1)
    {
        return DV_E_LINDEX;
    }

    return S_OK;
}

STDMETHODIMP CDisplaySettings::GetCanonicalFormatEtc(FORMATETC *pfmtetcIn, FORMATETC *pfmtetcOut)
{
    HRESULT hr;
    ASSERT(pfmtetcIn);
    ASSERT(pfmtetcOut);

    hr = QueryGetData(pfmtetcIn);

    if (hr == S_OK)
    {
        *pfmtetcOut = *pfmtetcIn;

        if (pfmtetcIn->ptd == NULL)
            hr = DATA_S_SAMEFORMATETC;
        else
        {
            pfmtetcIn->ptd = NULL;
            ASSERT(hr == S_OK);
        }
    }
    else
        ZeroMemory(pfmtetcOut, sizeof(*pfmtetcOut));
    return(hr);
}


STDMETHODIMP CDisplaySettings::SetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed, BOOL bRelease)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDisplaySettings::EnumFormatEtc(DWORD dwDirFlags, IEnumFORMATETC ** ppiefe)
{
    HRESULT hr;

    ASSERT(ppiefe);
    *ppiefe = NULL;

    if (dwDirFlags == DATADIR_GET)
    {
        FORMATETC rgfmtetc[] =
        {
            { (CLIPFORMAT)g_cfDisplayDevice,      NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfDisplayName,        NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfMonitorDevice,      NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfMonitorName,        NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfExtensionInterface, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfDisplayDeviceID,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfMonitorDeviceID,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfDisplayDeviceKey,   NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfDisplayStateFlags,  NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfDisplayPruningMode, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        };

        hr = SHCreateStdEnumFmtEtc(ARRAYSIZE(rgfmtetc), rgfmtetc, ppiefe);
    }
    else
        hr = E_NOTIMPL;

    return(hr);
}

STDMETHODIMP CDisplaySettings::DAdvise(FORMATETC *pfmtetc, DWORD dwAdviseFlags, IAdviseSink * piadvsink, DWORD * pdwConnection)
{
    ASSERT(pfmtetc);
    ASSERT(pdwConnection);

    *pdwConnection = 0;
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CDisplaySettings::DUnadvise(DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CDisplaySettings::EnumDAdvise(IEnumSTATDATA ** ppiesd)
{
    ASSERT(ppiesd);
    *ppiesd = NULL;
    return OLE_E_ADVISENOTSUPPORTED;
}


void CDisplaySettings::_InitClipboardFormats()
{
    if (g_cfDisplayDevice == 0)
        g_cfDisplayDevice = RegisterClipboardFormat(DESKCPLEXT_DISPLAY_DEVICE);

    if (g_cfDisplayDeviceID == 0)
        g_cfDisplayDeviceID = RegisterClipboardFormat(DESKCPLEXT_DISPLAY_ID);
        
    if (g_cfDisplayName == 0)
        g_cfDisplayName = RegisterClipboardFormat(DESKCPLEXT_DISPLAY_NAME);

    if (g_cfMonitorDevice == 0)
        g_cfMonitorDevice = RegisterClipboardFormat(DESKCPLEXT_MONITOR_DEVICE);

    if (g_cfMonitorDeviceID == 0)
        g_cfMonitorDeviceID = RegisterClipboardFormat(DESKCPLEXT_MONITOR_ID);
        
    if (g_cfMonitorName == 0)
        g_cfMonitorName = RegisterClipboardFormat(DESKCPLEXT_MONITOR_NAME);

    if (g_cfExtensionInterface == 0)
        g_cfExtensionInterface = RegisterClipboardFormat(DESKCPLEXT_INTERFACE);

    if (g_cfDisplayDeviceKey == 0)
        g_cfDisplayDeviceKey = RegisterClipboardFormat(DESKCPLEXT_DISPLAY_DEVICE_KEY);

    if (g_cfDisplayStateFlags == 0)
        g_cfDisplayStateFlags = RegisterClipboardFormat(DESKCPLEXT_DISPLAY_STATE_FLAGS);
    
    if (g_cfDisplayPruningMode == 0)
        g_cfDisplayPruningMode = RegisterClipboardFormat(DESKCPLEXT_PRUNING_MODE);
}

HRESULT CDisplaySettings::QueryInterface(REFIID riid, LPVOID * ppvObj)
{ 
    static const QITAB qit[] = {
        QITABENT(CDisplaySettings, IDataObject),
        QITABENT(CDisplaySettings, IDisplaySettings),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


ULONG CDisplaySettings::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDisplaySettings::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


STDMETHODIMP_(LPDEVMODEW)
CDisplaySettings::_lpfnEnumAllModes(
    LPVOID pContext,
    DWORD iMode)
{
    DWORD cCount = 0;
    DWORD i;

    CDisplaySettings *pSettings = (CDisplaySettings *) pContext;

    for (i = 0; pSettings->_apdm && (i < pSettings->_cpdm); i++)
    {
        // Don't show invalid modes or raw modes if pruning is on;

        if(!_IsModeVisible(pSettings, i))
        {
            continue;
        }

        if (cCount == iMode)
        {
            return (pSettings->_apdm + i)->lpdm;
        }

        cCount++;
    }

    return NULL;
}

STDMETHODIMP_(BOOL)
CDisplaySettings::_lpfnSetSelectedMode(
    LPVOID pContext,
    LPDEVMODEW lpdm)
{
    CDisplaySettings *pSettings = (CDisplaySettings *) pContext;

    return pSettings->_PerfectMatch(lpdm);
}

STDMETHODIMP_(LPDEVMODEW)
CDisplaySettings::_lpfnGetSelectedMode(
    LPVOID pContext
    )
{
    CDisplaySettings *pSettings = (CDisplaySettings *) pContext;

    return pSettings->_pCurDevmode;
}

STDMETHODIMP_(VOID)
CDisplaySettings::_lpfnSetPruningMode(
    LPVOID pContext,
    BOOL bIsPruningOn)
{
    CDisplaySettings *pSettings = (CDisplaySettings *) pContext;
    pSettings->SetPruningMode(bIsPruningOn);
}

STDMETHODIMP_(VOID)
CDisplaySettings::_lpfnGetPruningMode(
    LPVOID pContext,
    BOOL* pbCanBePruned,
    BOOL* pbIsPruningReadOnly,
    BOOL* pbIsPruningOn)
{
    CDisplaySettings *pSettings = (CDisplaySettings *) pContext;
    pSettings->GetPruningMode(pbCanBePruned, 
                              pbIsPruningReadOnly, 
                              pbIsPruningOn);
}

// If any attached device is at 640x480, we want to force small font
BOOL CDisplaySettings::IsSmallFontNecessary()
{
    if (_fOrgAttached || _fCurAttached)
    {
        //
        // Force Small fonts at 640x480
        //
        if (_CURXRES < 800 || _CURYRES < 600)
            return TRUE;
    }
    return FALSE;
}

// Constructor for CDisplaySettings
//
//  (gets called when ever a CDisplaySettings object is created)
//

CDisplaySettings::CDisplaySettings() 
    : _cRef(1)
    , _cpdm(0) 
    , _apdm(0)
    , _hPruningRegKey(NULL)
    , _bCanBePruned(FALSE)
    , _bIsPruningReadOnly(TRUE)
    , _bIsPruningOn(FALSE)
    , _pOrgDevmode(NULL)
    , _pCurDevmode(NULL)
    , _fOrgAttached(FALSE)
    , _fCurAttached(FALSE)
    , _bFilterOrientation(FALSE)
    , _bFilterFixedOutput(FALSE)
{
    SetRectEmpty(&_rcPreview);
}

//
// Destructor
//
CDisplaySettings::~CDisplaySettings() {

    TraceMsg(TF_DISPLAYSETTINGS, "**** Destructing %s", _pDisplayDevice->DeviceName);

    if (_apdm)
    {
        while(_cpdm--)
        {
            LocalFree((_apdm + _cpdm)->lpdm);
        }
        LocalFree(_apdm);
        _apdm = NULL;
    }

    _cpdm = 0;

    if(NULL != _hPruningRegKey)
        RegCloseKey(_hPruningRegKey);
}


//
// InitSettings -- Enumerate the settings, and build the mode list when
//

BOOL CDisplaySettings::InitSettings(LPDISPLAY_DEVICE pDisplay)
{
    BOOL fReturn = FALSE;
    LPDEVMODE pdevmode = (LPDEVMODE) LocalAlloc(LPTR, (sizeof(DEVMODE) + 0xFFFF));

    if (pdevmode)
    {
        ULONG  i = 0;
        BOOL   bCurrent = FALSE;
        BOOL   bRegistry = FALSE;
        BOOL   bExact = FALSE;

        fReturn = TRUE;

        // Set the cached values for modes.
        MAKEXYRES(&_ptCurPos, 0, 0);
        _fCurAttached  = FALSE;
        _pCurDevmode   = NULL;

        // Save the display name
        ASSERT(pDisplay);

        _pDisplayDevice = pDisplay;

        TraceMsg(TF_GENERAL, "Initializing CDisplaySettings for %s", _pDisplayDevice->DeviceName);

        // Pruning Mode
        _bCanBePruned = ((_pDisplayDevice->StateFlags & DISPLAY_DEVICE_MODESPRUNED) != 0);
        _bIsPruningReadOnly = TRUE;
        _bIsPruningOn = FALSE;
        if (_bCanBePruned)
        {
            _bIsPruningOn = TRUE; // if can be pruned, by default pruning is on 
            GetDeviceRegKey(_pDisplayDevice->DeviceKey, &_hPruningRegKey, &_bIsPruningReadOnly);
            if (_hPruningRegKey)
            {
                DWORD dwIsPruningOn = 1;
                DWORD cb = sizeof(dwIsPruningOn);
                RegQueryValueEx(_hPruningRegKey, 
                                SZ_PRUNNING_MODE,
                                NULL, 
                                NULL, 
                                (LPBYTE)&dwIsPruningOn, 
                                &cb);
                _bIsPruningOn = (dwIsPruningOn != 0);
            }
        }

        // See if we need to filter modes by orientation and/or stretched/centered
        ZeroMemory(pdevmode,sizeof(DEVMODE));
        pdevmode->dmSize = sizeof(DEVMODE);

        if (EnumDisplaySettingsExWrap(_pDisplayDevice->DeviceName,
                                      ENUM_CURRENT_SETTINGS,
                                      pdevmode,
                                      0))
        {
            if (pdevmode->dmFields & DM_DISPLAYORIENTATION)
            {
                _bFilterOrientation = TRUE;
                _dwOrientation = pdevmode->dmDisplayOrientation;
                TraceMsg(TF_GENERAL, "Filtering modes on orientation %d", _dwOrientation);
            }
            if (pdevmode->dmFields & DM_DISPLAYFIXEDOUTPUT)
            {
                _bFilterFixedOutput = TRUE;
                _dwFixedOutput = pdevmode->dmDisplayFixedOutput;
                TraceMsg(TF_GENERAL, "Filtering modes on fixed output %d", _dwFixedOutput);
            }
        }
        
        // Lets generate a list with all the possible modes.
        pdevmode->dmSize = sizeof(DEVMODE);

        // Enum the raw list of modes
        while (EnumDisplaySettingsExWrap(_pDisplayDevice->DeviceName, i++, pdevmode, EDS_RAWMODE))
        {
            WORD      dmsize = pdevmode->dmSize + pdevmode->dmDriverExtra;
            LPDEVMODE lpdm = (LPDEVMODE) LocalAlloc(LPTR, dmsize);

            if (lpdm)
            {
                CopyMemory(lpdm, pdevmode, dmsize);
                _AddDevMode(lpdm);
            }

            pdevmode->dmDriverExtra = 0;
        }

        // Filter the list of modes

        _FilterModes();
        if(_bCanBePruned)
        {
            // Enum pruned list of modes
            i = 0;
            _bCanBePruned = FALSE;
        
            while (EnumDisplaySettingsExWrap(_pDisplayDevice->DeviceName, i++, pdevmode, 0))
            {
                if(_MarkMode(pdevmode))
                    _bCanBePruned = TRUE; // at least one non-raw mode  
                pdevmode->dmDriverExtra = 0;
            }

            if(!_bCanBePruned)
            {
                _bIsPruningReadOnly = TRUE;
                _bIsPruningOn = FALSE;
            }
        }

#ifdef DEBUG
        // Debug
        _Dump_CDisplaySettings(TRUE);
#endif

        // Get the current mode
        ZeroMemory(pdevmode,sizeof(*pdevmode));
        pdevmode->dmSize = sizeof(*pdevmode);

        bCurrent = EnumDisplaySettingsExWrap(_pDisplayDevice->DeviceName,
                                         ENUM_CURRENT_SETTINGS,
                                         pdevmode,
                                         0);

        if (!bCurrent)
        {
            TraceMsg(TF_DISPLAYSETTINGS, "InitSettings -- No Current Mode. Try to use registry settings.");
        
            ZeroMemory(pdevmode,sizeof(*pdevmode));
            pdevmode->dmSize = sizeof(*pdevmode);

            bRegistry = EnumDisplaySettingsExWrap(_pDisplayDevice->DeviceName,
                                              ENUM_REGISTRY_SETTINGS,
                                              pdevmode,
                                              0);
        }

        // Set the default values based on registry or current settings.
        if (bCurrent || bRegistry)
        {
#ifdef DEBUG
            // Check if this DEVMODE is in the list
            TraceMsg(TF_FUNC, "Devmode for Exact Matching");
            _Dump_CDevmode(pdevmode);
            TraceMsg(TF_FUNC, "");
#endif
            // If the current mode is not in the list of modes supported by 
            // the monitor, we want to show it anyway.
            // 
            // Consider the following scenario: the user sets the display 
            // to 1024x768 and after that it goes to DevManager and selects 
            // a monitor type that can not do that mode. When the user 
            // reopens the applet the current mode will be pruned out. 
            // In such a case we want the current mode to be visible.
            bExact = _ExactMatch(pdevmode, TRUE);

            // Is attached?
            if(bCurrent)
            {
                _fOrgAttached = _fCurAttached = ((pdevmode->dmFields & DM_POSITION) ? 1 : 0);
            }
        
            // Set the original values
            if (bExact == TRUE)
            {
                MAKEXYRES(&_ptCurPos, pdevmode->dmPosition.x, pdevmode->dmPosition.y);
                ConfirmChangeSettings();
            }
        }

        // If we have no modes, return FALSE.
        if (_cpdm == 0)
        {
            FmtMessageBox(ghwndPropSheet,
                          MB_ICONEXCLAMATION,
                          MSG_CONFIGURATION_PROBLEM,
                          MSG_INVALID_OLD_DISPLAY_DRIVER);

            fReturn = FALSE;
        }
        else
        {
            // If there were no current values, set some now
            // But don't confirm them ...
            if (bExact == FALSE)
            {
                TraceMsg(TF_DISPLAYSETTINGS, "InitSettings -- No Current OR Registry Mode");

                i = 0;
                // Try setting any mode as the current.
                while (_apdm && (_PerfectMatch((_apdm + i++)->lpdm) == FALSE))
                {
                    if (i > _cpdm)
                    {
                        FmtMessageBox(ghwndPropSheet,
                                      MB_ICONEXCLAMATION,
                                      MSG_CONFIGURATION_PROBLEM,
                                      MSG_INVALID_OLD_DISPLAY_DRIVER);

                        fReturn = FALSE;
                        break;
                    }
                }
        
                if (fReturn && _fCurAttached)
                {
                    MAKEXYRES(&_ptCurPos, _pCurDevmode->dmPosition.x, _pCurDevmode->dmPosition.y);
                }
            }

            if (fReturn)
            {
                // Export our interfaces for extended properly pages.
                _InitClipboardFormats();

#ifdef DEBUG
                // Final debug output
                TraceMsg(TF_DUMP_CSETTINGS," InitSettings successful - current values :");
                _Dump_CDisplaySettings(FALSE);
#endif
            }
        }

        LocalFree(pdevmode);
    }

    return TRUE;
}


// SaveSettings
//
//  Writes the new display parameters to the proper place in the
//  registry.
int CDisplaySettings::SaveSettings(DWORD dwSet)
{
    int iResult = 0;

    if (_pCurDevmode)
    {
        // Make a copy of the current devmode
        ULONG dmSize = _pCurDevmode->dmSize + _pCurDevmode->dmDriverExtra;
        PDEVMODE pdevmode  = (LPDEVMODE) LocalAlloc(LPTR, dmSize);

        if (pdevmode)
        {
            CopyMemory(pdevmode, _pCurDevmode, dmSize);

            // Save all of the new values out to the registry
            // Resolution color bits and frequency
            //
            // We always have to set DM_POSITION when calling the API.
            // In order to remove a device from the desktop, what actually needs
            // to be done is provide an empty rectangle.
            pdevmode->dmFields |= DM_POSITION;

            if (!_fCurAttached)
            {
                pdevmode->dmPelsWidth = 0;
                pdevmode->dmPelsHeight = 0;
            }
            else
            {
                pdevmode->dmPosition.x = _ptCurPos.x;
                pdevmode->dmPosition.y = _ptCurPos.y;
            }

            TraceMsg(TF_GENERAL, "SaveSettings:: Display: %s", _pDisplayDevice->DeviceName);

#ifdef DEBUG
            _Dump_CDevmode(pdevmode);
#endif

            // These calls have NORESET flag set so that it only goes to
            // change the registry settings, it does not refresh the display

            // If EnumDisplaySettings was called with EDS_RAWMODE, we need CDS_RAWMODE below.
            // Otherwise, it's harmless.
            iResult = ChangeDisplaySettingsEx(_pDisplayDevice->DeviceName,
                                              pdevmode,
                                              NULL,
                                              CDS_RAWMODE | dwSet | ( _fPrimary ? CDS_SET_PRIMARY : 0),
                                              NULL);

            if (iResult < 0)
            {
                TraceMsg(TF_DISPLAYSETTINGS, "**** SaveSettings:: ChangeDisplaySettingsEx not successful on %s", _pDisplayDevice->DeviceName);
            }

            LocalFree(pdevmode);
        }
    }

    return iResult;
}


void ConvertStrToToken(LPTSTR pszString, DWORD cchSize)
{
    while (pszString[0])
    {
        if (TEXT('\\') == pszString[0])
        {
            pszString[0] = TEXT(':');
        }

        pszString++;
    }
}


HRESULT CDisplaySettings::_GetRegKey(LPDEVMODE pDevmode, int * pnIndex, LPTSTR pszRegKey, DWORD cchSize,
                                     LPTSTR pszRegValue, DWORD cchValueSize)
{
    HRESULT hr = E_FAIL;
    DISPLAY_DEVICE ddMonitor = {0};

    ddMonitor.cb = sizeof(ddMonitor);
    if (pDevmode && pDevmode->dmDeviceName && _pDisplayDevice &&
        EnumDisplayDevices(_pDisplayDevice->DeviceName, *pnIndex, &ddMonitor, 0))
    {
        TCHAR szMonitor[MAX_PATH];
        TCHAR szVideoAdapter[MAX_PATH];

        StringCchCopy(szMonitor, ARRAYSIZE(szMonitor), ddMonitor.DeviceID);
        StringCchCopy(szVideoAdapter, ARRAYSIZE(szVideoAdapter), _pDisplayDevice->DeviceID);
        ConvertStrToToken(szMonitor, ARRAYSIZE(szMonitor));
        ConvertStrToToken(szVideoAdapter, ARRAYSIZE(szVideoAdapter));

        StringCchPrintf(pszRegKey, cchSize, TEXT("%s\\%s\\%s,%d\\%dx%d x %dHz"), SZ_CP_SETTINGS_VIDEO, 
                szVideoAdapter, szMonitor, *pnIndex, pDevmode->dmPelsWidth, pDevmode->dmPelsHeight, 
                pDevmode->dmDisplayFrequency);

        StringCchPrintf(pszRegValue, cchValueSize, TEXT("%d bpp"), pDevmode->dmBitsPerPel);
        hr = S_OK;
    }

    return hr;
}


BOOL CDisplaySettings::ConfirmChangeSettings()
{
    // Succeeded, so, reset the original settings
    _ptOrgPos      = _ptCurPos;
    _pOrgDevmode   = _pCurDevmode;
    _fOrgAttached  = _fCurAttached;

    // Now write the results to the registry so we know this is safe and can use it later.
    TCHAR szRegKey[2*MAX_PATH];
    TCHAR szRegValue[20];
    int nIndex = 0;

    while (SUCCEEDED(_GetRegKey(_pCurDevmode, &nIndex, szRegKey, ARRAYSIZE(szRegKey), szRegValue, ARRAYSIZE(szRegValue))))
    {
        HKEY hKey;

        if (SUCCEEDED(HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegKey, 0, NULL,
            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL)))
        {
            RegCloseKey(hKey);
        }
        HrRegSetDWORD(HKEY_LOCAL_MACHINE, szRegKey, szRegValue, 1);
        nIndex++;
    }

    return TRUE;
}


BOOL CDisplaySettings::IsKnownSafe(void)
{
    TCHAR szRegKey[2*MAX_PATH];
    TCHAR szRegValue[20];
    BOOL fIsSafe = FALSE;
    int nIndex = 0;

    while (SUCCEEDED(_GetRegKey(_pCurDevmode, &nIndex, szRegKey, ARRAYSIZE(szRegKey), szRegValue, ARRAYSIZE(szRegValue))))
    {
        fIsSafe = HrRegGetDWORD(HKEY_LOCAL_MACHINE, szRegKey, szRegValue, 0);
        if (!fIsSafe)
        {
            break;
        }

        nIndex++;
    }

    // TODO: In Longhorn, just return TRUE as long as we were able to prune the list.  If we could prune the list,
    // then the driver dudes were able to get PnP IDs from the video cards (adapters) and monitors, so the list of
    // supported modes should be accurate.  If not, the drivers guys (ErickS) will fix.  -BryanSt
    return fIsSafe;
}


int CDisplaySettings::RestoreSettings()
{
    //
    // Test failed, so restore the old settings, only restore the color and resolution
    // information, and do restore the monitor position and its attached status
    // Although this function is currently only called when restoring resolution
    // the user could have changed position, then resolution and then clicked 'Apply,'
    // in which case we want to revert position as well.
    //

    int iResult = DISP_CHANGE_SUCCESSFUL;
    PDEVMODE pdevmode;

    //
    // If this display was originally turned off, don't bother
    //

    if ((_pOrgDevmode != NULL) &&
        ((_pOrgDevmode != _pCurDevmode) || (_ptOrgPos.x != _ptCurPos.x) || (_ptOrgPos.y != _ptCurPos.y) ))
    {
        iResult = DISP_CHANGE_NOTUPDATED;
        
        // Make a copy of the original devmode
        ULONG dmSize = _pOrgDevmode->dmSize + _pOrgDevmode->dmDriverExtra;
        pdevmode  = (LPDEVMODE) LocalAlloc(LPTR, dmSize);

        if (pdevmode)
        {
            CopyMemory(pdevmode, _pOrgDevmode, dmSize);

            pdevmode->dmFields |= DM_POSITION;
            pdevmode->dmPosition.x = _ptOrgPos.x;
            pdevmode->dmPosition.y = _ptOrgPos.y;
    
            if (!_fOrgAttached)
            {
                pdevmode->dmPelsWidth = 0;
                pdevmode->dmPelsHeight = 0;
            }
    
            TraceMsg(TF_GENERAL, "RestoreSettings:: Display: %s", _pDisplayDevice->DeviceName);

#ifdef DEBUG
            _Dump_CDevmode(pdevmode);
#endif

            // If EnumDisplaySettings was called with EDS_RAWMODE, we need CDS_RAWMODE below.
            // Otherwise, it's harmless.
            iResult = ChangeDisplaySettingsEx(_pDisplayDevice->DeviceName,
                                              pdevmode,
                                              NULL,
                                              CDS_RAWMODE | CDS_UPDATEREGISTRY | CDS_NORESET | ( _fPrimary ? CDS_SET_PRIMARY : 0),
                                              NULL);
            if (iResult  < 0 )
            {
                TraceMsg(TF_DISPLAYSETTINGS, "**** RestoreSettings:: ChangeDisplaySettingsEx not successful on %s", _pDisplayDevice->DeviceName);
                ASSERT(FALSE);
                LocalFree(pdevmode);
                return iResult;
            }
            else
            {
                // Succeeded, so, reset the original settings
                _ptCurPos      = _ptOrgPos;
                _pCurDevmode   = _pOrgDevmode;
                _fCurAttached  = _fOrgAttached;
                
                if(_bCanBePruned && !_bIsPruningReadOnly && _bIsPruningOn && _IsCurDevmodeRaw())
                    SetPruningMode(FALSE);
            }

            LocalFree(pdevmode);
        }
    }

    return iResult;
}

    


BOOL CDisplaySettings::_IsModeVisible(int i)
{
    return _IsModeVisible(this, i);
}


BOOL CDisplaySettings::_IsModeVisible(CDisplaySettings* pSettings, int i)
{
    ASSERT(pSettings);

    if (!pSettings->_apdm)
    {
        return FALSE;
    }

    // (the mode is valid) AND
    // ((pruning mode is off) OR (mode is not raw))
    return ((!((pSettings->_apdm + i)->dwFlags & MODE_INVALID)) &&
            ((!pSettings->_bIsPruningOn) || 
             (!((pSettings->_apdm + i)->dwFlags & MODE_RAW))
            )
           );
}


BOOL CDisplaySettings::_IsModePreferred(int i)
{
    LPDEVMODE pDevMode = ((PMODEARRAY)(_apdm + i))->lpdm;

    if (_pCurDevmode == pDevMode)
        return TRUE;

    BOOL bLandscape = (pDevMode->dmPelsWidth >= pDevMode->dmPelsHeight);

    TraceMsg(TF_DUMP_CSETTINGS, "_IsModePreferred: %d x %d - landscape mode: %d", 
             pDevMode->dmPelsWidth, pDevMode->dmPelsHeight, bLandscape);

    // (the mode is valid) AND
    // ((pruning mode is off) OR (mode is not raw))
    return (pDevMode->dmBitsPerPel >= 15 &&
            ((bLandscape && pDevMode->dmPelsWidth >= 800 && pDevMode->dmPelsHeight >= 600) || 
             (!bLandscape && pDevMode->dmPelsWidth >= 600 && pDevMode->dmPelsHeight >= 800)));
}


BOOL CDisplaySettings::_MarkMode(LPDEVMODE lpdm)
{
    LPDEVMODE pdm;
    ULONG i;
    BOOL bMark = FALSE;

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        if (!((_apdm + i)->dwFlags & MODE_INVALID))
        {
            pdm = (_apdm + i)->lpdm;

            if (
                ((lpdm->dmFields & DM_BITSPERPEL) &&
                 (pdm->dmBitsPerPel == lpdm->dmBitsPerPel))

                &&

                ((lpdm->dmFields & DM_PELSWIDTH) &&
                 (pdm->dmPelsWidth == lpdm->dmPelsWidth))

                &&

                ((lpdm->dmFields & DM_PELSHEIGHT) &&
                 (pdm->dmPelsHeight == lpdm->dmPelsHeight))

                &&

                ((lpdm->dmFields & DM_DISPLAYFREQUENCY) &&
                 (pdm->dmDisplayFrequency == lpdm->dmDisplayFrequency))
               )
            {
               (_apdm + i)->dwFlags &= ~MODE_RAW;
               bMark = TRUE;
            }
        }
    }

    return bMark;
}


BOOL CDisplaySettings::_IsCurDevmodeRaw()
{
    LPDEVMODE pdm;
    ULONG i;
    BOOL bCurrentAndPruned = FALSE;

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        if (!((_apdm + i)->dwFlags & MODE_INVALID) &&
            ((_apdm + i)->dwFlags & MODE_RAW))
        {
            pdm = (_apdm + i)->lpdm;

            if (
                ((_pCurDevmode->dmFields & DM_BITSPERPEL) &&
                 (pdm->dmBitsPerPel == _pCurDevmode->dmBitsPerPel))

                &&

                ((_pCurDevmode->dmFields & DM_PELSWIDTH) &&
                 (pdm->dmPelsWidth == _pCurDevmode->dmPelsWidth))

                &&

                ((_pCurDevmode->dmFields & DM_PELSHEIGHT) &&
                 (pdm->dmPelsHeight == _pCurDevmode->dmPelsHeight))

                &&

                ((_pCurDevmode->dmFields & DM_DISPLAYFREQUENCY) &&
                 (pdm->dmDisplayFrequency == _pCurDevmode->dmDisplayFrequency))
               )
            {
                bCurrentAndPruned = TRUE;
                break;
            }
        }
    }

    return bCurrentAndPruned;     
}

DISPLAY_DEVICE dd;

HRESULT CDisplaySettings::SetMonitor(DWORD dwMonitor)
{
    ZeroMemory(&dd, sizeof(dd));
    dd.cb = sizeof(DISPLAY_DEVICE);

    DWORD dwMon = 0;
    for (DWORD dwCount = 0; EnumDisplayDevices(NULL, dwCount, &dd, 0); dwCount++)
    {
        if (!(dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER))
        {
            if (dwMon == dwMonitor)
            {
                InitSettings(&dd);
                _fPrimary = (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE);
                return S_OK;
            }
            dwMon++;
        }
    }

    return E_INVALIDARG;
}

HRESULT CDisplaySettings::GetModeCount(DWORD* pdwCount, BOOL fOnlyPreferredModes)
{
    DWORD cCount = 0;

    for (DWORD i = 0; _apdm && (i < _cpdm); i++)
    {
        // Don't show invalid modes or raw modes if pruning is on;

        if(!_IsModeVisible(i))
        {
            continue;
        }

        if(fOnlyPreferredModes && (!_IsModePreferred(i)))
        {
            continue;
        }

        cCount++;
    }

    *pdwCount = cCount;

    return S_OK;
}

HRESULT CDisplaySettings::GetMode(DWORD dwMode, BOOL fOnlyPreferredModes, DWORD* pdwWidth, DWORD* pdwHeight, DWORD* pdwColor)
{
    DWORD cCount = 0;

    for (DWORD i = 0; _apdm && (i < _cpdm); i++)
    {
        // Don't show invalid modes or raw modes if pruning is on;

        if(!_IsModeVisible(i))
        {
            continue;
        }

        if(fOnlyPreferredModes && (!_IsModePreferred(i)))
        {
            continue;
        }

        if (cCount == dwMode)
        {
            LPDEVMODE lpdm = (_apdm + i)->lpdm;
            *pdwWidth = lpdm->dmPelsWidth;
            *pdwHeight = lpdm->dmPelsHeight;
            *pdwColor = lpdm->dmBitsPerPel;

            return S_OK;
        }

        cCount++;
    }

    return E_INVALIDARG;
}

DEVMODE dm;

HRESULT CDisplaySettings::SetSelectedMode(HWND hwnd, DWORD dwWidth, DWORD dwHeight, DWORD dwColor, BOOL* pfApplied, DWORD dwFlags)
{
    dm.dmBitsPerPel = dwColor;
    dm.dmPelsWidth = dwWidth;
    dm.dmPelsHeight = dwHeight;
    dm.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
    
    *pfApplied = FALSE;
    
    POINT res = {dwWidth, dwHeight};
    PLONGLONG freq = NULL;
    int cFreq = GetFrequencyList(dwColor, &res, &freq);
    if (cFreq)
    {
        dm.dmFields |= DM_DISPLAYFREQUENCY;
        // Default to lowest frequency
        dm.dmDisplayFrequency = (DWORD)freq[0];

        // Try to find a good frequency
        for (int i = cFreq - 1; i >= 0; i--)
        {
            if ((freq[i] >= 60) && (freq[i] <= 72))
            {
                dm.dmDisplayFrequency = (DWORD)freq[i];
            }
        }
    }
    LocalFree(freq);

    ULONG dmSize = _pCurDevmode->dmSize + _pCurDevmode->dmDriverExtra;
    PDEVMODE pOldDevMode = (LPDEVMODE) LocalAlloc(LPTR, dmSize);

    if (pOldDevMode)
    {
        CopyMemory(pOldDevMode, _pCurDevmode, dmSize);

        if (_ExactMatch(&dm, FALSE))
        {
            // Verify that the mode actually works
            if (SaveSettings(CDS_TEST) == DISP_CHANGE_SUCCESSFUL)
            {
                // Update the registry to specify the new display settings
                if (SaveSettings(CDS_UPDATEREGISTRY | CDS_NORESET) == DISP_CHANGE_SUCCESSFUL)
                {
                    // Refresh the display info from the registry, if you update directly ChangeDisplaySettings will do weird things in the fringe cases
                    if (ChangeDisplaySettings(NULL, CDS_RAWMODE) == DISP_CHANGE_SUCCESSFUL)
                    {
                        if (IsKnownSafe())
                        {
                            // No need to warn, this is known to be a good value.
                            *pfApplied = TRUE;
                        }
                        else
                        {
                            INT_PTR iRet = DialogBoxParam(HINST_THISDLL,
                                          MAKEINTRESOURCE((dwFlags & DS_BACKUPDISPLAYCPL) ? DLG_KEEPNEW2 : DLG_KEEPNEW3),
                                          hwnd,
                                          KeepNewDlgProc,
                                          (dwFlags & DS_BACKUPDISPLAYCPL) ? 15 : 30);
    
                            if ((IDYES == iRet) || (IDOK == iRet))
                            {
                                *pfApplied = TRUE;
                            }
                            else
                            {
                                if (_ExactMatch(pOldDevMode, FALSE))
                                {
                                    SaveSettings(CDS_UPDATEREGISTRY | CDS_NORESET);
                                    ChangeDisplaySettings(NULL, CDS_RAWMODE);
                                }
        
                                if (dwFlags & DS_BACKUPDISPLAYCPL)
                                {
                                    TCHAR szDeskCPL[MAX_PATH];
                                    SystemPathAppend(szDeskCPL, TEXT("desk.cpl"));
                                    
                                    // Use shellexecuteex to run the display CPL
                                    SHELLEXECUTEINFO shexinfo = {0};
                                    shexinfo.cbSize = sizeof (shexinfo);
                                    shexinfo.fMask = SEE_MASK_FLAG_NO_UI;
                                    shexinfo.nShow = SW_SHOWNORMAL;
                                    shexinfo.lpFile = szDeskCPL;
    
                                    ShellExecuteEx(&shexinfo);
                                }
                            }
                        }
                    }
                }
            }
        }

        LocalFree(pOldDevMode);
    }

    return S_OK;
}

HRESULT CDisplaySettings::GetSelectedMode(DWORD* pdwWidth, DWORD* pdwHeight, DWORD* pdwColor)
{
    if (pdwWidth && pdwHeight && pdwColor)
    {
        if (_pCurDevmode)
        {
            *pdwWidth = _pCurDevmode->dmPelsWidth;
            *pdwHeight = _pCurDevmode->dmPelsHeight;
            *pdwColor = _pCurDevmode->dmBitsPerPel;
            return S_OK;
        }
        else
        {
            return E_FAIL;
        }
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CDisplaySettings::GetAttached(BOOL* pfAttached)
{
    if (pfAttached)
    {
        *pfAttached = _fCurAttached;
        return S_OK;
    }
    else
        return E_INVALIDARG;
}

HRESULT CDisplaySettings::SetPruningMode(BOOL fIsPruningOn)
{
    ASSERT (_bCanBePruned && !_bIsPruningReadOnly);
    
    if (_bCanBePruned && 
        !_bIsPruningReadOnly &&
        ((fIsPruningOn != 0) != _bIsPruningOn))
    {
        _bIsPruningOn = (fIsPruningOn != 0);

        DWORD dwIsPruningOn = (DWORD)_bIsPruningOn;
        RegSetValueEx(_hPruningRegKey, 
                      SZ_PRUNNING_MODE,
                      NULL, 
                      REG_DWORD, 
                      (LPBYTE) &dwIsPruningOn, 
                      sizeof(dwIsPruningOn));

        //
        // handle the special case when we pruned out the current mode
        //
        if(_bIsPruningOn && _IsCurDevmodeRaw())
        {
            //
            // switch to the closest mode
            //
            _BestMatch(NULL, -1, TRUE);
        }
        
    }

    return S_OK;
}

HRESULT CDisplaySettings::GetPruningMode(BOOL* pfCanBePruned, BOOL* pfIsPruningReadOnly, BOOL* pfIsPruningOn)
{
    if (pfCanBePruned && pfIsPruningReadOnly && pfIsPruningOn)
    {
        *pfCanBePruned = _bCanBePruned;
        *pfIsPruningReadOnly = _bIsPruningReadOnly;
        *pfIsPruningOn = _bIsPruningOn;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CDisplaySettings_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (!punkOuter && ppvObj)
    {
        CDisplaySettings * pThis = new CDisplaySettings();

        *ppvObj = NULL;
        if (pThis)
        {
            hr = pThis->QueryInterface(riid, ppvObj);
            pThis->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\dllreg.cpp ===
/*****************************************************************************\
    FILE: dllreg.cpp

    DESCRIPTION:
        Register selfreg.inf, which exists in our resource.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"

#include <advpub.h>
#include <comcat.h>
#include <theme.h>       // For LIBID_Theme
#include <userenv.h>     // PT_ROAMING from userenv.dll

extern CComModule _Module;

BOOL g_fInSetup = FALSE;
BOOL g_fDoNotInstallThemeWallpaper = FALSE;     // This is used to not install wallpaper.

HRESULT InstallVS(LPCWSTR pszCmdLine);

// helper macros

// ADVPACK will return E_UNEXPECTED if you try to uninstall (which does a registry restore)
// on an INF section that was never installed.  We uninstall sections that may never have
// been installed, so this MACRO will quiet these errors.
#define QuietInstallNoOp(hr)   ((E_UNEXPECTED == hr) ? S_OK : hr)


BOOL UnregisterTypeLibrary(const CLSID* piidLibrary)
{
    TCHAR szScratch[GUIDSTR_MAX];
    HKEY hk;
    BOOL fResult = FALSE;

    // convert the libid into a string.
    SHStringFromGUID(*piidLibrary, szScratch, ARRAYSIZE(szScratch));

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("TypeLib"), 0, KEY_WRITE, &hk) == ERROR_SUCCESS)
    {
        fResult = RegDeleteKey(hk, szScratch);
        RegCloseKey(hk);
    }

    return fResult;
}



HRESULT MyRegTypeLib(void)
{
    ITypeLib * pTypeLib;
    WCHAR szTmp[MAX_PATH];

    GetModuleFileName(HINST_THISDLL, szTmp, ARRAYSIZE(szTmp));

    // Load and register our type library.
    HRESULT hr = LoadTypeLib(szTmp, &pTypeLib);
    if (SUCCEEDED(hr))
    {
        // call the unregister type library as we had some old junk that
        // was registered by a previous version of OleAut32, which is now causing
        // the current version to not work on NT...
        UnregisterTypeLibrary(&LIBID_Theme);
        hr = RegisterTypeLib(pTypeLib, szTmp, NULL);
        if (FAILED(hr))
        {
            TraceMsg(TF_WARNING, "RegisterTypeLib failed (%x)", hr);
        }

        pTypeLib->Release();
    }
    else
    {
        TraceMsg(TF_WARNING, "LoadTypeLib failed (%x)", hr);
    }

    return hr;
}



/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

Returns: 
Cond:    --
*/
HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;    
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szIEPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "NO_LONGER_USED", szIEPath },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            szIEPath[0] = 0;
            hr = pfnri(HINST_THISDLL, szSection, &stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


enum eThemeToSetup
{
    eThemeNoChange = 0,
    eThemeWindowsClassic,
    eThemeProfessional
};


eThemeToSetup GetVisualStyleToSetup(BOOL fPerUser)
{
    eThemeToSetup eVisualStyle = eThemeNoChange;

#ifndef _WIN64
    if (IsOS(OS_PERSONAL))
    {
        eVisualStyle = eThemeProfessional;        // We don't support Consumer yet.
    }
    else if (IsOS(OS_PROFESSIONAL))
    {

        eVisualStyle = eThemeProfessional;
    }
#endif

    return eVisualStyle;
}


eThemeToSetup GetThemeToSetup(BOOL fPerUser)
{
    eThemeToSetup eTheme = eThemeNoChange;

    // We want Pro, if:
    // 1. Not IA64
    // 2. Not Server or Personal
    // 3. Not Roaming
#ifndef _WIN64
    if (IsOS(OS_PERSONAL))
    {
        eTheme = eThemeProfessional;        // We don't support Consumer yet.
    }
    else if (IsOS(OS_PROFESSIONAL))
    {
        eTheme = eThemeProfessional;
    }
#endif

    return eTheme;
}


BOOL IsUserRoaming(void)
{
    BOOL fRoaming = FALSE;
    DWORD dwProfile;

    if (GetProfileType(&dwProfile))
    {
        fRoaming = ((dwProfile & (PT_ROAMING | PT_MANDATORY)) ? TRUE : FALSE);
    }

    return fRoaming;
}


BOOL IsUserHighContrastUser(void)
{
    BOOL fHighContrast = FALSE;
    HIGHCONTRAST hc;

    hc.cbSize = sizeof(hc);
    if (ClassicSystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0) &&
        (hc.dwFlags & HCF_HIGHCONTRASTON))
    {
        fHighContrast = TRUE;
    }

    return fHighContrast;
}


SIZE_T GetMachinePhysicalRAMSize(void)
{
    MEMORYSTATUS ms = {0};

    GlobalMemoryStatus(&ms);
    SIZE_T nMegabytes = (ms.dwTotalPhys / (1024 * 1024));

    return nMegabytes;
}


HRESULT InstallTheme(IThemeManager * pThemeManager, LPCTSTR pszThemePath)
{
    HRESULT hr = E_OUTOFMEMORY;
    CComVariant varTheme(pszThemePath);

    if (varTheme.bstrVal)
    {
        ITheme * pTheme;

        hr = pThemeManager->get_item(varTheme, &pTheme);
        if (SUCCEEDED(hr))
        {
            hr = pThemeManager->put_SelectedTheme(pTheme);
            pTheme->Release();
        }
    }

    return hr;
}


HRESULT InstallThemeAndDoNotStompBackground(int nLastVersion, LPCTSTR pszThemePath, LPCTSTR pszVisualStylePath, LPCTSTR pszVisualStyleColor, LPCTSTR pszVisualStyleSize)
{
    TCHAR szPath[MAX_PATH];
    WALLPAPEROPT wpo = {0};
    HRESULT hr = S_OK;

    wpo.dwSize = sizeof(wpo);
    wpo.dwStyle = WPSTYLE_STRETCH;      // We use stretch in case it fails.
    szPath[0] = 0;

    // This implements Whistler #185935.  We want to set the wallpaper to
    // "%windir%\web\wallpaper\Professional.bmp" if it's a clean install,
    // the wallpaper is blank, or it's set to something we don't like.
    {
        IActiveDesktop * pActiveDesktop = NULL;

        hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktop, &pActiveDesktop));
        if (SUCCEEDED(hr))
        {
            // Let's see if this is an upgrade case and they already specified wallpaper.
            hr = pActiveDesktop->GetWallpaper(szPath, ARRAYSIZE(szPath), 0);
            if (SUCCEEDED(hr) && szPath[0])
            {
                TCHAR szNone[MAX_PATH];

                LogStatus("InstallThemeAndDoNotStompBackground() Existing Background=%ls\r\n", szPath);
                if (LoadString(HINST_THISDLL, IDS_NONE, szNone, ARRAYSIZE(szNone)) &&
                    !StrCmpI(szNone, szPath))    // Make sure the wallpaper isn't "(None)".
                {
                    szPath[0] = 0;
                }
                else
                {
                    LPTSTR pszFilename = PathFindFileName(szPath);

                    if (LoadString(HINST_THISDLL, IDS_SETUP_BETA2_UPGRADEWALLPAPER, szNone, ARRAYSIZE(szNone)) &&
                        (3 == nLastVersion) &&
                        !StrCmpI(szNone, pszFilename))
                    {
                        // This is a "Beta2"->RTM upgrade.  We need to move from "Red Moon Desert.bmp" to "Bliss.bmp".
                        szPath[0] = 0;
                    }
                    else
                    {
                        if ((14 == lstrlen(pszFilename)) &&
                            !StrCmpNI(pszFilename, TEXT("Wallpaper"), 9))
                        {
                            // This is the "WallpaperX.bmp" template wallpaper we use.  So find the original.
                            TCHAR szOriginal[MAX_PATH];

                            if (SUCCEEDED(HrRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_CPDESKTOP, SZ_REGVALUE_CONVERTED_WALLPAPER, szOriginal, ARRAYSIZE(szOriginal))))
                            {
                                StringCchCopy(szPath, ARRAYSIZE(szPath), szOriginal);
                            }
                        }

                        hr = pActiveDesktop->GetWallpaperOptions(&wpo, 0);
                    }
                }

                WCHAR szTemp[MAX_PATH];

                // The string may come back with environment variables.
                if (0 == SHExpandEnvironmentStrings(szPath, szTemp, ARRAYSIZE(szTemp)))
                {
                    StringCchCopy(szTemp, ARRAYSIZE(szTemp), szPath);  // We failed so use the original.
                }

                StringCchCopy(szPath, ARRAYSIZE(szPath), szTemp);  // We failed so use the original.
                LogStatus("InstallThemeAndDoNotStompBackground() Background=%ls\r\n", szPath);

                if (szPath[0])
                {
                    g_fDoNotInstallThemeWallpaper = TRUE;
                }
            }

            ATOMICRELEASE(pActiveDesktop);
        }

        // If the machine has 64MB or less, don't have setup add a wallpaper.  Wallpapers
        // use about 1.5MB of working set and cause super physical memory contention.
        if (!g_fDoNotInstallThemeWallpaper && (70 >= GetMachinePhysicalRAMSize()))
        {
            g_fDoNotInstallThemeWallpaper = TRUE;
        }
    }

    IThemeManager * pThemeManager;

    hr = CThemeManager_CreateInstance(NULL, IID_PPV_ARG(IThemeManager, &pThemeManager));
    if (SUCCEEDED(hr))
    {
        if (pszThemePath && pszThemePath[0])
        {
            LogStatus("InstallThemeAndDoNotStompBackground() Installing Theme=%ls\r\n", pszThemePath);
            hr = InstallTheme(pThemeManager, pszThemePath);
        }

        if (pszVisualStylePath && pszVisualStylePath[0])
        {
            // Otherwise, we install the visual style.
            LogStatus("InstallThemeAndDoNotStompBackground() VS=%ls, Color=%ls, Size=%ls.\r\n", pszVisualStylePath, pszVisualStyleColor, pszVisualStyleSize);
            hr = InstallVisualStyle(pThemeManager, pszVisualStylePath, pszVisualStyleColor, pszVisualStyleSize);
        }

        // This ApplyNow() call will take a little while in normal situation (~10-20 seconds) in order
        // to broadcast the message to all open apps.  If a top level window is hung, it may take the
        // full 30 seconds to timeout.
        hr = pThemeManager->ApplyNow();

        IUnknown_SetSite(pThemeManager, NULL); // Tell him to break the ref-count cycle with his children.
        ATOMICRELEASE(pThemeManager);

        // Now we put the wallpaper back
        if (szPath[0])
        {
            IActiveDesktop * pActiveDesktop2 = NULL;

            // I purposely do not use the same IActiveDesktop object as above.  I do not want them to think
            // this is a no-op because they have stale info.
            hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktop, &pActiveDesktop2));
            if (SUCCEEDED(hr))
            {
                // Oh no, we replaced their wallpaper.  Let's set it back to what they like.
                hr = pActiveDesktop2->SetWallpaper(szPath, 0);
                if (SUCCEEDED(hr))
                {
                    LogStatus("InstallThemeAndDoNotStompBackground() Reapplying Wallpaper=%ls.\r\n", szPath);
                    hr = pActiveDesktop2->SetWallpaperOptions(&wpo, 0);
                }

                pActiveDesktop2->ApplyChanges(AD_APPLY_ALL);
                pActiveDesktop2->Release();
            }
        }
    }

    LogStatus("InstallThemeAndDoNotStompBackground() returned hr=%#08lx.\r\n", hr);
    return hr;
}



/*****************************************************************************\
    DESCRIPTION:
        This function will put the defaults for "Visual Styles Off" and "Visual
    Styles on" so the Perf CPL can toggle back and forth.
\*****************************************************************************/
HRESULT SetupPerfDefaultsForUser(void)
{
    HRESULT hr = S_OK;
    HKEY hKey;
    TCHAR szThemePath[MAX_PATH];
    TCHAR szVisualStylePath[MAX_PATH];
    TCHAR szVisualStyleColor[MAX_PATH];
    TCHAR szVisualStyleSize[MAX_PATH];

    hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_THEMES, SZ_REGVALUE_INSTALLCUSTOM_THEME, szThemePath, ARRAYSIZE(szThemePath));
    if (FAILED(hr))
    {
        hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, szThemePath, ARRAYSIZE(szThemePath));
    }
    if (FAILED(hr) || !szThemePath[0])
    {
        StringCchCopy(szThemePath, ARRAYSIZE(szThemePath), L"%ResourceDir%\\themes\\Windows Classic.theme");
    }

    // Make sure that MenuHilight and MenuBar are in the registry
    // (The NTUSER default values are wrong - hardcoded in ntuser\kernel\global.c, so default to legacy menu values)
    if (SUCCEEDED(HrRegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_COLORS, 0, KEY_READ, &hKey)))
    {
        TCHAR szColor[15];
        DWORD cbSize = sizeof(szColor);

        if (FAILED(HrRegQueryValueEx(hKey, s_pszColorNames[COLOR_MENUHILIGHT], NULL, NULL, (LPBYTE) szColor, &cbSize)))
        {
            // Copy MenuText to MenuHilight
            cbSize = sizeof(szColor);
            if (SUCCEEDED(HrRegQueryValueEx(hKey, s_pszColorNames[COLOR_HIGHLIGHT], NULL, NULL, (LPBYTE) szColor, &cbSize)))
            {
                HrRegSetValueString(HKEY_CURRENT_USER, REGSTR_PATH_COLORS, s_pszColorNames[COLOR_MENUHILIGHT], szColor);
            }
        }

        cbSize = sizeof(szColor);
        if (FAILED(HrRegQueryValueEx(hKey, s_pszColorNames[COLOR_MENUBAR], NULL, NULL, (LPBYTE) szColor, &cbSize)))
        {
            // Copy Menu to MenuBar
            cbSize = sizeof(szColor);
            if (SUCCEEDED(HrRegQueryValueEx(hKey, s_pszColorNames[COLOR_MENU], NULL, NULL, (LPBYTE) szColor, &cbSize)))
            {
                HrRegSetValueString(HKEY_CURRENT_USER, REGSTR_PATH_COLORS, s_pszColorNames[COLOR_MENUBAR], szColor);
            }
        }
        RegCloseKey(hKey);
    }

    eThemeToSetup eTheme = GetVisualStyleToSetup(FALSE);

    if (eTheme == eThemeNoChange) // Upgrade from Win2K server, or new user
    {
        TCHAR szDefaultScheme[MAX_PATH];
        TCHAR szScheme[MAX_PATH];
        bool bApplyStandard = false;    // If we fail to read Current from the registry, this is a Win2K upgrade with 
                                        // custom settings, so keep them. If this is a new user on XP/.NET, Current 
                                        // will contain the default, so apply Standard.

        // Setup create this key and userinit populates it.
        // "Control Panel\Appearance"
        hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_APPEARANCE, 0, KEY_READ, &hKey);
        if (SUCCEEDED(hr))
        {
            DWORD cbSize = sizeof(szScheme);

            // "Current"
            hr = HrRegQueryValueEx(hKey, SZ_REGVALUE_CURRENT, NULL, NULL, (LPBYTE) szScheme, &cbSize);
            RegCloseKey(hKey);
        }

        // First test is brand new user case: the Current key is the same as .Default
        if (SUCCEEDED(hr))
        {
            hr = HrRegOpenKeyEx(HKEY_USERS, L".Default\\" SZ_REGKEY_APPEARANCE, 0, KEY_READ, &hKey);
            if (SUCCEEDED(hr))
            {
                DWORD cbSize = sizeof(szDefaultScheme);

                hr = HrRegQueryValueEx(hKey, SZ_REGVALUE_CURRENT, NULL, NULL, (LPBYTE) szDefaultScheme, &cbSize);
                RegCloseKey(hKey);
            }
        }

        if (SUCCEEDED(hr))
        {
            // Note that "Windows Standard (Large)" will be treated like a new scheme compared to "Windows Standard"
            if (!StrCmpIW(szScheme, szDefaultScheme))
            {
                bApplyStandard = true;
            }
            // "Windows Standard"
            else if (0 != LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szDefaultScheme, ARRAYSIZE(szDefaultScheme))
                && !StrCmpIW(szScheme, szDefaultScheme))
            {
                // Didn't work, try another one.
                // Look for Windows Standard and Windows Classic. Windows Standard is the default
                // except for some East-Asian SKUs, where it is Windows Classic.
                // If it is one of those, we're allowed to "refresh" the settings.
                bApplyStandard = true;
            // "Windows Classic"
            } else if (0 != LoadString(HINST_THISDLL, IDS_APPEARANCE_THEME_NAME, szDefaultScheme, ARRAYSIZE(szDefaultScheme))
                && !StrCmpIW(szScheme, szDefaultScheme))
            {
                bApplyStandard = true;
            }
        } 

        if (bApplyStandard)
        {
            eTheme = eThemeWindowsClassic; // Re-install Windows Standard
        }
        else
        {
            // The user has a custom setting, write a special value which will cause InstallThemeAndDoNotStompBackground 
            // to be called but without changing settings
            hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, L"Default");
        }
    }

    if (eTheme != eThemeNoChange)
    {
        switch (eTheme)
        {
        case eThemeWindowsClassic:
            szVisualStylePath[0] = L'\0';
            LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
            LoadString(HINST_THISDLL, IDS_SCHEME_SIZE_NORMAL_CANONICAL, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
            break;
        case eThemeProfessional:
            StringCchCopy(szVisualStylePath, ARRAYSIZE(szVisualStylePath), L"%ResourceDir%\\themes\\Luna\\Luna.msstyles");
            LoadString(HINST_THISDLL, IDS_PROMSTHEME_DEFAULTCOLOR, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
            LoadString(HINST_THISDLL, IDS_PROMSTHEME_DEFAULTSIZE, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
            break;
        }

        // Set the defaults
        hr = HrRegSetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, TRUE, szThemePath);
        hr = HrRegSetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_VISUALSTYLE, TRUE, szVisualStylePath);
        hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_VSCOLOR, szVisualStyleColor);
        hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_VSSIZE, szVisualStyleSize);
    }

    // Set the defaults for the perf CPL to use if forced to "Visual Styles On"
    StringCchCopy(szThemePath, ARRAYSIZE(szThemePath), L"%ResourceDir%\\themes\\Luna.theme");
    StringCchCopy(szVisualStylePath, ARRAYSIZE(szVisualStylePath), L"%ResourceDir%\\themes\\Luna\\Luna.msstyles");
    LoadString(HINST_THISDLL, IDS_PROMSTHEME_DEFAULTCOLOR, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
    LoadString(HINST_THISDLL, IDS_PROMSTHEME_DEFAULTSIZE, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));

    hr = HrRegSetPath(HKEY_CURRENT_USER, SZ_REGKEY_THEME_DEFVSON, SZ_REGVALUE_INSTALL_VISUALSTYLE, TRUE, szVisualStylePath);
    hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_THEME_DEFVSON, SZ_REGVALUE_INSTALL_VSCOLOR, szVisualStyleColor);
    hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_THEME_DEFVSON, SZ_REGVALUE_INSTALL_VSSIZE, szVisualStyleSize);

    // Set the defaults for the perf CPL to use if forced to "Visual Styles Off"
    szVisualStylePath[0] = L'\0';
    LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
    LoadString(HINST_THISDLL, IDS_SCHEME_SIZE_NORMAL_CANONICAL, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
    hr = HrRegSetPath(HKEY_CURRENT_USER, SZ_REGKEY_THEME_DEFVSOFF, SZ_REGVALUE_INSTALL_VISUALSTYLE, TRUE, szVisualStylePath);
    hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_THEME_DEFVSOFF, SZ_REGVALUE_INSTALL_VSCOLOR, szVisualStyleColor);
    hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_THEME_DEFVSOFF, SZ_REGVALUE_INSTALL_VSSIZE, szVisualStyleSize);

    LogStatus("SetupPerfDefaultsForUser() sets:\r\n   Theme=%ls,\r\n   VisualStyle=%ls,\r\n   Color=%ls,\r\n   Size=%ls. returned hr=%#08lx.\r\n", szThemePath, szVisualStylePath, szVisualStyleColor, szVisualStyleSize, hr);
    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        This function will be called for each user when "theme setup" has not
    yet run for that user.  The machine setup will determine it's prefered
    Theme and VisualStyle.  This code needs to take additional information about
    the user (Accessibilities on?, Policy on?, etc.) into account before finally
    installing the Theme and/or VisualStyle.
\*****************************************************************************/
HRESULT SetupThemeForUser(void)
{
    HRESULT hr = S_OK;
    TCHAR szVersion[MAX_PATH];
    int nVersion;
    int nCurrentVersion = 0;

    if (SUCCEEDED(HrRegGetValueString(HKEY_CURRENT_USER, SZ_THEMES, REGVALUE_THEMESSETUPVER, szVersion, ARRAYSIZE(szVersion))))
    {
        StrToIntEx(szVersion, STIF_DEFAULT, &nCurrentVersion);
    }

    // If we succeeded, mark the registry that we don't need the user setup again.
    if (SUCCEEDED(HrRegGetValueString(HKEY_LOCAL_MACHINE, SZ_THEMES, REGVALUE_THEMESSETUPVER, szVersion, ARRAYSIZE(szVersion))) &&
        StrToIntEx(szVersion, STIF_DEFAULT, &nVersion))
    {
        if (nVersion > nCurrentVersion)
        {
            // We will skip this setup step for Clean boot.  We will get called back during
            // the next logon to do the work then.
            if (!ClassicGetSystemMetrics(SM_CLEANBOOT))
            {
                TCHAR szThemePath[MAX_PATH];
                TCHAR szVisualStylePath[MAX_PATH];
                TCHAR szVisualStyleColor[MAX_PATH];
                TCHAR szVisualStyleSize[MAX_PATH];
                DWORD dwType;
                DWORD cbSize = sizeof(szThemePath);

                szVisualStylePath[0] = szVisualStyleColor[0] = szVisualStyleSize[0] = szThemePath[0] = 0;

                SetupPerfDefaultsForUser();
                SHRegGetUSValue(SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_POLICY_INSTALLTHEME, &dwType, (void *) szThemePath, &cbSize, FALSE, NULL, 0);

                // First check the policy that admins use to force users to always use a certain visual style.
                // Specifying an empty value will cause no visual style to be setup.
                cbSize = sizeof(szVisualStylePath);
                if (ERROR_SUCCESS != SHRegGetUSValue(SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_POLICY_SETVISUALSTYLE, &dwType, (void *) szVisualStylePath, &cbSize, FALSE, NULL, 0))
                {
                    cbSize = sizeof(szVisualStylePath);

                    // That was not set, so check for the policy admins want to set the visual style for the first time.
                    if ((ERROR_SUCCESS != SHRegGetUSValue(SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_POLICY_INSTALLVISUALSTYLE, &dwType, (void *) szVisualStylePath, &cbSize, FALSE, NULL, 0)))
                    {
                        if (!SHRegGetBoolUSValue(SZ_THEMES, SZ_REGVALUE_NO_THEMEINSTALL, FALSE, FALSE))
                        {
                            // If the user is Roaming, we don't setup themes or visual styles in order that their
                            // settings will successfully roam downlevel.
                            // We also do not modify user settings if their high contrast bit is set.  We do this so
                            // their system does not become unreadable.
                            if (!IsUserRoaming() && !IsUserHighContrastUser())
                            {
                                LogStatus("SetupThemeForUser() Not Roaming and Not HighContrast.\r\n");
                                hr = HrRegGetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, szThemePath, ARRAYSIZE(szThemePath));
                                if (FAILED(hr))
                                {
                                   // That was not set, so see what the OS wants as a default.
                                    hr = HrRegGetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_VISUALSTYLE, szVisualStylePath, ARRAYSIZE(szVisualStylePath));
                                    hr = HrRegGetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_VSCOLOR, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
                                    hr = HrRegGetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_VSSIZE, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
                                }
                            }
                            else
                            {
                                LogStatus("SetupThemeForUser() Roaming or HighContrast is on.\r\n");
                            }
                        }
                    }
                    else
                    {
                        // It's okay if these fail, we will use defaults
                        HrRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_INSTALL_VSCOLOR, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
                        HrRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_INSTALL_VSSIZE, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
                        LogStatus("SetupThemeForUser() SZ_REGVALUE_POLICY_INSTALLVISUALSTYLE policy set.\r\n");
                    }
                }
                else
                {
                    // Someone set the SetVisualStyle policy.  This means that we won't install anything.
                    szThemePath[0] = 0;
                    LogStatus("SetupThemeForUser() SZ_REGVALUE_POLICY_SETVISUALSTYLE policy set.\r\n");

                    if (szVisualStylePath[0] == L'\0') // If the policy is empty
                    {
                        // Install the default theme with no style
                        LogStatus("SetupThemeForUser() Installed Windows Standard as per the SETVISUALSTYLE policy.\r\n");

                        TCHAR szVisualStylePath[MAX_PATH];
                        TCHAR szVisualStyleColor[MAX_PATH];
                        TCHAR szVisualStyleSize[MAX_PATH];

                        szVisualStylePath[0] = L'\0';
                        LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
                        LoadString(HINST_THISDLL, IDS_SCHEME_SIZE_NORMAL_CANONICAL, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
                        WCHAR szCmdLine[MAX_PATH * 3];

                        StringCchPrintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("%s%s','%s','%s'"),
                                    SZ_INSTALL_VS,
                                    szVisualStylePath,
                                    szVisualStyleColor,
                                    szVisualStyleSize);
                        InstallVS(szCmdLine);
                    }
                }
                ExpandResourceDir(szThemePath, ARRAYSIZE(szThemePath));
                ExpandResourceDir(szVisualStylePath, ARRAYSIZE(szVisualStylePath));

                // Specifying a Theme is specified, we install that.  In that case, the visual style comes from there.
                if (szThemePath[0] || szVisualStylePath[0])
                {
                    if (!StrCmpIW(szThemePath, L"Default"))
                    {
                        // This is a Server upgrade, we don't overwrite settings but we still need to call InstallThemeAndDoNotStompBackground
                        // in order to call CThemeManager::ApplyNow, which will trigger the registry migration 
                        // (other components use the New Schemes key).

                        // Mark the registry as "", which means Windows Classic.
                        HrRegSetValueString(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, L"");
                        // Tell InstallThemeAndDoNotStompBackground not to apply a theme
                        szThemePath[0] = 0;
                    }
                    hr = InstallThemeAndDoNotStompBackground(nCurrentVersion, szThemePath, szVisualStylePath, szVisualStyleColor, szVisualStyleSize);
                }

                if (SUCCEEDED(hr))
                {
                    // If we succeeded, mark the registry that we don't need the user setup again.
                    hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_THEMES, REGVALUE_THEMESSETUPVER, szVersion);
                }
                LogStatus("SetupThemeForUser() sets:\r\n   Theme=%ls,\r\n   VisualStyle=%ls,\r\n   Color=%ls,\r\n   Size=%ls. returned hr=%#08lx.\r\n", szThemePath, szVisualStylePath, szVisualStyleColor, szVisualStyleSize, hr);
            }
        }
    }


    return hr;
}


HRESULT SetupThemeForMachine(void)
{
    HRESULT hr = S_OK;
    eThemeToSetup eTheme = GetThemeToSetup(FALSE);
    eThemeToSetup eVisualStyle = GetVisualStyleToSetup(FALSE);
    WCHAR szVisualStyleName[MAX_PATH];
    WCHAR szThemeName[MAX_PATH];
    WCHAR szTemp[MAX_PATH];

    switch (eTheme)
    {
    case eThemeNoChange:
        szThemeName[0] = 0;
        break;
    case eThemeWindowsClassic:
        StringCchCopy(szThemeName, ARRAYSIZE(szThemeName), L"%ResourceDir%\\themes\\Windows Classic.theme");
        break;
    case eThemeProfessional:
        StringCchCopy(szThemeName, ARRAYSIZE(szThemeName), L"%ResourceDir%\\themes\\Luna.theme");
        break;
    }

    if (SUCCEEDED(HrRegGetValueString(HKEY_LOCAL_MACHINE, SZ_THEMES, SZ_REGVALUE_INSTALLCUSTOM_THEME, szTemp, ARRAYSIZE(szTemp))) &&
        (!szTemp[0] || PathFileExists(szTemp)))
    {
        // The admin or OEM wanted this custom theme installed instead.
        StringCchCopy(szThemeName, ARRAYSIZE(szThemeName), szTemp);
    }

    if (szThemeName[0])
    {
        DWORD cbSize = (sizeof(szThemeName[0]) * (lstrlen(szThemeName) + 1));
        SHSetValue(HKEY_LOCAL_MACHINE, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, REG_SZ, (LPCVOID) szThemeName, cbSize);
    }

    switch (eVisualStyle)
    {
    case eThemeNoChange:
        szVisualStyleName[0] = 0;
        break;
    case eThemeWindowsClassic:
        szVisualStyleName[0] = 0;
        break;
    case eThemeProfessional:
        StringCchCopy(szVisualStyleName, ARRAYSIZE(szVisualStyleName), L"%SystemRoot%\\Resources\\themes\\Luna\\Luna.msstyles");
        break;
    }

    if (szVisualStyleName[0])
    {
        DWORD cbSize = (sizeof(szVisualStyleName[0]) * (lstrlen(szVisualStyleName) + 1));
        SHSetValue(HKEY_LOCAL_MACHINE, SZ_THEMES, SZ_REGVALUE_INSTALL_VISUALSTYLE, REG_SZ, (LPCVOID) szVisualStyleName, cbSize);

        ExpandResourceDir(szVisualStyleName, ARRAYSIZE(szVisualStyleName));
        hr = ExpandThemeTokens(NULL, szVisualStyleName, ARRAYSIZE(szVisualStyleName));      // Expand %ThemeDir% or %WinDir%
        hr = RegisterDefaultTheme(szVisualStyleName, TRUE);
    }

    LogStatus("SetupThemeForMachine() T=%ls, VS=%ls. returned hr=%#08lx.\r\n", szThemeName, szVisualStyleName, hr);
    return hr;
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    hr = CallRegInstall("DLL_RegInstall");

    //---- do this even if error occured ----
    MyRegTypeLib();
    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    // UnInstall the registry values
    hr = CallRegInstall("DLL_RegUnInstall");
    UnregisterTypeLibrary(&LIBID_Theme);

    return hr;
}


HRESULT VSParseCmdLine(LPCWSTR pszCmdLine, LPWSTR pszPath, int cchPath, LPWSTR pszColor, int cchColor, LPWSTR pszSize, int cchSize)
{
    HRESULT hr = E_FAIL;

    pszPath[0] = pszColor[0] = pszSize[0] = 0;

    pszCmdLine = StrStrW(pszCmdLine, SZ_INSTALL_VS);
    pszCmdLine += (ARRAYSIZE(SZ_INSTALL_VS) - 1);
    
    LPWSTR pszEndOfVS = StrStrW(pszCmdLine, L"','");
    if (pszEndOfVS)
    {
        LPWSTR pszStartOfColor = (pszEndOfVS + 3);
        LPWSTR pszEndOfColor = StrStrW(pszStartOfColor, L"','");

        if (pszEndOfColor)
        {
            LPWSTR pszStartOfSize = (pszEndOfColor + 3);
            LPWSTR pszEndOfSize = StrStrW(pszStartOfSize, L"'");

            if (pszEndOfSize)
            {
                StringCchCopy(pszPath, (int)min(cchPath, (pszEndOfVS - pszCmdLine + 1)), pszCmdLine);
                StringCchCopy(pszColor, (int)min(cchColor, (pszEndOfColor - pszStartOfColor + 1)), pszStartOfColor);
                StringCchCopy(pszSize, (int)min(cchSize, (pszEndOfSize - pszStartOfSize + 1)), pszStartOfSize);
                hr = S_OK;
            }
        }
    }

    return hr;
}


HRESULT InstallVS(LPCWSTR pszCmdLine)
{
    TCHAR szVisualStylePath[MAX_PATH];
    TCHAR szVisualStyleColor[MAX_PATH];
    TCHAR szVisualStyleSize[MAX_PATH];
    HRESULT hr = VSParseCmdLine(pszCmdLine, szVisualStylePath, ARRAYSIZE(szVisualStylePath), szVisualStyleColor, ARRAYSIZE(szVisualStyleColor), szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));

    if (SUCCEEDED(hr))
    {
        IThemeManager * pThemeManager;

        hr = CThemeManager_CreateInstance(NULL, IID_PPV_ARG(IThemeManager, &pThemeManager));
        if (SUCCEEDED(hr))
        {
            // Otherwise, we install the visual style.
            LogStatus("InstallVS() VS=%ls, Color=%ls, Size=%ls.\r\n", szVisualStylePath, szVisualStyleColor, szVisualStyleSize);
            hr = InstallVisualStyle(pThemeManager, szVisualStylePath, szVisualStyleColor, szVisualStyleSize);

            if (SUCCEEDED(hr))
            {
                // This ApplyNow() call will take a little while in normal situation (~10-20 seconds) in order
                // to broadcast the message to all open apps.  If a top level window is hung, it may take the
                // full 30 seconds to timeout.
                hr = pThemeManager->ApplyNow();
            }

            IUnknown_SetSite(pThemeManager, NULL); // Tell him to break the ref-count cycle with his children.
            pThemeManager->Release();
        }
    }

    return hr;
}


void HandleBeta2Upgrade(void)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szTemp[MAX_PATH];

    szPath[0] = 0;
    SHExpandEnvironmentStringsW(L"%SystemRoot%\\web\\wallpaper\\", szPath, ARRAYSIZE(szPath));
    LoadString(HINST_THISDLL, IDS_SETUP_BETA2_UPGRADEWALLPAPER, szTemp, ARRAYSIZE(szTemp));
    PathAppend(szPath, szTemp);

    if (PathFileExists(szPath))
    {
        // We no longer use "Red Moon Desert.bmp", now the default is "Bliss.bmp".
        DeleteFile(szPath);
    }
}


/*****************************************************************************\
    DESCRIPTION:
        This function will be called in the following situations:
    1. GUI Mode Setup:  In this case the cmdline is "regsvr32.exe /i themeui.dll".
            In that case, we install the machine settings.
    2. Per User Login: ActiveSetup will call us with "regsvr32.exe /n /i:/UserInstall themeui.dll"
            per user and only once.
    3. External Callers to Set Visual Style: External Callers will call us with:
            "regsvr32.exe /n /i:"/InstallVS:'<VisualStyle>','<ColorScheme>','<Size>'" themeui.dll"
            This will install that visual style.  <VisualStyle> can be an empty string
            to install "Windows Classic".

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

STDAPI DllInstall(BOOL fInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;
    BOOL fUserSetup = (pszCmdLine && StrStrW(pszCmdLine, SZ_USER_INSTALL) ? TRUE : FALSE);
    BOOL fInstallVS = (pszCmdLine && StrStrW(pszCmdLine, SZ_INSTALL_VS) ? TRUE : FALSE);

    g_fInSetup = TRUE;
    if (fUserSetup)
    {
        if (fInstall)
        {
            hr = CoInitialize(0);
            if (SUCCEEDED(hr))
            {
                hr = SetupThemeForUser();
                CoUninitialize();
            }
        }
    }
    else if (fInstallVS)
    {
        if (fInstall)
        {
            hr = CoInitialize(0);
            if (SUCCEEDED(hr))
            {
                hr = InstallVS(pszCmdLine);
                CoUninitialize();
            }
        }
    }
    else
    {
        if (fInstall)
        {
            // Ignore errors from theme manager here
            SetupThemeForMachine();
            HandleBeta2Upgrade();
        }
    }
    g_fInSetup = FALSE;

    LogStatus("DllInstall(%hs, \"%ls\") returned hr=%#08lx.\r\n", (fInstall ? "TRUE" : "FALSE"), (pszCmdLine ? pszCmdLine : L""), hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\effectsadvpg.h ===
/*****************************************************************************\
    FILE: EffectsAdvPg.h

    DESCRIPTION:
        This code will display the Effect tab in the Advanced Display Control
    panel.

    BryanSt 4/13/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _EFFECTSADVPG_H
#define _EFFECTSADVPG_H

#include "store.h"
#include <cowsite.h>            // for CObjectWithSite
#include <shpriv.h>

class CEffectsPage;

#include "EffectsBasePg.h"

static const GUID IID_CEffectsPage_THIS = { 0xef2b6246, 0x6c1b, 0x44fd, { 0x87, 0xea, 0xb3, 0xc5, 0xd, 0x47, 0x8b, 0x8e } };// {EF2B6246-6C1B-44fd-87EA-B3C50D478B8E}



#define PROPSHEET_CLASS             CEffectsBasePage
class CPropSheetExt;

HRESULT CEffectsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog);


class CEffectsPage              : public CObjectWithSite
                                , public IAdvancedDialog
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAdvancedDialog ***
    virtual STDMETHODIMP DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply);


private:
    CEffectsPage(void);
    virtual ~CEffectsPage(void);

    // Private Member Variables
    long                    m_cRef;
    BOOL                    m_fDirty;
    CEffectState *          m_pEffectsState;

    // Private Member Functions
    HRESULT _OnInit(HWND hDlg);
    HRESULT _OnApply(HWND hDlg);            // The user clicked apply
    HRESULT _IsDirty(IN BOOL * pIsDirty);
    INT_PTR _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    INT_PTR _PropertySheetDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK PropertySheetDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

    friend HRESULT CEffectsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog);
};




#endif // _EFFECTSADVPG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\effectsadvpg.cpp ===
/*****************************************************************************\
    FILE: EffectsAdvPg.cpp

    DESCRIPTION:
        This code will display the Effect tab in the Advanced Display Control
    panel.

    BryanSt 4/13/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "EffectsAdvPg.h"
#include "regutil.h"

//#undef _SHSEMIP_H_
//#include <shsemip.h>



typedef struct
{
    DWORD dwControlID;
    DWORD dwHelpContextID;
}POPUP_HELP_ARRAY;

POPUP_HELP_ARRAY phaMainDisplay[] = {
   { IDC_LARGEICONS,         IDH_DISPLAY_EFFECTS_LARGE_ICONS_CHECKBOX },
   { IDC_ICONHIGHCOLOR,      IDH_DISPLAY_EFFECTS_ALL_COLORS_CHECKBOX  },
   { IDC_MENUANIMATION,      IDH_DISPLAY_EFFECTS_ANIMATE_WINDOWS },
   { IDC_FONTSMOOTH,         IDH_DISPLAY_EFFECTS_SMOOTH_FONTS_CHECKBOX },
   { IDC_SHOWDRAG,           IDH_DISPLAY_EFFECTS_DRAG_WINDOW_CHECKBOX },
   { IDC_KEYBOARDINDICATORS, IDH_DISPLAY_EFFECTS_HIDE_KEYBOARD_INDICATORS },
   { IDC_GRPBOX_2,           IDH_COMM_GROUPBOX                 },
   { IDC_COMBOEFFECT,        IDH_DISPLAY_EFFECTS_ANIMATE_LISTBOX },
   { IDC_COMBOFSMOOTH,       IDH_DISPLAY_EFFECTS_SMOOTH_FONTS_LISTBOX },
   { IDC_MENUSHADOWS,        IDH_DISPLAY_EFFECTS_MENUSHADOWS},
   { 0, 0 },
   { 0, 0 },          // double-null terminator NECESSARY!
};

#define SZ_HELPFILE_DISPLAY             TEXT("DISPLAY.HLP")
#define SZ_HELPFILE_WINDOWS             TEXT("WINDOWS.HLP")

ULONG   g_ulFontInformation, g_ulNewFontInformation;

//===========================
// *** Class Internals & Helpers ***
//===========================
DWORD ListIndexToFontSmoothingType(int nIndex, DWORD dwPreviousType)
{
    // We want to keep the high bits in dwPreviousType because we are only replacing
    // the lower bits.
    return ((0xFFFFFFF0 & dwPreviousType) | (nIndex + 1));
}


void HideComboEffectsWindow(HWND hDlg)
{
    TCHAR szText[MAX_PATH];

    // We change the text so it doesn't have a reference to the drop down.
    LoadString(HINST_THISDLL, IDS_COMBO_EFFECTS_NOLIST, szText, ARRAYSIZE(szText));
    SetWindowText(GetDlgItem(hDlg, IDC_MENUANIMATION), szText);
    ShowWindow(GetDlgItem(hDlg, IDC_COMBOEFFECT), SW_HIDE);
}


BOOL FadeEffectAvailable()
{
    BOOL fFade = FALSE, fTestFade = FALSE;
    
    ClassicSystemParametersInfo( SPI_GETMENUFADE, 0, (PVOID)&fFade, 0 );
    if (fFade) 
        return TRUE;

    ClassicSystemParametersInfo( SPI_SETMENUFADE, 0, (PVOID)1, 0);
    ClassicSystemParametersInfo( SPI_GETMENUFADE, 0, (PVOID)&fTestFade, 0 );
    ClassicSystemParametersInfo( SPI_SETMENUFADE, 0, IntToPtr(fFade), 0);

    return (fTestFade);
}


HRESULT CEffectsPage::_OnApply(HWND hDlg)
{
    HRESULT hr = S_OK;

    // Full Color Icons
    if (m_pEffectsState && (m_pEffectsState->_nOldHighIconColor != m_pEffectsState->_nHighIconColor))
    {
        if ((GetBitsPerPixel() < 16) && (m_pEffectsState->_nHighIconColor == 16)) // Display mode won't support icon high colors
        {
            TCHAR szTemp1[512];
            TCHAR szTemp2[256];

            LoadString(HINST_THISDLL, IDS_256COLORPROBLEM, szTemp1, ARRAYSIZE(szTemp1));
            LoadString(HINST_THISDLL, IDS_ICONCOLORWONTWORK, szTemp2, ARRAYSIZE(szTemp2));
            StringCchCat(szTemp1, ARRAYSIZE(szTemp1), szTemp2);
            LoadString(HINST_THISDLL, IDS_EFFECTS, szTemp2, ARRAYSIZE(szTemp2));

            MessageBox(hDlg, szTemp1, szTemp2, MB_OK|MB_ICONINFORMATION);
        }
    }

    return hr;
}


HRESULT CEffectsPage::_OnInit(HWND hDlg)
{
    HRESULT hr = S_OK;
    TCHAR szRes[100];

    if (!m_pEffectsState)
    {
        return E_INVALIDARG;
    }

    //////////////////////////////////////////////////////////////////////////
    // Load the state from persisted form (registry) to the state struct
    //////////////////////////////////////////////////////////////////////////
    g_bMirroredOS = IS_MIRRORING_ENABLED();

    //////////////////////////////////////////////////////////////////////////
    // Update UI based on the state struct
    //////////////////////////////////////////////////////////////////////////
    if (m_pEffectsState->_nLargeIcon == ICON_INDETERMINATE)
    {
        HWND hItem = GetDlgItem(hDlg, IDC_LARGEICONS);
        SendMessage(hItem, BM_SETSTYLE, (WPARAM)LOWORD(BS_AUTO3STATE), MAKELPARAM(FALSE,0));
    }

    // Set CheckBoxes
    SendMessage((HWND)GetDlgItem(hDlg, IDC_LARGEICONS), BM_SETCHECK, (WPARAM)m_pEffectsState->_nLargeIcon, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_MENUSHADOWS), BM_SETCHECK, (WPARAM)m_pEffectsState->_fMenuShadows, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_ICONHIGHCOLOR ), BM_SETCHECK, (WPARAM)(BOOL)(m_pEffectsState->_nHighIconColor == 16), 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_MENUANIMATION), BM_SETCHECK, (WPARAM)m_pEffectsState->_wpMenuAnimation, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_FONTSMOOTH), BM_SETCHECK, (WPARAM)m_pEffectsState->_fFontSmoothing, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_SHOWDRAG), BM_SETCHECK, (WPARAM)m_pEffectsState->_fDragWindow, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_KEYBOARDINDICATORS), BM_SETCHECK, (WPARAM)(m_pEffectsState->_fKeyboardIndicators ? BST_UNCHECKED : BST_CHECKED), 0);


    // Set Effects Drop Down
    HWND hwndCombo = GetDlgItem(hDlg,IDC_COMBOEFFECT);
    ComboBox_ResetContent(hwndCombo);
    LoadString(HINST_THISDLL, IDS_FADEEFFECT, szRes, ARRAYSIZE(szRes) );
    ComboBox_AddString(hwndCombo, szRes);
    LoadString(HINST_THISDLL, IDS_SCROLLEFFECT, szRes, ARRAYSIZE(szRes) );
    ComboBox_AddString(hwndCombo, szRes);
    ComboBox_SetCurSel(hwndCombo, (MENU_EFFECT_FADE == m_pEffectsState->_dwAnimationEffect) ? 0 : 1);
    EnableWindow(hwndCombo, (UINT)m_pEffectsState->_wpMenuAnimation);

    if (IsTSPerfFlagEnabled(TSPerFlag_NoAnimation))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_MENUANIMATION), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_COMBOEFFECT), FALSE);
        LogStatus("Animation Forced off because of TS Perf Flags\r\n");
    }

    if (IsTSPerfFlagEnabled(TSPerFlag_NoWindowDrag))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SHOWDRAG), FALSE);
        LogStatus("FullWindowDrag feature Forced off because of TS Perf Flags\r\n");
    }

    if (!FadeEffectAvailable()) 
    {
        HideComboEffectsWindow(hDlg);
    }

    if (0 != SHGetRestriction(NULL,POLICY_KEY_EXPLORER,POLICY_VALUE_ANIMATION))
    {
        //disable
        //0=     enable
        //non-0= disable
        //relies on the fact that if the key does not exist it returns 0 as well
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_MENUANIMATION), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_COMBOEFFECT), FALSE);
    }

    hwndCombo = GetDlgItem(hDlg,IDC_COMBOFSMOOTH); 
    ComboBox_ResetContent(hwndCombo);
    LoadString(HINST_THISDLL, IDS_STANDARDSMOOTHING, szRes, ARRAYSIZE(szRes));
    ComboBox_AddString(hwndCombo, szRes);
    LoadString(HINST_THISDLL, IDS_CLEARTYPE, szRes, ARRAYSIZE(szRes));
    ComboBox_AddString(hwndCombo, szRes);

    BOOL fTemp;
    ComboBox_SetCurSel(hwndCombo, m_pEffectsState->_dwFontSmoothingType-1);
    if (ClassicSystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, (PVOID)&fTemp, 0)) 
    {
        EnableWindow((HWND)hwndCombo, m_pEffectsState->_fFontSmoothing);
    }
    else
    {
        ShowWindow(hwndCombo, SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_SHOWME), SW_HIDE);
    }


    if (0 != SHGetRestriction(NULL, POLICY_KEY_EXPLORER, POLICY_VALUE_KEYBOARDNAV))
    {
        //disable, see comment for animation
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_KEYBOARDINDICATORS), FALSE);
    }

    //disable and uncheck things if we are on terminal server
    BOOL bEffectsEnabled;
    if (!ClassicSystemParametersInfo(SPI_GETUIEFFECTS, 0, (PVOID) &bEffectsEnabled, 0))
    {
        // This flag is only available on Win2k and later. We're depending
        // on the call returning false if the flag doesn't exist...
        bEffectsEnabled = TRUE;
    }

    if (!bEffectsEnabled)
    {
        EnableWindow((HWND)GetDlgItem( hDlg, IDC_MENUANIMATION), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_ICONHIGHCOLOR), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_KEYBOARDINDICATORS), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_FONTSMOOTH), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_COMBOFSMOOTH), FALSE);

        HideComboEffectsWindow(hDlg);
        SendDlgItemMessage(hDlg, IDC_MENUANIMATION, BM_SETCHECK, 0, 0);
        SendDlgItemMessage(hDlg, IDC_ICONHIGHCOLOR, BM_SETCHECK, 0, 0);
        SendDlgItemMessage(hDlg, IDC_KEYBOARDINDICATORS, BM_SETCHECK, 0, 0);
        SendDlgItemMessage(hDlg, IDC_FONTSMOOTH, BM_SETCHECK, 0, 0);
    }

    return hr;
}


INT_PTR CEffectsPage::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);
    WORD wEvent = GET_WM_COMMAND_CMD(wParam, lParam);

    switch (idCtrl)
    {
    case IDOK:
        EndDialog(hDlg, IDOK);
        break;

    case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;

    case IDC_LARGEICONS:
        if (m_pEffectsState)
        {
            m_pEffectsState->_nLargeIcon  = (int)SendMessage ( (HWND)lParam, BM_GETCHECK, 0, 0 );
        }
        break;

    case IDC_MENUSHADOWS:
        if (m_pEffectsState)
        {
            m_pEffectsState->_fMenuShadows  = (int)SendMessage ( (HWND)lParam, BM_GETCHECK, 0, 0 );
        }
        break;

    case IDC_ICONHIGHCOLOR:
        if (m_pEffectsState)
        {
            m_pEffectsState->_nHighIconColor = 4;
            if (SendMessage((HWND)lParam, BM_GETCHECK, 0, 0) == TRUE)
            {
                m_pEffectsState->_nHighIconColor = 16;
            }
        }
        break;

    case IDC_SHOWDRAG:
        if (m_pEffectsState)
        {
            m_pEffectsState->_fDragWindow = (SendMessage( (HWND)lParam, BM_GETCHECK, 0, 0 ) == BST_CHECKED);
        }
        break;

    case IDC_MENUANIMATION:
        if (m_pEffectsState)
        {
            switch (m_pEffectsState->_wpMenuAnimation)
            {
            case BST_UNCHECKED:
                m_pEffectsState->_wpMenuAnimation = BST_CHECKED;
                break;

            case BST_CHECKED:
            case BST_INDETERMINATE:
                m_pEffectsState->_wpMenuAnimation = BST_UNCHECKED;
                break;
            }
            SendMessage( (HWND)lParam, BM_SETCHECK, (WPARAM)m_pEffectsState->_wpMenuAnimation, 0 );
            EnableWindow((HWND)GetDlgItem( hDlg, IDC_COMBOEFFECT), (BST_CHECKED == m_pEffectsState->_wpMenuAnimation));
        }
        break;

    case IDC_COMBOEFFECT:
        if ((wEvent == CBN_SELCHANGE) && m_pEffectsState)
        {
            m_pEffectsState->_dwAnimationEffect = (DWORD)ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_COMBOEFFECT)) + 1;
        }
        break;

    case IDC_COMBOFSMOOTH:
        if ((wEvent == CBN_SELCHANGE) && m_pEffectsState)
        {
            m_pEffectsState->_dwFontSmoothingType = ListIndexToFontSmoothingType(ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_COMBOFSMOOTH)), m_pEffectsState->_dwFontSmoothingType);
        }
        break;

    case IDC_FONTSMOOTH:
        if (m_pEffectsState)
        {
            m_pEffectsState->_fFontSmoothing = (SendMessage( (HWND)lParam, BM_GETCHECK, 0, 0 ) == BST_CHECKED);
            EnableWindow((HWND)GetDlgItem( hDlg, IDC_COMBOFSMOOTH), m_pEffectsState->_fFontSmoothing);
            if (m_pEffectsState->_fFontSmoothing)
            {
                m_pEffectsState->_dwFontSmoothingType = ListIndexToFontSmoothingType(ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_COMBOFSMOOTH)), m_pEffectsState->_dwFontSmoothingType);
            }
        }
        break;

    case IDC_KEYBOARDINDICATORS:
        if (m_pEffectsState)
        {
            m_pEffectsState->_fKeyboardIndicators = ((SendMessage((HWND)lParam, BM_GETCHECK, 0, 0) == BST_CHECKED) ? FALSE : TRUE);
        }
        break;

    default:
        break;
    }

    return fHandled;
}


INT_PTR CALLBACK PropertySheetDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CEffectsPage * pThis = (CEffectsPage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CEffectsPage *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
        return pThis->_PropertySheetDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


//---------------------------------------------------------------------------
//
// PropertySheetDlgProc()
//
//  The dialog procedure for the "PlusPack" property sheet page.
//
//---------------------------------------------------------------------------
INT_PTR CEffectsPage::_PropertySheetDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch( uMessage )
    {
    case WM_INITDIALOG:
        _OnInit(hDlg);
    break;

    case WM_COMMAND:
        _OnCommand(hDlg, uMessage, wParam, lParam);
        break;

    case WM_HELP:
        {
            LPHELPINFO lphi = (LPHELPINFO)lParam;

            if( lphi->iContextType == HELPINFO_WINDOW )
            {
                LPCWSTR pszHelpFile = ((lphi->hItemHandle == GetDlgItem(hDlg, IDC_GRPBOX_2)) ? SZ_HELPFILE_WINDOWS : SZ_HELPFILE_DISPLAY);
                WinHelp( (HWND)lphi->hItemHandle, pszHelpFile, HELP_WM_HELP, (DWORD_PTR)phaMainDisplay);
            }
        }
        break;

    case WM_CONTEXTMENU:
        // first check for dlg window
        if( (HWND)wParam == hDlg )
        {
            // let the def dlg proc decide whether to respond or ignore;
            // necessary for title bar sys menu on right click
            return FALSE;       // didn't process message EXIT
        }
        else
        {
            // else go for the controls
            LPCWSTR pszHelpFile = (((HWND)wParam == GetDlgItem(hDlg, IDC_GRPBOX_2)) ? SZ_HELPFILE_WINDOWS : SZ_HELPFILE_DISPLAY);
            WinHelp( (HWND)wParam, pszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)phaMainDisplay);
        }
        break;

    default:
        return FALSE;
    }
    return(TRUE);
}


HRESULT CEffectsPage::_IsDirty(IN BOOL * pIsDirty)
{
    HRESULT hr = E_INVALIDARG;

    if (pIsDirty && m_pEffectsState)
    {
        // Ask state if it's dirty
        *pIsDirty = m_pEffectsState->IsDirty();
        hr = S_OK;
    }

    return hr;
}





//===========================
// *** IAdvancedDialog Interface ***
//===========================
HRESULT CEffectsPage::DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply)
{
    HRESULT hr = E_INVALIDARG;

    if (hwndParent && pBasePage && pfEnableApply)
    {
        // Load State Into Advanced Dialog 
        if (m_pEffectsState)
        {
            m_pEffectsState->Release();
            m_pEffectsState = NULL;
        }

        *pfEnableApply = FALSE;
        CEffectState * pEffectClone = NULL;

        hr = SHPropertyBag_ReadByRef(pBasePage, SZ_PBPROP_EFFECTSSTATE, (void *)&pEffectClone, sizeof(pEffectClone));
        if (SUCCEEDED(hr) && pEffectClone)
        {
            // We want a copy of their state
            hr = pEffectClone->Clone(&m_pEffectsState);
            if (SUCCEEDED(hr))
            {
                LinkWindow_RegisterClass();

                // Display Advanced Dialog
                if ((IDOK == DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_EFFECTS), hwndParent, PropertySheetDlgProc, (LPARAM)this)) && m_pEffectsState)
                {
                    // The user clicked OK, so merge modified state back into base dialog
                    _IsDirty(pfEnableApply);

                    // The user clicked Okay in the dialog so merge the dirty state from the
                    // advanced dialog into the base dialog.
                    hr = SHPropertyBag_WriteByRef(pBasePage, SZ_PBPROP_EFFECTSSTATE, (void *)m_pEffectsState);
                    m_pEffectsState->Release();
                    m_pEffectsState = NULL;
                }
            }

            LinkWindow_UnregisterClass(HINST_THISDLL);
            pEffectClone->Release();
        }
    }

    return hr;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CEffectsPage::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CEffectsPage::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CEffectsPage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CEffectsPage, IObjectWithSite),
        QITABENT(CEffectsPage, IAdvancedDialog),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}




//===========================
// *** Class Methods ***
//===========================
CEffectsPage::CEffectsPage() : m_cRef(1)
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_fDirty = FALSE;
}


CEffectsPage::~CEffectsPage()
{
    if (m_pEffectsState)
    {
        m_pEffectsState->Release();
    }
}


HRESULT CEffectsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        CEffectsPage * pThis = new CEffectsPage();

        if (pThis)
        {
            hr = pThis->QueryInterface(IID_PPV_ARG(IAdvancedDialog, ppAdvDialog));
            pThis->Release();
        }
        else
        {
            *ppAdvDialog = NULL;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\enumunknown.h ===
/*****************************************************************************\
    FILE: EnumUnknown.h

    DESCRIPTION:
        This code will implement IEnumUnknown for an HDPA.

    BryanSt 5/30/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _ENUMUNKNOWN_H
#define _ENUMUNKNOWN_H

HRESULT CEnumUnknown_CreateInstance(IN IUnknown * punkOwner, IN IUnknown ** ppArray, IN int nArraySize, IN int nIndex, OUT IEnumUnknown ** ppEnumUnknown);

#endif // _ENUMUNKNOWN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\exe.h ===
// EXE.H - read windows exe headers

/* Attempt to get information of type fInfo on the file szFile, depositing
    the information (to a maximum of nBuf characters) in pBuf.  If BOOL fError
    is set, then display error messages when something goes wrong... */

DWORD FAR PASCAL GetExeInfo(LPTSTR szFile, void FAR *pBuf, int cbBuf, UINT fInfo);

#define GEI_MODNAME         0x01
#define GEI_DESCRIPTION     0x02
#define GEI_FLAGS           0x03
#define GEI_EXEHDR          0x04
#define GEI_FAPI            0x05
#define GEI_EXPVER          0x06

#define PEMAGIC         0x4550  /* 'PE' */
#define NEMAGIC         0x454E  /* 'NE' */


// Second parameter must be writeable because that's how Kernel32 likes it...
UINT WinExecN(LPCTSTR pszPath, LPTSTR pszPathAndArgs, UINT uCmdShow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\effectsbasepg.cpp ===
/*****************************************************************************\
    FILE: EffectsBasePg.cpp

    DESCRIPTION:
        This code will be the base object that won't add any pages to the base
    "Display Properties" dialog.  However, it will request a "Effects" page be
    added to the Advanced.

    BryanSt 4/13/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.

\*****************************************************************************/
#include "priv.h"
#include <shlwapip.h>
#include <shlguidp.h>
#include <shsemip.h>
#pragma hdrstop

#include "EffectsBasePg.h"
#include "EffectsAdvPg.h"
#include <cfgmgr32.h>           // For MAX_GUID_STRING_LEN

//============================================================================================================
// *** Globals ***
//============================================================================================================

//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CEffectsBasePage::_InitState(void)
{
    HRESULT hr = S_OK;

    if (!m_pEffectsState)
    {
        m_pEffectsState = new CEffectState();
        if (m_pEffectsState)
        {
            m_pEffectsState->Load();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT CEffectsBasePage::_SaveState(CEffectState * pEffectsState)
{
    HRESULT hr = E_INVALIDARG;

    if (pEffectsState)
    {
        if (m_pEffectsState)
        {
            m_pEffectsState->Release();
        }

        m_pEffectsState = pEffectsState;
        pEffectsState->AddRef();
        hr = S_OK;
    }

    return hr;
}




//===========================
// *** IBasePropPage Interface ***
//===========================
HRESULT CEffectsBasePage::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(SZ_PBPROP_EFFECTSSTATE, pszPropName) && m_pEffectsState)
        {
            pVar->vt = VT_BYREF;
            pVar->byref = (void *)&m_pEffectsState;
            
            if (m_pEffectsState)
            {
                m_pEffectsState->AddRef();
            }

            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CEffectsBasePage::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (VT_BYREF == pVar->vt)
        {
            // The caller is passing us a (CEffectState *) object to save.
            if (!StrCmpW(SZ_PBPROP_EFFECTSSTATE, pszPropName))
            {
                hr = _SaveState((CEffectState *) pVar->byref);
            }
        }
        else if (VT_BOOL == pVar->vt)
        {
            // The caller is passing us a (CEffectState *) object to save.
            if (!StrCmpW(SZ_PBPROP_EFFECTS_MENUDROPSHADOWS, pszPropName))
            {
                hr = _InitState();
                if (SUCCEEDED(hr) && m_pEffectsState)
                {
                    m_pEffectsState->_fMenuShadows = (VARIANT_TRUE == pVar->boolVal);
                }
            }
        }
    }

    return hr;
}





//===========================
// *** IBasePropPage Interface ***
//===========================
HRESULT CEffectsBasePage::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        *ppAdvDialog = NULL;
        hr = _InitState();

        if (SUCCEEDED(hr))
        {
            hr = CEffectsPage_CreateInstance(ppAdvDialog);
        }
    }

    return hr;
}


HRESULT CEffectsBasePage::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    HRESULT hr = S_OK;

    if ((PPOAACTION_CANCEL != oaAction) && m_pEffectsState)
    {
        hr = m_pEffectsState->Save();

        // Make sure we reload the state next time we open the dialog.
        m_pEffectsState->Release();
        m_pEffectsState = NULL;
    }

    return hr;
}



//===========================
// *** IShellPropSheetExt Interface ***
//===========================
HRESULT CEffectsBasePage::AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam)
{
    // We don't want to add any pages to the base dialog since we moved the
    // "Effects" tab to the Advanced dlg.
    return S_OK;
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CEffectsBasePage::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CEffectsBasePage::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CEffectsBasePage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CEffectsBasePage, IBasePropPage),
        QITABENT(CEffectsBasePage, IPropertyBag),
        QITABENT(CEffectsBasePage, IPersist),
        QITABENT(CEffectsBasePage, IObjectWithSite),
        QITABENTMULTI(CEffectsBasePage, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CEffectsBasePage::CEffectsBasePage() : CObjectCLSID(&PPID_Effects), m_cRef(1)
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_fDirty = FALSE;
}

HRESULT CEffectsBasePage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (!punkOuter && ppvObj)
    {
        CEffectsBasePage * pThis = new CEffectsBasePage();

        *ppvObj = NULL;
        if (pThis)
        {
            hr = pThis->QueryInterface(riid, ppvObj);
            pThis->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\effectsbasepg.h ===
/*****************************************************************************\
    FILE: EffectsBasePg.h

    DESCRIPTION:
        This code will be the base object that won't add any pages to the base
    "Display Properties" dialog.  However, it will request a "Effects" page be
    added to the Advanced.

    BryanSt 4/13/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _EFFECTSBASEPG_H
#define _EFFECTSBASEPG_H

#include "store.h"
#include <cowsite.h>
#include <objclsid.h>
#include <shpriv.h>


#define SZ_PBPROP_EFFECTSSTATE               TEXT("EffectsState") // VT_BYREF (void *) to CEffectState class



HRESULT CEffectsBasePage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);


class CEffectsBasePage          : public CObjectCLSID
                                , public CObjectWithSite
                                , public IPropertyBag
                                , public IBasePropPage
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam) {return E_NOTIMPL;}

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IBasePropPage ***
    virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
    virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);



    CEffectsBasePage();
protected:

private:

    // Private Member Variables
    long                    m_cRef;

    BOOL                    m_fDirty;
    CEffectState *          m_pEffectsState;

    // Private Member Functions
    HRESULT _InitState(void);
    HRESULT _SaveState(CEffectState * pEffectsState);
};


#endif // _EFFECTSBASEPG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\enumunknown.cpp ===
/*****************************************************************************\
    FILE: EnumUnknown.cpp

    DESCRIPTION:
        This code will implement IEnumUnknown for an HDPA.

    BryanSt 5/30/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "EnumUnknown.h"


class CEnumUnknown      : public IEnumUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IEnumUnknown ***
    virtual STDMETHODIMP Next(IN ULONG celt, IN IUnknown ** rgelt, IN ULONG * pceltFetched);
    virtual STDMETHODIMP Skip(IN ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(OUT IEnumUnknown ** ppenum);

protected:
    HRESULT _Initialize(void);

private:
    CEnumUnknown(IN IUnknown * punkOwner, IN IUnknown ** ppArray, IN int nArraySize, IN int nIndex);
    virtual ~CEnumUnknown(void);

    // Private Member Variables
    long                    m_cRef;

    IUnknown *              m_punkOwner;                        // The owner of m_pUnknownArray.  We hold a ref on this guy to keep m_pUnknownArray valid.
    IUnknown **             m_pUnknownArray;                    // The array of IUnknowns
    int                     m_nArraySize;                       // The size of m_pUnknownArray 
    int                     m_nIndex;                           // The current index during enum.


    // Private Member Functions


    // Friend Functions
    friend HRESULT CEnumUnknown_CreateInstance(IN IUnknown * punkOwner, IN IUnknown ** ppArray, IN int nArraySize, IN int nIndex, OUT IEnumUnknown ** ppEnumUnknown);
};




//===========================
// *** Class Internals & Helpers ***
//===========================



//===========================
// *** IEnumUnknown Interface ***
//===========================
HRESULT CEnumUnknown::Next(IN ULONG celt, IN IUnknown ** rgelt, IN ULONG * pceltFetched)
{
    HRESULT hr = E_INVALIDARG;

    if (rgelt && pceltFetched)
    {
        ULONG nIndex;

        hr = S_OK;

        *pceltFetched = 0;
        for (nIndex = 0; nIndex < celt; nIndex++,m_nIndex++)
        {
            if ((m_nIndex < m_nArraySize) && m_pUnknownArray[m_nIndex])
            {
                rgelt[nIndex] = NULL;

                IUnknown_Set(&(rgelt[nIndex]), m_pUnknownArray[m_nIndex]);
                (*pceltFetched)++;
            }
            else
            {
                rgelt[nIndex] = NULL;
            }
        }
    }

    return hr;
}


HRESULT CEnumUnknown::Skip(IN ULONG celt)
{
    m_nIndex += celt;
    return S_OK;
}


HRESULT CEnumUnknown::Reset(void)
{
    m_nIndex = 0;
    return S_OK;
}


HRESULT CEnumUnknown::Clone(OUT IEnumUnknown ** ppenum)
{
    HRESULT hr = E_INVALIDARG;

    if (ppenum)
    {
        hr = CEnumUnknown_CreateInstance(SAFECAST(this, IEnumUnknown *), m_pUnknownArray, m_nArraySize, m_nIndex, ppenum);
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
ULONG CEnumUnknown::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CEnumUnknown::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CEnumUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CEnumUnknown, IEnumUnknown),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CEnumUnknown::CEnumUnknown(IN IUnknown * punkOwner, IN IUnknown ** ppArray, IN int nArraySize, IN int nIndex) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_punkOwner);

    IUnknown_Set(&m_punkOwner, punkOwner);
    m_pUnknownArray = ppArray;
    m_nArraySize = nArraySize;
    m_nIndex = nIndex;
}


CEnumUnknown::~CEnumUnknown()
{
    IUnknown_Set(&m_punkOwner, NULL);

    DllRelease();
}


HRESULT CEnumUnknown_CreateInstance(IN IUnknown * punkOwner, IN IUnknown ** ppArray, IN int nArraySize, IN int nIndex, OUT IEnumUnknown ** ppEnumUnknown)
{
    HRESULT hr = E_INVALIDARG;

    if (punkOwner && ppArray && ppEnumUnknown)
    {
        CEnumUnknown * pObject = new CEnumUnknown(punkOwner, ppArray, nArraySize, nIndex);

        *ppEnumUnknown = NULL;
        if (pObject)
        {
            hr = pObject->QueryInterface(IID_PPV_ARG(IEnumUnknown, ppEnumUnknown));
            pObject->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\exe.cpp ===
/*
 *  exe.c   Get info from a EXEHDR
 *
 *  Modification History:
 *
 *  4/03/89  ToddLa Wrote it
 *  4/09/90  T-JackD modification such that the type of error is reflected...
 *  4/17/90  t-jackd modification such that notification of error can be set...
 *  4/20/2001 BryanSt improved the error checking to bring the code into the 21st centry.
 */

#include "priv.h"
#pragma hdrstop

#include <newexe.h>
#include "exe.h"

static DWORD dwDummy;
#define FOPEN(sz)                CreateFile(sz, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL )
#define FCLOSE(fh)               CloseHandle(fh)
#define FREAD(fh,buf,len)        (ReadFile(fh,buf,len, &dwDummy, NULL) ? dwDummy : HFILE_ERROR)
#define FSEEK(fh,off,i)          SetFilePointer(fh,(DWORD)off, NULL, i)
#define F_SEEK_SET                    FILE_BEGIN

BOOL NEAR PASCAL IsFAPI(int fh, struct new_exe FAR *pne, long off);

/*
 *  Function will return a specific piece of information from a new EXEHDR
 *
 *      szFile      - Path Name a new exe
 *      pBuf        - Buffer to place returned info
 *      nBuf        - Size of buffer in BYTES
 *      fInfo       - What info to get?
 *
 *          GEI_MODNAME         - Get module name
 *          GEI_DESCRIPTION     - Get description
 *          GEI_FLAGS           - Get EXEHDR flags
 *
 *  returns:  LOWORD = ne_magic, HIWORD = ne_exever
 *            0 if error
 */

DWORD FAR PASCAL GetExeInfo(LPTSTR szFile, void FAR *pBuf, int nBuf, UINT fInfo)
{
    HANDLE      fh;
    DWORD       off;
    DWORD       dw;
    BYTE        len;
    struct exe_hdr exehdr;
    struct new_exe newexe;

    fh = FOPEN(szFile);

    if (fh == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    if (FREAD(fh, &exehdr, sizeof(exehdr)) != sizeof(exehdr) ||
        exehdr.e_magic != EMAGIC ||
        exehdr.e_lfanew == 0L)
    {
            goto error;        /* Abort("Not an exe",h); */
    }

    FSEEK(fh, exehdr.e_lfanew, F_SEEK_SET);

    if (FREAD(fh, &newexe, sizeof(newexe)) != sizeof(newexe))
    {
            goto error;      // Read error
    }

    if (newexe.ne_magic == PEMAGIC)
    {
            if (fInfo != GEI_DESCRIPTION &&
                fInfo != GEI_EXPVER)
                    goto error;

            // make the file name the description
            StringCchCopy((LPTSTR) pBuf, nBuf, szFile);

            // read the SubsystemVersion

            FSEEK(fh,exehdr.e_lfanew+18*4,F_SEEK_SET);
            FREAD(fh,&dw,4);

            newexe.ne_expver = LOBYTE(LOWORD(dw)) << 8 | LOBYTE(HIWORD(dw));
            goto exit;
    }

    if (newexe.ne_magic != NEMAGIC)
    {
            goto error;      // Invalid NEWEXE
    }

    switch (fInfo)
    {
        case GEI_EXEHDR:
            *(struct new_exe *)pBuf = newexe;
            break;

        case GEI_FLAGS:
            *(WORD *)pBuf = newexe.ne_flags;
            break;

        /* module name is the first entry in the medident name table */
        case GEI_MODNAME:
            off = exehdr.e_lfanew + newexe.ne_restab;
            goto readstr;
            break;

        /* module name is the first entry in the non-medident name table */
        case GEI_DESCRIPTION:
            off = newexe.ne_nrestab;
readstr:
            FSEEK(fh, off, F_SEEK_SET);
            FREAD(fh, &len, sizeof(BYTE));

            nBuf--;         // leave room for a \0

            if (len > (BYTE)nBuf)
                len = (BYTE)nBuf;

            {
                LPSTR pbTmp;
                pbTmp = (LPSTR) LocalAlloc(LMEM_FIXED, len);

                if (pbTmp)
                {
                    FREAD(fh, pbTmp, len);

                    len = (BYTE)MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pbTmp, len,
                            (LPWSTR)pBuf, nBuf / sizeof(WCHAR));

                    LocalFree(pbTmp);
                }
            }
            ((LPTSTR)pBuf)[len] = 0;
            break;

        case GEI_EXPVER:
            break;

        default:
            goto error;
            break;
    }

exit:
    FCLOSE(fh);
    return MAKELONG(newexe.ne_magic, newexe.ne_expver);

error:
    FCLOSE(fh);
    return 0;
}

// Code taken from kernel32.dll
#define DEFAULT_WAIT_FOR_INPUT_IDLE_TIMEOUT 30000

UINT WinExecN(LPCTSTR pszPath, LPTSTR pszPathAndArgs, UINT uCmdShow)
{
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL CreateProcessStatus;
    DWORD ErrorCode;

    ZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = (WORD)uCmdShow;
    CreateProcessStatus = CreateProcess(
                            pszPath,
                            pszPathAndArgs,
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &StartupInfo,
                            &ProcessInformation
                            );

    if ( CreateProcessStatus )
    {
        // Wait for the started process to go idle. If it doesn't go idle in
        // 10 seconds, return anyway.
        WaitForInputIdle(ProcessInformation.hProcess, DEFAULT_WAIT_FOR_INPUT_IDLE_TIMEOUT);
        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);
        return 33;
    }
    else
    {
        // If CreateProcess failed, then look at GetLastError to determine
        // appropriate return code.
        ErrorCode = GetLastError();
        switch ( ErrorCode )
        {
            case ERROR_FILE_NOT_FOUND:
                return 2;

            case ERROR_PATH_NOT_FOUND:
                return 3;

            case ERROR_BAD_EXE_FORMAT:
                return 11;

            default:
                return 0;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\fake.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Fake.c
//
// this code gives OEMs a bogus Settings page to patch/modify
//
// OEM display pages patch the snot out of the Settings page
// the problem is that we have changed the setting page, and
// even if the OEM code could deal with our changes, the
// settings page is not even on the same property sheet
// as the extensions.
//
// some OEMs hook the setting page by hooking the TabContol and
// watching for a mouse click to activate the Settings page
// then they modify the page.  NOTE they dont patch the page
// if it is activated via the keyboard only the mouse!
//
// some OEM pages find the Setting page by name.
// we have named the real settings page "Settings " and
// the fake page is "Settings"
//
// some OEM pages assume the last page is the Settings page.
// we make sure the fake settings is always last.
//
///////////////////////////////////////////////////////////////////////////////
#include "priv.h"
#include "winuser.h"
#pragma hdrstop
#include "cplext.h"

/*
 * Global stuff
 */
static LONG_PTR TabWndProc;             // SysTabControl WndProc
static LONG_PTR DlgWndProc;             // Dialog WndProc

/*
 * Local Constant Declarations
 */
int CALLBACK DeskPropSheetCallback(HWND hDlg, UINT code, LPARAM lParam);
INT_PTR CALLBACK FakeSettingsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

IThemeUIPages *g_pThemeUI;
///////////////////////////////////////////////////////////////////////////////
// AddFakeSettingsPage
///////////////////////////////////////////////////////////////////////////////
void AddFakeSettingsPage(IThemeUIPages *pThemeUI, PROPSHEETHEADER * ppsh)
{
    g_pThemeUI = pThemeUI;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpsp;

    ZeroMemory(&psp, sizeof(psp));

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = HINST_THISDLL;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_FAKE_SETTINGS);
    psp.pfnDlgProc  = FakeSettingsDlgProc;
    psp.lParam      = 0L;

    //
    // some OEMs find the Property sheet by window title
    // so make sure we have the title they expect.
    //
    hpsp = CreatePropertySheetPage(&psp);
    if (hpsp)
    {
        ppsh->phpage[ppsh->nPages++] = hpsp;

        ppsh->pfnCallback = DeskPropSheetCallback;
        ppsh->dwFlags    |= PSH_USECALLBACK;
    }
}

///////////////////////////////////////////////////////////////////////////////
// FakeSettingsDlgProc
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK FakeSettingsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    if (hDlg && DlgWndProc)
    {
        if (GetWindowLongPtr(hDlg, GWLP_WNDPROC) != DlgWndProc)
        {
            SetWindowLongPtr(hDlg, GWLP_WNDPROC, DlgWndProc);
        }

        if (GetWindowLongPtr(hDlg, DWLP_DLGPROC) != (LONG_PTR)FakeSettingsDlgProc)
        {
            SetWindowLongPtr(hDlg, DWLP_DLGPROC, (LONG_PTR)FakeSettingsDlgProc);
        }
    }

    switch (message)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_DESTROY:
            break;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDC_CHANGEDRV)
            {
            }
            break;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// HideFakeSettingsPage
//
// hide the bogus settings page from view so the user cant see it.
//
// this code uses a new TabCtrl item style TCIS_HIDDEN that is only
// in the Win98/NT5/IE4.01 COMMCTRL
//
///////////////////////////////////////////////////////////////////////////////
void HideFakeSettingsPage(HWND hDlg)
{
    HWND hwnd = PropSheet_GetTabControl(hDlg);
    if (hwnd)
    {
        TCITEM tci;
        tci.mask = TCIF_STATE;
        tci.dwStateMask = TCIS_HIDDEN;
        tci.dwState = TCIS_HIDDEN;
        TabCtrl_SetItem(hwnd, TabCtrl_GetItemCount(hwnd)-1, &tci);
    }
}

///////////////////////////////////////////////////////////////////////////////
// DeskPropSheetCallback
//
// what this callback does is look for someone subclassing the
// tab control, if we detect this we put the correct WndProc
// back.
//
// we also hide the fake settings page after all the entensions
// have initialized
//
///////////////////////////////////////////////////////////////////////////////
int CALLBACK DeskPropSheetCallback(HWND hDlg, UINT code, LPARAM lParam)
{
    HWND hwnd;

    WNDCLASS wc;

    switch (code)
    {
        case PSCB_INITIALIZED:
            TraceMsg(TF_GENERAL, "DeskPropSheetCallback: PSCB_INITIALIZED");

            hwnd = PropSheet_GetTabControl(hDlg);
            if (hwnd && TabWndProc)
            {
                if (GetWindowLongPtr(hwnd, GWLP_WNDPROC) != TabWndProc)
                {
                    SetWindowLongPtr(hwnd, GWLP_WNDPROC, TabWndProc);
                }
            }

            if (hDlg && DlgWndProc)
            {
                if (GetWindowLongPtr(hDlg, GWLP_WNDPROC) != DlgWndProc)
                {
                    SetWindowLongPtr(hDlg, GWLP_WNDPROC, DlgWndProc);
                }
            }

            //
            // hide the settings page so the user cant see it.
            //
            HideFakeSettingsPage(hDlg);
            break;

        case PSCB_PRECREATE:
            TraceMsg(TF_GENERAL, "DeskPropSheetCallback: PSCB_PRECREATE");

            ZeroMemory(&wc, sizeof(wc));
            SHFusionGetClassInfo(NULL, WC_DIALOG, &wc);
            DlgWndProc = (LONG_PTR)wc.lpfnWndProc;

            ZeroMemory(&wc, sizeof(wc));
            SHFusionGetClassInfo(NULL, WC_TABCONTROL, &wc);
            TabWndProc = (LONG_PTR)wc.lpfnWndProc;
            break;

        case PSCB_BUTTONPRESSED:
            if ((PSBTN_OK == lParam) || (PSBTN_APPLYNOW == lParam))
            {
                DWORD dwFlags = ((PSBTN_OK == lParam) ? (TUIAP_WAITFORAPPLY | TUIAP_NONE) : TUIAP_NONE);
                if (g_pThemeUI)
                {
                    g_pThemeUI->ApplyPressed(dwFlags);
                }
            }
            break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\guids.h ===
/*****************************************************************************\
    FILE: guids.h

    DESCRIPTION:
        This file contains GUIDs that we couldn't get from the public headers
    for one reason or another.

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif


#undef MIDL_DEFINE_GUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\general.cpp ===
/**************************************************************************\
 * Module Name: general.cpp
 *
 * Contains all the code to manage multiple devices
 *
 * Copyright (c) Microsoft Corp.  1995-1996 All Rights Reserved
 *
 * NOTES:
 *
 * History: Create by dli on 7/21/97
 *
 \**************************************************************************/


#include "priv.h"
#include "SettingsPg.h"

extern INT_PTR CALLBACK CustomFontDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);

//-----------------------------------------------------------------------------
static const DWORD sc_GeneralHelpIds[] =
{
    // font size
    IDC_FONTSIZEGRP,   NO_HELP, // IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_FONTSIZE, 
    IDC_FONT_SIZE_STR, IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_FONTSIZE, 
    IDC_FONT_SIZE,     IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_FONTSIZE,    
    IDC_CUSTFONTPER,   IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_FONTSIZE, 

    // group box
    IDC_DYNA,          NO_HELP, // IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_DYNA,     

    // radio buttons
    IDC_DYNA_TEXT,     NO_HELP,
    IDC_NODYNA,        IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_RESTART, 
    IDC_YESDYNA,       IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_DONT_RESTART,
    IDC_SHUTUP,        IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_ASK_ME, 
    IDC_SETTINGS_GEN_COMPATWARNING, (DWORD)-1, 

    0, 0
};


/*--------------------------------------------------------------------------*
 *--------------------------------------------------------------------------*/
class CGeneralDlg {
    private:
        int _idCustomFonts;
        int _iDynaOrg;
        IUnknown * _punkSite;
        HWND _hwndFontList;
        HWND _hDlg;
        //
        // current log pixels of the screen.
        // does not change !
        int _cLogPix;
        BOOL _fForceSmallFont;
        BOOL _InitFontList();
        void _InitDynaCDSPreference();
        LRESULT _OnNotify(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    public:
        CGeneralDlg(GENERAL_ADVDLG_INITPARAMS * pInitParams);
        void InitGeneralDlg(HWND hDlg);
        void SetFontSizeText( int cdpi );
        BOOL ChangeFontSize();
        void HandleGeneralApply(HWND hDlg);
        void HandleFontSelChange();
        void ForceSmallFont();
        LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

CGeneralDlg::CGeneralDlg(GENERAL_ADVDLG_INITPARAMS * pInitParams) : _fForceSmallFont(pInitParams->fFoceSmallFont), _idCustomFonts(-1)
{
    HKEY hkFont;
    DWORD cb;

    _punkSite = pInitParams->punkSite;

    // For font size just always use the one of the current screen.
    // Whether or not we are testing the current screen.
    _cLogPix = 96;

    // If the size does not match what is in the registry, then install
    // the new one
    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      SZ_FONTDPI_PROF,
                      0,
                      KEY_READ,
                      &hkFont) == ERROR_SUCCESS) ||
        (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      SZ_FONTDPI,
                      0,
                      KEY_READ,
                      &hkFont) == ERROR_SUCCESS))

    {
        cb = sizeof(DWORD);

        if (RegQueryValueEx(hkFont,
                            SZ_LOGPIXELS,
                            NULL,
                            NULL,
                            (LPBYTE) &_cLogPix,
                            &cb) != ERROR_SUCCESS)
        {
            _cLogPix = 96;
        }

       RegCloseKey(hkFont);
    }
};

//
//  The purpose of this function is to check if the OriginalDPI value was already saved in the 
// per-machine part of the registry. If this is NOT present, then get the system DPI and save it 
// there. We want to do it just once for a machine. When an end-user logsin, we need to detect if
// we need to change the sizes of UI fonts based on DPI change. We use the "AppliedDPI", which is 
// stored on the per-user branch of the registry to determine the dpi change. If this "AppliedDPI"
// is missing, then this OriginalDPI value will be used. If this value is also missing, that 
// implies that nobody has changed the system DPI value.
//
void SaveOriginalDPI()
{
    //See if the "OriginalDPI value is present under HKEY_LOCAL_MACHINE.
    HKEY hk;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SZ_CONTROLPANEL,
                     0,
                     KEY_READ | KEY_WRITE,
                     &hk) == ERROR_SUCCESS)
    {
        DWORD dwOriginalDPI;
        DWORD dwDataSize = sizeof(dwOriginalDPI);
        
        if (RegQueryValueEx(hk, SZ_ORIGINALDPI, NULL, NULL,
                            (LPBYTE)&dwOriginalDPI, &dwDataSize) != ERROR_SUCCESS)
        {
            //"OriginalDPI" value is not present in the registry. Now, get the DPI
            // and save it as the "OriginalDPI"
            HDC hdc = GetDC(NULL);
            dwOriginalDPI = GetDeviceCaps(hdc, LOGPIXELSY);
            ReleaseDC(NULL, hdc);
        }
            
        DWORD dwSize = sizeof(dwOriginalDPI);

        //Save the current DPI as the "OriginalDPI" value.
        RegSetValueEx(hk, SZ_ORIGINALDPI, NULL, REG_DWORD, (LPBYTE) &dwOriginalDPI, dwSize);
       
        RegCloseKey(hk);
    }
}

BOOL CGeneralDlg::ChangeFontSize()
{
    int cFontSize = 0;
    int cForcedFontSize;
    int cUIfontSize;

    // Change font size if necessary
    int i = ComboBox_GetCurSel(_hwndFontList);

    if (i != CB_ERR )
    {
        TCHAR awcDesc[10];

        cFontSize = (int)ComboBox_GetItemData(_hwndFontList, i);

        if ( (cFontSize != CB_ERR) &&
             (cFontSize != 0) &&
             (cFontSize != _cLogPix))
        {
            //Save the original DPI before the DPI ever changed.
            SaveOriginalDPI();
            
            cUIfontSize = cForcedFontSize = cFontSize;
            if (_idCustomFonts == i)
            {
                BOOL predefined = FALSE;
                int count = ComboBox_GetCount(_hwndFontList);
                int max = -1, min = 0xffff, dpi;
                for (i = 0; i < count; i++)
                {
                    if (i == _idCustomFonts) 
                        continue;

                    dpi  = (int)ComboBox_GetItemData(_hwndFontList, i);

                    if (dpi == cFontSize) 
                    {
                        predefined = TRUE;
                        break;
                    }

                    if (dpi < min) min = dpi;
                    if (dpi > max) max = dpi;
                }

                if (!predefined) {
                    if ((cFontSize > max) || (cFontSize + (max-min)/2 > max))
                        cForcedFontSize = max;
                    else 
                        cForcedFontSize = min;

                    // Currently our Custom font picker allows end-users to pick upto 500% of 
                    // normal font size; But, when we enlarge the UI fonts to this size, the 
                    // system becomes un-usable after reboot. So, what we do here is to allow
                    // ui font sizes to grow up to 200% and then all further increases are 
                    // proportionally reduced such that the maximum possible ui font size is only
                    // 250%. (i.e the range 200% to 500% is mapped on to a range of 200% to 250%)
                    // In other words, we allow upto 192 dpi (200%) with no modification. For any
                    // DPI greater than 192, we proportionately reduce it such that the highest DPI
                    // is only 240!
                    if(cUIfontSize > 192)
                        cUIfontSize = 192 + ((cUIfontSize - 192)/6);
                }
            }

            // Call setup to change the font size.
            StringCchPrintf(awcDesc, ARRAYSIZE(awcDesc), TEXT("%d"), cForcedFontSize);
            if (SetupChangeFontSize(_hDlg, awcDesc) == NO_ERROR)
            {
                IPropertyBag * pPropertyBag;

                // Font change has succeeded; Now there is a new DPI to be applied to UI fonts!
                if (_punkSite && SUCCEEDED(GetPageByCLSID(_punkSite, &PPID_BaseAppearance, &pPropertyBag)))
                {
                    // Use _punkSite to push the DPI back up to the Appearance tab where it's state lives.
                    LogStatus("CGeneralDlg::ChangeFontSize() user changed DPI to %d\r\n", cUIfontSize);
                    SHPropertyBag_WriteInt(pPropertyBag, SZ_PBPROP_DPI_MODIFIED_VALUE, cUIfontSize);
                    pPropertyBag->Release();
                }
                
                // A font size change will require a system reboot.
                PropSheet_RestartWindows(GetParent(_hDlg));

                HrRegSetDWORD(HKEY_LOCAL_MACHINE, SZ_FONTDPI_PROF, SZ_LOGPIXELS, cFontSize);
                HrRegSetDWORD(HKEY_LOCAL_MACHINE, SZ_FONTDPI, SZ_LOGPIXELS, cFontSize);
            }
            else
            {
                // Setup failed.
                FmtMessageBox(_hDlg,
                              MB_ICONSTOP | MB_OK,
                              ID_DSP_TXT_CHANGE_FONT,
                              ID_DSP_TXT_ADMIN_INSTALL);

                return FALSE;
            }
        }
    }

    if (cFontSize == 0)
    {
        // If we could not read the inf, then ignore the font selection
        // and don't force the reboot on account of that.
        cFontSize = _cLogPix;
    }

    return TRUE;
}

void CGeneralDlg::InitGeneralDlg(HWND hDlg)
{
    _hDlg = hDlg;
    _hwndFontList = GetDlgItem(_hDlg, IDC_FONT_SIZE);
    _InitFontList();
    _iDynaOrg = -1;
}

void CGeneralDlg::_InitDynaCDSPreference()
{
    int iDyna = GetDynaCDSPreference();
    if(iDyna != _iDynaOrg)
    {
        _iDynaOrg = iDyna;

        CheckDlgButton(_hDlg, IDC_SHUTUP, FALSE);
        CheckDlgButton(_hDlg, IDC_YESDYNA, FALSE);
        CheckDlgButton(_hDlg, IDC_NODYNA, FALSE);

        if (_iDynaOrg & DCDSF_ASK)
            CheckDlgButton(_hDlg, IDC_SHUTUP, TRUE);
        else if (_iDynaOrg & DCDSF_DYNA)
            CheckDlgButton(_hDlg, IDC_YESDYNA, TRUE);
        else
            CheckDlgButton(_hDlg, IDC_NODYNA, TRUE);
    }
}


static UINT s_DPIDisplayNames[] =
{
    96 /*DPI*/,  IDS_SETTING_GEN_96DPI,
    120 /*DPI*/, IDS_SETTING_GEN_120DPI,
};

HRESULT _LoadDPIDisplayName(int nDPI, LPTSTR pszDisplayName, DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    int nIndex;

    for (nIndex = 0; nIndex < ARRAYSIZE(s_DPIDisplayNames); nIndex += 2)
    {
        if (nDPI == (int)s_DPIDisplayNames[nIndex])
        {
            LoadString(HINST_THISDLL, s_DPIDisplayNames[nIndex + 1], pszDisplayName, cchSize);
            hr = S_OK;
            break;
        }
    }

    return hr;
}


// Init Font sizes 
//
// For NT:
// Read the supported fonts out of the inf file(s)
// Select was the user currently has.
//
BOOL CGeneralDlg::_InitFontList() {

    int i;
    ASSERT(_hwndFontList);
    ULONG uCurSel = (ULONG) -1;
    int cPix = 0;
    TCHAR szBuf2[100];

    HINF InfFileHandle;
    INFCONTEXT infoContext;

    //
    // Get all font entries from both inf files
    //

    InfFileHandle = SetupOpenInfFile(TEXT("font.inf"),
                                     NULL,
                                     INF_STYLE_WIN4,
                                     NULL);

    if (InfFileHandle != INVALID_HANDLE_VALUE)
    {
        if (SetupFindFirstLine(InfFileHandle,
                               TEXT("Font Sizes"),
                               NULL,
                               &infoContext))
        {
            for (;;)
            {
                TCHAR awcDesc[LINE_LEN];

                if (SetupGetStringField(&infoContext,
                                        0,
                                        awcDesc,
                                        ARRAYSIZE(awcDesc),
                                        NULL) &&
                    SetupGetIntField(&infoContext,
                                     1,
                                     &cPix))
                {
                    // Add it to the list box
                    _LoadDPIDisplayName(cPix, awcDesc, ARRAYSIZE(awcDesc));

                    i = ComboBox_AddString(_hwndFontList, awcDesc);
                    if (i != CB_ERR)
                    {
                        ComboBox_SetItemData(_hwndFontList, i, cPix);
                        if (_cLogPix == cPix)
                            uCurSel = i;
                    }
                }

                //
                // Try to get the next line.
                //

                if (!SetupFindNextLine(&infoContext,
                                       &infoContext))
                {
                    break;
                }
            }
        }

        SetupCloseInfFile(InfFileHandle);
    }

    //
    // Put in the custom fonts string
    //

    LoadString(HINST_THISDLL, ID_DSP_CUSTOM_FONTS, szBuf2, ARRAYSIZE(szBuf2));
    _idCustomFonts = ComboBox_AddString(_hwndFontList, szBuf2);

    if (_idCustomFonts != CB_ERR)
        ComboBox_SetItemData(_hwndFontList, _idCustomFonts, _cLogPix);
    
    if (uCurSel == (ULONG) -1) {
        uCurSel = _idCustomFonts;
    }


    // NOTE: We currently change the font size by calling SetupChangeFontSize
    // This function will fail if the user is not an administrator.  We would like to
    // disable this functionality but system admins want to be able to allow
    // non-admins to install by turning on a registry flag.  NT4 supports this,
    // so we need to also.  In order for this to work, we need to leave the
    // install button enabled.  This backs out NT #318617.  Contact
    // the following people about this issue: Marius Marin, Tom Politis,
    // Naresh Jivanji.     -BryanSt 3/24/2000
    // EnableWindow(_hwndFontList, IsUserAdmin());
    
    if (_fForceSmallFont && (_cLogPix == 96))
        this->ForceSmallFont();
    else
    {
        //
        // Select the right entry.
        //
        ComboBox_SetCurSel(_hwndFontList, uCurSel);
        this->SetFontSizeText( _cLogPix );
    }

    
    return TRUE;
}


void CGeneralDlg::SetFontSizeText( int cdpi )
{
    HWND hwndCustFontPer;
    TCHAR achStr[80];
    TCHAR achFnt[120];

    if (cdpi == CDPI_NORMAL)
    {
        LoadString(HINST_THISDLL, ID_DSP_NORMAL_FONTSIZE_TEXT, achStr, ARRAYSIZE(achStr));
        StringCchPrintf(achFnt, ARRAYSIZE(achFnt), achStr, cdpi);
    }
    else
    {
        LoadString(HINST_THISDLL, ID_DSP_CUSTOM_FONTSIZE_TEXT, achStr, ARRAYSIZE(achStr));
        StringCchPrintf(achFnt, ARRAYSIZE(achFnt), achStr, (100 * cdpi + 50) / CDPI_NORMAL, cdpi );
    }

    hwndCustFontPer = GetDlgItem(_hDlg, IDC_CUSTFONTPER);
    SendMessage(hwndCustFontPer, WM_SETTEXT, 0, (LPARAM)achFnt);
}


//
// ForceSmallFont method
//
//
void CGeneralDlg::ForceSmallFont() {
    int i, iSmall, dpiSmall, dpi;
    //
    // Set small font size in the listbox.
    //
    iSmall = CB_ERR;
    dpiSmall = 9999;
    for (i=0; i <=1; i++)
    {
        dpi = (int)ComboBox_GetItemData(_hwndFontList, i);
        if (dpi == CB_ERR)
            continue;

        if (dpi < dpiSmall || iSmall < CB_ERR)
        {
            iSmall = i;
            dpiSmall = dpi;
        }
    }

    if (iSmall != -1)
        ComboBox_SetCurSel(_hwndFontList, iSmall);
    this->SetFontSizeText(dpiSmall);
    EnableWindow(_hwndFontList, FALSE);
}

void CGeneralDlg::HandleGeneralApply(HWND hDlg)
{
    int iDynaNew;

    if (IsDlgButtonChecked(hDlg, IDC_YESDYNA))
        iDynaNew= DCDSF_YES;
    else if (IsDlgButtonChecked(hDlg, IDC_NODYNA))
        iDynaNew= DCDSF_NO;
    else
        iDynaNew = DCDSF_PROBABLY;

    if (iDynaNew != _iDynaOrg)
    {
        SetDisplayCPLPreference(REGSTR_VAL_DYNASETTINGSCHANGE, iDynaNew);
        _iDynaOrg = iDynaNew;
    }

    BOOL bSuccess = ChangeFontSize();
    
    long lRet = (bSuccess ? PSNRET_NOERROR: PSNRET_INVALID_NOCHANGEPAGE);
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lRet);
}

void CGeneralDlg::HandleFontSelChange()
{
    //
    // Warn the USER font changes will not be seen until after
    // reboot
    //
    int iCurSel;
    int cdpi;

    iCurSel = ComboBox_GetCurSel(_hwndFontList);
    cdpi = (int)ComboBox_GetItemData(_hwndFontList, iCurSel);
    if (iCurSel == _idCustomFonts) {

        InitDragSizeClass();
        cdpi = (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_CUSTOMFONT),
                              _hDlg, CustomFontDlgProc, cdpi );
        if (cdpi != 0)
            ComboBox_SetItemData(_hwndFontList, _idCustomFonts, cdpi);
        else
            cdpi = (int)ComboBox_GetItemData(_hwndFontList, _idCustomFonts);
    }

    if (cdpi != _cLogPix)
    {
        // Remove in blackcomb.  We need to streamline this process.  That includes verifying that
        // the fonts will always be on disk and there is no need to allow users to get them from
        // the CD.
        FmtMessageBox(_hDlg,
                      MB_ICONINFORMATION,
                      ID_DSP_TXT_CHANGE_FONT,
                      ID_DSP_TXT_FONT_LATER);
        PropSheet_Changed(GetParent(_hDlg), _hDlg);
    }

    this->SetFontSizeText(cdpi);
}

LRESULT CGeneralDlg::_OnNotify(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lReturn = TRUE;
    NMHDR *lpnm = (NMHDR *)lParam;

    if (lParam)
    {
        switch (lpnm->code)
        {
        case PSN_SETACTIVE:
            _InitDynaCDSPreference();
            break;
        case PSN_APPLY:
            HandleGeneralApply(hDlg);
            break;
        case NM_RETURN:
        case NM_CLICK:
        {
            PNMLINK pNMLink = (PNMLINK) lpnm;

            if (!StrCmpW(pNMLink->item.szID, L"idGameCompat"))
            {
                TCHAR szHelpURL[MAX_PATH * 2];

                LoadString(HINST_THISDLL, IDS_SETTING_GEN_COMPAT_HELPLINK, szHelpURL, ARRAYSIZE(szHelpURL));
                HrShellExecute(hDlg, NULL, szHelpURL, NULL, NULL, SW_NORMAL);
            }
            break;
        }
        default:
            lReturn = FALSE;
            break;
        }
    }

    return lReturn;
}

LRESULT CALLBACK CGeneralDlg::WndProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lReturn = TRUE;

    switch (message)
    {
    case WM_INITDIALOG:
        InitGeneralDlg(hDlg);
        break;

    case WM_NOTIFY:
        lReturn = _OnNotify(hDlg, message, wParam, lParam);
        break;
        
    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_NODYNA:
            case IDC_YESDYNA:
            case IDC_SHUTUP:
                if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                    PropSheet_Changed(GetParent(hDlg), hDlg);
                break;
            case IDC_FONT_SIZE:
                switch (GET_WM_COMMAND_CMD(wParam, lParam))
                {
                    case CBN_SELCHANGE:
                        HandleFontSelChange();
                        break;
                    default:
                        break;
                }
                break;

            default:
                break;
        }
        break;
        
    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("display.hlp"), HELP_WM_HELP,
            (DWORD_PTR)(LPTSTR)sc_GeneralHelpIds);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, TEXT("display.hlp"), HELP_CONTEXTMENU,
            (DWORD_PTR)(LPTSTR)sc_GeneralHelpIds);
        break;
  
    default:
        return FALSE;
    }

    return lReturn;
}

//-----------------------------------------------------------------------------
//
// Callback functions PropertySheet can use
//
INT_PTR CALLBACK
GeneralPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CGeneralDlg * pcgd = (CGeneralDlg * )GetWindowLongPtr(hDlg, DWLP_USER);
    switch (message)
    {
        case WM_INITDIALOG:
            ASSERT(!pcgd);
            ASSERT(lParam);

            if (((LPPROPSHEETPAGE)lParam)->lParam)
            {
                GENERAL_ADVDLG_INITPARAMS * pInitParams = (GENERAL_ADVDLG_INITPARAMS *) ((LPPROPSHEETPAGE)lParam)->lParam;
                pcgd = new CGeneralDlg(pInitParams);
                if(pcgd)
                {
                    // now we need to init
                    pcgd->InitGeneralDlg(hDlg);
                    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pcgd);
                    return TRUE;
                }
            }

            break;
            
        case WM_DESTROY:
            if (pcgd)
            {
                SetWindowLongPtr(hDlg, DWLP_USER, NULL);
                delete pcgd;
            }
            break;

        default:
            if (pcgd)
                return pcgd->WndProc(hDlg, message, wParam, lParam);
            break;
    }

    return FALSE;
}


/*--------------------------------------------------------------------------*
 *--------------------------------------------------------------------------*/
INT_PTR CALLBACK AskDynaCDSProc(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    int *pTemp;

    switch (msg)
    {
    case WM_INITDIALOG:
        if ((pTemp = (int *)lp) != NULL)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pTemp);
            CheckDlgButton(hDlg, (*pTemp & DCDSF_DYNA)?
                IDC_YESDYNA : IDC_NODYNA, BST_CHECKED);
        }
        else
            EndDialog(hDlg, -1);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wp, lp))
        {
        case IDOK:
            if ((pTemp = (int *)GetWindowLongPtr(hDlg, DWLP_USER)) != NULL)
            {
                *pTemp = IsDlgButtonChecked(hDlg, IDC_YESDYNA)? DCDSF_DYNA : 0;

                if (!IsDlgButtonChecked(hDlg, IDC_SHUTUP))
                    *pTemp |= DCDSF_ASK;

                SetDisplayCPLPreference(REGSTR_VAL_DYNASETTINGSCHANGE, *pTemp);
            }

            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


int  AskDynaCDS(HWND hOwner)
{
    int val = GetDynaCDSPreference();

    if (val & DCDSF_ASK)
    {
        switch (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_ASKDYNACDS),
            hOwner, AskDynaCDSProc, (LPARAM)(int *)&val))
        {
        case 0:         // user cancelled
            return -1;

        case -1:        // dialog could not be displayed
            val = DCDSF_NO;
            break;
        }
    }

    return ((val & DCDSF_DYNA) == DCDSF_DYNA);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\guids.cpp ===
/*****************************************************************************\
    FILE: guids.cpp

    DESCRIPTION:
        This file contains GUIDs that we couldn't get from the public headers
    for one reason or another.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/


#define INITGUID
#include "guids.h"

#include "priv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\fontfix.h ===
/*****************************************************************************\
    FILE: fontfix.h

    DESCRIPTION:
        This file will implement an API: FixFontsOnLanguageChange().
    The USER32 or Regional Settings code should own this API.  The fact that it's
    in the shell is a hack and it should be moved to USER32.  This font will
    be called when the MUI language changes so the fonts in the system metrics
    can be changed to valid values for the language.

    This API should be called in three cases:
    a. When the user changes the language via the Regional Settings CPL UI.
    b. During a user login, USER32 should see if the language changed and
       call this API.  This will handle the case where admins change the
       language via login screens and reboot.  This is not currently implemented.
    c. The language is changed via some other method (admin login scripts most likely)
       and the user opens the display CPL.  This method is a hack, especially
       since (b) isn't implemented.

    Contacts: EdwardP - International Font PM.

    Sankar  ?/??/???? - Created for Win2k or before in desk.cpl.
    BryanSt 3/24/2000 - Make to be modular so it can be moved back into USER32.
                        Made the code more robust.  Removed creating custom appearance
                        schemes in order to be compatible with new .theme and
                        .msstyles support.

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FONTFIX_H
#define _FONTFIX_H



/////////////////////////////////////////////////////////////////////
// String Constants
/////////////////////////////////////////////////////////////////////
#define SYSTEM_LOCALE_CHARSET  0  //The first item in the array is always system locale charset.




/////////////////////////////////////////////////////////////////////
// Data Structures
/////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////
// Public Function
/////////////////////////////////////////////////////////////////////

// This API is used to fix fonts in case the language changed and we need to fix the CHARSET.
STDAPI FixFontsOnLanguageChange(void);

// These are used to filter out fonts not compatible with the current language.
int CALLBACK Font_EnumValidCharsets(LPENUMLOGFONTEX lpelf, LPNEWTEXTMETRIC lpntm, DWORD Type, LPARAM lData);
void Font_GetCurrentCharsets(UINT uiCharsets[], int iCount);
void Font_GetUniqueCharsets(UINT uiCharsets[], UINT uiUniqueCharsets[], int iMaxCount, int *piCountUniqueCharsets);




#endif // _FONTFIX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\fontfix.cpp ===
/*****************************************************************************\
    FILE: fontfix.cpp

    DESCRIPTION:
        This file will implement an API: FixFontsOnLanguageChange().
    The USER32 or Regional Settings code should own this API.  The fact that it's
    in the shell is a hack and it should be moved to USER32.  This font will
    be called when the MUI language changes so the fonts in the system metrics
    can be changed to valid values for the language.

    Contacts: EdwardP - International Font PM.

    Sankar  ?/??/???? - Created for Win2k or before in desk.cpl.
    BryanSt 3/24/2000 - Make to be modular so it can be moved back into USER32.
                        Made the code more robust.  Removed creating custom appearance
                        schemes in order to be compatible with new .theme and
                        .msstyles support.

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "AdvAppearPg.h"
#include "fontfix.h"



#define SZ_DEFAULT_FONT             TEXT("Tahoma")


/////////////////////////////////////////////////////////////////////
// Private Functions
/////////////////////////////////////////////////////////////////////


BOOL FontFix_ReadCharsets(UINT uiCharsets[], int iCount)
{
    HKEY    hkAppearance;
    BOOL    fSuccess = FALSE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_APPEARANCE, 0, KEY_READ, &hkAppearance) == ERROR_SUCCESS)
    {
        DWORD dwType = REG_BINARY;
        DWORD dwSize = iCount * sizeof(UINT);

        if (RegQueryValueEx(hkAppearance, SZ_REGVALUE_RECENTFOURCHARSETS, NULL, &dwType, (LPBYTE)uiCharsets, &dwSize) == ERROR_SUCCESS)
            fSuccess = TRUE;

        RegCloseKey(hkAppearance);
    }

    return fSuccess;
}

BOOL FontFix_SaveCharsets(UINT uiCharsets[], int iCount)
{
    HKEY    hkAppearance;
    BOOL    fSuccess = FALSE;
    
    if(RegCreateKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_APPEARANCE, 0, TEXT(""), 0, KEY_WRITE, NULL, &hkAppearance, NULL) == ERROR_SUCCESS)
    {
        if(RegSetValueEx(hkAppearance, SZ_REGVALUE_RECENTFOURCHARSETS, 0, REG_BINARY, (LPBYTE)uiCharsets, iCount * sizeof(UINT)) == ERROR_SUCCESS)
            fSuccess = TRUE;
            
        RegCloseKey(hkAppearance);
    }

    return fSuccess;
}



void FontFix_GetDefaultFontName(LPTSTR pszDefFontName, DWORD cchSize)
{
    HKEY    hkDefFont;

    //Value is not there in the registry; Use "Tahoma" as the default name.
    StringCchCopy(pszDefFontName, cchSize, SZ_DEFAULT_FONT);

    // Read the "DefaultFontName" to be used.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SZ_APPEARANCE_SCHEMES,
                     0,
                     KEY_READ,
                     &hkDefFont) == ERROR_SUCCESS) 
    {
        DWORD dwType = REG_SZ;
        DWORD cbSize = (cchSize * sizeof(pszDefFontName[0]));
        
        RegQueryValueEx(hkDefFont,
                        SZ_REGVALUE_DEFAULTFONTNAME,
                        NULL,
                        &dwType,
                        (LPBYTE) pszDefFontName,
                        &cbSize);

        RegCloseKey(hkDefFont);
    }
}


BOOL FontFix_DoesFontSupportAllCharsets(HDC hdc, LPLOGFONT plf, UINT uiUniqueCharsets[], int iCountUniqueCharsets)
{
    int j;
    
    //The given font supports the system charset; Let's check if it supports the other charsets
    for (j = 0; j < iCountUniqueCharsets; j++)
    {
        plf->lfCharSet = (BYTE)uiUniqueCharsets[j];  //Let's try the next charset in the array.
        if (EnumFontFamiliesEx(hdc, plf, (FONTENUMPROC)Font_EnumValidCharsets, (LPARAM)0, 0) != 0)
        {
            // EnumFontFamiliesEx would have returned a zero if Font_EnumValidCharsets was called
            // even once. In other words, it returned a non-zero because not even a single font existed
            // that supported the given charset.
            return FALSE;
        }
    }

    return TRUE; //Yes this font supports all the charsets we are interested in.
}


// Given an array of fonts and an array of unique charsets, this function checks if the fonts 
// support ALL these charsets.
// Returns TRUE if these fonts support all the charsets.
// In all other cases, this function will return TRUE. If the fonts need to be changed to support
// the given charsets, this function does all those changes.
//
//  lpszName is the name of the scheme to be used in the MessageBox that appears if fSilent is FALSE.
BOOL FontFix_CheckFontsCharsets(LOGFONT lfUIFonts[], int iCountFonts, 
                        UINT uiCurUniqueCharsets[], int iCountCurUniqueCharsets, 
                        BOOL *pfDirty, LPCTSTR lpszName)
{
    int i;
    TCHAR   szDefaultFontFaceName[LF_FACESIZE];
    HDC     hdc;

    *pfDirty   = FALSE; //Assume that this scheme does not need to be saved.

    //Read the default font name from the registry (Mostly: Tahoma)
    FontFix_GetDefaultFontName(szDefaultFontFaceName, ARRAYSIZE(szDefaultFontFaceName));

    hdc = GetDC(NULL);

    //Check to see of the fonts support the system charset
    for (i = 0; i < iCountFonts; i++)
    {
        //Save the current charset because FontFix_DoesFontSupportAllCharsets() destroys this field.
        BYTE bCurCharset = lfUIFonts[i].lfCharSet;  

        if (!FontFix_DoesFontSupportAllCharsets(hdc, &lfUIFonts[i], uiCurUniqueCharsets, iCountCurUniqueCharsets))
        {
            //Copy the default fontname to the font.
            StringCchCopy(lfUIFonts[i].lfFaceName, ARRAYSIZE(lfUIFonts[i].lfFaceName), szDefaultFontFaceName);
            *pfDirty = TRUE;  //This scheme needs to be saved.
        }

        //Restore the charset because FontFix_DoesFontSupportAllCharsets() destroyed this field.
        lfUIFonts[i].lfCharSet = bCurCharset; // Restore the current charset.

        // Warning #1: The IconTitle font's Charset must always match the System Locale charset.
        // Warning #2: FoxPro's tooltips code expects the Status font's charset to the the System 
        // Locale's charset.
        // As per intl guys, we set the charset of all the UI fonts to SYSTEM_LOCALE_CHARSET.
        if (lfUIFonts[i].lfCharSet != uiCurUniqueCharsets[SYSTEM_LOCALE_CHARSET])
        {
            lfUIFonts[i].lfCharSet = (BYTE)uiCurUniqueCharsets[SYSTEM_LOCALE_CHARSET];
            *pfDirty = TRUE;
        }
    }  //For loop 

    ReleaseDC(NULL, hdc);

    return TRUE;  //The fonts have been modified as required.
}





void FontFix_GetUIFonts(NONCLIENTMETRICS *pncm, LOGFONT lfUIFonts[])
{
    pncm->cbSize = sizeof(NONCLIENTMETRICS);
    ClassicSystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS),
                                (void far *)(LPNONCLIENTMETRICS)pncm, FALSE);

    // Read the icon title font directly into the font array.
    ClassicSystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT),
                (void far *)(LPLOGFONT)&(lfUIFonts[FONT_ICONTITLE]), FALSE);
                
    //Make a copy of the ncm fonts into fonts array.
    LF32toLF(&(pncm->lfCaptionFont), &(lfUIFonts[FONT_CAPTION]));
    LF32toLF(&(pncm->lfSmCaptionFont), &(lfUIFonts[FONT_SMCAPTION]));
    LF32toLF(&(pncm->lfMenuFont), &(lfUIFonts[FONT_MENU]));
    LF32toLF(&(pncm->lfStatusFont), &(lfUIFonts[FONT_STATUS]));
    LF32toLF(&(pncm->lfMessageFont), &(lfUIFonts[FONT_MSGBOX]));
}


void FontFix_SetUIFonts(NONCLIENTMETRICS *pncm, LOGFONT lfUIFonts[])
{
    //Copy all fonts back into the ncm structure.
    LFtoLF32(&(lfUIFonts[FONT_CAPTION]), &(pncm->lfCaptionFont));
    LFtoLF32(&(lfUIFonts[FONT_SMCAPTION]), &(pncm->lfSmCaptionFont));
    LFtoLF32(&(lfUIFonts[FONT_MENU]), &(pncm->lfMenuFont));
    LFtoLF32(&(lfUIFonts[FONT_STATUS]), &(pncm->lfStatusFont));
    LFtoLF32(&(lfUIFonts[FONT_MSGBOX]), &(pncm->lfMessageFont));

    // FEATURE: Do we want a WININICHANGE HERE?
    // NOTE: We want to set a SPIF_SENDWININICHANGE, because we want to refresh.
    // Note we don't do this async.  This should only happen when the user changes MUI languages,
    // and in that case, perf can suck.
    TraceMsg(TF_GENERAL, "desk.cpl: Calling SPI_SETNONCLIENTMETRICS");
    ClassicSystemParametersInfo(SPI_SETNONCLIENTMETRICS, sizeof(*pncm), (void far *)(LPNONCLIENTMETRICS)pncm, (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE));

    TraceMsg(TF_GENERAL,"desk.cpl: Calling SPI_SETICONTITLELOGFONT");
    ClassicSystemParametersInfo(SPI_SETICONTITLELOGFONT, sizeof(LOGFONT),
            (void far *)(LPLOGFONT)&lfUIFonts[FONT_ICONTITLE], (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE));
}


// ------------------------ manage system settings --------------------------

//  Given the Locale ID, this returns the corresponding charset
UINT GetCharsetFromLCID(LCID lcid)
{
    TCHAR szData[6+1]; // 6 chars are max allowed for this lctype
    UINT uiRet;
    DWORD dwError = 0;

    if (GetLocaleInfo(lcid, LOCALE_IDEFAULTANSICODEPAGE, szData, ARRAYSIZE(szData)) > 0)
    {
        UINT uiCp = (UINT)StrToInt(szData);
        CHARSETINFO csinfo = {0};

        if (!TranslateCharsetInfo((DWORD *)IntToPtr(uiCp), &csinfo, TCI_SRCCODEPAGE))
        {
            dwError = GetLastError();
            uiRet = DEFAULT_CHARSET;
        }
        else
        {
            uiRet = csinfo.ciCharset;
        }
    }
    else
    {
        // at worst non penalty for charset
        dwError = GetLastError();
        uiRet = DEFAULT_CHARSET;
    }

    return uiRet;
}


int FontFix_CompareUniqueCharsets(UINT uiCharset1[], int iCount1, UINT uiCharset2[], int iCount2)
{
    if (iCount1 == iCount2)
    {
        int i, j;
        
        // The first items in the array is SYSTEM CHAR SET; It must match because system locale's
        // charset is always used by the Icon Title font; Icon Title font's charset is used by 
        // comctl32 to do A/W conversion. In order that all ANSI applications run correctly, 
        // the icon charset must always match current system locale.
        if (uiCharset1[SYSTEM_LOCALE_CHARSET] != uiCharset2[SYSTEM_LOCALE_CHARSET])
            return -1;

        //Now see if the arrays have the same elements.
        ASSERT(SYSTEM_LOCALE_CHARSET == 0);
        
        for (i = SYSTEM_LOCALE_CHARSET+1; i < iCount1; i++)
        {
            for (j = SYSTEM_LOCALE_CHARSET+1; j < iCount2; j++)
            {
                if(uiCharset1[i] == uiCharset2[j])
                    break;
            }
            if (j == iCount2)
                return -1;   // uiCharset1[i] is not found in the second array.
        }
    }
    
    return (iCount1 - iCount2); // Both the arrays have the same Charsets
}


// Given the Language ID, this gets the charset.
UINT GetCharsetFromLang(LANGID wLang)
{
    return(GetCharsetFromLCID(MAKELCID(wLang, SORT_DEFAULT)));
}







/////////////////////////////////////////////////////////////////////
// Public Functions
/////////////////////////////////////////////////////////////////////
void Font_GetCurrentCharsets(UINT uiCharsets[], int iCount)
{
    LCID lcid;
    LANGID langID;

    ASSERT(iCount == MAX_CHARSETS);

    // Get all the four charsets we are interested in.
    uiCharsets[0] = GetCharsetFromLCID(lcid = GetSystemDefaultLCID());
    AssertMsg(lcid, TEXT("GetSystemDefaultLCID() failed with %d"), GetLastError());

    uiCharsets[1] = GetCharsetFromLCID(lcid = GetUserDefaultLCID());
    AssertMsg(lcid, TEXT("GetUserDefaultLCID() failed with %d"), GetLastError());

    uiCharsets[2] = GetCharsetFromLang(langID = GetSystemDefaultUILanguage());
    AssertMsg(langID, TEXT("GetSystemDefaultUILanguage() failed with %d"), GetLastError());

    uiCharsets[3] = GetCharsetFromLang(langID = GetUserDefaultUILanguage());
    AssertMsg(langID, TEXT("GetUserDefaultUILanguage() failed with %d"), GetLastError());
}


void Font_GetUniqueCharsets(UINT uiCharsets[], UINT uiUniqueCharsets[], int iMaxCount, int *piCountUniqueCharsets)
{
    int i, j;
    
    // Find the unique Charsets;
    *piCountUniqueCharsets = 0;
    for (i = 0; i < iMaxCount; i++)
    {
        uiUniqueCharsets[i] = DEFAULT_CHARSET; //Initialize it to default charset.

        for (j = 0; j < *piCountUniqueCharsets; j++)
        {
            if (uiUniqueCharsets[j] == uiCharsets[i])
                break; // This Charset is already in the array
        }

        if (j == *piCountUniqueCharsets)
        {
            // Yes! It is a unique char set; Save it!
            uiUniqueCharsets[j] = uiCharsets[i];
            (*piCountUniqueCharsets)++; //One more unique char set found.
        }
    }
}



int CALLBACK Font_EnumValidCharsets(LPENUMLOGFONTEX lpelf, LPNEWTEXTMETRIC lpntm, DWORD Type, LPARAM lData)
{
    // The purpose of this function is to determine if a font supports a particular charset;
    // If this callback gets called even once, then that means that this font supports the given
    // charset. There is no need to enumerate all the other styles. We immediately return zero to
    // stop the enumeration. Since we return zero, the EnumFontFamiliesEx() also returns zero in 
    // this case and that return value is used to determine if a given font supports a given
    // charset.


    return 0;
}


HRESULT FontFix_FixNonClientFonts(LOGFONT lfUIFonts[])
{
    UINT    uiCurCharsets[MAX_CHARSETS];
    UINT    uiRegCharsets[MAX_CHARSETS];
    UINT    uiCurUniqueCharsets[MAX_CHARSETS];
    int     iCountCurUniqueCharsets = 0;
    UINT    uiRegUniqueCharsets[MAX_CHARSETS];
    int     iCountRegUniqueCharsets = 0;
    BOOL    fRegCharsetsValid = FALSE;
    HRESULT hr = S_OK;
    
    // Get the current four charsets from system.
    Font_GetCurrentCharsets(uiCurCharsets, MAX_CHARSETS);
    //Get the charsets saved in the registry.
    fRegCharsetsValid = FontFix_ReadCharsets(uiRegCharsets, MAX_CHARSETS);

    // Get rid of the duplicate charsets and get only the unique Charsets from these arrays.
    Font_GetUniqueCharsets(uiCurCharsets, uiCurUniqueCharsets, MAX_CHARSETS, &iCountCurUniqueCharsets);
    if (fRegCharsetsValid)
        Font_GetUniqueCharsets(uiRegCharsets, uiRegUniqueCharsets, MAX_CHARSETS, &iCountRegUniqueCharsets);

    // Check if these two arrays have the same charsets.
    if (!fRegCharsetsValid || !(FontFix_CompareUniqueCharsets(uiCurUniqueCharsets, iCountCurUniqueCharsets, uiRegUniqueCharsets, iCountRegUniqueCharsets) == 0))
    {
        BOOL fDirty = FALSE;

        FontFix_CheckFontsCharsets(lfUIFonts, NUM_FONTS, uiCurUniqueCharsets, iCountCurUniqueCharsets, &fDirty, TEXT(""));

        // Save the cur charsets into the registry.
        FontFix_SaveCharsets(uiCurCharsets, MAX_CHARSETS);

        hr = (fDirty ? S_OK : S_FALSE);
    }
    else
    {
        hr = S_FALSE;  // The charsets are the same; Nothing to do!
    }

    return hr; //Yes! We had to do some updates in connection with charsets and fonts.
}


//------------------------------------------------------------------------------------------------
//
// This is the function that needs to be called everytime a locale changes (or could have changed).
//
// It does the following:
//  1. It checks if any of the four the charset settings has changed.
//  2. If some charset has changed, it makes the corresponding changes in the 6 UI fonts.
//  3. If a scheme is selected, it checks to see if the fonts support the new charsets and if not
//     changes the fonts and/or charsets and saves the scheme under a new name.
//  4. Saves the new charsets in the registry sothat we don't have to do the same everytime this
//     function is called.
//
//  NOTE: This is a private export from desk.cpl. This is called in two places:
//  1. from regional control panel whenever it is run AND whenever it changes some locale.
//  2. from desk.cpl itself whenever "Appearance" tab is created. This is required because it is
// possible that an admin changes a system locale and then someother user logs-in. For this user
// the locale changes will cause font changes only when he runs Regional options or Appearance tab.
// The only other alternative would be to call this entry point whenever a user logs on, which will
// be a boot time perf hit.
//
//-------------------------------------------------------------------------------------------------
STDAPI FixFontsOnLanguageChange(void)
{
    NONCLIENTMETRICS ncm;
    LOGFONT lfUIFonts[NUM_FONTS];
    
    // Get all the 6 UI fonts.
    FontFix_GetUIFonts(&ncm, lfUIFonts);

    if (S_OK == FontFix_FixNonClientFonts(lfUIFonts))
    {
        FontFix_SetUIFonts(&ncm, lfUIFonts);
    }

    return S_OK; //Yes! We had to do some updates in connection with charsets and fonts.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\makefile.inc ===
resource.rc : $(PROJECT_ROOT)\lib\$(O)\Theme.tlb $(SELFREGNAME)

$(SELFREGNAME) : selfreg.inx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
        $(CLEANINF) $*.cln $@
        del $*.cln
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\ntreg.cpp ===
/**************************************************************************\
* Module Name: ntreg.cpp
*
* CRegistrySettings class
*
*  This class handles getting registry information for display driver
*  information.
*
* Copyright (c) Microsoft Corp.  1992-1998 All Rights Reserved
*
\**************************************************************************/

#include "priv.h"
#include <tchar.h>
#include "ntreg.hxx"
#include <devguid.h>

//
// CRegistrySettings constructor
//

CRegistrySettings::CRegistrySettings(LPTSTR pstrDeviceKey)
    : _hkVideoReg(NULL)
    , _pszDrvName(NULL)
    , _pszKeyName(NULL)
    , _pszDeviceInstanceId(NULL)
    , _dwDevInst(0)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR pszPath;
    HKEY hkeyCommon, hkeyDriver;
    DWORD cb;
    LPTSTR pszName = NULL;
    LPTSTR pszEnd;

    ASSERT(lstrlen(pstrDeviceKey) < MAX_PATH);
    
    //
    // Copy the data to local buffer.
    //

    StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), pstrDeviceKey);

    //
    // Initialize the device instance id
    // 
    
    InitDeviceInstanceID(szBuffer);

    //
    // At this point, szBuffer has something like:
    //  \REGISTRY\Machine\System\ControlSet001\...
    //
    // To use the Win32 registry calls, we have to strip off the \REGISTRY
    // and convert \Machine to HKEY_LOCAL_MACHINE
    //

    pszPath = SubStrEnd(SZ_REGISTRYMACHINE, szBuffer);

    //
    // Try to open the registry key
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pszPath,
                     0,
                     KEY_READ,
                     &_hkVideoReg) != ERROR_SUCCESS) {

        _hkVideoReg = 0;
    }

    //
    // Go to the video subkey
    //

    pszEnd = pszPath + lstrlen(pszPath);

    while (pszEnd != pszPath && *pszEnd != TEXT('\\')) {

        pszEnd--;
    }

    *pszEnd = UNICODE_NULL;

    StringCchCat(pszPath, ARRAYSIZE(szBuffer) - (pszEnd - szBuffer), SZ_COMMON_SUBKEY);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pszPath,
                     0,
                     KEY_READ,
                     &hkeyCommon) == ERROR_SUCCESS) {

        cb = sizeof(szBuffer);
        ZeroMemory(szBuffer, cb);

        if (RegQueryValueEx(hkeyCommon,
                            SZ_SERVICE,
                            NULL,
                            NULL,
                            (LPBYTE)szBuffer,
                            &cb) == ERROR_SUCCESS) {

            //
            // Save the key name
            //

            DWORD cchKeyName = (lstrlen(szBuffer) + 1);
            _pszKeyName = (LPTSTR)LocalAlloc(LPTR, cchKeyName * sizeof(TCHAR));

            if (_pszKeyName != NULL) {

                StringCchCopy(_pszKeyName, cchKeyName, szBuffer);
            
                StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%s%s"), SZ_SERVICES_PATH, _pszKeyName);

                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 szBuffer,
                                 0,
                                 KEY_READ,
                                 &hkeyDriver) == ERROR_SUCCESS) {
        
                    cb = sizeof(szBuffer);
                    ZeroMemory(szBuffer, cb);

                    if (RegQueryValueEx(hkeyDriver,
                                        L"ImagePath",
                                        NULL,
                                        NULL,
                                        (LPBYTE)szBuffer,
                                        &cb) == ERROR_SUCCESS) {
        
                        //
                        // This is a binary.
                        // Extract the name, which will be of the form ...\driver.sys
                        //
        
                        LPTSTR pszDriver, pszDriverEnd;
    
                        pszDriver = szBuffer;
                        pszDriverEnd = pszDriver + lstrlen(pszDriver);
    
                        while(pszDriverEnd != pszDriver &&
                              *pszDriverEnd != TEXT('.')) {
                            pszDriverEnd--;
                        }
    
                        *pszDriverEnd = UNICODE_NULL;
    
                        while(pszDriverEnd != pszDriver &&
                              *pszDriverEnd != TEXT('\\')) {
                            pszDriverEnd--;
                        }
    
                        //
                        // If pszDriver and pszDriverEnd are different, we now
                        // have the driver name.
                        //
    
                        if (pszDriverEnd > pszDriver) {
                            
                            pszDriverEnd++;
                            pszName = pszDriverEnd;
    
                        }
                    }
        
                    RegCloseKey(hkeyDriver);
                }
            
                if (!pszName) {

                    //
                    // Something failed trying to get the binary name.just get the device name
                    //

                    _pszDrvName = _pszKeyName;

                } else {

                    DWORD cchDrvName = lstrlen(pszName) + 1;
                    _pszDrvName = (LPTSTR)LocalAlloc(LPTR, cchDrvName * sizeof(TCHAR));

                    if (_pszDrvName != NULL) {

                        StringCchCopy(_pszDrvName, cchDrvName, pszName);

                    }
                }
            }
        }

        RegCloseKey(hkeyCommon);
    }
}

//
// CRegistrySettings destructor
//

CRegistrySettings::~CRegistrySettings() 
{
    //
    // Close the registry
    //

    if (_hkVideoReg) {
        RegCloseKey(_hkVideoReg);
    }

    //
    // Free the strings
    //
    if (_pszKeyName) {
        LocalFree(_pszKeyName);
    }

    if ((_pszKeyName != _pszDrvName) && _pszDrvName) {
        LocalFree(_pszDrvName);
    }

    if(_pszDeviceInstanceId) {
        LocalFree(_pszDeviceInstanceId);
    }
}


//
// Method to get the hardware information fields.
//

VOID
CRegistrySettings::GetHardwareInformation(
    PDISPLAY_REGISTRY_HARDWARE_INFO pInfo)
{

    DWORD cb, dwType;
    DWORD i;
    LONG lRet;

    LPWSTR pKeyNames[5] = {
        L"HardwareInformation.MemorySize",
        L"HardwareInformation.ChipType",
        L"HardwareInformation.DacType",
        L"HardwareInformation.AdapterString",
        L"HardwareInformation.BiosString"
    };

    ZeroMemory(pInfo, sizeof(*pInfo));

    //
    // Query each entry one after the other.
    //

    for (i = 0; i < 5; i++) {

        //
        // query the size of the string
        //

        cb = sizeof(pInfo->MemSize);
        lRet = RegQueryValueExW(_hkVideoReg,
                                pKeyNames[i],
                                NULL,
                                &dwType,
                                NULL,
                                &cb);

        if (lRet == ERROR_SUCCESS) {

            if (i == 0) {

                ULONG mem;

                cb = sizeof(mem);

                if (RegQueryValueExW(_hkVideoReg,
                                 pKeyNames[i],
                                 NULL,
                                 &dwType,
                                 (PUCHAR) (&mem),
                                 &cb) == ERROR_SUCCESS)
                {

                    //
                    // If we queried the memory size, we actually have
                    // a DWORD.  Transform the DWORD to a string
                    //

                    // Divide down to Ks

                    mem =  mem >> 10;

                    // if a MB multiple, divide again.

                    if ((mem & 0x3FF) != 0) {

                        StringCchPrintf((LPWSTR)pInfo, ARRAYSIZE(pInfo->MemSize), L"%d KB", mem );

                    } else {

                        StringCchPrintf((LPWSTR)pInfo, ARRAYSIZE(pInfo->MemSize), L"%d MB", mem >> 10 );

                    }
                }
                else
                {
                    goto Default;
                }

            } else {

                cb = sizeof(pInfo->MemSize);

                //
                // get the string
                //

                if (RegQueryValueExW(_hkVideoReg,
                                 pKeyNames[i],
                                 NULL,
                                 &dwType,
                                 (LPBYTE) pInfo,
                                 &cb) != ERROR_SUCCESS)
                {
                    goto Default;
                }
            }
        }
        else
        {
            //
            // Put in the default string
            //
Default:
            LoadString(HINST_THISDLL,
                       IDS_UNAVAILABLE,
                       (LPWSTR)pInfo,
                       ARRAYSIZE(pInfo->MemSize));
        }

        pInfo = (PDISPLAY_REGISTRY_HARDWARE_INFO)((PUCHAR)pInfo + sizeof(pInfo->MemSize));
    }
}


VOID CRegistrySettings::InitDeviceInstanceID(
    LPTSTR pstrDeviceKey
    ) 
{
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE ;
    SP_DEVINFO_DATA DevInfoData;
    ULONG InstanceIDSize = 0;
    BOOL bSuccess = FALSE;
    LPWSTR pwInterfaceName = NULL;
    LPWSTR pwInstanceID = NULL;

    ASSERT (pstrDeviceKey != NULL);
    ASSERT (_pszDeviceInstanceId == NULL);

    if (AllocAndReadInterfaceName(pstrDeviceKey, &pwInterfaceName)) {

        bSuccess = GetDevInfoDataFromInterfaceName(pwInterfaceName,
                                                   &hDevInfo,
                                                   &DevInfoData);
        if (bSuccess) {

            InstanceIDSize = 0;

            bSuccess = 

                ((CM_Get_Device_ID_Size(&InstanceIDSize, 
                                        DevInfoData.DevInst, 
                                        0) == CR_SUCCESS) &&

                 ((_pszDeviceInstanceId = (LPTSTR)LocalAlloc(LPTR, 
                     (InstanceIDSize + 1) * sizeof(TCHAR))) != NULL) &&

                 (CM_Get_Device_ID(DevInfoData.DevInst, 
                                   _pszDeviceInstanceId,
                                   InstanceIDSize,
                                   0) == CR_SUCCESS));

            if (bSuccess) {

                _dwDevInst = DevInfoData.DevInst;
            
            } else {

                //
                // Clean-up
                //

                if (NULL != _pszDeviceInstanceId) {
                    LocalFree(_pszDeviceInstanceId);
                    _pszDeviceInstanceId = NULL;
                }
            }

            SetupDiDestroyDeviceInfoList(hDevInfo);
        }

        LocalFree(pwInterfaceName);
    }

    if ((!bSuccess) &&
        AllocAndReadInstanceID(pstrDeviceKey, &pwInstanceID)) {

        _pszDeviceInstanceId = pwInstanceID;
    }

} // InitDeviceInstanceID


BOOL
CRegistrySettings::GetDevInfoDataFromInterfaceName(
    IN  LPWSTR pwInterfaceName,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfoData
    )

/*

    Note: If this function retuns success, the caller is responsible
          to destroy the device info list returned in phDevInfo

*/

{
    LPWSTR pwDevicePath = NULL;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DevInfoData;
    SP_DEVICE_INTERFACE_DATA InterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pInterfaceDetailData = NULL;
    DWORD InterfaceIndex = 0;
    DWORD InterfaceSize = 0;
    BOOL bMatch = FALSE;

    ASSERT (pwInterfaceName != NULL);
    ASSERT (phDevInfo != NULL);
    ASSERT (pDevInfoData != NULL);

    //
    // Enumerate all display adapter interfaces
    //

    hDevInfo = SetupDiGetClassDevs(&GUID_DISPLAY_ADAPTER_INTERFACE,
                                   NULL,
                                   NULL,
                                   DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (hDevInfo == INVALID_HANDLE_VALUE) {
        goto Cleanup;
    }

    InterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
    while (SetupDiEnumDeviceInterfaces(hDevInfo,
                                       NULL,
                                       &GUID_DISPLAY_ADAPTER_INTERFACE,
                                       InterfaceIndex,
                                       &InterfaceData)) {

        //
        // Get the required size for the interface
        //

        InterfaceSize = 0;
        SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                        &InterfaceData,
                                        NULL,
                                        0,
                                        &InterfaceSize,
                                        NULL);

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto Cleanup;
        }

        //
        // Alloc memory for the interface
        //

        pInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)
            LocalAlloc(LPTR, InterfaceSize);
        if (pInterfaceDetailData == NULL)
            goto Cleanup;

        //
        // Get the interface
        //

        pInterfaceDetailData->cbSize =
            sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                            &InterfaceData,
                                            pInterfaceDetailData,
                                            InterfaceSize,
                                            &InterfaceSize,
                                            &DevInfoData)) {

            //
            // Is the InterfaceName the same as the DevicePath?
            //

            pwDevicePath = pInterfaceDetailData->DevicePath;

            //
            // The first 4 characters of the interface name are different
            // between user mode and kernel mode (e.g. "\\?\" vs "\\.\")
            // Therefore, ignore them.
            //

            bMatch = (_wcsnicmp(pwInterfaceName + 4,
                                pwDevicePath + 4,
                                wcslen(pwInterfaceName + 4)) == 0);

            if (bMatch) {

                //
                // We found the device
                //

                *phDevInfo = hDevInfo;
                CopyMemory(pDevInfoData, &DevInfoData, sizeof(*pDevInfoData));

                break;
            }
        }

        //
        // Clean-up
        //

        LocalFree(pInterfaceDetailData);
        pInterfaceDetailData = NULL;

        //
        // Next interface ...
        //

        InterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        ++InterfaceIndex;
    }

Cleanup:

    if (pInterfaceDetailData != NULL) {
        LocalFree(pInterfaceDetailData);
    }

    //
    // Upon success, the caller is responsible to destroy the list
    //

    if (!bMatch && (hDevInfo != INVALID_HANDLE_VALUE)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    return bMatch;
}


HKEY
CRegistrySettings::OpenDrvRegKey()
{
    HKEY hkDriver = (HKEY)INVALID_HANDLE_VALUE;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA did;
    DWORD index = 0;

    if (_dwDevInst == 0) {
        goto Fallout;
    }

    hDevInfo = SetupDiGetClassDevs((LPGUID) &GUID_DEVCLASS_DISPLAY,
                                   NULL,
                                   NULL,
                                   0);
    
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        goto Fallout;
    }

    ZeroMemory(&did, sizeof(did));
    did.cbSize = sizeof(did);

    while (SetupDiEnumDeviceInfo(hDevInfo, index, &did)) {
    
        if (did.DevInst == _dwDevInst) {

            hkDriver = SetupDiOpenDevRegKey(hDevInfo,
                                            &did,
                                            DICS_FLAG_GLOBAL,
                                            0,
                                            DIREG_DRV ,
                                            KEY_READ);
            break;
        }

        did.cbSize = sizeof(SP_DEVINFO_DATA);
        index++;
    }

Fallout:
    
    if (hDevInfo != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    return hkDriver;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\previewsm.h ===
/*****************************************************************************\
    FILE: PreviewSM.h

    DESCRIPTION:
        This code will display a preview of system metrics.
    NOTE: This code will >hand< draw all the window controls, so if
    windows changes the way the windows controls are draw, this code
    needs to be manually updated.  This is an issue for skinning.

    BryanSt 4/4/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _PREVIEWSYSTEMMETRICS_H
#define _PREVIEWSYSTEMMETRICS_H

#include "regutil.h"


#define PREVIEWSM_CLASSA        "PreviewSystemMetrics"
#define PREVIEWSM_CLASS         TEXT(PREVIEWSM_CLASSA)



#define FONT_NONE   -1
#define FONT_CAPTION    0
#define FONT_SMCAPTION  1
#define FONT_MENU   2
#define FONT_ICONTITLE  3
#define FONT_STATUS 4
#define FONT_MSGBOX 5

#define NUM_FONTS   6
typedef struct {
    HFONT hfont;
    LOGFONT lf;
} LOOK_FONT;
extern LOOK_FONT g_fonts[];

#define COLOR_NONE  -1
extern COLORREF g_rgb[];extern HBRUSH g_brushes[];
extern HPALETTE g_hpal3D;

#define SIZE_NONE   -1
#define SIZE_FRAME  0
#define SIZE_SCROLL 1
#define SIZE_CAPTION    2
#define SIZE_SMCAPTION  3
#define SIZE_MENU   4
#define SIZE_DXICON     5
#define SIZE_DYICON     6
#define SIZE_ICON       7
#define SIZE_SMICON     8

#define NUM_SIZES   9

typedef struct {
    int CurSize;
    int MinSize;
    int MaxSize;
} LOOK_SIZE;
extern LOOK_SIZE g_sizes[];

typedef struct {
    int iMainColor;
    int iSize;
    BOOL fLinkSizeToFont;
    int iTextColor;
    int iFont;
    int iResId;     // id of name in resource (or -1 if duplicate)
    int iBaseElement;   // index of element that this overlaps (or -1)
    int iGradientColor; // index of element for Gradient Caption Bar (or -1)
    RECT rc;
} LOOK_ELEMENT;

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//this order has to match the array order in lookdlg.c
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
enum _ELEMENTS {
    ELEMENT_APPSPACE = 0,
    ELEMENT_DESKTOP,                // 1
    ELEMENT_INACTIVEBORDER,         // 2
    ELEMENT_ACTIVEBORDER,           // 3
    ELEMENT_INACTIVECAPTION,        // 4
    ELEMENT_INACTIVESYSBUT1,        // 5
    ELEMENT_INACTIVESYSBUT2,        // 6
    ELEMENT_ACTIVECAPTION,          // 7
    ELEMENT_ACTIVESYSBUT1,          // 8
    ELEMENT_ACTIVESYSBUT2,          // 9
    ELEMENT_MENUNORMAL,             // 10
    ELEMENT_MENUSELECTED,           // 11
    ELEMENT_MENUDISABLED,           // 12
    ELEMENT_WINDOW,                 // 13
    ELEMENT_MSGBOX,                 // 14
    ELEMENT_MSGBOXCAPTION,          // 15
    ELEMENT_MSGBOXSYSBUT,           // 16
    ELEMENT_SCROLLBAR,              // 17
    ELEMENT_SCROLLUP,               // 18
    ELEMENT_SCROLLDOWN,             // 19
    ELEMENT_BUTTON,                 // 20
    ELEMENT_SMCAPTION,              // 21
    ELEMENT_ICON,                   // 22
    ELEMENT_ICONHORZSPACING,        // 23
    ELEMENT_ICONVERTSPACING,        // 24
    ELEMENT_INFO                    // 25
};
// BOGUS:  need to get a size from somewhere
#define NUM_ELEMENTS ELEMENT_INFO+1

#if 0
// go fix lookdlg.cpp if you decide to add this back in
    ELEMENT_SMICON,
#endif


#define CPI_VGAONLY 0x0001
#define CPI_PALETTEOK   0x0002

typedef struct {
    HWND hwndParent;    // parent for any modal dialogs (choosecolor et al)
    HWND hwndOwner;     // control that owns mini color picker
    COLORREF rgb;
    UINT flags;
    HPALETTE hpal;
} COLORPICK_INFO, FAR * LPCOLORPICK_INFO;

#define WM_RECREATEBITMAP (WM_USER)
extern int cyBorder;
extern int cxBorder;
extern int cyEdge;
extern int cxEdge;

// NOTE: the order in g_elements must match the enum order above
extern LOOK_ELEMENT g_elements[];

BOOL RegisterPreviewSystemMetricClass(HINSTANCE hInst);
BOOL WINAPI ChooseColorMini(LPCOLORPICK_INFO lpcpi);
DWORD FAR PASCAL AdjustLuma(DWORD rgb, int n, BOOL fScale);
BOOL CreateGlobals(void);

HRESULT DrawAppearance(HDC hdc, LPRECT prc, SYSTEMMETRICSALL* psysMet, BOOL fOnlyShowActiveWindow, BOOL fRTL);

extern HDC g_hdcMem;


// Macro to replace MAKEPOINT() since points now have 32 bit x & y
#define LPARAM2POINT( lp, ppt ) \
    ((ppt)->x = (int)(short)LOWORD(lp), (ppt)->y = (int)(short)HIWORD(lp))

#define CCH_MAX_STRING    256
#define CCH_NONE          20        /* ARRAYSIZE( "(None)" ), big enough for German */



#endif // _PREVIEWSYSTEMMETRICS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\previewsm.cpp ===
/*****************************************************************************\
    FILE: PreviewSM.cpp

    DESCRIPTION:
        This code will display a preview of system metrics.
    NOTE: This code will >hand< draw all the window controls, so if
    windows changes the way the windows controls are draw, this code
    needs to be manually updated.  This is an issue for skinning.

    ??????? ?/??/1993    Created
    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "PreviewSM.h"
#include "AdvAppearPg.h"


#define RCZ(element)         g_elements[element].rc

TCHAR g_szActive[CCH_MAX_STRING];
TCHAR g_szInactive[CCH_MAX_STRING];
TCHAR g_szMinimized[CCH_MAX_STRING];
TCHAR g_szIconTitle[CCH_MAX_STRING];
TCHAR g_szNormal[CCH_MAX_STRING];
TCHAR g_szDisabled[CCH_MAX_STRING];
TCHAR g_szSelected[CCH_MAX_STRING];
TCHAR g_szMsgBox[CCH_MAX_STRING];
TCHAR g_szButton[CCH_MAX_STRING];
TCHAR g_szWindowText[CCH_MAX_STRING];
TCHAR g_szMsgBoxText[CCH_MAX_STRING];
TCHAR g_szABC[] = TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");

int cxSize;

HMENU g_hmenuSample;
HBITMAP g_hbmLook = NULL;       // bitmap for the appearance preview
int g_nBitsPixel = 0;   // bits pizel for the appearance preview

HDC g_hdcMem;
HBITMAP g_hbmDefault;
BOOL g_bMirroredOS = FALSE;

int cyBorder;
int cxBorder;
int cyEdge;
int cxEdge;












//===========================
// *** Class Internals & Helpers ***
//===========================
// Note that the rectangles are defined back to front.  So we walk through
// the list backwards, checking PtInRect() until we find a match.
int LookPrev_HitTest(POINT pt)
{
    int i;

    // start with last, don't bother with 0 (desktop)... it's the fallback
    for (i = NUM_ELEMENTS - 1; i > 0; i--)
    {
        if (PtInRect(&RCZ(i), pt))
        {
            break;
        }
    }

    // if the chosen one is really a dupe of another, use the base one
    if (g_elements[i].iBaseElement != -1)
    {
        i = g_elements[i].iBaseElement;
    }

    return i;
}


HRESULT CAdvAppearancePage::_OnNCCreate(HWND hWnd)
{
    DWORD dwWindowStyles = GetWindowLong(hWnd, GWL_STYLE);

    SetWindowLong(hWnd, GWL_STYLE, dwWindowStyles | WS_BORDER);
    dwWindowStyles = GetWindowLong(hWnd,GWL_EXSTYLE);
    SetWindowLong(hWnd, GWL_EXSTYLE, dwWindowStyles | WS_EX_CLIENTEDGE);

    return S_OK;
}


HRESULT CAdvAppearancePage::_OnCreatePreviewSMDlg(LPRECT prc, BOOL fRTL)
{
    cyBorder = ClassicGetSystemMetrics(SM_CYBORDER);
    cxBorder = ClassicGetSystemMetrics(SM_CXBORDER);
    cyEdge = ClassicGetSystemMetrics(SM_CXEDGE);
    cxEdge = ClassicGetSystemMetrics(SM_CYEDGE);

    _InitPreview(prc, fRTL);
    return S_OK;
}


// ----------------------------------------------------------------------------
// create the preview bitmap and collect all of the global, non-changing data
// ----------------------------------------------------------------------------
void CAdvAppearancePage::_InitPreview(LPRECT prc, BOOL fRTL)
{
    RECT rc;
    HDC hdc;

    rc = *prc;
    hdc = GetDC(NULL);
    g_nBitsPixel = GetDeviceCaps(hdc, BITSPIXEL);
    g_hbmLook = CreateCompatibleBitmap(hdc, rc.right - rc.left, rc.bottom - rc.top);
    ReleaseDC(NULL, hdc);

    // Load our display strings.
    LoadString(HINST_THISDLL, IDS_ACTIVE, g_szActive, ARRAYSIZE(g_szActive));
    LoadString(HINST_THISDLL, IDS_INACTIVE, g_szInactive, ARRAYSIZE(g_szInactive));
    LoadString(HINST_THISDLL, IDS_MINIMIZED, g_szMinimized, ARRAYSIZE(g_szMinimized));
    LoadString(HINST_THISDLL, IDS_ICONTITLE, g_szIconTitle, ARRAYSIZE(g_szIconTitle));
    LoadString(HINST_THISDLL, IDS_NORMAL, g_szNormal, ARRAYSIZE(g_szNormal));
    LoadString(HINST_THISDLL, IDS_DISABLED, g_szDisabled, ARRAYSIZE(g_szDisabled));
    LoadString(HINST_THISDLL, IDS_SELECTED, g_szSelected, ARRAYSIZE(g_szSelected));
    LoadString(HINST_THISDLL, IDS_MSGBOX, g_szMsgBox, ARRAYSIZE(g_szMsgBox));
    LoadString(HINST_THISDLL, IDS_BUTTONTEXT, g_szButton, ARRAYSIZE(g_szButton));
    LoadString(HINST_THISDLL, IDS_WINDOWTEXT, g_szWindowText, ARRAYSIZE(g_szWindowText));
    LoadString(HINST_THISDLL, IDS_MSGBOXTEXT, g_szMsgBoxText, ARRAYSIZE(g_szMsgBoxText));

    // load up and
    g_hmenuSample = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(IDR_MENU));
    EnableMenuItem(g_hmenuSample, IDM_DISABLED, MF_GRAYED | MF_BYCOMMAND);

    if (fRTL) {
        SET_DC_RTL_MIRRORED(g_hdcMem);
    }
}


HRESULT CAdvAppearancePage::_OnDestroyPreview(HWND hWnd)
{
    if (g_hbmLook)
    {
        DeleteObject(g_hbmLook);
        g_hbmLook = NULL;
    }
    if (g_hmenuSample)
    {
        DestroyMenu(g_hmenuSample);
        g_hmenuSample = NULL;
    }

    return S_OK;
}


HRESULT CAdvAppearancePage::_OnPaintPreview(HWND hWnd)
{
    PAINTSTRUCT ps;

    BeginPaint(hWnd, &ps);
    RECT rc;
    GetClientRect(hWnd, &rc);
    if (g_hbmLook)
        _ShowBitmap(hWnd, ps.hdc);
    else
        _DrawPreview(ps.hdc, &rc, FALSE, TRUE);
    EndPaint(hWnd, &ps);

    return S_OK;
}


HRESULT CAdvAppearancePage::_OnReCreateBitmap(HWND hWnd)
{
    if (g_hbmLook)
    {
        HDC hdc = GetDC(NULL);
        if (g_nBitsPixel != GetDeviceCaps(hdc, BITSPIXEL))
        {
            DeleteObject(g_hbmLook);
            g_hbmLook = NULL;

            RECT rc;
            GetClientRect(hWnd, &rc);
            _InitPreview(&rc, IS_WINDOW_RTL_MIRRORED(hWnd));

            _RepaintPreview(hWnd);
        }
        ReleaseDC(NULL, hdc);
    }

    return S_OK;
}


HRESULT CAdvAppearancePage::_OnButtonDownOrDblClick(HWND hWnd, int nCoordX, int nCoordY)
{
    POINT pt;
    pt.x = nCoordX;  // horizontal position of cursor
    pt.y = nCoordY;  // vertical position of cursor

    int nElementIndex = LookPrev_HitTest(pt);
    return _SelectElement(hWnd, nElementIndex, LSE_SETCUR);
}


LRESULT CALLBACK CAdvAppearancePage::PreviewSystemMetricsWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CAdvAppearancePage * pThis = (CAdvAppearancePage *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (!pThis && (WM_NCDESTROY != wMsg))
    {
        AssertMsg((NULL != g_pAdvAppearancePage), TEXT("We need this or the dlg doesn't work at all.  -BryanSt"));
        if (g_pAdvAppearancePage)
        {
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)g_pAdvAppearancePage);
            pThis = (CAdvAppearancePage *)g_pAdvAppearancePage;
        }
    }

    if (pThis)
        return pThis->_PreviewSystemMetricsWndProc(hWnd, wMsg, wParam, lParam);

    return DefWindowProc(hWnd, wMsg, wParam, lParam);
}


// This Property Sheet appear in the top level of the "Display Control Panel".
LRESULT CAdvAppearancePage::_PreviewSystemMetricsWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lReturnValue = TRUE;
    BOOL fCallWndProc = TRUE;

    switch(wMsg)
    {
    case WM_NCCREATE:
        _OnNCCreate(hWnd);
        fCallWndProc = FALSE;
        break;

    case WM_CREATE:
        {
            RECT rc;
            GetClientRect(hWnd, &rc);
            _OnCreatePreviewSMDlg(&rc, IS_WINDOW_RTL_MIRRORED(hWnd));
        }
        break;

    case WM_DESTROY:
        _OnDestroyPreview(hWnd);
        break;

    case WM_PALETTECHANGED:
        if ((HWND)wParam == hWnd)
            break;
        //fallthru
    case WM_QUERYNEWPALETTE:
        if (m_hpal3D)
            InvalidateRect(hWnd, NULL, FALSE);
        break;

    case WM_LBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
        _OnButtonDownOrDblClick(GetParent(hWnd), LOWORD(lParam), HIWORD(lParam));
        break;

    case WM_RECREATEBITMAP:
        _OnReCreateBitmap(hWnd);
        break;

    case WM_SIZE:      // right mouse click
        break;

    case WM_PAINT:
        _OnPaintPreview(hWnd);
        break;
    }

    if (fCallWndProc)
    {
        lReturnValue = DefWindowProc(hWnd, wMsg, wParam, lParam);
    }

    return lReturnValue;
}











// ----------------------------------------------------------------------------
// calculate all of the rectangles based on the given window rect
// ----------------------------------------------------------------------------
void CAdvAppearancePage::_Recalc(LPRECT prc)
{
    DWORD cxNormal;
    int cxDisabled, cxSelected;
    int cxAvgCharx2;
    RECT rc;
    HFONT hfontT;
    int cxFrame, cyFrame;
    int cyCaption;
    int i;
    SIZE sizButton;

    rc = *prc;

    // Get our drawing data
    cxSize = ClassicGetSystemMetrics(SM_CXSIZE);
    cxFrame = (m_sizes[SIZE_FRAME].CurSize + 1) * m_cxBorderSM + m_cxEdgeSM;
    cyFrame = (m_sizes[SIZE_FRAME].CurSize + 1) * m_cyBorderSM + m_cyEdgeSM;
    cyCaption = m_sizes[SIZE_CAPTION].CurSize;

    // Get text dimensions, with proper font.
    hfontT = (HFONT) SelectObject(g_hdcMem, m_fonts[FONT_MENU].hfont);

    GetTextExtentPoint32(g_hdcMem, g_szNormal, lstrlen(g_szNormal), &sizButton);
    cxNormal = sizButton.cx;

    GetTextExtentPoint32(g_hdcMem, g_szDisabled, lstrlen(g_szDisabled), &sizButton);
    cxDisabled = sizButton.cx;

    GetTextExtentPoint32(g_hdcMem, g_szSelected, lstrlen(g_szSelected), &sizButton);
    cxSelected = sizButton.cx;

    // get the average width (USER style) of menu font
    GetTextExtentPoint32(g_hdcMem, g_szABC, 52, &sizButton);
    cxAvgCharx2 = 2 * (sizButton.cx / 52);

    // actual menu-handling widths of strings is bigger
    cxDisabled += cxAvgCharx2;
    cxSelected += cxAvgCharx2;
    cxNormal += cxAvgCharx2;

    SelectObject(g_hdcMem, hfontT);

    GetTextExtentPoint32(g_hdcMem, g_szButton, lstrlen(g_szButton), &sizButton);

    // Desktop
    RCZ(ELEMENT_DESKTOP) = rc;

    InflateRect(&rc, -8*m_cxBorderSM, -8*m_cyBorderSM);

    // Windows
    rc.bottom -= cyFrame + cyCaption;
    RCZ(ELEMENT_ACTIVEBORDER) = rc;
    OffsetRect(&RCZ(ELEMENT_ACTIVEBORDER), cxFrame,
                        cyFrame + cyCaption + m_cyBorderSM);
    RCZ(ELEMENT_ACTIVEBORDER).bottom -= cyCaption;

    // Inactive window
    rc.right -= cyCaption;
    RCZ(ELEMENT_INACTIVEBORDER) = rc;

    // Caption
    InflateRect(&rc, -cxFrame, -cyFrame);
    rc.bottom = rc.top + cyCaption + m_cyBorderSM;
    RCZ(ELEMENT_INACTIVECAPTION) = rc;

    // close button
    InflateRect(&rc, -m_cxEdgeSM, -m_cyEdgeSM);
    rc.bottom -= m_cyBorderSM;      // compensate for magic line under caption
    RCZ(ELEMENT_INACTIVESYSBUT1) = rc;
    RCZ(ELEMENT_INACTIVESYSBUT1).left = rc.right - (cyCaption - m_cxEdgeSM);

    // min/max buttons
    RCZ(ELEMENT_INACTIVESYSBUT2) = rc;
    RCZ(ELEMENT_INACTIVESYSBUT2).right = RCZ(ELEMENT_INACTIVESYSBUT1).left - m_cxEdgeSM;
    RCZ(ELEMENT_INACTIVESYSBUT2).left = RCZ(ELEMENT_INACTIVESYSBUT2).right - 
                                                2 * (cyCaption - m_cxEdgeSM);

    // Caption
    rc = RCZ(ELEMENT_ACTIVEBORDER);
    InflateRect(&rc, -cxFrame, -cyFrame);
    RCZ(ELEMENT_ACTIVECAPTION) = rc;
    RCZ(ELEMENT_ACTIVECAPTION).bottom = 
        RCZ(ELEMENT_ACTIVECAPTION).top + cyCaption + m_cyBorderSM;

    // close button
    RCZ(ELEMENT_ACTIVESYSBUT1) = RCZ(ELEMENT_ACTIVECAPTION);
    InflateRect(&RCZ(ELEMENT_ACTIVESYSBUT1), -m_cxEdgeSM, -m_cyEdgeSM);
    RCZ(ELEMENT_ACTIVESYSBUT1).bottom -= m_cyBorderSM;      // compensate for magic line under caption
    RCZ(ELEMENT_ACTIVESYSBUT1).left = RCZ(ELEMENT_ACTIVESYSBUT1).right - 
                                        (cyCaption - m_cxEdgeSM);

    // min/max buttons
    RCZ(ELEMENT_ACTIVESYSBUT2) = RCZ(ELEMENT_ACTIVESYSBUT1);
    RCZ(ELEMENT_ACTIVESYSBUT2).right = RCZ(ELEMENT_ACTIVESYSBUT1).left - m_cxEdgeSM;
    RCZ(ELEMENT_ACTIVESYSBUT2).left = RCZ(ELEMENT_ACTIVESYSBUT2).right - 
                                                2 * (cyCaption - m_cxEdgeSM);

    // Menu
    rc.top = RCZ(ELEMENT_ACTIVECAPTION).bottom;
    RCZ(ELEMENT_MENUNORMAL) = rc;
    rc.top = RCZ(ELEMENT_MENUNORMAL).bottom = RCZ(ELEMENT_MENUNORMAL).top + m_sizes[SIZE_MENU].CurSize;
    RCZ(ELEMENT_MENUDISABLED) = RCZ(ELEMENT_MENUSELECTED) = RCZ(ELEMENT_MENUNORMAL);

    RCZ(ELEMENT_MENUDISABLED).left = RCZ(ELEMENT_MENUNORMAL).left + cxNormal;
    RCZ(ELEMENT_MENUDISABLED).right = RCZ(ELEMENT_MENUSELECTED).left = 
                        RCZ(ELEMENT_MENUDISABLED).left + cxDisabled;
    RCZ(ELEMENT_MENUSELECTED).right = RCZ(ELEMENT_MENUSELECTED).left + cxSelected;
    
    // Client
    RCZ(ELEMENT_WINDOW) = rc;

    // Scrollbar
    InflateRect(&rc, -m_cxEdgeSM, -m_cyEdgeSM); // take off client edge
    RCZ(ELEMENT_SCROLLBAR) = rc;
    rc.right = RCZ(ELEMENT_SCROLLBAR).left = rc.right - m_sizes[SIZE_SCROLL].CurSize;
    RCZ(ELEMENT_SCROLLUP) = RCZ(ELEMENT_SCROLLBAR);
    RCZ(ELEMENT_SCROLLUP).bottom = RCZ(ELEMENT_SCROLLBAR).top + m_sizes[SIZE_SCROLL].CurSize; 

    RCZ(ELEMENT_SCROLLDOWN) = RCZ(ELEMENT_SCROLLBAR);
    RCZ(ELEMENT_SCROLLDOWN).top = RCZ(ELEMENT_SCROLLBAR).bottom - m_sizes[SIZE_SCROLL].CurSize; 

    // Message Box
    rc.top = RCZ(ELEMENT_WINDOW).top + (RCZ(ELEMENT_WINDOW).bottom - RCZ(ELEMENT_WINDOW).top) / 2;
    rc.bottom = RCZ(ELEMENT_DESKTOP).bottom - 2*m_cyEdgeSM;
    rc.left = RCZ(ELEMENT_WINDOW).left + 2*m_cyEdgeSM;
    rc.right = RCZ(ELEMENT_WINDOW).left + (RCZ(ELEMENT_WINDOW).right - RCZ(ELEMENT_WINDOW).left) / 2 + 3*cyCaption;
    RCZ(ELEMENT_MSGBOX) = rc;

    // Caption
    RCZ(ELEMENT_MSGBOXCAPTION) = rc;
    RCZ(ELEMENT_MSGBOXCAPTION).top += m_cyEdgeSM + m_cyBorderSM;
    RCZ(ELEMENT_MSGBOXCAPTION).bottom = RCZ(ELEMENT_MSGBOXCAPTION).top + cyCaption + m_cyBorderSM;
    RCZ(ELEMENT_MSGBOXCAPTION).left += m_cxEdgeSM + m_cxBorderSM;
    RCZ(ELEMENT_MSGBOXCAPTION).right -= m_cxEdgeSM + m_cxBorderSM;

    RCZ(ELEMENT_MSGBOXSYSBUT) = RCZ(ELEMENT_MSGBOXCAPTION);
    InflateRect(&RCZ(ELEMENT_MSGBOXSYSBUT), -m_cxEdgeSM, -m_cyEdgeSM);
    RCZ(ELEMENT_MSGBOXSYSBUT).left = RCZ(ELEMENT_MSGBOXSYSBUT).right - 
                                        (cyCaption - m_cxEdgeSM);
    RCZ(ELEMENT_MSGBOXSYSBUT).bottom -= m_cyBorderSM;       // line under caption

    // Button
    RCZ(ELEMENT_BUTTON).bottom = RCZ(ELEMENT_MSGBOX).bottom - (4*m_cyBorderSM + m_cyEdgeSM);
    RCZ(ELEMENT_BUTTON).top = RCZ(ELEMENT_BUTTON).bottom - (sizButton.cy + 8 * m_cyBorderSM);

    i = (RCZ(ELEMENT_BUTTON).bottom - RCZ(ELEMENT_BUTTON).top) * 3;
    RCZ(ELEMENT_BUTTON).left = (rc.left + (rc.right - rc.left)/2) - i/2;
    RCZ(ELEMENT_BUTTON).right = RCZ(ELEMENT_BUTTON).left + i;
}

// ----------------------------------------------------------------------------
//
//  MyDrawFrame() -
//
//  Draws bordered frame, border size cl, and adjusts passed in rect.
//
// ----------------------------------------------------------------------------
void MyDrawFrame(HDC hdc, LPRECT prc, HBRUSH hbrColor, int cl)
{
    HBRUSH hbr;
    int cx, cy;
    RECT rcT;

    rcT = *prc;
    cx = cl * cxBorder;
    cy = cl * cyBorder;

    hbr = (HBRUSH) SelectObject(hdc, hbrColor);

    PatBlt(hdc, rcT.left, rcT.top, cx, rcT.bottom - rcT.top, PATCOPY);
    rcT.left += cx;

    PatBlt(hdc, rcT.left, rcT.top, rcT.right - rcT.left, cy, PATCOPY);
    rcT.top += cy;

    rcT.right -= cx;
    PatBlt(hdc, rcT.right, rcT.top, cx, rcT.bottom - rcT.top, PATCOPY);

    rcT.bottom -= cy;
    PatBlt(hdc, rcT.left, rcT.bottom, rcT.right - rcT.left, cy, PATCOPY);

    hbr = (HBRUSH) SelectObject(hdc, hbr);

    *prc = rcT;
}

/*
** draw a m_cyBorderSM band of 3DFACE at the bottom of the given rectangle.
** also, adjust the rectangle accordingly.
*/
void CAdvAppearancePage::_MyDrawBorderBelow(HDC hdc, LPRECT prc)
{
    int i;

    i = prc->top;
    prc->top = prc->bottom - m_cyBorderSM;
    FillRect(hdc, prc, m_brushes[COLOR_3DFACE]);
    prc->top = i;
    prc->bottom -= m_cyBorderSM;
}

void CAdvAppearancePage::_ShowBitmap(HWND hWnd, HDC hdc)
{
    RECT rc;
    HBITMAP hbmOld;
    HPALETTE hpalOld = NULL;

    if (m_hpal3D)
    {
        hpalOld = SelectPalette(hdc, m_hpal3D, FALSE);
        RealizePalette(hdc);
    }

    GetClientRect(hWnd, &rc);
    hbmOld = (HBITMAP) SelectObject(g_hdcMem, g_hbmLook);
    BitBlt(hdc, 0, 0, rc.right - rc.left, rc.bottom - rc.top, g_hdcMem, 0, 0, SRCCOPY);
    SelectObject(g_hdcMem, hbmOld);

    if (hpalOld)
    {
        SelectPalette(hdc, hpalOld, FALSE);
        RealizePalette(hdc);
    }
}


// ----------------------------------------------------------------------------
//
//
// ----------------------------------------------------------------------------
void CAdvAppearancePage::_DrawPreview(HDC hdc, LPRECT prc, BOOL fOnlyShowActiveWindow, BOOL fShowBack)
{
    RECT rcT;
    int nMode;
    DWORD rgbBk;
    int cxSize, cySize;
    HANDLE hOldColors;
    HPALETTE hpalOld = NULL;
    HICON hiconLogo;
    HFONT hfontOld;
    BOOL bGradient = FALSE;

    ClassicSystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, (PVOID)&bGradient, 0);

    SaveDC(hdc);

    if (m_hpal3D)
    {
        hpalOld = SelectPalette(hdc, m_hpal3D, TRUE);
        RealizePalette(hdc);
    }

    hOldColors = SetSysColorsTemp(m_rgb, m_brushes, COLOR_MAX);

    hiconLogo = (HICON) LoadImage(NULL, IDI_APPLICATION, IMAGE_ICON,
                        m_sizes[SIZE_CAPTION].CurSize - 2*m_cxBorderSM,
                        m_sizes[SIZE_CAPTION].CurSize - 2*m_cyBorderSM, 0);

    // Setup drawing stuff
    nMode = SetBkMode(hdc, TRANSPARENT);
    rgbBk = GetTextColor(hdc);

    cxSize  = ClassicGetSystemMetrics(SM_CXSIZE);
    cySize  = ClassicGetSystemMetrics(SM_CYSIZE);

    // Desktop
    if (fShowBack)
    {
        FillRect(hdc, &RCZ(ELEMENT_DESKTOP), m_brushes[COLOR_BACKGROUND]);
    }

    if (!fOnlyShowActiveWindow)
    {
        // Inactive window

        // Border
        rcT = RCZ(ELEMENT_INACTIVEBORDER);
        DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
        MyDrawFrame(hdc, &rcT, m_brushes[COLOR_INACTIVEBORDER], m_sizes[SIZE_FRAME].CurSize);
        MyDrawFrame(hdc, &rcT, m_brushes[COLOR_3DFACE], 1);

        // Caption
        rcT = RCZ(ELEMENT_INACTIVECAPTION);
        _MyDrawBorderBelow(hdc, &rcT);

        // NOTE: because USER draws icon stuff using its own DC and subsequently
        // its own palette, we need to make sure to use the inactivecaption
        // brush before USER does so that it will be realized against our palette.
        // this might get fixed in USER by better be safe.  

        // "clip" the caption title under the buttons
        rcT.left = RCZ(ELEMENT_INACTIVESYSBUT2).left - m_cyEdgeSM;
        FillRect(hdc, &rcT, m_brushes[bGradient ? COLOR_GRADIENTINACTIVECAPTION : COLOR_INACTIVECAPTION]);
        rcT.right = rcT.left;
        rcT.left = RCZ(ELEMENT_INACTIVECAPTION).left;
        DrawCaptionTemp(NULL, hdc, &rcT, m_fonts[FONT_CAPTION].hfont, hiconLogo, g_szInactive, DC_ICON | DC_TEXT |
                (bGradient ? DC_GRADIENT : 0));

        DrawFrameControl(hdc, &RCZ(ELEMENT_INACTIVESYSBUT1), DFC_CAPTION, DFCS_CAPTIONCLOSE);
        rcT = RCZ(ELEMENT_INACTIVESYSBUT2);
        rcT.right -= (rcT.right - rcT.left)/2;
        DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMIN);
        rcT.left = rcT.right;
        rcT.right = RCZ(ELEMENT_INACTIVESYSBUT2).right;
        DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMAX);
    }

    // Border
    rcT = RCZ(ELEMENT_ACTIVEBORDER);
    DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
    MyDrawFrame(hdc, &rcT, m_brushes[COLOR_ACTIVEBORDER], m_sizes[SIZE_FRAME].CurSize);
    MyDrawFrame(hdc, &rcT, m_brushes[COLOR_3DFACE], 1);

    // Caption
    rcT = RCZ(ELEMENT_ACTIVECAPTION);
    _MyDrawBorderBelow(hdc, &rcT);
    // "clip" the caption title under the buttons
    rcT.left = RCZ(ELEMENT_ACTIVESYSBUT2).left - m_cxEdgeSM;
    FillRect(hdc, &rcT, m_brushes[bGradient ? COLOR_GRADIENTACTIVECAPTION : COLOR_ACTIVECAPTION]);
    rcT.right = rcT.left;
    rcT.left = RCZ(ELEMENT_ACTIVECAPTION).left;
    DrawCaptionTemp(NULL, hdc, &rcT, m_fonts[FONT_CAPTION].hfont, hiconLogo, g_szActive, DC_ACTIVE | DC_ICON | DC_TEXT |
            (bGradient ? DC_GRADIENT : 0));

    DrawFrameControl(hdc, &RCZ(ELEMENT_ACTIVESYSBUT1), DFC_CAPTION, DFCS_CAPTIONCLOSE);
    rcT = RCZ(ELEMENT_ACTIVESYSBUT2);
    rcT.right -= (rcT.right - rcT.left)/2;
    DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMIN);
    rcT.left = rcT.right;
    rcT.right = RCZ(ELEMENT_ACTIVESYSBUT2).right;
    DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMAX);

    // Menu
    rcT = RCZ(ELEMENT_MENUNORMAL);
    DrawMenuBarTemp(GetDesktopWindow(), hdc, &rcT, g_hmenuSample, m_fonts[FONT_MENU].hfont);
    _MyDrawBorderBelow(hdc, &rcT);

    // Client area
    rcT = RCZ(ELEMENT_WINDOW);
    DrawEdge(hdc, &rcT, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
    FillRect(hdc, &rcT, m_brushes[COLOR_WINDOW]);

    // window text
    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, m_rgb[COLOR_WINDOWTEXT]);

    hfontOld = (HFONT) SelectObject(hdc, m_fonts[FONT_CAPTION].hfont);
    TextOut(hdc, RCZ(ELEMENT_WINDOW).left + 2*m_cxEdgeSM, RCZ(ELEMENT_WINDOW).top + 2*m_cyEdgeSM, g_szWindowText, lstrlen(g_szWindowText));
    if (hfontOld)
        SelectObject(hdc, hfontOld); 

    // scroll bar
    rcT = RCZ(ELEMENT_SCROLLBAR);
    FillRect(hdc, &rcT, m_brushes[COLOR_SCROLLBAR]);

    DrawFrameControl(hdc, &RCZ(ELEMENT_SCROLLUP), DFC_SCROLL, DFCS_SCROLLUP);
    DrawFrameControl(hdc, &RCZ(ELEMENT_SCROLLDOWN), DFC_SCROLL, DFCS_SCROLLDOWN); 

    if (!fOnlyShowActiveWindow)
    {
        // MessageBox
        rcT = RCZ(ELEMENT_MSGBOX);
        DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
        FillRect(hdc, &rcT, m_brushes[COLOR_3DFACE]);

        rcT = RCZ(ELEMENT_MSGBOXCAPTION);
        _MyDrawBorderBelow(hdc, &rcT);
        // "clip" the caption title under the buttons
        rcT.left = RCZ(ELEMENT_MSGBOXSYSBUT).left - m_cxEdgeSM;
        FillRect(hdc, &rcT, m_brushes[bGradient ? COLOR_GRADIENTACTIVECAPTION : COLOR_ACTIVECAPTION]);
        rcT.right = rcT.left;
        rcT.left = RCZ(ELEMENT_MSGBOXCAPTION).left;
        DrawCaptionTemp(NULL, hdc, &rcT, m_fonts[FONT_CAPTION].hfont, hiconLogo, g_szMsgBox, DC_ACTIVE | DC_ICON | DC_TEXT |
                (bGradient ? DC_GRADIENT : 0));
        DrawFrameControl(hdc, &RCZ(ELEMENT_MSGBOXSYSBUT), DFC_CAPTION, DFCS_CAPTIONCLOSE);

        // message box text
        SetBkMode(hdc, TRANSPARENT);
        SetTextColor(hdc, m_rgb[COLOR_WINDOWTEXT]);
        hfontOld = (HFONT) SelectObject(hdc, m_fonts[FONT_MSGBOX].hfont);
        TextOut(hdc, RCZ(ELEMENT_MSGBOX).left + 3*m_cxEdgeSM, RCZ(ELEMENT_MSGBOXCAPTION).bottom + m_cyEdgeSM,
                            g_szMsgBoxText, lstrlen(g_szMsgBoxText));
        if (hfontOld)
            SelectObject(hdc, hfontOld);

        // Button
        rcT = RCZ(ELEMENT_BUTTON);
        DrawFrameControl(hdc, &rcT, DFC_BUTTON, DFCS_BUTTONPUSH);

        // ?????? what font should this use ??????
        // [msadek]; Pick the same one we use for Messagebox text.(This is what Message Box uses for its buttons)
        // else we will be using the font originally selected in the DC (System font)
        hfontOld = (HFONT) SelectObject(hdc, m_fonts[FONT_MSGBOX].hfont);
  
        SetBkMode(hdc, TRANSPARENT);
        SetTextColor(hdc, m_rgb[COLOR_BTNTEXT]);
        DrawText(hdc, g_szButton, -1, &rcT, DT_CENTER | DT_NOPREFIX |
            DT_SINGLELINE | DT_VCENTER);
        if (hfontOld)
            SelectObject(hdc, hfontOld); 
    }

    SetBkColor(hdc, rgbBk);
    SetBkMode(hdc, nMode);

    if (hiconLogo)
        DestroyIcon(hiconLogo);

    SetSysColorsTemp(NULL, NULL, (UINT_PTR)hOldColors);

    if (hpalOld)
    {
        hpalOld = SelectPalette(hdc, hpalOld, FALSE);
        RealizePalette(hdc);
    }

    RestoreDC(hdc, -1);
}


void CAdvAppearancePage::_RepaintPreview(HWND hwnd)
{
    HBITMAP hbmOld;

    if (g_hbmLook)
    {
        hbmOld = (HBITMAP) SelectObject(g_hdcMem, g_hbmLook);
        RECT rc;
        GetClientRect(hwnd, &rc);
        _DrawPreview(g_hdcMem, &rc, FALSE, TRUE);
        SelectObject(g_hdcMem, hbmOld);
    }
    InvalidateRect(hwnd, NULL, FALSE);
}


BOOL RegisterPreviewSystemMetricClass(HINSTANCE hInst)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInst, PREVIEWSM_CLASS, &wc))
    {
        wc.style = 0;
        wc.lpfnWndProc = CAdvAppearancePage::PreviewSystemMetricsWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = hInst;
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = PREVIEWSM_CLASS;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    return TRUE;
}


/*---------------------------------------------------------
**
**---------------------------------------------------------*/
BOOL CreateGlobals(void)
{
    HBITMAP hbm;
    HDC hdc;

    // Check if the mirroring APIs exist on the current
    // platform.
    g_bMirroredOS = IS_MIRRORING_ENABLED();

    if (!g_hdcMem)
    {
        hdc = GetDC(NULL);
        g_hdcMem = CreateCompatibleDC(hdc);
        ReleaseDC(NULL, hdc);
    }

    if (!g_hdcMem)
        return FALSE;

    if (!g_hbmDefault)
    {
        hbm = CreateBitmap(1, 1, 1, 1, NULL);
        if (hbm)
        {
            g_hbmDefault = (HBITMAP) SelectObject(g_hdcMem, hbm);
            SelectObject(g_hdcMem, g_hbmDefault);
            DeleteObject(hbm);
        }
    }

    return TRUE;
}


HRESULT CAdvAppearancePage::Draw(HDC hdc, LPRECT prc, BOOL fOnlyShowActiveWindow, BOOL fRTL)
{
    _OnCreatePreviewSMDlg(prc, fRTL);

    m_cyBorderSM = ClassicGetSystemMetrics(SM_CYBORDER);
    m_cxBorderSM = ClassicGetSystemMetrics(SM_CXBORDER);
    m_cxEdgeSM = ClassicGetSystemMetrics(SM_CXEDGE);
    m_cyEdgeSM = ClassicGetSystemMetrics(SM_CYEDGE);

    _InitSysStuff();
    _Recalc(prc);
    _DrawPreview(hdc, prc, fOnlyShowActiveWindow, FALSE);
    _DestroySysStuff(); 

    if (g_hbmLook)
    {
        DeleteObject(g_hbmLook);
    }

    if (g_hmenuSample)
    {
        DestroyMenu(g_hmenuSample);
    }

    return S_OK;
}
    
HRESULT DrawAppearance(HDC hdc, LPRECT prc, SYSTEMMETRICSALL* psysMet, BOOL fOnlyShowActiveWindow, BOOL fRTL)
{
    HRESULT hr = E_OUTOFMEMORY;
    CAdvAppearancePage* pAdv = new CAdvAppearancePage(psysMet);
    if (pAdv)
    {
        hr = pAdv->Draw(hdc, prc, fOnlyShowActiveWindow, fRTL);
        delete pAdv;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\previewth.cpp ===
/*****************************************************************************\
    FILE: PreviewTh.cpp

    DESCRIPTION:
        This code will display a preview of the currently selected
    visual styles.

    BryanSt 5/5/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "PreviewTh.h"
#include "PreviewSM.h"
#include "classfactory.h"

// Old predef for Patterns
#define CXYDESKPATTERN 8

// Async Bitmap loading
#define PREVIEW_PICTURE_FILENAME      TEXT("PrePict.htm")
#define WM_HTML_BITMAP  (WM_USER + 100)
#define WM_ASYNC_BITMAP (WM_HTML_BITMAP + 1)
typedef struct{
    HWND hwnd;
    HBITMAP hbmp;
    DWORD id;
    WCHAR szFile[MAX_PATH];
} ASYNCWALLPARAM, * PASYNCWALLPARAM;

// Window Class Name
#define THEMEPREV_CLASS TEXT("ThemePreview")

//===========================
// *** IThemePreview Interface ***
//===========================
extern LPCWSTR s_Icons[];

HRESULT CPreviewTheme::UpdatePreview(IN IPropertyBag * pPropertyBag)
{
    HRESULT hr = E_INVALIDARG;

    DEBUG_CODE(DebugStartWatch());

    if (pPropertyBag && _hwndPrev)
    {
        SYSTEMMETRICSALL systemMetricsAll = {0};
        hr = SHPropertyBag_ReadByRef(pPropertyBag, SZ_PBPROP_SYSTEM_METRICS, &systemMetricsAll, sizeof(systemMetricsAll));
        BOOL fSysMetDirty = (memcmp(&systemMetricsAll, &_systemMetricsAll, sizeof(SYSTEMMETRICSALL)) != 0);
        if (fSysMetDirty)
            memcpy(&_systemMetricsAll, &systemMetricsAll, sizeof(_systemMetricsAll));

        _putBackground(NULL, TRUE, 0);

        if (_fShowBack)
        {
            WCHAR szBackgroundPath[MAX_PATH];
            DWORD dwBackgroundTile;

            // See the list of Property Bag names for Themes in shpriv.idl
            hr = SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_BACKGROUND_PATH, szBackgroundPath, ARRAYSIZE(szBackgroundPath));
            hr = SHPropertyBag_ReadDWORD(pPropertyBag, SZ_PBPROP_BACKGROUND_TILE, &dwBackgroundTile);

            if ((lstrcmp(szBackgroundPath, _szBackgroundPath) != 0) || (_iTileMode != (int)dwBackgroundTile))
            {
                StringCchCopy(_szBackgroundPath, ARRAYSIZE(_szBackgroundPath), szBackgroundPath);
                _putBackground(_szBackgroundPath, FALSE, dwBackgroundTile);
            }
        }

        if (_fShowVS)
        {
            WCHAR szVSPath[MAX_PATH];
            WCHAR szVSColor[MAX_PATH];
            WCHAR szVSSize[MAX_PATH];

            hr = SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_VISUALSTYLE_PATH, szVSPath, ARRAYSIZE(szVSPath));
            hr = SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_VISUALSTYLE_COLOR, szVSColor, ARRAYSIZE(szVSColor));
            hr = SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_VISUALSTYLE_SIZE, szVSSize, ARRAYSIZE(szVSSize));

            if ((lstrcmp(szVSPath, _szVSPath) != 0) || 
                (lstrcmp(szVSColor, _szVSColor) != 0) || 
                (lstrcmp(szVSSize, _szVSSize) != 0) || 
                fSysMetDirty)
            {
                StringCchCopy(_szVSPath, ARRAYSIZE(_szVSPath), szVSPath);
                StringCchCopy(_szVSColor, ARRAYSIZE(_szVSColor), szVSColor);
                StringCchCopy(_szVSSize, ARRAYSIZE(_szVSSize), szVSSize);
                _putVisualStyle(_szVSPath, _szVSColor, _szVSSize, &_systemMetricsAll);
            }
        }

        if (_fShowIcons)
        {
            _putIcons(pPropertyBag);
        }
    }

    DEBUG_CODE(TraceMsg(TF_THEMEUI_PERF, "CPreviewTheme::UpdatePreview() returned %#08lx. Time=%lums", hr, DebugStopWatch()));

    return hr;
}


HRESULT CPreviewTheme::CreatePreview(IN HWND hwndParent, IN DWORD dwFlags, IN DWORD dwStyle, IN DWORD dwExStyle, IN int x, IN int y, IN int nWidth, IN int nHeight, IN IPropertyBag * pPropertyBag, IN DWORD dwCtrlID)
{
    HRESULT hr = S_OK;

    DEBUG_CODE(DebugStartWatch());

    g_bMirroredOS = IS_MIRRORING_ENABLED();
    _fRTL = IS_WINDOW_RTL_MIRRORED(hwndParent);
    _hwndPrev = CreateWindowEx(dwExStyle, THEMEPREV_CLASS, L"Preview", dwStyle, x, y, nWidth, nHeight, hwndParent, (HMENU)IntToPtr(dwCtrlID), HINST_THISDLL, NULL);
    
    if (_hwndPrev)
    {
        SetWindowLongPtr(_hwndPrev, GWLP_USERDATA, (LONG_PTR)this);
        if (_pThumb)
            _pThumb->Init(_hwndPrev, WM_HTML_BITMAP);

        GetClientRect(_hwndPrev, &_rcOuter);

        if (dwFlags & TMPREV_SHOWMONITOR)
        {
            _fShowMon = TRUE;

            BITMAP bmMon;
            GetObject(_hbmMon, sizeof(bmMon), &bmMon);

            int ox = (RECTWIDTH(_rcOuter) - bmMon.bmWidth) / 2;
            int oy = (RECTHEIGHT(_rcOuter) - bmMon.bmHeight) / 2;
            RECT rc = { 16 + ox, 17 + oy, 168 + ox, 129 + oy};
            _rcInner = rc;
            _cxMon = ox;
            _cyMon = oy;
        }
        else
        {
            _rcInner = _rcOuter;
        }

        HDC hdcTemp = GetDC(_hwndPrev);
        if (hdcTemp)
        {
            HBITMAP hbmMem = CreateCompatibleBitmap(hdcTemp, RECTWIDTH(_rcOuter), RECTHEIGHT(_rcOuter));
            if (hbmMem)
            {
                HBITMAP hbmOld = (HBITMAP) SelectObject(_hdcMem, hbmMem);
                DeleteObject(hbmOld);
            }
            else
                hr = E_FAIL;
            ReleaseDC(_hwndPrev, hdcTemp);
        }
        else
            hr = E_FAIL;

        if (dwFlags & TMPREV_SHOWBKGND)
        {
            _fShowBack = TRUE;
        }

        _fShowVS = dwFlags & TMPREV_SHOWVS;
        _fOnlyActiveWindow = _fShowIcons = dwFlags & TMPREV_SHOWICONS;

        DEBUG_CODE(TraceMsg(TF_THEMEUI_PERF, "CPreviewTheme::CreatePreview() returned %#08lx. Time=%lums", hr, DebugStopWatch()));

        if (SUCCEEDED(hr))
            hr = UpdatePreview(pPropertyBag);
    }

    return hr;
}

//===========================
// *** IUnknown Interface ***
//===========================
ULONG CPreviewTheme::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CPreviewTheme::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CPreviewTheme::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CPreviewTheme, IObjectWithSite),
        QITABENT(CPreviewTheme, IThemePreview),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CPreviewTheme::CPreviewTheme() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pTheme);
    ASSERT(!m_pScheme);
    ASSERT(!m_pStyle);
    ASSERT(!m_pSize);
    ASSERT(!_hwndPrev);
}

HRESULT CPreviewTheme::_Init(void)
{
    HRESULT hr = S_OK;

    _RegisterThemePreviewClass(HINST_THISDLL);

    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        _hdcMem = CreateCompatibleDC(hdc);
        ReleaseDC(NULL, hdc);
    }
    else
        hr = E_FAIL;

    if (_hdcMem)
    {
        _hbmMon = LoadBitmap(HINST_THISDLL, MAKEINTRESOURCE(IDB_MONITOR));
        if (_hbmMon)
        {
            if (LoadString(HINST_THISDLL, IDS_NONE, _szNone, ARRAYSIZE(_szNone)) == 0)
                hr = E_FAIL;
        }
        else
            hr = E_FAIL;

        if (SUCCEEDED(hr))
            hr = CoCreateInstance(CLSID_Thumbnail, NULL, CLSCTX_INPROC_SERVER, IID_IThumbnail, (void **)&_pThumb);
    }
    else
        hr = E_FAIL;


    if (FAILED(hr))
    {
        if (_hbmMon)
        {
            DeleteObject(_hbmMon);
            _hbmMon = NULL;
        }
        if (_hdcMem)
        {
            DeleteDC(_hdcMem);
            _hdcMem = NULL;
        }
    }

    return hr;
}

CPreviewTheme::~CPreviewTheme()
{
    if (_hwndPrev && IsWindow(_hwndPrev))
    {
        DestroyWindow(_hwndPrev);
        _hwndPrev = NULL;
    }
    if (_hbmMon)
    {
        DeleteObject(_hbmMon);
        _hbmMon = NULL;
    }
    if (_hbmBack)
    {
        DeleteObject(_hbmBack);
        _hbmBack = NULL;
    }
    if (_hbrBack)
    {
        DeleteObject(_hbrBack);
        _hbrBack = NULL;
    }

    if (_hbmVS)
    {
        DeleteObject(_hbmVS);
    }

    if (_hdcMem)
    {
        DeleteDC(_hdcMem);
        _hpalMem = NULL;
        _hdcMem = NULL;
    }

    if (_pActiveDesk)
    {
        _pActiveDesk->Release();
    }

    for (int i = 0; i < MAX_PREVIEW_ICONS; i++)
    {
        if (_iconList[i].hicon)
        {
            DestroyIcon(_iconList[i].hicon);
        }
    }

    ATOMICRELEASE(m_pTheme);
    ATOMICRELEASE(m_pScheme);
    ATOMICRELEASE(m_pStyle);
    ATOMICRELEASE(m_pSize);
    ATOMICRELEASE(_pThumb);

    DllRelease();
}

LRESULT CALLBACK CPreviewTheme::ThemePreviewWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CPreviewTheme * pThis = (CPreviewTheme *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (pThis)
        return pThis->_ThemePreviewWndProc(hWnd, wMsg, wParam, lParam);

    return DefWindowProc(hWnd, wMsg, wParam, lParam);
}

LRESULT CPreviewTheme::_ThemePreviewWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch(wMsg)
    {
        case WM_CREATE:
            break;

        case WM_DESTROY:
            {
                MSG msg;
                while (PeekMessage(&msg, hWnd, WM_HTML_BITMAP, WM_ASYNC_BITMAP, PM_REMOVE))
                {
                    if ( msg.lParam )
                    {
                        if (msg.message == WM_ASYNC_BITMAP)
                        {
                            //  clean up this useless stuff
                            DeleteObject(((PASYNCWALLPARAM)(msg.lParam))->hbmp);
                            LocalFree((PASYNCWALLPARAM)(msg.lParam));
                        }
                        else // WM_HTML_BITMAP
                            DeleteObject((HBITMAP)msg.lParam);
                    }
                }
            }
            break;

        case WM_PALETTECHANGED:
            break;

        case WM_QUERYNEWPALETTE:
            break;

        case WM_HTML_BITMAP:
            {
                // may come through with NULL if the image extraction failed....
                if (wParam == _dwWallpaperID && lParam)
                {
                    _fHTMLBitmap = TRUE;
                    _iTileMode = _iNewTileMode;
                    _putBackgroundBitmap((HBITMAP)lParam);
                    // Take ownership of bitmap
                    return 1;
                }
                
                // Bitmap for something no longer selected
                return 0;
            }

        case WM_ASYNC_BITMAP:
            if (lParam)
            {
                PASYNCWALLPARAM pawp = (PASYNCWALLPARAM) lParam;
                ASSERT(pawp->hbmp);
                if (pawp->id == _dwWallpaperID)
                {
                    _fHTMLBitmap = FALSE;
                    _iTileMode = _iNewTileMode;
                    _putBackgroundBitmap(pawp->hbmp);
                }
                else
                {
                    //  clean up this useless stuff
                    DeleteObject(pawp->hbmp);
                    LocalFree(pawp);
                }
            }
            break;

        case WM_PAINT:
            {
                PAINTSTRUCT ps;
                BeginPaint(hWnd, &ps);
                _Paint(ps.hdc);
                EndPaint(hWnd, &ps);
            }
            return 0;

        case WM_ERASEBKGND:
            _Paint((HDC)wParam);
            return 1;

    }

    return DefWindowProc(hWnd,wMsg,wParam,lParam);
}

BOOL CPreviewTheme::_RegisterThemePreviewClass(HINSTANCE hInst)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInst, THEMEPREV_CLASS, &wc)) {
        wc.style = 0;
        wc.lpfnWndProc = CPreviewTheme::ThemePreviewWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = hInst;
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = THEMEPREV_CLASS;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    return TRUE;
}

HRESULT CPreviewTheme::_putIcons(IPropertyBag* pPropertyBag)
{
    HRESULT hr;

    for (int i = 0; i < MAX_PREVIEW_ICONS; i++)
    {
        if (_iconList[i].hicon)
        {
            DestroyIcon(_iconList[i].hicon);
        }

        WCHAR szIcon[MAX_PATH];

        hr = SHPropertyBag_ReadStr(pPropertyBag, s_Icons[i], szIcon, ARRAYSIZE(szIcon));
        if (SUCCEEDED(hr))
        {
            WCHAR szIconModule[MAX_PATH];
            SHExpandEnvironmentStrings(szIcon, szIconModule, ARRAYSIZE(szIconModule));
            int iIndex = PathParseIconLocation(szIconModule);
            ExtractIconEx(szIconModule, iIndex, &_iconList[i].hicon, NULL, 1);
        }
    }

    _fMemIsDirty = TRUE;
    InvalidateRect(_hwndPrev, &_rcInner, FALSE);
    return S_OK;
}

HRESULT CPreviewTheme::_putVisualStyle(LPCWSTR pszVSPath, LPCWSTR pszVSColor, LPCWSTR pszVSSize, SYSTEMMETRICSALL* psysMet)
{
    HRESULT hr = E_FAIL;
    HBITMAP hbmVS = NULL;
    HBITMAP hbmOldVS = NULL;
    HDC hdcVS = NULL;

    if (!pszVSPath || !*pszVSPath)
    {
        HDC hdcTemp = GetDC(_hwndPrev);

        if (hdcTemp)
        {
            hdcVS = CreateCompatibleDC(hdcTemp);
            hbmVS = CreateCompatibleBitmap(hdcTemp, RECTWIDTH(_rcInner), RECTHEIGHT(_rcInner));
            hbmOldVS = (HBITMAP)SelectObject(hdcVS, hbmVS);

            if (hdcVS && hbmVS)
            {
                RECT rcVS;
                rcVS.left   = 0;
                rcVS.right  = RECTWIDTH(_rcInner) - (_fShowIcons ? 100 : 8);
                rcVS.top    = 0;
                rcVS.bottom = RECTHEIGHT(_rcInner) - (_fShowIcons ? 50 : 8);

                // Create everyone including globals
                HDC hdcVStemp = CreateCompatibleDC(hdcTemp);
                HBITMAP hbmVStemp = CreateCompatibleBitmap(hdcTemp, RECTWIDTH(rcVS), RECTHEIGHT(rcVS));
                HBITMAP hbmOldVStemp = (HBITMAP) SelectObject(hdcVStemp, hbmVStemp);

                if (hdcVStemp && hbmVStemp)
                {
                    if (_fRTL)
                    {
                        SetLayout(hdcVStemp, LAYOUT_RTL);
                        SetLayout(hdcVS, LAYOUT_RTL);
                    }

                    HBRUSH hbr = CreateSolidBrush(RGB(255, 255, 0));
                    if (hbr)
                    {
                        FillRect(hdcVStemp, &rcVS, hbr);
                        RECT rcTemp = {0, 0, RECTWIDTH(_rcInner), RECTHEIGHT(_rcInner)};
                        FillRect(hdcVS, &rcTemp, hbr);
                        DeleteObject(hbr);
                    }

                    // Render image at full size
                    hr = DrawAppearance(hdcVStemp, &rcVS, psysMet, _fOnlyActiveWindow, _fRTL); 

                    // Shrink image to fit on "monitor"
                    int iX = _rcInner.left + (_fShowIcons ? 10 : RECTWIDTH(_rcInner) - RECTWIDTH(rcVS));
                    BitBlt(hdcVS, iX, _rcInner.top, RECTWIDTH(rcVS), RECTHEIGHT(rcVS),
                           hdcVStemp, rcVS.left, rcVS.top, SRCCOPY);
                }

                // Free temporary variables and store off globals
                if (hdcVStemp)
                {
                    SelectObject(hdcVStemp, hbmOldVStemp);
                    DeleteDC(hdcVStemp);
                }
                if (hbmVStemp)
                {
                    DeleteObject(hbmVStemp);
                }
            }

            ReleaseDC(_hwndPrev, hdcTemp);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        if (_hbmVS)
        {
            DeleteObject(_hbmVS);
        }
        _hbmVS = hbmVS;
        hbmVS = NULL;

        _fMemIsDirty = TRUE;
        InvalidateRect(_hwndPrev, &_rcInner, FALSE);
    }

    if (hdcVS)
    {
        if (hbmOldVS)
        {
            SelectObject(hdcVS, hbmOldVS);
        }
        DeleteDC(hdcVS);
    }
    if (hbmVS)
    {
        DeleteObject(hbmVS);
    }

    return hr;
}


HRESULT CPreviewTheme::_putBackgroundBitmap(HBITMAP hbm)
{
    if (_hbmBack)
    {
        DeleteObject(_hbmBack);
        _hbmBack = NULL;
    }

    if (_hpalMem)
    {
        DeleteObject(_hpalMem);
        _hpalMem = NULL;
    }

    _hbmBack = hbm;

    if (_hbmBack)
    {
        BITMAP bm;
        GetObject(_hbmBack, sizeof(bm), &bm);

        if (GetDeviceCaps(_hdcMem, RASTERCAPS) & RC_PALETTE)
        {
            if (bm.bmBitsPixel * bm.bmPlanes > 8)
                _hpalMem = CreateHalftonePalette(_hdcMem);
            else if (bm.bmBitsPixel * bm.bmPlanes == 8)
                _PaletteFromDS(_hdcMem, &_hpalMem);
            else
                _hpalMem = NULL;  //!!! assume 1 or 4bpp images dont have palettes
        }
    }

    _fMemIsDirty = TRUE;
    InvalidateRect(_hwndPrev, &_rcInner, FALSE);

    return S_OK;
}

HRESULT CPreviewTheme::_putBackground(BSTR bstrBackground, BOOL fPattern, int iTileMode)
{
    if (fPattern)
    {
        TCHAR szBuf[MAX_PATH];

        // get rid of old brush if there was one
        if (_hbrBack)
            DeleteObject(_hbrBack);

        if (bstrBackground && lstrcmpi(bstrBackground, _szNone))
        {
            WORD patbits[CXYDESKPATTERN] = {0, 0, 0, 0, 0, 0, 0, 0};

            if (GetPrivateProfileString(TEXT("patterns"), bstrBackground, TEXT(""),
                                        szBuf, ARRAYSIZE(szBuf), TEXT("control.ini")))
            {
                _ReadPattern(szBuf, patbits);    
            }

            HBITMAP hbmTemp = CreateBitmap(8, 8, 1, 1, patbits);
            if (hbmTemp)
            {
                _hbrBack = CreatePatternBrush(hbmTemp);
                DeleteObject(hbmTemp);
            }
        }
        else
        {
            _hbrBack = CreateSolidBrush(_systemMetricsAll.schemeData.rgb[COLOR_BACKGROUND]);
        }
        if (!_hbrBack)
            _hbrBack = (HBRUSH) GetStockObject(BLACK_BRUSH);

        _fMemIsDirty = TRUE;
        InvalidateRect(_hwndPrev, &_rcInner, FALSE);
    }
    else
    {
        _iNewTileMode = iTileMode;
        return _GetWallpaperAsync(bstrBackground);
    }
    return S_OK;
}

/*-------------------------------------------------------------
** given a pattern string from an ini file, return the pattern
** in a binary (ie useful) form.
**-------------------------------------------------------------*/
HRESULT CPreviewTheme::_ReadPattern(LPTSTR lpStr, WORD FAR *patbits)
{
    short i, val;

    /* Get eight groups of numbers seprated by non-numeric characters. */
    for (i = 0; i < CXYDESKPATTERN; i++)
    {
        val = 0;
        if (*lpStr != TEXT('\0'))
        {
            /* Skip over any non-numeric characters. */
            while (!(*lpStr >= TEXT('0') && *lpStr <= TEXT('9')))
                lpStr++;

            /* Get the next series of digits. */
            while (*lpStr >= TEXT('0') && *lpStr <= TEXT('9'))
                val = val*10 + *lpStr++ - TEXT('0');
         }

        patbits[i] = val;
    }

    return S_OK;
}


/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
HRESULT CPreviewTheme::_PaletteFromDS(HDC hdc, HPALETTE* phPalette)
{
    DWORD adw[257];
    int i,n;

    n = GetDIBColorTable(hdc, 0, 256, (LPRGBQUAD)&adw[1]);
    adw[0] = MAKELONG(0x300, n);

    for (i=1; i<=n; i++)
        adw[i] = RGB(GetBValue(adw[i]),GetGValue(adw[i]),GetRValue(adw[i]));

    *phPalette = (n == 0) ? NULL : CreatePalette((LPLOGPALETTE)&adw[0]);

    return S_OK;
}

HRESULT CPreviewTheme::_DrawMonitor(HDC hdc)
{
    HBITMAP hbmT;
    HDC hdcMon;
    BITMAP bmMon;

    if (_hbmMon == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // convert the "base" of the monitor to the right color.
    //
    // the lower left of the bitmap has a transparent color
    // we fixup using FloodFill
    //
    hdcMon = CreateCompatibleDC(NULL);
    if (hdcMon)
    {
        hbmT = (HBITMAP) SelectObject(hdcMon, _hbmMon);

        GetObject(_hbmMon, sizeof(bmMon), &bmMon);

        FillRect(hdc, &_rcOuter, GetSysColorBrush(COLOR_3DFACE));
        DrawThemeParentBackground(_hwndPrev, hdc, NULL);
        TransparentBlt(hdc, _rcOuter.left + _cxMon, _rcOuter.top + _cyMon, bmMon.bmWidth, bmMon.bmHeight,
               hdcMon, 0, 0, bmMon.bmWidth, bmMon.bmHeight, RGB(255, 0, 255));

        // clean up after ourselves
        SelectObject(hdcMon, hbmT);
        DeleteDC(hdcMon);
    }

    return S_OK;
}

HRESULT CPreviewTheme::_DrawBackground(HDC hdc)
{
    // Draw Pattern first
    if (_hbrBack)
    {
        COLORREF clrOldText = SetTextColor(hdc, GetSysColor(COLOR_BACKGROUND));
        COLORREF clrOldBk = SetBkColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        HBRUSH hbr = (HBRUSH) SelectObject(hdc, _hbrBack);

        PatBlt(hdc, _rcInner.left, _rcInner.top, RECTWIDTH(_rcInner), RECTHEIGHT(_rcInner), PATCOPY);

        SelectObject(hdc, hbr);
        SetTextColor(hdc, clrOldText);
        SetBkColor(hdc, clrOldBk);
    }

    /// Start Draw Wall Paper
    if (_hbmBack && _fShowBack)
    {
        HDC hdcBack = CreateCompatibleDC(hdc);
        if (hdcBack)
        {
            HBITMAP hbmOldBack = (HBITMAP)SelectObject(hdcBack, _hbmBack);
            BITMAP bm;

            GetObject(_hbmBack, sizeof(bm), &bm);

            int dxBack = MulDiv(bm.bmWidth, RECTWIDTH(_rcInner), GetDeviceCaps(hdc, HORZRES));
            int dyBack = MulDiv(bm.bmHeight, RECTHEIGHT(_rcInner), GetDeviceCaps(hdc, VERTRES));

            if (dxBack < 1) dxBack = 1;
            if (dyBack < 1) dyBack = 1;

            if (_hpalMem)
            {
                SelectPalette(hdc, _hpalMem, TRUE);
                RealizePalette(hdc);
            }

            IntersectClipRect(hdc, _rcInner.left, _rcInner.top, _rcInner.right, _rcInner.bottom);
            SetStretchBltMode(hdc, COLORONCOLOR);

            if ((_iTileMode == WPSTYLE_TILE) && (!_fHTMLBitmap))
            {
                int i;
                StretchBlt(hdc, _rcInner.left, _rcInner.top, dxBack, dyBack,
                    hdcBack, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);

                for (i = _rcInner.left+dxBack; i < (_rcInner.left + RECTWIDTH(_rcInner)); i+= dxBack)
                    BitBlt(hdc, i, _rcInner.top, dxBack, dyBack, hdc, _rcInner.left, _rcInner.top, SRCCOPY);

                for (i = _rcInner.top; i < (_rcInner.top + RECTHEIGHT(_rcInner)); i += dyBack)
                    BitBlt(hdc, _rcInner.left, i, RECTWIDTH(_rcInner), dyBack, hdc, _rcInner.left, _rcInner.top, SRCCOPY);
            }
            else
            {
                //We want to stretch the Bitmap to the preview monitor size ONLY for new platforms.
                if ((_iTileMode == WPSTYLE_STRETCH) || (_fHTMLBitmap))
                {
                    //Stretch the bitmap to the whole preview monitor.
                    dxBack = RECTWIDTH(_rcInner);
                    dyBack = RECTHEIGHT(_rcInner);
                }
                //Center the bitmap in the preview monitor
                StretchBlt(hdc, _rcInner.left + (RECTWIDTH(_rcInner) - dxBack)/2, _rcInner.top + (RECTHEIGHT(_rcInner) - dyBack)/2,
                        dxBack, dyBack, hdcBack, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
            }

            // restore dc
            SelectPalette(hdc, (HPALETTE) GetStockObject(DEFAULT_PALETTE), TRUE);
            SelectClipRgn(hdc, NULL);

            SelectObject(hdcBack, hbmOldBack);
            DeleteDC(hdcBack);
        }
    }

    return S_OK;
}

HRESULT CPreviewTheme::_DrawVisualStyle(HDC hdc)
{
    if (_hbmVS)
    {
        HDC hdcVS = CreateCompatibleDC(hdc);
        if (hdcVS)
        {
            HBITMAP hbmOldVS = (HBITMAP)SelectObject(hdcVS, _hbmVS);

            TransparentBlt(hdc, _rcInner.left, _rcInner.top, RECTWIDTH(_rcInner), RECTHEIGHT(_rcInner), hdcVS, 0, 0, RECTWIDTH(_rcInner), RECTHEIGHT(_rcInner), RGB(255, 255, 0));

            SelectObject(hdcVS, hbmOldVS);
            DeleteDC(hdcVS);
        }
    }
    else
    {
        RECT rc;
        rc.left   = _fShowIcons ? 20 : 8;
        rc.right  = RECTWIDTH(_rcInner) - (_fShowIcons ? 100 : 8);
        rc.top    = _fShowIcons ? 10 : 8;
        rc.bottom = RECTHEIGHT(_rcInner) - (_fShowIcons ? 60 : 20);
        DrawNCPreview(hdc, NCPREV_ACTIVEWINDOW | (_fOnlyActiveWindow ? 0 : NCPREV_MESSAGEBOX | NCPREV_INACTIVEWINDOW) | (_fRTL ? NCPREV_RTL : 0) , &rc, _szVSPath, _szVSColor, _szVSSize, &(_systemMetricsAll.schemeData.ncm), (_systemMetricsAll.schemeData.rgb));
    }

    return S_OK;
}


HRESULT CPreviewTheme::_DrawIcons(HDC hdc)
{
    int y = RECTHEIGHT(_rcInner) - _systemMetricsAll.nIcon - 8;
    int x = RECTWIDTH(_rcInner) - _systemMetricsAll.nIcon - 20;

    DrawIcon(hdc, x, y, _iconList[3].hicon);

    return S_OK;
}

HRESULT CPreviewTheme::_Paint(HDC hdc)
{
    HPALETTE hpalOld = NULL;

    if (_fMemIsDirty)
    {
        if (_fRTL)
        {
            SetLayout(_hdcMem, LAYOUT_RTL);
        }

        // Rebuild Back Buffer
        if (_fShowMon)
            _DrawMonitor(_hdcMem);

        // Always draw the background, the Background switch turns the background
        // image on/off
        _DrawBackground(_hdcMem);

        if (_fShowIcons)
            _DrawIcons(_hdcMem);

        if (_fShowVS)
            _DrawVisualStyle(_hdcMem);

        _fMemIsDirty = FALSE;
    }

    if (_hdcMem)
    {
        if (_hpalMem)
        {
            hpalOld = SelectPalette(hdc, _hpalMem, FALSE);
            RealizePalette(hdc);
        }

        if (_fRTL)
        {
            SetLayout(hdc, LAYOUT_RTL);
        }

        BitBlt(hdc, _rcOuter.left, _rcOuter.top, RECTWIDTH(_rcOuter), RECTHEIGHT(_rcOuter), _hdcMem, 0, 0, SRCCOPY);

        if (_hpalMem)
        {
            SelectPalette(hdc, hpalOld, TRUE);
            RealizePalette(hdc);
        }
    }

    return S_OK;
}


DWORD CALLBACK UpdateWallProc(LPVOID pv)
{
    ASSERT(pv);
    if (pv)
    {
        PASYNCWALLPARAM pawp = (PASYNCWALLPARAM) pv;
        pawp->hbmp = (HBITMAP)LoadImage(NULL, pawp->szFile,
                                          IMAGE_BITMAP, 0, 0,
                                          LR_LOADFROMFILE|LR_CREATEDIBSECTION);

        if (pawp->hbmp)
        {
            // if all is good, then the window will handle cleaning up
            if (IsWindow(pawp->hwnd) && PostMessage(pawp->hwnd, WM_ASYNC_BITMAP, 0, (LPARAM)pawp))
                return TRUE;

            DeleteObject(pawp->hbmp);
        }

        LocalFree(pawp);
    }

    return TRUE;
}

const GUID CLSID_HtmlThumbnailExtractor = {0xeab841a0, 0x9550, 0x11cf, 0x8c, 0x16, 0x0, 0x80, 0x5f, 0x14, 0x8, 0xf3};

DWORD CALLBACK UpdateWallProcHTML(LPVOID pv)
{
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        ASSERT(pv);
        if (pv)
        {
            PASYNCWALLPARAM pawp = (PASYNCWALLPARAM) pv;
            IPersistFile *ppf;
            HRESULT hr = CoCreateInstance(CLSID_HtmlThumbnailExtractor, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                hr = ppf->Load(pawp->szFile, STGM_READ);
                if (SUCCEEDED(hr))
                {
                    IExtractImage *pei= NULL;
                    hr = ppf->QueryInterface(IID_PPV_ARG(IExtractImage, &pei));
                    if (SUCCEEDED(hr))
                    {
                        DWORD dwPriority = 0;
                        DWORD dwFlags = IEIFLAG_SCREEN | IEIFLAG_OFFLINE;
                        WCHAR szLocation[MAX_PATH];
                        HDC hdc = GetDC(NULL);
                        SIZEL rgSize = {GetDeviceCaps(hdc, HORZRES), GetDeviceCaps(hdc, VERTRES)};
                        ReleaseDC(NULL, hdc);
                        
                        hr = pei->GetLocation(szLocation, ARRAYSIZE(szLocation), &dwPriority, &rgSize, SHGetCurColorRes(), &dwFlags);
                        if (SUCCEEDED(hr))
                        {
                            HBITMAP hbm;
                            hr = pei->Extract(&hbm);
                            if (SUCCEEDED(hr))
                            {
                                if (!SendMessage(pawp->hwnd, WM_HTML_BITMAP, pawp->id, (LPARAM)hbm))
                                {
                                    DeleteObject(hbm);
                                }
                            }
                        }
                        pei->Release();
                    }
                }
                ppf->Release();
            }
     
            LocalFree(pawp);
        }
        CoUninitialize();
    }

    return TRUE;
}

//
// Determines if the wallpaper can be supported in non-active desktop mode.
//
BOOL CPreviewTheme::_IsNormalWallpaper(LPCWSTR pszFileName)
{
    BOOL fRet = TRUE;

    if (pszFileName[0] == TEXT('\0'))
    {
        fRet = TRUE;
    }
    else
    {
        LPTSTR pszExt = PathFindExtension(pszFileName);

        //Check for specific files that can be shown only in ActiveDesktop mode!
        if((lstrcmpi(pszExt, TEXT(".GIF")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".gif")) == 0) ||     // 368690: Strange, but we must compare 'i' in both caps and lower case.
           (lstrcmpi(pszExt, TEXT(".JPG")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".JPE")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".JPEG")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".PNG")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".HTM")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".HTML")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".HTT")) == 0))
           return FALSE;

        //Everything else (including *.BMP files) are "normal" wallpapers
    }
    return fRet;
}

//
// Determines if the wallpaper is a picture (vs. HTML).
//
BOOL CPreviewTheme::_IsWallpaperPicture(LPCWSTR pszWallpaper)
{
    BOOL fRet = TRUE;

    if (pszWallpaper[0] == TEXT('\0'))
    {
        //
        // Empty wallpapers count as empty pictures.
        //
        fRet = TRUE;
    }
    else
    {
        LPTSTR pszExt = PathFindExtension(pszWallpaper);

        if ((lstrcmpi(pszExt, TEXT(".HTM")) == 0) ||
            (lstrcmpi(pszExt, TEXT(".HTML")) == 0) ||
            (lstrcmpi(pszExt, TEXT(".HTT")) == 0))
        {
            fRet = FALSE;
        }
    }

    return fRet;
}

HRESULT CPreviewTheme::_LoadWallpaperAsync(LPCWSTR pszFile, DWORD dwID, BOOL bHTML)
{
    PASYNCWALLPARAM pawp = (PASYNCWALLPARAM) LocalAlloc(LPTR, SIZEOF(ASYNCWALLPARAM));
    HRESULT hr = E_OUTOFMEMORY;

    if (pawp)
    {
        pawp->hwnd = _hwndPrev;
        pawp->id = dwID;
        hr =  StringCchCopy(pawp->szFile, ARRAYSIZE(pawp->szFile), pszFile);
        
        if (SUCCEEDED(hr))
        {
            if (bHTML)
            {
                if (!SHQueueUserWorkItem(UpdateWallProcHTML, pawp, 0, (DWORD_PTR)0, (DWORD_PTR *)NULL, NULL, 0))
                {
                    LocalFree(pawp);
                }
            }
            else
            {
                if (!SHQueueUserWorkItem(UpdateWallProc, pawp, 0, (DWORD_PTR)0, (DWORD_PTR *)NULL, NULL, 0))
                {
                    LocalFree(pawp);
                }
            }
        }
    }

    return S_OK;
}

HRESULT CPreviewTheme::_GetWallpaperAsync(LPWSTR psz)
{
    HRESULT hr = S_OK;
    WCHAR wszWallpaper[INTERNET_MAX_URL_LENGTH];
    LPWSTR pszWallpaper = psz;
    _dwWallpaperID++;

    if (*pszWallpaper && lstrcmpi(pszWallpaper, _szNone))
    {
        if (_IsNormalWallpaper(pszWallpaper))
        {
            _LoadWallpaperAsync(pszWallpaper, _dwWallpaperID, FALSE);
        }
        else
        {
            if(_IsWallpaperPicture(pszWallpaper))
            {
                pszWallpaper = wszWallpaper;
                // This is a picture (GIF, JPG etc.,)
                // We need to generate a small HTML file that has this picture
                // as the background image.
                //
                // Compute the filename for the Temporary HTML file.
                //
                GetTempPath(ARRAYSIZE(wszWallpaper), wszWallpaper);
                StringCchCat(wszWallpaper, ARRAYSIZE(wszWallpaper), PREVIEW_PICTURE_FILENAME);
                //
                // Generate the preview picture html file.
                //
                if (!_pActiveDesk)
                {
                    hr = _GetActiveDesktop(&_pActiveDesk);
                }

                if (SUCCEEDED(hr))
                {
                    _pActiveDesk->SetWallpaper(psz, 0);

                    WALLPAPEROPT wpo = { sizeof(WALLPAPEROPT) };
                    wpo.dwStyle = _iNewTileMode;
                    _pActiveDesk->SetWallpaperOptions(&wpo, 0);

                    _pActiveDesk->GenerateDesktopItemHtml(wszWallpaper, NULL, 0);
                }
            }

            _LoadWallpaperAsync(pszWallpaper, _dwWallpaperID, TRUE);
        }
    }
    else
    {
        _putBackgroundBitmap(NULL);
    }

    return hr;
}

HRESULT CPreviewTheme::_GetActiveDesktop(IActiveDesktop ** ppActiveDesktop)
{
    HRESULT hr = S_OK;

    if (!*ppActiveDesktop)
    {
        IActiveDesktopP * piadp;

        if (SUCCEEDED(hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktopP, &piadp)) ))
        {
            WCHAR wszScheme[MAX_PATH];
            DWORD dwcch = ARRAYSIZE(wszScheme);

            // Get the global "edit" scheme and set ourselves us to read from and edit that scheme
            if (SUCCEEDED(piadp->GetScheme(wszScheme, &dwcch, SCHEME_GLOBAL | SCHEME_EDIT)))
            {
                piadp->SetScheme(wszScheme, SCHEME_LOCAL);
                
            }
            hr = piadp->QueryInterface(IID_PPV_ARG(IActiveDesktop, ppActiveDesktop));
            piadp->Release();
        }
    }
    else
    {
        (*ppActiveDesktop)->AddRef();
    }

    return hr;
}

HRESULT CThemePreview_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (punkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    if (ppvObj)
    {
        CPreviewTheme * pObject = new CPreviewTheme();

        *ppvObj = NULL;
        if (pObject)
        {
            hr = pObject->_Init();
            if (SUCCEEDED(hr))
            {
                hr = pObject->QueryInterface(riid, ppvObj);
            }
            pObject->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\previewth.h ===
/*****************************************************************************\
    FILE: PreviewTh.h

    DESCRIPTION:
        This code will display a preview of the currently selected
    visual styles.

    BryanSt 5/5/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _PREVIEWTHEME_H
#define _PREVIEWTHEME_H

#include <cowsite.h>
#include "classfactory.h"

#define MAX_PREVIEW_ICONS 4

class CPreviewTheme             : public CObjectWithSite
                                , public IThemePreview
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemePreview ***
    virtual STDMETHODIMP UpdatePreview(IN IPropertyBag * pPropertyBag);
    virtual STDMETHODIMP CreatePreview(IN HWND hwndParent, IN DWORD dwFlags, IN DWORD dwStyle, IN DWORD dwExStyle, IN int x, IN int y, IN int nWidth, IN int nHeight, IN IPropertyBag * pPropertyBag, IN DWORD dwCtrlID);

    STDMETHODIMP _Init(void);
    CPreviewTheme();
protected:

private:
    virtual ~CPreviewTheme(void);

    // Private Member Variables
    long                m_cRef;
    ITheme *            m_pTheme;
    IThemeScheme *      m_pScheme;
    IThemeStyle *       m_pStyle;
    IThemeSize *        m_pSize;
    HWND                _hwndPrev;
    TCHAR               _szNone[CCH_NONE];  // this is the '(None)' string
    RECT                _rcOuter;           // Size of double buffer bitmap
    RECT                _rcInner;           // Size of region within the "monitor"

    // Double buffering globals
    HDC                 _hdcMem;            // memory DC
    HPALETTE            _hpalMem;           // palette that goes with hbmBack bitmap
    BOOL                _fMemIsDirty;       // Dirty flag for image cache
    BOOL                _fRTL;

    // Monitor globals 
    BOOL                _fShowMon;
    int                 _cxMon;
    int                 _cyMon;
    HBITMAP             _hbmMon;

    // Background globals
    WCHAR               _szBackgroundPath[MAX_PATH];
    BOOL                _fShowBack;
    int                 _iTileMode;
    BOOL                _fHTMLBitmap;
    int                 _iNewTileMode;      // This is the new value to be used when the images is recieved
    DWORD               _dwWallpaperID;
    HBITMAP             _hbmBack;           // bitmap image of wallpaper
    HBRUSH              _hbrBack;           // brush for the desktop background
    IThumbnail*         _pThumb;
    IActiveDesktop *    _pActiveDesk;

    // Visual Style globals
    WCHAR               _szVSPath[MAX_PATH];
    WCHAR               _szVSColor[MAX_PATH];
    WCHAR               _szVSSize[MAX_PATH];
    SYSTEMMETRICSALL    _systemMetricsAll;
    BOOL                _fShowVS;
    HBITMAP             _hbmVS;             // bitmp for Visual Style
    BOOL                _fOnlyActiveWindow;

    // Icon globals
    BOOL                _fShowIcons;
    typedef struct ICONLISTtag {
        HICON hicon;
        WCHAR szName[MAX_PATH];
    } ICONLIST;
    ICONLIST _iconList[MAX_PREVIEW_ICONS];

    // Taskbar globals
    BOOL                _fShowTaskbar;
    BOOL                _fAutoHide;
    BOOL                _fShowClock;
    BOOL                _fGlomming;
    HWND                _hwndTaskbar;

    // Private Member Functions
    BOOL _RegisterThemePreviewClass(HINSTANCE hInst);
    static LRESULT ThemePreviewWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _ThemePreviewWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
    
    STDMETHODIMP _putBackground(IN BSTR bstrWallpaper, IN BOOL fPattern, IN int iTileMode);
    STDMETHODIMP _putVisualStyle(LPCWSTR pszVSPath, LPCWSTR pszVSColor, LPCWSTR pszVSSize, SYSTEMMETRICSALL* psysMet);
    STDMETHODIMP _putIcons(IPropertyBag* pPropertyBag);

    STDMETHODIMP _ReadPattern(LPTSTR lpStr, WORD FAR *patbits);
    STDMETHODIMP _PaletteFromDS(HDC hdc, HPALETTE* phPalette);

    STDMETHODIMP _DrawMonitor(HDC hdc);
    STDMETHODIMP _DrawBackground(HDC hdc);
    STDMETHODIMP _DrawVisualStyle(HDC hdc);
    STDMETHODIMP _DrawIcons(HDC hdc);
    STDMETHODIMP _DrawTaskbar(HDC hdc);

    STDMETHODIMP _Paint(HDC hdc);

    STDMETHODIMP _putBackgroundBitmap(HBITMAP hbm);

    BOOL         _IsNormalWallpaper(LPCWSTR pszFileName);
    BOOL         _IsWallpaperPicture(LPCWSTR pszWallpaper);
    STDMETHODIMP _LoadWallpaperAsync(LPCWSTR pszFile, DWORD dwID, BOOL bHTML);
    STDMETHODIMP _GetWallpaperAsync(LPWSTR pszWallpaper);
    STDMETHODIMP _GetActiveDesktop(IActiveDesktop ** ppActiveDesktop);
};

#endif // _PREVIEWTHEME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\priv.h ===
/*****************************************************************************\
    FILE: priv.h

    DESCRIPTION:
        This is the precompiled header for themeui.dll.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _PRIV_H_
#define _PRIV_H_


/*****************************************************************************\

      Global Includes
\*****************************************************************************/

#define WIN32_LEAN_AND_MEAN
#define NOIME
#define NOSERVICE

// This stuff must run on Win95
#define _WIN32_WINDOWS      0x0400

#ifndef WINVER
#define WINVER              0x0400
#endif // WINVER


#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED
#undef _ATL_DLL
#undef _ATL_DLL_IMPL
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <windows.h>

#include <windowsx.h>

#include "resource.h"
#include "coverwnd.h"

#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
//WinInet need to be included BEFORE ShlObjp.h
#include <wininet.h>
#include <urlmon.h>
#include <shlobj.h>
#include <exdisp.h>
#include <objidl.h>

#include <shellids.h>       // Help IDs
#include <shlwapi.h>
#include <shlwapip.h>

// HACKHACK: For the life of me, I can't get shlwapip.h to include the diffinitions of these.
//    I'm giving up and putting them inline.  __IOleAutomationTypes_INTERFACE_DEFINED__ and
//    __IOleCommandTarget_INTERFACE_DEFINED__ need to be defined, which requires oaidl.h,
//    which requires hlink.h which requires rpcndr.h to come in the right order.  Once I got that
//    far I found it still didn't work and a lot of more stuff is needed.  The problem
//    is that shlwapi (exdisp/dspsprt/expdsprt/cnctnpt) or ATL will provide impls for
//    IConnectionPoint & IConnectionPointContainer, but one will conflict with the other.
LWSTDAPI IConnectionPoint_SimpleInvoke(IConnectionPoint *pcp, DISPID dispidMember, DISPPARAMS * pdispparams);
LWSTDAPI IConnectionPoint_OnChanged(IConnectionPoint *pcp, DISPID dispid);
LWSTDAPIV IUnknown_CPContainerInvokeParam(IUnknown *punk, REFIID riidCP, DISPID dispidMember, VARIANTARG *rgvarg, UINT cArgs, ...);

#include <shellapi.h>

#include <shsemip.h>
#include <crtfree.h>

#include <ole2ver.h>
#include <olectl.h>
#include <shellp.h>
#include <shdocvw.h>
#include <commdlg.h>
#include <shguidp.h>
#include <isguids.h>
#include <shdguid.h>
#include <mimeinfo.h>
#include <hlguids.h>
#include <mshtmdid.h>
#include <msident.h>
#include <msxml.h>
#include <Theme.h>                  // For ITheme interfaces
#include <perhist.h>
#include <regapix.h>
#include <shsemip.h>
#include <shfusion.h>               // For SHFusionInitialize()/SHFusionUninitialize()


#include <help.h>

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <urlhist.h>

#include <setupapi.h>
#include <cfgmgr32.h>
#include <syssetup.h>

#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#define USE_SYSTEM_URL_MONIKER
#include <urlmon.h>
#include <inetreg.h>

#define _INTSHCUT_    // get DECLSPEC_IMPORT stuff right for INTSHCUT.h
#include <intshcut.h>

#define HLINK_NO_GUIDS
#include <hlink.h>
#include <hliface.h>
#include <docobj.h>
#include <ccstock.h>
#include <port32.h>

#include <commctrl.h>
#include <shpriv.h>
#include <Prsht.h>


// Include the automation definitions...
#include <exdisp.h>
#include <exdispid.h>
#include <ocmm.h>
#include <mshtmhst.h>
#include <simpdata.h>
#include <htiface.h>
#include <objsafe.h>

#include <dspsprt.h>
#include <cowsite.h>
#include <cobjsafe.h>
#include <objclsid.h>
#include <objwindow.h>

#include <guids.h>
#include <tmschema.h>
#include <uxtheme.h>
#include <uxthemep.h>
#include "deskcmmn.h"

#include <cowsite.h>

#include <strsafe.h>

/*****************************************************************************\
 *      Local Includes
\*****************************************************************************/
// Include frequently used headers.
#include "util.h"
#include "theme.h"
#include "regutil.h"
#include "themefile.h"
#include <themeldr.h>
#include "themeutils.h"
#include "appScheme.h"
#include "thScheme.h"
#include "PreviewSM.h"
#include "deskcplext.h"
#include "dragsize.h"
#include "coverwnd.h"
#include "settings.h"
#include "advdlg.h"
#include "fontfix.h"
#include <tmreg.h>

// Trace flags
#define TF_WMTHEME          0x00000100      // Themes
#define TF_THEMEUI_PERF     0x00000200      // Perf
#define TF_DUMP_DEVMODE     0x00000400
#define TF_DUMP_CSETTINGS   0x00000800
#define TF_THEMEUI_SYSMETRICS   0x00001000      // Perf

#include <w4warn.h>

/*****************************************************************************\

 *
 *      Global Helper Macros/Typedefs
 *
\*****************************************************************************/

EXTERN_C HINSTANCE g_hinst;   // My instance handle
#define HINST_THISDLL g_hinst


STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);


#define CALLWNDPROC WNDPROC


#define MAX_PAGES               100

// Detect "." or ".." as invalid files
#define IS_VALID_FILE(str)        (!(('.' == str[0]) && (('\0' == str[1]) || (('.' == str[1]) && ('\0' == str[2])))))


/*****************************************************************************\
 *
 *      Global state management.
 *
 *      DLL reference count, DLL critical section.
 *
\*****************************************************************************/

void DllAddRef(void);
void DllRelease(void);


#define NULL_FOR_EMPTYSTR(str)          (((str) && (str)[0]) ? str : NULL)

typedef void (*LISTPROC)(UINT flm, LPVOID pv);

#define RECTWIDTH(rc)  ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)

/*****************************************************************************\
 *      Local Includes
\*****************************************************************************/


// This is defined in WININET.CPP
typedef LPVOID HINTERNET;
typedef HGLOBAL HIDA;


#define QW_MAC              0xFFFFFFFFFFFFFFFF

#define INTERNET_MAX_PATH_LENGTH        2048
#define INTERNET_MAX_SCHEME_LENGTH      32          // longest protocol name length
#define MAX_URL_STRING                  (INTERNET_MAX_SCHEME_LENGTH \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)

#define SZ_EMPTY                        TEXT("")
#define EMPTYSTR_FORNULL(str)           ((str) ? (str) : SZ_EMPTY)



//  Features (This is where they are turned on and off)

// With this feature on, we demote the advanced appearances
// options into an "Advanced" subdialog.
#define FEATURE_DEMOTE_ADVANCED_APPEAROPTIONS

// The uxtheme visual style code has problems with being compatible
// with system metrics.  Apps will get system metric sizes (like captionbar height)
// and paint accordingly.  If uxtheme paints correctly, it will
// use the captionbar height and be compatible with the app.
// If it cannot do this, then the .msstyles file specifies system metrics
// that do work and we try to discourage the user from changing the
// system metrics to other values by disabling the advanced button
// on the Appearance tab.  This is a hack because the user can
// change the values in via USER32 directly.
#define FEATURE_ENABLE_ADVANCED_WITH_SKINSON


// When selecting certain legacy color schemes, like "High Contrast Black", the SPI_SETHIGHCONTRAST
// bit should be set.  This wasn't done in Win2k but should be done.
// This is currently turned off until MicW will implement a flag for SPI_SETHIGHCONTRAST
// that will prevent sethc.exe from running.
//#define FEATURE_SETHIGHCONTRASTSPI


#ifndef _WIN64
#define ENABLE_IA64_VISUALSTYLES
#else // _WIN64
// We don't want to install the theme files that require visual styles since
// they aren't supported on ia64 (yet).  Win #175788
//#define ENABLE_IA64_VISUALSTYLES
#endif // _WIN64



// String Constants
// Registry
#define SZ_WINDOWMETRICS        TEXT("Control Panel\\Desktop\\WindowMetrics")
#define SZ_APPLIEDDPI           TEXT("AppliedDPI")

// PropertyBag Propertyes
#define SZ_PBPROP_APPLY_THEMEFILE           TEXT("Theme_ApplySettings")         // When this is sent to a CThemeFile object, it will apply the settings that haven't been pulled out of it and placed in other Display Control Panel tabs.
#define SZ_PBPROP_THEME_FILTER              TEXT("ThemeFilter:")                // The filter values of what parts of themes to apply.
#define SZ_PBPROP_THEME_DISPLAYNAME         TEXT("Theme_DisplayName")           // Get the Theme display name for the currently selected item.
#define SZ_PBPROP_THEME_SETSELECTION        TEXT("Theme_SetSelectedEntree")     // Set the item in the drop down and persist.  The VT_BSTR
#define SZ_PBPROP_THEME_LOADTHEME           TEXT("Theme_LoadTheme")             // Load the theme specified by the VT_BSTR value
#define SZ_PBPROP_VSBEHAVIOR_FLATMENUS      TEXT("VSBehavior_FlatMenus")        // Does this visual style file want to use Flat menus (SPI_SETFLATMENUS)?
#define SZ_PBPROP_COLORSCHEME_LEGACYNAME    TEXT("ColorScheme_LegacyName")      // VT_BSTR specifying the Legacy name.  Like "Lilac (Large)"
#define SZ_PBPROP_EFFECTS_MENUDROPSHADOWS   TEXT("Effects_MenuDropShadows")     // VT_BOOL specifying if MenuDropShadows in on
#define SZ_PBPROP_HASSYSMETRICS             TEXT("Theme_HasSystemMetrics")      // VT_BOOL specifying if MenuDropShadows in on


#define SIZE_THEME_FILTER_STR               (ARRAYSIZE(SZ_PBPROP_THEME_FILTER) - 1)


// Parsing Characters
#define CH_ADDRESS_SEPARATOR       L';'
#define CH_ADDRESS_QUOTES          L'"'
#define CH_EMAIL_START             L'<'
#define CH_EMAIL_END               L'>'
#define CH_EMAIL_AT                L'@'
#define CH_EMAIL_DOMAIN_SEPARATOR  L'.'
#define CH_HTML_ESCAPE             L'%'
#define CH_COMMA                   L','


#define COLLECTION_SIZE_UNINITIALIZED           -1

/*****************************************************************************\
        Object Constructors
\*****************************************************************************/
HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);
HRESULT CThemeUIPages_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);


#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\screenresfixer.cpp ===
#include "priv.h"
#include <regstr.h>
#include <atlcom.h>
#include <shguidp.h>
#include <shlguid.h>

typedef struct
{
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwColor;
    BOOL fAvailable;
} SCREENMODE;

class ATL_NO_VTABLE CScreenResFixer :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CScreenResFixer, &CLSID_ScreenResFixer>,
    public IContextMenu,
    public IScreenResFixer
{
public:
    CScreenResFixer() {}
    virtual ~CScreenResFixer() {}

    DECLARE_NOT_AGGREGATABLE(CScreenResFixer)

    BEGIN_COM_MAP(CScreenResFixer)
        COM_INTERFACE_ENTRY_IID(IID_IContextMenu, IContextMenu)
        COM_INTERFACE_ENTRY(IScreenResFixer)
    END_COM_MAP()

    // *** IContextMenu methods ***
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT iIndexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags) { return E_NOTIMPL; }
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax) { return E_NOTIMPL; }

private:
    int _PickScreenResolution(SCREENMODE* modes, int cModes);
    HRESULT _FixScreenResolution(BOOL fShowDisplayCPL);
};

// *** IContextMenu methods ***
STDMETHODIMP CScreenResFixer::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    WCHAR szTitle[256];
    HRESULT hr;

    szTitle[0] = 0;
    LoadString(HINST_THISDLL, IDS_SCREENRESFIXER_TITLE, szTitle, ARRAYSIZE(szTitle));

    BOOL fOK = FALSE;
    if (lpici)
    {
        WCHAR szText[512];
        szText[0] = 0;
        LoadString(HINST_THISDLL, IDS_SCREENRESFIXER_TEXT, szText, ARRAYSIZE(szText));
        fOK = (IDYES == SHMessageBoxCheck(NULL, szText, szTitle, MB_YESNO, 0, TEXT("ScreenCheck")));
    }
    else
    {
        WCHAR szText[512];
        szText[0] = 0;
        LoadString(HINST_THISDLL, IDS_SCREENRESFIXER_ALTTEXT, szText, ARRAYSIZE(szText));
        fOK = (IDOK == MessageBox(NULL, szText, szTitle, MB_OK));
    }

    if (fOK)
    {
        hr = _FixScreenResolution(!(lpici == NULL));
    }
    else
    {
        // If the user checked "Don't show me again" then force this setting into HKLM, so that it doesn't
        // show up for any users
        if (!SHRegGetBoolUSValue(REGSTR_PATH_EXPLORER TEXT("\\DontShowMeThisDialogAgain"), TEXT("ScreenCheck"), FALSE, TRUE))
        {
            SHRegSetUSValueW(REGSTR_PATH_EXPLORER TEXT("\\DontShowMeThisDialogAgain"), TEXT("ScreenCheck"), REG_SZ, L"no", sizeof(L"no"), SHREGSET_HKLM);
        }

        hr = S_OK;
    }

    // Now that the user finished with their screen resolution, tell the Start Menu
    // it's okay to pop up.
    HWND hwndTray = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), NULL);
    if (hwndTray)
        PostMessage(hwndTray, RegisterWindowMessage(TEXT("Welcome Finished")), 0, 0);

    return hr;
}

int CScreenResFixer::_PickScreenResolution(SCREENMODE* modes, int cModes)
{
    static const struct {
        int iMinWidth;
        int iMinHeight;
        int iMaxWidth;
        int iMaxHeight;
        int iIdealColor;
    } 
    picker[] = 
    {
        {  800, 600, 1024, 768, 32 },
        {  800, 600, 1024, 768, 24 },
        {  800, 600, 1024, 768, -1 },
        { 1024, 768,   -1,  -1, 32 },
        { 1024, 768,   -1,  -1, 24 },
        { 1024, 768,   -1,  -1, -1 },
    };

    for (int i = 0; i < ARRAYSIZE(picker); i++)
    {
        // Try for Ideal Color in given resolution range
        for (int iMode = 0; iMode < cModes; iMode++)
        {
            
            if ((modes[iMode].fAvailable) &&
                (modes[iMode].dwWidth >= (DWORD)picker[i].iMinWidth) &&
                (modes[iMode].dwHeight >= (DWORD)picker[i].iMinHeight))
            {
                if ((picker[i].iMaxWidth == -1) ||
                    ((modes[iMode].dwWidth < (DWORD)picker[i].iMaxWidth) &&
                     (modes[iMode].dwHeight < (DWORD)picker[i].iMaxHeight)))
                {
                    if (((picker[i].iIdealColor == -1) && (modes[iMode].dwColor >= 15)) ||
                        (modes[iMode].dwColor == (DWORD)picker[i].iIdealColor))
                    {
                        return iMode;
                    }
                }
            }
        }
    }

    return -1;
}

void UpdateRecycleBinInfo()
{
    static const LPTSTR lpszSubkey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ScreenResFixer");
    static const LPTSTR lpszValue = TEXT("AdjustRecycleBinPosition");

    //Read if the we have done it once already.
    DWORD dwAdjustPos = 0; //Assume that Recycle-bin has been already positioned.
    DWORD dwSize = sizeof(dwAdjustPos);
    
    SHRegGetUSValue(lpszSubkey, lpszValue, NULL, &dwAdjustPos, &dwSize, FALSE, &dwAdjustPos, dwSize);
    // 0 => Recycle-bin hasn't been positioned because of resolution fixer.
    // 1 => Recycle-bin needs to be repositioned. It has't happened yet!
    // 2 => Recycle-bin has already been re-positioned. Nothing needs to be done here!
    if(dwAdjustPos == 0)
    {
        // 0 => Recycle-bin hasn't been positioned because of resolution fixer.
        // So, we need to change the settings sothat when desktop.cpp responds to res change,
        // it will position the recycle-bin.
        dwAdjustPos = 1;
        SHRegSetUSValue(lpszSubkey, lpszValue, REG_DWORD, &dwAdjustPos, sizeof(dwAdjustPos), SHREGSET_HKCU | SHREGSET_FORCE_HKCU);
    }
}

HRESULT CScreenResFixer::_FixScreenResolution(BOOL fShowDisplayCPL)
{
    IDisplaySettings * pds;

    HRESULT hr = CoCreateInstance(CLSID_DisplaySettings, NULL, CLSCTX_INPROC_SERVER,
                 IID_PPV_ARG(IDisplaySettings, &pds));

    if (SUCCEEDED(hr))
    {
        for (DWORD dwMon = 0; SUCCEEDED(pds->SetMonitor(dwMon)); dwMon++)
        {
            BOOL fAttached = FALSE;
            hr = pds->GetAttached(&fAttached);
            if (SUCCEEDED(hr) && fAttached)
            {
                DWORD dwWidth, dwHeight, dwColor;
                hr = pds->GetSelectedMode(&dwWidth, &dwHeight, &dwColor);
                if (SUCCEEDED(hr) && ((dwWidth < 800) || (dwHeight < 600) || (dwColor < 15)))
                {
                    DWORD cModes = 0;
                    hr = pds->GetModeCount(&cModes, TRUE);

                    if (SUCCEEDED( hr ) && (cModes > 0))
                    {
                        SCREENMODE* modes = new SCREENMODE[cModes];
                        if (modes)
                        {
                            for (DWORD i = 0; i < cModes; i++)
                            {
                                hr = pds->GetMode(i, TRUE, &modes[i].dwWidth, &modes[i].dwHeight, &modes[i].dwColor);
                                modes[i].fAvailable =  SUCCEEDED(hr) && ((i <= 0) || 
                                                        (modes[i].dwWidth != modes[i-1].dwWidth) ||
                                                        (modes[i].dwHeight != modes[i-1].dwHeight) ||
                                                        (modes[i].dwColor != modes[i-1].dwColor));
                            }

                            int iMode = _PickScreenResolution(modes, cModes);
                            if (iMode != -1)
                            {
                                static BOOL fRecycleBinInfoUpdated = FALSE; //to begin with!
                                //We are about to change the mode. Make a note in registry
                                if(!fRecycleBinInfoUpdated)
                                {
                                    UpdateRecycleBinInfo();
                                    fRecycleBinInfoUpdated = TRUE;
                                }
                                
                                BOOL fApplied = FALSE;
                                pds->SetSelectedMode(NULL, modes[iMode].dwWidth, modes[iMode].dwHeight, modes[iMode].dwColor, &fApplied, fShowDisplayCPL ? DS_BACKUPDISPLAYCPL : 0);
                                if (!fApplied)
                                {
                                    hr = E_FAIL;
                                }
                            }

                            delete [] modes;
                            modes = NULL;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CScreenResFixer_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (!punkOuter && ppvObj)
    {
        CComObject<CScreenResFixer> * pThis = new CComObject<CScreenResFixer>();

        *ppvObj = NULL;
        if (pThis)
        {
            hr = pThis->QueryInterface(riid, ppvObj);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\screenresfixer.h ===
#ifndef SCREENRESFIXER_H
#define SCREENRESFIXER_H

HRESULT CScreenResFixer_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);

typedef struct
{
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwColor;
    BOOL fAvailable;
} SCREENMODE;

class CScreenResFixer : public IContextMenu
{
public:
    // *** IUnknown methods
    STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IContextMenu methods ***
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT iIndexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags) { return E_NOTIMPL; }
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax) { return E_NOTIMPL; }

private:
    LONG _cRef;

    int _PickScreenResolution(SCREENMODE* modes, int cModes);
    void _FixScreenResolution(BOOL fShowDisplayCPL);
};

#endif // SCREENRESFIXER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\screensaverpg.cpp ===
/*****************************************************************************\
    FILE: ScreenSaverPg.cpp

    DESCRIPTION:
        This file contains the COM object implementation that will display the
    ScreenSaver tab in the Display Control Panel.

    18-Feb-94   (Tracy Sharpe) Added power management functionality.
               Commented out several pieces of code that weren't being
               used.
    5/30/2000 (Bryan Starbuck) BryanSt: Turned into C++ and COM.  Exposed
              as an API so other tabs can communicate with it.  This enables
              the Plus! Theme page to modify the screen saver.
    11/08/2000 (Bryan Starbuck) BryanSt: Moved from \nt\shell\cpls\desknt5 to
              \nt\shell\themes\themeui\.

    Copyright (C) Microsoft Corp 1994-2000. All rights reserved.
\*****************************************************************************/


#include "priv.h"
#pragma hdrstop

#include <scrnsave.h>

#include "exe.h"
#include "ScreenSaverPg.h"
#include <MSGinaExports.h>  // for ShellIsFriendlyUIActive, etc..


#define         SFSE_SYSTEM     0
#define         SFSE_PRG        1
#define         SFSE_WINDOWS    2
#define         SFSE_FILE       3

#define         MAX_METHODS     100
#define         MIN_MINUTES     1
#define         MAX_MINUTES     9999    //The UI will allow upto four digits. 
#define         BUFFER_SIZE     400

#define WMUSER_SETINITSS        (WM_USER + 1)

/* Local funcprototypes... */
void  SearchForScrEntries     ( UINT, LPCTSTR );
BOOL  FreeScrEntries          ( void );
int   lstrncmp                ( LPTSTR, LPTSTR, int );
LPTSTR FileName                ( LPTSTR szPath);
LPTSTR StripPathName           ( LPTSTR szPath);
LPTSTR NiceName                ( LPTSTR szPath);

void  AddBackslash(LPTSTR pszPath, DWORD cchPath);
void  AppendPath(LPTSTR pszPath, DWORD cchPath, LPTSTR pszSpec);

PTSTR  PerformCheck(LPTSTR, BOOL);
void  DoScreenSaver(HWND hDlg, BOOL b);

void ScreenSaver_AdjustTimeouts(HWND hWnd,int BaseControlID);
void EnableDisablePowerDelays(HWND hDlg);

TCHAR   g_szSaverName[MAX_PATH];                    // Screen Saver EXE
HICON  hDefaultIcon = NULL;
HICON  hIdleWildIcon;
BOOL    bWasConfig=0;   // We were configing the screen saver
HWND    g_hwndTestButton;
HWND    g_hwndLastFocus;
BOOL    g_fPasswordWasPreviouslyEnabled = FALSE;
BOOL    g_fPasswordDirty = FALSE;                   // tells us if the user has actually changed the state of the password combobox
BOOL    g_fFriendlyUI = FALSE;                 // is winlogon going to switch back to the welcome screen, or call LockWorkStation for real?
BOOL    g_fPasswordBoxDeterminedByPolicy = FALSE;
BOOL    g_fSettingsButtonOffByPolicy = FALSE;
BOOL    g_fTimeoutDeterminedByPolicy = FALSE;
BOOL    g_fScreenSaverExecutablePolicy = FALSE;
// Local global variables

HICON  hIcons[MAX_METHODS];
UINT   wNumMethods = 0;
PTSTR   aszMethods[MAX_METHODS];
PTSTR   aszFiles[MAX_METHODS];

static const TCHAR c_szDemoParentClass[] = TEXT("SSDemoParent");

//  static TCHAR szFileNameCopy[MAX_PATH];
static int  g_iMethod;
static BOOL g_fPreviewActive;
static BOOL g_fAdapPwrMgnt = FALSE;

/*
 * Registry value for the "Password Protected" check box
 *
 * These are different for NT and Win95 to keep screen
 * savers built exclusivly for Win95 from trying to
 * handle password checks.  (NT does all password checking
 * in the built in security system to maintain C2
 * level security)
 */

#   define SZ_USE_PASSWORD     TEXT("ScreenSaverIsSecure")
#   define PWRD_REG_TYPE       REG_SZ
#   define CCH_USE_PWRD_VALUE  2
#   define CB_USE_PWRD_VALUE   (CCH_USE_PWRD_VALUE * sizeof(TCHAR))
TCHAR gpwdRegYes[CCH_USE_PWRD_VALUE] = TEXT("1");
TCHAR gpwdRegNo[CCH_USE_PWRD_VALUE]  = TEXT("0");
#define PasswdRegData(f)    ((f) ? (PBYTE)gpwdRegYes : (PBYTE)gpwdRegNo)

UDACCEL udAccel[] = {{0,1},{2,5},{4,30},{8,60}};

#include "help.h"

#define IDH_DESK_LOWPOWERCFG IDH_SCRSAVER_GRAPHIC

//  To simplify some things, the base control ID of a time control is associated
//  with its corresponding ClassicSystemParametersInfo action codes.
typedef struct {
    int taBaseControlID;
    UINT taGetTimeoutAction;
    UINT taSetTimeoutAction;
    UINT taGetActiveAction;
    UINT taSetActiveAction;
}   TIMEOUT_ASSOCIATION;

//  Except for the case of the "screen save" delay, each time grouping has three
//  controls-- a switch to determine whether that time should be used or not and
//  an edit box and an updown control to change the delay time.  ("Screen save"
//  is turned off my choosing (None) from the screen saver list)  These three
//  controls must be organized as follows:
#define BCI_DELAY               0
#define BCI_ARROW               1
#define BCI_SWITCH              2

//  Associations between base control IDs and ClassicSystemParametersInfo action codes.
//  The TA_* #defines are used as symbolic indexes into this array.  Note that
//  TA_SCREENSAVE is a special case-- it does NOT have a BCI_SWITCH.
#define TA_SCREENSAVE           0

TIMEOUT_ASSOCIATION g_TimeoutAssociation[] = {
    IDC_SCREENSAVEDELAY, SPI_GETSCREENSAVETIMEOUT, SPI_SETSCREENSAVETIMEOUT,
    SPI_GETSCREENSAVEACTIVE, SPI_SETSCREENSAVEACTIVE,
};

int g_Timeout[] = {
    0,
    0,
    0,
};

HBITMAP g_hbmDemo = NULL;
HBITMAP g_hbmEnergyStar = NULL;
BOOL g_bInitSS = TRUE;          // assume we are in initialization process
BOOL g_bChangedSS = FALSE;      // changes have been made






class CScreenSaverPg            : public CObjectWithSite
                                , public CObjectCLSID
                                , public IBasePropPage
                                , public IPropertyBag
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IBasePropPage ***
    virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
    virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam) {return E_NOTIMPL;}

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

protected:

private:
    CScreenSaverPg();

    // Private Member Variables
    LONG                    m_cRef;

    BOOL                    m_fSecure;
    BOOL                    m_fUIInitialized;           // Have we activated the UI tab and loaded the UI controls with state?
    BOOL                    m_fScreenSavePolicy;
    BOOL                    m_fScreenSaveActive;
    LONG                    m_lWaitTime;
    HWND                    m_hDlg;



    // Private Member Functions
    HRESULT _InitState(void);
    BOOL _InitSSDialog(HWND hDlg);
    HRESULT _OnSetActive(void);
    HRESULT _OnApply(void);
    HRESULT _OnSelectionChanged(void);
    HRESULT _SaveIni(HWND hDlg);
    HRESULT _SetByPath(LPCWSTR pszPath);

    INT_PTR _ScreenSaverDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK ScreenSaverDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

    friend HRESULT CScreenSaverPage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
};






//===========================
// *** Class Internals & Helpers ***
//===========================
const DWORD aSaverHelpIds[] = {
        IDC_NO_HELP_1,          NO_HELP,

        IDC_CHOICES,            IDH_DISPLAY_SCREENSAVER_SCREENSAVER_LISTBOX, 

        IDC_SSDELAYLABEL,       IDH_DISPLAY_SCREENSAVER_SCREENSAVER_WAIT,
        IDC_SSDELAYSCALE,       IDH_DISPLAY_SCREENSAVER_SCREENSAVER_WAIT,
        IDC_SCREENSAVEDELAY,    IDH_DISPLAY_SCREENSAVER_SCREENSAVER_WAIT,
        IDC_SCREENSAVEARROW,    IDH_DISPLAY_SCREENSAVER_SCREENSAVER_WAIT, 
    
        IDC_TEST,               IDH_DISPLAY_SCREENSAVER_SCREENSAVER_PREVIEW,

        IDC_SETTING,            IDH_DISPLAY_SCREENSAVER_SCREENSAVER_SETTINGS,
        IDC_BIGICONSS,          IDH_DISPLAY_SCREENSAVER_SCREENSAVER_MONITOR,

        IDC_ENERGY_TEXT,        NO_HELP,
        IDC_ENERGYSTAR_BMP,     IDH_DISPLAY_SCREENSAVER_ENERGYSAVE_GRAPHIC,
        IDC_USEPASSWORD,        IDH_DISPLAY_SCREENSAVER_SCREENSAVER_PASSWORD_CHECKBOX, 
        // IDC_SETPASSWORD,        IDH_COMM_PASSWDBUTT,
        IDC_LOWPOWERCONFIG,     IDH_DISPLAY_SCREENSAVER_POWER_BUTTON,
        IDC_ENERGY_TEXT2,       NO_HELP,
        0, 0
};


// are we going to return to the welcome dialog in the friendly UI case?
BOOL WillReturnToWelcome()
{
    HKEY hkey;
    BOOL bRet = TRUE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_SCREENSAVE, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        TCHAR szTemp[4];
        DWORD dwType;
        DWORD dwSize = sizeof(szTemp);

        if ((RegQueryValueEx(hkey, TEXT("NoAutoReturnToWelcome"), NULL, &dwType, (BYTE*)szTemp, &dwSize) == ERROR_SUCCESS) &&
            (dwType == REG_SZ))
        {
            bRet = !(StrToInt(szTemp));
        }

        RegCloseKey(hkey);
    }

    return bRet;
}

/*
 * Win95 and NT store different values in different places of the registry to
 * determine if the screen saver is secure or not.
 *
 * We can't really consolidate the two because the screen savers do different
 * actions based on which key is set.  Win95 screen savers do their own
 * password checking, but NT must let the secure desktop winlogon code do it.
 *
 * Therefore to keep Win95 screen savers from requesting the password twice on
 * NT, we use  REGSTR_VALUE_USESCRPASSWORD == (REG_DWORD)1 on Win95 to indicate
 * that a screen saver should check for the password, and
 * "ScreenSaverIsSecure" == (REG_SZ)"1" on NT to indicate that WinLogon should
 * check for a password.
 *
 * This function will deal with the differences.
 */
static BOOL IsPasswdSecure(HKEY hKey)
{
    union {
        DWORD dw;
        TCHAR asz[4];
    } uData;

    DWORD dwSize, dwType;
    BOOL fSecure = FALSE;

    dwSize = sizeof(uData);

    if (RegQueryValueEx(hKey,SZ_USE_PASSWORD,NULL, &dwType, (BYTE *)&uData, &dwSize) == ERROR_SUCCESS)
    {
        switch (dwType)
        {
        case REG_DWORD:
            fSecure = (uData.dw == 1);
            break;

        case REG_SZ:
            fSecure = (uData.asz[0] == TEXT('1'));
            break;
        }
    }

    // if we are in friendly UI mode, we might want to treat this as secure even if SZ_USE_PASSWORD is not set
    if (g_fFriendlyUI && !fSecure)
    {
        fSecure = WillReturnToWelcome();
    }

    return fSecure;
}


static void NEAR
EnableDlgChild( HWND dlg, HWND kid, BOOL val )
{
    if( !val && ( kid == GetFocus() ) )
    {
        // give prev tabstop focus
        SendMessage( dlg, WM_NEXTDLGCTL, 1, 0L );
    }

    EnableWindow( kid, val );
}

static void NEAR
EnableDlgItem( HWND dlg, int idkid, BOOL val )
{
    EnableDlgChild( dlg, GetDlgItem( dlg, idkid ), val );
}

HWND GetSSDemoParent( HWND page )
{
    static HWND parent = NULL;

    if (!parent || !IsWindow(parent))
    {
        parent = CreateWindowEx( 0, c_szDemoParentClass,
            TEXT(""), WS_CHILD | WS_CLIPCHILDREN, 0, 0, 0, 0,
            GetDlgItem(page, IDC_BIGICONSS), NULL, HINST_THISDLL, NULL );
    }

    return parent;
}

void ForwardSSDemoMsg(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    HWND hwndChild;

    hwnd = GetSSDemoParent(hwnd);

    if (hwnd)
    {
        for (hwndChild = GetWindow(hwnd, GW_CHILD); hwnd && (hwndChild != NULL);
            hwndChild = GetWindow(hwndChild, GW_HWNDNEXT))
        {
            SendMessage(hwndChild, uMessage, wParam, lParam);
        }
    }
}

void ParseSaverName( LPTSTR lpszName )
{
    if( *lpszName == TEXT('\"') )
    {
        LPTSTR lpcSrc = lpszName + 1;

        while( *lpcSrc && *lpcSrc != TEXT('\"') )
        {
            *lpszName++ = *lpcSrc++;
        }

        *lpszName = 0;  // clear second quote
    }
}

// YUCK:
// since our screen saver preview is in a different process,
//   it is possible that we paint in the wrong order.
// this ugly hack makes sure the demo always paints AFTER the dialog

WNDPROC g_lpOldStaticProc = NULL;

LRESULT  StaticSubclassProc(HWND wnd, UINT msg, WPARAM wp, LPARAM lp)
{
    LRESULT result =
        CallWindowProc(g_lpOldStaticProc, wnd, msg, wp, lp);

    if (msg == WM_PAINT)
    {
        HWND demos = GetSSDemoParent(GetParent(wnd));

        if (demos)
        {
            RedrawWindow(demos, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
        }
    }

    return result;
}


HRESULT CScreenSaverPg::_InitState(void)
{
    HRESULT hr = S_OK;
    HKEY  hKey;
    int Counter;
    int nActive;
    int Timeout;

    m_fScreenSavePolicy = FALSE;
    m_fScreenSaveActive = TRUE;

    // Fetch the timeout value from the win.ini and adjust between 1:00-60:00
    for (Counter = 0; Counter < ARRAYSIZE(g_TimeoutAssociation); Counter++)
    {
        // Fetch the timeout value from the win.ini and adjust between 1:00-60:00
        ClassicSystemParametersInfo(g_TimeoutAssociation[Counter].taGetTimeoutAction, 0, &Timeout, 0);

        //  The Win 3.1 guys decided that 0 is a valid ScreenSaveTimeOut value.
        //  This causes our screen savers not to kick in (who cares?).  In any
        //  case, I changed this to allow 0 to go through.  In this way, the
        //  user immediately sees that the value entered is not valid to fire
        //  off the screen saver--the OK button is disabled.  I don't know if
        //  I fully agree with this solution--it is just the minimal amount of
        //  code.  The optimal solution would be to ask the 3.1 guys why 0 is
        //  valid?  -cjp
        Timeout = min(max(Timeout, 1), MAX_MINUTES * 60);

        //  Convert Timeout to minutes, rounding up.
        Timeout = (Timeout + 59) / 60;
        g_Timeout[Counter] = Timeout;

        ClassicSystemParametersInfo(g_TimeoutAssociation[Counter].taGetActiveAction, 0, &nActive, SPIF_UPDATEINIFILE);
        if (Counter == TA_SCREENSAVE)
        {
            // I found that NTUSER will return random values so we don't use them.  If people want to set the policy,
            // they should do in the registry.
//            m_fScreenSaveActive = nActive;
        }
    }


    // Find the name of the exe used as a screen saver. "" means that the
    // default screen saver will be used.  First check the system policies
    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Policies\\Microsoft\\Windows\\Control Panel\\Desktop"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        BOOL fSettings;
        ULONG cbSize;
        
        cbSize = sizeof(g_szSaverName);
        if (RegQueryValueEx(hKey, TEXT("SCRNSAVE.EXE"), NULL, NULL, (LPBYTE)g_szSaverName, &cbSize) == ERROR_SUCCESS)
        {
            g_fScreenSaverExecutablePolicy = TRUE;
            LogStatus("POLICY ENABLED: ScreenSaver selection is forced to a certain SS file.");
        }

        cbSize = sizeof(m_fSecure);
        if (RegQueryValueEx(hKey, TEXT("ScreenSaverIsSecure"), NULL, NULL, (LPBYTE)&m_fSecure, &cbSize) == ERROR_SUCCESS)
        {
            g_fPasswordBoxDeterminedByPolicy = TRUE;
            LogStatus("POLICY ENABLED: ScreenSaverIsSecure is on.");
        }

        cbSize = sizeof( fSettings );
        if (RegQueryValueEx(hKey, TEXT("ScreenSaverSettingsButton"), NULL, NULL, (LPBYTE)&fSettings, &cbSize) == ERROR_SUCCESS)
        {
            g_fSettingsButtonOffByPolicy = TRUE;
            LogStatus("POLICY ENABLED: ScreenSaver settings button is disabled.");
        }

        TCHAR szTemp[20];
        if (SUCCEEDED(HrRegGetValueString(hKey, NULL, SZ_POLICY_SCREENSAVETIMEOUT, szTemp, ARRAYSIZE(szTemp))) &&
            szTemp[0])
        {
            m_lWaitTime = StrToInt(szTemp);
            g_fTimeoutDeterminedByPolicy = TRUE;
            LogStatus("POLICY ENABLED: ScreenSaver timeout value is set.");
        }

        if (SUCCEEDED(HrRegGetValueString(hKey, NULL, TEXT("ScreenSaveActive"), szTemp, ARRAYSIZE(szTemp))) &&
            szTemp[0])
        {
            m_fScreenSavePolicy = TRUE;
            m_fScreenSaveActive = StrToInt(szTemp);
            LogStatus("POLICY ENABLED: ScreenSaver Active is set.");
        }
        RegCloseKey(hKey);
    }
    
    if (!g_fScreenSaverExecutablePolicy)
    {
        if (FAILED(HrRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_CPDESKTOP, SZ_INIKEY_SCREENSAVER, g_szSaverName, ARRAYSIZE(g_szSaverName))))
        {
            TCHAR szTempPath[MAX_PATH];

            if (GetPrivateProfileString(SZ_INISECTION_SCREENSAVER, SZ_INIKEY_SCREENSAVER, TEXT(""), g_szSaverName, ARRAYSIZE(g_szSaverName), SZ_INISECTION_SYSTEMINI))
            {
                StringCchCopy(szTempPath, ARRAYSIZE(szTempPath), g_szSaverName);
                SHExpandEnvironmentStrings(szTempPath, g_szSaverName, ARRAYSIZE(g_szSaverName));
            }
        }
    }

    ParseSaverName(g_szSaverName);  // remove quotes and params

    // Call will fail if monitor or adapter don't support DPMS.
    int dummy; 

    g_fAdapPwrMgnt = ClassicSystemParametersInfo(SPI_GETLOWPOWERACTIVE, 0, &dummy, 0);
    if (!g_fAdapPwrMgnt)
    {
        g_fAdapPwrMgnt = ClassicSystemParametersInfo(SPI_GETPOWEROFFACTIVE, 0, &dummy, 0);
    }

    // initialize the password checkbox
    if (RegOpenKeyEx(HKEY_CURRENT_USER,REGSTR_PATH_SCREENSAVE, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        if (IsPasswdSecure(hKey))
        {
            g_fPasswordWasPreviouslyEnabled = TRUE;
        }
        RegCloseKey(hKey);
    }

    return hr;
}


BOOL CScreenSaverPg::_InitSSDialog(HWND hDlg)
{
    WNDCLASS wc;
    PTSTR  pszMethod;
    UINT  wTemp,wLoop;
    BOOL  fContinue;
    UINT  Counter;
    int   ControlID;
    int   wMethod;
    DWORD dwUserCount;
    HKEY  hKey;
    HWND  hwnd;
    int nActive;
    TCHAR szBuffer[MAX_PATH];

    m_hDlg = hDlg;
    m_fUIInitialized = TRUE;

    HINSTANCE hInstDeskCPL = LoadLibrary(TEXT("desk.cpl"));

    if (!GetClassInfo(HINST_THISDLL, c_szDemoParentClass, &wc))
    {
        // if two pages put one up, share one dc
        wc.style = 0;
        wc.lpfnWndProc = DefWindowProc;
        wc.cbClsExtra = wc.cbWndExtra = 0;
        wc.hInstance = HINST_THISDLL;
        wc.hIcon = (HICON)( wc.hCursor = NULL );
        wc.hbrBackground = (HBRUSH) GetStockObject( BLACK_BRUSH );
        wc.lpszMenuName = NULL;
        wc.lpszClassName = c_szDemoParentClass;

        if( !RegisterClass( &wc ) )
            return FALSE;
    }

    // Fetch the timeout value from the win.ini and adjust between 1:00-60:00
    for (Counter = 0; Counter < ARRAYSIZE(g_TimeoutAssociation); Counter++)
    {
        //  The base control id specifies the edit control id.
        ControlID = g_TimeoutAssociation[Counter].taBaseControlID;

        // Set the maximum length of all of the fields...
        SendDlgItemMessage(hDlg, ControlID, EM_LIMITTEXT, 4, 0); //Allow four digits.

        ClassicSystemParametersInfo(g_TimeoutAssociation[Counter].taGetActiveAction, 0, &nActive, SPIF_UPDATEINIFILE);
        if (Counter != TA_SCREENSAVE)
        {
            CheckDlgButton(hDlg, ControlID + BCI_SWITCH, nActive);
        }
        else
        {
//            m_fScreenSaveActive = nActive;
        }

        SetDlgItemInt(hDlg, ControlID, g_Timeout[Counter], FALSE);

        //  The associated up/down control id must be one after the edit control id.
        ControlID++;

        SendDlgItemMessage(hDlg, ControlID, UDM_SETRANGE, 0, MAKELPARAM(MAX_MINUTES, MIN_MINUTES));
        SendDlgItemMessage(hDlg, ControlID, UDM_SETACCEL, 4, (LPARAM)(LPUDACCEL)udAccel);
    }

    // Find the name of the exe used as a screen saver. "" means that the
    // default screen saver will be used.  First check the system policies
    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Policies\\Microsoft\\Windows\\Control Panel\\Desktop"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        BOOL fPower;
        ULONG cbSize;
        
        cbSize = sizeof(fPower);
        if (RegQueryValueEx(hKey, TEXT("ScreenSaverPowerButton"), NULL, NULL, (LPBYTE)&fPower, &cbSize) == ERROR_SUCCESS)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_LOWPOWERCONFIG), FALSE);
        }

        RegCloseKey(hKey);
    }

    if (g_fPasswordBoxDeterminedByPolicy)
    {
        CheckDlgButton(hDlg, IDC_USEPASSWORD, m_fSecure);
        EnableWindow(GetDlgItem(hDlg, IDC_USEPASSWORD), FALSE);
    }

    // if we are running with the new friendly UI w/ multiple users on the system, then we switch to text from "Password protect"
    // to "Return to the Welcome screen" because winlogon will do a switch user instead of a LockWorkStation in this case
    if (ShellIsFriendlyUIActive()                                       &&
        ShellIsMultipleUsersEnabled()                                   &&
        (ERROR_SUCCESS == ShellGetUserList(TRUE, &dwUserCount, NULL))   &&
        (dwUserCount > 1))
    {
        if (LoadString(HINST_THISDLL, IDS_RETURNTOWELCOME, szBuffer, ARRAYSIZE(szBuffer)))
        {
            SetDlgItemText(hDlg, IDC_USEPASSWORD, szBuffer);
            g_fFriendlyUI = TRUE;

            if (WillReturnToWelcome())
            {
                g_fPasswordWasPreviouslyEnabled = TRUE;
            }
        }
    }

    if (g_fSettingsButtonOffByPolicy)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SETTING), FALSE);
    }

    if (g_fTimeoutDeterminedByPolicy)
    {
        SetDlgItemInt(hDlg, IDC_SCREENSAVEDELAY, (UINT) m_lWaitTime / 60, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SCREENSAVEDELAY), FALSE);
    }

    if (m_fScreenSavePolicy && !m_fScreenSaveActive)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_CHOICES), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SETTING), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SSDELAYLABEL), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SCREENSAVEDELAY), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SCREENSAVEARROW), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SSDELAYSCALE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_USEPASSWORD), FALSE);
    }

    if (g_fScreenSaverExecutablePolicy)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_CHOICES), FALSE);
    }

    // Copy all of the variables into their copies...
    //  lstrcpy(szFileNameCopy, g_szSaverName);

    // Load in the default icon...
    if (hInstDeskCPL)
    {
        hDefaultIcon = LoadIcon(hInstDeskCPL, MAKEINTRESOURCE(IDS_ICON));
    }

    // Find the methods to save the screen.  If the method that was
    // selected is not found, the program will assume that the
    // first method in the list will be the one that is elected...
    wNumMethods = 0;
    wMethod = -1;

    SearchForScrEntries(SFSE_PRG,NULL);
    SearchForScrEntries(SFSE_SYSTEM,NULL);
    SearchForScrEntries(SFSE_WINDOWS,NULL);
    SearchForScrEntries(SFSE_FILE,g_szSaverName);

    szBuffer[0] = 0;

    TCHAR szNone[MAX_PATH];
    LoadString(HINST_THISDLL, IDS_NONE, szNone, ARRAYSIZE(szNone));

    // Set up the combo box for the different fields...
    SendDlgItemMessage(hDlg, IDC_CHOICES, CB_ADDSTRING, 0, (LPARAM)szNone);
    for (wTemp = 0; (wTemp < wNumMethods) && (ARRAYSIZE(aszFiles) > wTemp) && (ARRAYSIZE(aszMethods) > wTemp); wTemp++)
    {
        // Lock down the information and pass it to the combo box...
        pszMethod = aszMethods[wTemp];
        wLoop = (UINT)SendDlgItemMessage(hDlg,IDC_CHOICES,CB_ADDSTRING,0, (LPARAM)(pszMethod+1));
        SendDlgItemMessage(hDlg, IDC_CHOICES, CB_SETITEMDATA, wLoop, wTemp);

        // If we have the correct item, keep a copy so we can select it out of the combo box...
        // check for filename only as well as full path name
        if (!lstrcmpi(FileName(aszFiles[wTemp]), FileName(g_szSaverName)))
        {
            wMethod = wTemp;
            StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), pszMethod + 1);
        }
    }

    if (m_fScreenSavePolicy && !m_fScreenSaveActive)
    {
        wMethod = -1;
    }

    // Attempt to select the string we recieved from the
    // system.ini entry.  If there is no match, select the
    // first item from the list...
    if ((wMethod == -1) || (wNumMethods == 0))
    {
        fContinue = TRUE;
    }
    else
    {
        if (SendDlgItemMessage(hDlg, IDC_CHOICES, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)szBuffer) == CB_ERR)
            fContinue = TRUE;
        else
            fContinue = FALSE;
    }

    if (fContinue)
    {
       SendDlgItemMessage(hDlg,IDC_CHOICES,CB_SETCURSEL,0,0l);
       g_szSaverName[0] = '\0';
       wMethod = -1;
    }

    g_hbmDemo = LoadMonitorBitmap( TRUE );
    if (g_hbmDemo)
    {
        SendDlgItemMessage(hDlg,IDC_BIGICONSS,STM_SETIMAGE, IMAGE_BITMAP,(LPARAM)g_hbmDemo);
    }

    if (hInstDeskCPL)
    {
        g_hbmEnergyStar = (HBITMAP) LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_ENERGYSTAR), IMAGE_BITMAP, 0, 0, LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS);
        if (g_hbmEnergyStar)
        {
            SendDlgItemMessage(hDlg, IDC_ENERGYSTAR_BMP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)g_hbmEnergyStar);
        }
    }

    // Hide/Disable the energy related controls if the adaptor/monitor does not
    // support power mgnt.
    EnableDisablePowerDelays(hDlg);

    // subclass the static control so we can synchronize painting
    hwnd = GetDlgItem(hDlg, IDC_BIGICONSS);
    if (hwnd)
    {
        g_lpOldStaticProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)(WNDPROC)StaticSubclassProc);
        // Turn off the mirroring style for this control to allow the screen saver preview to work.
        SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE) & ~RTL_MIRRORED_WINDOW);
    }

    if (hInstDeskCPL)
    {
        FreeLibrary(hInstDeskCPL);
    }

    return TRUE;
}

// Build a command line in a format suitable for passing as the second
// parameter to CreateProcess.
void _PathBuildArgs(LPTSTR pszBuf, DWORD cchBuf, LPCTSTR pszExe, LPCTSTR pszFormat, ...)
{
    StringCchCopy(pszBuf, cchBuf, pszExe);
    PathQuoteSpaces(pszBuf);

    int cchBufUsed = lstrlen(pszBuf);
    pszBuf += cchBufUsed;
    cchBuf -= cchBufUsed;

    va_list ap;
    va_start(ap, pszFormat);
    wvnsprintf(pszBuf, cchBuf, pszFormat, ap);
    va_end(ap);
}

#define SS_WINDOWCLOSE_WAIT_LIMIT 5000

BOOL CALLBACK EnumSSChildWindowsProc(HWND hwndC, LPARAM lParam)
{
    HWND hwndDemo = (HWND)lParam;

    TraceMsg(TF_FUNC, "hwndDemo = %08x hwndC = %08x", hwndDemo, hwndC);

    if (IsWindow(hwndDemo) && (hwndDemo == GetParent(hwndC)))
    {      
        DWORD dwStart = GetTickCount();

        TraceMsg(TF_FUNC, "dwStart = %08x", dwStart);
    
        while (IsWindow(hwndC))
        {
            DWORD_PTR dwResult;

            TraceMsg(TF_FUNC, "Sending WM_CLOSE tickcount = %08x", GetTickCount());
            
            BOOL fShouldEndTask = !SendMessageTimeout(hwndC, WM_CLOSE, 0, 0, 
                    SMTO_ABORTIFHUNG | SMTO_NOTIMEOUTIFNOTHUNG | SMTO_NORMAL, 2000, &dwResult);

            TraceMsg(TF_FUNC, "Return from sending WM_CLOSE tickcount = %08x fShouldEndTask = %d", GetTickCount(), fShouldEndTask);

            if (!fShouldEndTask)
            {
                DWORD dwWait = dwStart + SS_WINDOWCLOSE_WAIT_LIMIT - GetTickCount();

                TraceMsg(TF_FUNC, "dwWait = %d", dwWait);

                if (dwWait > SS_WINDOWCLOSE_WAIT_LIMIT)
                {
                    TraceMsg(TF_FUNC, "Wait exceeded, ending task");
                    fShouldEndTask = TRUE;
                }
            }

            if (fShouldEndTask)
            {
                TraceMsg(TF_FUNC, "Call EndTask task for %08x", hwndC);
                EndTask(hwndC, FALSE, FALSE);
                TraceMsg(TF_FUNC, "Return from EndTask task for %08x", hwndC);
                break;
            }
        }
    }

    return TRUE;
}

void SetNewSSDemo(HWND hDlg, int iMethod)
{
    HBITMAP hbmOld;
    POINT ptIcon;
    HWND hwndDemo;
    HICON hicon;

    RECT rc = {MON_X, MON_Y, MON_X+MON_DX, MON_Y+MON_DY};

    hwndDemo = GetSSDemoParent(hDlg);
    if (hwndDemo)
    {
        // blank out the background with dialog color
        hbmOld = (HBITMAP) SelectObject(g_hdcMem, g_hbmDemo);
        FillRect(g_hdcMem, &rc, GetSysColorBrush(COLOR_DESKTOP));
        SelectObject(g_hdcMem, hbmOld);

        // make sure the old window is gone
        EnumChildWindows(hwndDemo, EnumSSChildWindowsProc, (LPARAM)hwndDemo);      

        Yield(); // paranoid
        Yield(); // really paranoid
        ShowWindow(hwndDemo, SW_HIDE);
        g_fPreviewActive = FALSE;

        if (iMethod >= 0 && aszMethods[iMethod][0] == TEXT('P'))
        {
            RECT rc;
            BITMAP bm;
            UpdateWindow(hDlg);
            //UpdateWindow(GetDlgItem(hDlg, IDC_BIGICONSS));
            TCHAR szArgs[MAX_PATH];

            GetObject(g_hbmDemo, sizeof(bm), &bm);
            GetClientRect(GetDlgItem(hDlg, IDC_BIGICONSS), &rc);
            rc.left = ( rc.right - bm.bmWidth ) / 2 + MON_X;
            rc.top = ( rc.bottom - bm.bmHeight ) / 2 + MON_Y;
            MoveWindow(hwndDemo, rc.left, rc.top, MON_DX, MON_DY, FALSE);
            _PathBuildArgs(szArgs, ARRAYSIZE(szArgs), g_szSaverName, TEXT(" /p %d"), hwndDemo);
            if (WinExecN(g_szSaverName, szArgs, SW_NORMAL) > 32)
            {
                ShowWindow(hwndDemo, SW_SHOWNA);
                g_fPreviewActive = TRUE;
                return;
            }
        }

        if (iMethod != -1)
        {
            ptIcon.x = ClassicGetSystemMetrics(SM_CXICON);
            ptIcon.y = ClassicGetSystemMetrics(SM_CYICON);

            // draw the icon double size
            ASSERT(ptIcon.y*2 <= MON_DY);
            ASSERT(ptIcon.x*2 <= MON_DX);

            hicon = hIcons[iMethod];

            if (hicon == NULL && aszMethods[iMethod][0] == TEXT('I'))
                hicon = hIdleWildIcon;
            if (hicon == NULL)
                hicon = hDefaultIcon;

            hbmOld = (HBITMAP) SelectObject(g_hdcMem, g_hbmDemo);
            DrawIconEx(g_hdcMem,
                MON_X + (MON_DX-ptIcon.x*2)/2,
                MON_Y + (MON_DY-ptIcon.y*2)/2,
                hicon, ptIcon.x*2, ptIcon.y*2, 0, NULL, DI_NORMAL);
            SelectObject(g_hdcMem, hbmOld);
        }
    }

    InvalidateRect(GetDlgItem(hDlg, IDC_BIGICONSS), NULL, FALSE);
}

static void SS_SomethingChanged(HWND hDlg)
{
    if (!g_bInitSS)
    {
        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
    }
}

static void SetScreenSaverPassword(HWND hDlg, int iMethod)
{
    if (iMethod >= 0 && aszMethods[iMethod][0] == TEXT('P'))
    {
        TCHAR szArgs[MAX_PATH];

        _PathBuildArgs(szArgs, ARRAYSIZE(szArgs), g_szSaverName, TEXT(" /a %u"), GetParent(hDlg));
        WinExecN(g_szSaverName, szArgs, SW_NORMAL);
    }
}


INT_PTR CALLBACK ScreenSaverDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CScreenSaverPg * pThis = (CScreenSaverPg *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

        if (pPropSheetPage)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
            pThis = (CScreenSaverPg *)pPropSheetPage->lParam;
        }
    }

    if (pThis)
        return pThis->_ScreenSaverDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}



BOOL SelectSSFromList(HWND hDlg)
{
    HWND hwndSSList = GetDlgItem(hDlg, IDC_CHOICES);
    BOOL fExistsInList = FALSE;

    // Select the current item in the list since another tab
    // may have changed this value.
    for (UINT nIndex = 0; nIndex < wNumMethods; nIndex++)
    {
        if (!StrCmpI(g_szSaverName, aszFiles[nIndex]))
        {
            int nItem = ComboBox_FindString(hwndSSList, 0, &(aszMethods[nIndex][1]));
            if (-1 != nItem)
            {
                ComboBox_SetCurSel(hwndSSList, nItem);
            }

            fExistsInList = TRUE;
            break;
        }
    }

    return fExistsInList;
}


HRESULT CScreenSaverPg::_OnSetActive(void)
{
    EnableDisablePowerDelays(m_hDlg);

    if (!SelectSSFromList(m_hDlg))
    {
        UINT wTemp;
        UINT wLoop;

        // We couldn't find it, so add it to aszMethods[].
        SearchForScrEntries(SFSE_FILE, g_szSaverName);

        // Now add it to the Drop Down.
        for (wTemp = 0; (wTemp < wNumMethods) && (ARRAYSIZE(aszFiles) > wTemp) && (ARRAYSIZE(aszMethods) > wTemp); wTemp++)
        {
            // Did we find the correct index?
            if (!StrCmpI(FileName(aszFiles[wTemp]), FileName(g_szSaverName)))
            {
                // Yes, so set the index.
                wLoop = (UINT)SendDlgItemMessage(m_hDlg, IDC_CHOICES, CB_ADDSTRING, 0, (LPARAM)(aszMethods[wTemp]+1));
                SendDlgItemMessage(m_hDlg, IDC_CHOICES, CB_SETITEMDATA, wLoop, wTemp);
                break;
            }
        }

        SelectSSFromList(m_hDlg);             // Try again now that we added it.  Another tab or API may have asked for us to use this SS.
    }

    if (!g_fPreviewActive)
    {
        g_bInitSS = TRUE;
        SendMessage(m_hDlg, WM_COMMAND, MAKELONG(IDC_CHOICES, CBN_SELCHANGE), (LPARAM)GetDlgItem(m_hDlg, IDC_CHOICES));
        g_bInitSS = FALSE;
    }

    return S_OK;
}


HRESULT CScreenSaverPg::_OnApply(void)
{
    // Our parent dialog will be notified of the Apply event and will call our
    // IBasePropPage::OnApply() to do the real work.
    return S_OK;
}


HRESULT CScreenSaverPg::_OnSelectionChanged(void)
{
    HRESULT hr = E_FAIL;
    PTSTR  pszMethod;
    int   wMethod;
    BOOL  fEnable;

    // Dump the name of the current selection into the buffer... 
    int wTemp = (int)SendDlgItemMessage(m_hDlg, IDC_CHOICES, CB_GETCURSEL,0,0l);
    if (wTemp)
    {
        wMethod = (int)SendDlgItemMessage(m_hDlg, IDC_CHOICES, CB_GETITEMDATA, wTemp, 0l);

        // Grey the button accordingly...
        pszMethod = aszMethods[wMethod];
        if ((pszMethod[0] == TEXT('C') ||       // can config
            pszMethod[0] == TEXT('I') ||       // IdleWild
            pszMethod[0] == TEXT('P')) &&
            !g_fSettingsButtonOffByPolicy)        // can preview
            EnableDlgItem(m_hDlg, IDC_SETTING, TRUE);
        else
            EnableDlgItem(m_hDlg, IDC_SETTING, FALSE);


        if (!g_fPasswordBoxDeterminedByPolicy)
        {
            EnableDlgItem(m_hDlg, IDC_USEPASSWORD, TRUE);
            CheckDlgButton(m_hDlg, IDC_USEPASSWORD, g_fPasswordWasPreviouslyEnabled);
        }

        // For fun, create an extra copy of g_szSaverName...
        pszMethod = aszFiles[wMethod];
        StringCchCopy(g_szSaverName, ARRAYSIZE(g_szSaverName), pszMethod);
        fEnable = TRUE;
    }
    else
    {
        wMethod = -1;
        g_szSaverName[0] = '\0';

        EnableDlgItem(m_hDlg, IDC_SETTING, FALSE);
        EnableDlgItem(m_hDlg, IDC_USEPASSWORD, FALSE);
        fEnable = FALSE;
    }

    //  Following are enabled as a group... (oh really?)
    EnableDlgItem(m_hDlg, IDC_SSDELAYLABEL, fEnable);
    EnableDlgItem(m_hDlg, IDC_SCREENSAVEDELAY, !g_fTimeoutDeterminedByPolicy && fEnable);
    EnableDlgItem(m_hDlg, IDC_SCREENSAVEARROW, fEnable);
    EnableDlgItem(m_hDlg, IDC_SSDELAYSCALE, fEnable);
    EnableDlgItem(m_hDlg, IDC_TEST, fEnable);

    g_iMethod = (int)wMethod;
    SetNewSSDemo(m_hDlg, wMethod);
    SS_SomethingChanged(m_hDlg);

    return hr;
}


INT_PTR CScreenSaverPg::_ScreenSaverDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnm;

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR *)lParam;
            switch(lpnm->code)
            {
                case PSN_APPLY:
                    _OnApply();
                    break;

                // nothing to do on cancel...
                case PSN_RESET:
                    if (g_fPreviewActive)
                        SetNewSSDemo(hDlg, -1);
                    break;

                case PSN_KILLACTIVE:
                    if (g_fPreviewActive)
                        SetNewSSDemo(hDlg, -1);
                    break;

                case PSN_SETACTIVE:
                    _OnSetActive();
                    break;
            }
            break;

        case WM_INITDIALOG:
            g_bInitSS = TRUE;
            _InitSSDialog(hDlg);
            g_bInitSS = FALSE;
            break;

        case WM_DISPLAYCHANGE:
        case WM_SYSCOLORCHANGE: {
            HBITMAP hbm;

            hbm = g_hbmDemo;

            g_hbmDemo = LoadMonitorBitmap( TRUE );
            if (g_hbmDemo)
            {
                // Got a new bitmap, use it and delete the old one.
                SendDlgItemMessage(hDlg,IDC_BIGICONSS,STM_SETIMAGE, IMAGE_BITMAP,(LPARAM)g_hbmDemo);
                if (hbm)
                {
                    DeleteObject(hbm);
                }
            }
            else
            {
                // Couldn't get a new bitmap, just reuse the old one
                g_hbmDemo = hbm;
            }

            break;
        }


        case WM_DESTROY:
            FreeScrEntries();
            if (g_fPreviewActive)
                SetNewSSDemo(hDlg, -1);
            if (g_hbmDemo)
            {
                SendDlgItemMessage(hDlg,IDC_BIGICONSS,STM_SETIMAGE,IMAGE_BITMAP, (LPARAM)NULL);
                DeleteObject(g_hbmDemo);
            }
            if (g_hbmEnergyStar)
            {
                SendDlgItemMessage(hDlg,IDC_ENERGYSTAR_BMP,STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)NULL);
                DeleteObject(g_hbmEnergyStar);
            }
            break;

        case WM_VSCROLL:
            if (LOWORD(wParam) == SB_THUMBPOSITION)
                ScreenSaver_AdjustTimeouts(hDlg, GetDlgCtrlID((HWND)lParam) - BCI_ARROW);
            break;

        case WM_HELP:
            WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, TEXT("display.hlp"), HELP_WM_HELP, (DWORD_PTR)aSaverHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, TEXT("display.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) aSaverHelpIds);
            break;

        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            ForwardSSDemoMsg(hDlg, message, wParam, lParam);
            break;

        case WMUSER_SETINITSS:
            g_bInitSS = (BOOL) lParam;
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                /* Check for a selection change in the combo box. If there is
                    one, then update the method number as well as the
                    configure button... */
                case IDC_CHOICES:
                    if(HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        _OnSelectionChanged();
                    }
                    break;

                /* If the edit box loses focus, translate... */
                case IDC_SCREENSAVEDELAY:
                    if (HIWORD(wParam) == EN_KILLFOCUS)
                        ScreenSaver_AdjustTimeouts(hDlg, LOWORD(wParam));
                    else
                        //check if initdialog is finished
                        if((FALSE == g_bInitSS) && (EN_CHANGE == (HIWORD(wParam))))
                            SS_SomethingChanged(hDlg);
                    break;

                case IDC_LOWPOWERCONFIG:
                    {
                        TCHAR szRunDll32[MAX_PATH];
                        SystemPathAppend(szRunDll32, TEXT("rundll32.exe"));
                        
                        TCHAR szShell32[MAX_PATH];
                        SystemPathAppend(szShell32, TEXT("shell32.dll"));

                        CHAR szCmdLine[3 * MAX_PATH];
                        StringCchPrintfA(szCmdLine, ARRAYSIZE(szCmdLine), "%S %S,Control_RunDLL powercfg.cpl,,", szRunDll32, szShell32);
                        
                        // Configure the low power timeout event.
                        WinExec(szCmdLine, SW_SHOWNORMAL);
                    }
                    break;

                /* If the user wishes to test... */
                case IDC_TEST:
                    switch( HIWORD( wParam ) )
                    {
                        case BN_CLICKED:
                        DoScreenSaver(hDlg,TRUE);
                        break;
                    }
                    break;

                /* Tell the DLL that it can do the configure... */
                case IDC_SETTING:
                    if (HIWORD(wParam) == BN_CLICKED) {
                        DoScreenSaver(hDlg,FALSE);
                        break;
                    }

                case IDC_USEPASSWORD:
                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        // the user actually toggled the checbox, so set our dirty flag
                        g_fPasswordDirty = TRUE;

                        g_fPasswordWasPreviouslyEnabled = IsDlgButtonChecked( hDlg, IDC_USEPASSWORD );
                        SS_SomethingChanged(hDlg);
                        break;
                    }

                case IDC_SETPASSWORD:
                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        // ask new savers to change passwords
                        int wTemp = (int)SendDlgItemMessage(hDlg,IDC_CHOICES, CB_GETCURSEL,0,0l);
                        if (wTemp)
                        {
                            SetScreenSaverPassword(hDlg, (int)SendDlgItemMessage(hDlg,IDC_CHOICES, CB_GETITEMDATA,wTemp,0l));
                        }
                        break;
                    }
            }
            break;

        case WM_CTLCOLORSTATIC:
            if( (HWND)lParam == GetSSDemoParent( hDlg ) )
            {
                return (INT_PTR)GetStockObject( NULL_BRUSH );
            }
            break;
    }
    return FALSE;
}

/*******************************************************************************
*
*  ScreenSaver_AdjustTimeouts
*
*  DESCRIPTION:
*     Called whenever the user adjusts the delay of one of the time controls.
*     Adjusts the delays of the other time controls such that the screen saver
*     delay is less than the low power delay and that the low power delay is
*     less than the power off delay.
*
*  PARAMETERS:
*     hWnd, handle of ScreenSaver window.
*     BaseControlID, base control ID of the radio, edit, and arrow time control
*        combination.
*
*******************************************************************************/

VOID
NEAR PASCAL
ScreenSaver_AdjustTimeouts(HWND hWnd, int BaseControlID)
{
    BOOL fTranslated;
    int Timeout;

    //  Get the new timeout for this time control and validate it's contents.
    Timeout = (int) GetDlgItemInt(hWnd, BaseControlID + BCI_DELAY, &fTranslated, FALSE);
    Timeout = min(max(Timeout, 1), MAX_MINUTES);
    SetDlgItemInt(hWnd, BaseControlID + BCI_DELAY, (UINT) Timeout, FALSE);

    //  Check the new value of this time control against the other timeouts,
    //  adjust their values if necessary.  Be careful when changing the order
    //  of these conditionals.
    //
    if (BaseControlID == IDC_SCREENSAVEDELAY)
    {
        if (g_Timeout[TA_SCREENSAVE] != Timeout)
        {
            g_Timeout[TA_SCREENSAVE] = Timeout;
            SS_SomethingChanged(hWnd);
        }
    }
    else
    {
        if (Timeout < g_Timeout[TA_SCREENSAVE])
        {
            g_Timeout[TA_SCREENSAVE] = Timeout;
            SetDlgItemInt(hWnd, IDC_SCREENSAVEDELAY, (UINT) Timeout, FALSE);
        }
    }
}


void EnableDisablePowerDelays(HWND hDlg)
{
    int i;
    static idCtrls[] = { IDC_ENERGY_TEXT,
                         IDC_ENERGY_TEXT2,
                         IDC_ENERGY_TEXT3,
                         IDC_ENERGYSTAR_BMP,
                         IDC_LOWPOWERCONFIG,
                         0 };

    for (i = 0; idCtrls[i] != 0; i++)
        ShowWindow( GetDlgItem( hDlg, idCtrls[i] ), g_fAdapPwrMgnt ? SW_SHOWNA : SW_HIDE );
}


/* This routine will search for entries that are screen savers.  The directory
    searched is either the system directory (.. */

void SearchForScrEntries(UINT wDir, LPCTSTR file)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szPath2[MAX_PATH];
    HANDLE hfind;
    WIN32_FIND_DATA fd;

    // don't do any work if no space left
    if( wNumMethods >= MAX_METHODS )
        return;

    /* Get the directory where the program resides... */
    GetModuleFileName(HINST_THISDLL, szPath, ARRAYSIZE(szPath));
    StripPathName(szPath);

    switch ( wDir )
    {
        case SFSE_WINDOWS:
            /* Search the windows directory and place the path with the \ in
                the szPath variable... */
            if (!GetWindowsDirectory(szPath2, ARRAYSIZE(szPath2)))
            {
                szPath2[0] = 0;
            }

sfseSanityCheck:
            /* if same dir as where it was launched, don't search again */
            if (!lstrcmpi(szPath, szPath2))
               return;

            StringCchCopy(szPath, ARRAYSIZE(szPath), szPath2);
            break;

        case SFSE_SYSTEM:
            /* Search the system directory and place the path with the \ in
                the szPath variable... */
            GetSystemDirectory(szPath2, ARRAYSIZE(szPath2));
            goto sfseSanityCheck;

        case SFSE_FILE:
            /* Search the directory containing 'file' */
            StringCchCopy(szPath2, ARRAYSIZE(szPath2), file);
            StripPathName(szPath2);
            goto sfseSanityCheck;
    }

    AppendPath(szPath, ARRAYSIZE(szPath), TEXT("*.scr"));

    if( ( hfind = FindFirstFile( szPath, &fd ) ) != INVALID_HANDLE_VALUE )
    {
        StripPathName(szPath);

        do
        {
            PTSTR pszDesc;
            BOOL fLFN;

            fLFN = !(fd.cAlternateFileName[0] == 0 ||
                    lstrcmp(fd.cFileName, fd.cAlternateFileName) == 0);

            StringCchCopy(szPath2, ARRAYSIZE(szPath2), szPath);
            AppendPath(szPath2, ARRAYSIZE(szPath2), fd.cFileName);

            // Note: PerformCheck does an alloc
            if( ( pszDesc = PerformCheck( szPath2, fLFN ) ) != NULL )
            {
                BOOL bAdded = FALSE;
                UINT i;

                for( i = 0; i < wNumMethods; i++ )
                {
                    if( !lstrcmpi( pszDesc, aszMethods[ i ] ) )
                    {
                        bAdded = TRUE;
                        break;
                    }
                }

                if( !bAdded )
                {
                    PTSTR pszEntries;

                    // COMPATIBILITY: always use short name
                    // otherwise some apps fault when peeking at SYSTEM.INI
                    if( fLFN )
                    {
                        StringCchCopy(szPath2, ARRAYSIZE(szPath2), szPath);
                        AppendPath(szPath2, ARRAYSIZE(szPath2), fd.cAlternateFileName);
                    }

                    if( ( pszEntries = StrDup( szPath2 ) ) != NULL )
                    {
                        if (pszDesc[0] != TEXT('P'))
                            hIcons[wNumMethods] = ExtractIcon(HINST_THISDLL, szPath2, 0);
                        else
                            hIcons[wNumMethods] = NULL;

                        aszMethods[wNumMethods] = pszDesc;
                        aszFiles[wNumMethods] = pszEntries;
                        wNumMethods++;
                        bAdded = TRUE;
                    }
                }

                if( !bAdded )
                    LocalFree((HLOCAL)pszDesc);
            }

        } while( FindNextFile( hfind, &fd ) && ( wNumMethods < MAX_METHODS ) );

        FindClose(hfind);
    }
    return;
}

//
//  This routine checks a given file to see if it is indeed a screen saver
//  executable...
//
//  a valid screen saver exe has the following description line:
//
//      SCRNSAVE [c] : description :
//
//      SCRNSAVE is a required name that indicates a screen saver.
//
PTSTR PerformCheck(LPTSTR lpszFilename, BOOL fLFN)
{
    int  i;
    TCHAR chConfig=TEXT('C');       // assume configure
    LPTSTR pch;
    DWORD dw;
    WORD  Version;
    WORD  Magic;
    TCHAR szBuffer[MAX_PATH];
    DWORD cchSizePch = (ARRAYSIZE(szBuffer)-1);

    // Get the description...
    pch = szBuffer + 1;

    //  if we have a LFN (Long File Name) dont bother getting the
    //  exe descrription
    dw = GetExeInfo(lpszFilename, pch, cchSizePch, fLFN ? GEI_EXPVER : GEI_DESCRIPTION);
    Version = HIWORD(dw);
    Magic   = LOWORD(dw);

    if (dw == 0)
        return NULL;

    if (Magic == PEMAGIC || fLFN)
    {
        BOOL fGotName = FALSE;

        if (!fLFN)
        {
            HINSTANCE hSaver = LoadLibraryEx(lpszFilename, NULL, LOAD_LIBRARY_AS_DATAFILE);

            // We have a 32 bit screen saver with a short name, look for an NT style
            // decription in it's string table
            if (hSaver)
            {
                int cchLoaded = LoadString(hSaver, IDS_DESCRIPTION, pch, cchSizePch);

                if (cchLoaded)
                {
                    if (!IsOS(OS_ANYSERVER))
                    {
                        // HACK!!!: The display CPL looks for screen saver descriptions with string resource id=IDS_DESCRIPTION.  
                        // As we need the certain screen saver descriptions to be different for client of server builds (32 and 64bit), 
                        // the description string may be in the form of "Server\0Client".  If this is true, LoadString will return a 
                        // count greater than the lstrlen of the string.
                        int cchActual = lstrlen(pch);

                        if (cchLoaded != cchActual)
                        {
                            // Extract the client portion of the description string
                            StringCchCopy(pch, ARRAYSIZE(szBuffer) - 1, &pch[cchActual + 1]);       
                        }
                    }

                    fGotName = TRUE;
                }

                FreeLibrary(hSaver);
            }
        }

        if (!fGotName)
        {
            //  we have a LFN (LongFileName) or a Win32 screen saver,
            //  Win32 exe's in general dont have a description field so
            //  we assume they can configure.  We also try to build
            //  a "nice" name for it.
            StringCchCopy(pch, cchSizePch, lpszFilename);

            pch = FileName(pch);                    // strip path part
            if ( ((TCHAR)CharUpper((LPTSTR)(pch[0]))) == TEXT('S') && ((TCHAR)CharUpper((LPTSTR)(pch[1]))) == TEXT('S'))     // map SSBEZIER.SCR to BEZIER.SCR
                pch+=2;

            pch = NiceName(pch);                    // map BEZIER.SCR to Bezier
        }
    }
    else
    {
        LPTSTR pchTemp;

        //  we have a 8.3 file name 16bit screen saveer, parse the
        //  description string from the exehdr
        /* Check to make sure that at least the 11 characters needed for info
            are there... */
        if (lstrlen(pch) < 9)
            return NULL;

        /* Check the first 8 characters for the string... */
        if (lstrncmp((LPTSTR)TEXT("SCRNSAVE"), pch, 8))
            return NULL;

        // If successful, allocate enough space for the string and copy the
        // string to the new one...

        pch = pch + 8;                 // skip over 'SCRNSAVE'

        while (*pch==TEXT(' '))                   // advance over white space
            pch++;

        if (*pch==TEXT('C') || *pch==TEXT('c'))         // parse the configure flag
        {
            chConfig = TEXT('C');
            pch++;
        }

        if (*pch==TEXT('X') || *pch==TEXT('x'))         // parse the don't configure flag
            chConfig = *pch++;

        // we might be pointing at a name or separation goop
        pchTemp = pch;                      // remember this spot

        while (*pch && *pch!=TEXT(':'))           // find separator
            pch++;

        while (*pch==TEXT(':') || *pch==TEXT(' '))      // advance over whtspc/last colon
            pch++;

        // if we haven't found a name yet fall back on the saved location
        if (!*pch)
            pch = pchTemp;

        while (*pch==TEXT(':') || *pch==TEXT(' '))      // re-advance over whtspc
            pch++;

        /* In case the screen saver has version information information
            embedded after the name, check to see if there is a colon TEXT(':')
            in the description and replace it with a NULL... */

        for (i=0; pch[i]; i++)              //
        {
            if (pch[i]==TEXT(':'))
                pch[i]=0;
        }
        
        // Space is OK for DBCS (FE)
        while(i>0 && pch[i-1]==TEXT(' '))         // remove trailing space
            pch[--i]=0;
    }

#ifdef DEBUG
    if (Magic != PEMAGIC)
    {
        StringCchCat(pch, cchSizePch, TEXT(" (16-bit)"));
    }

    if (Version == 0x030A)
        StringCchCat(pch, cchSizePch, TEXT(" (3.10)"));

    if (Version == 0x0400)
        StringCchCat(pch, cchSizePch, TEXT(" (4.00)"));
#endif
    //
    // assume any Win32 4.0 screen saver can do Preview mode
    //
    if (chConfig == TEXT('C') && Version >= 0x0400 && Magic == PEMAGIC)
        chConfig = TEXT('P');                     // mark as configurable/preview

    pch[-1] = chConfig;
    return StrDup(pch-1);
}


BOOL FreeScrEntries( void )
{
    UINT wLoop;

    for(wLoop = 0; wLoop < wNumMethods; wLoop++)
    {
        if(aszMethods[wLoop] != NULL)
            LocalFree((HANDLE)aszMethods[wLoop]);
        if(aszFiles[wLoop] != NULL)
            LocalFree((HANDLE)aszFiles[wLoop]);
        if(hIcons[wLoop] != NULL)
            FreeResource(hIcons[wLoop]);
    }

    if (hDefaultIcon)
        FreeResource(hDefaultIcon);

    if (hIdleWildIcon)
        FreeResource(hIdleWildIcon);

    hDefaultIcon=hIdleWildIcon=NULL;
    wNumMethods = 0;

    return TRUE;
}


int lstrncmp( LPTSTR lpszString1, LPTSTR lpszString2, int nNum )
{
    /* While we can still compare characters, compare.  If the strings are
        of different lengths, characters will be different... */
    while(nNum)
    {
        if(*lpszString1 != *lpszString2)
            return *lpszString1 - *lpszString2;
        lpszString1++;
        lpszString2++;
        nNum--;
    }
    return 0;
}


HRESULT CScreenSaverPg::_SaveIni(HWND hDlg)
{
    HRESULT hr = S_OK;
    LPTSTR pszMethod = TEXT("");
    BOOL bSSActive;
    int  wMethod,wTemp;
    UINT Counter;
    HKEY hKey;
    TCHAR szBuffer[MAX_PATH];

    if (m_fUIInitialized)
    {
        // Find the current method selection...
        wTemp = 0;
        if (wNumMethods)
        {
            // Dump the name of the current selection into the buffer... 
            wTemp = (int)SendDlgItemMessage(hDlg, IDC_CHOICES, CB_GETCURSEL, 0, 0);
            if (wTemp)
            {
                wMethod = (int)SendDlgItemMessage(hDlg, IDC_CHOICES, CB_GETITEMDATA, wTemp, 0);

                // Dump the method name into the buffer...
                pszMethod = aszFiles[wMethod];
            }
        }

        // since "(None)" is always the first entry in the combobox, we can use it to see if we have
        // a screensaver or not
        if (wTemp == 0)
        {
            // 0th inxed is "(None)" so the screensaver is disabled
            bSSActive = FALSE;
        }
        else
        {
            bSSActive = TRUE;
        }
    }
    else
    {
        TCHAR szNone[MAX_PATH];
        LoadString(HINST_THISDLL, IDS_NONE, szNone, ARRAYSIZE(szNone));

        if ((g_szSaverName[0] == TEXT('\0')) || (lstrcmpi(szNone, g_szSaverName) == 0))
        {
            // screensaver was not set, OR it was set to "(None)" -- therefore it is not active
            bSSActive = FALSE;
        }
        else
        {
            bSSActive = TRUE;
        }

        pszMethod = g_szSaverName;
    }

    // Now quote any spaces
    BOOL hasspace = FALSE;
    LPTSTR pc;

    for (pc = pszMethod; *pc; pc++)
    {
        if (*pc == TEXT(' '))
        {
            hasspace = TRUE;
            break;
        }
    }

    if (hasspace)
    {
        // if we need to add quotes we'll need two sets
        // because GetBlahBlahProfileBlah APIs strip quotes
        StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("\"\"%s\"\""), pszMethod);
    }
    else
    {
        StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), pszMethod);
    }

    // Save the buffer...
    if (!WritePrivateProfileString(SZ_INISECTION_SCREENSAVER, SZ_INIKEY_SCREENSAVER, (szBuffer[0] != TEXT('\0') ? szBuffer : NULL), SZ_INISECTION_SYSTEMINI))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // In win2k we decided to leave the screensaver ALWAYS active so that when the policy changed, it would take
    // w/out rebooting. This has become a PITA so we now do it the right way.
    ClassicSystemParametersInfo(SPI_SETSCREENSAVEACTIVE, bSSActive, NULL, SPIF_UPDATEINIFILE);

    for (Counter = 0; Counter < (sizeof(g_TimeoutAssociation) / sizeof(TIMEOUT_ASSOCIATION)); Counter++)
    {
        ClassicSystemParametersInfo(g_TimeoutAssociation[Counter].taSetTimeoutAction, (UINT) (g_Timeout[Counter] * 60), NULL, SPIF_UPDATEINIFILE);

        if (Counter != TA_SCREENSAVE)
        {
            ClassicSystemParametersInfo(g_TimeoutAssociation[Counter].taSetActiveAction,
                                        IsDlgButtonChecked(hDlg, g_TimeoutAssociation[Counter].taBaseControlID + BCI_SWITCH),
                                        NULL,
                                        SPIF_UPDATEINIFILE);
        }

    }

    // save the state of the TEXT("use password") checkbox
    if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_SCREENSAVE, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        if (g_fPasswordDirty)
        {
            if (g_fFriendlyUI)
            {
                // the user actually toggled the value, so don't automatically return to the welcome screen since they have
                // now made their own decision on this subject
                RegSetValueEx(hKey, TEXT("NoAutoReturnToWelcome"), 0, REG_SZ, (BYTE*)TEXT("1"), sizeof(TEXT("1")));

                RegSetValueEx(hKey, SZ_USE_PASSWORD, 0, PWRD_REG_TYPE, PasswdRegData(IsDlgButtonChecked(hDlg,IDC_USEPASSWORD)), CB_USE_PWRD_VALUE);
            }
            else
            {
                RegSetValueEx(hKey, SZ_USE_PASSWORD, 0, PWRD_REG_TYPE, PasswdRegData(IsDlgButtonChecked(hDlg,IDC_USEPASSWORD)), CB_USE_PWRD_VALUE);
            }
        }

        RegCloseKey(hKey);
    }

    // Broadcast a WM_WININICHANGE message...
    SendNotifyMessage(HWND_BROADCAST, WM_WININICHANGE, 0, (LPARAM)TEXT("Windows"));

    return hr;
}

/*
 * Thread for DoScreenSaver()
 */
typedef struct
{
    HWND    hDlg;
    TCHAR   szPath[MAX_PATH];
    TCHAR   szArgs[MAX_PATH];
} SSRUNDATA, *LPSSRUNDATA;

DWORD RunScreenSaverThread( LPVOID lpv )
{
    BOOL bSvrState;
    LPSSRUNDATA lpssrd;
    HWND hwndSettings, hwndPreview;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    HINSTANCE hiThd;
    TCHAR szPath[MAX_PATH];

    // Lock ourselves in mem so we don't fault if app unloads us
    GetModuleFileName(HINST_THISDLL, szPath, ARRAYSIZE(szPath));
    hiThd = LoadLibrary( szPath );

    lpssrd = (LPSSRUNDATA)lpv;

    hwndSettings = GetDlgItem( lpssrd->hDlg, IDC_SETTING);
    hwndPreview  = GetDlgItem( lpssrd->hDlg, IDC_TEST);

    // Save previous screen saver state
    ClassicSystemParametersInfo( SPI_GETSCREENSAVEACTIVE,0, &bSvrState, FALSE);

    // Disable current screen saver
    if( bSvrState )
        ClassicSystemParametersInfo( SPI_SETSCREENSAVEACTIVE,FALSE, NULL, FALSE );

    // Stop the miniture preview screen saver
    if (g_fPreviewActive)
        SetNewSSDemo( lpssrd->hDlg, -1);

    // Exec the screen saver and wait for it to die
    ZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = (WORD)SW_NORMAL;

    if (CreateProcess(lpssrd->szPath, lpssrd->szArgs, NULL, NULL, FALSE, 0, NULL, NULL, &StartupInfo, &ProcessInformation))
    {
        WaitForSingleObject( ProcessInformation.hProcess, INFINITE );
        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);
    }

    // Restore Screen saver state
    if( bSvrState )
        ClassicSystemParametersInfo( SPI_SETSCREENSAVEACTIVE, bSvrState, NULL, FALSE );

    // Restart miniture preview
    PostMessage(lpssrd->hDlg, WMUSER_SETINITSS, NULL, (LPARAM)TRUE);
    PostMessage(lpssrd->hDlg, WM_COMMAND, MAKELONG(IDC_CHOICES, CBN_SELCHANGE),
                                    (LPARAM)GetDlgItem( lpssrd->hDlg, IDC_CHOICES));
    PostMessage(lpssrd->hDlg, WMUSER_SETINITSS, NULL, (LPARAM)FALSE);

    // Enable setting and preview buttons
    EnableWindow( hwndSettings, TRUE );
    EnableWindow( hwndPreview,  TRUE );

    LocalFree( lpv );

    if (hiThd)
    {
        FreeLibraryAndExitThread( hiThd, 0 );
    }

    return 0;
}


// This routine actually calls the screen saver...
void DoScreenSaver(HWND hWnd, BOOL fSaver)
{
    if (g_szSaverName[0] != TEXT('\0'))
    {
        LPSSRUNDATA lpssrd = (LPSSRUNDATA) LocalAlloc(LMEM_FIXED, sizeof(*lpssrd));
        if (lpssrd != NULL)
        {
            lpssrd->hDlg = hWnd;
            StringCchCopy(lpssrd->szPath, ARRAYSIZE(lpssrd->szPath), g_szSaverName);

            if (fSaver)
            {
                _PathBuildArgs(lpssrd->szArgs, ARRAYSIZE(lpssrd->szArgs), g_szSaverName, TEXT(" /s"));
            }
            else 
            {
                _PathBuildArgs(lpssrd->szArgs, ARRAYSIZE(lpssrd->szArgs), g_szSaverName, TEXT(" /c:%lu"), (LPARAM)hWnd);
            }

            // Disable setting and preview buttons
            HWND hwndSettings = GetDlgItem(hWnd, IDC_SETTING);
            HWND hwndPreview  = GetDlgItem(hWnd, IDC_TEST);

            EnableWindow(hwndSettings, FALSE);
            EnableWindow(hwndPreview,  FALSE);

            DWORD id;
            HANDLE hThd = CreateThread(NULL, 0, RunScreenSaverThread, lpssrd, 0, &id);
            if (hThd != NULL)
            {
                CloseHandle(hThd);
            }
            else
            {
                // Exec failed, re-enable setting and preview buttons and clean up thread params
                EnableWindow(hwndSettings, TRUE);
                EnableWindow(hwndPreview,  TRUE);
                LocalFree(lpssrd);
            }
        }
    }
}


#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))

LPTSTR FileName(LPTSTR szPath)
{
    LPTSTR   sz;

    for (sz=szPath; *sz; sz++)
    {
        NULL;
    }

    for (; sz>=szPath && !SLASH(*sz) && *sz!=TEXT(':'); sz--)
    {
        NULL;
    }

    return ++sz;
}

void AddBackslash(LPTSTR pszPath, DWORD cchPath)
{
    if( pszPath[ lstrlen( pszPath ) - 1 ] != TEXT('\\') )
    {
        StringCchCat( pszPath, cchPath, TEXT("\\") );
    }
}


LPTSTR StripPathName(LPTSTR szPath)
{
    LPTSTR   sz = FileName(szPath);

    if (sz > szPath+1 && SLASH(sz[-1]) && sz[-2] != TEXT(':'))
    {
        sz--;
    }

    *sz = 0;
    return szPath;
}

void AppendPath(LPTSTR pszPath, DWORD cchPath, LPTSTR pszSpec)
{
    AddBackslash(pszPath, cchPath);
    StringCchCat(pszPath, cchPath, pszSpec);
}


LPTSTR NiceName(LPTSTR szPath)
{
    LPTSTR   sz;
    LPTSTR   lpsztmp;

    sz = FileName(szPath);

    for(lpsztmp = sz; *lpsztmp  && *lpsztmp != TEXT('.'); lpsztmp = CharNext(lpsztmp))
    {
        NULL;
    }

    *lpsztmp = TEXT('\0');

    if (IsCharUpper(sz[0]) && IsCharUpper(sz[1]))
    {
        CharLower(sz);
        CharUpperBuff(sz, 1);
    }

    return sz;
}


HRESULT HrStrToVariant(IN LPCWSTR pszString, VARIANT * pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszString && pVar)
    {
        pVar->vt = VT_BSTR;
        hr = HrSysAllocStringW(pszString, &pVar->bstrVal);
    }

    return hr;
}





//===========================
// *** IBasePropPage Interface ***
//===========================
HRESULT CScreenSaverPg::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        *ppAdvDialog = NULL;
        hr = E_NOTIMPL;     // We don't want to add an Advnaced Dialog.
    }

    return hr;
}


HRESULT CScreenSaverPg::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    HRESULT hr = S_OK;

    if (PPOAACTION_CANCEL != oaAction)
    {
        if (m_hDlg)
        {
            // Make sure the time we have is the last one entered...
            SendMessage(m_hDlg, WM_COMMAND, MAKELONG(IDC_SCREENSAVEDELAY, EN_KILLFOCUS), (LPARAM)GetDlgItem(m_hDlg, IDC_SCREENSAVEDELAY));
        }

        // Try to save the current settings...
        _SaveIni(m_hDlg);
    }

    if (PPOAACTION_OK == oaAction)
    {
    }

    return hr;
}




//===========================
// *** IShellPropSheetExt Interface ***
//===========================
HRESULT CScreenSaverPg::AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam)
{
    HRESULT hr = E_INVALIDARG;
    PROPSHEETPAGE psp = {0};

    psp.dwSize = sizeof(psp);
    psp.hInstance = HINST_THISDLL;
    psp.dwFlags = PSP_DEFAULT;
    psp.lParam = (LPARAM) this;

    psp.pszTemplate = MAKEINTRESOURCE(DLG_SCREENSAVER);
    psp.pfnDlgProc = ScreenSaverDlgProc;

    HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);
    if (hpsp)
    {
        if (pfnAddPage(hpsp, lParam))
        {
            hr = S_OK;
        }
        else
        {
            DestroyPropertySheetPage(hpsp);
            hr = E_FAIL;
        }
    }

    return hr;
}



//===========================
// *** IPropertyBag Interface ***
//===========================
HRESULT CScreenSaverPg::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_SCREENSAVER_PATH))
        {
            // The caller is asking for the ScreenSaver path.
            WCHAR szLongPath[MAX_PATH];

            DWORD cchSize = GetLongPathName(g_szSaverName, szLongPath, ARRAYSIZE(szLongPath));
            if ((0 == cchSize) || (ARRAYSIZE(szLongPath) < cchSize))
            {
                // It failed
                StringCchCopy(szLongPath, ARRAYSIZE(szLongPath), g_szSaverName);
            }

            hr = HrStrToVariant(szLongPath, pVar);
        }
    }

    return hr;
}


HRESULT CScreenSaverPg::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar && (VT_BSTR == pVar->vt))
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_SCREENSAVER_PATH))
        {
            if (m_fScreenSavePolicy && !m_fScreenSaveActive)
            {
                hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            }
            else
            {
                _SetByPath(pVar->bstrVal);
                hr = S_OK;
            }
        }
    }

    return hr;
}



HRESULT CScreenSaverPg::_SetByPath(LPCWSTR pszPath)
{
    HRESULT hr = S_OK;

    // COMPATIBILITY: always use short name
    // otherwise some apps fault when peeking at SYSTEM.INI
    DWORD cchSize = GetShortPathNameW(pszPath, g_szSaverName, ARRAYSIZE(g_szSaverName));
    if ((0 == cchSize) || (ARRAYSIZE(g_szSaverName) < cchSize))
    {
        // It failed
        StringCchCopy(g_szSaverName, ARRAYSIZE(g_szSaverName), pszPath);
    }

    if (m_hDlg)
    {
        ComboBox_SetCurSel(m_hDlg, 0);
        SelectSSFromList(m_hDlg);
    }

    return hr;
}


//===========================
// *** IUnknown Interface ***
//===========================
ULONG CScreenSaverPg::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CScreenSaverPg::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CScreenSaverPg::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CScreenSaverPg, IObjectWithSite),
        QITABENT(CScreenSaverPg, IPropertyBag),
        QITABENT(CScreenSaverPg, IPersist),
        QITABENT(CScreenSaverPg, IBasePropPage),
        QITABENTMULTI(CScreenSaverPg, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CScreenSaverPg::CScreenSaverPg() : CObjectCLSID(&PPID_ScreenSaver), m_cRef(1)
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.

    // This is a global that we want to initialize.
    g_szSaverName[0] = TEXT('\0');

    m_fScreenSavePolicy = FALSE;
    m_fScreenSaveActive = TRUE;
    m_lWaitTime = 0;
    m_hDlg = NULL;
    m_fUIInitialized = FALSE;

    _InitState();
}


HRESULT CScreenSaverPage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (!punkOuter && ppvObj)
    {
        CScreenSaverPg * pThis = new CScreenSaverPg();

        *ppvObj = NULL;
        if (pThis)
        {
            hr = pThis->QueryInterface(riid, ppvObj);
            pThis->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\regutil.cpp ===
/*****************************************************************************\
    FILE: regutil.cpp

    DESCRIPTION:
        This file will contain helper functions to load and save values to the
    registry that are theme related.

    BryanSt 3/24/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "regutil.h"


EXTERN_C void FAR SetMagicColors(HDC, DWORD, WORD);

// strings for color names in "WIN.INI".
PTSTR s_pszColorNames[] = {
/* COLOR_SCROLLBAR           */ TEXT("Scrollbar"),              // 0
/* COLOR_DESKTOP             */ TEXT("Background"),
/* COLOR_ACTIVECAPTION       */ TEXT("ActiveTitle"),
/* COLOR_INACTIVECAPTION     */ TEXT("InactiveTitle"),
/* COLOR_MENU                */ TEXT("Menu"),
/* COLOR_WINDOW              */ TEXT("Window"),                 // 5
/* COLOR_WINDOWFRAME         */ TEXT("WindowFrame"),
/* COLOR_MENUTEXT            */ TEXT("MenuText"),
/* COLOR_WINDOWTEXT          */ TEXT("WindowText"),
/* COLOR_CAPTIONTEXT         */ TEXT("TitleText"),
/* COLOR_ACTIVEBORDER        */ TEXT("ActiveBorder"),           // 10
/* COLOR_INACTIVEBORDER      */ TEXT("InactiveBorder"),
/* COLOR_APPWORKSPACE        */ TEXT("AppWorkspace"),
/* COLOR_HIGHLIGHT           */ TEXT("Hilight"),
/* COLOR_HIGHLIGHTTEXT       */ TEXT("HilightText"),
/* COLOR_3DFACE              */ TEXT("ButtonFace"),             // 15
/* COLOR_3DSHADOW            */ TEXT("ButtonShadow"),
/* COLOR_GRAYTEXT            */ TEXT("GrayText"),
/* COLOR_BTNTEXT             */ TEXT("ButtonText"),
/* COLOR_INACTIVECAPTIONTEXT */ TEXT("InactiveTitleText"),
/* COLOR_3DHILIGHT           */ TEXT("ButtonHilight"),          // 20
/* COLOR_3DDKSHADOW          */ TEXT("ButtonDkShadow"),
/* COLOR_3DLIGHT             */ TEXT("ButtonLight"),
/* COLOR_INFOTEXT            */ TEXT("InfoText"),
/* COLOR_INFOBK              */ TEXT("InfoWindow"),
/* COLOR_3DALTFACE           */ TEXT("ButtonAlternateFace"),    // 25
/* COLOR_HOTLIGHT            */ TEXT("HotTrackingColor"),
/* COLOR_GRADIENTACTIVECAPTION   */ TEXT("GradientActiveTitle"),
/* COLOR_GRADIENTINACTIVECAPTION */ TEXT("GradientInactiveTitle"),
/* COLOR_MENUHILIGHT         */ TEXT("MenuHilight"),            // 29
/* COLOR_MENUBAR             */ TEXT("MenuBar"),                // 30
};

// What about: AppWorkSpace

#define SZ_DEFAULT_FONT             TEXT("Tahoma")


/////////////////////////////////////////////////////////////////////
// Private Functions
/////////////////////////////////////////////////////////////////////
HRESULT DPIConvert_SystemMetricsAll(BOOL fScaleSizes, SYSTEMMETRICSALL * pStateToModify, int nFromDPI, int nToDPI)
{
    pStateToModify->schemeData.ncm.lfCaptionFont.lfHeight = MulDiv(pStateToModify->schemeData.ncm.lfCaptionFont.lfHeight, nToDPI, nFromDPI);
    pStateToModify->schemeData.ncm.lfSmCaptionFont.lfHeight = MulDiv(pStateToModify->schemeData.ncm.lfSmCaptionFont.lfHeight, nToDPI, nFromDPI);
    pStateToModify->schemeData.ncm.lfMenuFont.lfHeight = MulDiv(pStateToModify->schemeData.ncm.lfMenuFont.lfHeight, nToDPI, nFromDPI);
    pStateToModify->schemeData.ncm.lfStatusFont.lfHeight = MulDiv(pStateToModify->schemeData.ncm.lfStatusFont.lfHeight, nToDPI, nFromDPI);
    pStateToModify->schemeData.ncm.lfMessageFont.lfHeight = MulDiv(pStateToModify->schemeData.ncm.lfMessageFont.lfHeight, nToDPI, nFromDPI);
    pStateToModify->schemeData.lfIconTitle.lfHeight = MulDiv(pStateToModify->schemeData.lfIconTitle.lfHeight, nToDPI, nFromDPI);

    // Someone (NTUSER?) scales sizes for us.  So we don't need to do that in some cases.
    if (fScaleSizes)
    {
        pStateToModify->schemeData.ncm.iBorderWidth = MulDiv(pStateToModify->schemeData.ncm.iBorderWidth, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iScrollWidth = MulDiv(pStateToModify->schemeData.ncm.iScrollWidth, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iScrollHeight = MulDiv(pStateToModify->schemeData.ncm.iScrollHeight, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iCaptionWidth = MulDiv(pStateToModify->schemeData.ncm.iCaptionWidth, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iCaptionHeight = MulDiv(pStateToModify->schemeData.ncm.iCaptionHeight, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iSmCaptionWidth = MulDiv(pStateToModify->schemeData.ncm.iSmCaptionWidth, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iSmCaptionHeight = MulDiv(pStateToModify->schemeData.ncm.iSmCaptionHeight, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iMenuWidth = MulDiv(pStateToModify->schemeData.ncm.iMenuWidth, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iMenuHeight = MulDiv(pStateToModify->schemeData.ncm.iMenuHeight, nToDPI, nFromDPI);
    }

    return S_OK;
}


HRESULT DPIConvert_SystemMetricsAll_PersistToLive(BOOL fScaleSizes, SYSTEMMETRICSALL * pStateToModify, int nNewDPI)
{
    return DPIConvert_SystemMetricsAll(fScaleSizes, pStateToModify, DPI_PERSISTED, nNewDPI);
}


HRESULT DPIConvert_SystemMetricsAll_LiveToPersist(BOOL fScaleSizes, SYSTEMMETRICSALL * pStateToModify, int nNewDPI)
{
    return DPIConvert_SystemMetricsAll(fScaleSizes, pStateToModify, nNewDPI, DPI_PERSISTED);
}


HRESULT Look_GetSchemeData(IN HKEY hkSchemes, IN LPCTSTR pszSchemeName, IN SCHEMEDATA *psd)
{
    HRESULT hr;
    
    DWORD dwType = REG_BINARY;
    DWORD dwSize = sizeof(*psd);
    hr = HrRegQueryValueEx(hkSchemes, pszSchemeName, NULL, &dwType, (LPBYTE)psd, &dwSize);
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        if (psd->version == SCHEME_VERSION)
        {
            hr = S_OK;
        }
    }

    return hr; //Yes there is a current scheme and there is valid data! 
}


/////////////////////////////////////////////////////////////////////
// Public Functions
/////////////////////////////////////////////////////////////////////
HRESULT IconSize_Load(IN int * pnDXIcon, IN int * pnDYIcon, IN int * pnIcon, IN int * pnSmallIcon)
{
    TCHAR szSize[8];
    DWORD cbSize = sizeof(szSize);

    // default shell icon sizes
    *pnIcon = ClassicGetSystemMetrics(SM_CXICON);
    *pnSmallIcon = ((*pnIcon) / 2);

    HRESULT hr = HrSHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONSIZE, NULL, (LPBYTE)szSize, &cbSize);
    if (SUCCEEDED(hr))
    {
        *pnIcon = StrToInt(szSize);
    }

    cbSize = sizeof(szSize);
    hr = HrSHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_SMALLICONSIZE, NULL, (LPBYTE)szSize, &cbSize);
    if (SUCCEEDED(hr))
    {
        *pnSmallIcon = StrToInt(szSize);
    }

    *pnDXIcon = (ClassicGetSystemMetrics(SM_CXICONSPACING) - *pnIcon);
    if (*pnDXIcon < 0)
    {
        *pnDXIcon = 0;
    }

    *pnDYIcon = (ClassicGetSystemMetrics(SM_CYICONSPACING) - *pnIcon);
    if (*pnDYIcon < 0)
    {
        *pnDYIcon = 0;
    }

    return S_OK;
}


HRESULT IconSize_Save(IN int nDXIcon, IN int nDYIcon, IN int nIcon, IN int nSmallIcon)
{
    HRESULT hr = E_INVALIDARG;

    AssertMsg((0 != nIcon), TEXT("We should never save an icon size of zero."));
    AssertMsg((0 != nSmallIcon), TEXT("We should never save an small icon size of zero."));

    if (nIcon && nSmallIcon)
    {
        TCHAR szSize[8];

        StringCchPrintf(szSize, ARRAYSIZE(szSize), TEXT("%d"), nIcon);
        hr = HrSHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONSIZE, 
            REG_SZ, (LPBYTE)szSize, sizeof(szSize[0]) * (lstrlen(szSize) + 1));
    }

    // WM_SETTINGCHANGE needs to be sent for this to update.  The caller needs to do that.
    return hr;
}


void AssertPositiveFontSizes(SYSTEMMETRICSALL * pState)
{
    // NTUSER will incorrectly scale positive LOGFONT lfHeights so we need to verify
    // that we always set negative sizes.
    AssertMsg((0 > pState->schemeData.lfIconTitle.lfHeight), TEXT("LOGFONT sizes must be negative because of a NTUSER bug. (lfIconTitle)"));
    AssertMsg((0 > pState->schemeData.ncm.lfCaptionFont.lfHeight), TEXT("LOGFONT sizes must be negative because of a NTUSER bug. (lfCaptionFont)"));
    AssertMsg((0 > pState->schemeData.ncm.lfMenuFont.lfHeight), TEXT("LOGFONT sizes must be negative because of a NTUSER bug. (lfMenuFont)"));
    AssertMsg((0 > pState->schemeData.ncm.lfMessageFont.lfHeight), TEXT("LOGFONT sizes must be negative because of a NTUSER bug. (lfMessageFont)"));
    AssertMsg((0 > pState->schemeData.ncm.lfSmCaptionFont.lfHeight), TEXT("LOGFONT sizes must be negative because of a NTUSER bug. (lfSmCaptionFont)"));
    AssertMsg((0 > pState->schemeData.ncm.lfStatusFont.lfHeight), TEXT("LOGFONT sizes must be negative because of a NTUSER bug. (lfStatusFont)"));
}


#define SZ_INILABLE_COLORS                          TEXT("colors")           // colors section name

/*
** set all of the data to the system.
**
** COMPATIBILITY NOTE:
**   EXCEL 5.0 people hook metrics changes off of WM_SYSCOLORCHANGE
** instead of WM_WININICHANGE.  Windows 3.1's Desktop applet always sent
** both when the metrics were updated, so nobody noticed this bug.
**   Be careful when re-arranging this function...
**
*/
HRESULT SystemMetricsAll_Set(IN SYSTEMMETRICSALL * pState, CDimmedWindow* pDimmedWindow)
{
    // COMPATIBILITY:
    //   Do metrics first since the color stuff might cause USER to generate a
    // WM_SYSCOLORCHANGE message and we don't want to send two of them...

    TraceMsg(TF_THEMEUI_SYSMETRICS, "desk.cpl: _SetSysStuff");
    SystemParametersInfoAsync(SPI_SETFLATMENU, NULL, IntToPtr(pState->fFlatMenus), 0, (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE), pDimmedWindow);

    AssertMsg((0 != pState->nIcon), TEXT("We should never save an icon size of zero."));
    AssertMsg((0 != pState->nSmallIcon), TEXT("We should never save an small icon size of zero."));

    // NOTE: It would be nice to create one background thread and then make the 1 or 5 ClassicSystemParametersInfo()
    // calls on that single thread.
    if ((pState->dwChanged & METRIC_CHANGE) && pState->nIcon && pState->nSmallIcon)
    {
        HKEY hkey;

        TraceMsg(TF_THEMEUI_SYSMETRICS, "desk.cpl: Metrics Changed");

        TraceMsg(TF_THEMEUI_SYSMETRICS, "desk.cpl: Calling SPI_SETNONCLIENTMETRICS");
        pState->schemeData.ncm.cbSize = sizeof(pState->schemeData.ncm);
        AssertPositiveFontSizes(pState);
        SystemParametersInfoAsync(SPI_SETNONCLIENTMETRICS, sizeof(pState->schemeData.ncm), (void far *)(LPNONCLIENTMETRICS)&(pState->schemeData.ncm),
                sizeof(pState->schemeData.ncm), (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE), pDimmedWindow);

        TraceMsg(TF_THEMEUI_SYSMETRICS,"desk.cpl: Calling SPI_SETICONTITLELOGFONT");
        SystemParametersInfoAsync(SPI_SETICONTITLELOGFONT, sizeof(LOGFONT), (void far *)(LPLOGFONT)&(pState->schemeData.lfIconTitle),
                sizeof(pState->schemeData.lfIconTitle), (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE), pDimmedWindow);

        TraceMsg(TF_THEMEUI_SYSMETRICS,"desk.cpl: Calling SPI_ICONHORIZONTALSPACING");
        SystemParametersInfoAsync(SPI_ICONHORIZONTALSPACING, pState->nDXIcon + pState->nIcon, NULL, 0, (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE), pDimmedWindow);

        TraceMsg(TF_THEMEUI_SYSMETRICS,"desk.cpl: Calling SPI_ICONVERTICALSPACING");
        SystemParametersInfoAsync(SPI_ICONVERTICALSPACING, pState->nDYIcon + pState->nIcon, NULL, 0, (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE), pDimmedWindow);
        TraceMsg(TF_THEMEUI_SYSMETRICS,"desk.cpl: Done calling SPI's");

        if (RegCreateKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, NULL) == ERROR_SUCCESS)
        {
            TCHAR val[8];

            AssertMsg((0 != pState->nIcon), TEXT("pState->nIcon should never be zero (0)."));
            StringCchPrintf(val, ARRAYSIZE(val), TEXT("%d"), pState->nIcon);
            RegSetValueEx(hkey, SZ_REGVALUE_ICONSIZE, 0, REG_SZ, (LPBYTE)&val, SIZEOF(TCHAR) * (lstrlen(val) + 1));
            RegCloseKey(hkey);
        }

        // WM_SETTINGCHANGE is sent at the end of the function
    }

    if (pState->dwChanged & COLOR_CHANGE)
    {
        int i;
        int iColors[COLOR_MAX];
        COLORREF rgbColors[COLOR_MAX];
        TCHAR szRGB[32];
        COLORREF rgb;
        HKEY     hk;
        HDC      hdc;

        // restore magic colors back to Win31 defaults.
        hdc = GetDC(NULL);
        SetMagicColors(hdc, 0x00c0dcc0, 8);         // money green
        SetMagicColors(hdc, 0x00f0caa6, 9);         // IBM blue
        SetMagicColors(hdc, 0x00f0fbff, 246);       // off white
        ReleaseDC(NULL, hdc);

        // -------------------------------------------------
        // This call causes user to send a WM_SYSCOLORCHANGE
        // -------------------------------------------------
        for (i=0; i < COLOR_MAX; i++)
        {
            iColors[i] = i;
            rgbColors[i] = pState->schemeData.rgb[i] & 0x00FFFFFF;
        }

        SetSysColors(ARRAYSIZE(rgbColors), iColors, rgbColors);

        if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_COLORS, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hk, NULL) == ERROR_SUCCESS)
        {
            // write out the color information to win.ini
            for (i = 0; i < COLOR_MAX; i++)
            {
                rgb = pState->schemeData.rgb[i];
                StringCchPrintf(szRGB, ARRAYSIZE(szRGB), TEXT("%d %d %d"), GetRValue(rgb), GetGValue(rgb), GetBValue(rgb));

                // For the time being we will update the INI file also.
                WriteProfileString(SZ_INILABLE_COLORS, s_pszColorNames[i], szRGB);

                // Update the registry (Be sure to include the terminating zero in the byte count!)
                RegSetValueEx(hk, s_pszColorNames[i], 0L, REG_SZ, (LPBYTE)szRGB, SIZEOF(TCHAR) * (lstrlen(szRGB)+1));
                TraceMsg(TF_THEMEUI_SYSMETRICS, "CPL:Write Color: %s=%s\n\r",s_pszColorNames[i], szRGB);
            }
            RegCloseKey(hk);
        }
    }
    else if (pState->dwChanged & METRIC_CHANGE)
    {
        // COMPATIBILITY HACK:
        // no colors were changed, but metrics were
        // EXCEL 5.0 people tied metrics changes to WM_SYSCOLORCHANGE
        // and ignore the WM_WININICHANGE (now called WM_SETTINGCHANGE)

        // send a bogus WM_SYSCOLORCHANGE
        PostMessageBroadAsync(WM_SYSCOLORCHANGE, 0, 0);
    }

    // if metrics changed at all send a WM_SETTINGCHANGE
    if (pState->dwChanged & METRIC_CHANGE)
    {
        PostMessageBroadAsync(WM_SETTINGCHANGE, SPI_SETNONCLIENTMETRICS, 0);
    }

    return S_OK;
}


HRESULT SystemMetricsAll_Get(IN SYSTEMMETRICSALL * pState)
{
    HKEY hkey;

    // sizes and fonts
    pState->schemeData.ncm.cbSize = sizeof(pState->schemeData.ncm);
    ClassicSystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(pState->schemeData.ncm), (void far *)(LPNONCLIENTMETRICS)&(pState->schemeData.ncm), FALSE);

    ClassicSystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), (void far *)(LPLOGFONT)&(pState->schemeData.lfIconTitle), FALSE);

    // default shell icon sizes
    pState->nIcon = ClassicGetSystemMetrics(SM_CXICON);
    pState->nSmallIcon = pState->nIcon / 2;

    ClassicSystemParametersInfo(SPI_GETFLATMENU, NULL, &pState->fFlatMenus, 0);
    if (RegOpenKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        TCHAR val[8];
        LONG len = sizeof(val);

        if (RegQueryValueEx(hkey, SZ_REGVALUE_ICONSIZE, 0, NULL, (LPBYTE)&val, (LPDWORD)&len) == ERROR_SUCCESS)
        {
            pState->nIcon = StrToInt(val);
        }

        len = SIZEOF(val);
        if (RegQueryValueEx(hkey, SZ_REGVALUE_SMALLICONSIZE, 0, NULL, (LPBYTE)&val, (LPDWORD)&len) == ERROR_SUCCESS)
        {
            pState->nSmallIcon = StrToInt(val);
        }

        RegCloseKey(hkey);
    }

    pState->nDXIcon = ClassicGetSystemMetrics(SM_CXICONSPACING) - pState->nIcon;
    if (pState->nDXIcon < 0)
    {
        pState->nDXIcon = 0;
    }

    pState->nDYIcon = ClassicGetSystemMetrics(SM_CYICONSPACING) - pState->nIcon;
    if (pState->nDYIcon < 0)
    {
        pState->nDYIcon = 0;
    }

    // system colors
    for (int nIndex = 0; nIndex < COLOR_MAX; nIndex++)
    {
        pState->schemeData.rgb[nIndex] = GetSysColor(nIndex);
    }

    // If MENUBAR and MENUHILIGHT are not present, don't use the system defaults, they're wrong.
    // (Hardcoded in ntuser\kernel\global.c). Default to MENU and HILIGHT instead.
    HKEY hKey;
    if (SUCCEEDED(HrRegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_COLORS, 0, KEY_READ, &hKey)))
    {
        TCHAR szColor[15];
        DWORD cbSize = sizeof(szColor);

        if (FAILED(HrRegQueryValueEx(hKey, s_pszColorNames[COLOR_MENUHILIGHT], NULL, NULL, (LPBYTE) szColor, &cbSize)))
        {
            // Copy MenuText to MenuHilight
            pState->schemeData.rgb[COLOR_MENUHILIGHT] = pState->schemeData.rgb[COLOR_HIGHLIGHT];
        }

        cbSize = sizeof(szColor);
        if (FAILED(HrRegQueryValueEx(hKey, s_pszColorNames[COLOR_MENUBAR], NULL, NULL, (LPBYTE) szColor, &cbSize)))
        {
            // Copy Menu to MenuBar
            pState->schemeData.rgb[COLOR_MENUBAR] = pState->schemeData.rgb[COLOR_MENU];
        }
        RegCloseKey(hKey);
    }

    HIGHCONTRAST hc = {0};
    TCHAR szTemp[MAX_PATH];

    szTemp[0] = 0;

    hc.cbSize = sizeof(hc);
    if (SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0))
    {
        pState->fHighContrast = ((hc.dwFlags & HCF_HIGHCONTRASTON) ? TRUE : FALSE);
    }
    else
    {
        pState->fHighContrast = FALSE;
    }

    return S_OK;
}



HRESULT SystemMetricsAll_Copy(IN SYSTEMMETRICSALL * pStateSource, IN SYSTEMMETRICSALL * pStateDest)
{
    CopyMemory(pStateDest, pStateSource, sizeof(*pStateDest));
    return S_OK;
}


HRESULT SystemMetricsAll_Load(IN IThemeSize * pSizeToLoadFrom, IN SYSTEMMETRICSALL * pStateToLoad, IN const int * pnNewDPI)
{
    HRESULT hr = E_INVALIDARG;

    if (pSizeToLoadFrom && pStateToLoad)
    {
        pStateToLoad->schemeData.ncm.cbSize = sizeof(pStateToLoad->schemeData.ncm);
        pStateToLoad->schemeData.version = SCHEME_VERSION;
        pStateToLoad->schemeData.wDummy = 0;

        // Load Behavior System Metrics
        IPropertyBag * pPropertyBag;
        VARIANT var;

        var.boolVal = VARIANT_FALSE;
        hr = pSizeToLoadFrom->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            hr = pPropertyBag->Read(SZ_PBPROP_VSBEHAVIOR_FLATMENUS, &var, NULL);
            pPropertyBag->Release();
        }

        if (SUCCEEDED(hr))
        {
            pStateToLoad->fFlatMenus = (VARIANT_TRUE == var.boolVal);

            // Load Fonts
            hr = pSizeToLoadFrom->GetSystemMetricFont(SMF_CAPTIONFONT, &pStateToLoad->schemeData.ncm.lfCaptionFont);
            if (SUCCEEDED(hr))
            {
                hr = pSizeToLoadFrom->GetSystemMetricFont(SMF_SMCAPTIONFONT, &pStateToLoad->schemeData.ncm.lfSmCaptionFont);
                hr = pSizeToLoadFrom->GetSystemMetricFont(SMF_MENUFONT, &pStateToLoad->schemeData.ncm.lfMenuFont);
                hr = pSizeToLoadFrom->GetSystemMetricFont(SMF_STATUSFONT, &pStateToLoad->schemeData.ncm.lfStatusFont);
                hr = pSizeToLoadFrom->GetSystemMetricFont(SMF_MESSAGEFONT, &pStateToLoad->schemeData.ncm.lfMessageFont);

                hr = pSizeToLoadFrom->GetSystemMetricFont(SMF_ICONTITLEFONT, &pStateToLoad->schemeData.lfIconTitle);

                // Load Sizes
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_BORDERWIDTH, &pStateToLoad->schemeData.ncm.iBorderWidth);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_SCROLLWIDTH, &pStateToLoad->schemeData.ncm.iScrollWidth);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_SCROLLHEIGHT, &pStateToLoad->schemeData.ncm.iScrollHeight);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_CAPTIONWIDTH, &pStateToLoad->schemeData.ncm.iCaptionWidth);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_CAPTIONHEIGHT, &pStateToLoad->schemeData.ncm.iCaptionHeight);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_SMCAPTIONWIDTH, &pStateToLoad->schemeData.ncm.iSmCaptionWidth);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_SMCAPTIONHEIGHT, &pStateToLoad->schemeData.ncm.iSmCaptionHeight);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_MENUWIDTH, &pStateToLoad->schemeData.ncm.iMenuWidth);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_MENUHEIGHT, &pStateToLoad->schemeData.ncm.iMenuHeight);

                // Load Color
                hr = S_OK;
                for (int nIndex = 0; SUCCEEDED(hr) && (nIndex < ARRAYSIZE(pStateToLoad->schemeData.rgb)); nIndex++)
                {
                    hr = pSizeToLoadFrom->get_SystemMetricColor(nIndex, &pStateToLoad->schemeData.rgb[nIndex]);
                }

                if (pnNewDPI)
                {
                    // We need to scale the fonts to fit correctly on the current monitor's DPI.
                    LogSystemMetrics("SystemMetricsAll_Load() BEFORE P->DPI loading AppearSchm", pStateToLoad);
                    DPIConvert_SystemMetricsAll_PersistToLive(TRUE, pStateToLoad, *pnNewDPI);
                    LogSystemMetrics("SystemMetricsAll_Load() AFTER P->DPI loading AppearSchm", pStateToLoad);
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = IconSize_Load(&pStateToLoad->nDXIcon, &pStateToLoad->nDYIcon, &pStateToLoad->nIcon, &pStateToLoad->nSmallIcon);
    }

    if (SUCCEEDED(hr))
    {
        enumThemeContrastLevels ContrastLevel = CONTRAST_NORMAL;

        if (FAILED(pSizeToLoadFrom->get_ContrastLevel(&ContrastLevel)))
        {
            ContrastLevel = CONTRAST_NORMAL;
        }

        pStateToLoad->fHighContrast = ((CONTRAST_NORMAL == ContrastLevel) ? FALSE : TRUE);
    }

    return hr;
}


// Copy the settings from pStateToLoad to pSizeToLoadFrom.
HRESULT SystemMetricsAll_Save(IN SYSTEMMETRICSALL * pState, IN IThemeSize * pSizeToSaveTo, IN const int * pnNewDPI)
{
    HRESULT hr = E_INVALIDARG;

    if (pSizeToSaveTo && pState)
    {
        pState->schemeData.ncm.cbSize = sizeof(pState->schemeData.ncm);
        pState->schemeData.version = SCHEME_VERSION;
        pState->schemeData.wDummy = 0;

        // Load Behavior System Metrics
        IPropertyBag * pPropertyBag;

        hr = pSizeToSaveTo->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            VARIANT var;

            var.vt = VT_BOOL;
            var.boolVal = (pState->fFlatMenus ? VARIANT_TRUE : VARIANT_FALSE);
            hr = pPropertyBag->Write(SZ_PBPROP_VSBEHAVIOR_FLATMENUS, &var);
            pPropertyBag->Release();
        }

        if (pnNewDPI)
        {
            // We need to scale the fonts & sizes to be current DPI independent
            LogSystemMetrics("SystemMetricsAll_Save() BEFORE DPI->P to save AppearSchm", pState);
            DPIConvert_SystemMetricsAll_LiveToPersist(TRUE, pState, *pnNewDPI);
            LogSystemMetrics("SystemMetricsAll_Save() AFTER DPI->P to save AppearSchm", pState);
        }

        // Load Fonts
        hr = pSizeToSaveTo->PutSystemMetricFont(SMF_CAPTIONFONT, &pState->schemeData.ncm.lfCaptionFont);
        hr = pSizeToSaveTo->PutSystemMetricFont(SMF_SMCAPTIONFONT, &pState->schemeData.ncm.lfSmCaptionFont);
        hr = pSizeToSaveTo->PutSystemMetricFont(SMF_MENUFONT, &pState->schemeData.ncm.lfMenuFont);
        hr = pSizeToSaveTo->PutSystemMetricFont(SMF_STATUSFONT, &pState->schemeData.ncm.lfStatusFont);
        hr = pSizeToSaveTo->PutSystemMetricFont(SMF_MESSAGEFONT, &pState->schemeData.ncm.lfMessageFont);

        hr = pSizeToSaveTo->PutSystemMetricFont(SMF_ICONTITLEFONT, &pState->schemeData.lfIconTitle);

        // Load Sizes
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_BORDERWIDTH, pState->schemeData.ncm.iBorderWidth);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_SCROLLWIDTH, pState->schemeData.ncm.iScrollWidth);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_SCROLLHEIGHT, pState->schemeData.ncm.iScrollHeight);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_CAPTIONWIDTH, pState->schemeData.ncm.iCaptionWidth);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_CAPTIONHEIGHT, pState->schemeData.ncm.iCaptionHeight);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_SMCAPTIONWIDTH, pState->schemeData.ncm.iSmCaptionWidth);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_SMCAPTIONHEIGHT, pState->schemeData.ncm.iSmCaptionHeight);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_MENUWIDTH, pState->schemeData.ncm.iMenuWidth);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_MENUHEIGHT, pState->schemeData.ncm.iMenuHeight);

        // Load Color
        for (int nIndex = 0; nIndex < ARRAYSIZE(pState->schemeData.rgb); nIndex++)
        {
            hr = pSizeToSaveTo->put_SystemMetricColor(nIndex, pState->schemeData.rgb[nIndex]);
        }
    }

    // We don't save the icon info if it is zero.  It should never be NULL in normal cases, except when
    // we are converting the settings in the upgrade case.
    if (SUCCEEDED(hr) && pState->nIcon)
    {
        hr = IconSize_Save(pState->nDXIcon, pState->nDYIcon, pState->nIcon, pState->nSmallIcon);
    }

    if (SUCCEEDED(hr))
    {
        enumThemeContrastLevels ContrastLevel = (pState->fHighContrast ? CONTRAST_HIGHBLACK : CONTRAST_NORMAL);
        pSizeToSaveTo->put_ContrastLevel(ContrastLevel);
    }


    return hr;
}





BOOL _GetRegValueString(HKEY hKey, LPCTSTR lpszValName, LPTSTR pszString, int cchSize)
{
    DWORD cbSize = sizeof(pszString[0]) * cchSize;
    DWORD dwType;
    DWORD dwError = RegQueryValueEx(hKey, lpszValName, NULL, &dwType, (LPBYTE)pszString, &cbSize);

    return (ERROR_SUCCESS == dwError);
}


//------------------------------------------------------------------------------------
//      SetRegValueString()
//
//      Just a little helper routine that takes string and writes it to the     registry.
//      Returns: success writing to Registry, should be always TRUE.
//------------------------------------------------------------------------------------
BOOL SetRegValueString(HKEY hMainKey, LPCTSTR pszSubKey, LPCTSTR pszRegValue, LPCTSTR pszString)
{
    HKEY hKey;
    BOOL fSucceeded = FALSE;
    DWORD dwDisposition;

    DWORD dwError = RegCreateKeyEx(hMainKey, pszSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hKey, &dwDisposition);
    if (ERROR_SUCCESS == dwError)
    {
        dwError = SHRegSetPath(hKey, NULL, pszRegValue, pszString, 0);
        if (ERROR_SUCCESS == dwError)
        {
            fSucceeded = TRUE;
        }

        RegCloseKey(hKey);
    }

    return fSucceeded;
}


//------------------------------------------------------------------------------------
//      GetRegValueString()
//
//      Just a little helper routine, gets an individual string value from the
//      registry and returns it to the caller. Takes care of registry headaches,
//      including a paranoid length check before getting the string.
//
//      Returns: success of string retrieval
//------------------------------------------------------------------------------------
BOOL GetRegValueString( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPTSTR lpszValue, int iMaxSize )
{
    HKEY hKey;                   // cur open key
    LONG lRet = RegOpenKeyEx( hMainKey, lpszSubKey, (DWORD)0, KEY_QUERY_VALUE, (PHKEY)&hKey );
    if( lRet == ERROR_SUCCESS )
    {
        BOOL fRet = _GetRegValueString(hKey, lpszValName, lpszValue, iMaxSize);

        // close subkey
        RegCloseKey( hKey );
        return fRet;
    }

    return FALSE;
}


//------------------------------------------------------------------------------------
//      SetRegValueDword()
//
//      Just a little helper routine that takes an dword and writes it to the
//      supplied location.
//
//      Returns: success writing to Registry, should be always TRUE.
//------------------------------------------------------------------------------------
BOOL SetRegValueDword( HKEY hk, LPCTSTR pSubKey, LPCTSTR pValue, DWORD dwVal )
{
    HKEY hkey = NULL;
    BOOL bRet = FALSE;

    if (ERROR_SUCCESS == RegOpenKeyEx( hk, pSubKey, 0, KEY_WRITE, &hkey))
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkey, pValue, 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(DWORD)))
        {
            bRet = TRUE;
        }
    }


    if (hkey)
    {
        RegCloseKey( hkey );
    }

    return bRet;
}


//------------------------------------------------------------------------------------
//      GetRegValueDword()
//
//      Just a little helper routine that takes an dword and writes it to the
//      supplied location.
//
//      Returns: success writing to Registry, should be always TRUE.
//------------------------------------------------------------------------------------
DWORD GetRegValueDword( HKEY hk, LPCTSTR pSubKey, LPCTSTR pValue )
{
    HKEY hkey = NULL;
    DWORD dwVal = REG_BAD_DWORD;

    if (ERROR_SUCCESS == RegOpenKeyEx( hk, pSubKey, 0, KEY_READ, &hkey ))
    {
        DWORD dwType, dwSize = sizeof(DWORD);

        RegQueryValueEx( hkey, pValue, NULL, &dwType, (LPBYTE)&dwVal, &dwSize );
    }

    if (hkey)
    {
        RegCloseKey( hkey );
    }

    return dwVal;
}


//------------------------------------------------------------------------------------
//      SetRegValueInt()
//
//      Just a little helper routine that takes an int and writes it as a string to the
//      registry.
//
//      Returns: success writing to Registry, should be always TRUE.
//------------------------------------------------------------------------------------
BOOL SetRegValueInt( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, int iValue )
{
    TCHAR szValue[16];

    StringCchPrintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), iValue);
    return SetRegValueString( hMainKey, lpszSubKey, lpszValName, szValue );
}


//------------------------------------------------------------------------------------
//      GetRegValueInt()
//
//      Just a little helper routine, gets an individual string value from the
//      registry and returns it to the caller as an int. Takes care of registry headaches,
//      including a paranoid length check before getting the string.
//
//      Returns: success of string retrieval
//------------------------------------------------------------------------------------
BOOL GetRegValueInt(HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, int* piValue)
{
    TCHAR szValue[16];

    szValue[0] = 0;
    BOOL bOK = GetRegValueString( hMainKey, lpszSubKey, lpszValName, szValue, ARRAYSIZE(szValue));
    *piValue = StrToInt(szValue);

    return bOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\settings.cpp ===
#include "priv.h"

static const TCHAR sc_szCoverClass[] = TEXT("DeskSaysNoPeekingItsASurprise");
const TCHAR g_szNULL[] = TEXT("");


int FmtMessageBox(HWND hwnd, UINT fuStyle, DWORD dwTitleID, DWORD dwTextID)
{
    TCHAR Title[256];
    TCHAR Text[2000];

    LoadString(HINST_THISDLL, dwTextID, Text, ARRAYSIZE(Text));
    LoadString(HINST_THISDLL, dwTitleID, Title, ARRAYSIZE(Title));

    return (ShellMessageBox(HINST_THISDLL, hwnd, Text, Title, fuStyle));
}

HBITMAP FAR LoadMonitorBitmap( BOOL bFillDesktop )
{
    HBITMAP hbm,hbmT;
    BITMAP bm;
    HBRUSH hbrT;
    HDC hdc;

    hbm = LoadBitmap(HINST_THISDLL, MAKEINTRESOURCE(IDB_MONITOR));

    if (hbm == NULL)
    {
        return NULL;
    }

    //
    // convert the "base" of the monitor to the right color.
    //
    // the lower left of the bitmap has a transparent color
    // we fixup using FloodFill
    //
    hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        hbmT = (HBITMAP) SelectObject(hdc, hbm);
        hbrT = (HBRUSH) SelectObject(hdc, GetSysColorBrush(COLOR_3DFACE));

        GetObject(hbm, sizeof(bm), &bm);

        ExtFloodFill(hdc, 0, bm.bmHeight-1, GetPixel(hdc, 0, bm.bmHeight-1), FLOODFILLSURFACE);

        // unless the caller would like to do it, we fill in the desktop here
        if( bFillDesktop )
        {
            SelectObject(hdc, GetSysColorBrush(COLOR_DESKTOP));

            ExtFloodFill(hdc, MON_X+1, MON_Y+1, GetPixel(hdc, MON_X+1, MON_Y+1), FLOODFILLSURFACE);
        }

        // clean up after ourselves
        SelectObject(hdc, hbrT);
        SelectObject(hdc, hbmT);
        DeleteDC(hdc);
    }

    return hbm;
}

BOOL CALLBACK _AddDisplayPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER FAR * ppsh = (PROPSHEETHEADER FAR *) lParam;

    if (ppsh)
    {
        if (hpage && (ppsh->nPages < MAX_PAGES))
        {
            ppsh->phpage[ppsh->nPages++] = hpage;
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\regutil.h ===
/*****************************************************************************\
    FILE: regutil.h

    DESCRIPTION:
        This file will contain helper functions to load and save values to the
    registry that are theme related.

    BryanSt 3/24/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _REGUTIL_H
#define _REGUTIL_H

#define MAX_THEME_SIZE          MAX_PATH


/////////////////////////////////////////////////////////////////////
// String Constants
/////////////////////////////////////////////////////////////////////
// Registry Strings
#define SZ_REGKEY_CPDESKTOP             TEXT("Control Panel\\Desktop")
#define SZ_REGKEY_USERMETRICS           TEXT("Control Panel\\Desktop\\WindowMetrics")
#define SZ_REGKEY_APPEARANCE            TEXT("Control Panel\\Appearance")
#define SZ_APPEARANCE_SCHEMES           TEXT("Control Panel\\Appearance\\Schemes")
#define SZ_APPEARANCE_NEWSCHEMES        TEXT("Control Panel\\Appearance\\New Schemes")
#define SZ_REGKEY_UPGRADE_KEY           TEXT("Control Panel\\Appearance\\New Schemes\\Current Settings\\Sizes\\0")
#define SZ_REGKEY_ACCESS_HIGHCONTRAST   TEXT("Control Panel\\Accessibility\\HighContrast")
#define SZ_REGKEY_CP_CURSORS            TEXT("Control Panel\\Cursors")
#define SZ_REGKEY_STYLES                TEXT("Styles")
#define SZ_REGKEY_SIZES                 TEXT("Sizes")
#define SZ_THEMES_MSTHEMEDIRS           SZ_THEMES TEXT("\\VisualStyleDirs")
#define SZ_THEMES_THEMEDIRS             SZ_THEMES TEXT("\\InstalledThemes")
#define SZ_REGKEY_PLUS98DIR             TEXT("Software\\Microsoft\\Plus!98")
#define SZ_REGKEY_CURRENT_THEME         TEXT("Software\\Microsoft\\Plus!\\Themes\\Current")
#define SZ_REGKEY_THEME_FILTERS         TEXT("Software\\Microsoft\\Plus!\\Themes\\Apply")
#define SZ_REGKEY_IE_DOWNLOADDIR        TEXT("Software\\Microsoft\\Internet Explorer")
#define SZ_THEMES                       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Themes")
#define SZ_REGKEY_LASTTHEME             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\LastTheme")
#define SZ_REGKEY_THEME_SITES           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\DownloadSites")
#define SZ_REGKEY_THEME_DEFVSON         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\DefaultVisualStyleOn")
#define SZ_REGKEY_THEME_DEFVSOFF        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\DefaultVisualStyleOff")
#define SZ_CP_SETTINGS_VIDEO            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Settings\\Video")

#define SZ_REGVALUE_PLUS98DIR           TEXT("Path")
#define SZ_REGVALUE_ICONSIZE            TEXT("Shell Icon Size")
#define SZ_REGVALUE_SMALLICONSIZE       TEXT("Shell Small Icon Size")
#define SZ_REGVALUE_DEFAULTFONTNAME     TEXT("DefaultFontName")
#define SZ_REGVALUE_RECENTFOURCHARSETS  TEXT("RecentFourCharsets")
#define SZ_REGVALUE_DISPLAYNAME         TEXT("DisplayName")
#define SZ_REGVALUE_DISPLAYTHEMESPG     TEXT("DisplayThemesPage")
#define SZ_REGVALUE_DISPLAYSCHEMES      TEXT("DisplaySchemes")
#define SZ_REGVALUE_DISPLAYSCHEMES64    TEXT("DisplaySchemes64")
#define SZ_REGVALUE_CURRENT             TEXT("Current")
#define SZ_REGVALUE_CURRENTSCHEME       TEXT("CurrentScheme")
#define SZ_REGVALUE_SELECTEDSIZE        TEXT("SelectedSize")
#define SZ_REGVALUE_SELECTEDSTYLE       TEXT("SelectedStyle")
#define SZ_REGVALUE_CONTRASTLEVEL       TEXT("Contrast")
#define SZ_REGVALUE_DROPSHADOW          TEXT("Drop Shadow")
#define SZ_REGVALUE_FLATMENUS           TEXT("Flat Menus")
#define SZ_REGVALUE_LEGACYNAME          TEXT("LegacyName")
#define SZ_REGVALUE_ENABLEPLUSTHEMES    TEXT("Enable Plus Themes")
#define SZ_REGVALUE_CURRENT_SETTINGS    TEXT("Current Settings ")
#define SZ_REGVALUE_LOGINFO             TEXT("LoggingOn")
#define SZ_REGVALUE_ENABLEPREVIEW       TEXT("Enable Preview")
#define SZ_REGVALUE_ENABLETHEMEINSTALL  TEXT("Enable Theme Install")
#define SZ_REGVALUE_IE_DOWNLOADDIR      TEXT("Download Directory")
#define SZ_REGVALUE_ICONCOLORDEPTH      TEXT("Shell Icon BPP")          // (4 if the checkbox is false, otherwise 16, don't set it to anything else)
#define SZ_REGVALUE_SMOOTHSCROLL        TEXT("SmoothScroll")
#define SZ_REGVALUE_LT_THEMEFILE        TEXT("ThemeFile")
#define SZ_REGVALUE_LT_WALLPAPER        TEXT("Wallpaper")
#define SZ_REGVALUE_INSTALL_THEME       TEXT("InstallTheme")
#define SZ_REGVALUE_INSTALLCUSTOM_THEME TEXT("CustomInstallTheme")
#define SZ_REGVALUE_INSTALL_VISUALSTYLE TEXT("InstallVisualStyle")
#define SZ_REGVALUE_INSTALL_VSCOLOR     TEXT("InstallVisualStyleColor")
#define SZ_REGVALUE_INSTALL_VSSIZE      TEXT("InstallVisualStyleSize")
#define SZ_REGVALUE_MODIFIED_DISPNAME   TEXT("DisplayName of Modified")
#define SZ_REGVALUE_POLICY_SETVISUALSTYLE       TEXT("SetVisualStyle")          // This policy means that this visual style always needs to be set.
#define SZ_REGVALUE_POLICY_INSTALLVISUALSTYLE   TEXT("InstallVisualStyle")      // This policy means that this visual style should be installed the first time whistler is used
#define SZ_REGVALUE_POLICY_INSTALLTHEME         TEXT("InstallTheme")            // This policy indicates the .theme to install
#define SZ_REGVALUE_CONVERTED_WALLPAPER TEXT("ConvertedWallpaper")
#define SZ_REGVALUE_NO_THEMEINSTALL     TEXT("NoThemeInstall")                  // If this is REG_SZ "TRUE" in HKCU or HKLM, then no .Theme or .msstyles will be loaded during setup.
#define SZ_REGVALUE_ACCESS_HCFLAGS      TEXT("Flags")                           // Accessibility High Contrast Flags
#define SZ_REGVALUE_CURSOR_CURRENTSCHEME TEXT("Scheme Source")                   // This is the currently selected cursor color scheme in SZ_REGKEY_CP_CURSORS



#define SZ_REGKEY_POLICIES_SYSTEM       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System")

// System Policies
#define POLICY_KEY_EXPLORER             L"Explorer"
#define POLICY_KEY_SYSTEM               L"System"
#define POLICY_KEY_ACTIVEDESKTOP        L"ActiveDesktop"
#define SZ_REGKEY_POLICIES_DESKTOP      TEXT("Software\\Policies\\Microsoft\\Windows\\Control Panel\\Desktop")


#define SZ_POLICY_NOCHANGEWALLPAPER     TEXT("NoChangingWallpaper")             // Under CU, "ActiveDesktop"
#define SZ_POLICY_NODISPSCREENSAVERPG   TEXT("NoDispScrSavPage")                // Under CU, "System"
#define SZ_POLICY_SCREENSAVEACTIVE      TEXT("ScreenSaveActive")                // Under CU, SZ_REGKEY_POLICIES_DESKTOP
#define POLICY_VALUE_ANIMATION          L"NoChangeAnimation"                    // Under LM|CU, "Explorer"
#define POLICY_VALUE_KEYBOARDNAV        L"NoChangeKeyboardNavigationIndicators" // Under LM|CU, "Explorer"
#define SZ_POLICY_SCREENSAVETIMEOUT     L"ScreenSaveTimeOut"                    




#define SZ_WEBVW_SKIN_FILE              L"visualstyle.css"

#define SZ_SAVEGROUP_NOSKIN_KEY         L"Control Panel\\Appearance\\New Schemes\\Current Settings SaveNoVisualStyle"
#define SZ_SAVEGROUP_ALL_KEY            L"Control Panel\\Appearance\\New Schemes\\Current Settings SaveAll"

#define SZ_SAVEGROUP_NOSKIN_TITLE       L"Current Settings SaveNoVisualStyle"
#define SZ_SAVEGROUP_ALL_TITLE          L"Current Settings SaveAll"

#define SZ_SAVEGROUP_ALL                TEXT("::SaveAll")
#define SZ_SAVEGROUP_NOSKIN             TEXT("::SaveNoVisualStyle")


#define SCHEME_VERSION 2        // Ver 2 == Unicode

#define SCHEME_VERSION_WIN32 4     // Win32 version of schemes can be loaded from both NT and Win95

#define SCHEME_VERSION_400      1
#define SCHEME_VERSION_NT_400   2

#ifndef COLOR_HOTLIGHT
    #define COLOR_HOTLIGHT              26
    #define COLOR_GRADIENTACTIVECAPTION     27
    #define COLOR_GRADIENTINACTIVECAPTION   28
#endif

#define COLOR_MAX_40                (COLOR_INFOBK+1)
#define COLOR_MAX_41                (COLOR_GRADIENTINACTIVECAPTION+1)

#undef  MAX_SM_COLOR_WIN2k
#define MAX_SM_COLOR_WIN2k COLOR_MAX_41

#define SYSTEM_LOCALE_CHARSET  0  //The first item in the array is always system locale charset.

#define MAXSCHEMENAME 100

#define REG_BAD_DWORD 0xF0F0F0F0




/////////////////////////////////////////////////////////////////////
// Data Structures
/////////////////////////////////////////////////////////////////////
typedef struct
{
    SHORT version;
    // for alignment
    WORD  wDummy;
    NONCLIENTMETRICS ncm;
    LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX];
} SCHEMEDATA;


#define NO_CHANGE     0x0000
#define METRIC_CHANGE 0x0001
#define COLOR_CHANGE  0x0002
#define DPI_CHANGE    0x0004
#define SCHEME_CHANGE 0x8000

typedef struct
{
    DWORD dwChanged;
    SCHEMEDATA schemeData;
    int nDXIcon;
    int nDYIcon;
    int nIcon;
    int nSmallIcon;
    BOOL fModifiedScheme;
    BOOL fFlatMenus;
    BOOL fHighContrast;
}  SYSTEMMETRICSALL;




/////////////////////////////////////////////////////////////////////
// Shared Function
/////////////////////////////////////////////////////////////////////
// Theme Store Functions
HRESULT SystemMetricsAll_Set(IN SYSTEMMETRICSALL * pState, CDimmedWindow* pDimmedWindow);
HRESULT SystemMetricsAll_Get(IN SYSTEMMETRICSALL * pState);
HRESULT SystemMetricsAll_Copy(IN SYSTEMMETRICSALL * pStateSource, IN SYSTEMMETRICSALL * pStateDest);
HRESULT SystemMetricsAll_Load(IN IThemeSize * pSizeToLoad, IN SYSTEMMETRICSALL * pState, IN const int * pnNewDPI);
HRESULT SystemMetricsAll_Save(IN SYSTEMMETRICSALL * pState, IN IThemeSize * pSizeToSaveTo, IN const int * pnNewDPI);



// Misc.
HRESULT Look_GetSchemeData(IN HKEY hkSchemes, IN LPCTSTR pszSchemeName, IN SCHEMEDATA *psd);

#define LF32toLF(lplf32, lplf)  (*(lplf) = *(lplf32))
#define LFtoLF32(lplf, lplf32)  (*(lplf32) = *(lplf))


#define DPI_PERSISTED           96

// PersistToLive: This will convert the size from the stored size (at 96 DPI) to the current DPI.
// PersistToLive: This will convert the size from the current DPI to the stored size (at 96 DPI).
HRESULT DPIConvert_SystemMetricsAll(BOOL fScaleSizes, SYSTEMMETRICSALL * pStateToModify, int nFromDPI, int nToDPI);

extern PTSTR s_pszColorNames[COLOR_MAX];


BOOL GetRegValueInt(HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, int* piValue);
BOOL SetRegValueInt( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, int iValue );
BOOL SetRegValueDword( HKEY hk, LPCTSTR pSubKey, LPCTSTR pValue, DWORD dwVal );
DWORD GetRegValueDword( HKEY hk, LPCTSTR pSubKey, LPCTSTR pValue );


#include "PreviewSM.h"

#endif // _REGUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\screensaverpg.h ===
/*****************************************************************************\
    FILE: ScreenSaverPg.cpp

    DESCRIPTION:
        This file contains the COM object implementation that will display the
    ScreenSaver tab in the Display Control Panel.

    18-Feb-94   (Tracy Sharpe) Added power management functionality.
               Commented out several pieces of code that weren't being
               used.
    5/30/2000 (Bryan Starbuck) BryanSt: Turned into C++ and COM.  Exposed
              as an API so other tabs can communicate with it.  This enables
              the Plus! Theme page to modify the screen saver.

    Copyright (C) Microsoft Corp 1994-2000. All rights reserved.
\*****************************************************************************/

#ifndef _SSDLG_H
#define _SSDLG_H


HRESULT CScreenSaverPage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);


#endif // _SSDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\resource.h ===
/*****************************************************************************\
    FILE: resource.h

    DESCRIPTION:
        Header file for the resource file

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include <commctrl.h>


//  Features (This is where they are turned on and off)

// With this feature on, we add a "Theme Settings" button
// to the Theme tab.  This will open an advanced dialog to
// set a filter specifying which theme settings to apply
// when changing themes.  Users often get confused about the
// way this "Filter" works, so we are removing it on
// 10-23-2000 (JoelGros & GRaiz).  What users really want is
// layered settings and that this dialog's checkboxes will
// rollback those settings.  Way to late for this given it's
// low priority.
//#define FEATURE_THEME_SETTINGS_DIALOG

// This feature will enable a "Save As..." button on the Themes tab.
// Saving those themes will save the current .msstyles plus system metric
// values.
#define FEATURE_ENABLE_SAVEAS_THEMES


#define IDB_COLOR4               120
#define IDB_COLOR8               121
#define IDB_ENERGYSTAR           122
#define IDB_COLOR4DITHER         123
#define IDB_COLOR16              124
#define IDB_COLOR24              125
#define IDB_MONITOR              126


/////////////////////////////////////////////////////////////////////
// String Resource IDs (0x2000 - 0x10000)
/////////////////////////////////////////////////////////////////////
#define IDS_APPEARANCE_THEME_NAME                       2000
#define IDS_ADVDISPLAY_TITLE                            2001
#define IDS_SIZE_NORMAL                                 2002
#define IDS_NO_SKIN_DISPLAYNAME                         2003
#define IDS_CURRENT                                     2004
#define IDS_DEFAULT_APPEARANCES_SCHEME                  2005
#define IDS_THEMES_SUBDIR                               2007
#define IDS_THEMESUBDIR                                 2008
#define IDS_MYCUSTOMTHEME                               2009
#define IDS_THEME_OTHER                                 2010
#define IDS_THEME_FILETYPE                              2011
#define IDS_THEME_OPENTITLE                             2012
#define IDS_COMBO_EFFECTS_NOLIST                        2013
#define IDS_OLDTHEMENAME                                2014
#define IDS_PLUSTHEMESITE                               2015
#define IDS_THEME_CLASSIC_DISPNAME                      2016
#define IDS_THEME_PRO_DISPNAME                          2017
#define IDS_THEME_PER_DISPNAME                          2018
#define IDS_SCHEME_SIZE_NORMAL_CANONICAL                2019
#define IDS_SCHEME_SIZE_LARGE_CANONICAL                 2020
#define IDS_SCHEME_SIZE_EXTRALARGE_CANONICAL            2021
#define IDS_NONE                                        2022
#define IDS_SCREENRESFIXER_TITLE                        2023
#define IDS_SCREENRESFIXER_TEXT                         2024
#define IDS_MODIFIED_TEMPLATE                           2025
#define IDS_MODIFIED_FALLBACK                           2026
#define IDS_PROMSTHEME_DEFAULTCOLOR                     2027
#define IDS_PROMSTHEME_DEFAULTSIZE                      2028
#define IDS_CONMSTHEME_DEFAULTCOLOR                     2029
#define IDS_CONMSTHEME_DEFAULTSIZE                      2030
#define IDS_RETURNTOWELCOME                             2031
#define IDS_DEFAULTTHEMENAME                            2032
#define IDS_THEME_FILTER                                2033
#define IDS_CHANGESETTINGS_BADDUALVIEW                  2034
#define IDS_DEFAULT_APPEARANCES_SCHEME_CANONICAL        2035
#define IDS_THEMEFILE_WALLPAPER_PATH_PRO                2036
#define IDS_THEMEFILE_FONT_CAPTION                      2037
#define IDS_THEMEFILE_FONT_SMCAPTION                    2038
#define IDS_THEMEFILE_FONT_MENU                         2039
#define IDS_THEMEFILE_FONT_STATUS                       2040
#define IDS_THEMEFILE_FONT_MESSAGE                      2041
#define IDS_THEMEFILE_FONT_ICON                         2042
#define IDS_THEMEFILE_CURSOR_SCHEME                     2043
#define IDS_DEFAULT_APPEARANCES_SIZE_CANONICAL          2044
#define IDS_SETTING_GEN_96DPI                           2045
#define IDS_SETTING_GEN_120DPI                          2046
#define IDS_SETTING_GEN_COMPAT_HELPLINK                 2047
#define IDS_SETUP_BETA2_UPGRADEWALLPAPER                2048
#define IDS_SCREENRESFIXER_ALTTEXT                      2049
#define IDS_PLEASEWAIT                                  2050
#define IDS_THEMEFILE_WALLPAPER_PATH_PER                2051
#define IDS_THEMEFILE_WALLPAPER_PATH_SRV                2052

// Effects strings
//#define IDS_HELPFILE                                    2600  // AVAILABLE
#define IDS_NOICONSMSG1                                 2601
#define IDS_NOICONSMSG                                  2602
#define IDS_BADPATHMSG                                  2603
#define IDS_FONTSMOOTHWONTWORK                          2604
#define IDS_ICONCOLORWONTWORK                           2605
#define IDS_USE_LARGE                                   2613
#define IDS_256COLORPROBLEM                             2614

#define IDS_INVALIDPATH                                 2616
#define IDS_HELPFILE_PLUS                               2617
#define IDS_INTERNET                                    2619
#define IDS_DIRECTORY                                   2620
#define IDS_EFFECTS                                     2621
#define IDS_FADEEFFECT                                  2622
#define IDS_SCROLLEFFECT                                2623
#define IDS_CLEARTYPE                                   2624
#define IDS_STANDARDSMOOTHING                           2625
#define IDS_PAGE_TITLE                                  2626
#define IDS_UNKNOWNMONITOR                              2627
#define IDS_MULTIPLEMONITORS                            2628
#define MSG_CONFIGURATION_PROBLEM                       2629
#define IDS_OLD_DRIVER                                  2630
#define MSG_INVALID_OLD_DISPLAY_DRIVER                  2631
#define MSG_INVALID_NEW_DRIVER                          2632
#define MSG_INVALID_DEFAULT_DISPLAY_MODE                2633
#define MSG_INVALID_DISPLAY_DRIVER                      2634
#define MSG_INVALID_16COLOR_DISPLAY_MODE                2635
#define MSG_INVALID_DISPLAY_MODE                        2636
#define MSG_INVALID_CONFIGURATION                       2637
#define IDS_CHANGE_SETTINGS                             2638
#define IDS_CHANGESETTINGS_FAILED                       2639
#define IDS_REVERTBACK                                  2640
#define IDS_DISPLAYFORMAT                               2641
#define IDS_ADVDIALOGTITLE                              2642
#define IDS_TURNONTITLE                                 2643
#define IDS_TURNONMSG                                   2644
#define IDS_TURNITON                                    2645
#define IDS_SETTINGS_INVALID                            2646
#define IDS_SETTINGS_CANNOT_SAVE                        2648
#define IDS_SETTINGS_FAILED_SAVE                        2649
#define IDS_DYNAMIC_CHANGESETTINGS_FAILED               2650
#define IDS_TROUBLESHOOT_EXEC                           2651
#define IDS_NOTATTACHED                                 2652
#define IDS_PRIMARY                                     2653
#define IDS_SECONDARY                                   2654
#define ID_DSP_TXT_4BIT_COLOR                           2655
#define ID_DSP_TXT_8BIT_COLOR                           2656
#define ID_DSP_TXT_15BIT_COLOR                          2657
#define ID_DSP_TXT_16BIT_COLOR                          2658
#define ID_DSP_TXT_TRUECOLOR24                          2659
#define ID_DSP_TXT_TRUECOLOR32                          2660
#define ID_DSP_TXT_XBYY                                 2661
#define ID_DSP_TXT_CHANGE_FONT                          2662
#define ID_DSP_TXT_NEW_FONT                             2663
#define ID_DSP_TXT_ADMIN_INSTALL                        2664
#define ID_DSP_TXT_FONT_LATER                           2665
#define ID_DSP_CUSTOM_FONTS                             2666
#define ID_DSP_NORMAL_FONTSIZE_TEXT                     2667
#define ID_DSP_CUSTOM_FONTSIZE_TEXT                     2668
#define IDS_UNAVAILABLE                                 2669
#define IDS_10PTSAMPLEFACENAME                          2670
#define IDS_10PTSAMPLE                                  2671
#define IDS_RULERDIRECTION                              2672

// Theme fallback values
#define IDS_TFB_SOUND_DING                              2750        // Sounds
#define IDS_TFB_SOUND_NOTIFY                            2751
#define IDS_TFB_SOUND_CORD                              2752
#define IDS_TFB_SOUND_WINLOGON                          2753


// Error Strings
#define IDS_ERROR_TITLE_APPLYBASEAPPEARANCE             3000
#define IDS_ERROR_APPLYBASEAPPEARANCE                   3001
#define IDS_ERROR_APPLYBASEAPPEARANCE_LOADTHEME         3002
#define IDS_ERROR_UNKNOWN                               3003
#define IDS_ERROR_TITLE_APPLYBASEAPPEARANCE2            3004
#define IDS_ERROR_THEME_INVALID_TITLE                   3005
#define IDS_ERROR_THEME_INVALID                         3006
#define IDS_ERROR_THEME_SERVICE_NOTRUNNING              3007
#define IDS_ERROR_THEME_LOADFAILED                      3008
#define IDS_ERROR_THEME_DELETE                          3009
#define IDS_ERROR_THEME_DELETE_TITLE                    3010
#define IDS_ERROR_THEME_FILE_NOTFOUND                   3011
#define IDS_ERROR_TITLE_LOAD_MSSTYLES_FAIL              3012
#define IDS_ERROR_LOAD_MSSTYLES_FAIL                    3013


// Legacy Appearance Scheme Upgrade Mappings  (800 - 1000)
#define IDS_LEGACYSCHEME_NAME                           800         // 800-849
#define IDS_NEWSTYLE_NAME                               850         // 850-899
#define IDS_NEWSIZE_NAME                                900         // 900-949
#define IDS_NEWCONTRASTFLAGS                            950         // 950-999
#define IDS_LOCALIZATIONPOINTER                        1000         // 1000-1049

#define MAX_LEGACY_UPGRADE_SCENARIOS                    36


/////////////////////////////////////////////////////////////////////
// Dialogs  (1000 - 1100)
/////////////////////////////////////////////////////////////////////
// Base Pages
#define DLG_THEMESPG                                    1000
#define DLG_APPEARANCEPG                                1001
// Advanced Pages
#define DLG_APPEARANCE_ADVANCEDPG                       1002
#define DLG_THEMESETTINGSPG                             1003
// Supporting Dialogs
#define DLG_COLORPICK                                   1005
#define DLG_EFFECTS                                     1006
// Settings Pages
#define DLG_SINGLEMONITOR                               1007
#define DLG_MULTIMONITOR                                1008
#define DLG_WIZPAGE                                     1009
#define DLG_GENERAL                                     1010
#define DLG_KEEPNEW                                     1011
#define DLG_CUSTOMFONT                                  1012
#define DLG_ASKDYNACDS                                  1013
#define DLG_FAKE_SETTINGS                               1014
#define DLG_SCREENSAVER                                 1015
#define DLG_KEEPNEW2                                    1016
#define DLG_KEEPNEW3                                    1017

/////////////////////////////////////////////////////////////////////
// Dialog Controls  (1101 - 2000)
/////////////////////////////////////////////////////////////////////
//// Base Pages
// Themes Page controls
#define IDC_THPG_THEMELIST                              1101
#define IDC_THPG_THEMESETTINGS                          1102
#define IDC_THPG_THEME_PREVIEW                          1103
#define IDC_THPG_THEMEDESCRIPTION                       1104
#define IDC_THPG_THEMENAME                              1105
#define IDC_THPG_SAMPLELABLE                            1106
#define IDC_THPG_SAVEAS                                 1107
#define IDC_THPG_DELETETHEME                            1108


// Appearance Page controls
#define IDC_APPG_APPEARPREVIEW                          1110
#define IDC_APPG_LOOKFEEL                               1111
#define IDC_APPG_LOOKFEEL_LABLE                         1112
#define IDC_APPG_COLORSCHEME_LABLE                      1113
#define IDC_APPG_COLORSCHEME                            1114
#define IDC_APPG_WNDSIZE_LABLE                          1115
#define IDC_APPG_WNDSIZE                                1116
#define IDC_APPG_ADVANCED                               1117
#define IDC_APPG_EFFECTS                                1118
#define IDC_APPG_TESTFAULT                              1119

//// Advanced Pages
// Advanced Appearance controls
#define IDC_ADVAP_LOOKPREV                              1125
#define IDC_ADVAP_ELEMENTS                              1126
#define IDC_ADVAP_SIZELABEL                             1127
#define IDC_ADVAP_MAINSIZE                              1128
#define IDC_ADVAP_FONTNAME                              1129
#define IDC_ADVAP_FONTSIZE                              1130
#define IDC_ADVAP_FONTBOLD                              1131
#define IDC_ADVAP_FONTITAL                              1132
#define IDC_ADVAP_SIZEARROWS                            1133
#define IDC_ADVAP_COLORLABEL                            1134
#define IDC_ADVAP_MAINCOLOR                             1135
#define IDC_ADVAP_TEXTCOLOR                             1136
#define IDC_ADVAP_FONTLABEL                             1137
#define IDC_ADVAP_FNCOLORLABEL                          1138
#define IDC_ADVAP_FONTSIZELABEL                         1139
#define IDC_ADVAP_GRADIENTLABEL                         1140
#define IDC_ADVAP_GRADIENT                              1141
#define IDC_ADVAP_ELEMENTSLABEL                         1142
// Theme Settings controls
#define IDC_TSPG_THEMELIST_LABLE                        1150
#define IDC_TSPG_THEME_NAME                             1151
#define IDC_TSPG_SAVEASBUTTON                           1152
#define IDC_TSPG_DELETEBUTTON                           1153
#define IDC_TSPG_CB_SCREENSAVER                         1154 // Previously CB_SCRSVR
#define IDC_TSPG_CB_SOUNDS                              1155 // Previously CB_SOUND
#define IDC_TSPG_CB_MOUSE                               1156 // Previously CB_PTRS
#define IDC_TSPG_CB_WALLPAPER                           1157 // Previously CB_WALL
#define IDC_TSPG_CB_ICONS                               1158 // Previously CB_ICONS
#define IDC_TSPG_CB_COLORS                              1159 // Previously CB_COLORS
#define IDC_TSPG_CB_FONTS                               1160 // Previously CB_FONTS
#define IDC_TSPG_CB_BORDERS                             1161 // Previously CB_BORDERS
#define IDC_TSPG_CB_GROUP_LABEL                         1162
#define IDC_TSPG_CB_LABEL                               1163

// Effects
#define IDC_FULLWINDOWDRAGGING                          1170
#define IDC_FONTSMOOTHING                               1171
#define IDC_ICONHIGHCOLOR                               1172
#define IDC_STRETCHWALLPAPERFITSCREEN                   1173
#define IDD_PATH                                        1174
#define IDC_MENUANIMATION                               1175
#define IDD_ICON                                        1176
#define IDC_FONTSMOOTH                                  1177
#define IDD_BROWSE                                      1178
#define IDC_SHOWDRAG                                    1179
#define IDC_LARGEICONS                                  1180
#define IDC_KEYBOARDINDICATORS                          1181
#define IDC_COMBOEFFECT                                 1182
#define IDC_SHOWME                                      1183
#define IDC_COMBOFSMOOTH                                1184
#define IDC_MENUSHADOWS                                 1185
#define IDC_GRPBOX_2                                    1186
                     
                        

//// Supporting Dialogs
// Color Picker Dialog controls
#define IDC_CPDLG_16COLORS                              1205
#define IDC_CPDLG_COLORCUST                             1206
#define IDC_CPDLG_COLOROTHER                            1207
#define IDC_CPDLG_COLORETCH                             1208


// Screen Saver Dialog
#define IDC_CHOICES                                     1300
#define IDC_METHOD                                      1301
#define IDC_BIGICONSS                                   1302
#define IDC_SETTING                                     1303
#define IDC_TEST                                        1304
#define IDC_ENERGYSTAR_BMP                              1305
#define IDC_SCREENSAVEDELAY                             1306
#define IDC_SCREENSAVEARROW                             1307
#define IDC_LOWPOWERCONFIG                              1314

#define IDC_DEMO                                        1315
#define IDC_SSDELAYLABEL                                1316
#define IDC_ENERGY_TEXT                                 1317
#define IDC_ENERGY_TEXT2                                1318
#define IDC_ENERGY_TEXT3                                1319
#define IDC_USEPASSWORD                                 1320
#define IDC_SETPASSWORD                                 1321
#define IDC_SSDELAYSCALE                                1322
  


#define IDC_NO_HELP_2                                   201     // should be disabled for a control

// these need to be all clumped together because they are treated as a group
#define IDC_STARTMAINCOLOR      1500
#define IDC_CUSTOMMAINCOLOR     1549
#define IDC_ENDMAINCOLOR        IDC_CUSTOMMAINCOLOR
#define IDC_STARTTEXTCOLOR      1550
#define IDC_CUSTOMTEXTCOLOR     1599
#define IDC_ENDTEXTCOLOR        IDC_CUSTOMTEXTCOLOR
#define IDC_GRADIENT            1600

// Multimonitor controls

#define IDC_DISPLAYLIST         1800
#define IDC_DISPLAYDESK         1801
#define IDC_DISPLAYPROPERTIES   1802
#define IDC_DISPLAYNAME         1803
#define IDC_DISPLAYMODE         1804
#define IDC_DISPLAYUSEME        1805
#define IDC_DISPLAYPRIME        1806
#define IDC_COLORBOX            1807 // used to be ID_DSP_COLORBOX
#define IDC_SCREENSIZE          1808 // used to be ID_DSP_AREA_SB
#define IDC_FLASH               1810
#define IDC_DISPLAYTEXT         1811
#define IDC_SCREENSAMPLE        1812
#define IDC_COLORSAMPLE         1813
#define IDC_RESXY               1814
#define IDC_RES_LESS            1815
#define IDC_RES_MORE            1816
#define IDC_COLORGROUPBOX       1817
#define IDC_RESGROUPBOX         1818
#define IDC_MULTIMONHELP        1819
#define IDC_DISPLAYLABEL        1820
#define IDC_TROUBLESHOOT        1821
#define IDC_IDENTIFY            1822
#define IDC_WARNING_ICON        1823
#define IDC_DISABLEDMONITORS_MESSAGE        1824
#define IDC_DSP_CLRPALGRP       1825
#define IDC_DSP_COLORBAR        1826
#define IDC_DSP_DSKAREAGRP      1827
#define IDC_REFRESH_RATE        1828
#define IDC_MONITOR_BITMAP      1829
#define IDC_BIGICON             1830
#define IDC_COUNTDOWN           1831
#define IDC_FONTSIZEGRP         1832
#define IDC_FONT_SIZE           1833
#define IDC_CUSTFONTPER         1834
#define IDC_FONT_SIZE_STR       1835
#define IDC_DYNA_TEXT           1836
#define IDC_DYNA                1837
#define IDC_NODYNA              1838
#define IDC_YESDYNA             1839
#define IDC_SHUTUP              1840
#define IDC_CUSTOMSAMPLE        1841
#define IDC_CUSTOMRULER         1842
#define IDC_CUSTOMCOMBO         1843
#define IDC_NO_HELP_1           1844
#define IDC_FONTLIST            1845
#define IDC_CUSTOMFONT          1846
#define IDC_CHANGEDRV           1847
#define IDC_SETTINGS_GEN_COMPATWARNING 1848
#define IDC_PROGRESS            1849



// appearance elements
#define ELNAME_DESKTOP          1401
#define ELNAME_INACTIVECAPTION  1402
#define ELNAME_INACTIVEBORDER   1403
#define ELNAME_ACTIVECAPTION    1404
#define ELNAME_ACTIVEBORDER     1405
#define ELNAME_MENU             1406
#define ELNAME_MENUSELECTED     1407
#define ELNAME_WINDOW           1408
#define ELNAME_SCROLLBAR        1409
#define ELNAME_BUTTON           1410
#define ELNAME_SMALLCAPTION     1411
#define ELNAME_ICONTITLE        1412
#define ELNAME_CAPTIONBUTTON    1413
#define ELNAME_DISABLEDMENU     1414
#define ELNAME_MSGBOX           1415
#define ELNAME_SCROLLBUTTON     1416
#define ELNAME_APPSPACE         1417
#define ELNAME_SMCAPSYSBUT      1418
#define ELNAME_SMALLWINDOW      1419
#define ELNAME_DXICON           1420
#define ELNAME_DYICON           1421
#define ELNAME_INFO             1422
#define ELNAME_ICON             1423
#define ELNAME_SMICON           1424
#define ELNAME_HOTTRACKAREA     1425

// appearance strings for sample
#define IDS_ACTIVE              1450
#define IDS_INACTIVE            1451
#define IDS_MINIMIZED           1452
#define IDS_ICONTITLE           1453
#define IDS_NORMAL              1454
#define IDS_DISABLED            1455
#define IDS_SELECTED            1456
#define IDS_MSGBOX              1457
#define IDS_BUTTONTEXT          1458
#define IDS_WINDOWTEXT          1460
#define IDS_MSGBOXTEXT          1461

#define IDS_BLANKNAME           1480
#define IDS_NOSCHEME2DEL        1481

#define IDS_SCHEME_WARNING       1300
#define IDS_FONTCHANGE_IN_SCHEME 1301
#define IDS_COPYOF_SCHEME        1302








/////////////////////////////////////////////////////////////////////
// Help defines (??? -????)
/////////////////////////////////////////////////////////////////////
// Settings tab
#define IDH_DISPLAY_SETTINGS_MONITOR_GRAPHIC            4064  
#define IDH_DISPLAY_SETTINGS_DISPLAY_LIST               4065  
#define IDH_DISPLAY_SETTINGS_COLORBOX                   4066 
#define IDH_DISPLAY_SETTINGS_SCREENAREA                 4067
#define IDH_DISPLAY_SETTINGS_EXTEND_DESKTOP_CHECKBOX    4068  
#define IDH_DISPLAY_SETTINGS_ADVANCED_BUTTON            4069 
#define IDH_DISPLAY_SETTINGS_USE_PRIMARY_CHECKBOX       4072
#define IDH_DISPLAY_SETTINGS_IDENTIFY_BUTTON            4073
#define IDH_DISPLAY_SETTINGS_TROUBLE_BUTTON             4074


#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_FONTSIZE      4080
#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_DYNA          4081
#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_RESTART       4082
#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_DONT_RESTART  4083 
#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_ASK_ME        4084

#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_CUSTOMFONT_LISTBOX    4085
#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_CUSTOMFONT_RULER      4086
#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_CUSTOMFONT_SAMPLE     4087

// Screen saver tab
#define IDH_DISPLAY_SCREENSAVER_SCREENSAVER_PASSWORD_CHECKBOX 4110
#define IDH_DISPLAY_SCREENSAVER_SCREENSAVER_LISTBOX           4111
#define IDH_DISPLAY_SCREENSAVER_SCREENSAVER_WAIT              4112
#define IDH_DISPLAY_SCREENSAVER_SCREENSAVER_PREVIEW           4113
#define IDH_DISPLAY_SCREENSAVER_SCREENSAVER_SETTINGS          4114
#define IDH_DISPLAY_SCREENSAVER_SCREENSAVER_MONITOR           4115
#define IDH_DISPLAY_SCREENSAVER_ENERGYSAVE_GRAPHIC            4116
#define IDH_DISPLAY_SCREENSAVER_POWER_BUTTON                  4117

// Advanced Appearance Tab
#define IDH_DISPLAY_APPEARANCE_SCHEME                   4120
#define IDH_DISPLAY_APPEARANCE_SAVEAS_BUTTON            4121
#define IDH_DISPLAY_APPEARANCE_SAVEAS_DIALOG_TEXTBOX    4170
#define IDH_DISPLAY_APPEARANCE_DELETE_BUTTON            4122
#define IDH_DISPLAY_APPEARANCE_GRAPHIC                  4123
#define IDH_DISPLAY_APPEARANCE_ITEM_SIZE                4124
#define IDH_DISPLAY_APPEARANCE_FONT_BOLD                4125
#define IDH_DISPLAY_APPEARANCE_FONT_SIZE                4126
#define IDH_DISPLAY_APPEARANCE_FONT_COLOR               4127
#define IDH_DISPLAY_APPEARANCE_FONT_ITALIC              4128
#define IDH_DISPLAY_APPEARANCE_ITEM_COLOR               4129
#define IDH_DISPLAY_APPEARANCE_ITEM_LIST                4130
#define IDH_DISPLAY_APPEARANCE_FONT_LIST                4131
#define IDH_DISPLAY_APPEARANCE_GRADIENT                 4132
#define IDH_DISPLAY_APPEARANCE_ITEM_COLOR2              4133

// display.hlp IDH_'s
#define IDH_DISPLAY_EFFECTS_DESKTOP_ICONS               4300
#define IDH_DISPLAY_EFFECTS_CHANGE_ICON_BUTTON          4301
#define IDH_DISPLAY_EFFECTS_ALL_COLORS_CHECKBOX         4302
#define IDH_DISPLAY_EFFECTS_DRAG_WINDOW_CHECKBOX        4303
#define IDH_DISPLAY_EFFECTS_SMOOTH_FONTS_CHECKBOX       4304
//#define IDH_DISPLAY_EFFECTS_STRETCH                   4305    //Obsolete in NT5
#define IDH_DISPLAY_EFFECTS_ANIMATE_WINDOWS             4305
#define IDH_DISPLAY_EFFECTS_LARGE_ICONS_CHECKBOX        4306
#define IDH_DISPLAY_EFFECTS_DEFAULT_ICON_BUTTON         4307
#define IDH_DISPLAY_EFFECTS_HIDE_KEYBOARD_INDICATORS    4308
#define IDH_DISPLAY_EFFECTS_SMOOTH_FONTS_LISTBOX        4309
#define IDH_DISPLAY_EFFECTS_ANIMATE_LISTBOX             4310
#define IDH_DISPLAY_EFFECTS_MENUSHADOWS                 4311


/////////////////////////////////////////////////////////////////////
// Wizard Pages  (401 - 500)
/////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////
// Menu IDs (501 - 530)
/////////////////////////////////////////////////////////////////////
// appearance preview menu
#define IDR_MENU                                        501
#define MENU_MONITOR                                    502

/////////////////////////////////////////////////////////////////////
// Menu Item IDs (531 - 600)
/////////////////////////////////////////////////////////////////////
#define IDM_NORMAL                                      531
#define IDM_DISABLED                                    532
#define IDM_SELECTED                                    533


/////////////////////////////////////////////////////////////////////
// Bitmap Resource IDs (601 - 700)
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
// Icons IDs (701 - 800)
/////////////////////////////////////////////////////////////////////
#define IDS_ICON                                        40                // This icon is actually stored in desk.cpl
#define IDI_THEMEICON                                   701               // This icon is for .theme and .msstyles files.


/////////////////////////////////////////////////////////////////////
// AVI Resource IDs (801 - 900)
/////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\settings.h ===
//
// New message IDs
//

#define MSG_DSP_SETUP_MESSAGE    WM_USER + 0x200



#define SZ_REBOOT_NECESSARY     TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\RebootNecessary")
#define SZ_INVALID_DISPLAY      TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\InvalidDisplay")
#define SZ_DETECT_DISPLAY       TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\DetectDisplay")
#define SZ_NEW_DISPLAY          TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\NewDisplay")
#define SZ_DISPLAY_4BPP_MODES   TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\Display4BppModes")

#define SZ_VIDEO                TEXT("Video")
#define SZ_FONTDPI              TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontDPI")
#define SZ_FONTDPI_PROF         TEXT("SYSTEM\\CurrentControlSet\\Hardware Profiles\\Current\\Software\\Fonts")
#define SZ_LOGPIXELS            TEXT("LogPixels")
#define SZ_DEVICEDESCRIPTION    TEXT("Device Description")
#define SZ_INSTALLEDDRIVERS     TEXT("InstalledDisplayDrivers")
#define SZ_SERVICES             TEXT("\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\")
#define SZ_BACKBACKDOT          TEXT("\\\\.\\")
#define SZ_DOTSYS               TEXT(".sys")
#define SZ_DOTDLL               TEXT(".dll")

#define SZ_FILE_SEPARATOR       TEXT(", ")

#define SZ_WINDOWMETRICS        TEXT("Control Panel\\Desktop\\WindowMetrics")
#define SZ_APPLIEDDPI           TEXT("AppliedDPI")

#define SZ_CONTROLPANEL         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel")
#define SZ_ORIGINALDPI          TEXT("OriginalDPI")



//==========================================================================
//                          Typedefs
//==========================================================================


extern HWND ghwndPropSheet;
extern const TCHAR g_szNULL[];

#define CDPI_NORMAL     96      // Arbitrarily, 96dpi is "Normal"

// information about the monitor bitmap
// x, y, dx, dy define the size of the "screen" part of the bitmap
// the RGB is the color of the screen's desktop
// these numbers are VERY hard-coded to a monitor bitmap
#define MON_X   16
#define MON_Y   17
#define MON_DX  152
#define MON_DY  112
#define MON_W   184
#define MON_H   170
#define MON_RGB RGB(0, 128, 128)
#define MON_TRAY 8

INT_PTR CALLBACK GeneralPageProc    (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK _AddDisplayPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam);
void AddFakeSettingsPage(IThemeUIPages *pThemeUI, PROPSHEETHEADER * ppsh);
INT_PTR CALLBACK MultiMonitorDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
int ComputeNumberOfDisplayDevices();
int FmtMessageBox(HWND hwnd, UINT fuStyle, DWORD dwTitleID, DWORD dwTextID);
HBITMAP FAR LoadMonitorBitmap( BOOL bFillDesktop );
int DisplaySaveSettings(PVOID pContext, HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\settingspg.cpp ===
/*****************************************************************************\
    FILE: SettingsPg.cpp

    DESCRIPTION:
        This code will display a "Settings" tab in the
    "Display Properties" dialog

    BryanSt 1/05/2001    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2001. All rights reserved.
\*****************************************************************************/

#include "priv.h"

#include "SettingsPg.h"
#include "DisplaySettings.h"
#include "shlobjp.h"
#include "shlwapi.h"
#include "ntreg.hxx"
#include "AdvAppearPg.h"
#include <tchar.h>
#include <dbt.h>
#include <oleacc.h>
#include <devguid.h>

#define EIS_NOT_INVALID                          0x00000001
#define EIS_EXEC_INVALID_NEW_DRIVER              0x00000002
#define EIS_EXEC_INVALID_DEFAULT_DISPLAY_MODE    0x00000003
#define EIS_EXEC_INVALID_DISPLAY_DRIVER          0x00000004
#define EIS_EXEC_INVALID_OLD_DISPLAY_DRIVER      0x00000005
#define EIS_EXEC_INVALID_16COLOR_DISPLAY_MODE    0x00000006
#define EIS_EXEC_INVALID_DISPLAY_MODE            0x00000007
#define EIS_EXEC_INVALID_CONFIGURATION           0x00000008
#define EIS_EXEC_INVALID_DISPLAY_DEVICE          0x00000009

LRESULT CALLBACK MonitorWindowProc(HWND hwnd, UINT msg,WPARAM wParam,LPARAM lParam);
LRESULT CALLBACK SliderSubWndProc (HWND hwndSlider, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uID, ULONG_PTR dwRefData);
int ComputeNumberOfDisplayDevices();

BOOL MakeMonitorBitmap(int w, int h, LPCTSTR sz, HBITMAP *pBitmap, HBITMAP *pMaskBitmap, int cx, int cy, BOOL fSelected);

typedef struct _APPEXT {
    TCHAR szKeyName[MAX_PATH];
    TCHAR szDefaultValue[MAX_PATH];
    struct _APPEXT* pNext;
} APPEXT, *PAPPEXT;

VOID CheckForDuplicateAppletExtensions(HKEY hkDriver);
VOID DeskAESnapshot(HKEY hkExtensions, PAPPEXT* ppAppExt);
VOID DeskAECleanup(PAPPEXT pAppExt);
VOID DeskAEDelete(PTCHAR szDeleteFrom, PTCHAR mszExtensionsToRemove);

#define SELECTION_THICKNESS 4
#define MONITOR_BORDER      1

#define REGSTR_VAL_SAFEBOOT        TEXT("System\\CurrentControlSet\\Control\\SafeBoot\\Option")

// Maximum number of monitors supported.
#define MONITORS_MAX    10

#define PREVIEWAREARATIO 2

#define MM_REDRAWPREVIEW (WM_USER + 1)
#define MM_MONITORMOVED  (WM_USER + 2)

#define ToolTip_Activate(hTT, activate) \
    SendMessage(hTT, TTM_ACTIVATE, (WPARAM) activate, (LPARAM) 0)

#define ToolTip_AddTool(hTT, lpti) \
    SendMessage(hTT, TTM_ADDTOOL, (WPARAM) 0, (LPARAM) (lpti))

#define ToolTip_DelTool(hTT, lpti) \
    SendMessage(hTT, TTM_DELTOOL, (WPARAM) 0, (LPARAM) (lpti))

#define ToolTip_GetCurrentTool(hTT, lpti) \
    SendMessage(hTT, TTM_GETCURRENTTOOL, (WPARAM) 0, (LPARAM) (lpti))

#define ToolTip_RelayEvent(hTT, _msg, h, m, wp, lp)                         \
    _msg.hwnd = h; _msg.message = m; _msg.wParam = wp; _msg.lParam = lp;\
    SendMessage(hTT, TTM_RELAYEVENT, (WPARAM) 0, (LPARAM) &_msg);

#define ToolTip_SetDelayTime(hTT, d, t) \
    SendMessage(hTT, TTM_SETDELAYTIME, (WPARAM) d, (LPARAM)MAKELONG((t), 0))

#define ToolTip_SetToolInfo(hTT, lpti) \
    SendMessage(hTT, TTM_SETTOOLINFO, (WPARAM) 0, (LPARAM) (lpti))

#define ToolTip_TrackActivate(hTT, bActivate, lpti) \
    SendMessage(hTT, TTM_TRACKACTIVATE, (WPARAM) (bActivate), (LPARAM) (lpti))

#define ToolTip_TrackPosition(hTT, x, y) \
    SendMessage(hTT, TTM_TRACKPOSITION, (WPARAM) 0, (LPARAM) MAKELONG((x), (y)))

#define ToolTip_Update(hTT) \
    SendMessage(hTT, TTM_UPDATE, (WPARAM) 0, (LPARAM) 0)

VOID
CDECL
TRACE(
    PCTSTR pszMsg,
    ...
    )
/*++

Outputs a message to the setup log.  Prepends "desk.cpl  " to the strings and
appends the correct newline chars (\r\n)==

  --*/
{
    TCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    va_start(vArgs, pszMsg);
    StringCchVPrintf(ach, ARRAYSIZE(ach), pszMsg, vArgs);
    va_end(vArgs);

    OutputDebugString(ach);
}

#ifdef _WIN64
//
//  GetDlgItem and GetDlgCtrlID don't support INT_PTR's,
//  so we have to do it manually.
//  Fortunately, GetWindowLongPtr(GWLP_ID) actually returns a full 64-bit
//  value instead of truncating at 32-bits.
//

#define GetDlgCtrlIDP(hwnd)  GetWindowLongPtr(hwnd, GWLP_ID)

HWND GetDlgItemP(HWND hDlg, INT_PTR id)
{
    HWND hwndChild = GetWindow(hDlg, GW_CHILD);
    while (hwndChild && GetDlgCtrlIDP(hwndChild) != id)
        hwndChild = GetWindow(hwndChild, GW_HWNDNEXT);
    return hwndChild;
}

#else
#define GetDlgItemP     GetDlgItem
#define GetDlgCtrlIDP   GetDlgCtrlID
#endif


//
// display devices
//
typedef struct _multimon_device {

    //
    // Main class for settings
    //

    CDisplaySettings * pds;

    //
    // Color and resolution information cache
    // Rebuild when modes are enumerated.
    //

    int            cColors;
    PLONGLONG      ColorList;
    int            cResolutions;
    PPOINT         ResolutionList;


    ULONG          ComboBoxItem;
    DISPLAY_DEVICE DisplayDevice;
    ULONG          DisplayIndex;
    POINT          Snap;
    HDC            hdc;

    //
    // Image information.
    //
    int            w,h;
    HIMAGELIST     himl;
    int            iImage;

    BOOLEAN        bTracking;
    HWND           hwndFlash;  //Flash window.
} MULTIMON_DEVICE, *PMULTIMON_DEVICE;

#define GetDlgCtrlDevice(hwnd) ((PMULTIMON_DEVICE)GetDlgCtrlIDP(hwnd))

BOOL gfFlashWindowRegistered = FALSE;
HWND ghwndToolTipTracking;
HWND ghwndToolTipPopup;
HWND ghwndPropSheet;

void AddTrackingToolTip(PMULTIMON_DEVICE pDevice, HWND hwnd);
void RemoveTrackingToolTip(HWND hwnd);

void AddPopupToolTip(HWND hwndC);
void RemovePopupToolTip(HWND hwndC);

extern int AskDynaCDS(HWND hDlg);
extern int GetDisplayCPLPreference(LPCTSTR szRegVal);
extern void SetDisplayCPLPreference(LPCTSTR szRegVal, int val);

// Prototype for CreateStdAccessibleProxy.
// A and W versions are available - pClassName can be ANSI or UNICODE
// string. This is a TCHAR-style prototype, but you can do a A or W
// specific one if desired.
typedef HRESULT (WINAPI *PFNCREATESTDACCESSIBLEPROXY) (
    HWND     hWnd,
    LPTSTR   pClassName,
    LONG     idObject,
    REFIID   riid,
    void **  ppvObject
    );

// Same for LresultFromObject...
typedef LRESULT (WINAPI *PFNLRESULTFROMOBJECT)(
    REFIID riid,
    WPARAM wParam,
    LPUNKNOWN punk
    );


PRIVATE PFNCREATESTDACCESSIBLEPROXY s_pfnCreateStdAccessibleProxy = NULL;
PRIVATE PFNLRESULTFROMOBJECT s_pfnLresultFromObject = NULL;

BOOL g_fAttemptedOleAccLoad ;
HMODULE g_hOleAcc;

//-----------------------------------------------------------------------------
static const DWORD sc_MultiMonitorHelpIds[] =
{
   IDC_SCREENSAMPLE,  IDH_DISPLAY_SETTINGS_MONITOR_GRAPHIC,
   IDC_MULTIMONHELP,  IDH_DISPLAY_SETTINGS_MONITOR_GRAPHIC,
   IDC_DISPLAYDESK,   IDH_DISPLAY_SETTINGS_MONITOR_GRAPHIC,

   IDC_DISPLAYLABEL,  IDH_DISPLAY_SETTINGS_DISPLAY_LIST,
   IDC_DISPLAYLIST,   IDH_DISPLAY_SETTINGS_DISPLAY_LIST,
   IDC_DISPLAYTEXT,   IDH_DISPLAY_SETTINGS_DISPLAY_LIST,

   IDC_COLORGROUPBOX, IDH_DISPLAY_SETTINGS_COLORBOX,
   IDC_COLORBOX,      IDH_DISPLAY_SETTINGS_COLORBOX,
   IDC_COLORSAMPLE,   IDH_DISPLAY_SETTINGS_COLORBOX,

   IDC_RESGROUPBOX,   IDH_DISPLAY_SETTINGS_SCREENAREA,
   IDC_SCREENSIZE,    IDH_DISPLAY_SETTINGS_SCREENAREA,
   IDC_RES_LESS,      IDH_DISPLAY_SETTINGS_SCREENAREA,
   IDC_RES_MORE,      IDH_DISPLAY_SETTINGS_SCREENAREA,
   IDC_RESXY,         IDH_DISPLAY_SETTINGS_SCREENAREA,

   IDC_DISPLAYUSEME,  IDH_DISPLAY_SETTINGS_EXTEND_DESKTOP_CHECKBOX,
   IDC_DISPLAYPRIME,  IDH_DISPLAY_SETTINGS_USE_PRIMARY_CHECKBOX,

   IDC_IDENTIFY,          IDH_DISPLAY_SETTINGS_IDENTIFY_BUTTON,
   IDC_TROUBLESHOOT,      IDH_DISPLAY_SETTINGS_TROUBLE_BUTTON,
   IDC_DISPLAYPROPERTIES, IDH_DISPLAY_SETTINGS_ADVANCED_BUTTON,

   0, 0
};

class CAccessibleWrapper: public IAccessible
{
        // We need to do our own refcounting for this wrapper object
        LONG           m_cRef;

        // Need ptr to the IAccessible
        IAccessible *  m_pAcc;
        HWND           m_hwnd;
public:
        CAccessibleWrapper( HWND hwnd, IAccessible * pAcc );
        virtual ~CAccessibleWrapper(void);

        // IUnknown
        // (We do our own ref counting)
        virtual STDMETHODIMP            QueryInterface(REFIID riid, void** ppv);
        virtual STDMETHODIMP_(ULONG)    AddRef();
        virtual STDMETHODIMP_(ULONG)    Release();

        // IDispatch
        virtual STDMETHODIMP            GetTypeInfoCount(UINT* pctinfo);
        virtual STDMETHODIMP            GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        virtual STDMETHODIMP            GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid);
        virtual STDMETHODIMP            Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
            UINT* puArgErr);

        // IAccessible
        virtual STDMETHODIMP            get_accParent(IDispatch ** ppdispParent);
        virtual STDMETHODIMP            get_accChildCount(long* pChildCount);
        virtual STDMETHODIMP            get_accChild(VARIANT varChild, IDispatch ** ppdispChild);

        virtual STDMETHODIMP            get_accName(VARIANT varChild, BSTR* pszName);
        virtual STDMETHODIMP            get_accValue(VARIANT varChild, BSTR* pszValue);
        virtual STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR* pszDescription);
        virtual STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT *pvarRole);
        virtual STDMETHODIMP            get_accState(VARIANT varChild, VARIANT *pvarState);
        virtual STDMETHODIMP            get_accHelp(VARIANT varChild, BSTR* pszHelp);
        virtual STDMETHODIMP            get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
        virtual STDMETHODIMP            get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);
        virtual STDMETHODIMP            get_accFocus(VARIANT * pvarFocusChild);
        virtual STDMETHODIMP            get_accSelection(VARIANT * pvarSelectedChildren);
        virtual STDMETHODIMP            get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

        virtual STDMETHODIMP            accSelect(long flagsSel, VARIANT varChild);
        virtual STDMETHODIMP            accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        virtual STDMETHODIMP            accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
        virtual STDMETHODIMP            accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
        virtual STDMETHODIMP            accDoDefaultAction(VARIANT varChild);

        virtual STDMETHODIMP            put_accName(VARIANT varChild, BSTR szName);
        virtual STDMETHODIMP            put_accValue(VARIANT varChild, BSTR pszValue);
};

CAccessibleWrapper::CAccessibleWrapper( HWND hwnd, IAccessible * pAcc )
    : m_cRef( 1 ),
      m_pAcc( pAcc ),
      m_hwnd( hwnd )
{
    ASSERT( m_pAcc );
    m_pAcc->AddRef();
}


CAccessibleWrapper::~CAccessibleWrapper()
{
    m_pAcc->Release();
}


// IUnknown
// Implement refcounting ourselves
// Also implement QI ourselves, so that we return a ptr back to the wrapper.
STDMETHODIMP  CAccessibleWrapper::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if ((riid == IID_IUnknown)  ||
        (riid == IID_IDispatch) ||
        (riid == IID_IAccessible))
    {
        *ppv = (IAccessible *) this;
    }
    else
        return(E_NOINTERFACE);

    AddRef();
    return(NOERROR);
}


STDMETHODIMP_(ULONG) CAccessibleWrapper::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CAccessibleWrapper::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IDispatch
// - pass all through m_pAcc

STDMETHODIMP  CAccessibleWrapper::GetTypeInfoCount(UINT* pctinfo)
{
    return m_pAcc->GetTypeInfoCount(pctinfo);
}


STDMETHODIMP  CAccessibleWrapper::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{
    return m_pAcc->GetTypeInfo(itinfo, lcid, pptinfo);
}


STDMETHODIMP  CAccessibleWrapper::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid)
{
    return m_pAcc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

STDMETHODIMP  CAccessibleWrapper::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
            UINT* puArgErr)
{
    return m_pAcc->Invoke(dispidMember, riid, lcid, wFlags,
            pdispparams, pvarResult, pexcepinfo,
            puArgErr);
}

// IAccessible
// - pass all through m_pAcc

STDMETHODIMP  CAccessibleWrapper::get_accParent(IDispatch ** ppdispParent)
{
    return m_pAcc->get_accParent(ppdispParent);
}


STDMETHODIMP  CAccessibleWrapper::get_accChildCount(long* pChildCount)
{
    return m_pAcc->get_accChildCount(pChildCount);
}


STDMETHODIMP  CAccessibleWrapper::get_accChild(VARIANT varChild, IDispatch ** ppdispChild)
{
    return m_pAcc->get_accChild(varChild, ppdispChild);
}



STDMETHODIMP  CAccessibleWrapper::get_accName(VARIANT varChild, BSTR* pszName)
{
    return m_pAcc->get_accName(varChild, pszName);
}



STDMETHODIMP  CAccessibleWrapper::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    // varChild.lVal specifies which sub-part of the component
    // is being queried.
    // CHILDID_SELF (0) specifies the overall component - other
    // non-0 values specify a child.

    // In a trackbar, CHILDID_SELF refers to the overall trackbar
    // (which is what we want), whereas other values refer to the
    // sub-components - the actual slider 'thumb', and the 'page
    // up/page down' areas to the left/right of it.
    if( varChild.vt == VT_I4 && varChild.lVal == CHILDID_SELF )
    {
        HWND hDlg;
        TCHAR achRes[120];

        hDlg = GetParent( m_hwnd );

        SendDlgItemMessage(hDlg, IDC_RESXY, WM_GETTEXT, 120, (LPARAM)achRes);
        *pszValue = SysAllocString( achRes );

        return S_OK;

    }
    else
    {
        // Pass requests about the sub-components to the
        // 'original' IAccessible for us).
        return m_pAcc->get_accValue(varChild, pszValue);
    }
}


STDMETHODIMP  CAccessibleWrapper::get_accDescription(VARIANT varChild, BSTR* pszDescription)
{
    return m_pAcc->get_accDescription(varChild, pszDescription);
}


STDMETHODIMP  CAccessibleWrapper::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    return m_pAcc->get_accRole(varChild, pvarRole);
}


STDMETHODIMP  CAccessibleWrapper::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    return m_pAcc->get_accState(varChild, pvarState);
}


STDMETHODIMP  CAccessibleWrapper::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{
    return m_pAcc->get_accHelp(varChild, pszHelp);
}


STDMETHODIMP  CAccessibleWrapper::get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic)
{
    return m_pAcc->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
}


STDMETHODIMP  CAccessibleWrapper::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut)
{
    return m_pAcc->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
}


STDMETHODIMP  CAccessibleWrapper::get_accFocus(VARIANT * pvarFocusChild)
{
    return m_pAcc->get_accFocus(pvarFocusChild);
}


STDMETHODIMP  CAccessibleWrapper::get_accSelection(VARIANT * pvarSelectedChildren)
{
    return m_pAcc->get_accSelection(pvarSelectedChildren);
}


STDMETHODIMP  CAccessibleWrapper::get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction)
{
    return m_pAcc->get_accDefaultAction(varChild, pszDefaultAction);
}



STDMETHODIMP  CAccessibleWrapper::accSelect(long flagsSel, VARIANT varChild)
{
    return m_pAcc->accSelect(flagsSel, varChild);
}


STDMETHODIMP  CAccessibleWrapper::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    return m_pAcc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
}


STDMETHODIMP  CAccessibleWrapper::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    return m_pAcc->accNavigate(navDir, varStart, pvarEndUpAt);
}


STDMETHODIMP  CAccessibleWrapper::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    return m_pAcc->accHitTest(xLeft, yTop, pvarChildAtPoint);
}


STDMETHODIMP  CAccessibleWrapper::accDoDefaultAction(VARIANT varChild)
{
    return m_pAcc->accDoDefaultAction(varChild);
}



STDMETHODIMP  CAccessibleWrapper::put_accName(VARIANT varChild, BSTR szName)
{
    return m_pAcc->put_accName(varChild, szName);
}


STDMETHODIMP  CAccessibleWrapper::put_accValue(VARIANT varChild, BSTR pszValue)
{
    return m_pAcc->put_accValue(varChild, pszValue);
}


class CSettingsPage  :  public CObjectWithSite,
                        public CObjectCLSID,
                        public IMultiMonConfig,
                        public IPropertyBag, 
                        public IBasePropPage

{
    friend int ComputeNumberOfDisplayDevices();
    friend int DisplaySaveSettings(PVOID pContext, HWND hwnd);

    private:
        // Data Section
        PMULTIMON_DEVICE _pCurDevice;
        PMULTIMON_DEVICE _pPrimaryDevice;

        // HWND for the main window
        HWND _hDlg;
        HWND _hwndDesk;
        HWND _hwndList;

        // union of all monitor RECTs
        RECT _rcDesk;

        // ref count
        LONG _cRef;
        LONG _nInApply;

        // how to translate to preview size
        int   _DeskScale;
        POINT _DeskOff;
        UINT  _InSetInfo;
        ULONG _NumDevices;
        HBITMAP _hbmScrSample;
        HBITMAP _hbmMonitor;
        HIMAGELIST _himl;
        DWORD _dwInvalidMode;


        // UI variables
        int  _iColor;
        int  _iResolution;

        BOOL _bBadDriver         : 1;
        BOOL _bNoAttach          : 1;
        BOOL _bDirty             : 1;

        MULTIMON_DEVICE _Devices[MONITORS_MAX];

        // Private functions
        void _DeskToPreview(LPRECT in, LPRECT out);
        void _OffsetPreviewToDesk(HWND hwndC, LPRECT prcNewPreview, LPRECT prcOldPreview, LPRECT out);
        BOOL _QueryForceSmallFont();
        void _SetPreviewScreenSize(int HRes, int VRes, int iOrgXRes, int iOrgYRes);
        void _CleanupRects(HWND hwndP);
        void _ConfirmPositions();
        void _DoAdvancedSettingsSheet();
        BOOL _HandleHScroll(HWND hwndSB, int iCode, int iPos);
        void _RedrawDeskPreviews();
        void _OnAdvancedClicked();

        BOOL _InitDisplaySettings(BOOL bExport);
        int  _EnumerateAllDisplayDevices(); //Enumerates and returns the number of devices.
        void _DestroyMultimonDevice(PMULTIMON_DEVICE pDevice);
        void _DestroyDisplaySettings();

        void _InitUI();
        void _UpdateUI(BOOL fAutoSetColorDepth = TRUE, int FocusToCtrlID = 0);
        LPTSTR _FormatMessageInvoke(LPCTSTR pcszFormat, va_list *argList);
        LPTSTR _FormatMessageWrap(LPCTSTR pcszFormat, ...);
        void _GetDisplayName(PMULTIMON_DEVICE pDevice, LPTSTR pszDisplay, DWORD cchSize);
        int  _SaveDisplaySettings(DWORD dwSet);
        void _ForwardToChildren(UINT message, WPARAM wParam, LPARAM lParam);

        static BOOL _CanSkipWarningBecauseKnownSafe(CDisplaySettings *rgpds[], ULONG numDevices);
        static BOOL _AnyChange(CDisplaySettings *rgpds[], ULONG numDevices);
        static BOOL _IsSingleToMultimonChange(CDisplaySettings *rgpds[],
                                              ULONG numDevices);

        static int _DisplaySaveSettings(CDisplaySettings *rgpds[],
                                        ULONG            numDevices,
                                        HWND             hDlg);

        static int _SaveSettings(CDisplaySettings *rgpds[],
                                 ULONG numDevices,
                                 HWND hDlg,
                                 DWORD dwSet);

        BOOL _AreExtraMonitorsDisabledOnPersonal();
        BOOL _InitMessage();
        void _vPreExecMode();
        void _vPostExecMode();
    public:
        CSettingsPage();

        static BOOL RegisterPreviewWindowClass(WNDPROC pfnWndProc);
        // *** IUnknown methods ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // *** IMultiMonConfig methods ***
        STDMETHOD ( Initialize ) ( HWND hwndHost, WNDPROC pfnWndProc, DWORD dwReserved);
        STDMETHOD ( GetNumberOfMonitors ) (int * pCMon, DWORD dwReserved);
        STDMETHOD ( GetMonitorData) (int iMonitor, MonitorData * pmd, DWORD dwReserved);
        STDMETHOD ( Paint) (THIS_ int iMonitor, DWORD dwReserved);

        // *** IShellPropSheetExt ***
        virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
        virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam);

        // *** IObjectWithSite ***
        virtual STDMETHODIMP SetSite(IUnknown *punkSite);

        // *** IPropertyBag ***
        virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
        virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

        // *** IBasePropPage ***
        virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
        virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);

        BOOL InitMultiMonitorDlg(HWND hDlg);
        PMULTIMON_DEVICE GetCurDevice(){return _pCurDevice;};

        int  GetNumberOfAttachedDisplays();
        void UpdateActiveDisplay(PMULTIMON_DEVICE pDevice, BOOL bRepaint = TRUE);
        BOOL HandleMonitorChange(HWND hwndP, BOOL bMainDlg, BOOL bRepaint = TRUE);
        void SetDirty(BOOL bDirty=TRUE);
        BOOL SetPrimary(PMULTIMON_DEVICE pDevice);
        BOOL SetMonAttached(PMULTIMON_DEVICE pDevice, BOOL bSetAttached,
                            BOOL bForce, HWND hwnd);

        HWND  GetCurDeviceHwnd() { return GetDlgItemP(_hwndDesk, (INT_PTR) _pCurDevice);};
        ULONG GetNumDevices()    { return _NumDevices;};
        BOOL  QueryNoAttach()    { return _bNoAttach;};
        BOOL  IsDirty()          { return _bDirty;};

        void GetMonitorPosition(PMULTIMON_DEVICE pDevice, HWND hwndP, PPOINT ptPos);

        static INT_PTR CALLBACK SettingsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
        LRESULT CALLBACK WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

        IThemeUIPages* _pThemeUI;
};

CSettingsPage::CSettingsPage() : _cRef(1), CObjectCLSID(&PPID_Settings)
{
    ASSERT(_pCurDevice == NULL);
    ASSERT(_pPrimaryDevice == NULL);
    ASSERT(_DeskScale == 0);
    ASSERT(_InSetInfo == 0);
    ASSERT(_NumDevices == 0);
    ASSERT(IsRectEmpty(&_rcDesk));
    ASSERT(_bNoAttach == FALSE);
    ASSERT(_bDirty == FALSE);

    _nInApply = 0;
};


void CSettingsPage::_DestroyMultimonDevice(PMULTIMON_DEVICE pDevice)
{
    ASSERT(pDevice->pds);
    pDevice->pds->Release();
    pDevice->pds = NULL;

    if(pDevice->hwndFlash)
    {
        DestroyWindow(pDevice->hwndFlash);
        pDevice->hwndFlash = NULL;
    }

    if (pDevice->hdc) {
        DeleteDC(pDevice->hdc);
        pDevice->hdc = NULL;
    }

    if (pDevice->ResolutionList) {
        LocalFree(pDevice->ResolutionList);
        pDevice->ResolutionList = NULL;
    }

    if (pDevice->ColorList) {
        LocalFree(pDevice->ColorList);
        pDevice->ColorList = NULL;
    }
}

void CSettingsPage::_DestroyDisplaySettings()
{
    ULONG iDevice;
    HWND    hwndC;
    ASSERT(_NumDevices);
    TraceMsg(TF_GENERAL, "DestroyDisplaySettings: %d devices", _NumDevices);

    // We are about to destroy the _Devices below. Pointerts to these devices are used as the
    // CtrlIDs for the monitor windows. So, we need destroy the monitor windows first;
    // otherwise, if the monitor windows are destroyed later, they try to use these invalid
    // pDevice in FlashText. (pDevice->hwndFlash will fault).
    hwndC = GetWindow(_hwndDesk, GW_CHILD);
    while (hwndC)
    {
        RemoveTrackingToolTip(hwndC);
        RemovePopupToolTip(hwndC);
        DestroyWindow(hwndC);
        hwndC = GetWindow(_hwndDesk, GW_CHILD);
    }

    // Now, we can destroy the _Devices safely.
    for (iDevice = 0; iDevice < _NumDevices; iDevice++) {
        _DestroyMultimonDevice(_Devices + iDevice);
        // Note: pds is destroyed and set to zero already in the above call.
        //delete _Devices[iDevice].pds;
        //_Devices[iDevice].pds = 0;
    }

    if (_himl) {
        ImageList_Destroy(_himl);
        _himl = NULL;
    }

    DestroyWindow(ghwndToolTipTracking);
    DestroyWindow(ghwndToolTipPopup);

    ghwndToolTipTracking = NULL;
    ghwndToolTipPopup = NULL;

    TraceMsg(TF_GENERAL, "DestroyDisplaySettings: Finished destroying all devices");
}

//
// deterines if the applet is in detect mode.
//

//
// Called to put up initial messages that need to appear above the dialog
// box
//

BOOL CSettingsPage::_InitMessage()
{
    {
        //
        // _bBadDriver will be set when we fail to build the list of modes,
        // or something else failed during initialization.
        //
        // In almost every case, we should already know about this situation
        // based on our boot code.
        // However, if this is a new situation, just report a "bad driver"
        //

        DWORD dwExecMode;
        if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
        {
            if (_bBadDriver)
            {
                ASSERT(dwExecMode == EM_INVALID_MODE);

                _pThemeUI->SetExecMode(EM_INVALID_MODE);
                dwExecMode = EM_INVALID_MODE;
                _dwInvalidMode = EIS_EXEC_INVALID_DISPLAY_DRIVER;
            }


            if (dwExecMode == EM_INVALID_MODE)
            {
                DWORD Mesg;

                switch(_dwInvalidMode) {

                case EIS_EXEC_INVALID_NEW_DRIVER:
                    Mesg = MSG_INVALID_NEW_DRIVER;
                    break;
                case EIS_EXEC_INVALID_DEFAULT_DISPLAY_MODE:
                    Mesg = MSG_INVALID_DEFAULT_DISPLAY_MODE;
                    break;
                case EIS_EXEC_INVALID_DISPLAY_DRIVER:
                    Mesg = MSG_INVALID_DISPLAY_DRIVER;
                    break;
                case EIS_EXEC_INVALID_OLD_DISPLAY_DRIVER:
                    Mesg = MSG_INVALID_OLD_DISPLAY_DRIVER;
                    break;
                case EIS_EXEC_INVALID_16COLOR_DISPLAY_MODE:
                    Mesg = MSG_INVALID_16COLOR_DISPLAY_MODE;
                    break;
                case EIS_EXEC_INVALID_DISPLAY_MODE:
                    Mesg = MSG_INVALID_DISPLAY_MODE;
                    {
                        //
                        // If we are in safe mode, then we will get to here when
                        // we initially log in.  We are in forced VGA mode, so there
                        // is no real error here.  Emulate a click on the OK button
                        // and everybody is happy.
                        //
                        HKEY hSafe;

                        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                         REGSTR_VAL_SAFEBOOT,
                                         0,
                                         KEY_READ,
                                         &hSafe) == ERROR_SUCCESS) {

                            //
                            // If we ever care about the actual safe mode, the value
                            // is nameed "OptionValue"
                            //
                            RegCloseKey(hSafe);
                            PropSheet_PressButton(GetParent(_hDlg), PSBTN_OK);
                            return TRUE;
                        }
                    }
                    break;
                case EIS_EXEC_INVALID_CONFIGURATION:
                default:
                    Mesg = MSG_INVALID_CONFIGURATION;
                    break;
                }

                FmtMessageBox(_hDlg,
                              MB_ICONEXCLAMATION,
                              MSG_CONFIGURATION_PROBLEM,
                              Mesg);

                //
                // For a bad display driver or old display driver, let's send the
                // user straight to the installation dialog.
                //

                if ((_dwInvalidMode == EIS_EXEC_INVALID_OLD_DISPLAY_DRIVER) ||
                    (_dwInvalidMode == EIS_EXEC_INVALID_DISPLAY_DRIVER))
                {
                    ASSERT(FALSE);
                }
            }
        }
    }

    return TRUE;
}

VOID CSettingsPage::_vPreExecMode()
{

    HKEY hkey;

    //
    // This function sets up the execution mode of the applet.
    // There are four vlid modes.
    //
    // EXEC_NORMAL - When the apple is launched from the control panel
    //
    // EXEC_INVALID_MODE is exactly the same as for NORMAL except we will
    //                   not mark the current mode as tested so the user has
    //                   to at least test a mode
    //
    // EXEC_DETECT - When the applet is launched normally, but a detect was
    //               done on the previous boot (the key in the registry is
    //               set)
    //
    // EXEC_SETUP  - When we launch the applet in setup mode from setup (Both
    //               the registry key is set and the setup flag is passed in).
    //

    //
    // These two keys should only be checked \ deleted if the machine has been
    // rebooted and the detect \ new display has actually happened.
    // So we will look for the RebootNecessary key (a volatile key) and if
    // it is not present, then we can delete the key.  Otherwise, the reboot
    // has not happened, and we keep the key
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SZ_REBOOT_NECESSARY,
                     0,
                     KEY_READ | KEY_WRITE,
                     &hkey) != ERROR_SUCCESS) {

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         SZ_DETECT_DISPLAY,
                         0,
                         KEY_READ | KEY_WRITE,
                         &hkey) == ERROR_SUCCESS) {

            //
            // NOTE: This key is also set when EXEC_SETUP is being run.
            //

            DWORD dwExecMode;
            if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
            {
                if (dwExecMode == EM_NORMAL) {

                    _pThemeUI->SetExecMode(EM_DETECT);

                } else {

                    //
                    // If we are in setup mode, we also check the extra values
                    // under DetectDisplay that control the unattended installation.
                    //

                    ASSERT(dwExecMode == EM_SETUP);

                }
            }

            RegCloseKey(hkey);
        }

        //
        // Check for a new driver being installed
        //

        DWORD dwExecMode;
        if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
        {
            if ( (dwExecMode == EM_NORMAL) &&
                 (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               SZ_NEW_DISPLAY,
                               0,
                               KEY_READ | KEY_WRITE,
                               &hkey) == ERROR_SUCCESS) ) {

                _pThemeUI->SetExecMode(EM_INVALID_MODE);
                _dwInvalidMode = EIS_EXEC_INVALID_NEW_DRIVER;

                RegCloseKey(hkey);
            }
        }

        RegDeleteKey(HKEY_LOCAL_MACHINE,
                     SZ_DETECT_DISPLAY);

        RegDeleteKey(HKEY_LOCAL_MACHINE,
                     SZ_NEW_DISPLAY);
    }
    {
        LPTSTR psz = NULL;
        LPTSTR pszInv = NULL;

        DWORD dwExecMode;
        if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
        {
            switch(dwExecMode) {

                case EM_NORMAL:
                    psz = TEXT("Normal Execution mode");
                    break;
                case EM_DETECT:
                    psz = TEXT("Detection Execution mode");
                    break;
                case EM_SETUP:
                    psz = TEXT("Setup Execution mode");
                    break;
                case EM_INVALID_MODE:
                    psz = TEXT("Invalid Mode Execution mode");

                    switch(_dwInvalidMode) {

                        case EIS_EXEC_INVALID_NEW_DRIVER:
                            pszInv = TEXT("Invalid new driver");
                            break;
                        default:
                            pszInv = TEXT("*** Invalid *** Invalid mode");
                            break;
                    }
                    break;
                default:
                    psz = TEXT("*** Invalid *** Execution mode");
                    break;
            }

            if (dwExecMode == EM_INVALID_MODE)
            {
                TraceMsg(TF_FUNC, "\t\t sub invalid mode : %ws", pszInv);
            }
        }
        TraceMsg(TF_FUNC, "\n\n", psz);
    }
}


VOID CSettingsPage::_vPostExecMode() {

    HKEY hkey;
    DWORD cb;
    DWORD data;

    //
    // Check for various invalid configurations
    //

    DWORD dwExecMode;
    if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
    {
        if ( (dwExecMode == EM_NORMAL) &&
             (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           SZ_INVALID_DISPLAY,
                           0,
                           KEY_READ | KEY_WRITE,
                           &hkey) == ERROR_SUCCESS) ) {

            _pThemeUI->SetExecMode(EM_INVALID_MODE);

            //
            // Check for these fields in increasing order of "badness" or
            // "detail" so that the *worst* error is the one remaining in the
            // _dwInvalidMode  variable once all the checks are done.
            //

            cb = sizeof(data);
            if (RegQueryValueEx(hkey,
                                TEXT("DefaultMode"),
                                NULL,
                                NULL,
                                (LPBYTE)(&data),
                                &cb) == ERROR_SUCCESS)
            {
                _dwInvalidMode = EIS_EXEC_INVALID_DEFAULT_DISPLAY_MODE;
            }

            cb = sizeof(data);
            if (RegQueryValueEx(hkey,
                                TEXT("BadMode"),
                                NULL,
                                NULL,
                                (LPBYTE)(&data),
                                &cb) == ERROR_SUCCESS)
            {
                _dwInvalidMode = EIS_EXEC_INVALID_DISPLAY_MODE;
            }

            cb = sizeof(data);
            if (RegQueryValueEx(hkey,
                                TEXT("16ColorMode"),
                                NULL,
                                NULL,
                                (LPBYTE)(&data),
                                &cb) == ERROR_SUCCESS)
            {
                _dwInvalidMode = EIS_EXEC_INVALID_16COLOR_DISPLAY_MODE;
            }


            cb = sizeof(data);
            if (RegQueryValueEx(hkey,
                                TEXT("InvalidConfiguration"),
                                NULL,
                                NULL,
                                (LPBYTE)(&data),
                                &cb) == ERROR_SUCCESS)
            {
                _dwInvalidMode = EIS_EXEC_INVALID_CONFIGURATION;
            }

            cb = sizeof(data);
            if (RegQueryValueEx(hkey,
                                TEXT("MissingDisplayDriver"),
                                NULL,
                                NULL,
                                (LPBYTE)(&data),
                                &cb) == ERROR_SUCCESS)
            {
                _dwInvalidMode = EIS_EXEC_INVALID_DISPLAY_DRIVER;
            }

            //
            // This last case will be set in addition to the previous one in the
            // case where the driver was an old driver linking to winsvr.dll
            // and we can not load it.
            //

            cb = sizeof(data);
            if (RegQueryValueEx(hkey,
                                TEXT("OldDisplayDriver"),
                                NULL,
                                NULL,
                                (LPBYTE)(&data),
                                &cb) == ERROR_SUCCESS)
            {
                _dwInvalidMode = EIS_EXEC_INVALID_OLD_DISPLAY_DRIVER;
            }

            RegCloseKey(hkey);

        }
    }

    //
    // Delete all of these bad configuration keys since we only want the
    // user to see the message once.
    //

    RegDeleteKey(HKEY_LOCAL_MACHINE,
                 SZ_INVALID_DISPLAY);

{
    LPTSTR psz = NULL;
    LPTSTR pszInv = NULL;

    DWORD dwExecMode;
    if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
    {
        if (dwExecMode == EM_INVALID_MODE)
        {
            switch (_dwInvalidMode)
            {
            case EIS_EXEC_INVALID_DEFAULT_DISPLAY_MODE:
                pszInv = TEXT("Default mode being used");
                break;
            case EIS_EXEC_INVALID_DISPLAY_DRIVER:
                pszInv = TEXT("Invalid Display Driver");
                break;
            case EIS_EXEC_INVALID_OLD_DISPLAY_DRIVER:
                pszInv = TEXT("Old Display Driver");
                break;
            case EIS_EXEC_INVALID_16COLOR_DISPLAY_MODE:
                pszInv = TEXT("16 color mode not supported");
                break;
            case EIS_EXEC_INVALID_DISPLAY_MODE:
                pszInv = TEXT("Invalid display mode");
                break;
            case EIS_EXEC_INVALID_CONFIGURATION:
                pszInv = TEXT("Invalid configuration");
                break;
            default:
                psz = TEXT("*** Invalid *** Invalid mode");
                break;
            }

            TraceMsg(TF_FUNC, "\t\t sub invlid mode : %ws", pszInv);
            TraceMsg(TF_FUNC, "\n\n", psz);
        }
    }
}
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CSettingsPage::_DeskToPreview(LPRECT in, LPRECT out)
{
    out->left   = _DeskOff.x + MulDiv(in->left   - _rcDesk.left,_DeskScale,1000);
    out->top    = _DeskOff.y + MulDiv(in->top    - _rcDesk.top, _DeskScale,1000);
    out->right  = _DeskOff.x + MulDiv(in->right  - _rcDesk.left,_DeskScale,1000);
    out->bottom = _DeskOff.y + MulDiv(in->bottom - _rcDesk.top, _DeskScale,1000);
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CSettingsPage::_OffsetPreviewToDesk(HWND hwndC, LPRECT prcNewPreview, LPRECT prcOldPreview, LPRECT out)
{
    int x = 0, y = 0;
    int dtLeft, dtRight, dtTop, dtBottom;
    int nTotal;
    HWND hwndT;
    RECT rcC, rcT, rcPosT;
    BOOL bx = FALSE, by = FALSE;
    PMULTIMON_DEVICE pDeviceT;

    dtLeft = prcNewPreview->left - prcOldPreview->left;
    dtRight = prcNewPreview->right - prcOldPreview->right;
    dtTop = prcNewPreview->top - prcOldPreview->top;
    dtBottom = prcNewPreview->bottom - prcOldPreview->bottom;

    nTotal = abs(dtLeft) + abs(dtRight) + abs(dtTop) + abs(dtBottom);

    if (nTotal == 0) {
        
        return;
    
    } else if (nTotal > 2) {
    
        //
        // walk all other windows and snap our window to them
        //

        GetWindowRect(hwndC, &rcC);

        for (hwndT = GetWindow(hwndC,  GW_HWNDFIRST); 
             (hwndT && (!bx || !by));
             hwndT = GetWindow(hwndT, GW_HWNDNEXT))
        {
            if (hwndT == hwndC)
                continue;

            GetWindowRect(hwndT, &rcT);
            pDeviceT = GetDlgCtrlDevice(hwndT);

            if (pDeviceT) {
            
                pDeviceT->pds->GetCurPosition(&rcPosT);
    
                if (!bx) {
    
                    bx = TRUE;
    
                    if (rcC.left == rcT.left) {
    
                        x = rcPosT.left - out->left;
                    
                    } else if (rcC.left == rcT.right) {
    
                        x = rcPosT.right - out->left;
                    
                    } else if (rcC.right == rcT.left) {
    
                        x = rcPosT.left - out->right;
        
                    } else if (rcC.right == rcT.right) {
    
                        x = rcPosT.right - out->right;
    
                    } else {
    
                        bx = FALSE;
                    }
                }
    
                if (!by) {
                
                    by = TRUE;
    
                    if (rcC.top == rcT.top) {
    
                        y = rcPosT.top - out->top;
    
                    } else if (rcC.top == rcT.bottom) {
    
                        y = rcPosT.bottom - out->top;
    
                    } else if (rcC.bottom == rcT.top) {
    
                        y = rcPosT.top - out->bottom;
    
                    } else if (rcC.bottom == rcT.bottom) {
    
                        y = rcPosT.bottom - out->bottom;
                    
                    } else {
    
                        by = FALSE; 
                    }
                }
            }
        }

        if (!bx) {
            x = _rcDesk.left + MulDiv(prcNewPreview->left - _DeskOff.x,1000,_DeskScale);
            x = x - out->left;
        }

        if (!by) {
            y = _rcDesk.top  + MulDiv(prcNewPreview->top  - _DeskOff.y,1000,_DeskScale);
            y = y - out->top;
        }
    
    } else {
    
        x = dtLeft * 8;
        y = dtTop * 8;
    }

    OffsetRect(out, x, y);
}


//-----------------------------------------------------------------------------
int CSettingsPage::_SaveSettings(CDisplaySettings *rgpds[], ULONG numDevices, HWND hDlg, DWORD dwSet)
{
    int     iRet = 0;
    ULONG   iDevice;

    for (iDevice = 0; iDevice < numDevices; iDevice++)
    {
        // PERF - we should only save the settings for devices that have
        // changed.
        if (rgpds[iDevice])
        {
            int iResult = rgpds[iDevice]->SaveSettings(dwSet);
            if (iResult != DISP_CHANGE_SUCCESSFUL)
            {
                if (iResult == DISP_CHANGE_RESTART)
                {
                    iRet = iResult;
                    continue;
                }
                else
                {
                    FmtMessageBox(hDlg,
                                  MB_ICONEXCLAMATION,
                                  IDS_CHANGE_SETTINGS,
                                  IDS_CHANGESETTINGS_FAILED);

                    ASSERT(iResult < 0);
                    return iResult;
                }
            }
        }
    }

    return iRet;
}



INT_PTR CALLBACK KeepNewDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    UINT_PTR idTimer = 0;
    HICON hicon;
    TCHAR szRevert[100];
    TCHAR szString[120];

    switch(message)
    {
        case WM_INITDIALOG:

            hicon = LoadIcon(NULL, IDI_QUESTION);
            if (hicon)
                SendDlgItemMessage(hDlg, IDC_BIGICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hicon);

            LoadString(HINST_THISDLL, IDS_REVERTBACK, szRevert, ARRAYSIZE(szRevert));
            StringCchPrintf(szString, ARRAYSIZE(szString), szRevert, lParam);
            SetDlgItemText(hDlg, IDC_COUNTDOWN, szString);
            idTimer = SetTimer(hDlg, lParam, 1000, NULL);

            SetFocus(GetDlgItem(hDlg, IDNO));

            // FALSE so that the focus set above is kept
            return FALSE;

        case WM_DESTROY:

            // raymondc - this code is dead; idTimer is initialized to zero
            // fortunately, timers are automatically killed at window destruction
            // if (idTimer)
            //    KillTimer(hDlg, idTimer);
            hicon = (HICON)SendDlgItemMessage(hDlg, IDC_BIGICON, STM_GETIMAGE, IMAGE_ICON, 0);
            if (hicon)
                DestroyIcon(hicon);
            break;

        case WM_TIMER:

            KillTimer(hDlg, wParam);
            LoadString(HINST_THISDLL, IDS_REVERTBACK, szRevert, ARRAYSIZE(szRevert));
            StringCchPrintf(szString, ARRAYSIZE(szString), szRevert, wParam - 1);
            SetDlgItemText(hDlg, IDC_COUNTDOWN, szString);
            idTimer = SetTimer(hDlg, wParam - 1, 1000, NULL);

            if (wParam == 1)
                EndDialog(hDlg, IDNO);

            break;

        case WM_COMMAND:

            EndDialog(hDlg, wParam);
            break;

        default:

            return FALSE;
    }
    return TRUE;
}

int CSettingsPage::GetNumberOfAttachedDisplays()
{
    int nDisplays = 0;

    for (ULONG iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        if (_Devices[iDevice].pds->IsAttached())
            nDisplays++;
    }
    return nDisplays;
}

BOOL CSettingsPage::_IsSingleToMultimonChange(CDisplaySettings *rgpds[],
                                                       ULONG numDevices)
{
    int nAttached = 0;
    int nOrgAttached = 0;

    for (ULONG iDevice = 0;
         (iDevice < numDevices) && (nOrgAttached <= 1);
         iDevice++)
    {
        if (rgpds[iDevice]->IsOrgAttached())
            nOrgAttached++;
        if (rgpds[iDevice]->IsAttached())
            nAttached++;
    }

    return ((nOrgAttached <= 1) && (nAttached > 1));
}

BOOL CSettingsPage::_AnyChange(CDisplaySettings *rgpds[], ULONG numDevices)
{
   for (ULONG iDevice = 0; iDevice < numDevices; iDevice++)
   {
       if (rgpds[iDevice]->IsAttached() && rgpds[iDevice]->bIsModeChanged())
       {
           return TRUE;
       }
   }

   return FALSE;
}

BOOL CSettingsPage::_CanSkipWarningBecauseKnownSafe(CDisplaySettings *rgpds[], ULONG numDevices)
{
    BOOL fSafe = TRUE;

    for (ULONG iDevice = 0; iDevice < numDevices; iDevice++)
    {
        if (rgpds[iDevice] && !rgpds[iDevice]->IsKnownSafe())
        {
            fSafe = FALSE;
            break;
        }
    }

    return fSafe;
}

BOOL CSettingsPage::_QueryForceSmallFont()
{
    for (ULONG iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        if ((_Devices[iDevice].pds->IsAttached()) &&
            (!_Devices[iDevice].pds->IsSmallFontNecessary()))
        {
            return FALSE;
        }
    }
    return TRUE;
}

LPTSTR  CSettingsPage::_FormatMessageInvoke(LPCTSTR pcszFormat, va_list *argList)

{
    LPTSTR  pszOutput;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                      pcszFormat,
                      0, 0,
                      reinterpret_cast<LPTSTR>(&pszOutput), 0,
                      argList) == 0)
    {
        pszOutput = NULL;
    }
    return(pszOutput);
}

LPTSTR  CSettingsPage::_FormatMessageWrap(LPCTSTR pcszFormat, ...)

{
    LPTSTR      pszOutput;
    va_list     argList;

    va_start(argList, pcszFormat);
    pszOutput = _FormatMessageInvoke(pcszFormat, &argList);
    va_end(argList);
    return(pszOutput);
}

void CSettingsPage::_GetDisplayName(PMULTIMON_DEVICE pDevice, LPTSTR pszDisplay, DWORD cchSize)
{
    LPTSTR  pszFormattedOutput;
    TCHAR   szMonitor[140];
    TCHAR   szDisplayFormat[40];

    LoadString(HINST_THISDLL, IDS_DISPLAYFORMAT, szDisplayFormat, ARRAYSIZE(szDisplayFormat));

    pDevice->pds->GetMonitorName(szMonitor, ARRAYSIZE(szMonitor));

    pszFormattedOutput = _FormatMessageWrap(szDisplayFormat,
                                            pDevice->DisplayIndex,
                                            szMonitor,
                                            pDevice->DisplayDevice.DeviceString);
    StringCchCopy(pszDisplay, cchSize, pszFormattedOutput);
    LocalFree(pszFormattedOutput);
}


void CSettingsPage::_OnAdvancedClicked()
{
    BOOL bCanBePruned, bIsPruningReadOnly;
    BOOL bBeforeIsPruningOn, bAfterIsPruningOn;

    if (_pCurDevice && _pCurDevice->pds)
    {
        _pCurDevice->pds->GetPruningMode(&bCanBePruned,
                                         &bIsPruningReadOnly,
                                         &bBeforeIsPruningOn);

        _DoAdvancedSettingsSheet();

        if (bCanBePruned && !bIsPruningReadOnly)
        {
            _pCurDevice->pds->GetPruningMode(&bCanBePruned,
                                             &bIsPruningReadOnly,
                                             &bAfterIsPruningOn);
            if (bBeforeIsPruningOn != bAfterIsPruningOn)
            {
                // pruning mode has changed - update the UI
                _InitUI();
                _UpdateUI();
            }
        }
    }
}


//-----------------------------------------------------------------------------
void CSettingsPage::_DoAdvancedSettingsSheet()
{
    if (_pCurDevice && _pCurDevice->pds)
    {
        PROPSHEETHEADER psh;
        HPROPSHEETPAGE rPages[MAX_PAGES];
        PROPSHEETPAGE psp;
        HPSXA hpsxa = NULL;
        HPSXA hpsxaOEM = NULL;
        HPSXA hpsxaAdapter = NULL;
        HPSXA* phpsxaChildren = NULL;
        INT_PTR iResult = 0;
        TCHAR szDisplay[140 + 256 + 20];  //Monitor-name and Adapter Properties.
        TCHAR szMonitor[140];
        TCHAR szDisplayFormat[35];
        GENERAL_ADVDLG_INITPARAMS generalInitParams = {0};

        // Create the "Monitor-name and Adapter-name properties" string to be used as the title for these
        // property sheets.
        LoadString(HINST_THISDLL, IDS_ADVDIALOGTITLE, szDisplayFormat, ARRAYSIZE(szDisplayFormat));

        _pCurDevice->pds->GetMonitorName(szMonitor, ARRAYSIZE(szMonitor));

        StringCchPrintf(szDisplay, ARRAYSIZE(szDisplay), szDisplayFormat, szMonitor, _pCurDevice->DisplayDevice.DeviceString);

        generalInitParams.fFoceSmallFont = _QueryForceSmallFont();
        generalInitParams.punkSite = _punkSite;         // They don't get a ref because their property dialog appears and goes away before this function returns.

        psh.dwSize = sizeof(psh);
        psh.dwFlags = PSH_PROPTITLE;
        psh.hwndParent = GetParent(_hDlg);
        psh.hInstance = HINST_THISDLL;
        psh.pszCaption = szDisplay;
        psh.nPages = 0;
        psh.nStartPage = 0;
        psh.phpage = rPages;

        psp.dwSize = sizeof(psp);
        psp.dwFlags = PSP_DEFAULT;
        psp.hInstance = HINST_THISDLL;

        psp.pfnDlgProc = GeneralPageProc;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_GENERAL);
        psp.lParam = (LPARAM)&generalInitParams;

        rPages[psh.nPages] = CreatePropertySheetPage(&psp);
        if (rPages[psh.nPages])
            psh.nPages++;

        IDataObject * pdo = NULL;
        _pCurDevice->pds->QueryInterface(IID_IDataObject, (LPVOID *) &pdo);

        CRegistrySettings RegSettings(_pCurDevice->DisplayDevice.DeviceKey);
        HKEY hkDriver = RegSettings.OpenDrvRegKey();

        if (hkDriver != INVALID_HANDLE_VALUE) 
        {
            CheckForDuplicateAppletExtensions(hkDriver);
        }

        //
        // load the generic (non hardware specific) extensions
        //
    
        if( ( hpsxa = SHCreatePropSheetExtArrayEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_CONTROLSFOLDER TEXT("\\Device"), 8, pdo) ) != NULL )
        {
            SHAddFromPropSheetExtArray( hpsxa, _AddDisplayPropSheetPage, (LPARAM)&psh );
        }

        //
        // Load the hardware-specific extensions
        //
        // NOTE it is very important to load the OEM extensions *after* the
        // generic extensions some HW extensions expect to be the last tabs
        // in the propsheet (right before the settings tab)
        //
        // FEATURE - we may need a way to NOT load the vendor extensions in case
        // they break our applet.
        //

        if( ( hpsxaOEM = SHCreatePropSheetExtArrayEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_CONTROLSFOLDER TEXT("\\Display"), 8, pdo) ) != NULL )
        {
            SHAddFromPropSheetExtArray( hpsxaOEM, _AddDisplayPropSheetPage, (LPARAM)&psh );
        }

        //
        // Load the applet extensions for the adapter
        //

        if (hkDriver != INVALID_HANDLE_VALUE) 
        {

            if( ( hpsxaAdapter = SHCreatePropSheetExtArrayEx( hkDriver, TEXT("Display"), 8, pdo) ) != NULL )
            {
                SHAddFromPropSheetExtArray( hpsxaAdapter, _AddDisplayPropSheetPage, (LPARAM)&psh );
            }

            RegCloseKey(hkDriver);
        }

        //
        // Load the applet extensions for the adapter child devices (e.g. monitors)
        //
    
        DEVINST devInstAdapter, devInstMonitor;
        DWORD cChildDevices = 0, nChild, index;
        HDEVINFO hDevMonitors = INVALID_HANDLE_VALUE;
        SP_DEVINFO_DATA DevInfoData;
        HKEY hkMonitor;
        BOOL bMonitors = FALSE;
        LPTSTR szAdapterInstanceID = RegSettings.GetDeviceInstanceId();
    
        if (szAdapterInstanceID != NULL) 
        {
            if (CM_Locate_DevNodeW(&devInstAdapter, szAdapterInstanceID, 0) == CR_SUCCESS)
            {
                //
                // Get the number of child devices
                //
    
                cChildDevices = 0;
                if (CM_Get_Child(&devInstMonitor, devInstAdapter, 0) == CR_SUCCESS) 
                {
                    do 
                    {
                        cChildDevices++;
                    } 
                    while (CM_Get_Sibling(&devInstMonitor, devInstMonitor, 0) == CR_SUCCESS);
                }
    
                //
                // Allocate the memory
                //
    
                if (cChildDevices > 0) 
                {
                    phpsxaChildren = (HPSXA*)LocalAlloc(LPTR, cChildDevices * sizeof(HPSXA));
    
                    hDevMonitors = SetupDiGetClassDevs((LPGUID)&GUID_DEVCLASS_MONITOR,
                                                       NULL,
                                                       NULL,
                                                       0);
                }
    
                //
                // Load the applet extensions
                //
    
                if ((phpsxaChildren != NULL) &&
                    (hDevMonitors != INVALID_HANDLE_VALUE))
                {
                    nChild = 0;
                    if (CM_Get_Child(&devInstMonitor, devInstAdapter, 0) == CR_SUCCESS) 
                    {
                        do 
                        {
                            DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                            index = 0;
                            while (SetupDiEnumDeviceInfo(hDevMonitors, 
                                                         index, 
                                                         &DevInfoData)) {
    
                                if (DevInfoData.DevInst == devInstMonitor) {
    
                                    hkMonitor = SetupDiOpenDevRegKey(hDevMonitors,
                                                                     &DevInfoData,
                                                                     DICS_FLAG_GLOBAL,
                                                                     0,
                                                                     DIREG_DRV ,
                                                                     KEY_WRITE | KEY_READ);
    
                                    if (hkMonitor != INVALID_HANDLE_VALUE) 
                                    {
                                        if ((phpsxaChildren[nChild] = SHCreatePropSheetExtArrayEx(hkMonitor, 
                                                                                                  TEXT("Display"), 
                                                                                                  8, 
                                                                                                  pdo)) != NULL)
                                        {
                                            bMonitors = TRUE;
                                            SHAddFromPropSheetExtArray(phpsxaChildren[nChild], 
                                                                       _AddDisplayPropSheetPage, 
                                                                       (LPARAM)&psh);
                                        }
    
                                        RegCloseKey(hkMonitor);
                                    }
    
                                    break;
                                }
    
                                DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                                index++;
                            }
    
                            nChild++;
                        } 
                        while ((nChild < cChildDevices) &&
                               (CM_Get_Sibling(&devInstMonitor, devInstMonitor, 0) == CR_SUCCESS));
                    }
                }
            }
        }
    
        //
        // add a fake settings page to fool OEM extensions (must be last)
        //
        if (hpsxa || hpsxaOEM || hpsxaAdapter || bMonitors)
        {
            AddFakeSettingsPage(_pThemeUI, &psh);
        }

        if (psh.nPages)
        {
            iResult = PropertySheet(&psh);
        }

        _GetDisplayName(_pCurDevice, szDisplay, ARRAYSIZE(szDisplay));

        if (_NumDevices == 1)
        {
            //Set the name of the primary in the static text
            //strip the first token off (this is the number we dont want it)
            TCHAR *pch;
            for (pch=szDisplay; *pch && *pch != TEXT(' '); pch++);
            for (;*pch && *pch == TEXT(' '); pch++);
            SetDlgItemText(_hDlg, IDC_DISPLAYTEXT, pch);
        }
        else
        {
            ComboBox_DeleteString(_hwndList, _pCurDevice->ComboBoxItem);
            ComboBox_InsertString(_hwndList, _pCurDevice->ComboBoxItem, szDisplay);
            ComboBox_SetItemData(_hwndList, _pCurDevice->ComboBoxItem, (DWORD_PTR)_pCurDevice);
            ComboBox_SetCurSel(_hwndList, _pCurDevice->ComboBoxItem);
        }

        if( hpsxa )
            SHDestroyPropSheetExtArray( hpsxa );
        
        if( hpsxaOEM )
            SHDestroyPropSheetExtArray( hpsxaOEM );
        
        if( hpsxaAdapter )
            SHDestroyPropSheetExtArray( hpsxaAdapter );
        
        if (phpsxaChildren != NULL)
        {
            for (nChild = 0; nChild < cChildDevices; nChild++) {
                if (phpsxaChildren[nChild] != NULL) 
                {
                    SHDestroyPropSheetExtArray(phpsxaChildren[nChild]);
                }
            }
            LocalFree(phpsxaChildren);
        }

        if (hDevMonitors != INVALID_HANDLE_VALUE)
        {
            SetupDiDestroyDeviceInfoList(hDevMonitors);
        }
    
        if (pdo)
            pdo->Release();

        if ((iResult == ID_PSRESTARTWINDOWS) || (iResult == ID_PSREBOOTSYSTEM))
        {
            PropSheet_CancelToClose(GetParent(_hDlg));

            if (iResult == ID_PSREBOOTSYSTEM)
                PropSheet_RebootSystem(ghwndPropSheet);
            else
                PropSheet_RestartWindows(ghwndPropSheet);
        }

        //
        // APPCOMPAT
        // Reset the dirty flag based on what the extensions did.
        //

        //
        // Reset the controls in case someone changed the selected mode.
        //

        UpdateActiveDisplay(NULL);
    }
}

//-----------------------------------------------------------------------------
void CSettingsPage::UpdateActiveDisplay(PMULTIMON_DEVICE pDevice, BOOL bRepaint /*=TRUE*/)
{
    if (_pCurDevice && _pCurDevice->pds)
    {
        HWND hwndC;

        _InSetInfo++;

        if (pDevice == NULL)
            pDevice = (PMULTIMON_DEVICE)ComboBox_GetItemData(_hwndList, ComboBox_GetCurSel(_hwndList));
        else
            ComboBox_SetCurSel(_hwndList, pDevice->ComboBoxItem);

        if (pDevice && pDevice != (PMULTIMON_DEVICE)CB_ERR)
        {
            hwndC = GetCurDeviceHwnd();

            // The Current Device has changed, so, force recreating the bitmap the next time
            // we paint the monitor on the preview window.
            _pCurDevice->w = pDevice->w = 0;

            _pCurDevice = pDevice;

            if (hwndC)
                RedrawWindow(hwndC, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);

            hwndC = GetCurDeviceHwnd();
            if (hwndC)
                RedrawWindow(hwndC, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);

            if(_NumDevices > 1)
            {
                // Update the two check box windows
                CheckDlgButton(_hDlg, IDC_DISPLAYPRIME, _pCurDevice->pds->IsPrimary());
                EnableWindow(GetDlgItem(_hDlg, IDC_DISPLAYPRIME),
                         _pCurDevice->pds->IsAttached() &&
                         !_pCurDevice->pds->IsRemovable() &&
                         !_pCurDevice->pds->IsPrimary());

                CheckDlgButton(_hDlg, IDC_DISPLAYUSEME, _pCurDevice->pds->IsAttached());
                EnableWindow(GetDlgItem(_hDlg, IDC_DISPLAYUSEME),
                         !_bNoAttach && !_pCurDevice->pds->IsPrimary());
            }

            // Reset the values for the list boxes, and then repaint it
            if(bRepaint)
            {
                _InitUI();
                _UpdateUI(FALSE /*fAutoSetColorDepth*/);
            }
        }
        else
        {
            // No display device !
            TraceMsg(TF_WARNING, "**** UpdateActiveDisplay: No display device!!!!");
            ASSERT(FALSE);
        }

        _InSetInfo--;
    }
}

// ---------------------------------------------------------------------------
// Initialize the resolution and color UI widgets
//

void CSettingsPage::_InitUI()
{
    if (_pCurDevice && _pCurDevice->pds)
    {
        int       i;
        int       Color;

        // Update the Color list
        TraceMsg(TF_FUNC, "_InitUI() -- Color list");

        SendDlgItemMessage(_hDlg, IDC_COLORBOX, CB_RESETCONTENT, 0, 0);

        if (_pCurDevice->ColorList)
        {
            LocalFree(_pCurDevice->ColorList);
            _pCurDevice->ColorList = NULL;
        }
        _pCurDevice->cColors = _pCurDevice->pds->GetColorList(NULL, &_pCurDevice->ColorList);

        for (i = 0; i < _pCurDevice->cColors; i++)
        {
            TCHAR  achColor[50];
            DWORD  idColor = ID_DSP_TXT_TRUECOLOR32;

            Color = (int) *(_pCurDevice->ColorList + i);

            //
            // convert bit count to number of colors and make it a string
            //

            switch (Color)
            {
            case 32: idColor = ID_DSP_TXT_TRUECOLOR32; break;
            case 24: idColor = ID_DSP_TXT_TRUECOLOR24; break;
            case 16: idColor = ID_DSP_TXT_16BIT_COLOR; break;
            case 15: idColor = ID_DSP_TXT_15BIT_COLOR; break;
            case  8: idColor = ID_DSP_TXT_8BIT_COLOR; break;
            case  4: idColor = ID_DSP_TXT_4BIT_COLOR; break;
            default:
                ASSERT(FALSE);
            }

            LoadString(HINST_THISDLL, idColor, achColor, ARRAYSIZE(achColor));
            SendDlgItemMessage(_hDlg, IDC_COLORBOX, CB_INSERTSTRING, i, (LPARAM)achColor);
        }

        //
        // Update the screen Size List
        //

        TraceMsg(TF_FUNC, "_InitUI() -- Screen Size list");

        if (_pCurDevice->ResolutionList)
        {
            LocalFree(_pCurDevice->ResolutionList);
            _pCurDevice->ResolutionList = NULL;
        }
        _pCurDevice->cResolutions =
            _pCurDevice->pds->GetResolutionList(-1, &_pCurDevice->ResolutionList);

        SendDlgItemMessage(_hDlg, IDC_SCREENSIZE, TBM_SETRANGE, TRUE,
                           MAKELONG(0, _pCurDevice->cResolutions - 1));

        TraceMsg(TF_FUNC, "_InitUI() -- Res MaxRange = %d", _pCurDevice->cResolutions - 1);

        // Reset the indices since they are no longer valid
        _iResolution = -1;
        _iColor = -1;
    }
}

// ---------------------------------------------------------------------------
// Update the resolution and color UI widgets
//
void CSettingsPage::_UpdateUI(BOOL fAutoSetColorDepth, int FocusToCtrlID)
{
    if (_pCurDevice && _pCurDevice->pds)
    {
        int  i;
        POINT Res;
        int   Color;
        BOOL bRepaint;

        // Get the current values
        _pCurDevice->pds->GetCurResolution(&Res);
        Color = _pCurDevice->pds->GetCurColor();

        // Update the color listbox
        TraceMsg(TF_FUNC, "_UpdateUI() -- Set Color %d", Color);

        for (i=0; i<_pCurDevice->cColors; i++)
        {
            if (Color == (int) *(_pCurDevice->ColorList + i))
            {
                TraceMsg(TF_FUNC, "_UpdateUI() -- Set Color index %d", i);

                if (_iColor == i)
                {
                    TraceMsg(TF_FUNC, "_UpdateUI() -- Set Color index %d - is current", i);
                    break;
                }

                HBITMAP hbm, hbmOld;
                int iBitmap = IDB_COLOR4DITHER;
                HDC hdc = GetDC(NULL);
                int bpp = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);

                SendDlgItemMessage(_hDlg, IDC_COLORBOX, CB_SETCURSEL, i, 0);

                if (Color <= 4)
                    iBitmap = IDB_COLOR4;
                else if (bpp >= 16)
                {
                    if (Color <= 8)
                        iBitmap = IDB_COLOR8;
                    else if (Color <= 16)
                        iBitmap = IDB_COLOR16;
                    else
                        iBitmap = IDB_COLOR24;
                }

                ReleaseDC(NULL, hdc);

                hbm = (HBITMAP)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(iBitmap), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
                if (hbm)
                {
                    hbmOld = (HBITMAP) SendDlgItemMessage(_hDlg, IDC_COLORSAMPLE, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hbm);
                    if (hbmOld)
                    {
                        DeleteObject(hbmOld);
                    }
                }

                _iColor = i;
                break;
            }
        }

        if (i == _pCurDevice->cColors)
        {
            TraceMsg(TF_ERROR, "_UpdateUI -- !!! inconsistent color list !!!");
        }


        TraceMsg(TF_FUNC, "_UpdateUI() -- Set Resolution %d %d", Res.x, Res.y);

        // Update the resolution string
        {
            TCHAR achStr[80];
            TCHAR achRes[120];

            LoadString(HINST_THISDLL, ID_DSP_TXT_XBYY, achStr, ARRAYSIZE(achStr));
            StringCchPrintf(achRes, ARRAYSIZE(achRes), achStr, Res.x, Res.y);

            SendDlgItemMessage(_hDlg, IDC_RESXY, WM_SETTEXT, 0, (LPARAM)achRes);
        }

        // Update the resolution slider
        for (i=0; i<_pCurDevice->cResolutions; i++)
        {
            if ( (Res.x == (*(_pCurDevice->ResolutionList + i)).x) &&
                 (Res.y == (*(_pCurDevice->ResolutionList + i)).y) )
            {
                TraceMsg(TF_FUNC, "_UpdateUI() -- Set Resolution index %d", i);

                if (_iResolution == i)
                {
                    TraceMsg(TF_FUNC, "_UpdateUI() -- Set Resolution index %d - is current", i);
                    break;
                }

                SendDlgItemMessage(_hDlg, IDC_SCREENSIZE, TBM_SETPOS, TRUE, i);
                break;
            }
        }

        if (i == _pCurDevice->cResolutions)
        {
            TraceMsg(TF_ERROR, "_UpdateUI -- !!! inconsistent color list !!!");
        }

        bRepaint = (i != _iResolution);
        _iResolution = i;

        // If the resolution has changed, we have to repaint the preview window
        // Set the focus back to the trackbar after the repaint so any further
        // kb events will be send to it rather than the preview window
        if (bRepaint) {
            SendMessage(_hDlg, MM_REDRAWPREVIEW, 0, 0);
        }

        if (FocusToCtrlID != 0) {
            SetFocus(GetDlgItem(_hDlg, FocusToCtrlID));
        }
    }
}

//----------------------------------------------------------------------------
//
//  SetPrimary()
//
//----------------------------------------------------------------------------

BOOL
CSettingsPage::SetPrimary(
    PMULTIMON_DEVICE pDevice)
{
    //
    // Check if state is already set.
    //

    if (pDevice == _pPrimaryDevice)
    {
        pDevice->pds->SetPrimary(TRUE);
        return TRUE;
    }

    ASSERT(pDevice->pds->IsAttached());

    _pPrimaryDevice->pds->SetPrimary(FALSE);
    pDevice->pds->SetPrimary(TRUE);
    _pPrimaryDevice = pDevice;

    SetDirty();

    return TRUE;
}

//----------------------------------------------------------------------------
//
//  SetMonAttached()
//
//----------------------------------------------------------------------------

BOOL
CSettingsPage::SetMonAttached(
    PMULTIMON_DEVICE pDevice,
    BOOL bSetAttached,
    BOOL bForce,
    HWND hwnd)
{
    if (pDevice->pds->IsAttached() == bSetAttached)
    {
        return TRUE;
    }

    if (bSetAttached)
    {
        //
        // Make sure this device actually has a rectangle.
        // If it does not (not configured in the registry, then we need
        // to put up a popup and ask the user to configure the device.
        //

        if (hwnd)
        {
            //
            // Check to see if we should ask the user about enabling this device
            //

            if (bForce == FALSE)
            {
                TCHAR szTurnItOn[400];
                TCHAR szTurnOnTitleFormat[30];
                TCHAR szTurnOnTitle[110];
                LPTSTR pstr = szTurnItOn;
                DWORD chSize = ARRAYSIZE(szTurnItOn);

                LoadString(HINST_THISDLL, IDS_TURNONTITLE, szTurnOnTitleFormat, ARRAYSIZE(szTurnOnTitleFormat));
                StringCchPrintf(szTurnOnTitle, ARRAYSIZE(szTurnOnTitle), szTurnOnTitleFormat, pDevice->DisplayIndex);

                if (GetNumberOfAttachedDisplays() == 1)
                {
                    LoadString(HINST_THISDLL, IDS_TURNONMSG, szTurnItOn, ARRAYSIZE(szTurnItOn));
                    pstr += lstrlen(szTurnItOn);
                    chSize -= lstrlen(szTurnItOn);
                }

                LoadString(HINST_THISDLL, IDS_TURNITON, pstr, chSize);

                if (ShellMessageBox(HINST_THISDLL, hwnd, szTurnItOn, szTurnOnTitle,
                                    MB_YESNO | MB_ICONINFORMATION) != IDYES)
                {
                   return FALSE;
                }
            }
        }

        pDevice->pds->SetAttached(TRUE);

    }
    else  // (bSetAttached == FALSE)
    {
        //
        // Can't detach if we have only one device or it's the primary.
        // The UI should disable this situation
        //

        if ((GetNumberOfAttachedDisplays() == 1) ||
            pDevice->pds->IsPrimary())
        {
            ASSERT(FALSE);
        }

        pDevice->pds->SetAttached(FALSE);
    }

    SetDirty();

    return TRUE;
}

//----------------------------------------------------------------------------
//
//  SetDirty
//
//----------------------------------------------------------------------------
void CSettingsPage::SetDirty(BOOL bDirty)
{
    _bDirty = bDirty;

    if (_bDirty)
    {
        EnableApplyButton(_hDlg);
    }
}

//-----------------------------------------------------------------------------

void CSettingsPage::_CleanupRects(HWND hwndP)
{
    int   n;
    HWND  hwndC;
    DWORD arcDev[MONITORS_MAX];
    RECT arc[MONITORS_MAX];
    DWORD iArcPrimary = 0;

    RECT rc;
    RECT rcU;
    int   i;
    RECT rcPrev;
    int sx,sy;
    int x,y;

    //
    // get the positions of all the windows
    //

    n = 0;

    for (ULONG iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        PMULTIMON_DEVICE pDevice = &_Devices[iDevice];

        hwndC = GetDlgItemP(hwndP, (INT_PTR) pDevice);

        if (hwndC != NULL)
        {
            RECT rcPos;
            RECT rcPreview;

            TraceMsg(TF_GENERAL, "_CleanupRects start Device %08lx, Dev = %d, hwnd = %08lx",
                     pDevice, iDevice, hwndC);

            ShowWindow(hwndC, SW_SHOW);

            GetWindowRect(hwndC, &arc[n]);
            MapWindowPoints(NULL, hwndP, (POINT FAR*)&arc[n], 2);

            pDevice->pds->GetCurPosition(&rcPos);
            pDevice->pds->GetPreviewPosition(&rcPreview);

            _OffsetPreviewToDesk(hwndC, &arc[n], &rcPreview, &rcPos);

            arc[n] = rcPos;
            arcDev[n] = iDevice;

            // TEMP
            // For non-atached devices, make sure they end up to the right
            // Eventually, non-attached devices should be showed aligned on the
            // right hand side of the window.

            if (!pDevice->pds->IsAttached())
            {
                OffsetRect(&arc[n], 10000, 0);
            }

            if (pDevice->pds->IsPrimary())
            {
                TraceMsg(TF_GENERAL, "_CleanupRects primary Device %08lx", pDevice);

                iArcPrimary = n;
            }


            n++;
        }
    }

    //
    // cleanup the rects
    //

    AlignRects(arc, n, iArcPrimary, CUDR_NORMAL);
    
    //
    // Get the union.
    //
    SetRectEmpty(&rcU);
    for (i=0; i<n; i++)
        UnionRect(&rcU, &rcU, &arc[i]);
    GetClientRect(hwndP, &rcPrev);

    //
    // only rescale if the new desk hangs outside the preview area.
    // or is too small
    //

    _DeskToPreview(&rcU, &rc);
    x = ((rcPrev.right  - rcPrev.left)-(rc.right  - rc.left))/2;
    y = ((rcPrev.bottom - rcPrev.top) -(rc.bottom - rc.top))/2;

    if (rcU.left < 0 || rcU.top < 0 || x < 0 || y < 0 ||
        rcU.right > rcPrev.right || rcU.bottom > rcPrev.bottom ||
        (x > (rcPrev.right-rcPrev.left)/8 &&
         y > (rcPrev.bottom-rcPrev.top)/8))
    {
        _rcDesk = rcU;
        sx = MulDiv(rcPrev.right  - rcPrev.left - 16,1000,_rcDesk.right  - _rcDesk.left);
        sy = MulDiv(rcPrev.bottom - rcPrev.top  - 16,1000,_rcDesk.bottom - _rcDesk.top);

        _DeskScale = min(sx,sy) * 2 / 3;
        _DeskToPreview(&_rcDesk, &rc);
        _DeskOff.x = ((rcPrev.right  - rcPrev.left)-(rc.right  - rc.left))/2;
        _DeskOff.y = ((rcPrev.bottom - rcPrev.top) -(rc.bottom - rc.top))/2;
    }

    //
    // Show all the windows and save them all to the devmode.
    //
    for (i=0; i < n; i++)
    {
        RECT rcPos;
        POINT ptPos;

        _Devices[arcDev[i]].pds->GetCurPosition(&rcPos);
        hwndC = GetDlgItemP(hwndP, (INT_PTR) &_Devices[arcDev[i]]);

        _DeskToPreview(&arc[i], &rc);

        rc.right =  MulDiv(RECTWIDTH(rcPos),  _DeskScale, 1000);
        rc.bottom = MulDiv(RECTHEIGHT(rcPos), _DeskScale, 1000);

        TraceMsg(TF_GENERAL, "_CleanupRects set Dev = %d, hwnd = %08lx", arcDev[i], hwndC);
        TraceMsg(TF_GENERAL, "_CleanupRects window pos %d,%d,%d,%d", rc.left, rc.top, rc.right, rc.bottom);
        
        SetWindowPos(hwndC,
                     NULL,
                     rc.left,
                     rc.top,
                     rc.right,
                     rc.bottom,
                     SWP_NOZORDER);
        
        rc.right += rc.left;
        rc.bottom += rc.top;

        _Devices[arcDev[i]].pds->SetPreviewPosition(&rc);

        ptPos.x = arc[i].left;
        ptPos.y = arc[i].top;

        _Devices[arcDev[i]].pds->SetCurPosition(&ptPos);
    }

    TraceMsg(TF_GENERAL, "");
}

void CSettingsPage::_ConfirmPositions()
{
    ASSERT (_NumDevices > 1);

    PMULTIMON_DEVICE pDevice;
    ULONG iDevice;

    for (iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        pDevice = &_Devices[iDevice];
        if (pDevice->pds->IsOrgAttached())
        {
            RECT rcOrg, rcCur;

            pDevice->pds->GetCurPosition(&rcCur);
            pDevice->pds->GetOrgPosition(&rcOrg);
            if ((rcCur.left != rcOrg.left) ||
                (rcCur.top != rcOrg.top))
            {
                POINT ptOrg;

                ptOrg.x = rcCur.left;
                ptOrg.y = rcCur.top;
                pDevice->pds->SetOrgPosition(&ptOrg);
                SetDirty(TRUE);
            }
        }
    }
}

void CSettingsPage::GetMonitorPosition(PMULTIMON_DEVICE pDevice, HWND hwndP, PPOINT ptPos)
{
    int iPrimary = 0;
    HWND hwndC;
    RECT rcPos;
    RECT rcPreview;
    RECT arc[MONITORS_MAX];
    int i;

    for (ULONG iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        PMULTIMON_DEVICE pDevice = &_Devices[iDevice];

        hwndC = GetDlgItemP(hwndP, (INT_PTR) pDevice);
        ASSERT(hwndC);

        GetWindowRect(hwndC, &arc[iDevice]);
        MapWindowPoints(NULL, hwndP, (POINT FAR*)&arc[iDevice], 2);

        pDevice->pds->GetCurPosition(&rcPos);
        pDevice->pds->GetPreviewPosition(&rcPreview);

        _OffsetPreviewToDesk(hwndC, &arc[iDevice], &rcPreview, &rcPos);
        
        arc[iDevice] = rcPos;

        if (pDevice->pds->IsPrimary()) {
            iPrimary = iDevice;
        }
    }

    AlignRects(arc, iDevice, iPrimary, CUDR_NORMAL);

    i = (int)(pDevice - _Devices);
    ptPos->x = arc[i].left;
    ptPos->y = arc[i].top;
}

BOOL CSettingsPage::HandleMonitorChange(HWND hwndP, BOOL bMainDlg, BOOL bRepaint /*=TRUE*/)
{
    if (!bMainDlg && _InSetInfo)
        return FALSE;

    SetDirty();

    if (bMainDlg)
        BringWindowToTop(hwndP);
    _CleanupRects(GetParent(hwndP));
    UpdateActiveDisplay(_pCurDevice, bRepaint);
    return TRUE;
}

BOOL CSettingsPage::RegisterPreviewWindowClass(WNDPROC pfnWndProc)
{
    TraceMsg(TF_GENERAL, "InitMultiMonitorDlg\n");
    WNDCLASS         cls;

    cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
    cls.hIcon          = NULL;
    cls.lpszMenuName   = NULL;
    cls.lpszClassName  = TEXT("Monitor32");
    cls.hbrBackground  = (HBRUSH)(COLOR_DESKTOP + 1);
    cls.hInstance      = HINST_THISDLL;
    cls.style          = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
    cls.lpfnWndProc    = pfnWndProc;
    cls.cbWndExtra     = sizeof(LPVOID);
    cls.cbClsExtra     = 0;

    return RegisterClass(&cls);
}

LRESULT CALLBACK DeskWndProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, UINT_PTR uID, DWORD_PTR dwRefData);

// This function is called from desk.c; Hence extern "C".
// This function is needed to determine if we need to use the single monitor's dialog
// or multi-monitor's dialog template at the time of starting the control panel applet.
int ComputeNumberOfDisplayDevices(void)
{
    int iNumberOfDevices = 0;
    CSettingsPage * pMultiMon = new CSettingsPage;

    if (pMultiMon)
    {
        int iDevice;

        // Enumerate all display devices to count the number of valid devices.
        iNumberOfDevices = pMultiMon->_EnumerateAllDisplayDevices();

        // Now that we have the number of devices, let's cleanup the device settings we
        // created in the process of enumerating above.
        for (iDevice = 0; iDevice < iNumberOfDevices; iDevice++)
            pMultiMon->_DestroyMultimonDevice(&pMultiMon->_Devices[iDevice]);

        // Let's clean up the MultiMon we allocated earlier.
        pMultiMon->Release();
    }

    return iNumberOfDevices;
}


int ComputeNumberOfMonitorsFast(BOOL fFastDetect)       
{
    int nVideoCards = 0;
    int nIndex;
    DISPLAY_DEVICE dispDevice = {0};

    dispDevice.cb = sizeof(dispDevice);
    for (nIndex = 0; EnumDisplayDevices(NULL, nIndex, &dispDevice, 0); nIndex++)
    {
        // Fast Detect means the caller only cares if there are more than 1.
        if (fFastDetect && (nVideoCards > 1))
        {
            break;
        }
        dispDevice.cb = sizeof(dispDevice);
        if (!(dispDevice.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER))
        {
            nVideoCards++;
        }
    }

    return nVideoCards;
}



BOOL CSettingsPage::_InitDisplaySettings(BOOL bExport)
{
    HWND             hwndC;
    int              iItem;
    LONG             iPrimeDevice = 0;
    TCHAR            ach[128];
    PMULTIMON_DEVICE pDevice;
    RECT             rcPrimary;

    HCURSOR hcur;

    _InSetInfo = 1;
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // Reset all the data so we can reinitialize the applet.
    //

    {
        ComboBox_ResetContent(_hwndList);
        SetRectEmpty(&_rcDesk);

        hwndC = GetWindow(_hwndDesk, GW_CHILD);
        while (hwndC)
        {
            RemoveTrackingToolTip(hwndC);
            RemovePopupToolTip(hwndC);
            DestroyWindow(hwndC);
            hwndC = GetWindow(_hwndDesk, GW_CHILD);
        }

        ShowWindow(_hwndDesk, SW_HIDE);

        if (_himl != NULL)
        {
            ImageList_Destroy(_himl);
            _himl = NULL;
        }

        //
        // Clear out all the devices.
        //
        for (ULONG iDevice = 0; iDevice < _NumDevices; iDevice++) {
            pDevice = _Devices + iDevice;
            _DestroyMultimonDevice(pDevice);
            ZeroMemory(pDevice, sizeof(*pDevice));
        }

        ZeroMemory(_Devices + _NumDevices,
                   sizeof(_Devices) - sizeof(MULTIMON_DEVICE) * _NumDevices);

        _NumDevices = 0;
    }

    //
    // Enumerate all the devices in the system.
    //
    // Note: This function computes the _NumDevices.

    _EnumerateAllDisplayDevices();

    if (_NumDevices == 0)
    {
        ASSERT(0);
        return FALSE;
    }

    // Because we are getting the registry values, the current state of
    // the registry may be inconsistent with that of the system:
    //
    // EmumDisplayDevices will return the active primary in the
    // system, which may be different than the actual primary marked in the
    // registry

    BOOL bTmpDevicePrimary  = FALSE;
    ULONG iDevice;

    _pPrimaryDevice = NULL;

    for (iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        // First, we can pick any monitor that is attached as the primary.
        if (_Devices[iDevice].pds->IsAttached())
        {
            if ((_pPrimaryDevice == NULL) && 
                !_Devices[iDevice].pds->IsRemovable())
            {
                _pPrimaryDevice = &_Devices[iDevice];
                TraceMsg(TF_GENERAL, "InitDisplaySettings: primary found %d\n", iDevice);
            }

            // If the DISPLAY_DEVICE structure tells us this is the primary,
            // Pick this one.
            if (_Devices[iDevice].DisplayDevice.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
            {
                if (bTmpDevicePrimary)
                {
                    ASSERT(FALSE);
                }
                else
                {
                    _pPrimaryDevice = &_Devices[iDevice];
                    bTmpDevicePrimary = TRUE;
                    TraceMsg(TF_GENERAL, "InitDisplaySettings: Tmp DEVICE_PRIMARY found %d", iDevice);
                }

                // Check that the position should really be 0,0
                RECT pos;

                _Devices[iDevice].pds->GetCurPosition(&pos);

                if ((pos.left == 0) &&
                    (pos.top == 0))
                {
                    _pPrimaryDevice = &_Devices[iDevice];
                    TraceMsg(TF_GENERAL, "InitDisplaySettings: Best DEVICE_PRIMARY found %d", iDevice);
                }
                else
                {
                    ASSERT(FALSE);
                    TraceMsg(TF_GENERAL, "InitDisplaySettings: PRIMARY is not at 0,0");
                }
            }
        }
    }

    if (_pPrimaryDevice == NULL)
    {
        TraceMsg(TF_GENERAL, "InitDisplaySettings: NO Attached devices !!!");

        // We must be running setup.
        // Pick the first non-removable device as the primary.
        for (iDevice = 0; iDevice < _NumDevices; iDevice++)
        {
            if (!_Devices[iDevice].pds->IsRemovable()) 
            {
                _pPrimaryDevice = &_Devices[iDevice];
                break;
            }
        }

        if (_pPrimaryDevice == NULL)
        {
            ASSERT(FALSE);
            TraceMsg(TF_GENERAL, "InitDisplaySettings: All devices are removable !!!");
            
            _pPrimaryDevice = &_Devices[0];
        }
    }

    _pCurDevice = _pPrimaryDevice;

    //
    // Reset the primary's variables to make sure it is a properly formated
    // primary entry.
    //

    SetMonAttached(_pPrimaryDevice, TRUE, TRUE, NULL);
    SetPrimary(_pPrimaryDevice);
    _pPrimaryDevice->pds->GetCurPosition(&rcPrimary);

    //
    // compute the max image size needed for a monitor bitmap
    //
    // NOTE this must be the max size the images will *ever*
    // be we cant just take the current max size.
    // we use the client window size, a child monitor cant be larger than this.
    //
    RECT rcDesk;
    GetClientRect(_hwndDesk, &rcDesk);
    int cxImage = rcDesk.right;
    int cyImage = rcDesk.bottom;

    //
    // Create a temporary monitor bitmap
    //
    HBITMAP hbm = NULL;
    MakeMonitorBitmap(cxImage, cyImage, NULL, &hbm, NULL, cxImage, cyImage, FALSE);

    //
    // Go through all the devices one last time to create the windows
    //
    for (iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        TCHAR szDisplay[256];
        pDevice = &_Devices[iDevice];
        MonitorData md = {0};
        RECT rcPos;
        LPVOID pWindowData = (LPVOID)this;
        pDevice->DisplayIndex = iDevice + 1;
        _GetDisplayName(pDevice, szDisplay, ARRAYSIZE(szDisplay));
        iItem = ComboBox_AddString(_hwndList, szDisplay);

        pDevice->ComboBoxItem = iItem;

        ComboBox_SetItemData(_hwndList,
                             iItem,
                             (DWORD_PTR)pDevice);

        //
        // If the monitor is part of the desktop, show it on the screen
        // otherwise keep it invisible.
        //

        StringCchPrintf(ach, ARRAYSIZE(ach), TEXT("%d"), iDevice + 1);

        // Set the selection
        //

        if (pDevice == _pPrimaryDevice)
        {
            iPrimeDevice = iDevice;
        }

        if (!pDevice->pds->IsAttached())
        {
            // By default set the unattached monitors to the right of the primary monitor
            POINT ptPos = {rcPrimary.right, rcPrimary.top};
            pDevice->pds->SetCurPosition(&ptPos);
        }

        pDevice->pds->GetCurPosition(&rcPos);

        if (bExport)
        {
            md.dwSize = sizeof(MonitorData);
            if ( pDevice->pds->IsPrimary() )
                md.dwStatus |= MD_PRIMARY;
            if ( pDevice->pds->IsAttached() )
                md.dwStatus |= MD_ATTACHED;
            md.rcPos = rcPos;

            pWindowData = &md;
        }

        if (_himl == NULL)
        {
            UINT flags = ILC_COLORDDB | ILC_MASK;
            _himl = ImageList_Create(cxImage, cyImage, flags, _NumDevices, 1);
            ASSERT(_himl);
            ImageList_SetBkColor(_himl, GetSysColor(COLOR_APPWORKSPACE));
        }

        pDevice->w      = -1;
        pDevice->h      = -1;
        pDevice->himl   = _himl;
        pDevice->iImage = ImageList_AddMasked(_himl, hbm, CLR_DEFAULT);

        TraceMsg(TF_GENERAL, "InitDisplaySettings: Creating preview windows %s at %d %d %d %d",
                 ach, rcPos.left, rcPos.top, rcPos.right, rcPos.bottom);

        // HACK! Use pDevice as its own id.  Doesn't work on Win64.
        hwndC = CreateWindowEx(
                               0, 
                               TEXT("Monitor32"), ach,
                               WS_CLIPSIBLINGS | WS_VISIBLE | WS_CHILD,
                               rcPos.left, rcPos.top, RECTWIDTH(rcPos), RECTHEIGHT(rcPos),
                               _hwndDesk,
                               (HMENU)pDevice,
                               HINST_THISDLL,
                               pWindowData);

        ASSERT(hwndC);
        AddTrackingToolTip(pDevice, hwndC);
        AddPopupToolTip(hwndC);
    }

    ToolTip_Activate(ghwndToolTipPopup, TRUE);
    ToolTip_SetDelayTime(ghwndToolTipPopup, TTDT_INITIAL, 1000);
    ToolTip_SetDelayTime(ghwndToolTipPopup, TTDT_RESHOW, 1000);

    //  nuke the temp monitor bitmap.
    if (hbm)
        DeleteObject(hbm);

    //
    // Set the primary device as the current device
    //

    ComboBox_SetCurSel(_hwndList, iPrimeDevice);

    // Initialize all the constants and the settings fields
    _DeskScale = 1000;
    _DeskOff.x = 0;
    _DeskOff.y = 0;
    _CleanupRects(_hwndDesk);

    // Now: depends on whether we have a multimon system, change the UI
    if (_NumDevices == 1)
    {
        HWND hwndDisable;

        hwndDisable = GetDlgItem(_hDlg, IDC_MULTIMONHELP);
        ShowWindow(hwndDisable, SW_HIDE);
        ShowWindow(_hwndDesk, SW_HIDE);

        // set up bitmaps for sample screen
        _hbmScrSample = LoadMonitorBitmap( TRUE ); // let them do the desktop
        SendDlgItemMessage(_hDlg, IDC_SCREENSAMPLE, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)_hbmScrSample);

        // get a base copy of the bitmap for when the "internals" change
        _hbmMonitor = LoadMonitorBitmap( FALSE ); // we'll do the desktop

        //Hide the combo box, keep the static text
        ShowWindow(_hwndList, SW_HIDE);

        //Set the name of the primary in the static text
        //strip the first token off (this is the number we dont want it)
        TCHAR *pch, szDisplay[MAX_PATH];
        _GetDisplayName(_pPrimaryDevice, szDisplay, ARRAYSIZE(szDisplay));
        for (pch=szDisplay; *pch && *pch != TEXT(' '); pch++);
        for (;*pch && *pch == TEXT(' '); pch++);
        SetDlgItemText(_hDlg, IDC_DISPLAYTEXT, pch);

        // Hide the check boxes

        // Single monitors use a different dialog template now!
        hwndDisable = GetDlgItem(_hDlg, IDC_DISPLAYPRIME);
        if(hwndDisable)
            ShowWindow(hwndDisable, SW_HIDE);
        hwndDisable = GetDlgItem(_hDlg, IDC_DISPLAYUSEME);
        if(hwndDisable)
            ShowWindow(hwndDisable, SW_HIDE);

    }
    else if (_NumDevices > 0)
    {
        //Hide the static text, keep the combo box
        ShowWindow(GetDlgItem(_hDlg, IDC_DISPLAYTEXT), SW_HIDE);

        // Hide the Multimon version of the preview objects
        ShowWindow(GetDlgItem(_hDlg, IDC_SCREENSAMPLE), SW_HIDE);

        // In case of multiple devices, subclass the _hwndDesk window for key board support
        SetWindowSubclass(_hwndDesk, DeskWndProc, 0, (DWORD_PTR)this);
        ShowWindow(_hwndDesk, SW_SHOW);
    }

    //
    // Paint the UI.
    //

    UpdateActiveDisplay(_pCurDevice);

    //
    // Reset the cursor and leave
    //

    SetCursor(hcur);
    _InSetInfo--;

    return TRUE;
}

//
// This function enumerates all the devices and returns the number of
// devices found in the system.
//

int  CSettingsPage::_EnumerateAllDisplayDevices()
{
    PMULTIMON_DEVICE pDevice;
    int iEnum;
    BOOL fSuccess;
    ULONG dwVgaPrimary = 0xFFFFFFFF;

    //
    // Enumerate all the devices in the system.
    //

    for (iEnum = 0; _NumDevices < MONITORS_MAX; iEnum++)
    {
        pDevice = &_Devices[_NumDevices];
        ZeroMemory(&(pDevice->DisplayDevice), sizeof(pDevice->DisplayDevice));
        pDevice->DisplayDevice.cb = sizeof(pDevice->DisplayDevice);

        fSuccess = EnumDisplayDevices(NULL, iEnum, &pDevice->DisplayDevice, 0);

        TraceMsg(TF_GENERAL, "Device %d       ", iEnum);
        TraceMsg(TF_GENERAL, "cb %d           ", pDevice->DisplayDevice.cb);
        TraceMsg(TF_GENERAL, "DeviceName %ws  ", pDevice->DisplayDevice.DeviceName);
        TraceMsg(TF_GENERAL, "DeviceString %ws", pDevice->DisplayDevice.DeviceString);
        TraceMsg(TF_GENERAL, "StateFlags %08lx", pDevice->DisplayDevice.StateFlags);

        // ignore device's we cant create a DC for.
        if (!fSuccess)
        {
            TraceMsg(TF_GENERAL, "End of list\n");
            break;
        }

        // We won't even include the MIRRORING drivers in the list for
        // now.
        if (pDevice->DisplayDevice.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
        {
            TraceMsg(TF_GENERAL, "Mirroring driver - skip it\n");
            continue;
        }

        // dump the device software key
        TraceMsg(TF_GENERAL, "DeviceKey %s", pDevice->DisplayDevice.DeviceKey);

        // Create the settings for this device
        pDevice->pds = new CDisplaySettings();
        if (pDevice->pds)
        {
            if (pDevice->pds->InitSettings(&pDevice->DisplayDevice))
            {
                // Determine if the VGA is the primary.
                // This will only happen for SETUP or BASEVIDEO
                //
                // We want to delete this device later on if we have others.
                if (pDevice->DisplayDevice.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
                {
                    CRegistrySettings crv(&pDevice->DisplayDevice.DeviceKey[0]);

                    LPTSTR pszMini = crv.GetMiniPort();

                    // If VGA is active, then go to pass 2.
                    // Otherwise, let's try to use this device
                    //

                    if (pszMini && (!lstrcmpi(TEXT("vga"), pszMini)))
                    {
                        TraceMsg(TF_GENERAL, "EnumDevices - VGA primary\n");
                        dwVgaPrimary = _NumDevices;
                    }
                }
                // Add it to the list.
                _NumDevices++;
            }
            else
            {
                pDevice->pds->Release();
                pDevice->pds = NULL;
            }
        }
    }

    //
    // If the primary VGA is not needed, remove it.
    //

    if ((dwVgaPrimary != 0xFFFFFFFF) &&
        (_NumDevices >= 2))
    {
        TraceMsg(TF_GENERAL, "REMOVE primary VGA device\n");

        _Devices[dwVgaPrimary].pds->Release();
        _Devices[dwVgaPrimary].pds = NULL;

        _NumDevices--;
        _Devices[dwVgaPrimary] = _Devices[_NumDevices];

    }

    return(_NumDevices);  //Return the number of devices.
}


//-----------------------------------------------------------------------------
BOOL CSettingsPage::InitMultiMonitorDlg(HWND hDlg)
{
    HWND hwndSlider;
    BOOL fSucceeded;

    _hDlg = hDlg;
    _hwndDesk = GetDlgItem(_hDlg, IDC_DISPLAYDESK);
    _hwndList = GetDlgItem(_hDlg, IDC_DISPLAYLIST);

    hwndSlider = GetDlgItem(hDlg, IDC_SCREENSIZE);
    ASSERT(hwndSlider != NULL);

    fSucceeded = SetWindowSubclass(hwndSlider, SliderSubWndProc, 0, NULL);
    ASSERT(fSucceeded);

    // Determine in what mode we are running the applet before getting information
    _vPreExecMode();

    // Create a tooltip window
    ghwndToolTipTracking = CreateWindowEx(WS_EX_TOPMOST, TOOLTIPS_CLASS, TEXT(""),
                                WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT,
                                CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
                                HINST_THISDLL, NULL);

    ghwndToolTipPopup = CreateWindowEx(WS_EX_TOPMOST, TOOLTIPS_CLASS, TEXT(""),
                                WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT,
                                CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
                                HINST_THISDLL, NULL);

    RegisterPreviewWindowClass(&MonitorWindowProc);
    _InitDisplaySettings(FALSE);

    if (_NumDevices > 1)
        _ConfirmPositions();

    if (ClassicGetSystemMetrics(SM_REMOTESESSION)) {
        EnableWindow(GetDlgItem(_hDlg, IDC_DISPLAYPROPERTIES), FALSE);
    }

    // Determine if any errors showed up during enumerations and initialization
    _vPostExecMode();

    // Now tell the user what we found out during initialization
    // Errors, or what we found during detection
    PostMessage(hDlg, MSG_DSP_SETUP_MESSAGE, 0, 0);

    // Since this could have taken a very long time, just make us visible
    // if another app (like progman) came up.
    ShowWindow(hDlg, SW_SHOW);

    return TRUE;
}


LRESULT CALLBACK DeskWndProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, UINT_PTR uID, DWORD_PTR dwRefData)
{
    CSettingsPage * pcmm = (CSettingsPage *)dwRefData;
    HWND hwndC;
    RECT rcPos;
    BOOL bMoved = TRUE;
    int iMonitor, nMoveUnit;

    switch(message)
    {
        case WM_GETDLGCODE:
             return DLGC_WANTCHARS | DLGC_WANTARROWS;

        case WM_KILLFOCUS:
            RedrawWindow(hDlg, NULL, NULL, RDW_INVALIDATE);
            break;

        case WM_MOUSEMOVE: {
                MSG mmsg;
                ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, hDlg, message, wParam, lParam);
            }
            break;

        case WM_PAINT:
            if (GetFocus() != hDlg)
                break;
            return(DefSubclassProc(hDlg, message, wParam, lParam));
            break;

        case WM_LBUTTONDOWN:
            SetFocus(hDlg);
            break;

        case WM_KEYDOWN:

            nMoveUnit = ((GetKeyState(VK_CONTROL) & 0x8000) ? 1 : 3);
            hwndC = pcmm->GetCurDeviceHwnd();
            GetWindowRect(hwndC, &rcPos);
            MapWindowRect(NULL, hDlg, &rcPos);
            switch(wParam)
            {
                case VK_LEFT:
                    MoveWindow(hwndC, rcPos.left - nMoveUnit, rcPos.top, RECTWIDTH(rcPos), RECTHEIGHT(rcPos), TRUE);
                    break;
                case VK_RIGHT:
                    MoveWindow(hwndC, rcPos.left + nMoveUnit, rcPos.top, RECTWIDTH(rcPos), RECTHEIGHT(rcPos), TRUE);
                    break;
                case VK_UP:
                    MoveWindow(hwndC, rcPos.left, rcPos.top - nMoveUnit, RECTWIDTH(rcPos), RECTHEIGHT(rcPos), TRUE);
                    break;
                case VK_DOWN:
                    MoveWindow(hwndC, rcPos.left, rcPos.top + nMoveUnit, RECTWIDTH(rcPos), RECTHEIGHT(rcPos), TRUE);
                    break;
                default:
                    bMoved = FALSE;
                    break;
            }

            if (bMoved)
            {
                pcmm->HandleMonitorChange(hwndC, FALSE, FALSE);
                if (IsWindowVisible(ghwndToolTipPopup)) {
                    ToolTip_Update(ghwndToolTipPopup);
                }
            }

            break;

        case WM_CHAR:

            if (wParam >= TEXT('0') && wParam <= TEXT('9') && pcmm) {
                iMonitor = (TCHAR)wParam - TEXT('0');
                if ((iMonitor == 0) && (pcmm->GetNumDevices() >= 10))
                {
                    iMonitor = 10;
                }

                if ((iMonitor > 0) && ((ULONG)iMonitor <= pcmm->GetNumDevices()))
                {
                    HWND hwndList = GetDlgItem(GetParent(hDlg), IDC_DISPLAYLIST);
                    ComboBox_SetCurSel(hwndList, iMonitor - 1);
                    pcmm->UpdateActiveDisplay(NULL);
                    return 0;
                }
            }
            break;

        case WM_DESTROY:
            RemoveWindowSubclass(hDlg, DeskWndProc, 0);
            break;

        default:
            break;
    }

    return DefSubclassProc(hDlg, message, wParam, lParam);
}


//-----------------------------------------------------------------------------
//
// Callback functions PropertySheet can use
//
INT_PTR CALLBACK CSettingsPage::SettingsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CSettingsPage * pcmm = (CSettingsPage *) GetWindowLongPtr(hDlg, DWLP_USER);
    switch (message)
    {
        case WM_INITDIALOG:
            {
                PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

                if (pPropSheetPage)
                {
                    SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
                    pcmm = (CSettingsPage *)pPropSheetPage->lParam;
                }

                if (pcmm)
                {
                    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pcmm);
                    ghwndPropSheet = GetParent(hDlg);

                    SetWindowLong(ghwndPropSheet,
                                  GWL_STYLE,
                                  GetWindowLong(ghwndPropSheet, GWL_STYLE) | WS_CLIPCHILDREN);

                    if (pcmm->InitMultiMonitorDlg(hDlg))
                    {
                        //
                        // if we have a invalid mode force the user to Apply
                        //
                        DWORD dwExecMode;
                        if (pcmm->_pThemeUI && (SUCCEEDED(pcmm->_pThemeUI->GetExecMode(&dwExecMode))))
                        {
                            if (dwExecMode == EM_INVALID_MODE)
                                pcmm->SetDirty();
                        }

                        return TRUE;
                    }
                    else
                        return FALSE;
                }
            }
            break;
        case WM_DESTROY:
            if (pcmm)
            {
                pcmm->WndProc(message, wParam, lParam);
                SetWindowLongPtr(hDlg, DWLP_USER, NULL);
            }
            if(gfFlashWindowRegistered)
            {
                gfFlashWindowRegistered = FALSE;
                UnregisterClass(TEXT("MonitorNumber32"), HINST_THISDLL);
            }
            break;
        default:
            if (pcmm)
                return pcmm->WndProc(message, wParam, lParam);
            break;
    }

    return FALSE;
}

void CSettingsPage::_SetPreviewScreenSize(int HRes, int VRes, int iOrgXRes, int iOrgYRes)
{
    HBITMAP hbmOld, hbmOld2;
    HBRUSH hbrOld;
    HDC hdcMem, hdcMem2;


    // stretching the taskbar could get messy, we'll only do the desktop
    int mon_dy = MON_DY - MON_TRAY;

    // init to identical extents
    SIZE dSrc = { MON_DX, mon_dy };
    SIZE dDst = { MON_DX, mon_dy };

    // set up a work area to play in
    if (!_hbmMonitor || !_hbmScrSample)
        return;

    HDC hdc = GetDC(NULL);
    hdcMem = CreateCompatibleDC(hdc);
    hdcMem2 = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);
    if (!hdcMem2 || !hdcMem)
        return;
    hbmOld2 = (HBITMAP)SelectObject(hdcMem2, _hbmScrSample);
    hbmOld = (HBITMAP)SelectObject(hdcMem, _hbmMonitor);

    // see if we need to shrink either aspect of the image
    if (HRes > iOrgXRes || VRes > iOrgYRes)
    {
        // make sure the uncovered area will be seamless with the desktop
        RECT rc = { MON_X, MON_Y, MON_X + MON_DX, MON_Y + mon_dy };
        HBRUSH hbr = CreateSolidBrush(GetPixel( hdcMem, MON_X + 1, MON_Y + 1 ));

        if (hbr)
        {
            FillRect(hdcMem2, &rc, hbr);
            DeleteObject(hbr);
        }
    }

    // stretch the image to reflect the new resolution
    if( HRes > iOrgXRes )
        dDst.cx = MulDiv( MON_DX, iOrgXRes, HRes );
    else if( HRes < iOrgXRes )
        dSrc.cx = MulDiv( MON_DX, HRes, iOrgXRes );

    if( VRes > iOrgYRes )
        dDst.cy = MulDiv( mon_dy, iOrgYRes, VRes );
    else if( VRes < iOrgYRes )
        dSrc.cy = MulDiv( mon_dy, VRes, iOrgYRes );

    SetStretchBltMode( hdcMem2, COLORONCOLOR );
    StretchBlt( hdcMem2, MON_X, MON_Y, dDst.cx, dDst.cy,
                hdcMem, MON_X, MON_Y, dSrc.cx, dSrc.cy, SRCCOPY);

    // now fill the new image's desktop with the possibly-dithered brush
    // the top right corner seems least likely to be hit by the stretch...

    hbrOld = (HBRUSH)SelectObject( hdcMem2, GetSysColorBrush( COLOR_DESKTOP ) );
    ExtFloodFill(hdcMem2, MON_X + MON_DX - 2, MON_Y+1,
                 GetPixel(hdcMem2, MON_X + MON_DX - 2, MON_Y+1), FLOODFILLSURFACE);

    // clean up after ourselves
    SelectObject( hdcMem2, hbrOld );
    SelectObject( hdcMem2, hbmOld2 );
    DeleteObject( hdcMem2 );
    SelectObject( hdcMem, hbmOld );
    DeleteObject( hdcMem );
}

void CSettingsPage::_RedrawDeskPreviews()
{
    if (_NumDevices > 1)
    {
        _CleanupRects(_hwndDesk);
        RedrawWindow(_hwndDesk, NULL, NULL, RDW_ALLCHILDREN | RDW_ERASE | RDW_INVALIDATE);
    }
    else if (_pCurDevice && _pCurDevice->pds)
    {
        RECT rcPos, rcOrgPos;
        _pCurDevice->pds->GetCurPosition(&rcPos);
        _pCurDevice->pds->GetOrgPosition(&rcOrgPos);
        _SetPreviewScreenSize(RECTWIDTH(rcPos), RECTHEIGHT(rcPos), RECTWIDTH(rcOrgPos), RECTHEIGHT(rcOrgPos));
        // only invalidate the "screen" part of the monitor bitmap
        rcPos.left = MON_X;
        rcPos.top = MON_Y;
        rcPos.right = MON_X + MON_DX + 2;  // fudge (trust me)
        rcPos.bottom = MON_Y + MON_DY + 1; // fudge (trust me)
        InvalidateRect(GetDlgItem(_hDlg, IDC_SCREENSAMPLE), &rcPos, FALSE);
    }
}


int DisplaySaveSettings(PVOID pContext, HWND hwnd)
{
    CDisplaySettings *rgpds[1];
    rgpds[0] = (CDisplaySettings*) pContext;
    if(rgpds[0]->bIsModeChanged())
        return CSettingsPage::_DisplaySaveSettings(rgpds, 1, hwnd);
    else
        return DISP_CHANGE_SUCCESSFUL;
}

int CSettingsPage::_DisplaySaveSettings(CDisplaySettings *rgpds[], ULONG numDevices, HWND hDlg)
{
    BOOL  bReboot = FALSE;
    BOOL  bTest = FALSE;
    int   iSave;
    ULONG iDevice;
    POINT ptCursorSave;

    // Test the new settings first
    iSave = _SaveSettings(rgpds, numDevices, hDlg, CDS_TEST);

    if (iSave < DISP_CHANGE_SUCCESSFUL)
    {
        FmtMessageBox(hDlg,
                      MB_ICONEXCLAMATION,
                      IDS_CHANGE_SETTINGS,
                      IDS_SETTINGS_INVALID);

        return iSave;
    }

    int iDynaResult;

    // Ask first and then change the settings.
    if (!bReboot &&
        (_AnyChange(rgpds, numDevices) ||
         _IsSingleToMultimonChange(rgpds, numDevices)))
    {
        iDynaResult = AskDynaCDS(hDlg);
        if (iDynaResult == -1)
        {
            return DISP_CHANGE_NOTUPDATED;
        }
        else if (iDynaResult == 0)
        {
            bReboot = TRUE;
        }
    }

    if (!bReboot && _AnyChange(rgpds, numDevices) &&
        !_CanSkipWarningBecauseKnownSafe(rgpds, numDevices))
    {
        bTest = TRUE;
    }

    // Save the settings to the registry.
    iSave = _SaveSettings(rgpds, numDevices, hDlg, CDS_UPDATEREGISTRY | CDS_NORESET);

    if (iSave < DISP_CHANGE_SUCCESSFUL)
    {
        // NOTE
        // If we get NOT_UPDATED, this mean security may be turned on.
        // We could still try to do the dynamic change.
        // This only works in single mon ...
        if (iSave == DISP_CHANGE_NOTUPDATED)
        {
            FmtMessageBox(hDlg,
                          MB_ICONEXCLAMATION,
                          IDS_CHANGE_SETTINGS,
                          IDS_SETTINGS_CANNOT_SAVE);
        }
        else
        {
            FmtMessageBox(hDlg,
                          MB_ICONEXCLAMATION,
                          IDS_CHANGE_SETTINGS,
                          IDS_SETTINGS_FAILED_SAVE);
        }

        // Restore the settings to their original state
        for (iDevice = 0; iDevice < numDevices; iDevice++)
        {
            rgpds[iDevice]->RestoreSettings();
        }

        _SaveSettings(rgpds, numDevices, hDlg, CDS_UPDATEREGISTRY | CDS_NORESET);
        return iSave;
    }

    if (bReboot)
    {
        iSave = DISP_CHANGE_RESTART;
    }

    // Try to change the mode dynamically if it was requested
    GetCursorPos(&ptCursorSave);

    if (iSave == DISP_CHANGE_SUCCESSFUL)
    {
        // If EnumDisplaySettings was called with EDS_RAWMODE, we need CDS_RAWMODE below.
        // Otherwise, it's harmless.
        iSave = ChangeDisplaySettings(NULL, CDS_RAWMODE);
        //We post a message to ourselves to destroy it later.
        // Check the return from the dynamic mode switch.
        if (iSave < 0)
        {
            DWORD dwMessage =
                ((iSave == DISP_CHANGE_BADDUALVIEW) ? IDS_CHANGESETTINGS_BADDUALVIEW
                                                    : IDS_DYNAMIC_CHANGESETTINGS_FAILED);
            FmtMessageBox(hDlg,
                          MB_ICONEXCLAMATION,
                          IDS_CHANGE_SETTINGS,
                          dwMessage);
        }
        else if (iSave == DISP_CHANGE_SUCCESSFUL)
        {
            // Set the cursor to where it was before we changed the display
            // (ie, if we changed a 2ndary monitor, the cursor would have been
            // placed on the primary after the application of the change, move
            // it back to the 2ndary monitor.  If the change failed, we are
            // just placing the cursor back to it orig pos
            SetCursorPos(ptCursorSave.x, ptCursorSave.y);

            // Determine what to do based on the return code.
            if (bTest && (IDYES != DialogBoxParam(HINST_THISDLL,
                                             MAKEINTRESOURCE(DLG_KEEPNEW),
                                             GetParent(hDlg),
                                             KeepNewDlgProc, 15)))
            {
                iSave = DISP_CHANGE_NOTUPDATED;
            }
        }
    }

    // Determine what to do based on the return code.
    if (iSave >= DISP_CHANGE_SUCCESSFUL)
    {
        // Confirm the settings
        for (iDevice = 0; iDevice < numDevices; iDevice++)
        {
            rgpds[iDevice]->ConfirmChangeSettings();
        }
    }
    else
    {
        // Restore the settings to their original state
        for (iDevice = 0; iDevice < numDevices; iDevice++)
        {
            rgpds[iDevice]->RestoreSettings();
        }

        //DLI: This last function call will actually go refresh the whole desktop
        // If EnumDisplaySettings was called with EDS_RAWMODE, we need CDS_RAWMODE below.
        // Otherwise, it's harmless.
        ChangeDisplaySettings(NULL, CDS_RAWMODE);
    }

    return iSave;
}

//-----------------------------------------------------------------------------
//
// Resolution slider
//
CSettingsPage::_HandleHScroll(HWND hwndTB, int iCode, int iPos)
{
    if (_pCurDevice && _pCurDevice->pds)
    {
        int iRes = _iResolution;
        int cRes = (int)SendMessage(hwndTB, TBM_GETRANGEMAX, TRUE, 0);

        TraceMsg(TF_FUNC, "_HandleHScroll: MaxRange = %d, iRes = %d, iPos = %d", cRes, iRes, iPos);

        // Message box if something bad is going to happen ?
        //    _VerifyPrimaryMode(TRUE);

        switch (iCode)
        {
            case TB_LINEUP:
            case TB_PAGEUP:
                if (iRes != 0)
                    iRes--;
                break;

            case TB_LINEDOWN:
            case TB_PAGEDOWN:
                if (++iRes >= cRes)
                    iRes = cRes;
                break;

            case TB_BOTTOM:
                iRes = cRes;
                break;

            case TB_TOP:
                iRes = 0;
                break;

            case TB_THUMBTRACK:
            case TB_THUMBPOSITION:
                iRes = iPos;
                break;

            default:
                return FALSE;
        }

        TraceMsg(TF_FUNC, "_HandleHScroll: iRes = %d, iCode = %d", iRes, iCode);

        // We only want to automatically set the color depth for the user if they
        // changed the resolution. (not just set focus to the control)
        BOOL fAutoSetColorDepth = (_iResolution != iRes);       // iPos

        _pCurDevice->pds->SetCurResolution(_pCurDevice->ResolutionList + iRes, fAutoSetColorDepth);

        // Repaint the control in case they changed
        _UpdateUI(TRUE /*fAutoSetColorDepth*/, IDC_SCREENSIZE);

        DWORD dwExecMode;
        if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
        {
            if ( (dwExecMode == EM_NORMAL) ||
                 (dwExecMode == EM_INVALID_MODE) ||
                 (dwExecMode == EM_DETECT) ) {

                //
                // Set the apply button if resolution has changed
                //

                if (_pCurDevice->pds->bIsModeChanged())
                    SetDirty();

                return 0;
            }
        }
    }

    return TRUE;
}

void CSettingsPage::_ForwardToChildren(UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND hwndC = GetDlgItem(_hDlg, IDC_SCREENSIZE);
    if (hwndC)
        SendMessage(hwndC, message, wParam, lParam);
}

LRESULT CALLBACK CSettingsPage::WndProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR * lpnm;
    HWND hwndC;
    HWND hwndSample;
    HBITMAP hbm;

    switch (message)
    {
    case WM_NOTIFY:

        lpnm = (NMHDR FAR *)lParam;
        switch (lpnm->code)
        {
        case PSN_APPLY:
            return TRUE;
        default:
            return FALSE;
        }
        break;

    case WM_CTLCOLORSTATIC:

        if (GetDlgCtrlID((HWND)lParam) == IDC_DISPLAYDESK)
        {
            return (UINT_PTR)GetSysColorBrush(COLOR_APPWORKSPACE);
        }
        return FALSE;


    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DISPLAYPRIME:

            if (!SetPrimary(_pCurDevice))
            {
                return FALSE;
            }

            hwndC = GetCurDeviceHwnd();
            HandleMonitorChange(hwndC, TRUE);

            break;


        case IDC_DISPLAYUSEME:
            // Don't pop up warning dialog box if this display is already attached
            // or if there are already more than 1 display
            if (!_pCurDevice ||
                !SetMonAttached(_pCurDevice,
                                !_pCurDevice->pds->IsAttached(),
                                TRUE,
                                _hDlg))
            {
                return FALSE;
            }

            hwndC = GetCurDeviceHwnd();
            HandleMonitorChange(hwndC, TRUE);

            break;

        case IDC_DISPLAYLIST:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case CBN_DBLCLK:
                goto DoDeviceSettings;

            case CBN_SELCHANGE:
                UpdateActiveDisplay(NULL);
                break;

            default:
                return FALSE;
            }
            break;

        case IDC_DISPLAYPROPERTIES:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            DoDeviceSettings:
            case BN_CLICKED:
                if (IsWindowEnabled(GetDlgItem(_hDlg, IDC_DISPLAYPROPERTIES)))
                    _OnAdvancedClicked();
                break;

            default:
                return FALSE;
            }
            break;

        case IDC_COLORBOX:
            switch(GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case CBN_SELCHANGE:
                {
                    HWND hwndColorBox = GetDlgItem(_hDlg, IDC_COLORBOX);
                    int iClr = ComboBox_GetCurSel(hwndColorBox);

                    if ((iClr != CB_ERR) && _pCurDevice && _pCurDevice->pds && _pCurDevice->ColorList)
                    {
                        // Message box if something bad is going to happen ?
                        //    _VerifyPrimaryMode(TRUE);
                        _pCurDevice->pds->SetCurColor((int) *(_pCurDevice->ColorList + iClr));

                        // Repaint the control in case they changed
                        _UpdateUI(TRUE /*fAutoSetColorDepth*/, IDC_COLORBOX);
                    }

                    break;
                }
                default:
                    break;
            }

            break;

        case IDC_TROUBLESHOOT:
            // Invokes the trouble shooter for the Settings tab.
            {
                TCHAR szCommand[MAX_PATH];

                LoadString(HINST_THISDLL,IDS_TROUBLESHOOT_EXEC, szCommand, ARRAYSIZE(szCommand));
                
                // Get location of HelpCtr.exe, which is the value in the 
                // HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\HELPCTR.EXE key                
                TCHAR szHelpCtr[MAX_PATH];
                HKEY hKey = NULL;
                DWORD cbHelpCtr = sizeof(szHelpCtr);
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                 TEXT("Microsoft\\Windows\\CurrentVersion\\App Paths\\HELPCTR.EXE"),
                                 0,
                                 KEY_QUERY_VALUE,
                                 &hKey) != ERROR_SUCCESS || 
                    RegQueryValueEx(hKey, 
                                    TEXT(""), 
                                    NULL, 
                                    NULL, 
                                    (LPBYTE)szHelpCtr, 
                                    &cbHelpCtr) != ERROR_SUCCESS)
                {                    
                    StringCchCopy(szHelpCtr, ARRAYSIZE(szHelpCtr), TEXT("HelpCtr.exe"));
                }

                if (hKey)
                {
                    RegCloseKey(hKey);
                }

                HrShellExecute(_hwndDesk, NULL, szHelpCtr, szCommand, NULL, SW_NORMAL);
            }
            break;

        case IDC_IDENTIFY:
            // Flashes the Text on all the monitors simultaneously
            {
                HWND  hwndC;

                //Enumerate all the monitors and flash this for each!
                hwndC = GetWindow(_hwndDesk, GW_CHILD);
                while (hwndC)
                {
                    PostMessage(hwndC, WM_COMMAND, MAKEWPARAM(IDC_FLASH, 0), MAKELPARAM(0, 0));
                    hwndC = GetWindow(hwndC, GW_HWNDNEXT);
                }
            }
            break;

        default:
            return FALSE;
        }

        // Enable the apply button only if we are not in setup.
        DWORD dwExecMode;
        if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
        {
            if ( (dwExecMode == EM_NORMAL) ||
                 (dwExecMode == EM_INVALID_MODE) ||
                 (dwExecMode == EM_DETECT) )
            {
                // Set the apply button if something changed
                if (_pCurDevice && _pCurDevice->pds &&
                    _pCurDevice->pds->bIsModeChanged())
                {
                    SetDirty();
                }
            }
        }
        break;

    case WM_HSCROLL:
        _HandleHScroll((HWND)lParam, (int) LOWORD(wParam), (int) HIWORD(wParam));
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("display.hlp"), HELP_WM_HELP,
            (DWORD_PTR)(LPTSTR)sc_MultiMonitorHelpIds);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, TEXT("display.hlp"), HELP_CONTEXTMENU,
            (DWORD_PTR)(LPTSTR)sc_MultiMonitorHelpIds);
        break;

    case WM_DISPLAYCHANGE:
    case WM_WININICHANGE:
        _ForwardToChildren(message, wParam, lParam);
        break;

    case WM_SYSCOLORCHANGE:
        if (_himl)
            ImageList_SetBkColor(_himl, GetSysColor(COLOR_APPWORKSPACE));

        //
        // Needs to be passed to all the new common controls so they repaint
        // correctly using the new system colors
        //
        _ForwardToChildren(message, wParam, lParam);

        //
        // Rerender the monitor(s) bitmap(s) to reflect the new colors
        //
        if (_NumDevices == 1) {
            // set up bitmaps for sample screen
            if (_hbmScrSample && (GetObjectType(_hbmScrSample) != 0)) {
                DeleteObject(_hbmScrSample);
                _hbmScrSample = 0;
            }
            _hbmScrSample = LoadMonitorBitmap( TRUE ); // let them do the desktop
            SendDlgItemMessage(_hDlg, IDC_SCREENSAMPLE, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)_hbmScrSample);

            // get a base copy of the bitmap for when the "internals" change
            if (_hbmMonitor && (GetObjectType(_hbmMonitor) != 0)) {
                DeleteObject(_hbmMonitor);
                _hbmMonitor = 0;
            }
            _hbmMonitor = LoadMonitorBitmap( FALSE ); // we'll do the desktop
        }
        else if (_NumDevices > 0)
        {
            HBITMAP hbm, hbmMask;
            int cx, cy;
            UINT iDevice;
            PMULTIMON_DEVICE pDevice;
            TCHAR            ach[12];

            // replace each monitor bitmap with one with correct colors
            for (iDevice = 0; (iDevice < _NumDevices); iDevice++)
            {
                pDevice = &_Devices[iDevice];

                if (pDevice)
                {
                    _itot(iDevice+1,ach,10);
                    ImageList_GetIconSize(pDevice->himl, &cx, &cy);
                    MakeMonitorBitmap(pDevice->w,pDevice->h,ach,&hbm,&hbmMask,cx,cy, (pDevice == _pCurDevice));
                    ImageList_Replace(pDevice->himl,pDevice->iImage,hbm,hbmMask);

                    DeleteObject(hbm);
                    DeleteObject(hbmMask);
                }
            }
        }

        break;

#if 0
    //
    // NOTE:  until video supports device interfaces, we cannot use
    //        WM_DEVICECHANGE to detect video changes.  The default WM_DEVCHANGE
    //        only reports about legacy devices
    //
    case WM_DEVICECHANGE:
        //
        // Rebuild the device list if we are not currently enumerating,
        // because enumerating may cause another device to come on-line
        //
        // We only reenumerate if a new *video* device arrives
        //
        if (!_InSetInfo &&
            (wParam == DBT_DEVICEARRIVAL || wParam == DBT_DEVICEREMOVECOMPLETE))
        {
                        DEV_BROADCAST_HDR *bhdr = (DEV_BROADCAST_HDR *) lParam;

            // check for something else here, most likely the dev interface guid
                        if (bhdr->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE)
            {
                _InitDisplaySettings(FALSE);
            }
        }

        break;
#endif

    case WM_DESTROY:
        TraceMsg(TF_GENERAL, "WndProc:: WM_DESTROY");
        hwndSample = GetDlgItem(_hDlg, IDC_COLORSAMPLE);
        hbm = (HBITMAP)SendMessage(hwndSample, STM_SETIMAGE, IMAGE_BITMAP, NULL);
        if (hbm)
            DeleteObject(hbm);

        if (_NumDevices == 1)
        {
            hwndSample = GetDlgItem(_hDlg, IDC_SCREENSAMPLE);
            hbm = (HBITMAP)SendMessage(hwndSample, STM_SETIMAGE, IMAGE_BITMAP, NULL);
            if (hbm)
                DeleteObject(hbm);

            if (_hbmScrSample && (GetObjectType(_hbmScrSample) != 0))
                DeleteObject(_hbmScrSample);
            if (_hbmMonitor && (GetObjectType(_hbmMonitor) != 0))
                DeleteObject(_hbmMonitor);
        }

        _DestroyDisplaySettings();

        break;

    case MSG_DSP_SETUP_MESSAGE:
        return _InitMessage();
        // MultiMonitor CPL specific messages
    case MM_REDRAWPREVIEW:
        _RedrawDeskPreviews();
        break;

    case WM_LBUTTONDBLCLK:
        if (_NumDevices == 1)
        {
            HWND hwndSample = GetDlgItem(_hDlg, IDC_SCREENSAMPLE);
            if(NULL != hwndSample)
            {
                POINT pt;
                RECT rc;

                pt.x = GET_X_LPARAM(lParam);  // horizontal position of cursor
                pt.y = GET_Y_LPARAM(lParam);  // vertical position of cursor
                GetWindowRect(hwndSample, &rc);

                if(ClientToScreen(_hDlg, &pt) && PtInRect(&rc, pt))
                    PostMessage(_hDlg, WM_COMMAND, MAKEWPARAM(IDC_DISPLAYPROPERTIES, BN_CLICKED), (LPARAM)hwndSample);
            }

            break;
        }
        else
            return FALSE;

    default:
        return FALSE;
    }

    return TRUE;
}


// IUnknown methods
HRESULT CSettingsPage::QueryInterface(REFIID riid, LPVOID * ppvObj)
{ 
    static const QITAB qit[] = {
        QITABENT(CSettingsPage, IObjectWithSite),
        QITABENT(CSettingsPage, IPropertyBag),
        QITABENT(CSettingsPage, IBasePropPage),
        QITABENTMULTI(CSettingsPage, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CSettingsPage::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CSettingsPage::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IMultiMonConfig methods
HRESULT CSettingsPage::Initialize(HWND hwndHost, WNDPROC pfnWndProc, DWORD dwReserved)
{
    HRESULT hr = E_FAIL;

    if (hwndHost && RegisterPreviewWindowClass(pfnWndProc))
    {
        _hwndDesk = hwndHost;
        if (_InitDisplaySettings(TRUE))
            hr = S_OK;
    }
    return hr;
}

HRESULT CSettingsPage::GetNumberOfMonitors(int * pCMon, DWORD dwReserved)
{
    if (pCMon)
    {
        *pCMon = _NumDevices;
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CSettingsPage::GetMonitorData(int iMonitor, MonitorData * pmd, DWORD dwReserved)
{
    ASSERT(pmd);
    if ((pmd == NULL) || ((ULONG)iMonitor >= _NumDevices))
        return ResultFromWin32(ERROR_INVALID_PARAMETER);

    PMULTIMON_DEVICE pDevice = &_Devices[iMonitor];

    pmd->dwSize = sizeof(MonitorData);
    if ( pDevice->pds->IsPrimary() )
        pmd->dwStatus |= MD_PRIMARY;
    if ( pDevice->pds->IsAttached() )
        pmd->dwStatus |= MD_ATTACHED;
    pDevice->pds->GetCurPosition(&pmd->rcPos);

    return S_OK;
}

HRESULT CSettingsPage::Paint(int iMonitor, DWORD dwReserved)
{
    _RedrawDeskPreviews();

    return S_OK;
}


/*----------------------------------------------------------------------------
----------------------------------------------------------------------------*/
HFONT GetFont(LPRECT prc)
{
    LOGFONT lf;

    ZeroMemory(&lf, sizeof(lf));
    lf.lfWeight = FW_EXTRABOLD;
    lf.lfHeight = prc->bottom - prc->top;
    lf.lfWidth  = 0;
    lf.lfPitchAndFamily = FF_SWISS;
    lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;

    return CreateFontIndirect(&lf);
}

/*----------------------------------------------------------------------------
----------------------------------------------------------------------------*/
#define HANG_TIME 2500

LRESULT CALLBACK BigNumberWindowProc(HWND hwnd, UINT msg,WPARAM wParam,LPARAM lParam)
{
    TCHAR ach[80];
    HFONT hfont;
    RECT  rc;
    HDC   hdc;
    HRGN  hrgnTxtA;
    PAINTSTRUCT ps;
    HGDIOBJ hOldPen;
    HGDIOBJ hNewPen;

    switch (msg)
    {
    case WM_CREATE:
        break;

    case WM_SIZE:
        GetWindowText(hwnd, ach, ARRAYSIZE(ach));
        GetClientRect(hwnd, &rc);
        hfont = GetFont(&rc);

        hdc = GetDC(hwnd);
        SelectObject(hdc, hfont);

        BeginPath(hdc);
            SetBkMode(hdc, TRANSPARENT);
            TextOut(hdc,0,0,ach,lstrlen(ach));
        EndPath(hdc);

        hrgnTxtA = PathToRegion(hdc);
        SetWindowRgn(hwnd,hrgnTxtA,TRUE);

        ReleaseDC(hwnd, hdc);
        DeleteObject(hfont);
        break;

    case WM_TIMER:
        DestroyWindow(hwnd);
        return 0;

    case WM_PAINT:
        GetWindowText(hwnd, ach, ARRAYSIZE(ach));
        GetClientRect(hwnd, &rc);
        hfont = GetFont(&rc);

        if (hfont)
        {
            hdc = BeginPaint(hwnd, &ps);
            //The following paints the whole region (which is in the shape of the number) black!
            PatBlt(hdc, 0, 0, rc.right, rc.bottom, BLACKNESS | NOMIRRORBITMAP);

            SelectObject(hdc, hfont);
            SetTextColor(hdc, 0xFFFFFF);
            //Let's create a path that is the shape of the region by drawing that number.
            BeginPath(hdc);
                SetBkMode(hdc, TRANSPARENT);
                TextOut(hdc,0,0,ach,lstrlen(ach));
            EndPath(hdc);

            // The above TextOut calljust created the path. Let's now actually draw the number!
            // Note: We are drawing the number in white there by changing whatever painted as black
            // a few moments ago!
            TextOut(hdc,0,0,ach,lstrlen(ach));

            //Let's create a thick black brush to paint the borders of the number we just drew!
            hNewPen = CreatePen(PS_INSIDEFRAME, 4, 0x0); //Black Color
            if (hNewPen)
            {
                hOldPen = SelectObject(hdc, hNewPen);

                //Draw the border of the white number with the thick black brush!
                StrokePath(hdc);

                SelectObject(hdc, hOldPen);
                DeleteObject(hNewPen);
            }

            EndPaint(hwnd, &ps);
            DeleteObject(hfont);
        }
        break;
    }

    return DefWindowProc(hwnd,msg,wParam,lParam);
}

int Bail()
{
    POINT pt;
    POINT pt0;
    DWORD time0;
    DWORD d;

    d     = GetDoubleClickTime();
    time0 = GetMessageTime();
    pt0.x = (int)(short)LOWORD(GetMessagePos());
    pt0.y = (int)(short)HIWORD(GetMessagePos());

    if (GetTickCount()-time0 > d)
        return 2;

    if (!((GetAsyncKeyState(VK_LBUTTON) | GetAsyncKeyState(VK_RBUTTON)) & 0x8000))
        return 1;

    GetCursorPos(&pt);

    if ((pt.y - pt0.y) > 2 || (pt.y - pt0.y) < -2)
        return 1;

    if ((pt.x - pt0.x) > 2 || (pt.x - pt0.x) < -2)
        return 1;

    return 0;
}

void FlashText(HWND hDlg, PMULTIMON_DEVICE pDevice, LPCTSTR sz, LPRECT prc, BOOL fWait)
{
    HFONT hfont;
    SIZE  size;
    HDC   hdc;
    int   i;

    if (!pDevice->pds->IsOrgAttached())
        return;

    if (pDevice->hwndFlash && IsWindow(pDevice->hwndFlash))
    {
        DestroyWindow(pDevice->hwndFlash);
        pDevice->hwndFlash = NULL;
    }

    if (sz == NULL)
        return;

    if (fWait)
    {
        while ((i=Bail()) == 0)
            ;

        if (i == 1)
            return;
    }

    hdc = GetDC(NULL);
    hfont = GetFont(prc);
    SelectObject(hdc, hfont);
    if (!GetTextExtentPoint(hdc, sz, lstrlen(sz), &size))
    {
        size.cx = 0;
        size.cy = 0;
    }
    ReleaseDC(NULL, hdc);
    DeleteObject(hfont);

    if (!gfFlashWindowRegistered)
    {
        WNDCLASS    cls;
        cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon          = NULL;
        cls.lpszMenuName   = NULL;
        cls.lpszClassName  = TEXT("MonitorNumber32");
        cls.hbrBackground  = (HBRUSH)(COLOR_DESKTOP + 1);
        cls.hInstance      = HINST_THISDLL;
        cls.style          = CS_VREDRAW | CS_HREDRAW;
        cls.lpfnWndProc    = BigNumberWindowProc;
        cls.cbWndExtra     = 0;
        cls.cbClsExtra     = 0;

        RegisterClass(&cls);

        gfFlashWindowRegistered = TRUE;
    }

    pDevice->hwndFlash = CreateWindowEx(
        WS_EX_TOPMOST | WS_EX_TOOLWINDOW, //WS_BORDER,
        TEXT("MonitorNumber32"), sz,
        WS_POPUP,
        (prc->right  + prc->left - size.cx)/2,
        (prc->bottom + prc->top  - size.cy)/2,
        size.cx,
        size.cy,
        hDlg,   //Set the dialog as the parent sothat we get back the activation after flash window goes away!
        NULL,
        HINST_THISDLL,
        NULL);

    if (pDevice->hwndFlash)
    {
        ShowWindow(pDevice->hwndFlash, SW_SHOW);
        UpdateWindow(pDevice->hwndFlash);
        SetTimer(pDevice->hwndFlash, 1, HANG_TIME, NULL);
    }
}


void DrawMonitorNum(HDC hdc, int w, int h, LPCTSTR sz, BOOL fDrawBackground=TRUE)
{
    HFONT    hfont;
    HFONT    hfontT;
    RECT     rc;
    COLORREF rgb;
    COLORREF rgbDesk;

    SetRect(&rc, 0, 0, w, h);

    rgb     = GetSysColor(COLOR_CAPTIONTEXT);
    rgbDesk = GetSysColor(COLOR_DESKTOP);

    if (fDrawBackground)
        FillRect(hdc, &rc, GetSysColorBrush (COLOR_DESKTOP));

    InflateRect(&rc, -(MON_X*w / MON_W)>> 1, -(MON_Y*h/ MON_H));

    if (rgbDesk == rgb)
        rgb = GetSysColor(COLOR_WINDOWTEXT);

    if (rgbDesk == rgb)
        rgb = rgbDesk ^ 0x00FFFFFF;

    SetTextColor(hdc, rgb);

    hfont = GetFont(&rc);
    if (hfont)
    {
        hfontT = (HFONT)SelectObject(hdc, hfont);
        SetTextAlign(hdc, TA_CENTER | TA_TOP);
        SetBkMode(hdc, TRANSPARENT);
        ExtTextOut(hdc, (rc.left+rc.right)/2, rc.top, 0, NULL, sz, lstrlen(sz), NULL);
        SelectObject(hdc, hfontT);
        DeleteObject(hfont);
    }
}

void AddTrackingToolTip(PMULTIMON_DEVICE pDevice, HWND hwnd)
{
    TOOLINFO ti;
    TCHAR location[16];
    RECT rcPos;

    //
    // New tool Tip
    //

    pDevice->pds->GetCurPosition(&rcPos);
    StringCchPrintf(location, ARRAYSIZE(location), TEXT("%d, %d"), rcPos.left, rcPos.top);

    GetWindowRect(hwnd, &rcPos);

    ti.cbSize      = sizeof(TOOLINFO);
    ti.uFlags      = TTF_TRACK;
    ti.hwnd        = hwnd;
    ti.uId         = (UINT_PTR) pDevice;
    ti.hinst       = HINST_THISDLL;
    ti.lpszText    = location;
    ti.rect.left   = rcPos.left + 2;
    ti.rect.top    = rcPos.top + 2;
    ti.rect.right  = rcPos.right - 2;// ti.rect.left + 10;
    ti.rect.bottom = rcPos.bottom - 2; //  ti.rect.top + 10;

    ToolTip_AddTool(ghwndToolTipTracking, &ti);
    pDevice->bTracking = FALSE;

    TraceMsg(TF_GENERAL, "Added TOOLTIP hwnd %08lx, uId %08lx\n", ti.hwnd, ti.uId);
    return;
}

void RemoveTrackingToolTip(HWND hwnd)
{
    TOOLINFO ti;

    ZeroMemory(&ti, sizeof(ti));
    ti.cbSize      = sizeof(ti);
    ti.hwnd        = hwnd;
    ti.uId         = (UINT_PTR) GetDlgCtrlDevice(hwnd);

    ToolTip_DelTool(ghwndToolTipTracking, &ti);
}

BOOLEAN TrackToolTip(PMULTIMON_DEVICE pDevice, HWND hwnd, BOOL bTrack)
{
    TOOLINFO ti;
    BOOLEAN oldTracking;

    ZeroMemory(&ti, sizeof(ti));
    ti.cbSize      = sizeof(ti);
    ti.hwnd        = hwnd;
    ti.uId         = (UINT_PTR) pDevice;

    oldTracking = pDevice->bTracking;
    pDevice->bTracking = (BOOLEAN)bTrack;
    ToolTip_TrackActivate(ghwndToolTipTracking, bTrack, &ti);

    TraceMsg(TF_GENERAL, "Track TOOLTIP hwnd %08lx, uId %08lx\n", ti.hwnd, ti.uId);

    return oldTracking;
}

void AddPopupToolTip(HWND hwndC)
{
    TOOLINFO ti;

    //
    // New tool Tip
    //
    ti.cbSize      = sizeof(TOOLINFO);
    ti.uFlags      = TTF_IDISHWND | TTF_SUBCLASS | TTF_CENTERTIP;
    ti.hwnd        = hwndC;
    ti.uId         = (UINT_PTR) hwndC;
    ti.hinst       = HINST_THISDLL;
    GetWindowRect(hwndC, &ti.rect);
    ti.lpszText    = LPSTR_TEXTCALLBACK;

    ToolTip_AddTool(ghwndToolTipPopup, &ti);
}

void RemovePopupToolTip(HWND hwndC)
{
    TOOLINFO ti;

    ZeroMemory(&ti, sizeof(ti));
    ti.cbSize      = sizeof(ti);
    ti.hwnd        = hwndC;
    ti.uId         = (UINT_PTR) hwndC;

    ToolTip_DelTool(ghwndToolTipPopup, &ti);
}

BOOL MakeMonitorBitmap(int w, int h, LPCTSTR sz, HBITMAP *pBitmap, HBITMAP *pMaskBitmap, int cx, int cy, BOOL fSelected)
{
    HDC     hdc;        // work dc
    HDC     hdcS;       // screen dc

    ASSERT(w <= cx);
    ASSERT(h <= cy);

    *pBitmap = NULL;

    hdcS = GetDC(NULL);
    hdc  = CreateCompatibleDC(hdcS);
    if (hdc)
    {
        HDC     hdcT;       // another work dc

        hdcT = CreateCompatibleDC(hdcS);
        if (hdcT)
        {
            HBITMAP hbm;        // 128x128 bitmap we will return
            HBITMAP hbmT = NULL;// bitmap loaded from resource
            HBITMAP hbmM = NULL;// mask bitmap
            HDC     hdcM = NULL;// another work dc
            RECT    rc;

            if (pMaskBitmap)
                hdcM = CreateCompatibleDC(hdcS);

            hbm  = CreateCompatibleBitmap(hdcS, cx, cy);
            if (hbm)
            {
                hbmT = CreateCompatibleBitmap(hdcS, w, h);
                if(pMaskBitmap)
                    hbmM = CreateBitmap(cx,cy,1,1,NULL);
                ReleaseDC(NULL,hdcS);

                if (hbmT)
                {
                    SelectObject(hdc, hbm);
                    SelectObject(hdcT,hbmT);
                    if (pMaskBitmap && hdcM)
                        SelectObject(hdcM, hbmM);
                }
                *pBitmap = hbm;
            }

            // Make sure the color of the borders (selection & normal) is different than the background color.
            HBRUSH hbrDiff = NULL;
            BOOL bNeedDiff = ((fSelected &&
                               (GetSysColor(COLOR_APPWORKSPACE) == GetSysColor(COLOR_HIGHLIGHT))) ||
                              (GetSysColor(COLOR_APPWORKSPACE) == GetSysColor(COLOR_BTNHIGHLIGHT)));
            if(bNeedDiff)
            {
                DWORD rgbDiff = ((GetSysColor(COLOR_ACTIVEBORDER) != GetSysColor(COLOR_APPWORKSPACE))
                                    ? GetSysColor(COLOR_ACTIVEBORDER)
                                    : GetSysColor(COLOR_APPWORKSPACE) ^ 0x00FFFFFF);
                hbrDiff = CreateSolidBrush(rgbDiff);
            }

            // Fill it with the selection color or the background color.
            SetRect(&rc, 0, 0, w, h);
            FillRect(hdcT, &rc,
                     (fSelected ? ((GetSysColor(COLOR_APPWORKSPACE) != GetSysColor(COLOR_HIGHLIGHT))
                                       ? GetSysColorBrush(COLOR_HIGHLIGHT)
                                       : hbrDiff)
                                : GetSysColorBrush(COLOR_APPWORKSPACE)));

            InflateRect(&rc, -SELECTION_THICKNESS, -SELECTION_THICKNESS);
            FillRect(hdcT, &rc,
                     ((GetSysColor(COLOR_APPWORKSPACE) != GetSysColor(COLOR_BTNHIGHLIGHT))
                          ? GetSysColorBrush(COLOR_BTNHIGHLIGHT)
                          : hbrDiff));

            if (hbrDiff)
            {
                DeleteObject(hbrDiff);
                hbrDiff = NULL;
            }

            InflateRect(&rc, -MONITOR_BORDER, -MONITOR_BORDER);
            FillRect(hdcT, &rc, GetSysColorBrush(COLOR_DESKTOP));

            // fill bitmap with transparent color
            SetBkColor(hdc,GetSysColor(COLOR_APPWORKSPACE));
            SetRect(&rc, 0, 0, cx, cy);
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

            // copy bitmap to upper-left of bitmap
            BitBlt(hdc,0,0,w,h,hdcT,0,0,SRCCOPY);

            // draw the monitor number, if provided, in the bitmap (in the right place)
            if (sz)
                DrawMonitorNum(hdc, w, h, sz, FALSE);

            // make mask, if needed.
            if (pMaskBitmap && hdcM)
            {
                BitBlt(hdcM,0,0,cx,cy,hdc,0,0,SRCCOPY);
                *pMaskBitmap = hbmM;
            }

            if (hbmT)
                DeleteObject(hbmT);

            if (pMaskBitmap && hdcM)
                DeleteDC(hdcM);

            DeleteDC(hdcT);
        }
        DeleteDC(hdc);
    }

    return TRUE;
}

//
// SnapMonitorRect
//
// called while the user is moving a monitor window (WM_MOVING)
// if the CTRL key is not down we will snap the window rect
// to the edge of one of the other monitors.
//
// this is done so the user can easily align monitors
//
// NOTE pDevice->Snap must be initialized to 0,0 in WM_ENTERSIZEMOVE
//
void SnapMonitorRect(PMULTIMON_DEVICE pDevice, HWND hwnd, RECT *prc)
{
    HWND hwndT;
    int  d;
    RECT rcT;
    RECT rc;

    //
    // allow the user to move the window anywhere when the CTRL key is down
    //
    if (GetKeyState(VK_CONTROL) & 0x8000)
        return;

    //
    // macros to help in alignment
    //
    #define SNAP_DX 6
    #define SNAP_DY 6

    #define SNAPX(f,x) \
        d = rcT.x - rc.f; if (abs(d) <= SNAP_DX) rc.left+=d, rc.right+=d;

    #define SNAPY(f,y) \
        d = rcT.y - rc.f; if (abs(d) <= SNAP_DY) rc.top+=d, rc.bottom+=d;

    //
    // get current rect and offset it by the amount we have corrected
    // it so far (this alignes the rect with the position of the mouse)
    //
    rc = *prc;
    OffsetRect(&rc, pDevice->Snap.x, pDevice->Snap.y);

    //
    // walk all other windows and snap our window to them
    //
    for (hwndT = GetWindow(hwnd,  GW_HWNDFIRST); hwndT;
         hwndT = GetWindow(hwndT, GW_HWNDNEXT))
    {
        if (hwndT == hwnd)
            continue;

        GetWindowRect(hwndT, &rcT);
        InflateRect(&rcT,SNAP_DX,SNAP_DY);

        if (IntersectRect(&rcT, &rcT, &rc))
        {
            GetWindowRect(hwndT, &rcT);

            SNAPX(right,left);  SNAPY(bottom,top);
            SNAPX(right,right); SNAPY(bottom,bottom);
            SNAPX(left,left);   SNAPY(top,top);
            SNAPX(left,right);  SNAPY(top,bottom);
        }
    }

    //
    // adjust the amount we have snap'ed so far, and return the new rect
    //
    pDevice->Snap.x += prc->left - rc.left;
    pDevice->Snap.y += prc->top  - rc.top;
    *prc = rc;
}

WPARAM GetKeyStates()
{
    WPARAM wParam = 0x0;

    if (GetKeyState(VK_CONTROL) & 0x8000)
        wParam |= MK_CONTROL;
    if (GetKeyState(VK_LBUTTON) & 0x8000)
        wParam |= MK_LBUTTON;
    if (GetKeyState(VK_MBUTTON) & 0x8000)
        wParam |= MK_MBUTTON;
    if (GetKeyState(VK_RBUTTON) & 0x8000)
        wParam |= MK_RBUTTON;
    if (GetKeyState(VK_SHIFT) & 0x8000)
        wParam |= MK_SHIFT;

    return wParam;
}


LRESULT CALLBACK MonitorWindowProc(HWND hwnd, UINT msg,WPARAM wParam,LPARAM lParam)
{
    TOOLINFO ti;
    PAINTSTRUCT ps;
    HDC hdc;
    RECT rc;
    int w,h;
    TCHAR ach[80];
    PMULTIMON_DEVICE pDevice;
    HWND hDlg = GetParent(GetParent(hwnd));
    RECT rcPos;
    MSG mmsg;
    CSettingsPage * pcmm = (CSettingsPage *) GetWindowLongPtr(hwnd, 0);

    switch (msg)
    {
        case WM_CREATE:
            ASSERT(((LPCREATESTRUCT)lParam)->lpCreateParams);
            SetWindowLongPtr(hwnd, 0, (LONG_PTR)((LPCREATESTRUCT)lParam)->lpCreateParams);
            break;

        case WM_NCCREATE:
            // turn off RTL_MIRRORED_WINDOW in GWL_EXSTYLE
            SHSetWindowBits(hwnd, GWL_EXSTYLE, RTL_MIRRORED_WINDOW, 0);
            break;
        case WM_NCHITTEST:
            //
            // return HTCAPTION so that we can get the ENTERSIZEMOVE message.
            //
            pDevice = GetDlgCtrlDevice(hwnd);
            // Let disabled monitors move
            if (pDevice) // if (pDevice && pDevice->pds->IsAttached())
                return HTCAPTION;
            break;

        case WM_NCLBUTTONDBLCLK:
            FlashText(hDlg, GetDlgCtrlDevice(hwnd), NULL,NULL,FALSE);
            PostMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_DISPLAYPROPERTIES, BN_CLICKED), (LPARAM)hwnd );
            break;

        case WM_CHILDACTIVATE:
            if (GetFocus() != GetParent(hwnd)) {
                SetFocus(GetParent(hwnd));
            }
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("display.hlp"), HELP_WM_HELP,
                (DWORD_PTR)(LPTSTR)sc_MultiMonitorHelpIds);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, TEXT("display.hlp"), HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR)sc_MultiMonitorHelpIds);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDC_DISPLAYPRIME:
            case IDC_DISPLAYUSEME:
            case IDC_DISPLAYPROPERTIES:
                PostMessage(hDlg, WM_COMMAND, wParam, lParam);
                break;

            case IDC_FLASH:
                pDevice = GetDlgCtrlDevice(hwnd);

                pDevice->pds->GetOrgPosition(&rcPos);

                if (!IsRectEmpty(&rcPos))
                {
                    GetWindowText(hwnd, ach, ARRAYSIZE(ach));
                    FlashText(hDlg, pDevice, ach, &rcPos, FALSE);
                }
                break;
            }
            break;

        case WM_INITMENUPOPUP:
            pDevice = GetDlgCtrlDevice(hwnd);

            CheckMenuItem((HMENU)wParam, IDC_DISPLAYUSEME,
                          pDevice->pds->IsAttached() ? MF_CHECKED : MF_UNCHECKED);
            CheckMenuItem((HMENU)wParam, IDC_DISPLAYPRIME,
                          pDevice->pds->IsPrimary()  ? MF_CHECKED : MF_UNCHECKED);
            // until I figure out how to render on a non attached monitor, just
            // disable the menu item
            EnableMenuItem((HMENU)wParam, IDC_FLASH,
                           pDevice->pds->IsAttached() ? MF_ENABLED : MF_GRAYED);
            EnableMenuItem((HMENU)wParam, IDC_DISPLAYPROPERTIES,
                           IsWindowEnabled(GetDlgItem(GetParent(GetParent(hwnd)), IDC_DISPLAYPROPERTIES)) ?
                           MF_ENABLED : MF_GRAYED);
            EnableMenuItem((HMENU)wParam, IDC_DISPLAYUSEME,
                           pDevice->pds->IsPrimary() ? MF_GRAYED : MF_ENABLED);

            EnableMenuItem((HMENU)wParam, IDC_DISPLAYPRIME,
                           ((pDevice->pds->IsAttached() && 
                             !pDevice->pds->IsRemovable() &&
                             !pDevice->pds->IsPrimary()) ? 
                            MF_ENABLED : MF_GRAYED));

            SetMenuDefaultItem((HMENU)wParam, IDC_DISPLAYPROPERTIES, MF_BYCOMMAND);
            break;

        case WM_NCMOUSEMOVE:
            ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, NULL, WM_MOUSEMOVE, GetKeyStates(), lParam);
            break;

        case WM_NCMBUTTONDOWN:
            ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, NULL, WM_MBUTTONDOWN, GetKeyStates(), lParam);
            break;

        case WM_NCMBUTTONUP:
            ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, NULL, WM_MBUTTONUP, GetKeyStates(), lParam);
            break;

        case WM_NCRBUTTONDOWN:
            ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, NULL, WM_RBUTTONDOWN, GetKeyStates(), lParam);

            pDevice = GetDlgCtrlDevice(hwnd);

            if (pDevice && pcmm)
            {
                HMENU hmenu;
                POINT pt;

                hmenu = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(MENU_MONITOR));

                if (hmenu)
                {
                    pcmm->UpdateActiveDisplay(pDevice);
                    GetCursorPos(&pt);
                    TrackPopupMenu(GetSubMenu(hmenu,0), TPM_RIGHTBUTTON,
                        pt.x, pt.y, 0, hwnd, NULL);

                    DestroyMenu(hmenu);
                }
            }
            break;

        case WM_NCRBUTTONUP:
            ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, NULL, WM_RBUTTONUP, GetKeyStates(), lParam);
            break;

        case WM_NCLBUTTONDOWN:
            //TraceMsg(TF_FUNC, "WM_NCLBUTTONDOWN");
            // don't relay the message here because we want to keep the tool tip
            // active until they start moving the monitor.  This click might just
            // be for selection
            // ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, hDlg, WM_LBUTTONDOWN, GetKeyStates(), lParam);

            BringWindowToTop(hwnd);
            pDevice = GetDlgCtrlDevice(hwnd);

            if (pcmm)
                pcmm->UpdateActiveDisplay(pDevice);

            pDevice->pds->GetOrgPosition(&rcPos);

            if (!IsRectEmpty(&rcPos))
            {
                GetWindowText(hwnd, ach, ARRAYSIZE(ach));
                FlashText(hDlg, pDevice, ach, &rcPos, TRUE);
            }

            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
            {
            case TTN_NEEDTEXT:
                pDevice = GetDlgCtrlDevice(hwnd);
                if (pDevice->pds->IsPrimary())
                {
                    LoadString(HINST_THISDLL, IDS_PRIMARY,
                               ((LPNMTTDISPINFO)lParam)->szText,
                               ARRAYSIZE(((LPNMTTDISPINFO)lParam)->szText) );
                }
                else if (!pDevice->pds->IsAttached())
                {
                    LoadString(HINST_THISDLL, IDS_NOTATTACHED,
                               ((LPNMTTDISPINFO)lParam)->szText,
                               ARRAYSIZE(((LPNMTTDISPINFO)lParam)->szText) );
                }
                else
                {
                    TCHAR szSecondary[32];
                    LoadString(HINST_THISDLL, IDS_SECONDARY, szSecondary, ARRAYSIZE(szSecondary));
                    pDevice->pds->GetCurPosition(&rcPos);
                    StringCchPrintf(((LPNMTTDISPINFO)lParam)->szText, ARRAYSIZE(((LPNMTTDISPINFO)lParam)->szText), TEXT("%s (%d, %d)"), szSecondary, rcPos.left, rcPos.top);
                }
                break;

            default:
                break;
            }

            break;

        case WM_ENTERSIZEMOVE:
            //TraceMsg(TF_FUNC, "WM_ENTERSIZEMOVE");
            // relay a mouse up to clean the information tooltip
            ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, NULL, WM_LBUTTONDOWN, GetKeyStates(), lParam);
            pDevice = GetDlgCtrlDevice(hwnd);
            pDevice->Snap.x = 0;
            pDevice->Snap.y = 0;
            FlashText(hDlg, pDevice, NULL,NULL,FALSE);
            break;

        case WM_MOVING:
            //TraceMsg(TF_FUNC, "WM_MOVING");
            pDevice = GetDlgCtrlDevice(hwnd);

            SnapMonitorRect(pDevice, hwnd, (RECT*)lParam);
            ZeroMemory(&ti, sizeof(ti));
            ti.cbSize = sizeof(ti);

            if (!pDevice->bTracking) {
                ToolTip_TrackPosition(ghwndToolTipTracking,
                                      ((LPRECT)lParam)->left+2,
                                      ((LPRECT)lParam)->top+2);
                TrackToolTip(pDevice, hwnd, TRUE);
            }

            if (ToolTip_GetCurrentTool(ghwndToolTipTracking, &ti) && pcmm)
            {
                TCHAR location[16];
                POINT pt;

                pcmm->GetMonitorPosition(pDevice, GetParent(hwnd), &pt);
                StringCchPrintf(location, ARRAYSIZE(location), TEXT("%d, %d"), pt.x, pt.y);

                ti.lpszText    = location;
                ti.rect.left   = ((RECT*)lParam)->left + 2;
                ti.rect.top    = ((RECT*)lParam)->top + 2;
                ti.rect.right  = ti.rect.left + 10;
                ti.rect.bottom = ti.rect.top + 10;

                ToolTip_SetToolInfo(ghwndToolTipTracking, &ti);
                ToolTip_TrackPosition(ghwndToolTipTracking, ti.rect.left, ti.rect.top);
                // SendMessage(ghwndToolTip, TTM_UPDATE, 0, 0);
            }

            break;

        case WM_EXITSIZEMOVE:
            //TraceMsg(TF_FUNC, "WM_EXITSIZEMOVE");
            pDevice = GetDlgCtrlDevice(hwnd);
            TrackToolTip(pDevice, hwnd, FALSE);

            //
            // We don't want to pop up any dialogs here because the modal size
            // loop is still active (it eats any mouse movements and the dialogs
            // can't be moved by the user).
            //
            PostMessage(hwnd, MM_MONITORMOVED, 0, 0);
            break;

        case MM_MONITORMOVED:
            pDevice = GetDlgCtrlDevice(hwnd);
            if (pcmm)
            {
                //
                // If the user moved the monitor, see if they want to attach it
                //
                if (!pcmm->QueryNoAttach() && pDevice && !pDevice->pds->IsAttached())
                {
                    if (pcmm->SetMonAttached(pDevice, TRUE, FALSE, hwnd))
                    {
                        pcmm->UpdateActiveDisplay(pDevice);
                    }
                }
                pcmm->HandleMonitorChange(hwnd, FALSE);
            }

            RedrawWindow(GetParent(hwnd), NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
            return TRUE;

        case WM_DESTROY:
            FlashText(hDlg, GetDlgCtrlDevice(hwnd), NULL,NULL,FALSE);
            SetWindowLong(hwnd, 0, NULL);
            break;

        case WM_ERASEBKGND:
            //GetClientRect(hwnd, &rc);
            //FillRect((HDC)wParam, &rc, GetSysColorBrush(COLOR_APPWORKSPACE));
            return 0L;

        case WM_PAINT:

            hdc = BeginPaint(hwnd,&ps);
            GetWindowText(hwnd, ach, ARRAYSIZE(ach));
            GetClientRect(hwnd, &rc);
            w = rc.right;
            h = rc.bottom;

            pDevice = GetDlgCtrlDevice(hwnd);

            BOOL fSelected = (pcmm ? (BOOL)(pDevice == pcmm->GetCurDevice()) : FALSE);

            if (pDevice->w != w || pDevice->h != h)
            {
                HBITMAP hbm, hbmMask;
                int cx,cy;

                pDevice->w = w;
                pDevice->h = h;

                ImageList_GetIconSize(pDevice->himl, &cx, &cy);
                MakeMonitorBitmap(w,h,ach,&hbm,&hbmMask,cx,cy, fSelected);
                ImageList_Replace(pDevice->himl,pDevice->iImage,hbm,hbmMask);

                DeleteObject(hbm);
                DeleteObject(hbmMask);
            }

            if (!pDevice->pds->IsAttached())
            {
                FillRect(hdc, &rc, GetSysColorBrush(COLOR_APPWORKSPACE));

                if (pcmm && fSelected)
                {
                    ImageList_DrawEx(pDevice->himl,pDevice->iImage,hdc,0,0,w,h,
                        CLR_DEFAULT,CLR_DEFAULT,ILD_BLEND25);
                }
                else
                {
                    ImageList_DrawEx(pDevice->himl,pDevice->iImage,hdc,0,0,w,h,
                        CLR_DEFAULT,CLR_NONE,ILD_BLEND50);
                }
            }
            else
            {
                    ImageList_DrawEx(pDevice->himl,pDevice->iImage,hdc,0,0,w,h,
                        CLR_DEFAULT,CLR_DEFAULT,ILD_IMAGE);
            }

            EndPaint(hwnd,&ps);
            return 0L;
    }

    return DefWindowProc(hwnd,msg,wParam,lParam);
}

LRESULT CALLBACK SliderSubWndProc (HWND hwndSlider, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uID, ULONG_PTR dwRefData)
{
    ASSERT(uID == 0);
    ASSERT(dwRefData == 0);

    switch (uMsg)
    {
        case WM_GETOBJECT:
            if ( lParam == OBJID_CLIENT )
            {
                // At this point we will try to load oleacc and get the functions
                // we need.
                if (!g_fAttemptedOleAccLoad)
                {
                    g_fAttemptedOleAccLoad = TRUE;

                    ASSERT(s_pfnCreateStdAccessibleProxy == NULL);
                    ASSERT(s_pfnLresultFromObject == NULL);

                    g_hOleAcc = LoadLibrary(TEXT("OLEACC"));
                    if (g_hOleAcc != NULL)
                    {
                        s_pfnCreateStdAccessibleProxy = (PFNCREATESTDACCESSIBLEPROXY)
                                                    GetProcAddress(g_hOleAcc, "CreateStdAccessibleProxyW");
                        s_pfnLresultFromObject = (PFNLRESULTFROMOBJECT)
                                                    GetProcAddress(g_hOleAcc, "LresultFromObject");
                    }
                    if (s_pfnLresultFromObject == NULL || s_pfnCreateStdAccessibleProxy == NULL)
                    {
                        if (g_hOleAcc)
                        {
                            // No point holding on to Oleacc since we can't use it.
                            FreeLibrary(g_hOleAcc);
                            g_hOleAcc = NULL;
                        }
                        s_pfnLresultFromObject = NULL;
                        s_pfnCreateStdAccessibleProxy = NULL;
                    }
                }


                if (g_hOleAcc && s_pfnCreateStdAccessibleProxy && s_pfnLresultFromObject)
                {
                    IAccessible *pAcc = NULL;
                    HRESULT hr;

                    // Create default slider proxy.
                    hr = s_pfnCreateStdAccessibleProxy(
                            hwndSlider,
                            TEXT("msctls_trackbar32"),
                            OBJID_CLIENT,
                            IID_IAccessible,
                            (void **)&pAcc
                            );


                    if (SUCCEEDED(hr) && pAcc)
                    {
                        // now wrap it up in our customized wrapper...
                        IAccessible * pWrapAcc = new CAccessibleWrapper( hwndSlider, pAcc );
                        // Release our ref to proxy (wrapper has its own addref'd ptr)...
                        pAcc->Release();

                        if (pWrapAcc != NULL)
                        {

                            // ...and return the wrapper via LresultFromObject...
                            LRESULT lr = s_pfnLresultFromObject( IID_IAccessible, wParam, pWrapAcc );
                            // Release our interface pointer - OLEACC has its own addref to the object
                            pWrapAcc->Release();

                            // Return the lresult, which 'contains' a reference to our wrapper object.
                            return lr;
                            // All done!
                        }
                    // If it didn't work, fall through to default behavior instead.
                    }
                }
            }
            break;

        case WM_DESTROY:
            RemoveWindowSubclass(hwndSlider, SliderSubWndProc, uID);
            break;

    } /* end switch */

    return DefSubclassProc(hwndSlider, uMsg, wParam, lParam);
}


BOOL CSettingsPage::_AreExtraMonitorsDisabledOnPersonal(void)
{
    BOOL fIsDisabled = IsOS(OS_PERSONAL);

    if (fIsDisabled)
    {
        // POSSIBLE FUTURE REFINEMENT: Insert call to ClassicSystemParametersInfo() to see if there are video cards that we had to disable.
        fIsDisabled = FALSE;
    }

    return fIsDisabled;
}

// *** IShellPropSheetExt ***
HRESULT CSettingsPage::AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam)
{
    HRESULT hr = S_OK;

    PROPSHEETPAGE psp = {0};

    psp.dwSize = sizeof(psp);
    psp.hInstance = HINST_THISDLL;
    psp.dwFlags = PSP_DEFAULT;
    psp.lParam = (LPARAM) this;

    // GetSystemMetics(SM_CMONITORS) returns only the enabled monitors. So, we need to 
    // enumerate ourselves to determine if this is a multimonitor scenario. We have our own
    // function to do this.
    // Use the appropriate dlg template for multimonitor and single monitor configs.
    // if(ClassicGetSystemMetrics(SM_CMONITORS) > 1)
    //
    // PERF-WARNING: calling EnumDisplaySettingsEx() is a huge perf hit, so see if we can
    // findout if there is only one adapter with a cheaper call.
    DEBUG_CODE(DebugStartWatch());
    if (!_AreExtraMonitorsDisabledOnPersonal() && (ComputeNumberOfMonitorsFast(TRUE) > 1))
    {
        psp.pszTemplate = MAKEINTRESOURCE(DLG_MULTIMONITOR);
    }
    else
    {
        psp.pszTemplate = MAKEINTRESOURCE(DLG_SINGLEMONITOR);
    }
    DEBUG_CODE(TraceMsg(TF_THEMEUI_PERF, "CSettingsPage::AddPages() took Time=%lums", DebugStopWatch()));

    psp.pfnDlgProc = CSettingsPage::SettingsDlgProc;

    HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);
    if (hpsp)
    {
        if (pfnAddPage(hpsp, lParam))
        {
            hr = S_OK;
        }
        else
        {
            DestroyPropertySheetPage(hpsp);
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CSettingsPage::ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam)
{
    return E_NOTIMPL;
}

// *** IObjectWithSite ***
HRESULT CSettingsPage::SetSite(IN IUnknown * punkSite)
{
    if (_pThemeUI)
    {
        _pThemeUI->Release();
        _pThemeUI = NULL;
    }

    if (punkSite)
    {
        punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &_pThemeUI));
    }


    return CObjectWithSite::SetSite(punkSite);
}

// *** IPropertyBag ***
HRESULT CSettingsPage::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    return hr;
}


HRESULT CSettingsPage::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    return hr;
}


// *** IBasePropPage ***
HRESULT CSettingsPage::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
    if (ppAdvDialog)
    {
        *ppAdvDialog = NULL;
    }

    return E_NOTIMPL;
}


HRESULT CSettingsPage::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    if (IsDirty() && !_nInApply)
    {
        int status;

        _nInApply++;
        // Apply the settings, and enable\disable the Apply button
        // appropriatly.
        CDisplaySettings *rgpds[MONITORS_MAX];
        ULONG           iDevice;

        for (iDevice = 0; iDevice < _NumDevices; iDevice++) {
            rgpds[iDevice] = _Devices[iDevice].pds;
        }

        status = _DisplaySaveSettings(rgpds, _NumDevices, _hDlg);

        SetDirty(status < 0);

        if (status == DISP_CHANGE_RESTART)
        {
            PropSheet_RestartWindows(ghwndPropSheet);
        }
        else if (_pCurDevice && (status == DISP_CHANGE_SUCCESSFUL))
        {
            UINT iDevice;
            TCHAR szDeviceName[32];

            ASSERT(sizeof(szDeviceName) >=
                   sizeof(_pCurDevice->DisplayDevice.DeviceName));

            StringCchCopy(szDeviceName, ARRAYSIZE(szDeviceName), _pCurDevice->DisplayDevice.DeviceName);
            _InitDisplaySettings(FALSE);
            for (iDevice = 0; iDevice < _NumDevices; iDevice++)
            {
                if (lstrcmp(_Devices[iDevice].DisplayDevice.DeviceName, szDeviceName) == 0)
                {
                    UpdateActiveDisplay(_Devices + iDevice);
                    break;
                }
            }
        }
        else
        {
            // Make sure the dialog stays and redraw
            _InitDisplaySettings(FALSE);
            UpdateActiveDisplay(NULL);
            SetWindowLongPtr(_hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
        }

        _nInApply--;
    }

    return S_OK;
}


HRESULT CSettingsPage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (!punkOuter && ppvObj)
    {
        CSettingsPage * pThis = new CSettingsPage();

        *ppvObj = NULL;
        if (pThis)
        {
            hr = pThis->QueryInterface(riid, ppvObj);
            pThis->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


VOID CheckForDuplicateAppletExtensions(HKEY hkDriver)
{
    DWORD dwCheckForDuplicates = 0, cb = sizeof(DWORD), Len = 0;
    HKEY hkExtensions = (HKEY)INVALID_HANDLE_VALUE;
    PAPPEXT pAppExtTemp = NULL, pAppExt = NULL;
    PTCHAR pmszAppExt = NULL;

    if (RegQueryValueEx(hkDriver,
                        TEXT("DeskCheckForDuplicates"),
                        NULL,
                        NULL,
                        (LPBYTE)(&dwCheckForDuplicates),
                        &cb) == ERROR_SUCCESS) 
    {
        RegDeleteValue(hkDriver, TEXT("DeskCheckForDuplicates"));
    }

    if (dwCheckForDuplicates != 1) 
        return;

    if (RegOpenKeyEx(hkDriver,
                     TEXT("Display\\shellex\\PropertySheetHandlers"),
                     0,
                     KEY_READ,
                     &hkExtensions) != ERROR_SUCCESS) 
    {
        hkExtensions = (HKEY)INVALID_HANDLE_VALUE;
        goto Fallout;
    }

    DeskAESnapshot(hkExtensions, &pAppExt);
    
    if (pAppExt != NULL) 
    {
        pAppExtTemp = pAppExt;
        Len = 0;
        while (pAppExtTemp) 
        {
            Len += lstrlen(pAppExtTemp->szDefaultValue) + 1;
            pAppExtTemp = pAppExtTemp->pNext;
        }

        DWORD cchAppExt = (Len + 1);
        pmszAppExt = (PTCHAR)LocalAlloc(LPTR, cchAppExt * sizeof(TCHAR));
        if (pmszAppExt != NULL) 
        {
            pAppExtTemp = pAppExt;
            Len = 0;
            while (pAppExtTemp) 
            {
                StringCchCopy(pmszAppExt + Len, cchAppExt - Len, pAppExtTemp->szDefaultValue);
                Len += lstrlen(pAppExtTemp->szDefaultValue) + 1;
                pAppExtTemp = pAppExtTemp->pNext;
            }

            
            DeskAEDelete(REGSTR_PATH_CONTROLSFOLDER TEXT("\\Display\\shellex\\PropertySheetHandlers"),
                         pmszAppExt);
            
            DeskAEDelete(REGSTR_PATH_CONTROLSFOLDER TEXT("\\Device\\shellex\\PropertySheetHandlers"),
                         pmszAppExt);

            LocalFree(pmszAppExt);
        }

        DeskAECleanup(pAppExt);
    }

Fallout:

    if (hkExtensions != INVALID_HANDLE_VALUE)
    {
        RegCloseKey(hkExtensions);
    }
}


VOID
DeskAESnapshot(
    HKEY hkExtensions,
    PAPPEXT* ppAppExt
    )
{
    HKEY hkSubkey = 0;
    DWORD index = 0;
    DWORD ulSize = MAX_PATH;
    APPEXT AppExtTemp;
    PAPPEXT pAppExtBefore = NULL;
    PAPPEXT pAppExtTemp = NULL;

    ulSize = sizeof(AppExtTemp.szKeyName) / sizeof(TCHAR);
    while (RegEnumKeyEx(hkExtensions, 
                        index, 
                        AppExtTemp.szKeyName, 
                        &ulSize, 
                        NULL, 
                        NULL, 
                        NULL, 
                        NULL) == ERROR_SUCCESS) {

            if (RegOpenKeyEx(hkExtensions,
                             AppExtTemp.szKeyName,
                             0,
                             KEY_READ,
                             &hkSubkey) == ERROR_SUCCESS) {

                ulSize = sizeof(AppExtTemp.szDefaultValue);
                if ((RegQueryValueEx(hkSubkey,
                                     NULL,
                                     0,
                                     NULL,
                                     (PBYTE)AppExtTemp.szDefaultValue,
                                     &ulSize) == ERROR_SUCCESS) && 
                    (AppExtTemp.szDefaultValue[0] != TEXT('\0'))) {

                    PAPPEXT pAppExt = (PAPPEXT)LocalAlloc(LPTR, sizeof(APPEXT));
                    
                    if (pAppExt != NULL) {

                        *pAppExt = AppExtTemp;

                        pAppExtBefore = pAppExtTemp = *ppAppExt;
                        
                        while((pAppExtTemp != NULL) &&
                              (lstrcmpi(pAppExtTemp->szDefaultValue,
                                        pAppExt->szDefaultValue) < 0)) {

                            pAppExtBefore = pAppExtTemp;
                            pAppExtTemp = pAppExtTemp->pNext;
                        }

                        if (pAppExtBefore != pAppExtTemp) {
                        
                            pAppExt->pNext = pAppExtBefore->pNext;
                            pAppExtBefore->pNext = pAppExt;

                        } else {

                            pAppExt->pNext = *ppAppExt;
                            *ppAppExt = pAppExt;
                        }
                    }
                }

                RegCloseKey(hkSubkey);
            }

        ulSize = sizeof(AppExtTemp.szKeyName) / sizeof(TCHAR);
        index++;
    }
}


VOID
DeskAEDelete(
    PTCHAR szDeleteFrom,
    PTCHAR mszExtensionsToRemove
    )
{
    TCHAR szKeyName[MAX_PATH];
    HKEY  hkDeleteFrom, hkExt;
    DWORD cSubKeys = 0, cbSize = 0;
    TCHAR szDefaultValue[MAX_PATH];
    PTCHAR szValue;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     szDeleteFrom, 
                     0,
                     KEY_READ,
                     &hkDeleteFrom) == ERROR_SUCCESS) {

        if (RegQueryInfoKey(hkDeleteFrom, 
                            NULL,
                            NULL,
                            NULL,
                            &cSubKeys,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL) == ERROR_SUCCESS) {
        
            while (cSubKeys--) {
        
                if (RegEnumKey(hkDeleteFrom, 
                               cSubKeys, 
                               szKeyName, 
                               ARRAYSIZE(szKeyName)) == ERROR_SUCCESS) {
        
                    int iComp = -1;
        
                    if (RegOpenKeyEx(hkDeleteFrom,
                                     szKeyName,
                                     0,
                                     KEY_READ,
                                     &hkExt) == ERROR_SUCCESS) {
        
                        cbSize = sizeof(szDefaultValue);
                        if ((RegQueryValueEx(hkExt,
                                             NULL,
                                             0,
                                             NULL,
                                             (PBYTE)szDefaultValue,
                                             &cbSize) == ERROR_SUCCESS) &&
                            (szDefaultValue[0] != TEXT('\0'))) {
        
                            szValue = mszExtensionsToRemove;
        
                            while (*szValue != TEXT('\0')) {
                            
                                iComp = lstrcmpi(szDefaultValue, szValue);
        
                                if (iComp <= 0) {
                                    break;
                                }
        
                                while (*szValue != TEXT('\0')) 
                                    szValue++;

                                szValue++;
                            }
                        }
        
                        RegCloseKey(hkExt);
                    }
        
                    if (iComp == 0) {
                    
                        SHDeleteKey(hkDeleteFrom, szKeyName);
                    }
                }
            }
        }

        RegCloseKey(hkDeleteFrom);
    }
} 


VOID
DeskAECleanup(
    PAPPEXT pAppExt
    )
{
    PAPPEXT pAppExtTemp;

    while (pAppExt) {
        pAppExtTemp = pAppExt->pNext;
        LocalFree(pAppExt);
        pAppExt = pAppExtTemp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\settingspg.h ===
/*****************************************************************************\
    FILE: SettingsPg.h

    DESCRIPTION:
        This code will display a "Settings" tab in the
    "Display Properties" dialog

    BryanSt 1/05/2001    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2001. All rights reserved.
\*****************************************************************************/

#ifndef _SETTINGSPG_H
#define _SETTINGSPG_H


typedef struct
{
    BOOL fFoceSmallFont;
    IUnknown * punkSite;
} GENERAL_ADVDLG_INITPARAMS;

#endif // _SETTINGSPG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\themefile.h ===
/*****************************************************************************\
    FILE: ThemeFile.h

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_THEMEFILE
#define _FILE_H_THEMEFILE

#include <atlbase.h>


#define THEMESETTING_NORMAL         0x00000000
#define THEMESETTING_LOADINDIRECT   0x00000001

#define SIZE_CURSOR_ARRAY           15
#define SIZE_SOUNDS_ARRAY           30

typedef struct
{
    LPCTSTR pszRegKey;
    UINT nResourceID;
} THEME_FALLBACK_VALUES;


extern LPCTSTR s_pszCursorArray[SIZE_CURSOR_ARRAY];
extern THEME_FALLBACK_VALUES s_ThemeSoundsValues[SIZE_SOUNDS_ARRAY];

HRESULT CThemeFile_CreateInstance(IN LPCWSTR pszThemeFile, OUT ITheme ** ppTheme);


class CThemeFile                : public CObjectWithSite
                                , public ITheme
                                , public IPropertyBag
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** ITheme ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName);
    virtual STDMETHODIMP get_Background(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP put_Background(IN BSTR bstrPath);
    virtual STDMETHODIMP get_BackgroundTile(OUT enumBkgdTile * pnTile);
    virtual STDMETHODIMP put_BackgroundTile(IN enumBkgdTile nTile);
    virtual STDMETHODIMP get_ScreenSaver(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP put_ScreenSaver(IN BSTR bstrPath);
    virtual STDMETHODIMP get_VisualStyle(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP put_VisualStyle(IN BSTR bstrPath);
    virtual STDMETHODIMP get_VisualStyleColor(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP put_VisualStyleColor(IN BSTR bstrPath);
    virtual STDMETHODIMP get_VisualStyleSize(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP put_VisualStyleSize(IN BSTR bstrPath);

    virtual STDMETHODIMP GetPath(IN VARIANT_BOOL fExpand, OUT BSTR * pbstrPath);
    virtual STDMETHODIMP SetPath(IN BSTR bstrPath);
    virtual STDMETHODIMP GetCursor(IN BSTR bstrCursor, OUT BSTR * pbstrPath);
    virtual STDMETHODIMP SetCursor(IN BSTR bstrCursor, IN BSTR bstrPath);
    virtual STDMETHODIMP GetSound(IN BSTR bstrSoundName, OUT BSTR * pbstrPath);
    virtual STDMETHODIMP SetSound(IN BSTR bstrSoundName, IN BSTR bstrPath);
    virtual STDMETHODIMP GetIcon(IN BSTR bstrIconName, OUT BSTR * pbstrIconPath);
    virtual STDMETHODIMP SetIcon(IN BSTR bstrIconName, IN BSTR bstrIconPath);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return E_ACCESSDENIED; }


private:
    CThemeFile(LPCTSTR pszThemeFile);
    virtual ~CThemeFile(void);


    // Private Member Variables
    long                    m_cRef;

    LPTSTR                  m_pszThemeFile;
    DWORD                   m_dwCachedState;                        // Have we cached the state yet?
    SYSTEMMETRICSALL        m_systemMetrics;                        // This is the system metrics attributes in the file


    // Private Member Functions
    HRESULT _getThemeSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, DWORD dwFlags, OUT BSTR * pbstrPath);
    HRESULT _putThemeSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, BOOL fUTF7, IN LPWSTR pszPath);
    HRESULT _getIntSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, int nDefault, OUT int * pnValue);
    HRESULT _LoadLiveSettings(int * pnDPI);        // Load the settings in memory
    HRESULT _LoadSettings(void);            // Load the settings in the .theme file.
    HRESULT _ApplyThemeSettings(void);
    HRESULT _ApplySounds(void);
    HRESULT _ApplyCursors(void);
    HRESULT _ApplyWebview(void);
    HRESULT _GetSound(LPCWSTR pszSoundName, OUT BSTR * pbstrPath);
    HRESULT _SaveSystemMetrics(SYSTEMMETRICSALL * pSystemMetrics);

    HRESULT _LoadCustomFonts(void);
    HRESULT _GetCustomFont(LPCTSTR pszFontName, LOGFONT * pLogFont);
    HRESULT _getThemeSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, OUT BSTR * pbstrPath);

    BOOL _IsFiltered(IN DWORD dwFilter);

    // Friend Functions
    friend HRESULT CThemeFile_CreateInstance(IN LPCWSTR pszThemeFile, OUT ITheme ** ppTheme);
};


#endif // _FILE_H_THEMEFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\store.h ===
/*****************************************************************************\
    FILE: store.h

    DESCRIPTION:
        This file will get and set effect settings into the persisted store.
    That persisted store is the registery and in SystemParametersInfo.

    BryanSt 4/17/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _STORE_H
#define _STORE_H


#define MENU_EFFECT_FADE        1
#define MENU_EFFECT_SCROLL      2

#define FONT_SMOOTHING_MONO        0
#define FONT_SMOOTHING_AA          1
#define FONT_SMOOTHING_CT          2

#define PATH_WIN  0
#define PATH_SYS  1
#define PATH_IEXP 2

enum ICON_SIZE_TYPES {
   ICON_DEFAULT         = 0,
   ICON_LARGE           = 1,
   ICON_INDETERMINATE   = 2
};

#define ICON_DEFAULT_SMALL    16
#define ICON_DEFAULT_NORMAL   32
#define ICON_DEFAULT_LARGE    48


extern GUID CLSID_EffectsPage;



class CEffectState
{
public:
    // Private Member Variables
    int      _nLargeIcon;             // Large Icon State            (iOldLI, iNewLI)
    int      _nHighIconColor;         // High Icon Colour            (iOldHIC, iNewHIC)
    WPARAM   _wpMenuAnimation;        // Menu Animation State        (wOldMA, wNewMA)
    BOOL     _fFontSmoothing;         // Font Smoothing State        (bOldSF, bNewSF)
    DWORD    _dwFontSmoothingType;    // Font Smoothing Type         (dwOldSFT, dwNewSFT)
    BOOL     _fDragWindow;            // Drag Window State           (bOldDW, bNewDW)
    BOOL     _fKeyboardIndicators;    // Keyboard Indicators         (uOldKI, uNewKI)
    DWORD    _dwAnimationEffect;      // Animation Effect            (dwOldEffect, dwNewEffect)
    BOOL     _fMenuShadows;           // Show Menu Shadows

    // Old values (before they were dirtied)
    int      _nOldLargeIcon;             // Large Icon State            (iOldLI)
    int      _nOldHighIconColor;         // High Icon Colour            (iOldHIC)
    WPARAM   _wpOldMenuAnimation;        // Menu Animation State        (wOldMA)
    BOOL     _fOldFontSmoothing;         // Font Smoothing State        (bOldSF)
    DWORD    _dwOldFontSmoothingType;    // Font Smoothing Type         (dwOldSFT)
    BOOL     _fOldDragWindow;            // Drag Window State           (bOldDW)
    BOOL     _fOldKeyboardIndicators;    // Keyboard Indicators         (uOldKI)
    DWORD    _dwOldAnimationEffect;      // Animation Effect            (dwOldEffect)
    BOOL     _fOldMenuShadows;           // Show Menu Shadows

    // Private Member Functions
    HRESULT Load(void);
    HRESULT Save(void);
    HRESULT Clone(OUT CEffectState ** ppEffectClone);
    BOOL IsDirty(void);
    HRESULT GetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN LPWSTR pszPath, IN DWORD cchSize);
    HRESULT SetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN LPCWSTR pszPath, IN int nResourceID);

    CEffectState(void);

    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

private:

    // Private Member Variables
    long                    m_cRef;

    // Private Member Functions
    HRESULT _SaveWorkerProc(void);
    HRESULT _SaveSettings(BOOL fBroadcast);
    static DWORD CALLBACK Save_WorkerProc(void * pThis);
};




int GetBitsPerPixel(void);

extern HINSTANCE g_hmodShell32;



#endif // _STORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\stgtheme.cpp ===
/*****************************************************************************\
    FILE: stgTheme.cpp

    DESCRIPTION:
        This is the Autmation Object to theme manager object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"

extern BOOL IsUserHighContrastUser(void);

//===========================
// *** Class Internals & Helpers ***
//===========================
// lParam can be: 0 == do a case sensitive search.  1 == do a case insensitive search.
int DPA_StringCompareCB(LPVOID pvString1, LPVOID pvString2, LPARAM lParam)
{
    // return < 0 for pvPidl1 before pvPidl2.
    // return == 0 for pvPidl1 equals pvPidl2.
    // return > 0 for pvPidl1 after pvPidl2.
    int nSort = 0;      // Default to equal
    LPCTSTR pszToInsert = (LPCTSTR)pvString1;
    LPCTSTR pszToComparePath = (LPCTSTR)pvString2;

    if (pszToInsert && pszToComparePath)
    {
        LPCTSTR pszToCompareFileName = PathFindFileName(pszToComparePath);

        if (pszToCompareFileName)
        {
            nSort = StrCmp(pszToInsert, pszToCompareFileName);
        }
    }

    return nSort;
}



#define SZ_THEMES_FILTER        TEXT("*.theme")
#define SZ_ALL_FILTER           TEXT("*.*")

HRESULT CThemeManager::_AddThemesFromDir(LPCTSTR pszPath, BOOL fFirstLevel, int nInsertLoc)
{
    HRESULT hr = S_OK;
    WIN32_FIND_DATA findFileData;
    TCHAR szSearch[MAX_PATH];

    AssertMsg((nInsertLoc >= 0), TEXT("nInsertLoc should never be negative"));
    StringCchCopy(szSearch, ARRAYSIZE(szSearch), pszPath);
    PathAppend(szSearch, SZ_THEMES_FILTER);

    HANDLE hFindFiles = FindFirstFile(szSearch, &findFileData);
    if (hFindFiles && (INVALID_HANDLE_VALUE != hFindFiles))
    {
        while (hFindFiles && (INVALID_HANDLE_VALUE != hFindFiles))
        {
            if (!(FILE_ATTRIBUTE_DIRECTORY & findFileData.dwFileAttributes))
            {
                StringCchCopy(szSearch, ARRAYSIZE(szSearch), pszPath);
                if (PathAppend(szSearch, findFileData.cFileName))
                {
                    LPWSTR pszPath = StrDup(szSearch);

                    if (pszPath)
                    {
                        if (nInsertLoc)
                        {
                            if (-1 == DPA_InsertPtr(m_hdpaThemeDirs, nInsertLoc - 1, pszPath))
                            {
                                // We failed so free the memory
                                LocalFree(pszPath);
                                hr = E_OUTOFMEMORY;
                            }
                            else
                            {
                                nInsertLoc++;
                            }
                        }
                        else
                        {
                            if (-1 == DPA_SortedInsertPtr(m_hdpaThemeDirs, PathFindFileName(pszPath), 0, DPA_StringCompareCB, NULL, DPAS_INSERTBEFORE, pszPath))
                            {
                                // We failed so free the memory
                                LocalFree(pszPath);
                                hr = E_OUTOFMEMORY;
                            }
                        }
                    }
                }
                else
                {
                    hr = E_FAIL;
                    break;
                }
            }

            if (!FindNextFile(hFindFiles, &findFileData))
            {
                break;
            }
        }

        FindClose(hFindFiles);
    }

    // We only want to recurse one directory.
    if (fFirstLevel)
    {
        StringCchCopy(szSearch, ARRAYSIZE(szSearch), pszPath);
        PathAppend(szSearch, SZ_ALL_FILTER);

        HANDLE hFindFiles = FindFirstFile(szSearch, &findFileData);
        if (hFindFiles && (INVALID_HANDLE_VALUE != hFindFiles))
        {
            while (hFindFiles && (INVALID_HANDLE_VALUE != hFindFiles))
            {
                // We are looking for any directories. Of course we exclude "." and "..".
                if ((FILE_ATTRIBUTE_DIRECTORY & findFileData.dwFileAttributes) &&
                    StrCmpI(findFileData.cFileName, TEXT(".")) &&
                    StrCmpI(findFileData.cFileName, TEXT("..")))
                {
                    StringCchCopy(szSearch, ARRAYSIZE(szSearch), pszPath);
                    if (PathAppend(szSearch, findFileData.cFileName))
                    {
                        _AddThemesFromDir(szSearch, FALSE, nInsertLoc);
                    }
                    else
                    {
                        hr = E_FAIL;
                        break;
                    }
                }

                if (!FindNextFile(hFindFiles, &findFileData))
                {
                    break;
                }
            }

            FindClose(hFindFiles);
        }
    }

    // We will want to repeat this process recursively for directories.  At least
    // one level of recursively.

    return hr;
}


HRESULT CThemeManager::_InitThemeDirs(void)
{
    HRESULT hr = S_OK;

    if (!m_hdpaThemeDirs)
    {
        if (SHRegGetBoolUSValue(SZ_THEMES, SZ_REGVALUE_ENABLEPLUSTHEMES, FALSE, TRUE))
        {
            m_hdpaThemeDirs = DPA_Create(2);
            if (m_hdpaThemeDirs)
            {
                TCHAR szPath[MAX_PATH];

                // The follwoing directories can contain themes:
                //   Plus!98 Install Path\Themes
                //   Plus!95 Install Path\Themes
                //   Kids for Plus! Install Path\Themes
                //   Program Files\Plus!\Themes
                if (SUCCEEDED(GetPlusThemeDir(szPath, ARRAYSIZE(szPath))))
                {
                    _AddThemesFromDir(szPath, TRUE, 0);
                }

                hr = SHGetResourcePath(TRUE, szPath, ARRAYSIZE(szPath));
                if (SUCCEEDED(hr))
                {
                    _AddThemesFromDir(szPath, TRUE, 1);
                }

                if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_APPDATA, TRUE))
                {
                    if (PathAppend(szPath, TEXT("Microsoft\\Windows\\Themes")))
                    {
                        _AddThemesFromDir(szPath, TRUE, 1);
                    }
                }

                if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_PERSONAL, TRUE))
                {
                    _AddThemesFromDir(szPath, TRUE, 1);
                }

                // Enum any paths 3rd parties add to the registry
                HKEY hKey;
                if (SUCCEEDED(HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_THEMES_THEMEDIRS, 0, KEY_READ, &hKey)))
                {
                    for (int nDirIndex = 0; SUCCEEDED(hr); nDirIndex++)
                    {
                        TCHAR szValueName[MAXIMUM_VALUE_NAME_LENGTH];
                        DWORD cchSize = ARRAYSIZE(szValueName);
                        DWORD dwType;
                        DWORD cbSize = sizeof(szPath);

                        hr = HrRegEnumValue(hKey, nDirIndex, szValueName, &cchSize, 0, &dwType, (LPBYTE)szPath, &cbSize);
                        if (SUCCEEDED(hr))
                        {
                            TCHAR szFinalPath[MAX_PATH];

                            if (0 == SHExpandEnvironmentStringsForUserW(NULL, szPath, szFinalPath, ARRAYSIZE(szFinalPath)))
                            {
                                StringCchCopy(szFinalPath, ARRAYSIZE(szFinalPath), szPath);
                            }
                            _AddThemesFromDir(szFinalPath, TRUE, 1);
                        }
                    }

                    hr = S_OK;
                    RegCloseKey(hKey);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}


#define SZ_THEMES                       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Themes")
#define SZ_REGVALUE_REQUIRESIGNING      TEXT("Require VisualStyle Signing")

HRESULT CThemeManager::_EnumSkinCB(THEMECALLBACK tcbType, LPCWSTR pszFileName, OPTIONAL LPCWSTR pszDisplayName, OPTIONAL LPCWSTR pszToolTip, OPTIONAL int iIndex)
{
    HRESULT hr = S_OK;

    // only signed theme files will be enumerated and passed to this function

    if (pszFileName)
    {
        LPWSTR pszPath = StrDup(pszFileName);

        AssertMsg((NULL != m_hdpaSkinDirs), TEXT("We should never hit this.  We will leak.  -BryanSt"));
        if (pszPath)
        {
            if (-1 == DPA_AppendPtr(m_hdpaSkinDirs, pszPath))
            {
                // We failed so free the memory
                LocalFree(pszPath);
            }
        }
    }

    return hr;
}


BOOL CThemeManager::EnumSkinCB(THEMECALLBACK tcbType, LPCWSTR pszFileName, OPTIONAL LPCWSTR pszDisplayName, 
    OPTIONAL LPCWSTR pszToolTip, OPTIONAL int iIndex, LPARAM lParam)
{
    CThemeManager * pThis = (CThemeManager *) lParam;
    HRESULT hr = E_FAIL;

    if (pThis)
    {
        hr = pThis->_EnumSkinCB(tcbType, pszFileName, pszDisplayName, pszToolTip, iIndex);
    }

    return SUCCEEDED(hr);
}


HRESULT CThemeManager::_EnumSkinsFromKey(HKEY hKey)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];

    for (int nDirIndex = 0; SUCCEEDED(hr); nDirIndex++)
    {
        TCHAR szValueName[MAXIMUM_VALUE_NAME_LENGTH];
        DWORD cchSize = ARRAYSIZE(szValueName);
        DWORD dwType;
        DWORD cbSize = sizeof(szPath);

        hr = HrRegEnumValue(hKey, nDirIndex, szValueName, &cchSize, 0, &dwType, (LPBYTE)szPath, &cbSize);
        if (SUCCEEDED(hr))
        {
            hr = ExpandResourceDir(szPath, ARRAYSIZE(szPath));
            if (SUCCEEDED(hr))
            {
                hr = EnumThemes(szPath, CThemeManager::EnumSkinCB, (LPARAM) this);
                LogStatus("EnumThemes(path=\"%ls\") returned %#08lx in CThemeManager::_EnumSkinsFromKey.\r\n", szPath, hr);
            }
        }
    }

    return S_OK;
}



HRESULT CThemeManager::_InitSkinDirs(void)
{
    HRESULT hr = S_OK;

    if (!m_hdpaSkinDirs)
    {
        m_hdpaSkinDirs = DPA_Create(2);
        if (m_hdpaSkinDirs)
        {
            // We only want to add skins if they are supported.  They are only supported if the VisualStyle manager
            // can run.  We will know that if QueryThemeServices() returns QTS_GLOBALAVAILABLE.
            BOOL fVisualStylesSupported = (QueryThemeServicesWrap() & QTS_AVAILABLE);
            LogStatus("QueryThemeServices() returned %hs in CThemeManager::_InitSkinDirs\r\n", (fVisualStylesSupported ? "TRUE" : "FALSE"));

            // Note that the VisualStyle's Manager API only works when explorer is running.  This means we will
            // lack functionality, but it is their limitation, not ours.
            if (fVisualStylesSupported)
            {
                HKEY hNewKey;

                if (SUCCEEDED(HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_THEMES_MSTHEMEDIRS, 0, KEY_READ, &hNewKey)))
                {
                    hr = _EnumSkinsFromKey(hNewKey);
                    RegCloseKey(hNewKey);
                }

                if (SUCCEEDED(HrRegOpenKeyEx(HKEY_CURRENT_USER, SZ_THEMES_MSTHEMEDIRS, 0, KEY_READ, &hNewKey)))
                {
                    hr = _EnumSkinsFromKey(hNewKey);
                    RegCloseKey(hNewKey);
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}



HRESULT CThemeManager::_InitSelectedThemeFile(void)
{
    HRESULT hr = E_INVALIDARG;

    if (!_pszSelectTheme)
    {
        WCHAR szPath[MAX_PATH];

        DWORD dwError = SHRegGetPathW(HKEY_CURRENT_USER, SZ_REGKEY_CURRENT_THEME, NULL, szPath, 0);
        hr = HRESULT_FROM_WIN32(dwError);

        // Is this the "<UserName>'s Custom Theme" item?
        // Or did it fail?  If it failed, then no theme is selected.
        if (SUCCEEDED(hr))
        {
            Str_SetPtr(&_pszSelectTheme, szPath);
            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CThemeManager::_SetSelectedThemeEntree(LPCWSTR pszPath)
{
    HRESULT hr = E_INVALIDARG;

    Str_SetPtr(&_pszSelectTheme, pszPath);
    if (pszPath)
    {
        hr = HrRegSetPath(HKEY_CURRENT_USER, SZ_REGKEY_CURRENT_THEME, NULL, TRUE, pszPath);
    }
    else
    {
        hr = HrRegDeleteValue(HKEY_CURRENT_USER, SZ_REGKEY_CURRENT_THEME, NULL);
    }

    return hr;
}




//===========================
// *** IThemeManager Interface ***
//===========================
HRESULT CThemeManager::get_SelectedTheme(OUT ITheme ** ppTheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppTheme)
    {
        *ppTheme = NULL;

        // In the future, we may want to call into PPID_Theme's IPropertyBag
        // to find the current visual style.  This will factor in "(Modified)"
        // themes.
        hr = _InitSelectedThemeFile();
        if (SUCCEEDED(hr))
        {
            hr = CThemeFile_CreateInstance(_pszSelectTheme, ppTheme);
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        Don't forget that this change is not applied until ::ApplyNow() is
    called.
\*****************************************************************************/
HRESULT CThemeManager::put_SelectedTheme(IN ITheme * pTheme)
{
    HRESULT hr = E_INVALIDARG;

    CComBSTR bstrPath;

    if (pTheme)
    {
        // Persist the filename to the registry.
        hr = pTheme->GetPath(VARIANT_TRUE, &bstrPath);
    }

    if (SUCCEEDED(hr))
    {
        IPropertyBag * pPropertyBag;

        hr = _GetPropertyBagByCLSID(&PPID_Theme, &pPropertyBag);
        if (SUCCEEDED(hr))
        {
            hr = SHPropertyBag_WriteStr(pPropertyBag, SZ_PBPROP_THEME_LOADTHEME, bstrPath);
            pPropertyBag->Release();
        }
    }

    return hr;
}


HRESULT CThemeManager::get_WebviewCSS(OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pbstrPath)
    {
        *pbstrPath = NULL;

        IThemeScheme * pThemeScheme;

        hr = _saveGetSelectedScheme(&pThemeScheme);
        if (SUCCEEDED(hr))
        {
            IThemeStyle * pThemeStyle;

            hr = pThemeScheme->get_SelectedStyle(&pThemeStyle);
            if (SUCCEEDED(hr))
            {
                IThemeSize * pThemeSize;

                hr = pThemeStyle->get_SelectedSize(&pThemeSize);
                if (SUCCEEDED(hr))
                {
                    hr = pThemeSize->get_WebviewCSS(pbstrPath);

                    pThemeSize->Release();
                }

                pThemeStyle->Release();
            }

            pThemeScheme->Release();
        }
    }

    return hr;
}


HRESULT CThemeManager::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pnLength)
    {
        *pnLength = 0;

        hr = _InitThemeDirs();
        if (SUCCEEDED(hr))
        {
            if (m_hdpaThemeDirs)
            {
                *pnLength += DPA_GetPtrCount(m_hdpaThemeDirs);
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::get_item(IN VARIANT varIndex, OUT ITheme ** ppTheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppTheme)
    {
        *ppTheme = NULL;

        long nCount = 0;

        hr = E_INVALIDARG;
        get_length(&nCount);

        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
            varIndex = *(varIndex.pvarVal);

        switch (varIndex.vt)
        {
        case VT_I2:
            varIndex.lVal = (long)varIndex.iVal;
            // And fall through...

        case VT_I4:
            if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount))
            {
                if (m_hdpaThemeDirs)
                {
                    LPWSTR pszFilename = (LPWSTR) DPA_GetPtr(m_hdpaThemeDirs, varIndex.lVal);

                    if (pszFilename)
                    {
                        hr = CThemeFile_CreateInstance(pszFilename, ppTheme);
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    AssertMsg(0, TEXT("This should have been initiailized by get_Length(). -BryanSt"));
                    hr = E_FAIL;
                }
            }
        break;
        case VT_BSTR:
        if (varIndex.bstrVal)
        {
            hr = CThemeFile_CreateInstance(varIndex.bstrVal, ppTheme);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

        default:
            hr = E_NOTIMPL;
        }
    }
    return hr;
}


HRESULT CThemeManager::get_SelectedScheme(OUT IThemeScheme ** ppThemeScheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeScheme)
    {
        *ppThemeScheme = NULL;

        if (!_pThemeSchemeSelected)
        {
            hr = _saveGetSelectedScheme(&_pThemeSchemeSelected);
        }

        if (_pThemeSchemeSelected)
        {
            IUnknown_Set((IUnknown **) ppThemeScheme, _pThemeSchemeSelected);
            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CThemeManager::_saveGetSelectedScheme(OUT IThemeScheme ** ppThemeScheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeScheme)
    {
        *ppThemeScheme = NULL;
        BOOL fIsThemeActive = IsThemeActive();

        LogStatus("IsThemeActive() returned %hs in CThemeManager::_saveGetSelectedScheme.\r\n", (fIsThemeActive ? "TRUE" : "FALSE"));

        // The selected Scheme can either be a legacy "Appearance Scheme" or
        // a selected ".msstyles" (skin) file.
        if (fIsThemeActive)
        {
            WCHAR szPath[MAX_PATH];

            hr = GetCurrentThemeName(szPath, ARRAYSIZE(szPath), NULL, 0, NULL, 0);
            LogStatus("GetCurrentThemeName(path=\"%ls\", color=\"%ls\", size=\"%ls\") returned %#08lx in CThemeManager::_saveGetSelectedScheme.\r\n", szPath, TEXT("NULL"), TEXT("NULL"), hr);
            if (SUCCEEDED(hr))
            {
                hr = CSkinScheme_CreateInstance(szPath, ppThemeScheme);
            }

            // Currently, we create this object and get the size
            // in order to force an upgrade in case it's neccessary.
            IThemeScheme * pThemeSchemeTemp;
            if (SUCCEEDED(CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, &pThemeSchemeTemp))))
            {
                long nLength;

                pThemeSchemeTemp->get_length(&nLength);
                pThemeSchemeTemp->Release();
            }
        }

        // We want to get the Appearance scheme if no visual style is selected (i.e. IsThemeActive() returns FALSE).
        // However, if uxtheme gets confused, IsThemeActive() will return TRUE but GetCurrentThemeName() will fail.
        // in that case, we want to also fallback to the classic visual style so the UI is usable.
        if (FAILED(hr))
        {
            // The "Control Panel\\Appearance","Current" key will indicate the selected
            // Appearance Scheme.
            hr = CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, ppThemeScheme));
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        Don't forget that this change is not applied until ::ApplyNow() is
    called.
\*****************************************************************************/
HRESULT CThemeManager::put_SelectedScheme(IN IThemeScheme * pThemeScheme)
{
    HRESULT hr;

    if (pThemeScheme)
    {
        CComBSTR bstrPath;
        IThemeStyle * pThemeStyle;

        IUnknown_Set((IUnknown **) &_pThemeSchemeSelected, pThemeScheme);

        pThemeScheme->get_Path(&bstrPath);      // It's fine if it returns NULL or empty str.
        hr = pThemeScheme->get_SelectedStyle(&pThemeStyle);
        if (SUCCEEDED(hr))
        {
            CComBSTR bstrStyle;

            hr = pThemeStyle->get_Name(&bstrStyle);
            if (SUCCEEDED(hr))
            {
                IThemeSize * pThemeSize;

                hr = pThemeStyle->get_SelectedSize(&pThemeSize);
                if (SUCCEEDED(hr))
                {
                    CComBSTR bstrSize;

                    hr = pThemeSize->get_Name(&bstrSize);
                    if (SUCCEEDED(hr))
                    {
                        VARIANT variant;

                        variant.vt = VT_BSTR;
                        variant.bstrVal = bstrPath;
                        hr = Write(SZ_PBPROP_VISUALSTYLE_PATH, &variant);
                        if (SUCCEEDED(hr))
                        {
                            variant.bstrVal = bstrStyle;
                            hr = Write(SZ_PBPROP_VISUALSTYLE_COLOR, &variant);
                            if (SUCCEEDED(hr))
                            {
                                variant.bstrVal = bstrSize;
                                hr = Write(SZ_PBPROP_VISUALSTYLE_SIZE, &variant);
                            }
                        }
                    }

                    pThemeSize->Release();
                }
            }

            pThemeStyle->Release();
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}


HRESULT CThemeManager::get_schemeLength(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pnLength)
    {
        *pnLength = 1;

        hr = _InitSkinDirs();
        if (SUCCEEDED(hr))
        {
            if (m_hdpaSkinDirs)
            {
                *pnLength += DPA_GetPtrCount(m_hdpaSkinDirs);
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::get_schemeItem(IN VARIANT varIndex, OUT IThemeScheme ** ppThemeScheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeScheme)
    {
        long nCount = 0;

        hr = E_INVALIDARG;
        get_schemeLength(&nCount);
        *ppThemeScheme = NULL;

        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
            varIndex = *(varIndex.pvarVal);

        switch (varIndex.vt)
        {
        case VT_I2:
            varIndex.lVal = (long)varIndex.iVal;
            // And fall through...

        case VT_I4:
            if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount))
            {
                if (0 == varIndex.lVal)
                {
                    // 0 is the Appearance scheme, which means there isn't a skin.
                    // This is the same as the legacy Appeanance tab.
                    hr = CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, ppThemeScheme));
                }
                else
                {
                    if (m_hdpaSkinDirs)
                    {
                        LPWSTR pszFilename = (LPWSTR) DPA_GetPtr(m_hdpaSkinDirs, varIndex.lVal-1);

                        if (pszFilename)
                        {
                            hr = CSkinScheme_CreateInstance(pszFilename, ppThemeScheme);
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        AssertMsg(0, TEXT("This should have been initiailized by get_schemeLength(). -BryanSt"));
                        hr = E_FAIL;
                    }
                }
            }
        break;
        case VT_BSTR:
        if (varIndex.bstrVal && varIndex.bstrVal[0] &&
            !StrCmpI(PathFindExtension(varIndex.bstrVal), TEXT(".msstyles")))
        {
            hr = CSkinScheme_CreateInstance(varIndex.bstrVal, ppThemeScheme);
        }
        else
        {
            hr = CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, ppThemeScheme));
        }
        break;

        default:
            hr = E_NOTIMPL;
        }
    }

    return hr;
}


HRESULT CThemeManager::GetSelectedSchemeProperty(IN BSTR bstrName, OUT BSTR * pbstrValue)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrName && pbstrValue)
    {
        *pbstrValue = NULL;

        TCHAR szPath[MAX_PATH];
        TCHAR szColor[MAX_PATH];
        TCHAR szSize[MAX_PATH];
        BOOL fIsThemeActive = IsThemeActive();

        LogStatus("IsThemeActive() returned %hs in CThemeManager::GetSelectedSchemeProperty.\r\n", (fIsThemeActive ? "TRUE" : "FALSE"));


        szPath[0] = 0;
        szColor[0] = 0;
        szSize[0] = 0;
        if (fIsThemeActive)
        {
            hr = GetCurrentThemeName(szPath, ARRAYSIZE(szPath), szColor, ARRAYSIZE(szColor),
                                     szSize, ARRAYSIZE(szSize));
            LogStatus("GetCurrentThemeName() returned %#08lx in CThemeManager::GetSelectedSchemeProperty.\r\n", hr);
        }

        if (SUCCEEDED(hr))
        {
            if (!StrCmpI(bstrName, SZ_CSP_PATH))
            {
                PathRemoveFileSpec(szPath);
                hr = HrSysAllocString(szPath, pbstrValue);
            }
            else if (!StrCmpI(bstrName, SZ_CSP_FILE))
            {
                hr = HrSysAllocString(szPath, pbstrValue);
            }
            else if (!StrCmpI(bstrName, SZ_CSP_DISPLAYNAME))
            {
                if (szPath[0])
                {
                    hr = GetThemeDocumentationProperty(szPath, SZ_THDOCPROP_DISPLAYNAME, szPath, ARRAYSIZE(szPath));
                    LogStatus("GetThemeDocumentationProperty() returned %#08lx in CThemeManager::GetSelectedSchemeProperty.\r\n", hr);
                }

                if (SUCCEEDED(hr))
                {
                    hr = HrSysAllocString(szPath, pbstrValue);
                }
            }
            else if (!StrCmpI(bstrName, SZ_CSP_CANONICALNAME))
            {
                if (szPath[0])
                {
                    hr = GetThemeDocumentationProperty(szPath, SZ_THDOCPROP_CANONICALNAME, szPath, ARRAYSIZE(szPath));
                    LogStatus("GetThemeDocumentationProperty() returned %#08lx in CThemeManager::GetSelectedSchemeProperty.\r\n", hr);
                }

                if (SUCCEEDED(hr))
                {
                    hr = HrSysAllocString(szPath, pbstrValue);
                }
            }
            else if (!StrCmpI(bstrName, SZ_CSP_COLOR))
            {
                hr = HrSysAllocString(szColor, pbstrValue);
            }
            else if (!StrCmpI(bstrName, SZ_CSP_SIZE))
            {
                hr = HrSysAllocString(szSize, pbstrValue);
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::GetSpecialTheme(IN BSTR bstrName, OUT ITheme ** ppTheme)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrName && ppTheme)
    {
        *ppTheme = NULL;

        if (!StrCmpI(SZ_STDEFAULTTHEME, bstrName))
        {
            TCHAR szPath[MAX_PATH];
        
            hr = HrRegGetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, szPath, ARRAYSIZE(szPath));
            if (SUCCEEDED(hr))
            {
                ExpandResourceDir(szPath, ARRAYSIZE(szPath));
                hr = CThemeFile_CreateInstance(szPath, ppTheme);
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::SetSpecialTheme(IN BSTR bstrName, IN ITheme * pTheme)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrName)
    {
        if (!StrCmpI(SZ_STDEFAULTTHEME, bstrName))
        {
            CComBSTR bstrPath;

            if (pTheme)
            {
                hr = pTheme->GetPath(VARIANT_TRUE, &bstrPath);
            }
            else
            {
                bstrPath = L"";     // This means use "Windows Classic".
            }

            if (bstrPath)
            {
                hr = HrRegSetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, TRUE, bstrPath);
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::GetSpecialScheme(IN BSTR bstrName, OUT IThemeScheme ** ppThemeScheme, OUT IThemeStyle ** ppThemeStyle, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrName && ppThemeScheme && ppThemeStyle && ppThemeSize)
    {
        *ppThemeScheme = NULL;
        *ppThemeStyle = NULL;
        *ppThemeSize = NULL;

        TCHAR szVisualStylePath[MAX_PATH];
        DWORD dwType;
        DWORD cbSize = sizeof(szVisualStylePath);

        // Is a SetVisualStyle policy is set, don't honor this call
        if (ERROR_SUCCESS == SHRegGetUSValue(SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_POLICY_SETVISUALSTYLE, &dwType, (void *) szVisualStylePath, &cbSize, FALSE, NULL, 0)
            || IsUserHighContrastUser())
        {
            hr = E_ACCESSDENIED; // Don't mess with visual styles when SetVisualStyle is enforced or high contrast is on
        } 
        else
        {
            if (!StrCmpI(SZ_SSDEFAULVISUALSTYLEON, bstrName) ||
                !StrCmpI(SZ_SSDEFAULVISUALSTYLEOFF, bstrName))
            {
                TCHAR szRegKey[MAX_PATH];
                TCHAR szVisualStyle[MAX_PATH];

                StringCchPrintf(szRegKey, ARRAYSIZE(szRegKey), TEXT("%s\\%s"), SZ_THEMES, bstrName);
                hr = HrRegGetPath(HKEY_CURRENT_USER, szRegKey, SZ_REGVALUE_INSTALL_VISUALSTYLE, szVisualStyle, ARRAYSIZE(szVisualStyle));
                if (SUCCEEDED(hr))
                {
                    TCHAR szColorStyle[MAX_PATH];

                    ExpandResourceDir(szVisualStyle, ARRAYSIZE(szVisualStyle));
                    hr = HrRegGetValueString(HKEY_CURRENT_USER, szRegKey, SZ_REGVALUE_INSTALL_VSCOLOR, szColorStyle, ARRAYSIZE(szColorStyle));
                    if (SUCCEEDED(hr))
                    {
                        TCHAR szSize[MAX_PATH];

                        hr = HrRegGetValueString(HKEY_CURRENT_USER, szRegKey, SZ_REGVALUE_INSTALL_VSSIZE, szSize, ARRAYSIZE(szSize));
                        if (SUCCEEDED(hr))
                        {
                            CComVariant varIndex(szVisualStyle);

                            hr = get_schemeItem(varIndex, ppThemeScheme);
                            if (SUCCEEDED(hr))
                            {
                                CComVariant varColorIndex(szColorStyle);

                                hr = (*ppThemeScheme)->get_item(varColorIndex, ppThemeStyle);
                                if (SUCCEEDED(hr))
                                {
                                    CComVariant varSizeIndex(szSize);

                                    hr = (*ppThemeStyle)->get_item(varSizeIndex, ppThemeSize);
                                }
                            }
                        }
                    }
                }

                if (FAILED(hr))
                {
                    // Return consistent results.
                    ATOMICRELEASE(*ppThemeScheme);
                    ATOMICRELEASE(*ppThemeStyle);
                    ATOMICRELEASE(*ppThemeSize);
                }
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::SetSpecialScheme(IN BSTR bstrName, IN IThemeScheme * pThemeScheme, IThemeStyle * pThemeStyle, IThemeSize * pThemeSize)
{
    return E_NOTIMPL;
}


HRESULT CThemeManager::ApplyNow(void)
{
    return ApplyPressed(TUIAP_NONE | TUIAP_WAITFORAPPLY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\store.cpp ===
//---------------------------------------------------------------------------
//
//  File: plustab.cpp
//
//  Main Implementation of the Effects page
//
//---------------------------------------------------------------------------


#include "priv.h"
#pragma hdrstop

#include "shlwapip.h"
#include "shlguidp.h"
#include "EffectsAdvPg.h"
#include "store.h"
#include "regutil.h"

// OLE-Registry magic number
GUID CLSID_EffectsPage = { 0x41e300e0, 0x78b6, 0x11ce,{0x84, 0x9b, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00}};

#define SPI_GETKEYBOARDINDICATORS SPI_GETMENUUNDERLINES//0x100A
#define SPI_SETKEYBOARDINDICATORS SPI_SETMENUUNDERLINES//0x100B

#define SPI_GETFONTCLEARTYPE      116
#define SPI_SETFONTCLEARTYPE      117

// Handle to the DLL
extern HINSTANCE g_hInst;

// vars needed for new shell api
#define SZ_SHELL32                  TEXT("shell32.dll")
#define SZ_SHUPDATERECYCLEBINICON   "SHUpdateRecycleBinIcon"    // Parameter for GetProcAddr()... DO NOT TEXT("") IT!

typedef void (* PFNSHUPDATERECYCLEBINICON)( void );

int GetBitsPerPixel(void)
{
    int iBitsPerPixel = 8;
    HDC hDC = GetDC(NULL);

    if (hDC)
    {
        iBitsPerPixel = GetDeviceCaps(hDC, BITSPIXEL);
        ReleaseDC(NULL, hDC);
    }

    return iBitsPerPixel;
}

int GetIconState(void)
{
    BOOL bRet;
    int iSize;

    bRet = GetRegValueInt(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONSIZE, &iSize);
    if (bRet == FALSE)
        return ICON_DEFAULT;

    if (iSize == ICON_DEFAULT_NORMAL)
        return ICON_DEFAULT;
    else if (iSize == ICON_DEFAULT_LARGE)
        return ICON_LARGE;
    return ICON_INDETERMINATE;
}


BOOL ChangeIconSizes(int iOldState, int iNewState)
{
    BOOL bRet;
    int  iOldSize, iNewSize;
    int  iHorz;
    int  iVert;

    // Don't bother if nothing changed
    if (iOldState == iNewState)
        return FALSE;

    // Get New Size
    switch (iNewState)
        {
        case ICON_DEFAULT:
            iNewSize = ICON_DEFAULT_NORMAL;
            break;

        case ICON_LARGE:
            iNewSize = ICON_DEFAULT_LARGE;
            break;

        case ICON_INDETERMINATE:
            // Don't bother to change anything
            return FALSE;

        default:
            return FALSE;
        }

    // Get Original Size
    bRet = GetRegValueInt(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONSIZE, &iOldSize);
    if (!bRet)
    {
        // Try geting system default instead
        iOldSize = ClassicGetSystemMetrics(SM_CXICON);
    }

    // Don't need to change size if nothing has really changed
    if (iNewSize == iOldSize)
        return FALSE;

    // Get new horizontal spacing
    iHorz = ClassicGetSystemMetrics(SM_CXICONSPACING);
    iHorz -= iOldSize;
    if (iHorz < 0)
    {
        iHorz = 0;
    }
    iHorz += iNewSize;

    // Get new vertical spacing
    iVert = ClassicGetSystemMetrics(SM_CYICONSPACING);
    iVert -= iOldSize;
    if (iVert < 0)
    {
        iVert = 0;
    }
    iVert += iNewSize;

        // Set New sizes and spacing
    bRet = SetRegValueInt(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONSIZE, iNewSize);
    if (!bRet)
        return FALSE;

    // We don't need to call the Async version because this function is called on a background thread.
    ClassicSystemParametersInfo(SPI_ICONHORIZONTALSPACING, iHorz, NULL, (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE));
    ClassicSystemParametersInfo(SPI_ICONVERTICALSPACING, iVert, NULL, (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE));

    // We need to do this in order to force DefView to update.
    // BUG:194437
    ICONMETRICS iconMetrics;
    iconMetrics.cbSize = sizeof(iconMetrics);
    ClassicSystemParametersInfo(SPI_GETICONMETRICS, sizeof(iconMetrics), &iconMetrics, 0);
    ClassicSystemParametersInfo(SPI_SETICONMETRICS, sizeof(iconMetrics), &iconMetrics, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);

    // We did change the sizes
    return TRUE;
}


//
//  GetAnimations
//
//  Get current state of animations (windows / menus / etc.).
//
WPARAM GetAnimations(DWORD *pdwEffect)
{
    BOOL fMenu = FALSE, fWindow = FALSE, fCombo = FALSE, fSmooth = FALSE, fList = FALSE, fFade = FALSE;
    ANIMATIONINFO ai;

    ai.cbSize = sizeof(ai);
    if (ClassicSystemParametersInfo(SPI_GETANIMATION, sizeof(ai), (PVOID)&ai, 0 ))
    {
        fWindow = (ai.iMinAnimate) ? TRUE : FALSE;
    }

    ClassicSystemParametersInfo(SPI_GETCOMBOBOXANIMATION, 0, (PVOID)&fCombo, 0 );
    ClassicSystemParametersInfo(SPI_GETLISTBOXSMOOTHSCROLLING, 0, (PVOID)&fList, 0 );
    ClassicSystemParametersInfo(SPI_GETMENUANIMATION, 0, (PVOID)&fMenu, 0 );
    fSmooth = GetRegValueDword(HKEY_CURRENT_USER, SZ_REGKEY_CPDESKTOP, SZ_REGVALUE_SMOOTHSCROLL);

    if (fSmooth == REG_BAD_DWORD)
    {
        fSmooth = 1;
    }
    
    ClassicSystemParametersInfo(SPI_GETMENUFADE, 0, (PVOID)&fFade, 0 );
    *pdwEffect = (fFade ? MENU_EFFECT_FADE : MENU_EFFECT_SCROLL);
    
    if (fMenu && fWindow && fCombo && fSmooth && fList)
        return BST_CHECKED;

    if ((!fMenu) && (!fWindow) && (!fCombo) && (!fSmooth) && (!fList))
        return BST_UNCHECKED;

    return BST_INDETERMINATE;
}

//
//  SetAnimations
//
//  Set animations according (windows / menus / etc.) according to flag.
//
void SetAnimations(WPARAM wVal, DWORD dwEffect, DWORD dwBroadcast)
{
    if (!IsTSPerfFlagEnabled(TSPerFlag_NoAnimation))
    {
        ANIMATIONINFO ai;

        // Note, if the checkbox is indeterminate, we treat it like it was checked.
        // We should never get this far if the user didn't change something so this should be okay.
        BOOL bVal = (wVal == BST_UNCHECKED) ? 0 : 1;
        BOOL bEfx = (dwEffect == MENU_EFFECT_FADE) ? 1 : 0;
        
        ai.cbSize = sizeof(ai);
        ai.iMinAnimate = bVal;
        ClassicSystemParametersInfo(SPI_SETANIMATION, sizeof(ai), (PVOID)&ai, dwBroadcast);
        ClassicSystemParametersInfo(SPI_SETCOMBOBOXANIMATION, 0, IntToPtr(bVal), dwBroadcast);
        ClassicSystemParametersInfo(SPI_SETLISTBOXSMOOTHSCROLLING, 0, IntToPtr(bVal), dwBroadcast);
        ClassicSystemParametersInfo(SPI_SETMENUANIMATION, 0, IntToPtr(bVal), dwBroadcast);
        ClassicSystemParametersInfo(SPI_SETTOOLTIPANIMATION, 0, IntToPtr(bVal), dwBroadcast);
        SetRegValueDword(HKEY_CURRENT_USER, SZ_REGKEY_CPDESKTOP, SZ_REGVALUE_SMOOTHSCROLL, bVal);

        ClassicSystemParametersInfo(SPI_SETMENUFADE, 0, IntToPtr(bEfx), dwBroadcast);
        ClassicSystemParametersInfo(SPI_SETTOOLTIPFADE, 0, IntToPtr(bEfx), dwBroadcast);
        ClassicSystemParametersInfo(SPI_SETSELECTIONFADE, 0, bVal ? IntToPtr(bEfx) : 0, dwBroadcast);
    }
}

CEffectState::CEffectState() : m_cRef(1)
{
}


HRESULT CEffectState::Load(void)
{
    HRESULT hr = S_OK;

    // Get the values for the settings from the registry and set the checkboxes
    // Large Icons
    _nLargeIcon = GetIconState();

    // Full Color Icons
    if(FALSE == GetRegValueInt(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONCOLORDEPTH, &_nHighIconColor)) // Key not in registry yet
    {
        _nHighIconColor = 4;
    }

    // Use animations
    _wpMenuAnimation = GetAnimations(&_dwAnimationEffect);
    
    // Smooth edges of screen fonts
    _fFontSmoothing = FALSE;
    ClassicSystemParametersInfo(SPI_GETFONTSMOOTHING, 0, (PVOID)&_fFontSmoothing, 0);

    _dwFontSmoothingType = FONT_SMOOTHING_AA;
    if (ClassicSystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, (PVOID)&_dwFontSmoothingType, 0)) 
    {
    }

    if (FONT_SMOOTHING_MONO == _dwFontSmoothingType)
    {
        _dwFontSmoothingType = FONT_SMOOTHING_AA;
    }

    // Show contents while dragging
    _fDragWindow = FALSE;
    ClassicSystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, (PVOID)&_fDragWindow, 0);

    _fKeyboardIndicators = FALSE;
    ClassicSystemParametersInfo(SPI_GETKEYBOARDINDICATORS, 0, (PVOID)&_fKeyboardIndicators, 0);

    _fMenuShadows = TRUE;
    ClassicSystemParametersInfo(SPI_GETDROPSHADOW, 0, (PVOID)&_fMenuShadows, 0);

    // Set the old values so we know when they changed.
    _nOldLargeIcon = _nLargeIcon;
    _nOldHighIconColor = _nHighIconColor;
    _wpOldMenuAnimation = _wpMenuAnimation;
    _fOldFontSmoothing = _fFontSmoothing;
    _dwOldFontSmoothingType = _dwFontSmoothingType;
    _fOldDragWindow = _fDragWindow;
    _fOldKeyboardIndicators = _fKeyboardIndicators;
    _dwOldAnimationEffect = _dwAnimationEffect;
    _fOldMenuShadows = _fMenuShadows;

    return hr;
}


HRESULT CEffectState::Save(void)
{
    // ClassicSystemParametersInfo() will hang if a top level window is hung (#162570) and USER will not fix that bug.
    // Therefore, we need to make that API call on a background thread because we need to
    // be more rebust than to hang.
    AddRef();
    SPICreateThread(Save_WorkerProc, (void *)this);
    return S_OK;
}


DWORD CEffectState::Save_WorkerProc(void * pvThis)
{
    CEffectState * pThis = (CEffectState *) pvThis;

    if (pThis)
    {
        pThis->_SaveWorkerProc();
    }

    return 0;
}


HRESULT CEffectState::_SaveWorkerProc(void)
{
    HRESULT hr = S_OK;

    // First pass to persist the settings.
    hr = _SaveSettings(FALSE);
    if (SUCCEEDED(hr))
    {
        // Second pass to broadcast the change.  This may hang if apps are hung.
        // This pass may only make it half way thru before it aborts.  In some cases
        // it's only given 30 seconds to do it's work.  If no apps are hung, that should be
        // fine.  This is cancelled after a period of time because we need this process to go
        // away, or the Display CPL will not open again if the user launches it again.
        hr = _SaveSettings(TRUE);
    }

    Release();
    return hr;
}


// POSSIBLE FUTURE PERF REFINEMENT:
// We could optimize this by checking if we have more than 5 or so
// broadcasts to make.  Then don't send the broadcasts on SystemParametersInfo()
// but instead with WM_WININICHANGE with 0,0.  This may reduce flicker.
HRESULT CEffectState::_SaveSettings(BOOL fBroadcast)
{
    HRESULT hr = S_OK;
    BOOL bDorked = FALSE;
    DWORD dwUpdateFlags = (fBroadcast ? (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE) : SPIF_UPDATEINIFILE);
    BOOL bSendSettingsChange = FALSE;

    // Full Color Icons
    if(_nOldHighIconColor != _nHighIconColor)
    {
        SetRegValueInt(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONCOLORDEPTH, _nHighIconColor);
        if ((GetBitsPerPixel() < 16) && (_nHighIconColor == 16)) // Display mode won't support icon high colors
        {
        }
        else
        {
           _nOldHighIconColor = _nHighIconColor;
           bSendSettingsChange = TRUE;
        }
    }

    // Full window drag
    if (_fOldDragWindow != _fDragWindow)
    {
        if (fBroadcast)
        {
            _fOldDragWindow = _fDragWindow;
        }

        if (!IsTSPerfFlagEnabled(TSPerFlag_NoWindowDrag))
        {
            ClassicSystemParametersInfo(SPI_SETDRAGFULLWINDOWS, _fDragWindow, 0, dwUpdateFlags);
        }

        // we need to send this because the tray's autohide switches off this
        bSendSettingsChange = TRUE;
    }

    // Show Menu Shadows
    if (_fOldMenuShadows != _fMenuShadows)
    {
        if (fBroadcast)
        {
            _fOldMenuShadows = _fMenuShadows;
        }
        ClassicSystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(_fMenuShadows), dwUpdateFlags);
        // we need to send this because the tray's autohide switches off this
        PostMessageBroadAsync(WM_SETTINGCHANGE, 0, 0);

        bSendSettingsChange = TRUE;
    }

    // Font smoothing
    if ((_fOldFontSmoothing != _fFontSmoothing) || (_dwOldFontSmoothingType != _dwFontSmoothingType))
    {
        if (!_fFontSmoothing)
        {
            // #168059: If font smoothing is off, we need to set SPI_SETFONTSMOOTHINGTYPE to xxx
            // Otherwise, it will still use ClearType.
            _dwFontSmoothingType = FONT_SMOOTHING_MONO;
        }

        ClassicSystemParametersInfo(SPI_SETFONTSMOOTHINGTYPE, 0, (PVOID)UlongToPtr(_dwFontSmoothingType), dwUpdateFlags);

        if (fBroadcast)
        {
            _dwOldFontSmoothingType = _dwFontSmoothingType;
            _fOldFontSmoothing = _fFontSmoothing;
        }

        ClassicSystemParametersInfo(SPI_SETFONTSMOOTHING, _fFontSmoothing, 0, dwUpdateFlags);
        if (fBroadcast)
        {
            // Now have the windows repaint with the change.  Whistler #179531
            RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ERASENOW | RDW_UPDATENOW | RDW_ALLCHILDREN);
        }
    }

    // Menu animations
    if ((_wpOldMenuAnimation != _wpMenuAnimation) || (_dwOldAnimationEffect != _dwAnimationEffect))
    {
        if (fBroadcast)
        {
            _wpOldMenuAnimation = _wpMenuAnimation;
        }
        SetAnimations(_wpMenuAnimation, _dwAnimationEffect, dwUpdateFlags);

        if (fBroadcast)
        {
            _dwOldAnimationEffect = _dwAnimationEffect;
        }
    }

    // Keyboard indicators
    if (_fOldKeyboardIndicators != _fKeyboardIndicators)
    {
        if (fBroadcast)
        {
            _fOldKeyboardIndicators = _fKeyboardIndicators;
        }

        // Are we turning this on? (!_fKeyboardIndicators means "don't show" -> hide)
        if (!_fKeyboardIndicators)
        {
            // Yes, on: hide the key cues, turn on the mechanism
            ClassicSystemParametersInfo(SPI_SETKEYBOARDINDICATORS, 0, IntToPtr(_fKeyboardIndicators), dwUpdateFlags);
            PostMessageBroadAsync(WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);
        }
        else
        {
            // No, off: means show the keycues, turn off the mechanism
            PostMessageBroadAsync(WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);

            ClassicSystemParametersInfo(SPI_SETKEYBOARDINDICATORS, 0, IntToPtr(_fKeyboardIndicators), dwUpdateFlags);
        }
    }

    // Large Icons
    bSendSettingsChange = ChangeIconSizes(_nOldLargeIcon, _nLargeIcon);
    if (bSendSettingsChange)
    {
        if (fBroadcast)
        {
            _nOldLargeIcon = _nLargeIcon;
        }
        bDorked = TRUE;
    }

    // Make the system notice we changed the system icons
    if (bDorked)
    {
        PFNSHUPDATERECYCLEBINICON pfnSHUpdateRecycleBinIcon = NULL;
        SHChangeNotify(SHCNE_ASSOCCHANGED, 0, NULL, NULL); // should do the trick!

        // Load SHUpdateRecycleBinIcon() if it exists
        HINSTANCE hmodShell32 = LoadLibrary(SZ_SHELL32);

        if (hmodShell32)
        {
            pfnSHUpdateRecycleBinIcon = (PFNSHUPDATERECYCLEBINICON)GetProcAddress(hmodShell32, SZ_SHUPDATERECYCLEBINICON);
            if (pfnSHUpdateRecycleBinIcon != NULL)
            {
                pfnSHUpdateRecycleBinIcon();
            }
            FreeLibrary(hmodShell32);
        }
    }

    if (bSendSettingsChange)
    {
        // We post this message because if an app is hung or slow, we don't want to hang.
        PostMessageBroadAsync(WM_SETTINGCHANGE, 0, 0);
    }

    return hr;
}


HRESULT CEffectState::Clone(OUT CEffectState ** ppEffectClone)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppEffectClone = new CEffectState();
    if (*ppEffectClone)
    {
        hr = S_OK;

        (*ppEffectClone)->_nLargeIcon = _nLargeIcon;
        (*ppEffectClone)->_nHighIconColor = _nHighIconColor;
        (*ppEffectClone)->_wpMenuAnimation = _wpMenuAnimation;
        (*ppEffectClone)->_fFontSmoothing = _fFontSmoothing;
        (*ppEffectClone)->_dwFontSmoothingType = _dwFontSmoothingType;
        (*ppEffectClone)->_fDragWindow = _fDragWindow;
        (*ppEffectClone)->_fKeyboardIndicators = _fKeyboardIndicators;
        (*ppEffectClone)->_dwAnimationEffect = _dwAnimationEffect;
        (*ppEffectClone)->_fMenuShadows = _fMenuShadows;

        (*ppEffectClone)->_nOldLargeIcon = _nOldLargeIcon;
        (*ppEffectClone)->_nOldHighIconColor = _nOldHighIconColor;
        (*ppEffectClone)->_wpOldMenuAnimation = _wpOldMenuAnimation;
        (*ppEffectClone)->_fOldFontSmoothing = _fOldFontSmoothing;
        (*ppEffectClone)->_dwOldFontSmoothingType = _dwOldFontSmoothingType;
        (*ppEffectClone)->_fOldDragWindow = _fOldDragWindow;
        (*ppEffectClone)->_fOldKeyboardIndicators = _fOldKeyboardIndicators;
        (*ppEffectClone)->_dwOldAnimationEffect = _dwOldAnimationEffect;
        (*ppEffectClone)->_fOldMenuShadows = _fOldMenuShadows;
    }

    return hr;
}



BOOL CEffectState::IsDirty(void)
{
    BOOL fDirty = FALSE;

    if ((_nLargeIcon != _nOldLargeIcon) ||
        (_nHighIconColor != _nOldHighIconColor) ||
        (_wpMenuAnimation != _wpOldMenuAnimation) ||
        (_fFontSmoothing != _fOldFontSmoothing) ||
        (_dwFontSmoothingType != _dwOldFontSmoothingType) ||
        (_fDragWindow != _fOldDragWindow) ||
        (_fMenuShadows != _fOldMenuShadows) ||
        (_fKeyboardIndicators != _fOldKeyboardIndicators) ||
        (_dwAnimationEffect != _dwOldAnimationEffect))
    {
        fDirty = TRUE;
    }

    return fDirty;
}



ULONG CEffectState::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CEffectState::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\themefile.cpp ===
/*****************************************************************************\
    FILE: ThemeFile.cpp

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>
#include <mmsystem.h>
#include "ThSettingsPg.h"
#include "ThemeFile.h"



LPCTSTR s_pszCursorArray[SIZE_CURSOR_ARRAY] =
{   // different cursors
   TEXT("Arrow"),
   TEXT("Help"),
   TEXT("AppStarting"),
   TEXT("Wait"),
   TEXT("NWPen"),
   TEXT("No"),
   TEXT("SizeNS"),
   TEXT("SizeWE"),
   TEXT("Crosshair"),
   TEXT("IBeam"),
   TEXT("SizeNWSE"),
   TEXT("SizeNESW"),
   TEXT("SizeAll"),
   TEXT("UpArrow"),
   TEXT("Link"),
};


// This is a list of string pairs.  The first string in the pair is the RegKey and the second is the default sound.
// NULL means to delete the key.  If you use an environment string other than "%SystemRoot%", you need to
// update _ApplySounds();
#define SOUND_DEFAULT    (UINT)-1

THEME_FALLBACK_VALUES s_ThemeSoundsValues[SIZE_SOUNDS_ARRAY] =
{
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\.Default\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\AppGPFault\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Close\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\DeviceConnect\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\DeviceDisconnect\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\DeviceFail\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\LowBatteryAlarm\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\MailBeep\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Maximize\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\MenuCommand\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\MenuPopup\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Minimize\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Open\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\PrintComplete\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\RestoreDown\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\RestoreUp\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\RingIn\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Ringout\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemAsterisk\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemExclamation\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemExit\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemHand\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemNotification\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemQuestion\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemStart\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemStartMenu\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\WindowsLogoff\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\WindowsLogon\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\Explorer\\EmptyRecycleBin\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\Explorer\\Navigating\\.Current"), SOUND_DEFAULT},
};



//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CThemeFile::_GetCustomFont(LPCTSTR pszFontName, LOGFONT * pLogFont)
{
    HRESULT hr = S_OK;
    TCHAR szFont[MAX_PATH];
    
    if (GetPrivateProfileString(SZ_INISECTION_METRICS, pszFontName, SZ_EMPTY, szFont, ARRAYSIZE(szFont), m_pszThemeFile))
    {
        if (TEXT('@') == szFont[0])     // Is the string indirect for MUI?
        {
            TCHAR szTemp[MAX_PATH];

            if (SUCCEEDED(SHLoadIndirectString(szFont, szTemp, ARRAYSIZE(szTemp), NULL)))
            {
                StringCchCopy(szFont, ARRAYSIZE(szFont), szTemp);
            }
        }

        if (TEXT('{') == szFont[0])
        {
            LPTSTR pszStart = &szFont[1];
            BOOL fHasMore = TRUE;

            LPTSTR pszEnd = StrChr(pszStart, TEXT(','));
            if (!pszEnd)
            {
                pszEnd = StrChr(pszStart, TEXT('}'));
                fHasMore = FALSE;
            }

            if (pszEnd)
            {
                pszEnd[0] = 0;  // Terminate Name.

                StringCchCopy(pLogFont->lfFaceName, ARRAYSIZE(pLogFont->lfFaceName), pszStart);
                if (fHasMore)
                {
                    pszStart = &pszEnd[1];
                    pszEnd = StrStr(pszStart, TEXT("pt"));
                    if (pszEnd)
                    {
                        TCHAR szTemp[MAX_PATH];

                        pszEnd[0] = 0;  // Terminate Name.
                        pszEnd += 2;    // Skip past the "pt"

                        StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszStart);
                        PathRemoveBlanks(szTemp);

                        pLogFont->lfHeight = -MulDiv(StrToInt(szTemp), DPI_PERSISTED, 72);      // Map pt size to lfHeight
                        pLogFont->lfHeight = min(-3, pLogFont->lfHeight);        // Make sure the font doesn't get too small
                        pLogFont->lfHeight = max(-100, pLogFont->lfHeight);      // Make sure the font doesn't get too large
                        if (TEXT(',') == pszEnd[0])
                        {
                            pszStart = &pszEnd[1];
                            pszEnd = StrChr(pszStart, TEXT('}'));
                            if (pszEnd)
                            {
                                pszEnd[0] = 0;  // Terminate Name.
                
                                pLogFont->lfCharSet = (BYTE) StrToInt(pszStart);
                            }
                        }
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CThemeFile::_LoadCustomFonts(void)
{
    _GetCustomFont(TEXT("CaptionFont"), &(m_systemMetrics.schemeData.ncm.lfCaptionFont));
    _GetCustomFont(TEXT("SmCaptionFont"), &(m_systemMetrics.schemeData.ncm.lfSmCaptionFont));
    _GetCustomFont(TEXT("MenuFont"), &(m_systemMetrics.schemeData.ncm.lfMenuFont));
    _GetCustomFont(TEXT("StatusFont"), &(m_systemMetrics.schemeData.ncm.lfStatusFont));
    _GetCustomFont(TEXT("MessageFont"), &(m_systemMetrics.schemeData.ncm.lfMessageFont));
    _GetCustomFont(TEXT("IconFont"), &(m_systemMetrics.schemeData.lfIconTitle));

    return S_OK;
}


// Load the settings in memory
HRESULT CThemeFile::_LoadLiveSettings(int * pnDPI)
{
    HRESULT hr = S_OK;

    if (m_pszThemeFile)
    {
        if (pnDPI)
        {
            *pnDPI = DPI_PERSISTED;
        }

        // Get property bag with default settings.
        if (_punkSite)
        {
            IPropertyBag * pPropertyBag;

            hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                hr = SHPropertyBag_ReadByRef(pPropertyBag, SZ_PBPROP_SYSTEM_METRICS, (void *)&m_systemMetrics, sizeof(m_systemMetrics));

                if (pnDPI && FAILED(SHPropertyBag_ReadInt(pPropertyBag, SZ_PBPROP_DPI_MODIFIED_VALUE, pnDPI)))
                {
                    *pnDPI = DPI_PERSISTED;    // Default to the default DPI.
                }
                pPropertyBag->Release();
            }
        }
    }

    return hr;
}


// Load the settings in the .theme file.
HRESULT CThemeFile::_LoadSettings(void)
{
    int nCurrentDPI = DPI_PERSISTED;
    HRESULT hr = _LoadLiveSettings(&nCurrentDPI);

    if (m_pszThemeFile)
    {
        BOOL fFontsFilter = _IsFiltered(THEMEFILTER_SMSTYLES);
        TCHAR szIconMetrics[2048];

        if (m_systemMetrics.nIcon && m_systemMetrics.nSmallIcon)
        {
            ////////////////////////////////////////////
            // Get the icon Metrics

            // if we somehow come up with no icon metrics in the theme, just
            // PUNT and leave cur settings
            if (GetPrivateProfileString(SZ_INISECTION_METRICS, SZ_INIKEY_ICONMETRICS, SZ_EMPTY, szIconMetrics, ARRAYSIZE(szIconMetrics), m_pszThemeFile))
            {                   // if something there to set
                ICONMETRICSA iconMetricsA;

                // translate stored data string to ICONMETRICS bytes
                if ((sizeof(iconMetricsA) == WriteBytesToBuffer(szIconMetrics, (void *)&iconMetricsA, sizeof(iconMetricsA))) &&  // char str read from and binary bytes
                    (sizeof(iconMetricsA) == iconMetricsA.cbSize))
                {
                    // ICONMETRICS are stored in ANSI format in the Theme file so if
                    // we're living in a UNICODE world we need to convert from ANSI
                    // to UNICODE
                    ICONMETRICSW iconMetricsW;

                    if (!fFontsFilter)
                    {
                        ConvertIconMetricsToWIDE(&iconMetricsA, &iconMetricsW);
                        m_systemMetrics.schemeData.lfIconTitle = iconMetricsW.lfFont;
                    }
                }
            }


            ////////////////////////////////////////////
            // Get Non-Client Metrics

            // if we somehow come up with no icon metrics in the theme, just
            // PUNT and leave cur settings
            if (GetPrivateProfileString(SZ_INISECTION_METRICS, SZ_INIKEY_NONCLIENTMETRICS, SZ_EMPTY, szIconMetrics, ARRAYSIZE(szIconMetrics), m_pszThemeFile))
            {
                BOOL fBordersFilter = _IsFiltered(THEMEFILTER_SMSIZES);
                NONCLIENTMETRICSA nonClientMetrics;

                // if something there to set
                // translate stored data string to ICONMETRICS bytes
                if ((sizeof(nonClientMetrics) == WriteBytesToBuffer(szIconMetrics, (void *)&nonClientMetrics, sizeof(nonClientMetrics))) &&  // char str read from and binary bytes
                    (sizeof(nonClientMetrics) == nonClientMetrics.cbSize))
                {
                    // ICONMETRICS are stored in ANSI format in the Theme file so if
                    // we're living in a UNICODE world we need to convert from ANSI
                    // to UNICODE
                    NONCLIENTMETRICSW nonClientMetricsW = {0};

                    ConvertNCMetricsToWIDE(&nonClientMetrics, &nonClientMetricsW);
                    nonClientMetricsW.cbSize = sizeof(nonClientMetricsW); // paranoid

                    // what we reset if the user checks Font names and styles
                    if (!fFontsFilter)
                    {
                        // only (some) font information
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfCaptionFont), &(nonClientMetricsW.lfCaptionFont), TFC_STYLE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfSmCaptionFont), &(nonClientMetricsW.lfSmCaptionFont), TFC_STYLE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfMenuFont), &(nonClientMetricsW.lfMenuFont), TFC_STYLE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfStatusFont), &(nonClientMetricsW.lfStatusFont), TFC_STYLE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfMessageFont), &(nonClientMetricsW.lfMessageFont), TFC_STYLE);
                    }

                    // what we reset if the user checks Font and window si&zes
                    if (!fBordersFilter)
                    {
                        // fonts
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfCaptionFont), &(nonClientMetricsW.lfCaptionFont), TFC_SIZE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfSmCaptionFont), &(nonClientMetricsW.lfSmCaptionFont), TFC_SIZE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfMenuFont), &(nonClientMetricsW.lfMenuFont), TFC_SIZE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfStatusFont), &(nonClientMetricsW.lfStatusFont), TFC_SIZE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfMessageFont), &(nonClientMetricsW.lfMessageFont), TFC_SIZE);

                        // Since we are copying the font sizes, scale them to the current DPI.
                        // window elements sizes
                        m_systemMetrics.schemeData.ncm.iBorderWidth = nonClientMetricsW.iBorderWidth;
                        m_systemMetrics.schemeData.ncm.iScrollWidth = nonClientMetricsW.iScrollWidth;
                        m_systemMetrics.schemeData.ncm.iScrollHeight = nonClientMetricsW.iScrollHeight;
                        m_systemMetrics.schemeData.ncm.iCaptionWidth = nonClientMetricsW.iCaptionWidth;
                        m_systemMetrics.schemeData.ncm.iCaptionHeight = nonClientMetricsW.iCaptionHeight;
                        m_systemMetrics.schemeData.ncm.iSmCaptionWidth = nonClientMetricsW.iSmCaptionWidth;
                        m_systemMetrics.schemeData.ncm.iSmCaptionHeight = nonClientMetricsW.iSmCaptionHeight;
                        m_systemMetrics.schemeData.ncm.iMenuWidth = nonClientMetricsW.iMenuWidth;
                        m_systemMetrics.schemeData.ncm.iMenuHeight = nonClientMetricsW.iMenuHeight;

                        // Local custom fonts
                        _LoadCustomFonts();

                        if (nCurrentDPI != DPI_PERSISTED)
                        {
                            LogSystemMetrics("CThemeFile::_LoadSettings() BEFORE Loading from .theme", &m_systemMetrics);
                            DPIConvert_SystemMetricsAll(TRUE, &m_systemMetrics, DPI_PERSISTED, nCurrentDPI);
                            LogSystemMetrics("CThemeFile::_LoadSettings() AFTER Loading from .theme", &m_systemMetrics);
                        }

                        // CHARSET: In Win2k, fontfix.cpp was used as a hack to change the CHARSET from one language to another.
                        // That doesn't work for many reasons: a) not called on roaming, b) not called for OS lang changes, 
                        // c) won't fix the problem for strings with multiple languages, d) etc.
                        // Therefore, the SHELL team (BryanSt) had the NTUSER team (MSadek) agree to use DEFAULT_CHARSET all the time.
                        // If some app has bad logic testing the charset parameter, then the NTUSER team will shim that app to fix it.
                        // The shim would be really simple, on the return from a SystemParametersInfo(SPI_GETNONCLIENTMETRICS or ICONFONTS)
                        // just patch the lfCharSet param to the current charset.

                        // For all CHARSETs to DEFAULT_CHARSET
                        m_systemMetrics.schemeData.ncm.lfCaptionFont.lfCharSet = DEFAULT_CHARSET;
                        m_systemMetrics.schemeData.ncm.lfSmCaptionFont.lfCharSet = DEFAULT_CHARSET;
                        m_systemMetrics.schemeData.ncm.lfMenuFont.lfCharSet = DEFAULT_CHARSET;
                        m_systemMetrics.schemeData.ncm.lfStatusFont.lfCharSet = DEFAULT_CHARSET;
                        m_systemMetrics.schemeData.ncm.lfMessageFont.lfCharSet = DEFAULT_CHARSET;
                        m_systemMetrics.schemeData.lfIconTitle.lfCharSet = DEFAULT_CHARSET;
                    }
                }
            }


            ////////////////////////////////////////////
            // Get Colors
            BOOL fGrad = FALSE;         // Are gradient captions enabled?
            int nIndex;
            BOOL fColorFilter = _IsFiltered(THEMEFILTER_COLORS);

            ClassicSystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, (LPVOID)&fGrad, 0);    // Init fGrad
            if (!fColorFilter)
            {
                for (nIndex = 0; nIndex < ARRAYSIZE(s_pszColorNames); nIndex++)
                {
                    TCHAR szColor[MAX_PATH];

                    // get string from theme
                    if (!GetPrivateProfileString(SZ_INISECTION_COLORS, s_pszColorNames[nIndex], SZ_EMPTY, szColor, ARRAYSIZE(szColor), m_pszThemeFile))
                    {
                        if ((nIndex == COLOR_GRADIENTACTIVECAPTION) && !szColor[0])
                        {
                            // They didn't specify the COLOR_GRADIENTACTIVECAPTION color, so use COLOR_ACTIVECAPTION
                            GetPrivateProfileString(SZ_INISECTION_COLORS, s_pszColorNames[COLOR_ACTIVECAPTION], SZ_EMPTY, szColor, ARRAYSIZE(szColor), m_pszThemeFile);
                        }
                        if ((nIndex == COLOR_GRADIENTINACTIVECAPTION) && !szColor[0])
                        {
                            // They didn't specify the COLOR_GRADIENTINACTIVECAPTION color, so use COLOR_INACTIVECAPTION
                            GetPrivateProfileString(SZ_INISECTION_COLORS, s_pszColorNames[COLOR_INACTIVECAPTION], SZ_EMPTY, szColor, ARRAYSIZE(szColor), m_pszThemeFile);
                        }
                    }

                    if (szColor[0])
                    {
                        m_systemMetrics.schemeData.rgb[nIndex] = RGBStringToColor(szColor);
                    }
                }
            }
        }
        else
        {
            AssertMsg((NULL != _punkSite), TEXT("The caller needs to set our site or we can't succeed because we can't find out the icon size."));
            hr = E_INVALIDARG;
        }

        hr = S_OK;
    }

    return hr;
}


HRESULT CThemeFile::_SaveSystemMetrics(SYSTEMMETRICSALL * pSystemMetrics)
{
    HRESULT hr = _LoadSettings();

    AssertMsg((NULL != m_pszThemeFile), TEXT("We don't have a file specified yet."));
    if (SUCCEEDED(hr) && m_pszThemeFile)
    {
        int nCurrentDPI = DPI_PERSISTED;

        _LoadLiveSettings(&nCurrentDPI);
        hr = SystemMetricsAll_Copy(pSystemMetrics, &m_systemMetrics);
        if (SUCCEEDED(hr))
        {
            // Write the following:
            LPWSTR pszStringOut;
            NONCLIENTMETRICSA nonClientMetricsA = {0};
            SYSTEMMETRICSALL systemMetricsPDPI;     // SYSMETS in persist DPI

            SystemMetricsAll_Copy(pSystemMetrics, &systemMetricsPDPI);
            // Scale the values so they are persisted in a DPI independent way.  (A.k.a., in 96 DPI)
            LogSystemMetrics("CThemeFile::_SaveSystemMetrics() BEFORE scale to P-DPI for .theme file", &systemMetricsPDPI);
            DPIConvert_SystemMetricsAll(TRUE, &systemMetricsPDPI, nCurrentDPI, DPI_PERSISTED);
            LogSystemMetrics("CThemeFile::_SaveSystemMetrics() AFTER scale to P-DPI for .theme file", &systemMetricsPDPI);

            ConvertNCMetricsToANSI(&(systemMetricsPDPI.schemeData.ncm), &nonClientMetricsA);

            // #1 "NonclientMetrics"
            hr = ConvertBinaryToINIByteString((BYTE *)&nonClientMetricsA, sizeof(nonClientMetricsA), &pszStringOut);
            if (SUCCEEDED(hr))
            {
                hr = _putThemeSetting(SZ_INISECTION_METRICS, SZ_INIKEY_NONCLIENTMETRICS, FALSE, pszStringOut);
                LocalFree(pszStringOut);

                if (SUCCEEDED(hr))
                {
                    // #2 "IconMetrics"
                    ICONMETRICSA iconMetricsA;

                    iconMetricsA.cbSize = sizeof(iconMetricsA);
                    GetIconMetricsFromSysMetricsAll(&systemMetricsPDPI, &iconMetricsA, sizeof(iconMetricsA));
                    hr = ConvertBinaryToINIByteString((BYTE *)&iconMetricsA, sizeof(iconMetricsA), &pszStringOut);
                    if (SUCCEEDED(hr))
                    {
                        hr = _putThemeSetting(SZ_INISECTION_METRICS, SZ_INIKEY_ICONMETRICS, FALSE, pszStringOut);
                        if (SUCCEEDED(hr))
                        {
                            int nIndex;

                            for (nIndex = 0; nIndex < ARRAYSIZE(s_pszColorNames); nIndex++)
                            {
                                LPWSTR pszColor;
                                DWORD dwColor = systemMetricsPDPI.schemeData.rgb[nIndex];

                                hr = ConvertBinaryToINIByteString((BYTE *)&dwColor, 3, &pszColor);
                                if (SUCCEEDED(hr))
                                {
                                    DWORD cchSize = lstrlen(pszColor);

                                    if (L' ' == pszColor[cchSize - 1])
                                    {
                                        pszColor[cchSize - 1] = 0;
                                    }

                                    hr = HrWritePrivateProfileStringW(SZ_INISECTION_COLORS, s_pszColorNames[nIndex], pszColor, m_pszThemeFile);
                                    LocalFree(pszColor);
                                }
                            }

                            // Delete the MUI version of the fonts because we just got new NONCLIENTMETRICs
                            _putThemeSetting(SZ_INISECTION_METRICS, TEXT("CaptionFont"), FALSE, NULL);
                            _putThemeSetting(SZ_INISECTION_METRICS, TEXT("SmCaptionFont"), FALSE, NULL);
                            _putThemeSetting(SZ_INISECTION_METRICS, TEXT("MenuFont"), FALSE, NULL);
                            _putThemeSetting(SZ_INISECTION_METRICS, TEXT("StatusFont"), FALSE, NULL);
                            _putThemeSetting(SZ_INISECTION_METRICS, TEXT("MessageFont"), FALSE, NULL);
                            _putThemeSetting(SZ_INISECTION_METRICS, TEXT("IconFont"), FALSE, NULL);
                        }
                        LocalFree(pszStringOut);
                    }
                }
            }
        }
    }

    return hr;
}


BOOL CThemeFile::_IsFiltered(IN DWORD dwFilter)
{
    BOOL fFiltered = FALSE;

    // Get property bag with default settings.
    if (_punkSite)
    {
        IPropertyBag * pPropertyBag;

        HRESULT hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            fFiltered = !SHPropertyBag_ReadBOOLDefRet(pPropertyBag, g_szCBNames[dwFilter], FALSE);
            pPropertyBag->Release();
        }
    }

    return fFiltered;
}


HRESULT CThemeFile::_ApplySounds(void)
{
    HRESULT hr = S_OK;

    if (!_IsFiltered(THEMEFILTER_SOUNDS))
    {
        int nIndex;

        for (nIndex = 0; nIndex < ARRAYSIZE(s_ThemeSoundsValues); nIndex++)
        {
            CComBSTR bstrPath;

            hr = _GetSound(s_ThemeSoundsValues[nIndex].pszRegKey, &bstrPath);
            if (SUCCEEDED(hr))
            {
                DWORD dwError = SHRegSetPathW(HKEY_CURRENT_USER, s_ThemeSoundsValues[nIndex].pszRegKey, NULL, bstrPath, 0);
                hr = HRESULT_FROM_WIN32(dwError);
            }
            else
            {

                // First delete the value because we many need to switch from REG_SZ to REG_EXPAND_SZ
                // Ignore if this fails
                HrRegDeleteValue(HKEY_CURRENT_USER, s_ThemeSoundsValues[nIndex].pszRegKey, NULL);
                hr = E_FAIL;

                // The file didn't specify what to use, so reset to the default values.
                if (s_ThemeSoundsValues[nIndex].nResourceID)
                {
                    // Use the specified value.
                    TCHAR szReplacement[MAX_PATH];
                    DWORD dwType;
                    DWORD cbSize;

                    if (s_ThemeSoundsValues[nIndex].nResourceID == SOUND_DEFAULT)
                    {
                        TCHAR szDefaultKey[MAX_PATH];
                        StringCchCopy(szDefaultKey, ARRAYSIZE(szDefaultKey), s_ThemeSoundsValues[nIndex].pszRegKey);

                        DWORD cchDefaultKey = lstrlen(szDefaultKey);
                        DWORD cchCurrent = ARRAYSIZE(L".Current");
                        DWORD cchp = ARRAYSIZE(szDefaultKey) - cchDefaultKey - cchCurrent + 1;
                        LPTSTR p = szDefaultKey + cchDefaultKey - cchCurrent + 1;

                        // Replace ".Current" with ".default"
                        if (*p == L'.')
                        {
                            StringCchCopy(p, cchp, L".Default");
                            cbSize = sizeof szReplacement;
                            hr = HrSHGetValue(HKEY_CURRENT_USER, szDefaultKey, NULL, &dwType, (LPVOID) szReplacement, &cbSize);
                            if (SUCCEEDED(hr))
                            {
                                PathUnExpandEnvStringsWrap(szReplacement, ARRAYSIZE(szReplacement));
                            }
                        }
                    }
                    else
                    {
                        if (0 != LoadString(HINST_THISDLL, s_ThemeSoundsValues[nIndex].nResourceID, szReplacement, ARRAYSIZE(szReplacement)))
                        {
                            hr = S_OK;
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        dwType = (StrStrW(szReplacement, L"%SystemRoot%")) ? REG_EXPAND_SZ : REG_SZ;
                        cbSize = ((lstrlen(szReplacement) + 1) * sizeof(szReplacement[0]));

                        hr = HrSHSetValue(HKEY_CURRENT_USER, s_ThemeSoundsValues[nIndex].pszRegKey, NULL, dwType, (LPVOID) szReplacement, cbSize);
                    }
                }
                else
                {
                    // We leave the value deleted because the default was empty.
                }
            }
        }

        hr = S_OK;  // We don't care if it fails.

        // Need to flush buffer and ensure new sounds used for next events
        sndPlaySoundW(NULL, SND_ASYNC | SND_NODEFAULT);

        // Clear the current pointer scheme string from the registry so that Mouse
        // cpl doesn't display a bogus name.  Don't care if this fails.
        RegSetValue(HKEY_CURRENT_USER, SZ_REGKEY_SOUNDS, REG_SZ, TEXT(".current"), 0);
    }

    return hr;
}


HRESULT CThemeFile::_ApplyCursors(void)
{
    HRESULT hr = S_OK;

    if (!_IsFiltered(THEMEFILTER_CURSORS))
    {
        int nIndex;

        for (nIndex = 0; nIndex < ARRAYSIZE(s_pszCursorArray); nIndex++)
        {
            BSTR bstrPath;
            hr = _getThemeSetting(SZ_INISECTION_CURSORS, s_pszCursorArray[nIndex], THEMESETTING_LOADINDIRECT, &bstrPath);
            if (FAILED(hr) || !bstrPath[0])
            {
                // The caller didn't specify a value so delete the key so we use default values.
                hr = HrRegDeleteValue(HKEY_CURRENT_USER, SZ_INISECTION_CURSORS, s_pszCursorArray[nIndex]);
                if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    hr = S_OK;      // it may already not exist, which is fine.
                }
            }
            else if (SUCCEEDED(hr))
            {
                hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_INISECTION_CURSORS, s_pszCursorArray[nIndex], bstrPath);
            }
        }

        BSTR bstrCursor;
        if (SUCCEEDED(_getThemeSetting(SZ_INISECTION_CURSORS, SZ_INIKEY_CURSORSCHEME, THEMESETTING_LOADINDIRECT, &bstrCursor)) && bstrCursor && bstrCursor[0])
        {
            // Set the cursor scheme
            HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_CP_CURSORS, NULL, bstrCursor);

            // GPease wants me to mark this regkey -1 so he knows it was changed from the display CPL.  See
            // him with questions.
            HrRegSetDWORD(HKEY_CURRENT_USER, SZ_REGKEY_CP_CURSORS, SZ_REGVALUE_CURSOR_CURRENTSCHEME, 2);
        }
        else
        {
            HrRegDeleteValue(HKEY_CURRENT_USER, SZ_REGKEY_CP_CURSORS, NULL);
            HrRegDeleteValue(HKEY_CURRENT_USER, SZ_REGKEY_CP_CURSORS, SZ_REGVALUE_CURSOR_CURRENTSCHEME);
        }

        // For the system to start using the new cursors.
        SystemParametersInfoAsync(SPI_SETCURSORS, 0, 0, 0, SPIF_SENDCHANGE, NULL);
    }

    return hr;
}


HRESULT CThemeFile::_ApplyWebview(void)
{
    HRESULT hr = S_OK;

    // We aren't going to support this.
    return hr;
}


HRESULT CThemeFile::_ApplyThemeSettings(void)
{
    HRESULT hr = E_INVALIDARG;

    if (m_pszThemeFile)
    {
        HCURSOR hCursorOld = ::SetCursor(LoadCursor(NULL, IDC_WAIT));

        hr = S_OK;
        if (!((METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE) & m_systemMetrics.dwChanged))
        {
            // Only load settings if we haven't loaded the settings yet.
            hr = _LoadSettings();
        }

        if (SUCCEEDED(hr))
        {
            hr = _ApplySounds();
            if (SUCCEEDED(hr))
            {
                hr = _ApplyCursors();
                if (SUCCEEDED(hr))
                {
                    hr = _ApplyWebview();
                }
            }
        }
        
        // OTHERS:
        // 1. Save Icon: SPI_SETICONMETRICS w/iconMetricsW.iHorzSpacing, iVertSpacing, (Policy bIconSpacing).
        // 2. Save Icon: SPI_SETICONMETRICS w/iconMetricsW.lfFont (Policy bIconFont).
        // 2. Save Icon: from Theme:"Control Panel\\Desktop\\WindowMetrics","Shell Icon Size" to reg same. (Policy bIconSpacing).  Repeate for "Shell Small Icon Size"
        ::SetCursor(hCursorOld);
    }

    return hr;
}


HRESULT CThemeFile::_getThemeSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, DWORD dwFlags, OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath)
    {
        *pbstrPath = 0;
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        if (m_pszThemeFile)
        {
            WCHAR szPath[MAX_PATH];
            DWORD cbRead = 0;

            szPath[0] = 0;
            if (THEMESETTING_LOADINDIRECT & dwFlags)
            {
                TCHAR szMUIIniKey[MAX_PATH];

                StringCchPrintf(szMUIIniKey, ARRAYSIZE(szMUIIniKey), TEXT("%s.MUI"), pszIniKey);
                cbRead = SHGetIniStringW(pszIniSection, szMUIIniKey, szPath, ARRAYSIZE(szPath), m_pszThemeFile);
            }

            if (0 == cbRead)
            {
                cbRead = SHGetIniStringW(pszIniSection, pszIniKey, szPath, ARRAYSIZE(szPath), m_pszThemeFile);
            }

            if (cbRead)
            {
                if (L'@' == szPath[0])
                {
                    TCHAR szTemp[MAX_PATH];

                    if (SUCCEEDED(SHLoadIndirectString(szPath, szTemp, ARRAYSIZE(szTemp), NULL)))
                    {
                        StringCchCopy(szPath, ARRAYSIZE(szPath), szTemp);
                    }
                }

                hr = ExpandResourceDir(szPath, ARRAYSIZE(szPath));
                hr = ExpandThemeTokens(m_pszThemeFile, szPath, ARRAYSIZE(szPath));      // Expand %ThemeDir% or %WinDir%

                // Sometimes szPath won't be a path.
                if (SUCCEEDED(hr) && !PathIsFileSpec(szPath))
                {
                    hr = ((CF_NOTFOUND == ConfirmFile(szPath, TRUE)) ? HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) : S_OK);
                }

                if (SUCCEEDED(hr))
                {
                    hr = HrSysAllocString(szPath, pbstrPath);
                }
            }
        }
    }

    return hr;
}


// pszPath - NULL means delete value
HRESULT CThemeFile::_putThemeSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, BOOL fUTF7, IN OPTIONAL LPWSTR pszPath)
{
    HRESULT hr = E_INVALIDARG;

    if (m_pszThemeFile)
    {
        TCHAR szPath[MAX_PATH];
        LPCWSTR pszValue = pszPath;

        szPath[0] = 0;
        if (pszValue && !PathIsRelative(pszValue) && PathFileExists(pszValue))
        {
            if (PathUnExpandEnvStringsForUser(NULL, pszValue, szPath, ARRAYSIZE(szPath)))
            {
                pszValue = szPath;
            }
        }

        StrReplaceToken(TEXT("%WinDir%\\"), TEXT("%WinDir%"), szPath, ARRAYSIZE(szPath));
        StrReplaceToken(TEXT("%SystemRoot%\\"), TEXT("%WinDir%"), szPath, ARRAYSIZE(szPath));
        if (fUTF7)
        {
            if (SHSetIniStringW(pszIniSection, pszIniKey, pszValue, m_pszThemeFile))
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            hr = HrWritePrivateProfileStringW(pszIniSection, pszIniKey, pszValue, m_pszThemeFile);
        }

        TCHAR szMUIIniKey[MAX_PATH];

        // Delete any ".MUI" copies because they are out of date.
        StringCchPrintf(szMUIIniKey, ARRAYSIZE(szMUIIniKey), TEXT("%s.MUI"), pszIniKey);
        HrWritePrivateProfileStringW(pszIniSection, szMUIIniKey, NULL, m_pszThemeFile);
    }

    return hr;
}


HRESULT CThemeFile::_getIntSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, int nDefault, OUT int * pnValue)
{
    HRESULT hr = E_INVALIDARG;

    if (pnValue)
    {
        *pnValue = 0;
        hr = E_FAIL;
        if (m_pszThemeFile)
        {
            *pnValue = GetPrivateProfileInt(pszIniSection, pszIniKey, nDefault, m_pszThemeFile);
            hr = S_OK;
        }
    }

    return hr;
}


//===========================
// *** ITheme Interface ***
//===========================
HRESULT CThemeFile::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrDisplayName)
    {
        WCHAR szDisplayName[MAX_PATH];

        *pbstrDisplayName = NULL;
        hr = _getThemeSetting(SZ_INISECTION_THEME, SZ_INIKEY_DISPLAYNAME, THEMESETTING_NORMAL, pbstrDisplayName);
        if (FAILED(hr))
        {
            LPCTSTR pszFileName = PathFindFileName(m_pszThemeFile);

            hr = E_FAIL;
            if (pszFileName)
            {
                SHTCharToUnicode(pszFileName, szDisplayName, ARRAYSIZE(szDisplayName));
                PathRemoveExtensionW(szDisplayName);

                hr = HrSysAllocStringW(szDisplayName, pbstrDisplayName);
            }
        }
    }

    return hr;
}


HRESULT CThemeFile::put_DisplayName(IN BSTR bstrDisplayName)
{
    HRESULT hr = E_INVALIDARG;

    // NULL bstrDisplayName is allowed, it means to delete the name in the file
    // so the filename will be used in the future.
    if (bstrDisplayName)
    {
        hr = _putThemeSetting(SZ_INISECTION_THEME, SZ_INIKEY_DISPLAYNAME, TRUE, bstrDisplayName);
    }
    else
    {
        SHSetIniStringW(SZ_INISECTION_THEME, SZ_INIKEY_DISPLAYNAME, NULL, m_pszThemeFile);
        hr = S_OK;
    }

    return hr;
}


HRESULT CThemeFile::get_ScreenSaver(OUT BSTR * pbstrPath)
{
    return _getThemeSetting(SZ_INISECTION_SCREENSAVER, SZ_INIKEY_SCREENSAVER, THEMESETTING_NORMAL, pbstrPath);
}


HRESULT CThemeFile::put_ScreenSaver(IN BSTR bstrPath)
{
    return _putThemeSetting(SZ_INISECTION_SCREENSAVER, SZ_INIKEY_SCREENSAVER, TRUE, bstrPath);
}


HRESULT CThemeFile::get_Background(OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath)
    {
        hr = _getThemeSetting(SZ_INISECTION_BACKGROUND, SZ_INIKEY_BACKGROUND, THEMESETTING_LOADINDIRECT, pbstrPath);
        if (SUCCEEDED(hr))
        {
            TCHAR szNone[MAX_PATH];

            LoadString(HINST_THISDLL, IDS_NONE, szNone, ARRAYSIZE(szNone));
            if (!StrCmpI(szNone, *pbstrPath))
            {
                (*pbstrPath)[0] = 0;
            }
        }
    }

    return hr;
}


HRESULT CThemeFile::put_Background(IN BSTR bstrPath)
{
    return _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_INIKEY_BACKGROUND, TRUE, bstrPath);
}


HRESULT CThemeFile::get_BackgroundTile(OUT enumBkgdTile * pnTile)
{
    HRESULT hr = E_INVALIDARG;

    if (pnTile)
    {
        TCHAR szSize[10];
        int tile = 0;       // Zero is the default value to use if the registry is empty.
        int stretch = 0;

        if (SUCCEEDED(HrRegGetValueString(HKEY_CURRENT_USER, SZ_INISECTION_BACKGROUND, SZ_REGVALUE_TILEWALLPAPER, szSize, ARRAYSIZE(szSize))))
        {
            tile = StrToInt(szSize);
        }

        if (SUCCEEDED(HrRegGetValueString(HKEY_CURRENT_USER, SZ_INISECTION_BACKGROUND, SZ_REGVALUE_WALLPAPERSTYLE, szSize, ARRAYSIZE(szSize))))
        {
            tile = (2 & StrToInt(szSize));
        }

        // If a theme is selected, and we are using a plus wall paper then
        // find out if tiling is on, and what style to use from the ini file.
        // Otherwise, we already got the information from the registry.
        _getIntSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_TILEWALLPAPER, tile, &tile);
        _getIntSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_WALLPAPERSTYLE, stretch, &stretch);

        stretch &= 2;
        _getIntSetting(SZ_INISECTION_MASTERSELECTOR, SZ_REGVALUE_STRETCH, stretch, &stretch);

        if (tile)
        {
            *pnTile = BKDGT_TILE;
        }
        else if (stretch)
        {
            *pnTile = BKDGT_STRECH;
        }
        else
        {
            *pnTile = BKDGT_CENTER;
        }

        hr = S_OK;
    }

    return hr;
}


HRESULT CThemeFile::put_BackgroundTile(IN enumBkgdTile nTile)
{
    HRESULT hr = E_INVALIDARG;

    switch (nTile)
    {
    case BKDGT_STRECH:
        hr = _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_TILEWALLPAPER, FALSE, TEXT("0"));
        hr = _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_WALLPAPERSTYLE, FALSE, TEXT("2"));
        break;
    case BKDGT_CENTER:
        hr = _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_TILEWALLPAPER, FALSE, TEXT("0"));
        hr = _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_WALLPAPERSTYLE, FALSE, TEXT("0"));
        break;
    case BKDGT_TILE:
        hr = _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_TILEWALLPAPER, FALSE, TEXT("1"));
        hr = _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_WALLPAPERSTYLE, FALSE, TEXT("0"));
        break;
    };

    return hr;
}


HRESULT CThemeFile::get_VisualStyle(OUT BSTR * pbstrPath)
{
    return _getThemeSetting(SZ_INISECTION_VISUALSTYLES, SZ_INIKEY_VISUALSTYLE, THEMESETTING_NORMAL, pbstrPath);
}


HRESULT CThemeFile::put_VisualStyle(IN BSTR bstrPath)
{
    return _putThemeSetting(SZ_INISECTION_VISUALSTYLES, SZ_INIKEY_VISUALSTYLE, TRUE, bstrPath);
}


HRESULT CThemeFile::get_VisualStyleColor(OUT BSTR * pbstrPath)
{
    return _getThemeSetting(SZ_INISECTION_VISUALSTYLES, SZ_INIKEY_VISUALSTYLECOLOR, THEMESETTING_NORMAL, pbstrPath);
}


HRESULT CThemeFile::put_VisualStyleColor(IN BSTR bstrPath)
{
    return _putThemeSetting(SZ_INISECTION_VISUALSTYLES, SZ_INIKEY_VISUALSTYLECOLOR, TRUE, bstrPath);
}


HRESULT CThemeFile::get_VisualStyleSize(OUT BSTR * pbstrPath)
{
    return _getThemeSetting(SZ_INISECTION_VISUALSTYLES, SZ_INIKEY_VISUALSTYLESIZE, THEMESETTING_NORMAL, pbstrPath);
}


HRESULT CThemeFile::put_VisualStyleSize(IN BSTR bstrPath)
{
    return _putThemeSetting(SZ_INISECTION_VISUALSTYLES, SZ_INIKEY_VISUALSTYLESIZE, TRUE, bstrPath);
}


HRESULT CThemeFile::GetPath(IN VARIANT_BOOL fExpand, OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath && m_pszThemeFile)
    {
        TCHAR szPath[MAX_PATH];

        StringCchCopy(szPath, ARRAYSIZE(szPath), m_pszThemeFile);
        if (VARIANT_TRUE == fExpand)
        {
            TCHAR szPathTemp[MAX_PATH];
            
            if (SHExpandEnvironmentStrings(szPath, szPathTemp, ARRAYSIZE(szPathTemp)))
            {
                StringCchCopy(szPath, ARRAYSIZE(szPath), szPathTemp);
            }
        }

        hr = HrSysAllocString(szPath, pbstrPath);
    }

    return hr;
}


HRESULT CThemeFile::SetPath(IN BSTR bstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrPath)
    {
        Str_SetPtr(&m_pszThemeFile, bstrPath);
        hr = S_OK;
    }

    return hr;
}


HRESULT CThemeFile::GetCursor(IN BSTR bstrCursor, OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath)
    {
        *pbstrPath = NULL;

        if (bstrCursor)
        {
            hr = _getThemeSetting(SZ_INISECTION_CURSORS, bstrCursor, THEMESETTING_LOADINDIRECT, pbstrPath);
        }
    }

    return hr;
}


HRESULT CThemeFile::SetCursor(IN BSTR bstrCursor, IN BSTR bstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrCursor)
    {
        hr = _putThemeSetting(SZ_INISECTION_CURSORS, bstrCursor, TRUE, bstrPath);
    }

    return hr;
}


HRESULT CThemeFile::_GetSound(LPCWSTR pszSoundName, OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pszSoundName && pbstrPath)
    {
        *pbstrPath = NULL;
        hr = _getThemeSetting(pszSoundName, SZ_INIKEY_DEFAULTVALUE, THEMESETTING_LOADINDIRECT, pbstrPath);
    }

    return hr;
}


HRESULT CThemeFile::GetSound(IN BSTR bstrSoundName, OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath)
    {
        *pbstrPath = NULL;

        if (bstrSoundName)
        {
            hr = _GetSound(bstrSoundName, pbstrPath);
            if (FAILED(hr))
            {
                int nIndex;

                for (nIndex = 0; nIndex < ARRAYSIZE(s_ThemeSoundsValues); nIndex++)
                {
                    if (!StrCmpI(bstrSoundName, s_ThemeSoundsValues[nIndex].pszRegKey))
                    {
                        // First delete the value because we many need to switch from REG_SZ to REG_EXPAND_SZ
                        TCHAR szReplacement[MAX_PATH];

                        LoadString(HINST_THISDLL, s_ThemeSoundsValues[nIndex].nResourceID, szReplacement, ARRAYSIZE(szReplacement));
                        hr = HrSysAllocStringW(szReplacement, pbstrPath);
                        break;
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CThemeFile::SetSound(IN BSTR bstrSoundName, IN BSTR bstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrSoundName && bstrPath)
    {
        hr = _putThemeSetting(bstrSoundName, SZ_INIKEY_DEFAULTVALUE, TRUE, bstrPath);
    }

    return hr;
}


HRESULT CThemeFile::GetIcon(IN BSTR bstrIconName, OUT BSTR * pbstrIconPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrIconPath)
    {
        *pbstrIconPath = NULL;

        if (bstrIconName)
        {
            WCHAR szPath[MAX_URL_STRING];
            WCHAR szIconType[MAX_PATH];

            StringCchCopy(szPath, ARRAYSIZE(szPath), bstrIconName);
            LPWSTR pszSeparator = StrChrW(szPath, L':');
            if (pszSeparator)
            {
                StringCchCopy(szIconType, ARRAYSIZE(szIconType), CharNext(pszSeparator));
                pszSeparator[0] = 0;
            }
            else
            {
                // The caller should specify this but this is a safe fallback.
                StringCchCopy(szIconType, ARRAYSIZE(szIconType), L"DefaultValue");
            }

            hr = _getThemeSetting(szPath, szIconType, THEMESETTING_NORMAL, pbstrIconPath);
            if (FAILED(hr))
            {
                // The Plus! 98 format started adding "Software\Classes" to the path.
                // So try that now.
                // Plus!95 format: "[CLSID\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\DefaultIcon]"
                // Plus!98 format: "[Software\Classes\CLSID\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\DefaultIcon]"
                WCHAR szPath98[MAX_URL_STRING];

                StringCchPrintf(szPath98, ARRAYSIZE(szPath98), L"Software\\Classes\\%ls", szPath);
                hr = _getThemeSetting(szPath98, szIconType, THEMESETTING_NORMAL, pbstrIconPath);
            }
        }
    }

    return hr;
}


HRESULT CThemeFile::SetIcon(IN BSTR bstrIconName, IN BSTR bstrIconPath)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrIconName && bstrIconPath)
    {
        WCHAR szPath[MAX_URL_STRING];
        WCHAR szIconType[MAX_PATH];

        StringCchCopy(szPath, ARRAYSIZE(szPath), bstrIconName);
        LPWSTR pszSeparator = StrChrW(szPath, L':');
        if (pszSeparator)
        {
            StringCchCopy(szIconType, ARRAYSIZE(szIconType), CharNext(pszSeparator));
            pszSeparator[0] = 0;
        }
        else
        {
            // The caller should specify this but this is a safe fallback.
            StringCchCopy(szIconType, ARRAYSIZE(szIconType), L"DefaultValue");
        }

        hr = _putThemeSetting(szPath, szIconType, TRUE, bstrIconPath);
    }

    return hr;
}




//===========================
// *** IPropertyBag Interface ***
//===========================
HRESULT CThemeFile::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_SYSTEM_METRICS))
        {
            hr = _LoadSettings();

            // This is pretty ugly.
            pVar->vt = VT_BYREF;
            pVar->byref = &m_systemMetrics;
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_HASSYSMETRICS))
        {
            hr = _LoadSettings();

            pVar->vt = VT_BOOL;
            pVar->boolVal = VARIANT_FALSE;
            if (SUCCEEDED(hr))
            {
                TCHAR szIconMetrics[2048];
                
                if (GetPrivateProfileString(SZ_INISECTION_METRICS, SZ_INIKEY_ICONMETRICS, SZ_EMPTY, szIconMetrics, ARRAYSIZE(szIconMetrics), m_pszThemeFile))
                {                    
                    if (GetPrivateProfileString(SZ_INISECTION_METRICS, SZ_INIKEY_NONCLIENTMETRICS, SZ_EMPTY, szIconMetrics, ARRAYSIZE(szIconMetrics), m_pszThemeFile))
                    {
                        GetPrivateProfileString(SZ_INISECTION_COLORS, s_pszColorNames[COLOR_ACTIVECAPTION], SZ_EMPTY, szIconMetrics, ARRAYSIZE(szIconMetrics), m_pszThemeFile);
                        pVar->boolVal = (szIconMetrics[0] ? VARIANT_TRUE : VARIANT_FALSE);
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CThemeFile::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_NOTIMPL;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_APPLY_THEMEFILE))
        {
            VariantInit(pVar);
            hr = _ApplyThemeSettings();       // This will do nothing if already loaded.
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_SYSTEM_METRICS) && (VT_BYREF == pVar->vt) && pVar->byref)
        {
            SYSTEMMETRICSALL * pCurrent = (SYSTEMMETRICSALL *) pVar->byref;

            // The caller will pass SYSTEMMETRICS in the live system DPI.
            hr = _SaveSystemMetrics(pCurrent);
        }
    }

    return hr;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CThemeFile::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CThemeFile::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CThemeFile::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CThemeFile, IObjectWithSite),
        QITABENT(CThemeFile, IPropertyBag),
        QITABENT(CThemeFile, ITheme),
        QITABENT(CThemeFile, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CThemeFile::CThemeFile(LPCTSTR pszThemeFile) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    
    m_dwCachedState = 0xFFFFFFFF;

    InitFrost();
}


CThemeFile::~CThemeFile()
{
    Str_SetPtr(&m_pszThemeFile, NULL);

    DllRelease();
}


HRESULT CThemeFile_CreateInstance(IN LPCWSTR pszThemeFile, OUT ITheme ** ppTheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppTheme)
    {
        CThemeFile * pObject = new CThemeFile(pszThemeFile);

        hr = E_OUTOFMEMORY;
        *ppTheme = NULL;
        if (pObject)
        {
            hr = pObject->SetPath((BSTR)pszThemeFile);
            if (SUCCEEDED(hr))
            {
                hr = pObject->QueryInterface(IID_PPV_ARG(ITheme, ppTheme));
            }

            pObject->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\themepg.h ===
/*****************************************************************************\
    FILE: ThemePg.h

    DESCRIPTION:
        This code will display a "Theme" tab in the
    "Display Properties" dialog (the base dialog, not the advanced dlg).

    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#ifndef _THEMEPG_H
#define _THEMEPG_H

#include <cowsite.h>
#include "PreviewTh.h"
#include "ThSettingsPg.h"


#define SIZE_ICONS_ARRAY           5

extern LPCWSTR s_Icons[SIZE_ICONS_ARRAY];

enum eThemeType
{
    eThemeFile = 0,
    eThemeURL,
    eThemeModified,
    eThemeOther,
};

typedef struct
{
    eThemeType type;
    union
    {
        ITheme * pTheme;
        LPWSTR pszUrl;
    };
} THEME_ITEM_BLOCK;


class CThemePage                : public CObjectWithSite
                                , public CObjectWindow
                                , public CObjectCLSID
                                , public IPropertyBag
                                , public IBasePropPage
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam) {return E_NOTIMPL;}

    // *** IObjectWithSite ***
    virtual STDMETHODIMP SetSite(IUnknown *punkSite);

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IBasePropPage ***
    virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
    virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);

    CThemePage();
protected:

private:
    virtual ~CThemePage(void);

    // Private Member Variables
    long                    m_cRef;

    HWND                    m_hwndThemeCombo;
    HWND                    m_hwndDeleteButton;
    int                     m_nPreviousSelected;        // Track the previously selected item so we can reset.
    HKEY                    m_hkeyFilter;               // We cache this key because it will probably be used 16 times.
    BOOL                    m_fFilters[ARRAYSIZE(g_szCBNames)];  // These are the theme filters
    ITheme *                m_pLastSelected;            // Used to see if the user selected the same item.
    ITheme *                m_pSelectedTheme;
    IThemePreview *         m_pThemePreview;
    IPropertyBag  *         m_pScreenSaverUI;
    IPropertyBag  *         m_pBackgroundUI;
    IPropertyBag  *         m_pAppearanceUI;            // Used to set the system metrics and visual style settings.
    LPWSTR                  m_pszThemeToApply;          // When the apply button is pressed, we need to apply this theme.
    LPWSTR                  m_pszThemeLaunched;         // When we open up, load this team because the caller wants that theme loaded when the dialog first opens.
    LPWSTR                  m_pszLastAppledTheme;       // If NULL, then the theme is modified, otherwise the path to the last applied theme file.
    LPWSTR                  m_pszModifiedName;          // This is the display name we use for the "xxx (Modified)" item.
    BOOL                    m_fInInit;
    BOOL                    m_fInited;                  // Have we loaded the settings yet?
    THEME_ITEM_BLOCK        m_Modified;

    // Private Member Functions
    INT_PTR _ThemeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnInitThemesDlg(HWND hDlg);
    HRESULT _OnDestroy(HWND hDlg);
    INT_PTR _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnSetActive(HWND hDlg);
    HRESULT _OnApply(HWND hDlg, LPARAM lParam);
    HRESULT _OnSetSelection(IN int nIndex);
    HRESULT _OnSelectOther(void);
    HRESULT _OnThemeChange(HWND hDlg, BOOL fOnlySelect);

    HRESULT _OnOpenAdvSettingsDlg(HWND hDlg);
    HRESULT _FreeThemeDropdown(void);
    HRESULT _UpdatePreview(void);
    HRESULT _InitScreenSaver(void);
    HRESULT _InitFilterKey(void);
    HRESULT _LoadThemeFilterState(void);
    HRESULT _SaveThemeFilterState(void);
    HRESULT _RemoveTheme(int nIndex);

    HRESULT _SaveAs(void);
    HRESULT _DeleteTheme(void);
    HRESULT _EnableDeleteIfAppropriate(void);

    HRESULT _OnSetBackground(void);
    HRESULT _OnSetIcons(void);
    HRESULT _OnSetSystemMetrics(void);
    HRESULT _ApplyThemeFile(void);

    HRESULT _RemoveUserTheme(void);
    HRESULT _ChooseOtherThemeFile(IN LPCWSTR pszFile, BOOL fOnlySelect);
    HRESULT _LoadCustomizeValue(void);
    HRESULT _CustomizeTheme(void);
    HRESULT _HandleCustomizedEntre(void);
    HRESULT _PersistState(void);

    HRESULT _AddUrls(void);
    HRESULT _AddUrl(LPCTSTR pszDisplayName, LPCTSTR pszUrl);
    HRESULT _AddThemeFile(LPCTSTR pszDisplayName, int * pnIndex, ITheme * pTheme);
    ITheme * _GetThemeFile(int nIndex);
    LPCWSTR _GetThemeUrl(int nIndex);
    HRESULT _OnLoadThemeValues(ITheme * pTheme, BOOL fOnlySelect);
    HRESULT _DisplayThemeOpenErr(LPCTSTR pszOpenFile);

    BOOL _IsFiltered(IN DWORD dwFilter);
    BOOL _IsDirty(void);

    static INT_PTR CALLBACK ThemeDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};


#endif // _THEMEPG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\thscheme.h ===
/*****************************************************************************\
    FILE: thScheme.h

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.  This one will be
    a skin.

    BryanSt 5/9/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_THSCHEME
#define _FILE_H_THSCHEME

#include <cowsite.h>
#include <atlbase.h>


static const GUID CLSID_SkinScheme = { 0x570fdefa, 0x5907, 0x47fe, { 0x96, 0x6b, 0x90, 0x30, 0xb4, 0xba, 0x10, 0xcd } };// {570FDEFA-5907-47fe-966B-9030B4BA10CD}
HRESULT CSkinScheme_CreateInstance(IN LPCWSTR pszFilename, OUT IThemeScheme ** ppThemeScheme);




class CSkinScheme               : public CObjectCLSID
                                , public IThemeScheme
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeScheme ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName) {return E_NOTIMPL;}
    virtual STDMETHODIMP get_Path(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP put_Path(IN BSTR bstrPath);
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT IThemeStyle ** ppThemeStyle);
    virtual STDMETHODIMP get_SelectedStyle(OUT IThemeStyle ** ppThemeStyle);
    virtual STDMETHODIMP put_SelectedStyle(IN IThemeStyle * pThemeStyle);
    virtual STDMETHODIMP AddStyle(OUT IThemeStyle ** ppThemeStyle);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return E_ACCESSDENIED; }

private:
    CSkinScheme(IN LPCWSTR pszFilename);
    virtual ~CSkinScheme(void);


    // Private Member Variables
    long                    m_cRef;

    IThemeStyle *           m_pSelectedStyle;       // The selected style.
    LPWSTR                  m_pszFilename;          // This is the full path to the ".thx" file
    long                    m_nSize;                // The size of the collection of "Color Styles".

    // Private Member Functions

    // Friend Functions
    friend HRESULT CSkinScheme_CreateInstance(IN LPCWSTR pszFilename, OUT IThemeScheme ** ppThemeScheme);
};


#endif // _FILE_H_THSCHEME
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\thscheme.cpp ===
/*****************************************************************************\
    FILE: thScheme.cpp

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 5/11/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "theme.h"
#include "appstyle.h"
#include "thsize.h"
#include "thstyle.h"
#include "thscheme.h"


//===========================
// *** Class Internals & Helpers ***
//===========================




//===========================
// *** ITheme Interface ***
//===========================
HRESULT CSkinScheme::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    WCHAR szDisplayName[MAX_PATH];
    HRESULT hr = GetThemeDocumentationProperty(m_pszFilename, SZ_THDOCPROP_DISPLAYNAME, szDisplayName, ARRAYSIZE(szDisplayName));

    LogStatus("GetThemeDocumentationProperty(path=\"%ls\", displayname=\"%ls\") returned %#08lx.\r\n", m_pszFilename, szDisplayName, hr);
    if (SUCCEEDED(hr))
    {
        hr = HrSysAllocStringW(szDisplayName, pbstrDisplayName);
    }

    return hr;
}


HRESULT CSkinScheme::get_Path(OUT BSTR * pbstrPath)
{
    return HrSysAllocString(m_pszFilename, pbstrPath);
}


HRESULT CSkinScheme::put_Path(IN BSTR bstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrPath)
    {
        Str_SetPtr(&m_pszFilename, bstrPath);
        hr = (m_pszFilename ? S_OK : E_OUTOFMEMORY);
    }

    return hr;
}


HRESULT CSkinScheme::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;

    if (pnLength)
    {
        hr = S_OK;
        if (COLLECTION_SIZE_UNINITIALIZED == m_nSize)
        {
            THEMENAMEINFO themeInfo;
            m_nSize = 0;

            // Make sure there are at least 1 color or return a failure HR.
            hr = EnumThemeColors(m_pszFilename, NULL, m_nSize, &themeInfo);
            do
            {
                m_nSize++;
            }
            while (SUCCEEDED(EnumThemeColors(m_pszFilename, NULL, m_nSize, &themeInfo)));
        }

        *pnLength = m_nSize;
    }

    return hr;
}


HRESULT CSkinScheme::get_item(IN VARIANT varIndex, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        long nCount = 0;

        get_length(&nCount);
        *ppThemeStyle = NULL;

        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
            varIndex = *(varIndex.pvarVal);

        switch (varIndex.vt)
        {
        case VT_I2:
            varIndex.lVal = (long)varIndex.iVal;
            // And fall through...

        case VT_I4:
            if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount) && m_pszFilename)
            {
                THEMENAMEINFO themeInfo;

                hr = EnumThemeColors(m_pszFilename, NULL, varIndex.lVal, &themeInfo);
                LogStatus("EnumThemeColors(path=\"%ls\") returned %#08lx in CSkinScheme::get_item.\r\n", m_pszFilename, hr);
                if (SUCCEEDED(hr))
                {
                    hr = CSkinStyle_CreateInstance(m_pszFilename, themeInfo.szName, themeInfo.szDisplayName, ppThemeStyle);
                }
            }
            break;

        case VT_BSTR:
            if (varIndex.bstrVal)
            {
                if (!varIndex.bstrVal[0])
                {
                    if (m_pszFilename)
                    {
                        TCHAR szColor[MAX_PATH];
                        TCHAR szSize[MAX_PATH];

                        hr = GetThemeDefaults(m_pszFilename, szColor, ARRAYSIZE(szColor), szSize, ARRAYSIZE(szSize));
                        LogStatus("GetThemeDefaults(pszFilename=\"%ls\", szColor=\"%ls\", szSize=\"%ls\") returned %#08lx in CSkinScheme::get_item.\r\n", m_pszFilename, szColor, szSize, hr);
                        if (SUCCEEDED(hr))
                        {
                            hr = CSkinStyle_CreateInstance(m_pszFilename, szColor, ppThemeStyle);
                        }
                    }
                }
                else
                {
                    THEMENAMEINFO themeInfo;

                    for (long nIndex = 0; FAILED(hr) && (nIndex < nCount) && SUCCEEDED(EnumThemeColors(m_pszFilename, NULL, nIndex, &themeInfo));
                                nIndex++)
                    {
                        if (!StrCmpIW(themeInfo.szDisplayName, varIndex.bstrVal) ||
                            !StrCmpIW(themeInfo.szName, varIndex.bstrVal))
                        {
                            hr = CSkinStyle_CreateInstance(m_pszFilename, themeInfo.szName, themeInfo.szDisplayName, ppThemeStyle);
                        }
                    }
                }
            }
            break;

        default:
            hr = E_NOTIMPL;
        }
    }

    return hr;
}


HRESULT CSkinScheme::get_SelectedStyle(OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        WCHAR szCurrentPath[MAX_PATH];
        WCHAR szCurrentStyle[MAX_PATH];

        szCurrentPath[0] = 0;
        szCurrentStyle[0] = 0;
        *ppThemeStyle = NULL;
        hr = GetCurrentThemeName(szCurrentPath, ARRAYSIZE(szCurrentPath), szCurrentStyle, ARRAYSIZE(szCurrentStyle), NULL, 0);
        LogStatus("GetCurrentThemeName(path=\"%ls\", color=\"%ls\", size=\"%ls\") returned %#08lx in CSkinScheme::get_SelectedStyle.\r\n", szCurrentPath, szCurrentStyle, TEXT("NULL"), hr);
        if (SUCCEEDED(hr))
        {
            AssertMsg((0 != szCurrentStyle[0]), TEXT("The GetCurrentThemeName() API returned an invalid value."));

            // Is this skin currently selected?
            if (!StrCmpIW(m_pszFilename, szCurrentPath))
            {
                // Yes, so get the color style from that API.
                if (!m_pSelectedStyle)
                {
                    hr = CSkinStyle_CreateInstance(m_pszFilename, szCurrentStyle, &m_pSelectedStyle);
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
            
        if (FAILED(hr))
        {
            ATOMICRELEASE(m_pSelectedStyle);

            // No, so find the default color style for this skin(scheme).
            hr = GetThemeDefaults(m_pszFilename, szCurrentStyle, ARRAYSIZE(szCurrentStyle), NULL, 0);
            LogStatus("GetThemeDefaults(szCurrentStyle=\"%ls\", szCurrentStyle=\"%ls\") returned %#08lx in CSkinScheme::get_SelectedStyle.\r\n", szCurrentStyle, szCurrentStyle, hr);
            if (SUCCEEDED(hr))
            {
                hr = CSkinStyle_CreateInstance(m_pszFilename, szCurrentStyle, &m_pSelectedStyle);
            }
        }

        if (m_pSelectedStyle)
        {
            IUnknown_Set((IUnknown **)ppThemeStyle, m_pSelectedStyle);
        }
    }

    return hr;
}


HRESULT CSkinScheme::put_SelectedStyle(IN IThemeStyle * pThemeStyle)
{
    IUnknown_Set((IUnknown **)&m_pSelectedStyle, pThemeStyle);
    return S_OK;
}


HRESULT CSkinScheme::AddStyle(OUT IThemeStyle ** ppThemeStyle)
{
    if (ppThemeStyle)
    {
        *ppThemeStyle = NULL;
    }

    return E_NOTIMPL;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CSkinScheme::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CSkinScheme::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CSkinScheme::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CSkinScheme, IPersist),
        QITABENT(CSkinScheme, IThemeScheme),
        QITABENT(CSkinScheme, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CSkinScheme::CSkinScheme(IN LPCWSTR pszFilename) : CObjectCLSID(&CLSID_SkinScheme), m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pSelectedStyle);

    Str_SetPtr(&m_pszFilename, pszFilename);
    m_nSize = COLLECTION_SIZE_UNINITIALIZED;
}


CSkinScheme::~CSkinScheme()
{
    ATOMICRELEASE(m_pSelectedStyle);
    Str_SetPtr(&m_pszFilename, NULL);

    DllRelease();
}



HRESULT CSkinScheme_CreateInstance(IN LPCWSTR pszFilename, OUT IThemeScheme ** ppThemeScheme)
{
    HRESULT hr = E_INVALIDARG;

    if (pszFilename && ppThemeScheme)
    {
        TCHAR szPath[MAX_PATH];

        StringCchCopy(szPath, ARRAYSIZE(szPath), pszFilename);
        ExpandResourceDir(szPath, ARRAYSIZE(szPath));
        
        CSkinScheme * pObject = new CSkinScheme(szPath);

        *ppThemeScheme = NULL;
        hr = E_OUTOFMEMORY;
        if (pObject)
        {
            if (pObject->m_pszFilename)
            {
                hr = pObject->QueryInterface(IID_PPV_ARG(IThemeScheme, ppThemeScheme));
            }

            pObject->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\themepg.cpp ===
/*****************************************************************************\
    FILE: ThemePg.cpp

    DESCRIPTION:
        This code will display a "Theme" tab in the
    "Display Properties" dialog (the base dialog, not the advanced dlg).

    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "ThemePg.h"
#include "AdvAppearPg.h"
#include "ThSettingsPg.h"



//============================================================================================================
// *** Globals ***
//============================================================================================================
const static DWORD FAR aThemesHelpIds[] = {
        IDC_THPG_THEME_PREVIEW,         IDH_DISPLAY_THEMES_PREVIEW,         // Preview window
        IDC_THPG_THEMELIST,             IDH_DISPLAY_THEMES_LIST,            // Drop Down containing Plus! Themes
        IDC_THPG_THEMESETTINGS,         IDH_DISPLAY_THEMES_SETTINGS,        // "Properties" button to Advanced settings.
        IDC_THPG_THEMEDESCRIPTION,      (DWORD)-1,                          // 
        IDC_THPG_THEMENAME,             IDH_DISPLAY_THEMES_LIST,            // Title for Themes Drop Down
        IDC_THPG_SAMPLELABLE,           IDH_DISPLAY_THEMES_PREVIEW,         // Label for Preview
        IDC_THPG_SAVEAS,                IDH_DISPLAY_THEMES_SAVEAS,          // Button for Theme "Save As..."
        IDC_THPG_DELETETHEME,           IDH_DISPLAY_THEMES_DELETETHEME,     // Button for Theme "Delete"
        0, 0
};

#define SZ_HELPFILE_THEMES             TEXT("display.hlp")

// EnableApplyButton() fails in WM_INITDIALOG so we need to do it later.
#define WMUSER_DELAYENABLEAPPLY            (WM_USER + 1)
#define DelayEnableApplyButton(hDlg)    PostMessage(hDlg, WMUSER_DELAYENABLEAPPLY, 0, 0)

//===========================
// *** Class Internals & Helpers ***
//===========================
BOOL CThemePage::_IsDirty(void)
{
    BOOL fIsDirty = FALSE;

    if (m_pSelectedTheme)
    {
        fIsDirty = TRUE;
    }

    return fIsDirty;
}


INT_PTR CALLBACK CThemePage::ThemeDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CThemePage * pThis = (CThemePage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

        if (pPropSheetPage)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
            pThis = (CThemePage *)pPropSheetPage->lParam;
        }
    }

    if (pThis)
        return pThis->_ThemeDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


HRESULT CThemePage::_OnOpenAdvSettingsDlg(HWND hDlg)
{
    IAdvancedDialog * pAdvDialog;
    HRESULT hr = GetAdvancedDialog(&pAdvDialog);

    if (SUCCEEDED(hr))
    {
        BOOL fEnableApply = FALSE;

        IUnknown_SetSite(pAdvDialog, SAFECAST(this, IObjectWithSite *));
        hr = pAdvDialog->DisplayAdvancedDialog(hDlg, SAFECAST(this, IPropertyBag *), &fEnableApply);
        IUnknown_SetSite(pAdvDialog, NULL);
        if (SUCCEEDED(hr) && fEnableApply)
        {
            EnableApplyButton(hDlg);
        }

        pAdvDialog->Release();
    }

    return hr;
}


HRESULT CThemePage::_EnableDeleteIfAppropriate(void)
{
    HRESULT hr = E_UNEXPECTED;
    BOOL fEnabled = FALSE;
    ITheme * pCurrent = m_pSelectedTheme;

    if (!pCurrent)
    {
        pCurrent = _GetThemeFile(ComboBox_GetCurSel(m_hwndThemeCombo));
    }

    if (pCurrent)
    {
        CComBSTR bstrPath;

        if (SUCCEEDED(pCurrent->GetPath(VARIANT_TRUE, &bstrPath)) &&
            bstrPath && bstrPath[0])
        {
            TCHAR szReadOnlyDir[MAX_PATH];
            TCHAR szCommonRoot[MAX_PATH];

            if (ExpandEnvironmentStrings(TEXT("%SystemRoot%\\Resources"), szReadOnlyDir, ARRAYSIZE(szReadOnlyDir)))
            {
                PathCommonPrefix(bstrPath, szReadOnlyDir, szCommonRoot);
                if (!StrStrI(szCommonRoot, szReadOnlyDir))
                {
                    fEnabled = TRUE;
                }
            }
        }
    }

    EnableWindow(m_hwndDeleteButton, fEnabled);
    return hr;
}



HRESULT CThemePage::_DeleteTheme(void)
{
    HRESULT hr = E_UNEXPECTED;

    if (m_pSelectedTheme)
    {
        CComBSTR bstrPath;

        if (SUCCEEDED(m_pSelectedTheme->GetPath(VARIANT_TRUE, &bstrPath)) &&
            bstrPath && bstrPath[0])
        {
            HCURSOR old = SetCursor(LoadCursor(NULL, IDC_WAIT));
            hr = HrSHFileOpDeleteFile(_hwnd, (FOF_NOCONFIRMATION | FOF_NOERRORUI), bstrPath);      // We use SHFileOperation so it will go into the Recycle Bin for undo reasons.
            SetCursor(old);

            if (FAILED(hr))
            {
                if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
                {
                    TCHAR szTitle[MAX_PATH];

                    LoadString(HINST_THISDLL, IDS_ERROR_THEME_DELETE_TITLE, szTitle, ARRAYSIZE(szTitle));
                    ErrorMessageBox(_hwnd, szTitle, IDS_ERROR_THEME_DELETE, hr, bstrPath, 0);
                }
            }
            else
            {
                int nIndex = ComboBox_GetCurSel(m_hwndThemeCombo);

                IUnknown_SetSite(m_pSelectedTheme, NULL);   // Break any back pointers.
                ATOMICRELEASE(m_pSelectedTheme);    // Indicate that we no longer need to apply anything.
                hr = _RemoveTheme(nIndex);
                if (SUCCEEDED(hr))
                {
                    if (!_GetThemeFile(nIndex))
                    {
                        // Now we want to select the next item in the list.  However we want to avoid
                        // choosing "Browse..." because that will bring up the dialog.
                        for (nIndex = 0; nIndex < ComboBox_GetCount(m_hwndThemeCombo); nIndex++)
                        {
                            if (_GetThemeFile(nIndex))
                            {
                                break;
                            }
                        }
                    }

                    if (_GetThemeFile(nIndex))
                    {
                        // We found something good.
                        ComboBox_SetCurSel(m_hwndThemeCombo, nIndex);
                        _OnThemeChange(_hwnd, FALSE);
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CThemePage::_SaveAs(void)
{
    TCHAR szFileName[MAX_PATH];
    TCHAR szPath[MAX_PATH];

    LoadString(HINST_THISDLL, IDS_DEFAULTTHEMENAME, szFileName, ARRAYSIZE(szFileName));
    HRESULT hr = SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, 0, szPath);
    if (SUCCEEDED(hr) && _punkSite)
    {
        OPENFILENAME ofn = { 0 };
        TCHAR szFilter[MAX_PATH];
        LoadString(HINST_THISDLL, IDS_THEME_FILTER, szFilter, ARRAYSIZE(szFilter)-2);
        
        // Need to ensure the filter string is terminated with \0\0.
        int nLen = lstrlen(szFilter) + 1;
        nLen += lstrlen(&szFilter[nLen]);
        AssertMsg(nLen <= ARRAYSIZE(szFilter) - 2, TEXT("CThemePage::_SaveAs: Filter buffer is not big enough"));
        szFilter[nLen] = szFilter[nLen+1] = 0;

        if (!PathAppend(szPath, szFileName))
        {
            hr = E_FAIL;
        }
        else
        {
            ofn.lStructSize = sizeof(ofn);
            ofn.hwndOwner = _hwnd;
            ofn.hInstance = HINST_THISDLL;
            ofn.lpstrFilter = szFilter;
            ofn.nFilterIndex = 1;
            ofn.lpstrFile = szPath;
            ofn.nMaxFile = ARRAYSIZE(szPath);
            ofn.lpstrDefExt = TEXT("theme");
            ofn.Flags = (OFN_EXPLORER | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_ENABLESIZING);

            // 1. Display SaveAs... dialog
            if (GetSaveFileName(&ofn))
            {
                IPropertyBag * pPropertyBag = NULL;

                hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
                if (SUCCEEDED(hr))
                {
                    ITheme * pTheme;
                    TCHAR szDisplayName[MAX_PATH];
                    HCURSOR old = SetCursor(LoadCursor(NULL, IDC_WAIT));

                    StringCchCopy(szDisplayName, ARRAYSIZE(szDisplayName), PathFindFileName(szPath));
                    PathRemoveExtension(szDisplayName);
                    hr = SnapShotLiveSettingsToTheme(pPropertyBag, szPath, &pTheme);
                    SetCursor(old);

                    if (SUCCEEDED(hr))
                    {
                        CComBSTR bstrName(szDisplayName);

                        Str_SetPtr(&m_pszLastAppledTheme, szPath);
                        hr = pTheme->put_DisplayName(NULL);
                        if (SUCCEEDED(hr))
                        {
                            _ChooseOtherThemeFile(szPath, TRUE);
                        }
                        pTheme->Release();
                    }

                    pPropertyBag->Release();
                }
            }
        }
    }

    return hr;
}


HRESULT CThemePage::_RemoveTheme(int nIndex)
{
    HRESULT hr = E_FAIL;
    LPARAM lParam = ComboBox_GetItemData(m_hwndThemeCombo, nIndex);

    if (CB_ERR != lParam)
    {
        THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) lParam;

        if (pThemeItemBock && (pThemeItemBock != &m_Modified))
        {
            if (eThemeFile == pThemeItemBock->type)
            {
                ATOMICRELEASE(pThemeItemBock->pTheme);
            }
            else if (eThemeURL == pThemeItemBock->type)
            {
                Str_SetPtr(&(pThemeItemBock->pszUrl), NULL);
            }

            LocalFree(pThemeItemBock);
        }

        ComboBox_DeleteString(m_hwndThemeCombo, nIndex);
        _EnableDeleteIfAppropriate();
        hr = S_OK;
    }

    return hr;
}


HRESULT CThemePage::_FreeThemeDropdown(void)
{
    HRESULT hr = S_OK;

    if (m_hwndThemeCombo)
    {
        do
        {
            // Remove the themes fromt he list..
        }
        while (SUCCEEDED(_RemoveTheme(0)));
    }

    return hr;
}


HRESULT IUnknown_GetBackground(IUnknown * punk, LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = E_FAIL;

    if (punk)
    {
        IPropertyBag * ppb;

        hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, &ppb));
        if (SUCCEEDED(hr))
        {
            hr = SHPropertyBag_ReadStr(ppb, SZ_PBPROP_BACKGROUNDSRC_PATH, pszPath, cchSize);
            ppb->Release();
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        This function will determine the currently applied theme.  It will then
    have it selected from the list or select "Custom" if appropriate.

    STATES:
        When the CPL opens, the currently selected .theme can be:
    1. "<Theme Name> (Modified)".  This means the "ThemeFile" regkey will be empty
       and "DisplayName of Modified" will contain the name.  In this case m_pszModifiedName
       will contain that display name.
    2. Any .theme file.  In this case, any .theme file is selected.  "ThemeFile" will
       have the path to the file.
\*****************************************************************************/
HRESULT CThemePage::_LoadCustomizeValue(void)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];
    DWORD cbSize = sizeof(szPath);
    DWORD dwType;

    // See if the user has choosen a value in the past.
    hr = HrRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_LT_THEMEFILE, szPath, ARRAYSIZE(szPath)); 
    if (FAILED(hr))
    {
        // Get the global value.
        hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_LT_THEMEFILE, szPath, ARRAYSIZE(szPath)); 
    }

    if (SUCCEEDED(hr))
    {
        // They have, so we use it as long as nothing has changed (like someone changing the background from the outside)
        TCHAR szWallpaper[MAX_PATH];

        if (szPath[0] &&
            SUCCEEDED(HrRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_LT_WALLPAPER, szWallpaper, ARRAYSIZE(szWallpaper))) &&
            _punkSite)
        {
            TCHAR szCurrWallpaper[MAX_PATH];

            if (SUCCEEDED(IUnknown_GetBackground(_punkSite, szCurrWallpaper, ARRAYSIZE(szCurrWallpaper))))
            {
                PathExpandEnvStringsWrap(szCurrWallpaper, ARRAYSIZE(szCurrWallpaper));
                if (StrCmpI(szCurrWallpaper, szWallpaper))
                {
                    TCHAR szName[MAX_PATH];

                    cbSize = sizeof(szName);
                    if (SUCCEEDED(HrSHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_MODIFIED_DISPNAME, &dwType, (LPVOID) szName, &cbSize)) &&
                        !szName[0])
                    {
                        // We don't have a good custom name so force one now.  This happens when
                        // We have a valid theme but someone makes a modification by using IE to
                        // change the wallpaper.
                        Str_SetPtr(&m_pszLastAppledTheme, szPath);
                        _CustomizeTheme();
                    }

                    // Someone changed the wallpaper outside of our UI so we need to treat the theme as "Customized"
                    szPath[0] = 0;
                }
            }
        }
    }

    if (FAILED(hr))
    {
        // Treat it as customized
        szPath[0] = 0;
    }

    if (!szPath[0])
    {
        TCHAR szName[MAX_PATH];

        szName[0] = 0;
        cbSize = sizeof(szName);
        if (FAILED(HrSHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_MODIFIED_DISPNAME, &dwType, (LPVOID) szName, &cbSize)) || !szName[0])
        {
            LoadString(HINST_THISDLL, IDS_MODIFIED_FALLBACK, szName, ARRAYSIZE(szName));
        }

        Str_SetPtr(&m_pszModifiedName, szName);   // This means the theme is customized.
    }

    Str_SetPtr(&m_pszLastAppledTheme, (szPath[0] ? szPath : NULL));   // This means the theme is customized.

    hr = _HandleCustomizedEntre();
    if (szPath[0])
    {
        // Now we need to select the item from the list.
        hr = _ChooseOtherThemeFile(szPath, TRUE);
    }

    m_fInited = TRUE;
    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        This function is called if someone modified a value in the theme.  Since
    they have modified it, we want the display name to change so:
    a. They know that it's not the same, and
    b. They can switch back if they don't like the modifications.

    This function will create the new Display Name, normally "Football 200 (Modified)"
    and call to have it added to the drop down.
\*****************************************************************************/
HRESULT CThemePage::_CustomizeTheme(void)
{
    // Are we already
    if (m_pszLastAppledTheme)
    {
        Str_SetPtr(&m_pszModifiedName, NULL);

        if (m_pSelectedTheme)
        {
            CComBSTR bstrDisplayName;

            if (SUCCEEDED(m_pSelectedTheme->get_DisplayName(&bstrDisplayName)))
            {
                TCHAR szTemplate[MAX_PATH];
                TCHAR szDisplayName[MAX_PATH];

                LoadStringW(HINST_THISDLL, IDS_MODIFIED_TEMPLATE, szTemplate, ARRAYSIZE(szTemplate));
                StringCchPrintf(szDisplayName, ARRAYSIZE(szDisplayName), szTemplate, bstrDisplayName);
                Str_SetPtr(&m_pszModifiedName, szDisplayName);
            }
        }

        if (!m_pszModifiedName)
        {
            TCHAR szDisplayName[MAX_PATH];

            LoadStringW(HINST_THISDLL, IDS_MODIFIED_FALLBACK, szDisplayName, ARRAYSIZE(szDisplayName));
            Str_SetPtr(&m_pszModifiedName, szDisplayName);
        }

        Str_SetPtr(&m_pszLastAppledTheme, NULL);   // This means the theme is customized.
    }

    return _HandleCustomizedEntre();
}


/*****************************************************************************\
    DESCRIPTION:
        This function will add the "Modified" item to the menu if needed and select
    it.  Or it will remove it if appropriate.
\*****************************************************************************/
HRESULT CThemePage::_HandleCustomizedEntre(void)
{
    HRESULT hr = S_OK;

    // If m_pszLastAppledTheme is NULL, then we want to make sure "<ThemeName> (Modified)" is
    // in the list and is selected.
    if (!m_pszLastAppledTheme)
    {
        // We now know we want one to exist and to select it.
        THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) ComboBox_GetItemData(m_hwndThemeCombo, 0);

        if (m_pszModifiedName)
        {
            // We now need to update the name or add it.
            if (pThemeItemBock && ((THEME_ITEM_BLOCK *)CB_ERR != pThemeItemBock) && (eThemeModified == pThemeItemBock->type))
            {
                // It already exists so we need to update the title to make it up to date.
                _RemoveUserTheme();
                int nIndex = ComboBox_InsertString(m_hwndThemeCombo, 0, m_pszModifiedName);
                if ((CB_ERR != nIndex) && (CB_ERRSPACE != nIndex))
                {
                    if (CB_ERR == ComboBox_SetItemData(m_hwndThemeCombo, 0, &m_Modified))
                    {
                        hr = E_FAIL;
                    }
                }
            }
            else
            {
                // If it isn't found, so add it.
                int nIndex = ComboBox_InsertString(m_hwndThemeCombo, 0, m_pszModifiedName);
                if ((CB_ERR != nIndex) && (CB_ERRSPACE != nIndex))
                {
                    if (CB_ERR == ComboBox_SetItemData(m_hwndThemeCombo, 0, &m_Modified))
                    {
                        hr = E_FAIL;
                    }
                }
            }
        }

        _OnSetSelection(0);
        m_nPreviousSelected = 0;
    }

    return hr;
}


HRESULT CThemePage::_RemoveUserTheme(void)
{
    HRESULT hr = S_OK;
    THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) ComboBox_GetItemData(m_hwndThemeCombo, 0);

    // We now need to update the name or add it.
    if (pThemeItemBock && ((THEME_ITEM_BLOCK *)CB_ERR != pThemeItemBock) && (eThemeModified == pThemeItemBock->type))
    {
        ComboBox_DeleteString(m_hwndThemeCombo, 0);
    }

    return hr;
}


ITheme * CThemePage::_GetThemeFile(int nIndex)
{
    ITheme * pTheme = NULL;
    THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) ComboBox_GetItemData(m_hwndThemeCombo, nIndex);

    if (((THEME_ITEM_BLOCK *)CB_ERR != pThemeItemBock) && pThemeItemBock && (eThemeFile == pThemeItemBock->type))
    {
        pTheme = pThemeItemBock->pTheme;
    }

    return pTheme;
}


LPCWSTR CThemePage::_GetThemeUrl(int nIndex)
{
    LPCWSTR pszUrl = NULL;
    THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) ComboBox_GetItemData(m_hwndThemeCombo, nIndex);

    if (((THEME_ITEM_BLOCK *)CB_ERR != pThemeItemBock) && pThemeItemBock && (eThemeURL == pThemeItemBock->type))
    {
        pszUrl = pThemeItemBock->pszUrl;
    }

    return pszUrl;
}


HRESULT CThemePage::_AddThemeFile(LPCTSTR pszDisplayName, int * pnIndex, ITheme * pTheme)
{
    THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) LocalAlloc(LPTR, sizeof(*pThemeItemBock));
    HRESULT hr = (pThemeItemBock ? S_OK : E_OUTOFMEMORY);

    if (SUCCEEDED(hr))
    {
        int nAddIndex;

        if (!pnIndex)
        {
            nAddIndex = ComboBox_AddString(m_hwndThemeCombo, pszDisplayName);
        }
        else
        {
            nAddIndex = ComboBox_InsertString(m_hwndThemeCombo, *pnIndex, pszDisplayName);
            *pnIndex = nAddIndex;
        }

        pThemeItemBock->type = eThemeFile;
        pThemeItemBock->pTheme = pTheme;
        if ((CB_ERR != nAddIndex) && (CB_ERRSPACE != nAddIndex))
        {
            if (CB_ERR == ComboBox_SetItemData(m_hwndThemeCombo, nAddIndex, pThemeItemBock))
            {
                hr = E_FAIL;
            }
        }
        else
        {
            LocalFree(pThemeItemBock);
        }
    }

    return hr;
}


HRESULT CThemePage::_AddUrl(LPCTSTR pszDisplayName, LPCTSTR pszUrl)
{
    THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) LocalAlloc(LPTR, sizeof(*pThemeItemBock));
    HRESULT hr = (pThemeItemBock ? S_OK : E_OUTOFMEMORY);

    if (SUCCEEDED(hr))
    {
        LPTSTR pszUrlDup = NULL;
        
        Str_SetPtr(&pszUrlDup, pszUrl);
        if (pszUrlDup)
        {
            int nAddIndex = ComboBox_AddString(m_hwndThemeCombo, pszDisplayName);

            pThemeItemBock->type = eThemeURL;
            pThemeItemBock->pszUrl = pszUrlDup;
            if ((CB_ERR != nAddIndex) && (CB_ERRSPACE != nAddIndex))
            {
                ComboBox_SetItemData(m_hwndThemeCombo, nAddIndex, pThemeItemBock);
            }
            else
            {
                LocalFree(pThemeItemBock);
            }
        }
        else
        {
            LocalFree(pThemeItemBock);
        }
    }

    return hr;
}


HRESULT CThemePage::_AddUrls(void)
{
    HKEY hKey;
    DWORD dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_THEME_SITES, 0, KEY_READ, &hKey);
    HRESULT hr = HRESULT_FROM_WIN32(dwError);

    if (SUCCEEDED(hr))
    {
        for (DWORD dwIndex = 0; SUCCEEDED(hr); dwIndex++)
        {
            TCHAR szValue[MAXIMUM_SUB_KEY_LENGTH];

            dwError = RegEnumKey(hKey, dwIndex, szValue, ARRAYSIZE(szValue));
            hr = HRESULT_FROM_WIN32(dwError);

            if (SUCCEEDED(hr))
            {
                TCHAR szURL[MAX_URL_STRING];
                DWORD dwType;
                DWORD cbSize = sizeof(szURL);

                if ((ERROR_SUCCESS == SHGetValue(hKey, szValue, TEXT("URL"), &dwType, (void *)szURL, &cbSize)) &&
                    (REG_SZ == dwType))
                {
                    HKEY hKeyURL;

                    if (ERROR_SUCCESS == RegOpenKeyEx(hKey, szValue, 0, KEY_READ, &hKeyURL))
                    {
                        TCHAR szDisplayName[MAX_PATH];
        
                        if (SUCCEEDED(SHLoadRegUIString(hKeyURL, TEXT("DisplayName"), szDisplayName, ARRAYSIZE(szDisplayName))))
                        {
                            _AddUrl(szDisplayName, szURL);
                        }

                        RegCloseKey(hKeyURL);
                    }
                }

            }
        }

        hr = S_OK;
        RegCloseKey(hKey);
    }

    return hr;
}


BOOL DoesThemeHaveAVisualStyle(ITheme * pTheme)
{
    BOOL fHasVisualStyle = FALSE;
    CComBSTR bstrPath;

    if (SUCCEEDED(pTheme->get_VisualStyle(&bstrPath)) &&
        bstrPath && bstrPath[0])
    {
        fHasVisualStyle = TRUE;
    }

    return fHasVisualStyle;
}


HRESULT CThemePage::_OnInitThemesDlg(HWND hDlg)
{
    HRESULT hr = E_FAIL;

    m_fInInit = TRUE;
    _FreeThemeDropdown();    // Purge any existing items.

    AssertMsg((NULL != _punkSite), TEXT("We need our site pointer in order to save the settings."));
    if (_punkSite)
    {
        IThemeManager * pThemeManager;

        _hwnd = hDlg;
        m_hwndThemeCombo = GetDlgItem(hDlg, IDC_THPG_THEMELIST);
        m_hwndDeleteButton = GetDlgItem(hDlg, IDC_THPG_DELETETHEME);

        hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeManager, &pThemeManager));
        if (SUCCEEDED(hr))
        {
            VARIANT varIndex;
            BOOL fVisualStylesSupported = (QueryThemeServicesWrap() & QTS_AVAILABLE);

            LogStatus("QueryThemeServices() returned %hs\r\n", (fVisualStylesSupported ? "TRUE" : "FALSE"));

            IUnknown_SetSite(m_pSelectedTheme, NULL);   // Break any back pointers.
            ATOMICRELEASE(m_pSelectedTheme);

            varIndex.vt = VT_I4;
            for (varIndex.lVal = 0; SUCCEEDED(hr); varIndex.lVal++)
            {
                ITheme * pTheme;

                hr = pThemeManager->get_item(varIndex, &pTheme);
                if (SUCCEEDED(hr))
                {
                    if (!fVisualStylesSupported && DoesThemeHaveAVisualStyle(pTheme))
                    {
                        // Filter out .theme files if they have a .msstyles file and the
                        // system doesn't currently support visual styles.
                    }
                    else
                    {
                        CComBSTR bstrDisplayName;

                        IUnknown_SetSite(pTheme, _punkSite);
                        hr = pTheme->get_DisplayName(&bstrDisplayName);
                        IUnknown_SetSite(pTheme, NULL); // This prevents leaking the site object.
                        if (SUCCEEDED(hr))
                        {
                            hr = _AddThemeFile(bstrDisplayName, NULL, pTheme);
                            if (SUCCEEDED(hr))
                            {
                                pTheme = NULL;
                            }
                        }
                    }

                    ATOMICRELEASE(pTheme);
                }
            }

            hr = S_OK;

            _UpdatePreview();
            pThemeManager->Release();
        }

        // Add Web URLs
        _AddUrls();

        // Add the "Other..." entre
        WCHAR szOtherTheme[MAX_PATH];
        LoadStringW(HINST_THISDLL, IDS_THEME_OTHER, szOtherTheme, ARRAYSIZE(szOtherTheme));
        ComboBox_AddString(m_hwndThemeCombo, szOtherTheme);

        _LoadCustomizeValue();
        m_nPreviousSelected = ComboBox_GetCurSel(m_hwndThemeCombo);
        if (m_pszThemeLaunched)
        {
            hr = _ChooseOtherThemeFile(m_pszThemeLaunched, FALSE);
            DelayEnableApplyButton(_hwnd);
        }
        _EnableDeleteIfAppropriate();
    }

    m_fInInit = FALSE;
    return hr;
}


#define SZ_EXTENSION            L".Theme"

HRESULT CThemePage::_ChooseOtherThemeFile(IN LPCWSTR pszFile, BOOL fOnlySelect)
{
    HRESULT hr = E_FAIL;

    // Get results and check that it is a valid theme file
    if (!IsValidThemeFile(pszFile))
    {
        TCHAR szErrorMessage[MAX_URL_STRING];
        TCHAR szTitle[MAX_PATH];
        TCHAR szMessage[MAX_URL_STRING];

        // Bad file: post msg before going back to common open
        LoadString(HINST_THISDLL, IDS_ERROR_THEME_INVALID_TITLE, szTitle, ARRAYSIZE(szTitle));
        LoadString(HINST_THISDLL, IDS_ERROR_THEME_INVALID, szErrorMessage, ARRAYSIZE(szErrorMessage));
        StringCchPrintf(szMessage, ARRAYSIZE(szMessage), szErrorMessage, pszFile);

        MessageBox(m_hwndThemeCombo, szMessage, szTitle, (MB_OK | MB_ICONERROR | MB_APPLMODAL));
    }
    else
    {
        // Now we want to:
        int nSlot = -1;
        int nCount = ComboBox_GetCount(m_hwndThemeCombo);
        int nIndex;

        hr = S_OK;

        // 1. Is it in the list already?
        for (nIndex = 0; nIndex < nCount; nIndex++)
        {
            ITheme * pTheme = _GetThemeFile(nIndex);

            if (pTheme)
            {
                CComBSTR bstrPath;

                hr = pTheme->GetPath(VARIANT_TRUE, &bstrPath);
                if (SUCCEEDED(hr))
                {
                    if (!StrCmpIW(bstrPath, pszFile))
                    {
                        // We found it, so stop looking.
                        nSlot = nIndex;
                        break;
                    }
                }
            }
        }

        // 2. If it is not in the list, add it.  We put it on the bottom, right above "Other...".
        if (-1 == nSlot)
        {
            ITheme * pThemeNew;

            hr = CThemeFile_CreateInstance(pszFile, &pThemeNew);
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrDisplayName;

                hr = pThemeNew->get_DisplayName(&bstrDisplayName);
                if (SUCCEEDED(hr))
                {
                    nIndex = ComboBox_GetCount(m_hwndThemeCombo);

                    if (nIndex > 1)
                    {
                        nIndex -= 1;
                    }

                    hr = _AddThemeFile(bstrDisplayName, &nIndex, pThemeNew);
                    nSlot = nIndex;
                }

                if (FAILED(hr))
                {
                    pThemeNew->Release();
                }
            }
        }

        if (-1 != nSlot)
        {
            ComboBox_SetCurSel(m_hwndThemeCombo, nIndex);
            _EnableDeleteIfAppropriate();

            // 3. Select the theme from the list.
            if (CB_ERR != ComboBox_GetItemData(m_hwndThemeCombo, ComboBox_GetCurSel(m_hwndThemeCombo)))
            {
                // Okay, we now know we won't recurse infinitely, so let's recurse.
                hr = _OnThemeChange(_hwnd, fOnlySelect);
            }
            else
            {
                hr = E_FAIL;
                AssertMsg(0, TEXT("We should have correctly selected the item.  Please investiate.  -BryanSt"));
            }
        }
        else
        {
            hr = E_FAIL;
        }
        // POSSIBLE USABILITY REFINEMENT:
        // We want to add this directory to the MRU because it may have other themes or we should allow it to be available later.
    }

    return hr;
}


// This function is isolated in order to reduce stack space.
HRESULT CThemePage::_DisplayThemeOpenErr(LPCTSTR pszOpenFile)
{
    TCHAR szErrorMessage[MAX_PATH];
    TCHAR szTitle[MAX_PATH];
    TCHAR szMessage[MAX_PATH];

    // Bad file: post msg before going back to common open
    LoadString(HINST_THISDLL, IDS_ERROR_THEME_INVALID_TITLE, szTitle, ARRAYSIZE(szTitle));
    LoadString(HINST_THISDLL, IDS_ERROR_THEME_INVALID, szErrorMessage, ARRAYSIZE(szErrorMessage));
    StringCchPrintf(szMessage, ARRAYSIZE(szMessage), szErrorMessage, pszOpenFile);

    MessageBox(m_hwndThemeCombo, szMessage, szTitle, (MB_OK | MB_ICONERROR | MB_APPLMODAL));
    return HRESULT_FROM_WIN32(ERROR_CANCELLED);           // We already displayed an error dialog so don't do it later.
}


HRESULT CThemePage::_OnSelectOther(void)
{
    HRESULT hr = E_FAIL;
    OPENFILENAME ofnOpen = {0};
    WCHAR szOpenFile[MAX_PATH];
    WCHAR szFileSpec[MAX_PATH];
    WCHAR szCurrentDirectory[MAX_PATH];
    WCHAR szTitle[MAX_PATH];

    LoadStringW(HINST_THISDLL, IDS_THEME_OPENTITLE, szTitle, ARRAYSIZE(szTitle));
    LoadStringW(HINST_THISDLL, IDS_THEME_FILETYPE, szFileSpec, ARRAYSIZE(szFileSpec)-2);

    DWORD cchSize = lstrlenW(szFileSpec);
    szFileSpec[cchSize + 1] = szFileSpec[cchSize + 2] = 0;      // Add the double NULLs to the end.
    LPWSTR pszEnd = StrChrW(szFileSpec, L'|');
    if (pszEnd)
    {
        pszEnd[0] = 0;
    }

    DWORD dwError = SHRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_IE_DOWNLOADDIR, SZ_REGVALUE_IE_DOWNLOADDIR, szCurrentDirectory, 0);
    if (ERROR_SUCCESS != dwError)
    {
        SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, 0, szCurrentDirectory);
    }
    hr = E_FAIL;
    do
    {
        StringCchCopy(szOpenFile, ARRAYSIZE(szOpenFile), L"*" SZ_EXTENSION);  // start w/ *.Theme

        ofnOpen.lStructSize = sizeof(OPENFILENAME);
        ofnOpen.hwndOwner = m_hwndThemeCombo;
        ofnOpen.lpstrFilter = szFileSpec;
        ofnOpen.lpstrCustomFilter = NULL;
        ofnOpen.nMaxCustFilter = 0;
        ofnOpen.nFilterIndex = 1;
        ofnOpen.lpstrFile = szOpenFile;
        ofnOpen.nMaxFile = ARRAYSIZE(szOpenFile);
        ofnOpen.lpstrFileTitle = NULL; // szFileTitle;
        ofnOpen.nMaxFileTitle = 0;             // sizeof(szFileTitle);
        ofnOpen.lpstrInitialDir = szCurrentDirectory;
        ofnOpen.lpstrTitle = szTitle;
        ofnOpen.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
        ofnOpen.lpstrDefExt = CharNextW(SZ_EXTENSION);

        // NOTE: We could make the UI much better by providing a OFNHookProc with the CDN_FILEOK flag.  This would allow
        // us to verify the file without closing the dialog.

        // Display the File Open dialog.
        if (!GetOpenFileNameW(&ofnOpen))
        {
            // If they didn't open a file, could be hit cancel but
            // also check for lowmem return

            // select old theme in list
            ComboBox_SetCurSel(m_hwndThemeCombo, m_nPreviousSelected);
            _EnableDeleteIfAppropriate();
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);       // We don't need to display any error dialogs later since the user cancelled.
            break;
        }
        else
        {
            // Get results and check that it is a valid theme file
            if (!IsValidThemeFile(szOpenFile))
            {
                hr = _DisplayThemeOpenErr(szOpenFile);
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    while (FAILED(hr));

    if (SUCCEEDED(hr))
    {
        hr = _ChooseOtherThemeFile(szOpenFile, FALSE);
    }

    return hr;
}


HRESULT CThemePage::_LoadThemeFilterState(void)
{
    HRESULT hr = _InitFilterKey();

    if (SUCCEEDED(hr))
    {
        DWORD dwType;
        WCHAR szEnabled[5];
        DWORD cbSize;

        COMPILETIME_ASSERT(ARRAYSIZE(g_szCBNames) == ARRAYSIZE(m_fFilters));
        for (int nIndex = 0; nIndex < ARRAYSIZE(g_szCBNames); nIndex++)
        {
            m_fFilters[nIndex] = TRUE; // Default to true.
            cbSize = sizeof(szEnabled);

            if (SUCCEEDED(HrRegQueryValueEx(m_hkeyFilter, &(g_szCBNames[nIndex][SIZE_THEME_FILTER_STR]), 0, &dwType, (LPBYTE) szEnabled, &cbSize)) &&
                !StrCmpIW(szEnabled, L"0"))
            {
                m_fFilters[nIndex] = FALSE;
            }
        }
    }

    return hr;
}


HRESULT CThemePage::_SaveThemeFilterState(void)
{
    HRESULT hr = _InitFilterKey();

    if (SUCCEEDED(hr))
    {
        for (int nIndex = 0; nIndex < ARRAYSIZE(g_szCBNames); nIndex++)
        {
            hr = HrRegSetValueString(m_hkeyFilter, NULL, &(g_szCBNames[nIndex][SIZE_THEME_FILTER_STR]), (m_fFilters[nIndex] ? L"1" : L"0"));
        }
    }

    return hr;
}




HRESULT CThemePage::_UpdatePreview(void)
{
    HRESULT hr = S_OK;

    if (!m_pThemePreview)
    {
        hr = CThemePreview_CreateInstance(NULL, IID_PPV_ARG(IThemePreview, &m_pThemePreview));
        if (SUCCEEDED(hr) && _punkSite)
        {
            IPropertyBag * pPropertyBag;

            hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                HWND hwndParent = GetParent(m_hwndThemeCombo);
                HWND hwndPlaceHolder = GetDlgItem(hwndParent, IDC_THPG_THEME_PREVIEW);
                RECT rcPreview;

                AssertMsg((NULL != m_hwndThemeCombo), TEXT("We should have this window at this point.  -BryanSt"));
                GetClientRect(hwndPlaceHolder, &rcPreview);
                MapWindowPoints(hwndPlaceHolder, hwndParent, (LPPOINT)&rcPreview, 2);

                hr = m_pThemePreview->CreatePreview(hwndParent, TMPREV_SHOWBKGND | TMPREV_SHOWICONS | TMPREV_SHOWVS, WS_VISIBLE | WS_CHILDWINDOW | WS_BORDER | WS_OVERLAPPED, WS_EX_CLIENTEDGE, rcPreview.left, rcPreview.top, RECTWIDTH(rcPreview), RECTHEIGHT(rcPreview), pPropertyBag, IDC_THPG_THEME_PREVIEW);
                if (SUCCEEDED(hr))
                {
                    IPropertyBag * pPropertyBag;

                    // If we succeeded, remove the dummy window.
                    DestroyWindow(hwndPlaceHolder);

                    hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
                    if (SUCCEEDED(hr))
                    {
                        hr = SHPropertyBag_WritePunk(pPropertyBag, SZ_PBPROP_PREVIEW1, m_pThemePreview);
                        pPropertyBag->Release();
                    }
                }

                pPropertyBag->Release();
            }
        }
    }
    else if (_punkSite)
    {
        IThemeUIPages * pThemeUIPages;

        hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUIPages));
        if (SUCCEEDED(hr))
        {
            hr = pThemeUIPages->UpdatePreview(0);
        }
        pThemeUIPages->Release();
    }

    return hr;
}


BOOL CThemePage::_IsFiltered(IN DWORD dwFilter)
{
    BOOL fFiltered = FALSE;
    VARIANT varFilter;

    if (SUCCEEDED(Read(g_szCBNames[dwFilter], &varFilter, NULL)) &&
        (VT_BOOL == varFilter.vt))
    {
        fFiltered = (VARIANT_TRUE != varFilter.boolVal);
    }

    return fFiltered;
}


HRESULT CThemePage::_OnDestroy(HWND hDlg)
{
    _FreeThemeDropdown();
    return S_OK;
}


HRESULT CThemePage::_InitScreenSaver(void)
{
    HRESULT hr = S_OK;

    if (!m_pScreenSaverUI)
    {
        ATOMICRELEASE(m_pBackgroundUI);
        ATOMICRELEASE(m_pAppearanceUI);

        hr = E_FAIL;
        if (_punkSite)
        {
            IThemeUIPages * pThemeUI;

            hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUI));
            if (SUCCEEDED(hr))
            {
                IEnumUnknown * pEnumUnknown;

                hr = pThemeUI->GetBasePagesEnum(&pEnumUnknown);
                if (SUCCEEDED(hr))
                {
                    IUnknown * punk;

                    // This may not exit due to policy
                    if (SUCCEEDED(IEnumUnknown_FindCLSID(pEnumUnknown, PPID_ScreenSaver, &punk)))
                    {
                        hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, &m_pScreenSaverUI));
                        punk->Release();
                    }

                    if (SUCCEEDED(hr))
                    {
                        // This may not exit due to policy
                        if (SUCCEEDED(IEnumUnknown_FindCLSID(pEnumUnknown, PPID_Background, &punk)))
                        {
                            hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, &m_pBackgroundUI));
                            punk->Release();
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        // This may not exit due to policy
                        if (SUCCEEDED(IEnumUnknown_FindCLSID(pEnumUnknown, PPID_BaseAppearance, &punk)))
                        {
                            hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, &m_pAppearanceUI));
                            punk->Release();
                        }
                    }

                    pEnumUnknown->Release();
                }

                pThemeUI->Release();
            }
        }
    }

    return hr;
}


LPCWSTR s_Icons[SIZE_ICONS_ARRAY] =
{
    L"CLSID\\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\DefaultIcon:DefaultValue",       // My Computer
    L"CLSID\\{450D8FBA-AD25-11D0-98A8-0800361B1103}\\DefaultIcon:DefaultValue",       // My Documents
    L"CLSID\\{208D2C60-3AEA-1069-A2D7-08002B30309D}\\DefaultIcon:DefaultValue",       // My Network Places
    L"CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\DefaultIcon:full",               // Recycle Bin (Full)
    L"CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\DefaultIcon:empty",              // Recycle Bin (Empty)
};


extern BOOL g_fDoNotInstallThemeWallpaper;     // This is used to not install wallpaper.

HRESULT CThemePage::_OnSetBackground(void)
{
    HRESULT hr = S_OK;

    if (!_IsFiltered(THEMEFILTER_WALLPAPER) &&
        !SHGetRestriction(NULL, POLICY_KEY_ACTIVEDESKTOP, SZ_POLICY_NOCHANGEWALLPAPER) &&
        !g_fDoNotInstallThemeWallpaper)
    {
        // Get the screen saver from the theme and tell the Screen Saver page to use it.
        if (m_pSelectedTheme)
        {
            CComBSTR bstrPath;

            if (FAILED(m_pSelectedTheme->get_Background(&bstrPath)))        // This will fail if the there isn't a wallpaper set.
            {
                bstrPath = L"";
            }

            // This call will fail if the hide background tab policies is enabled.
            if (m_pBackgroundUI && SUCCEEDED(SHPropertyBag_WriteStr(m_pBackgroundUI, SZ_PBPROP_BACKGROUND_PATH, bstrPath)))
            {
                enumBkgdTile nTile = BKDGT_STRECH;
                if (FAILED(m_pSelectedTheme->get_BackgroundTile(&nTile)))
                {
                    nTile = BKDGT_STRECH;   // Default to stretch, it's good for you.
                }

                LPCWSTR pszExtension = PathFindExtensionW(bstrPath);
                // If our wallpaper is an HTML page we need to force stretching on and tiling off
                if (pszExtension &&
                    ((StrCmpIW(pszExtension, L".htm") == 0) ||
                     (StrCmpIW(pszExtension, L".html") == 0)))
                {
                    nTile = BKDGT_STRECH;
                }

                hr = SHPropertyBag_WriteDWORD(m_pBackgroundUI, SZ_PBPROP_BACKGROUND_TILE, nTile);
            }
        }
    }

    return hr;
}


HRESULT CThemePage::_OnSetIcons(void)
{
    HRESULT hr = S_OK;

    if (!_IsFiltered(THEMEFILTER_ICONS) && m_pSelectedTheme && m_pBackgroundUI)
    {
        int nForIndex;

        for (nForIndex = 0; nForIndex < ARRAYSIZE(s_Icons); nForIndex++)
        {
            CComBSTR bstrPath;
            CComBSTR bstrIconString(s_Icons[nForIndex]);

            // We will probably want to reset any blank values to standard windows settings.
            hr = m_pSelectedTheme->GetIcon(bstrIconString, &bstrPath);

            // If the theme file doesn't specify the icon or specified "", we need to 
            // pass "" to SHPropertyBag_WriteStr() so it will delete the regkey.  This will
            // revert the icons back to their default value.

            // We ignore error values because this will fail if the hide background tab
            // policy is enabled
            SHPropertyBag_WriteStr(m_pBackgroundUI, s_Icons[nForIndex], (bstrPath ? bstrPath : L""));
        }
    }

    return hr;
}


HRESULT CThemePage::_OnSetSystemMetrics(void)
{
    HRESULT hr = S_OK;

    if (m_pSelectedTheme)
    {
        CComBSTR bstrPath;
        HRESULT hrVisualStyle;      // S_OK if we loaded a visual style, which is optional.

#ifndef ENABLE_IA64_VISUALSTYLES
        // We use a different regkey for 64bit because we need to leave it off until the pre-Whistler
        // 64-bit release forks from the Whistler code base.
        if (SHRegGetBoolUSValue(SZ_REGKEY_APPEARANCE, SZ_REGVALUE_DISPLAYSCHEMES64, FALSE, FALSE))
        {
            hrVisualStyle = m_pSelectedTheme->get_VisualStyle(&bstrPath);
        }
        else
        {
            hrVisualStyle = E_FAIL;        // In this case, themes are disabled so we ignore that value from the file.
        }
#else // ENABLE_IA64_VISUALSTYLES
        hrVisualStyle = m_pSelectedTheme->get_VisualStyle(&bstrPath);
#endif // ENABLE_IA64_VISUALSTYLES

        if (SUCCEEDED(hrVisualStyle) && m_pAppearanceUI)       // It's fine if this isn't present.
        {
            hrVisualStyle = hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_PATH, bstrPath);
            if (SUCCEEDED(hr))
            {
                hr = m_pSelectedTheme->get_VisualStyleColor(&bstrPath);
                if (SUCCEEDED(hr))
                {
                    hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_COLOR, bstrPath);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_pSelectedTheme->get_VisualStyleSize(&bstrPath);
                        if (SUCCEEDED(hr))
                        {
                            hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_SIZE, bstrPath);
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            IPropertyBag * pPropertyBag;

            hr = m_pSelectedTheme->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                BOOL fHasSysMetricsSections = FALSE;

                // If the .theme file specifies "[IconMetrics]" and "[NonclientMetrics]" sections, then load them.
                // If a .theme file wants to use the values from the visual style, then these should be missing.
                if (SUCCEEDED(SHPropertyBag_ReadBOOL(pPropertyBag, SZ_PBPROP_HASSYSMETRICS, &fHasSysMetricsSections)) &&
                    fHasSysMetricsSections)
                {
                    SYSTEMMETRICSALL systemMetrics = {0};

                    // We want to copy the SYSTEMMETRICSALL structure from the file to the base Appearance page.
                    // If the user has a filter, these are the base values that may not get replaced.
                    hr = SHPropertyBag_ReadByRef(pPropertyBag, SZ_PBPROP_SYSTEM_METRICS, (void *)&systemMetrics, sizeof(systemMetrics));
                    if (SUCCEEDED(hr))
                    {
                        if (FAILED(hrVisualStyle) && m_pAppearanceUI)   // Skip setting the visual style drop down to a placeholder value if we set it to a real value above.
                        {
                            WCHAR szPath[MAX_PATH];

                            bstrPath = L"";
                            hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_PATH, bstrPath);
                            if (SUCCEEDED(hr))
                            {
                                LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME_CANONICAL, szPath, ARRAYSIZE(szPath));
                                hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_COLOR, szPath);
                                if (FAILED(hr))
                                {
                                    // This call will fail on builds with EN+MUI because we fail to give the canonical names in
                                    // the registry.  This is an inherint problem with previous OSs putting the localized name
                                    // in the registry.  We can only upgrade and fix that name to be canonical if the strings we load
                                    // from the registry (MUI) match that in the registry, which are from the base OS language (EN).
                                    LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szPath, ARRAYSIZE(szPath));
                                    hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_COLOR, szPath);

                                    // MUI: We may still fail to select the string.  The user can change MUI languages in such a way
                                    // that we can't upgrade the DisplayName to be MUI complient, and the language in the DLL may
                                    // not match the langauge in the registry.
                                    hr = S_OK;
                                }

                                if (SUCCEEDED(hr))
                                {
                                    LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SIZE_CANONICAL, szPath, ARRAYSIZE(szPath));
                                    hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_SIZE, szPath);
                                    if (FAILED(hr))
                                    {
                                        // This call will fail on builds with EN+MUI because we fail to give the canonical names in
                                        // the registry.  This is an inherint problem with previous OSs putting the localized name
                                        // in the registry.  We can only upgrade and fix that name to be canonical if the strings we load
                                        // from the registry (MUI) match that in the registry, which are from the base OS language (EN).
                                        LoadString(HINST_THISDLL, IDS_SIZE_NORMAL, szPath, ARRAYSIZE(szPath));
                                        hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_SIZE, szPath);

                                        // MUI: We may still fail to select the string.  The user can change MUI languages in such a way
                                        // that we can't upgrade the DisplayName to be MUI complient, and the language in the DLL may
                                        // not match the langauge in the registry.
                                        hr = S_OK;
                                    }
                                }
                            }
                        }

                        // We want to force Flat Menu off because this .theme file does not specify a visual style.
                        // Flat Menu needs to be off because the .theme files can't specify the new system metrics for the
                        // flat menu colors.  Now put the system metrics back.
                        systemMetrics.fFlatMenus = FALSE;
                        SHPropertyBag_WriteByRef(m_pAppearanceUI, SZ_PBPROP_SYSTEM_METRICS, (void *)&systemMetrics);
                    }
                }

                pPropertyBag->Release();
            }
        }
    }

    return hr;
}


HRESULT CThemePage::_OnSetSelection(IN int nIndex)
{
    ComboBox_SetCurSel(m_hwndThemeCombo, nIndex);
    m_pLastSelected = _GetThemeFile(nIndex);
    _EnableDeleteIfAppropriate();

    return S_OK;
}


HRESULT CThemePage::_OnThemeChange(HWND hDlg, BOOL fOnlySelect)
{
    HRESULT hr = S_OK;
    int nIndex = ComboBox_GetCurSel(m_hwndThemeCombo);
    ITheme * pTheme = _GetThemeFile(nIndex);
    ITheme * pThemePrevious = NULL;

    if (-1 == nIndex)
    {
        nIndex = 0;
    }

    IUnknown_Set((IUnknown **)&pThemePrevious, pTheme);
    if (pTheme)
    {
        if (m_pLastSelected != pTheme)   // Don't bother if the selection hasn't changed.
        {
            if (-1 == nIndex)
            {
                nIndex = 0; // The caller may NOT select nothing.
            }

            _RemoveUserTheme();
            Str_SetPtr(&m_pszModifiedName, NULL); // Remove the name so it's generated next time.
            hr = _OnLoadThemeValues(pTheme, fOnlySelect);

            if (!fOnlySelect)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
                _UpdatePreview();
                if (!m_fInInit)
                {
                    DelayEnableApplyButton(hDlg);
                }
            }
        }
    }
    else
    {
        if (!fOnlySelect)
        {
            LPCWSTR pszUrl = _GetThemeUrl(nIndex);

            if (pszUrl)
            {
                HrShellExecute(m_hwndThemeCombo, NULL, pszUrl, NULL, NULL, SW_SHOW);
                ComboBox_SetCurSel(m_hwndThemeCombo, m_nPreviousSelected);
                _EnableDeleteIfAppropriate();
                hr = S_OK;
            }
            else
            {
                // This could be the "Other..." item or the "<UserName>'s Customer Theme".
                // We can find out by seeing if it's the last one.
                if ((ComboBox_GetCount(m_hwndThemeCombo) - 1) == nIndex)
                {
                    // This means that it was the "Other..." entre.
                    hr = _OnSelectOther();
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        m_nPreviousSelected = ComboBox_GetCurSel(m_hwndThemeCombo);
    }
    else
    {
        if (!fOnlySelect)
        {
            if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
            {
                TCHAR szTitle[MAX_PATH];
                CComBSTR bstrPath;

                if (pTheme)
                {
                    pTheme->GetPath(VARIANT_TRUE, &bstrPath);
                }

                LoadString(HINST_THISDLL, IDS_ERROR_THEME_INVALID_TITLE, szTitle, ARRAYSIZE(szTitle));
                if (HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE) == hr)
                {
                    TCHAR szErrMsg[MAX_PATH * 2];
                    TCHAR szTemplate[MAX_PATH * 2];

                    // A common error will be that the service is not running.  Let's customize
                    // that message to make it friendly.
                    LoadString(HINST_THISDLL, IDS_ERROR_THEME_SERVICE_NOTRUNNING, szTemplate, ARRAYSIZE(szTemplate));
                    StringCchPrintf(szErrMsg, ARRAYSIZE(szErrMsg), szTemplate, EMPTYSTR_FORNULL(bstrPath));
                    MessageBox(_hwnd, szErrMsg, szTitle, (MB_OK | MB_ICONERROR));
                }
                else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    TCHAR szErrMsg[MAX_PATH * 2];
                    TCHAR szTemplate[MAX_PATH * 2];

                    // Often a .theme file will be incorrectly installed and we can't find the other files
                    // (like background, screensaver, icons, sounds, etc.).  Let's give a better message.
                    LoadString(HINST_THISDLL, IDS_ERROR_THEME_FILE_NOTFOUND, szTemplate, ARRAYSIZE(szTemplate));
                    StringCchPrintf(szErrMsg, ARRAYSIZE(szErrMsg), szTemplate, EMPTYSTR_FORNULL(bstrPath));
                    MessageBox(_hwnd, szErrMsg, szTitle, (MB_OK | MB_ICONERROR));
                }
                else
                {
                    ErrorMessageBox(_hwnd, szTitle, IDS_ERROR_THEME_LOADFAILED, hr, EMPTYSTR_FORNULL(bstrPath), 0);
                }
            }

            _OnLoadThemeValues(m_pSelectedTheme, TRUE);
            ComboBox_SetCurSel(m_hwndThemeCombo, m_nPreviousSelected);
        }
    }

    IUnknown_Set((IUnknown **)&pThemePrevious, NULL);
    return hr;
}


HRESULT CThemePage::_OnLoadThemeValues(ITheme * pTheme, BOOL fOnlySelect)
{
    HRESULT hr = S_OK;

    if (pTheme)
    {
        if (m_pLastSelected != pTheme)   // Don't bother if the selection hasn't changed.
        {
            IUnknown_SetSite(m_pSelectedTheme, NULL);   // Break any back pointers.
            IUnknown_Set((IUnknown **)&m_pSelectedTheme, pTheme);
            IUnknown_SetSite(m_pSelectedTheme, _punkSite);

            _RemoveUserTheme();
            Str_SetPtr(&m_pszModifiedName, NULL); // Remove the name so it's generated next time.

            if (!fOnlySelect)
            {
                CComBSTR bstrPath;

                hr = _InitScreenSaver();
                if (SUCCEEDED(hr))
                {
                    // Set the Screen Saver: Get the screen saver from the theme and tell the Screen Saver page to use it.
                    if (!_IsFiltered(THEMEFILTER_SCREENSAVER) && 
                        !SHGetRestriction(NULL, POLICY_KEY_SYSTEM, SZ_POLICY_NODISPSCREENSAVERPG) &&
                        !SHGetRestriction(SZ_REGKEY_POLICIES_DESKTOP, NULL, SZ_POLICY_SCREENSAVEACTIVE) &&
                        m_pScreenSaverUI)
                    {
                        m_pSelectedTheme->get_ScreenSaver(&bstrPath);       // If this is not specified, we set the wallpaper to "NONE".
                        hr = SHPropertyBag_WriteStr(m_pScreenSaverUI, SZ_PBPROP_SCREENSAVER_PATH, (bstrPath ? bstrPath : L""));

                        if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
                        {
                            hr = S_OK;
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        // Set the Background:
                        hr = _OnSetBackground();

                        if (SUCCEEDED(hr))
                        {
                            // Set the Icons:
                            hr = _OnSetIcons();

                            if (SUCCEEDED(hr))
                            {
                                // Set the System Metrics:
                                hr = _OnSetSystemMetrics();

                                if (SUCCEEDED(hr))
                                {
                                    hr = m_pSelectedTheme->GetPath(VARIANT_TRUE, &bstrPath);
                                    if (SUCCEEDED(hr))
                                    {
                                        Str_SetPtrW(&m_pszThemeToApply, bstrPath);
                                        Str_SetPtrW(&m_pszLastAppledTheme, bstrPath);
                                        m_pLastSelected = pTheme;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return hr;
}


INT_PTR CThemePage::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    const WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idCtrl)
    {
        case IDC_THPG_THEMESETTINGS:
            _OnOpenAdvSettingsDlg(hDlg);
            break;

        case IDC_THPG_SAVEAS:
            _SaveAs();
            break;

        case IDC_THPG_DELETETHEME:
            _DeleteTheme();
            break;

        case IDC_THPG_THEMELIST:
            if (HIWORD(wParam) == CBN_SELENDOK)
            {
                _OnThemeChange(hDlg, FALSE);
                _EnableDeleteIfAppropriate();
            }
            break;
        default:
            break;
    }

    return fHandled;
}



HRESULT CThemePage::_OnSetActive(HWND hDlg)
{
    return S_OK;
}


HRESULT CThemePage::_OnApply(HWND hDlg, LPARAM lParam)
{
    // Our parent dialog will be notified of the Apply event and will call our
    // IBasePropPage::OnApply() to do the real work.
    return S_OK;
}


// This Property Sheet appear in the top level of the "Display Control Panel".
INT_PTR CThemePage::_ThemeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
            case PSN_SETACTIVE:
                _OnSetActive(hDlg);
                break;
            case PSN_APPLY:
                _OnApply(hDlg, lParam);
                break;

            case PSN_RESET:
                break;
        }
        break;

    case WM_INITDIALOG:
        _OnInitThemesDlg(hDlg);
        break;

    case WM_DESTROY:
        _OnDestroy(hDlg);
        break;

    case WM_QUERYNEWPALETTE:
    case WM_PALETTECHANGED:
        SendDlgItemMessage(hDlg, IDC_THPG_THEME_PREVIEW, message, wParam, lParam);
        return TRUE;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_THEMES, HELP_WM_HELP, (DWORD_PTR) aThemesHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, SZ_HELPFILE_THEMES, HELP_CONTEXTMENU, (DWORD_PTR) aThemesHelpIds);
        break;

    case WM_COMMAND:
        _OnCommand(hDlg, message, wParam, lParam);
        break;

    case WMUSER_DELAYENABLEAPPLY:
        EnableApplyButton(hDlg);
        break;
    }

    return FALSE;
}


HRESULT CThemePage::_PersistState(void)
{
    HRESULT hr = S_OK;

    if (m_fInited)
    {
        LPCWSTR pszValue = (m_pszLastAppledTheme ? m_pszLastAppledTheme : L"");
        TCHAR szCurrWallpaper[MAX_PATH];

        HrRegSetPath(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_LT_THEMEFILE, TRUE, pszValue);
        if (SUCCEEDED(IUnknown_GetBackground(_punkSite, szCurrWallpaper, ARRAYSIZE(szCurrWallpaper))))
        {
            PathUnExpandEnvStringsWrap(szCurrWallpaper, ARRAYSIZE(szCurrWallpaper));
            HrRegSetPath(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_LT_WALLPAPER, TRUE, szCurrWallpaper);
        }

        pszValue = (m_pszModifiedName ? m_pszModifiedName : L"");
        DWORD cbSize = (sizeof(pszValue[0]) * (lstrlen(pszValue) + 1));
        HrSHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_MODIFIED_DISPNAME, REG_SZ, (LPVOID) pszValue, cbSize);
    }

    return hr;
}


HRESULT CThemePage::_ApplyThemeFile(void)
{
    HRESULT hr = S_OK;

    if (m_pszThemeToApply)
    {
        if (m_pSelectedTheme)
        {
            IPropertyBag * pPropertyBag;

            hr = m_pSelectedTheme->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                VARIANT varEmpty;

                VariantInit(&varEmpty);
                // Here we need to apply all the settings in the theme, like: Sounds, Cursors, Webview
                // that haven't been pushed to the other tabs.
                hr = pPropertyBag->Write(SZ_PBPROP_APPLY_THEMEFILE, &varEmpty);
                pPropertyBag->Release();
            }
        }
    }

    return hr;
}


HRESULT CThemePage::_InitFilterKey(void)
{
    HRESULT hr = S_OK;

    if (!m_hkeyFilter)
    {
        hr = HrRegCreateKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_THEME_FILTERS, 0, NULL, 0, (KEY_WRITE | KEY_READ), NULL, &m_hkeyFilter, NULL);
    }

    return hr;
}




//===========================
// *** IPropertyBag Interface ***
//===========================
HRESULT CThemePage::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        // We have a list of "ThemeFilter:" properties for all of the filter values on
        // what part of themes to apply.
        if (!StrCmpNIW(SZ_PBPROP_THEME_FILTER, pszPropName, SIZE_THEME_FILTER_STR))
        {
            pVar->vt = VT_BOOL;
            pVar->boolVal = VARIANT_TRUE;
            for (int nIndex = 0; nIndex < ARRAYSIZE(g_szCBNames); nIndex++)
            {
                if (!StrCmpIW(pszPropName, g_szCBNames[nIndex]))
                {
                    pVar->boolVal = (m_fFilters[nIndex] ? VARIANT_TRUE : VARIANT_FALSE);
                    hr = S_OK;
                    break;
                }
            }
        }
        else if (!StrCmpIW(SZ_PBPROP_THEME_DISPLAYNAME, pszPropName))
        {
            WCHAR szDisplayName[MAX_PATH];
            int nIndex = ComboBox_GetCurSel(m_hwndThemeCombo);

            if ((ARRAYSIZE(szDisplayName) > ComboBox_GetLBTextLen(m_hwndThemeCombo, nIndex)) && 
                (CB_ERR != ComboBox_GetLBText(m_hwndThemeCombo, nIndex, szDisplayName)))
            {
                pVar->vt = VT_BSTR;
                hr = HrSysAllocStringW(szDisplayName, &pVar->bstrVal);
            }
        }
    }

    return hr;
}


HRESULT CThemePage::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_CUSTOMIZE_THEME))
        {
            // We don't care what the variant is.
            // Note that we don't null out m_pSelectedTheme.  This is because we still want to apply it.
            hr = _CustomizeTheme();
        }
        // We have a list of "ThemeFilter:" properties for all of the filter values on
        // what part of themes to apply.
        else if (!StrCmpNIW(SZ_PBPROP_THEME_FILTER, pszPropName, SIZE_THEME_FILTER_STR) &&
                 (VT_BOOL == pVar->vt))
        {
            for (int nIndex = 0; nIndex < ARRAYSIZE(g_szCBNames); nIndex++)
            {
                if (!StrCmpIW(pszPropName, g_szCBNames[nIndex]))
                {
                    m_fFilters[nIndex] = (VARIANT_TRUE == pVar->boolVal);
                    hr = S_OK;
                    break;
                }
            }
        }
        else if ((VT_LPWSTR == pVar->vt) &&
            !StrCmpW(pszPropName, SZ_PBPROP_THEME_LAUNCHTHEME))
        {
            Str_SetPtrW(&m_pszThemeLaunched, pVar->bstrVal);
            m_nPreviousSelected = ComboBox_GetCurSel(m_hwndThemeCombo);
            hr = S_OK;
        }
        else if ((VT_BSTR == pVar->vt) &&
            !StrCmpW(pszPropName, SZ_PBPROP_THEME_LOADTHEME) &&
            pVar->bstrVal)
        {
            ITheme * pTheme;
            
            hr = CThemeFile_CreateInstance(pVar->bstrVal, &pTheme);
            if (SUCCEEDED(hr))
            {
                hr = _OnLoadThemeValues(pTheme, FALSE);
                if (SUCCEEDED(hr) && !m_fInited)
                {
                    m_fInited = TRUE;
                }

                pTheme->Release();
            }
        }
    }

    return hr;
}




//===========================
// *** IBasePropPage Interface ***
//===========================
HRESULT CThemePage::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
#ifdef FEATURE_THEME_SETTINGS_DIALOG
    return CThemeSettingsPage_CreateInstance(ppAdvDialog);

#else // FEATURE_THEME_SETTINGS_DIALOG

    *ppAdvDialog = NULL;
    return S_OK;
#endif // FEATURE_THEME_SETTINGS_DIALOG
}


HRESULT CThemePage::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    HRESULT hr = S_OK;
    HCURSOR old = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if ((PPOAACTION_CANCEL != oaAction))
    {
        hr = _SaveThemeFilterState();
        AssertMsg((NULL != _punkSite), TEXT("We need our site pointer in order to save the settings."));
        if (_IsDirty() && _punkSite)
        {
            // m_pSelectedTheme will be NULL if a Theme wasn't chosen to be applied.
            if (m_pSelectedTheme)
            {
                IPropertyBag * pPropertyBag;

                hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
                if (SUCCEEDED(hr))
                {
                    CComBSTR bstrPath;

                    if (m_pSelectedTheme)
                    {
                        // Persist the filename to the registry.
                        hr = m_pSelectedTheme->GetPath(VARIANT_TRUE, &bstrPath);
                    }

                    hr = SHPropertyBag_WriteStr(pPropertyBag, SZ_PBPROP_THEME_SETSELECTION, bstrPath);
                    pPropertyBag->Release();
                }

                if (SUCCEEDED(hr))
                {
                    hr = _ApplyThemeFile();

                    IUnknown_SetSite(m_pSelectedTheme, NULL);   // Break any back pointers.
                    ATOMICRELEASE(m_pSelectedTheme);    // Indicate that we no longer need to apply anything.
                }
            }
        }

        // We save the Theme selection even if the user didn't change themes.  They may have caused
        // the theme selection to become customized.
        _PersistState();
    }

    SetCursor(old);
    return hr;
}



#define FEATURE_SHOWTHEMEPAGE           TRUE

//===========================
// *** IShellPropSheetExt Interface ***
//===========================
HRESULT CThemePage::AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam)
{
    HRESULT hr = S_OK;

    // Does the policy say to add the Themes Tab?
    if (SHRegGetBoolUSValue(SZ_REGKEY_APPEARANCE, SZ_REGVALUE_DISPLAYTHEMESPG, FALSE, FEATURE_SHOWTHEMEPAGE))
    {
        PROPSHEETPAGE psp = {0};

        psp.dwSize = sizeof(psp);
        psp.hInstance = HINST_THISDLL;
        psp.dwFlags = PSP_DEFAULT;
        psp.lParam = (LPARAM) this;

        psp.pszTemplate = MAKEINTRESOURCE(DLG_THEMESPG);
        psp.pfnDlgProc = CThemePage::ThemeDlgProc;

        HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);
        if (hpsp)
        {
            if (pfnAddPage(hpsp, lParam))
            {
                hr = S_OK;
            }
            else
            {
                DestroyPropertySheetPage(hpsp);
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}



//===========================
// *** IObjectWithSite Interface ***
//===========================
HRESULT CThemePage::SetSite(IN IUnknown * punkSite)
{
    if (!punkSite)
    {
        // We need to break back pointers.
        IUnknown_SetSite(m_pSelectedTheme, NULL);
    }

    return CObjectWithSite::SetSite(punkSite);
}


//===========================
// *** IUnknown Interface ***
//===========================
ULONG CThemePage::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CThemePage::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CThemePage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CThemePage, IObjectWithSite),
        QITABENT(CThemePage, IOleWindow),
        QITABENT(CThemePage, IPersist),
        QITABENT(CThemePage, IPropertyBag),
        QITABENT(CThemePage, IBasePropPage),
        QITABENTMULTI(CThemePage, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CThemePage::CThemePage() : m_cRef(1), CObjectCLSID(&PPID_Theme)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pSelectedTheme);
    ASSERT(!m_pThemePreview);
    ASSERT(!m_pScreenSaverUI);
    ASSERT(!m_pBackgroundUI);
    ASSERT(!m_pAppearanceUI);
    ASSERT(!m_pszThemeToApply);
    ASSERT(!m_hkeyFilter);
    ASSERT(!m_pszLastAppledTheme);
    ASSERT(!m_pszModifiedName);
    ASSERT(!m_hwndDeleteButton);

    m_fInited = FALSE;
    m_fInInit = FALSE;
    m_Modified.type = eThemeModified;
    m_Modified.pszUrl = NULL;

    // Load the Theme Filter state.
    _LoadThemeFilterState();
}


CThemePage::~CThemePage()
{
    IUnknown_SetSite(m_pSelectedTheme, NULL);   // Break any back pointers.

    ATOMICRELEASE(m_pSelectedTheme);
    ATOMICRELEASE(m_pThemePreview);
    ATOMICRELEASE(m_pScreenSaverUI);
    ATOMICRELEASE(m_pBackgroundUI);
    ATOMICRELEASE(m_pAppearanceUI);

    Str_SetPtrW(&m_pszLastAppledTheme, NULL);
    Str_SetPtrW(&m_pszModifiedName, NULL);
    Str_SetPtrW(&m_pszThemeToApply, NULL);
    Str_SetPtrW(&m_pszThemeLaunched, NULL);

    if (m_hkeyFilter)
    {
        RegCloseKey(m_hkeyFilter);
    }

    DllRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\themeutils.cpp ===
/*****************************************************************************\
    FILE: themeutils.cpp

    DESCRIPTION:
        This class will load and save the "Theme" settings from their persisted
    state.

    BryanSt 5/26/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "ThemePg.h"
#include "ThemeFile.h"




// Determine if we need to get this value from the effects tab.
BOOL g_bGradient = TRUE;

BOOL g_bReadOK, g_bWroteOK;             // Save: read from reg/sys, write to file
                                    // Apply: not implemented since ignoring results anyway

#define MAX_MSGLEN   512         // TRANSLATORS: English strs max 256
                                 // MAX_MSGLEN must be at least 2xMAX_STRLEN
                                 // MAX_MSGLEN must be at least 2xMAX_PATH

TCHAR szCurDir[MAX_PATH+1];    // last dir opened a theme file from

TCHAR szMsg[MAX_MSGLEN+1];        // scratch buffer


//
// *Path
//
// These routines help to make themes transportable between computers.
// The problem is that the registry keeps filenames for the various
// theme elements and, of course, these are hard-coded paths that vary
// from machine to machine.
//
// The way we work around this problem is by storing filenames in the
// theme file as _relative_ paths: relative to the theme file directory
// or the Windows directory. (Actually, these routines are set up to
// be relative to any number of directories.) When saving a filename to
// a theme, we check to see if any relative paths can be abstracted out.
// When retrieving a filename from a theme, we take the abstract placeholder
// and replace it with the current sessions instances.

// these must parallel each other. abstract strs must start with %
void ExpandSZ(LPTSTR pszSrc, int cchSize)
{
    LPTSTR pszTmp = (LPTSTR)LocalAlloc(GPTR, (MAX_PATH * sizeof(TCHAR)));
    if (pszTmp)
    {
       if (ExpandEnvironmentStrings(pszSrc, pszTmp, MAX_PATH))
       {
          StringCchCopy(pszSrc, cchSize, pszTmp);
       }

       LocalFree(pszTmp);
    }
}


// HandGet
//
// Just a little helper routine, gets an individual string value from the 
// registry and returns it to the caller. Takes care of registry headaches,
// including a paranoid length check before getting the string.
//
// NOTE that this function thinks it's getting a string value. If it's
// another kind, this function will do OK: but the caller may be surprised
// if expecting a string.
//
// Returns: success of string retrieval
BOOL HandGet(HKEY hKeyRoot, LPTSTR lpszSubKey, LPTSTR lpszValName, LPTSTR lpszRet)
{
    LONG lret;
    HKEY hKey;                       // cur open key
    BOOL bOK = TRUE;
    DWORD dwSize = 0;
    DWORD dwType;

    // inits
    // get subkey
    lret = RegOpenKeyEx( hKeyRoot, lpszSubKey,
        (DWORD)0, KEY_QUERY_VALUE, (PHKEY)&hKey );
    if (lret != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    // now do our paranoid check of data size
    lret = RegQueryValueEx(hKey, lpszValName,
        (LPDWORD)NULL,
        (LPDWORD)&dwType,
        (LPBYTE)NULL,  // null for size info only
        (LPDWORD)&dwSize );
    
    if (ERROR_SUCCESS == lret)
    {     // saw something there
        // here's the size check before getting the data
        if (dwSize > (DWORD)(MAX_PATH * sizeof(TCHAR)))
        { // if string too big
            bOK = FALSE;               // can't read, so very bad news
            g_bReadOK = FALSE;
        }
        else
        {                        // size is OK to continue
            // now really get the value
            lret = RegQueryValueEx(hKey, lpszValName,
                (LPDWORD)NULL,
                (LPDWORD)&dwType,
                (LPBYTE)lpszRet, // getting actual value
                (LPDWORD)&dwSize);
            
            if (ERROR_SUCCESS == lret)
            {
                // If this is an EXPAND_SZ we need to expand it...
                if (REG_EXPAND_SZ == dwType)
                {
                    ExpandSZ(lpszRet, MAX_PATH);
                }
            }
            else
            {            
                bOK = FALSE;
            }
        }
    }
    else
    {
        bOK = FALSE;
    }

    // cleanup
    // close subkey
    RegCloseKey(hKey);

    return (bOK);
}


HRESULT _GetPlus98ThemesDir(LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_REGKEY_PLUS98DIR, SZ_REGVALUE_PLUS98DIR, pszPath, cchSize);
    if (SUCCEEDED(hr))
    {
        TCHAR szSubDir[MAX_PATH];

        LoadString(HINST_THISDLL, IDS_THEMES_SUBDIR, szSubDir, ARRAYSIZE(szSubDir));

        if (!PathAppend(pszPath, szSubDir))
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


HRESULT _GetPlus95ThemesDir(LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_REGKEY_PLUS95DIR, SZ_REGVALUE_PLUS98DIR, pszPath, cchSize);
    if (SUCCEEDED(hr))
    {
        TCHAR szSubDir[MAX_PATH];

        LPTSTR pszFile = PathFindFileName(pszPath);
        if (pszFile)
        {
            // Plus!95 DestPath has "Plus!.dll" on the end so get rid of that.
            pszFile[0] = 0;
        }

        // Tack on a "Themes" onto the path
        LoadString(HINST_THISDLL, IDS_THEMES_SUBDIR, szSubDir, ARRAYSIZE(szSubDir));

        if (!PathAppend(pszPath, szSubDir))
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


HRESULT _GetKidsThemesDir(LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_REGKEY_KIDSDIR, SZ_REGVALUE_KIDSDIR, pszPath, cchSize);
    if (SUCCEEDED(hr))
    {
        TCHAR szSubDir[MAX_PATH];

        // Tack a "\Plus! for Kids\Themes" onto the path
        if (!PathAppend(pszPath, TEXT("Plus! for Kids")))
        {
            hr = E_FAIL;
        }
        
        if (SUCCEEDED(hr))
        {
            LoadString(HINST_THISDLL, IDS_THEMES_SUBDIR, szSubDir, ARRAYSIZE(szSubDir));
    
            if (!PathAppend(pszPath, szSubDir))
            {
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


HRESULT _GetHardDirThemesDir(LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_REGKEY_PROGRAMFILES, SZ_REGVALUE_PROGRAMFILESDIR, pszPath, cchSize);
    if (SUCCEEDED(hr))
    {
        TCHAR szSubDir[MAX_PATH];

        if (!PathAppend(pszPath, TEXT("Plus!")))
        {
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            LoadString(HINST_THISDLL, IDS_THEMES_SUBDIR, szSubDir, ARRAYSIZE(szSubDir));

            if (!PathAppend(pszPath, szSubDir))
            {
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        Find any one of the directories that a previous plus pack may have
    installed.  This may include Plus! 95, 98, kids, etc.
\*****************************************************************************/
HRESULT GetPlusThemeDir(IN LPTSTR pszPath, IN int cchSize)
{
    HRESULT hr = S_OK;

    // The follwoing directories can contain themes:
    //   Plus!98 Install Path\Themes
    //   Plus!95 Install Path\Themes
    //   Kids for Plus! Install Path\Themes
    //   Program Files\Plus!\Themes
    hr = _GetPlus98ThemesDir(pszPath, cchSize);
    if (FAILED(hr))
    {
        hr = _GetPlus95ThemesDir(pszPath, cchSize);
        if (FAILED(hr))
        {
            hr = _GetKidsThemesDir(pszPath, cchSize);
            if (FAILED(hr))
            {
                hr = _GetHardDirThemesDir(pszPath, cchSize);
            }
        }
    }

    return hr;
}




TCHAR g_szThemeDir[MAX_PATH];  // dir of most theme files
TCHAR g_szWinDir[MAX_PATH];    // Windows directory

LPTSTR g_pszThemeValues[] = {g_szThemeDir, g_szWinDir, g_szWinDir};
LPCTSTR g_pszThemeTokens[] = {TEXT("%ThemeDir%"),   TEXT("%WinDir%"),  TEXT("%SystemRoot%")};

void ReplaceStringToken(IN LPCTSTR pszSource, IN LPCTSTR pszToken, IN LPCTSTR pszReplacement, IN LPTSTR pszDest, IN int cchSize)
{
    LPCTSTR pszLastPart = &pszSource[lstrlen(pszToken)];

    if (L'\\' == pszLastPart[0])
    {
        pszLastPart++;          // Skip past any slashes
    }

    StringCchCopy(pszDest, cchSize, pszReplacement);
    PathAppend(pszDest, pszLastPart);
}

/*****************************************************************************\
    DESCRIPTION:
        Find any tokens in the path (%ThemeDir%, %WinDir%) and replace them
    with the correct paths.
\*****************************************************************************/
HRESULT ExpandThemeTokens(IN LPCTSTR pszThemeFile, IN LPTSTR pszPath, IN int cchSize)
{
    HRESULT hr = S_OK;
    int nIndex;
    TCHAR szFinalPath[MAX_PATH];
    TCHAR szOriginalPath[MAX_PATH];

    szFinalPath[0] = 0;
    StringCchCopy(szFinalPath, ARRAYSIZE(szFinalPath), pszPath);
    StringCchCopy(szOriginalPath, ARRAYSIZE(szOriginalPath), pszPath);

    InitFrost();
    AssertMsg((0 != g_szThemeDir[0]), TEXT("Someone needs to call InitFrost() first to in this."));
    AssertMsg((0 != g_szWinDir[0]), TEXT("Someone needs to call InitFrost() first to in this."));

    for (nIndex = 0; nIndex < ARRAYSIZE(g_pszThemeTokens); nIndex++)
    {
        if (!StrCmpNI(g_pszThemeTokens[nIndex], szFinalPath, lstrlen(g_pszThemeTokens[nIndex]) - 1))
        {
            // We found the token to replace.
            TCHAR szTempPath[MAX_PATH];

            StringCchCopy(szTempPath, ARRAYSIZE(szTempPath), szFinalPath);
            ReplaceStringToken(szTempPath, g_pszThemeTokens[nIndex], g_pszThemeValues[nIndex], szFinalPath, ARRAYSIZE(szFinalPath));
            if ((0 == nIndex) && !PathFileExists(szFinalPath))
            {
                // Sometimes the .theme file will not be in the Theme directory, so we need to try
                // the directory containing the .theme file.
                TCHAR szThemeDir[MAX_PATH];

                StringCchCopy(szThemeDir, ARRAYSIZE(szThemeDir), pszThemeFile);
                PathRemoveFileSpec(szThemeDir);
                StringCchCopy(szTempPath, ARRAYSIZE(szTempPath), szOriginalPath);
                ReplaceStringToken(szTempPath, g_pszThemeTokens[nIndex], szThemeDir, szFinalPath, ARRAYSIZE(szFinalPath));
            }
            else
            {
                // It worked
            }

            hr = S_OK;
            break;
        }
    }

    if (0 == SHExpandEnvironmentStringsForUserW(NULL, szFinalPath, pszPath, cchSize))
    {
        StringCchCopy(pszPath, cchSize, szFinalPath);
    }

    return hr;
}


//
// ConfirmFile
//
// This function does the "smart" file searching that's supposed to be
// built into each resource file reference in applying themes.
//
// First see if the full pathname + file given actually exists.
// If it does not, then try looking for the same filename (stripped from path)
// in other standard directories, in this order:
//    Current Theme file directory
//    Theme switcher THEMES subdirectory
//    Windows directory
//    Windows/MEDIA directory
//    Windows/CURSORS directory
//    Windows/SYSTEM directory
//
// Input: LPTSTR lpszPath     full pathname 
//        BOOL  bUpdate       whether to alter the filename string with found file
// Returns: int flag telling if and how file has been confirmed
//              CF_EXISTS   pathname passed in was actual file
//              CF_FOUND    file did not exist, but found same filename elsewhere
//              CF_NOTFOUND file did not exist, could not find elsewhere
//          
int ConfirmFile(IN LPTSTR lpszPath, IN BOOL bUpdate)
{
    TCHAR szWork[MAX_PATH+1];
    TCHAR szTest[MAX_PATH+1];
    int iret = CF_NOTFOUND;          // default value
    LPTSTR lpFile;
    LPTSTR lpNumber;
    HANDLE hTest;

    // special case easy return: if it's null, then trivially satisfied.
    if (!*lpszPath)
        return CF_EXISTS;  // NO WORK EXIT

    // Inits
    // copy pathname to a work string for the function
    StringCchCopy(szWork, ARRAYSIZE(szWork), lpszPath);

    // input can be of the form foo.dll,13. need to strip off that comma,#
    // but hold onto it to put back at the end if we change the pathname
    lpNumber = StrChr(szWork, TEXT(','));
    if (lpNumber && *lpNumber)
    {
        // if there is a comma
        lpFile = lpNumber;            // temp
        lpNumber = CharNext(lpNumber);// hold onto number
        *lpFile = 0;
    }

    // TODO: In Longhorn we should call SHPathPrepareForWrite() in case
    //       szWork is stored on removable media that the user should insert.

    // Do the checks
    // *** first check if the given file just exists as is
    hTest = CreateFile(szWork, GENERIC_READ, FILE_SHARE_READ,
        (LPSECURITY_ATTRIBUTES)NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
    if (hTest != INVALID_HANDLE_VALUE)
    {
        // success
        iret = CF_EXISTS;             // assign ret value
        // don't need to worry about bUpdate: found with input string
    }
    else            // otherwise, let's go searching for the same filename in other dirs
    {
        // get ptr to the filename separated from the path
        lpFile = PathFindFileName(szWork);

        // *** try the cur theme file dir
        StringCchPrintf(szTest, ARRAYSIZE(szTest), TEXT("%s%s"), szCurDir, lpFile);
        hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
            (LPSECURITY_ATTRIBUTES)NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
        if (hTest != INVALID_HANDLE_VALUE)
        {   // success
            iret = CF_FOUND;           // assign ret value
        }
        else    // *** otherwise try the Theme switcher THEMES subdirectory
        {
            StringCchPrintf(szTest, ARRAYSIZE(szTest), TEXT("%s%s"), g_szThemeDir, lpFile);
            hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
                (LPSECURITY_ATTRIBUTES)NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
            if (hTest != INVALID_HANDLE_VALUE)
            {   // success
                iret = CF_FOUND;           // assign ret value
            }
            else            // *** otherwise try the win dir
            {
                StringCchPrintf(szTest, ARRAYSIZE(szTest), TEXT("%s%s"), g_szWinDir, lpFile);
                hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
                    (LPSECURITY_ATTRIBUTES)NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                if (hTest != INVALID_HANDLE_VALUE)
                {   // success
                    iret = CF_FOUND;           // assign ret value
                }
                else                    // *** otherwise try the win/media dir
                {
                    // can get this one directly from Registry
                    HandGet(HKEY_LOCAL_MACHINE,
                        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"),
                        TEXT("MediaPath"), szTest);

                    StringCchCat(szTest, ARRAYSIZE(szTest), TEXT("\\"));
                    StringCchCat(szTest, ARRAYSIZE(szTest), lpFile);

                    hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
                        (LPSECURITY_ATTRIBUTES)NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                    if (hTest != INVALID_HANDLE_VALUE)
                    {   // success
                        iret = CF_FOUND;           // assign ret value
                    }
                    else      // *** otherwise try the win/cursors dir
                    {
                        StringCchPrintf(szTest, ARRAYSIZE(szTest), TEXT("%sCURSORS\\%s"), g_szWinDir, lpFile);
                        hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
                            (LPSECURITY_ATTRIBUTES)NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                        if (hTest != INVALID_HANDLE_VALUE)
                        {   // success
                            iret = CF_FOUND;           // assign ret value
                        }
                        else    // *** otherwise try the win/system dir
                        {
                            StringCchPrintf(szTest, ARRAYSIZE(szTest), TEXT("%sSYSTEM\\%s"), g_szWinDir, lpFile);
                            hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
                                (LPSECURITY_ATTRIBUTES)NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                            if (hTest != INVALID_HANDLE_VALUE)
                            {   // success
                                iret = CF_FOUND;           // assign ret value
                            }
                            else    // *** otherwise try the win/system32 dir
                            {
                                StringCchPrintf(szTest, ARRAYSIZE(szTest), TEXT("%sSYSTEM32\\%s"), g_szWinDir, lpFile);

                                hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
                                    (LPSECURITY_ATTRIBUTES)NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                                if (hTest != INVALID_HANDLE_VALUE)
                                {   // success
                                    iret = CF_FOUND;           // assign ret value
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // if found anywhere other than orig, copy found path/str as requested
        if ((iret == CF_FOUND) && bUpdate)
        {
            StringCchCopy(lpszPath, MAX_PATH, szTest);
            // if we stripped off a number, let's add it back on
            if (lpNumber && *lpNumber)
            {
                StringCchCat(lpszPath, MAX_PATH, TEXT(","));
                StringCchCat(lpszPath, MAX_PATH, lpNumber);
            }
        }  // endif found file by searching
   }
   
   // cleanup
   if (iret != CF_NOTFOUND)
       CloseHandle(hTest);           // close file if opened

   return (iret);
}


// InitFrost
// Since there are no window classes to register, this routine just loads
// the strings and, since there's only one instance, calls InitInstance().
//
// Returns: success of initialization
void InitFrost(void)
{
    static BOOL s_fInited = FALSE;

    if (FALSE == s_fInited)
    {
        BOOL bret;
        HDC hdc;

        s_fInited = TRUE;

        if (!GetWindowsDirectory(g_szWinDir, ARRAYSIZE(g_szWinDir)))
        {
            g_szWinDir[0] = 0;
        }

        if (FAILED(GetPlusThemeDir(g_szThemeDir, ARRAYSIZE(g_szThemeDir))))
        {
            StringCchCopy(g_szThemeDir, ARRAYSIZE(g_szThemeDir), g_szWinDir);
        }

        // Initialize our g_bGradient flag
        // We may need to get the g_bGradient flag from the Effects tab.
        hdc = GetDC(NULL);
        g_bGradient = (BOOL)(GetDeviceCaps(hdc, BITSPIXEL) > 8);
        ReleaseDC(NULL, hdc);
    
        // init directory strings
        szCurDir[0];

        // default current dir
        StringCchCopy(szCurDir, ARRAYSIZE(szCurDir), g_szThemeDir);
    
        // Windows directory
        if (TEXT('\\') != g_szWinDir[lstrlen(g_szWinDir)-1])
        {
            StringCchCat(g_szWinDir, ARRAYSIZE(g_szWinDir), TEXT("\\"));
        }
    
        // see if there is a previous theme file to return to
        bret = HandGet(HKEY_CURRENT_USER, SZ_REGKEY_CURRENTTHEME, NULL, szMsg);
        if (bret)
        {
            // get init cur dir from prev theme file
            StringCchCopy(szCurDir, ARRAYSIZE(szCurDir), szMsg);
            PathFindFileName(szCurDir)[0] = 0;
        }
    }
}


// ascii to integer conversion routine
//

// ***DEBUG*** int'l: is this true? 
// These don't need to be UNICODE/international ready, since they
// *only* deal with strings from the Registry and our own private
// INI files.

/* CAREFUL!! This atoi just IGNORES non-numerics like decimal points!!! */
/* checks for (>=1) leading negative sign */
int latoi(LPSTR s)
{
   int n;
   LPSTR pS;
   BOOL bSeenNum;
   BOOL bNeg;

   n=0;
   bSeenNum = bNeg = FALSE;

   for (pS=s; *pS; pS++) {
      if ((*pS >= '0') && (*pS <= '9')) {
         bSeenNum = TRUE;
         n = n*10 + (*pS - '0');
      }
      if (!bSeenNum && (*pS == '-')) {
         bNeg = TRUE;
      }
   }

   if (bNeg) {
      n = -n;
   }
   
   return(n);
}


//
// Utility routine for above; takes ASCII string to binary in 
// global pValue[] buffer.
//
// Since the values this guy is manipulating is purely ASCII
// numerics we should be able to get away with this char pointer
// arithmetic.  If they were not simple ASCII numerics I think
// we could get into trouble with some DBCS chars
//
// Uses: writes binary data to global pValue[]
//
int WriteBytesToBuffer(IN LPTSTR pszInput, IN void * pOut, IN int cbSize)
{
   LPTSTR lpszCur, lpszNext, lpszEnd;
   BYTE * pbCur = (BYTE *)pOut;
   int iTemp, iBytes;
   CHAR szTempA[10];

   // inits
   lpszNext = pszInput;
   iBytes = 0;
   lpszEnd = pszInput + lstrlen(pszInput);   // points to null term

   // translating loop
   while (*lpszNext && (lpszNext < lpszEnd) && (iBytes < cbSize))
   {
      // update str pointers
      // hold onto your starting place
      lpszCur = lpszNext;
      // advance pointer to next and null terminate cur
      while ((TEXT(' ') != *lpszNext) && *lpszNext) { lpszNext++; }
      *lpszNext = 0;    lpszNext++;
      // on last number, this leaves lpszNext pointing past lpszEnd

      // translate this string-number into binary number and place in
      // output buffer.
      wcstombs(szTempA, lpszCur, sizeof(szTempA));
      iTemp = latoi(szTempA);
      *pbCur = (BYTE)iTemp;
      pbCur++;                      // incr byte loc in output buffer

      // keep track of your bytes
      iBytes++;
   }

   //
   // cleanup
   return (iBytes);
}


HRESULT ConvertBinaryToINIByteString(BYTE * pBytes, DWORD cbSize, LPWSTR * ppszStringOut)
{
    HRESULT hr = E_OUTOFMEMORY;

    DWORD cbOut = sizeof(WCHAR) * ((4 * cbSize) + 1);
    *ppszStringOut = (LPWSTR)LocalAlloc(LPTR, cbOut);
    if (*ppszStringOut)
    {
        LPWSTR pszCurrent = *ppszStringOut;
        DWORD dwIndex;
        TCHAR szTemp[10];

        for (dwIndex = 0; dwIndex < cbSize; dwIndex++)
        {
            StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT("%d "), pBytes[dwIndex]);
            StringCbCopy(pszCurrent, cbOut, szTemp);
            pszCurrent += lstrlen(szTemp);
        }

        hr = S_OK;
    }

    return hr;
}


void ConvertLogFontToWIDE(LPLOGFONTA aLF, LPLOGFONTW wLF)
{
   ZeroMemory(wLF, sizeof(wLF));
   wLF->lfHeight = aLF->lfHeight;
   wLF->lfWidth = aLF->lfWidth;
   wLF->lfEscapement = aLF->lfEscapement;
   wLF->lfOrientation = aLF->lfOrientation;
   wLF->lfWeight = aLF->lfWeight;
   wLF->lfItalic = aLF->lfItalic;
   wLF->lfUnderline = aLF->lfUnderline;
   wLF->lfStrikeOut = aLF->lfStrikeOut;
   wLF->lfCharSet = aLF->lfCharSet;
   wLF->lfOutPrecision = aLF->lfOutPrecision;
   wLF->lfClipPrecision = aLF->lfClipPrecision;
   wLF->lfQuality = aLF->lfQuality;
   wLF->lfPitchAndFamily = aLF->lfPitchAndFamily;

   MultiByteToWideChar(CP_ACP, 0, aLF->lfFaceName, -1, wLF->lfFaceName, LF_FACESIZE);
}


void ConvertIconMetricsToWIDE(LPICONMETRICSA aIM, LPICONMETRICSW wIM)
{
   ZeroMemory(wIM, sizeof(wIM));

   wIM->cbSize = sizeof(*wIM);
   wIM->iHorzSpacing = aIM->iHorzSpacing;
   wIM->iVertSpacing = aIM->iVertSpacing;
   wIM->iTitleWrap = aIM->iTitleWrap;
   ConvertLogFontToWIDE(&aIM->lfFont, &wIM->lfFont);
}


void ConvertNCMetricsToWIDE(LPNONCLIENTMETRICSA aNCM, LPNONCLIENTMETRICSW wNCM)
{
   ZeroMemory(wNCM, sizeof(wNCM));

   wNCM->cbSize = sizeof(*wNCM);
   wNCM->iBorderWidth = aNCM->iBorderWidth;
   wNCM->iScrollWidth = aNCM->iScrollWidth;
   wNCM->iScrollHeight = aNCM->iScrollHeight;
   wNCM->iCaptionWidth = aNCM->iCaptionWidth;
   wNCM->iCaptionHeight = aNCM->iCaptionHeight;
   ConvertLogFontToWIDE(&aNCM->lfCaptionFont, &wNCM->lfCaptionFont);
   wNCM->iSmCaptionWidth = aNCM->iSmCaptionWidth;
   wNCM->iSmCaptionHeight = aNCM->iSmCaptionHeight;
   ConvertLogFontToWIDE(&aNCM->lfSmCaptionFont, &wNCM->lfSmCaptionFont);
   wNCM->iMenuWidth = aNCM->iMenuWidth;
   wNCM->iMenuHeight = aNCM->iMenuHeight;
   ConvertLogFontToWIDE(&aNCM->lfMenuFont, &wNCM->lfMenuFont);
   ConvertLogFontToWIDE(&aNCM->lfStatusFont, &wNCM->lfStatusFont);
   ConvertLogFontToWIDE(&aNCM->lfMessageFont, &wNCM->lfMessageFont);
}


void ConvertLogFontToANSI(LPLOGFONTW wLF, LPLOGFONTA aLF)
{
   ZeroMemory(aLF, sizeof(aLF));
   aLF->lfHeight = wLF->lfHeight;
   aLF->lfWidth = wLF->lfWidth;
   aLF->lfEscapement = wLF->lfEscapement;
   aLF->lfOrientation = wLF->lfOrientation;
   aLF->lfWeight = wLF->lfWeight;
   aLF->lfItalic = wLF->lfItalic;
   aLF->lfUnderline = wLF->lfUnderline;
   aLF->lfStrikeOut = wLF->lfStrikeOut;
   aLF->lfCharSet = wLF->lfCharSet;
   aLF->lfOutPrecision = wLF->lfOutPrecision;
   aLF->lfClipPrecision = wLF->lfClipPrecision;
   aLF->lfQuality = wLF->lfQuality;
   aLF->lfPitchAndFamily = wLF->lfPitchAndFamily;

   SHUnicodeToAnsi(wLF->lfFaceName, aLF->lfFaceName, ARRAYSIZE(aLF->lfFaceName));
}

void ConvertNCMetricsToANSI(LPNONCLIENTMETRICSW wNCM, LPNONCLIENTMETRICSA aNCM)
{
   ZeroMemory(aNCM, sizeof(aNCM));

   aNCM->cbSize = sizeof(*aNCM);
   aNCM->iBorderWidth = wNCM->iBorderWidth;
   aNCM->iScrollWidth = wNCM->iScrollWidth;
   aNCM->iScrollHeight = wNCM->iScrollHeight;
   aNCM->iCaptionWidth = wNCM->iCaptionWidth;
   aNCM->iCaptionHeight = wNCM->iCaptionHeight;
   ConvertLogFontToANSI(&wNCM->lfCaptionFont, &aNCM->lfCaptionFont);
   aNCM->iSmCaptionWidth = wNCM->iSmCaptionWidth;
   aNCM->iSmCaptionHeight = wNCM->iSmCaptionHeight;
   ConvertLogFontToANSI(&wNCM->lfSmCaptionFont, &aNCM->lfSmCaptionFont);
   aNCM->iMenuWidth = wNCM->iMenuWidth;
   aNCM->iMenuHeight = wNCM->iMenuHeight;
   ConvertLogFontToANSI(&wNCM->lfMenuFont, &aNCM->lfMenuFont);
   ConvertLogFontToANSI(&wNCM->lfStatusFont, &aNCM->lfStatusFont);
   ConvertLogFontToANSI(&wNCM->lfMessageFont, &aNCM->lfMessageFont);
}


HRESULT GetIconMetricsFromSysMetricsAll(SYSTEMMETRICSALL * pSystemMetrics, LPICONMETRICSA pIconMetrics, DWORD cchSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pIconMetrics && (sizeof(*pIconMetrics) == cchSize))
    {
        ZeroMemory(pIconMetrics, sizeof(*pIconMetrics));

        pIconMetrics->cbSize = sizeof(*pIconMetrics);
        SystemParametersInfoA(SPI_GETICONMETRICS, sizeof(*pIconMetrics), pIconMetrics, 0);

        ConvertLogFontToANSI(&pSystemMetrics->schemeData.lfIconTitle, &pIconMetrics->lfFont);

        hr = S_OK;
    }

    return hr;
}

//
// TransmitFontCharacteristics
//
// This is actually a pretty key function. See, font characteristics are
// all set together: a LOGFONT has name and style and size info all in one.
// But when you are setting all the nonclient metrics like window caption
// and menu size, you need to stretch the font sizes with it. But we give the
// user a choice of changing window sizes without "changing" the font; i.e.
// without applying a new font name and style from the theme.
//
// So we need to be able to pick apart the name and style from the size
// characteristics. And here it is.
//
// Really just a helper routine for the above function, so we don't have all
// this gunk inline five times.
//
void TransmitFontCharacteristics(PLOGFONT plfDst, PLOGFONT plfSrc, int iXmit)
{
   switch (iXmit)
   {
   case TFC_SIZE:
      plfDst->lfHeight = plfSrc->lfHeight;
      plfDst->lfWidth = plfSrc->lfWidth;
      break;
   case TFC_STYLE:
      plfDst->lfEscapement = plfSrc->lfEscapement;
      plfDst->lfOrientation = plfSrc->lfOrientation;
      plfDst->lfWeight = plfSrc->lfWeight;
      plfDst->lfItalic = plfSrc->lfItalic;
      plfDst->lfUnderline = plfSrc->lfUnderline;
      plfDst->lfStrikeOut = plfSrc->lfStrikeOut;
      plfDst->lfCharSet = plfSrc->lfCharSet;
      plfDst->lfOutPrecision = plfSrc->lfOutPrecision;
      plfDst->lfClipPrecision = plfSrc->lfClipPrecision;
      plfDst->lfQuality = plfSrc->lfQuality;
      plfDst->lfPitchAndFamily = plfSrc->lfPitchAndFamily;
      StringCchCopy(plfDst->lfFaceName, ARRAYSIZE(plfDst->lfFaceName), plfSrc->lfFaceName);
      break;
   }
}


// RGB to String to RGB utilities.
COLORREF RGBStringToColor(LPTSTR lpszRGB)
{
   LPTSTR lpszCur, lpszNext;
   BYTE bRed, bGreen, bBlue;
   CHAR szTempA[10];

   // inits
   lpszNext = lpszRGB;

   // set up R for translation
   lpszCur = lpszNext;
   while ((TEXT(' ') != *lpszNext) && *lpszNext) { lpszNext++; }
   *lpszNext = 0;    lpszNext++;
   // get Red
   wcstombs(szTempA, (wchar_t *)lpszCur, sizeof(szTempA));
   bRed = (BYTE)latoi(szTempA);

   // set up G for translation
   lpszCur = lpszNext;
   while ((TEXT(' ') != *lpszNext) && *lpszNext) { lpszNext++; }
   *lpszNext = 0;    lpszNext++;
   // get Green
   wcstombs(szTempA, (wchar_t *)lpszCur, sizeof(szTempA));
   bGreen = (BYTE)latoi(szTempA);

   // set up B for translation
   lpszCur = lpszNext;
   while ((TEXT(' ') != *lpszNext) && *lpszNext) { lpszNext++; }
   *lpszNext = 0;    lpszNext++;
   // get Blue
   wcstombs(szTempA, (wchar_t *)lpszCur, sizeof(szTempA));
   bBlue = (BYTE)latoi(szTempA);

   // OK, now combine them all for the big finish.....!
   return(RGB(bRed, bGreen, bBlue));
}



// IsValidThemeFile
//
// Answers the question.
BOOL IsValidThemeFile(IN LPCWSTR pszTest)
{
   WCHAR szValue[MAX_PATH];
   BOOL fIsValid = FALSE;

   if (GetPrivateProfileString(SZ_INISECTION_MASTERSELECTOR, SZ_INIKEY_THEMEMAGICTAG, SZ_EMPTY, szValue, ARRAYSIZE(szValue), pszTest))
   {
       fIsValid = !StrCmp(szValue, SZ_INIKEY_THEMEMAGICVALUE);
   }

   return fIsValid;
}




HRESULT SnapCreateTemplate(LPCWSTR pszPath, ITheme ** ppTheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppTheme)
    {
        *ppTheme = NULL;

        if (pszPath)
        {
            // Start with a template ("Windows Classic.theme").
            TCHAR szTemplate[MAX_PATH];

            DeleteFile(pszPath);
            StringCchCopy(szTemplate, ARRAYSIZE(szTemplate), pszPath);
            PathRemoveFileSpec(szTemplate);
            SHCreateDirectoryEx(NULL, szTemplate, NULL);

            hr = SHGetResourcePath(TRUE, szTemplate, ARRAYSIZE(szTemplate));
            if (SUCCEEDED(hr))
            {
                if (PathAppend(szTemplate, TEXT("Themes\\Windows Classic.theme")))
                {
                    if (CopyFile(szTemplate, pszPath, FALSE))
                    {
                        hr = CThemeFile_CreateInstance(pszPath, ppTheme);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
   }

   return hr;
}



/*****************************************************************************\
    DESCRIPTION:
        This function will grab the live settings (from pPropertyBag) and put
    theme into a file specified by pszPath.  A pointer to the Theme will be
    returned in ppTheme.  If the settings cannot be obtained, they will come
    from "Windows Classic.theme".  This includes the Display Name, so the call
    will almost always want to specify that if this function returns successfully.

    PARAMETERS:
        pPropertyBag: This is were the settings will be read from.
        pszPath: This is the file will be saved to.  It will be replaced if it exists.
        ppTheme: This will be created and returned if successful.
\*****************************************************************************/
HRESULT SnapShotLiveSettingsToTheme(IPropertyBag * pPropertyBag, LPCWSTR pszPath, ITheme ** ppTheme)
{
    HRESULT hr = SnapCreateTemplate(pszPath, ppTheme);

    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        ITheme * pTheme = *ppTheme;

        // 1. Save the Background
        // We may fail to get the background path if the policy turns it off.
        if (SUCCEEDED(SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_BACKGROUNDSRC_PATH, szPath, ARRAYSIZE(szPath))))
        {
            CComBSTR bstrPath(szPath);
            hr = pTheme->put_Background(bstrPath);
            if (SUCCEEDED(hr))
            {
                DWORD dwBackgroundTile;

                if (SUCCEEDED(SHPropertyBag_ReadDWORD(pPropertyBag, SZ_PBPROP_BACKGROUND_TILE, &dwBackgroundTile)))
                {
                    enumBkgdTile nTile = BKDGT_STRECH;

                    switch (dwBackgroundTile)
                    {
                    case WPSTYLE_CENTER:
                        nTile = BKDGT_CENTER;
                        break;
                    case WPSTYLE_TILE:
                        nTile = BKDGT_TILE;
                        break;
                    };

                    hr = pTheme->put_BackgroundTile(nTile);
                }
            }
        }

        // 2. Save Screen Saver
        if (SUCCEEDED(hr))
        {
            // This will fail with policies enabled.  In that case, we just use the default value.
            if (SUCCEEDED(SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_SCREENSAVER_PATH, szPath, ARRAYSIZE(szPath))))
            {
                CComBSTR bstrPath(szPath);
                hr = pTheme->put_ScreenSaver(bstrPath);
            }
        }

        // 3. Save Visual Style
        if (SUCCEEDED(hr))
        {
            // It's okay to have no visual style selected.
            if (SUCCEEDED(SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_VISUALSTYLE_PATH, szPath, ARRAYSIZE(szPath))) && szPath[0])
            {
                CComBSTR bstrPath(szPath);

                hr = pTheme->put_VisualStyle(bstrPath);
                if (SUCCEEDED(hr) &&
                    SUCCEEDED(SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_VISUALSTYLE_COLOR, szPath, ARRAYSIZE(szPath))))
                {
                    bstrPath = szPath;

                    hr = pTheme->put_VisualStyleColor(bstrPath);
                    if (SUCCEEDED(hr) &&
                        SUCCEEDED(SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_VISUALSTYLE_SIZE, szPath, ARRAYSIZE(szPath))))
                    {
                        bstrPath = szPath;

                        hr = pTheme->put_VisualStyleSize(bstrPath);
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            // 4. Save System Metrics
            IPropertyBag * pPropertyBagFile;

            hr = pTheme->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBagFile));
            if (SUCCEEDED(hr))
            {
                VARIANT var = {0};

                // This call will return SYSTEMMETRICS relative to the currently live DPI.
                hr = pPropertyBag->Read(SZ_PBPROP_SYSTEM_METRICS, &var, NULL);
                if (SUCCEEDED(hr) && (VT_BYREF == var.vt) && var.byref)
                {
                    SYSTEMMETRICSALL * pCurrent = (SYSTEMMETRICSALL *) var.byref;

                    IUnknown_SetSite(pPropertyBagFile, pPropertyBag);   // Set the site so they can get settings.
                    hr = SHPropertyBag_WriteByRef(pPropertyBagFile, SZ_PBPROP_SYSTEM_METRICS, (void *)pCurrent);
                    IUnknown_SetSite(pPropertyBagFile, NULL);   // Break any back pointers.
                }

                pPropertyBagFile->Release();
            }
        }

        // 5. Save Sounds
        int nIndex;

        for (nIndex = 0; nIndex < ARRAYSIZE(s_ThemeSoundsValues); nIndex++)
        {
            if (FAILED(HrRegGetPath(HKEY_CURRENT_USER, s_ThemeSoundsValues[nIndex].pszRegKey, NULL, szPath, ARRAYSIZE(szPath))))
            {
                szPath[0] = 0;
            }

            pTheme->SetSound((BSTR)s_ThemeSoundsValues[nIndex].pszRegKey, szPath);
        }


        // 6. Save Icons
        for (nIndex = 0; (nIndex < ARRAYSIZE(s_Icons)); nIndex++)
        {
            // This can fail if the background policy is enabled.
            if (SUCCEEDED(SHPropertyBag_ReadStr(pPropertyBag, s_Icons[nIndex], szPath, ARRAYSIZE(szPath))))
            {
                pTheme->SetIcon((BSTR)s_Icons[nIndex], szPath);
            }
        }


        // 7. Save Cursors
        for (nIndex = 0; nIndex < ARRAYSIZE(s_pszCursorArray); nIndex++)
        {
            if (FAILED(HrRegGetPath(HKEY_CURRENT_USER, SZ_INISECTION_CURSORS, s_pszCursorArray[nIndex], szPath, ARRAYSIZE(szPath))))
            {
                szPath[0] = 0;
            }

            pTheme->SetCursor((BSTR)s_pszCursorArray[nIndex], szPath);
        }

        if (SUCCEEDED(HrRegGetPath(HKEY_CURRENT_USER, SZ_INISECTION_CURSORS, NULL, szPath, ARRAYSIZE(szPath))))
        {
            pTheme->SetCursor(SZ_INIKEY_CURSORSCHEME, szPath);
        }

        if (FAILED(hr))
        {
            // Partially written files are very bad.
            DeleteFile(pszPath);
            ATOMICRELEASE(*ppTheme);
        }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\themeutils.h ===
/*****************************************************************************\
    FILE: themeutils.h

    DESCRIPTION:
        This class will load and save the "Theme" settings from their persisted
    state.

    BryanSt 5/26/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _THEMEUTIL_H
#define _THEMEUTIL_H


/////////////////////////////////////////////////////////////////////
// String Constants
/////////////////////////////////////////////////////////////////////
// Registry Strings
#define SZ_REGKEY_USERMETRICS           TEXT("Control Panel\\Desktop\\WindowMetrics")
#define SZ_REGKEY_CURRENTTHEME          TEXT("Software\\Microsoft\\Plus!\\Themes\\Current")     // Previously szPlus_CurTheme
#define SZ_REGKEY_PROGRAMFILES          TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define SZ_REGKEY_PLUS95DIR             TEXT("Software\\Microsoft\\Plus!\\Setup")         // PLUS95_KEY
#define SZ_REGKEY_PLUS98DIR             TEXT("Software\\Microsoft\\Plus!98")          // PLUS98_KEY
#define SZ_REGKEY_KIDSDIR               TEXT("Software\\Microsoft\\Microsoft Kids\\Kids Plus!")   // KIDS_KEY
#define SZ_REGKEY_SOUNDS                TEXT("AppEvents\\Schemes")   

#define SZ_REGVALUE_PLUS95DIR           TEXT("DestPath")  // PLUS95_PATH
#define SZ_REGVALUE_PLUS98DIR           TEXT("Path")        // PLUS98_PATH
#define SZ_REGVALUE_KIDSDIR             TEXT("InstallDir")            // KIDS_PATH
#define SZ_REGVALUE_PROGRAMFILESDIR     TEXT("ProgramFilesDir")
#define SZ_REGVALUE_WALLPAPERSTYLE      TEXT("WallpaperStyle")
#define SZ_REGVALUE_TILEWALLPAPER       TEXT("TileWallpaper")
#define SZ_REGVALUE_STRETCH             TEXT("Stretch")


#define SZ_INISECTION_SCREENSAVER       TEXT("boot")
#define SZ_INISECTION_THEME             TEXT("Theme")
#define SZ_INISECTION_BACKGROUND        TEXT("Control Panel\\Desktop")
#define SZ_INISECTION_COLORS            TEXT("Control Panel\\Colors")
#define SZ_INISECTION_CURSORS           TEXT("Control Panel\\Cursors")
#define SZ_INISECTION_VISUALSTYLES      TEXT("VisualStyles")
#define SZ_INISECTION_MASTERSELECTOR    TEXT("MasterThemeSelector")
#define SZ_INISECTION_METRICS           TEXT("Metrics")
#define SZ_INISECTION_CONTROLINI        TEXT("control.ini")
#define SZ_INISECTION_SYSTEMINI         TEXT("system.ini")

#define SZ_INIKEY_SCREENSAVER           TEXT("SCRNSAVE.EXE")
#define SZ_INIKEY_BACKGROUND            TEXT("Wallpaper")
#define SZ_INIKEY_VISUALSTYLE           TEXT("Path")
#define SZ_INIKEY_VISUALSTYLECOLOR      TEXT("ColorStyle")
#define SZ_INIKEY_VISUALSTYLESIZE       TEXT("Size")
#define SZ_INIKEY_ICONMETRICS           TEXT("IconMetrics")
#define SZ_INIKEY_NONCLIENTMETRICS      TEXT("NonclientMetrics")
#define SZ_INIKEY_DEFAULTVALUE          TEXT("DefaultValue")
#define SZ_INIKEY_THEMEMAGICTAG         TEXT("MTSM")
#define SZ_INIKEY_THEMEMAGICVALUE       TEXT("DABJDKT")
#define SZ_INIKEY_DISPLAYNAME           TEXT("DisplayName")
#define SZ_INIKEY_CURSORSCHEME          TEXT("DefaultValue")




/////////////////////////////////////////////////////////////////////
// Data Structures
/////////////////////////////////////////////////////////////////////
// for ConfirmFile()
#define CF_EXISTS    1
#define CF_FOUND     2
#define CF_NOTFOUND  3




/////////////////////////////////////////////////////////////////////
// Shared Function
/////////////////////////////////////////////////////////////////////
HRESULT GetPlusThemeDir(IN LPTSTR pszPath, IN int cchSize);
HRESULT ExpandThemeTokens(IN LPCTSTR pszThemeFile, IN LPTSTR pszPath, IN int cchSize);
int ConfirmFile(IN LPTSTR lpszPath, IN BOOL bUpdate);
void InitFrost(void);
int WriteBytesToBuffer(IN LPTSTR pszInput, IN void * pOut, IN int cbSize);
void ConvertIconMetricsToWIDE(LPICONMETRICSA aIM, LPICONMETRICSW wIM);
void ConvertNCMetricsToWIDE(LPNONCLIENTMETRICSA aNCM, LPNONCLIENTMETRICSW wNCM);
void ConvertNCMetricsToANSI(LPNONCLIENTMETRICSW wNCM, LPNONCLIENTMETRICSA aNCM);
void ConvertLogFontToANSI(LPLOGFONTW wLF, LPLOGFONTA aLF);
HRESULT ConvertBinaryToINIByteString(BYTE * pBytes, DWORD cbSize, LPWSTR * ppszStringOut);
COLORREF RGBStringToColor(LPTSTR lpszRGB);
BOOL IsValidThemeFile(IN LPCWSTR pszTest);
HRESULT GetIconMetricsFromSysMetricsAll(SYSTEMMETRICSALL * pSystemMetrics, LPICONMETRICSA pIconMetrics, DWORD cchSize);

void TransmitFontCharacteristics(PLOGFONT plfDst, PLOGFONT plfSrc, int iXmit);
#define TFC_STYLE    1
#define TFC_SIZE     2

/////////////////////////////////////////////////////////////////////
// The following functions are used to "SnapShot" settings and save
// or restore them from a .theme file.
/////////////////////////////////////////////////////////////////////
HRESULT SnapShotLiveSettingsToTheme(IPropertyBag * pPropertyBag, LPCWSTR pszPath, ITheme ** ppTheme);


#endif // _THEMEUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\thsettingspg.h ===
/*****************************************************************************\
    FILE: ThSettingsPg.h

    DESCRIPTION:
        This code will display a "Theme Settings" tab in the advanced
    "Display Properties" dialog (the advanced dialog, not the base dlg).

    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#ifndef _THEMESETTINGSPG_H
#define _THEMESETTINGSPG_H

#include <cowsite.h>



HRESULT CThemeSettingsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog);


#define THEMEFILTER_SCREENSAVER             0x00000000
#define THEMEFILTER_SOUNDS                  0x00000001
#define THEMEFILTER_CURSORS                 0x00000002
#define THEMEFILTER_WALLPAPER               0x00000003
#define THEMEFILTER_ICONS                   0x00000004
#define THEMEFILTER_COLORS                  0x00000005
#define THEMEFILTER_SMSTYLES                0x00000006
#define THEMEFILTER_SMSIZES                 0x00000007


#define SIZE_THEME_FILTERS          9
extern const TCHAR * g_szCBNames[SIZE_THEME_FILTERS];


#endif // _THEMESETTINGSPG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\thsettingspg.cpp ===
/*****************************************************************************\
    FILE: ThSettingsPg.cpp

    DESCRIPTION:
        This code will display a "Theme Settings" tab in the advanced
    "Display Properties" dialog (the advanced dialog, not the base dlg).

    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "regutil.h"
#include "ThSettingsPg.h"
#include "AdvAppearPg.h"



//============================================================================================================
// Class
//============================================================================================================
class CThemeSettingsPage        : public CObjectWithSite
                                , public IAdvancedDialog
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAdvancedDialog ***
    virtual STDMETHODIMP DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply);

    CThemeSettingsPage();
protected:

private:
    virtual ~CThemeSettingsPage(void);

    // Private Member Variables
    long                    m_cRef;
    BOOL                    m_fDirty;
    HWND                    m_hDlg;
    IPropertyBag *          m_pPropertyBag;

    // Private Member Functions
    INT_PTR _ThemeSettingsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnInitThemesDlg(HWND hDlg);
    INT_PTR _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    HRESULT _LoadState(IN IPropertyBag * pBasePage);
    HRESULT _SaveState(IN IPropertyBag * pBasePage);

    HRESULT _IsDirty(IN BOOL * pIsDirty);

    static INT_PTR CALLBACK ThemeSettingsDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};








//============================================================================================================
// *** Globals ***
//============================================================================================================
const static DWORD FAR aThemeSettingsHelpIds[] = {
    IDC_TSPG_THEMELIST_LABLE,           IDH_DISPLAY_THEMESETTINGS_NAMELABLE,
    IDC_TSPG_THEME_NAME,                IDH_DISPLAY_THEMESETTINGS_NAME,
    IDC_TSPG_CB_GROUP_LABEL,            IDH_DISPLAY_THEMESETTINGS_LABEL,
    IDC_TSPG_CB_LABEL,                  IDH_DISPLAY_THEMESETTINGS_LABEL,
    IDC_TSPG_CB_WALLPAPER,              IDH_DISPLAY_THEMESETTINGS_WALLPAPER,
    IDC_TSPG_CB_SOUNDS,                 IDH_DISPLAY_THEMESETTINGS_SOUNDS,
    IDC_TSPG_CB_MOUSE,                  IDH_DISPLAY_THEMESETTINGS_MOUSE,
    IDC_TSPG_CB_SCREENSAVER,            IDH_DISPLAY_THEMESETTINGS_SCREENSAVER,
    IDC_TSPG_CB_ICONS,                  IDH_DISPLAY_THEMESETTINGS_ICONS, 
    IDC_TSPG_CB_COLORS,                 IDH_DISPLAY_THEMESETTINGS_COLORS, 
    IDC_TSPG_CB_FONTS,                  IDH_DISPLAY_THEMESETTINGS_FONTS,
    IDC_TSPG_CB_BORDERS,                IDH_DISPLAY_THEMESETTINGS_BORDERS, 
    0, 0
};

#define SZ_HELPFILE_THEMESETTINGS           TEXT("display.hlp")


const TCHAR * g_szCBNames[SIZE_THEME_FILTERS] =
{
    SZ_PBPROP_THEME_FILTER TEXT("Screen saver"),
    SZ_PBPROP_THEME_FILTER TEXT("Sound events"),
    SZ_PBPROP_THEME_FILTER TEXT("Mouse pointers"),
    SZ_PBPROP_THEME_FILTER TEXT("Desktop wallpaper"),
    SZ_PBPROP_THEME_FILTER TEXT("Icons"),
    SZ_PBPROP_THEME_FILTER TEXT("Colors"),
    SZ_PBPROP_THEME_FILTER TEXT("Font names and styles"),
    SZ_PBPROP_THEME_FILTER TEXT("Font and window sizes"),
    SZ_PBPROP_THEME_FILTER TEXT("Rotate theme monthly")
};  




//===========================
// *** Class Internals & Helpers ***
//===========================
INT_PTR CALLBACK CThemeSettingsPage::ThemeSettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CThemeSettingsPage * pThis = (CThemeSettingsPage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CThemeSettingsPage *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
        return pThis->_ThemeSettingsDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


HRESULT CThemeSettingsPage::_OnInitThemesDlg(HWND hDlg)
{
    m_hDlg = hDlg;
    
    if (m_pPropertyBag)
    {
        VARIANT varName;

        VariantInit(&varName);
        HRESULT hr = m_pPropertyBag->Read(SZ_PBPROP_THEME_DISPLAYNAME, &varName, NULL);
        if (SUCCEEDED(hr))
        {
            if (VT_BSTR == varName.vt)
            {
                SetWindowTextW(GetDlgItem(hDlg, IDC_TSPG_THEME_NAME), varName.bstrVal);
            }

            VariantClear(&varName);
        }
    }

    return _LoadState(m_pPropertyBag);
}


INT_PTR CThemeSettingsPage::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idCtrl)
    {
    case IDOK:
        _SaveState(m_pPropertyBag);
        EndDialog(hDlg, IDOK);
        break;

    case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;

    case IDC_TSPG_CB_SCREENSAVER:
    case IDC_TSPG_CB_SOUNDS:
    case IDC_TSPG_CB_MOUSE:
    case IDC_TSPG_CB_WALLPAPER:
    case IDC_TSPG_CB_ICONS:
    case IDC_TSPG_CB_COLORS:
    case IDC_TSPG_CB_FONTS:
    case IDC_TSPG_CB_BORDERS:
        m_fDirty = TRUE;
        break;

    default:
        break;
    }

    return fHandled;
}



// This Property Sheet appear in the top level of the "Display Control Panel".
INT_PTR CThemeSettingsPage::_ThemeSettingsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        _OnInitThemesDlg(hDlg);
        break;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_THEMESETTINGS, HELP_WM_HELP, (DWORD_PTR) aThemeSettingsHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, SZ_HELPFILE_THEMESETTINGS, HELP_CONTEXTMENU, (DWORD_PTR) aThemeSettingsHelpIds);
        break;

    case WM_COMMAND:
        _OnCommand(hDlg, message, wParam, lParam);
        break;
    }

    return FALSE;
}



HRESULT CThemeSettingsPage::_IsDirty(IN BOOL * pIsDirty)
{
    HRESULT hr = E_INVALIDARG;

    if (pIsDirty)
    {
        *pIsDirty = m_fDirty;
        hr = S_OK;
    }

    return hr;
}


HRESULT CThemeSettingsPage::_LoadState(IN IPropertyBag * pPropertyBag)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pPropertyBag)
    {
        for (int nIndex = IDC_TSPG_CB_SCREENSAVER; nIndex <= IDC_TSPG_CB_BORDERS; nIndex++)
        {
            VARIANT varFilter;

            varFilter.vt = VT_BOOL;
            varFilter.boolVal = VARIANT_TRUE;

            hr = pPropertyBag->Read(g_szCBNames[nIndex - IDC_TSPG_CB_SCREENSAVER], &varFilter, NULL);
            CheckDlgButton(m_hDlg, nIndex, ((VARIANT_TRUE == varFilter.boolVal) ? BST_CHECKED : BST_UNCHECKED));
        }
    }

    return hr;
}


HRESULT CThemeSettingsPage::_SaveState(IN IPropertyBag * pBasePage)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pBasePage)
    {
        for (int nIndex = IDC_TSPG_CB_SCREENSAVER; nIndex <= IDC_TSPG_CB_BORDERS; nIndex++)
        {
            VARIANT varFilter;

            varFilter.vt = VT_BOOL;
            varFilter.boolVal = ((BST_UNCHECKED != IsDlgButtonChecked(m_hDlg, nIndex)) ? VARIANT_TRUE : VARIANT_FALSE);

            hr = pBasePage->Write(g_szCBNames[nIndex - IDC_TSPG_CB_SCREENSAVER], &varFilter);
        }
    }

    return hr;
}




//===========================
// *** IAdvancedDialog Interface ***
//===========================
HRESULT CThemeSettingsPage::DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply)
{
    HRESULT hr = E_INVALIDARG;

    if (hwndParent && pBasePage && pfEnableApply)
    {
        // Load State Into Advanced Dialog 
        *pfEnableApply = FALSE;
        IUnknown_Set((IUnknown **) &m_pPropertyBag, pBasePage);

        hr = S_OK;
        // Display Advanced Dialog
        if (IDOK == DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_THEMESETTINGSPG), hwndParent, CThemeSettingsPage::ThemeSettingsDlgProc, (LPARAM)this))
        {
            // The user clicked OK, so merge modified state back into base dialog
            _IsDirty(pfEnableApply);
        }
    }

    return hr;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CThemeSettingsPage::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CThemeSettingsPage::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CThemeSettingsPage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CThemeSettingsPage, IObjectWithSite),
        QITABENT(CThemeSettingsPage, IAdvancedDialog),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CThemeSettingsPage::CThemeSettingsPage() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_fDirty);
    ASSERT(!m_hDlg);
    ASSERT(!m_pPropertyBag);

}


CThemeSettingsPage::~CThemeSettingsPage()
{
    IUnknown_Set((IUnknown **) &m_pPropertyBag, NULL);
    DllRelease();
}




HRESULT CThemeSettingsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        CThemeSettingsPage * pThis = new CThemeSettingsPage();

        if (pThis)
        {
            hr = pThis->QueryInterface(IID_PPV_ARG(IAdvancedDialog, ppAdvDialog));
            pThis->Release();
        }
        else
        {
            *ppAdvDialog = NULL;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\thsize.h ===
/*****************************************************************************\
    FILE: thSize.h

    DESCRIPTION:
        This is the Autmation Object to theme size object.  This one will be
    for the Skin objects.

    BryanSt 5/13/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_THSIZE
#define _FILE_H_THSIZE

#include <cowsite.h>
#include <atlbase.h>



HRESULT CSkinSize_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, IN LPCWSTR pszDisplayName, OUT IThemeSize ** ppThemeSize);
HRESULT CSkinSize_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, OUT IThemeSize ** ppThemeSize);


class CSkinSize                 : public IThemeSize
                                , public IPropertyBag
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeSize ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName);
    virtual STDMETHODIMP get_Name(OUT BSTR * pbstrName);
    virtual STDMETHODIMP put_Name(IN BSTR bstrName);
    virtual STDMETHODIMP get_SystemMetricColor(IN int nSysColorIndex, OUT COLORREF * pColorRef);
    virtual STDMETHODIMP put_SystemMetricColor(IN int nSysColorIndex, IN COLORREF ColorRef) {return E_NOTIMPL;}
    virtual STDMETHODIMP get_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, OUT int * pnSize);
    virtual STDMETHODIMP put_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, IN int nSize) {return E_NOTIMPL;}
    virtual STDMETHODIMP get_WebviewCSS(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP get_ContrastLevel(OUT enumThemeContrastLevels * pContrastLevel) {if (pContrastLevel) {*pContrastLevel = CONTRAST_NORMAL;} return S_OK;}
    virtual STDMETHODIMP put_ContrastLevel(IN enumThemeContrastLevels ContrastLevel) {return E_NOTIMPL;}
    virtual STDMETHODIMP GetSystemMetricFont(IN enumSystemMetricFont nSPIFontIndex, IN LOGFONTW * pParamW);
    virtual STDMETHODIMP PutSystemMetricFont(IN enumSystemMetricFont nSPIFontIndex, IN LOGFONTW * pParamW) {return E_NOTIMPL;}

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar) {return E_NOTIMPL;}

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return E_ACCESSDENIED; }

private:
    CSkinSize(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, IN LPCWSTR pszDisplayName);
    virtual ~CSkinSize(void);


    // Private Member Variables
    long                    m_cRef;

    LPWSTR                  m_pszFilename;          // This is the full path to the ".thx" file
    LPWSTR                  m_pszStyleName;         // This is the canonical name of the color style
    LPWSTR                  m_pszSizeName;          // This is the canonical name of the size
    LPWSTR                  m_pszDisplayName;       // This is the display name of the size
    HTHEME                  m_hTheme;               // This is the Theme we represent.

    BOOL                    m_fFontsLoaded;         // Have we loaded the fonts yet?
    SYSTEMMETRICSALL        m_sysMetrics;           // The loaded fonts

    // Private Methods
    HRESULT _InitVisualStyle(void);

    // Friend Functions
    friend HRESULT CSkinSize_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, IN LPCWSTR pszDisplayName, OUT IThemeSize ** ppThemeSize);
    friend HRESULT CSkinSize_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, OUT IThemeSize ** ppThemeSize);
};


#endif // _FILE_H_THSIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\thstyle.h ===
/*****************************************************************************\
    FILE: thStyle.h

    DESCRIPTION:
        This is the Autmation Object to theme style object.  This one will be
    for the Skin objects.

    BryanSt 5/13/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_THSTYLE
#define _FILE_H_THSTYLE

#include <cowsite.h>
#include <atlbase.h>



HRESULT CSkinStyle_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszDisplayName, OUT IThemeStyle ** ppThemeStyle);
HRESULT CSkinStyle_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, OUT IThemeStyle ** ppThemeStyle);


class CSkinStyle                : public IThemeStyle
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeStyle ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName);
    virtual STDMETHODIMP get_Name(OUT BSTR * pbstrName);
    virtual STDMETHODIMP put_Name(IN BSTR bstrName);
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT IThemeSize ** ppThemeSize);
    virtual STDMETHODIMP get_SelectedSize(OUT IThemeSize ** ppThemeSize);
    virtual STDMETHODIMP put_SelectedSize(IN IThemeSize * pThemeSize);
    virtual STDMETHODIMP AddSize(OUT IThemeSize ** ppThemeSize);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return E_ACCESSDENIED; }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return E_ACCESSDENIED; }

private:
    CSkinStyle(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszDisplayName);
    virtual ~CSkinStyle(void);


    // Private Member Variables
    long                    m_cRef;

    LPWSTR                  m_pszFilename;          // This is the full path to the ".thx" file
    LPWSTR                  m_pszDisplayName;       // This is the display name of the color style
    LPWSTR                  m_pszStyleName;         // This is the canonical name of the color style
    long                    m_nSize;                // The size of the collection of Sizes.
    IThemeSize *            m_pSelectedSize;        // The selected size.


    // Private Member Functions

    // Friend Functions
    friend HRESULT CSkinStyle_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszDisplayName, OUT IThemeStyle ** ppThemeStyle);
    friend HRESULT CSkinStyle_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, OUT IThemeStyle ** ppThemeStyle);
};


#endif // _FILE_H_THSTYLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxbud\stdafx.h ===
//---------------------------------------------------------------------------
// stdafx.h : include file for standard system include files
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <atlbase.h>
#define STRSAFE_LIB
#include <strsafe.h>

#include <uxthemep.h>
#include <tmschema.h>
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\wmpapitemp.h ===
/* The WMP team should add this file to our enlistment as "wmpshell.h" soon.
   This is a place holder until they do that.
 */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Nov 07 18:40:17 2000
 */
/* Compiler settings for .\wmpshell.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmpshell_h__
#define __wmpshell_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMPSkinMngr_FWD_DEFINED__
#define __IWMPSkinMngr_FWD_DEFINED__
typedef interface IWMPSkinMngr IWMPSkinMngr;
#endif 	/* __IWMPSkinMngr_FWD_DEFINED__ */


#ifndef __WMPPlayAsPlaylistLauncher_FWD_DEFINED__
#define __WMPPlayAsPlaylistLauncher_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMPPlayAsPlaylistLauncher WMPPlayAsPlaylistLauncher;
#else
typedef struct WMPPlayAsPlaylistLauncher WMPPlayAsPlaylistLauncher;
#endif /* __cplusplus */

#endif 	/* __WMPPlayAsPlaylistLauncher_FWD_DEFINED__ */


#ifndef __WMPAddToPlaylistLauncher_FWD_DEFINED__
#define __WMPAddToPlaylistLauncher_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMPAddToPlaylistLauncher WMPAddToPlaylistLauncher;
#else
typedef struct WMPAddToPlaylistLauncher WMPAddToPlaylistLauncher;
#endif /* __cplusplus */

#endif 	/* __WMPAddToPlaylistLauncher_FWD_DEFINED__ */


#ifndef __WMPBurnAudioCDLauncher_FWD_DEFINED__
#define __WMPBurnAudioCDLauncher_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMPBurnAudioCDLauncher WMPBurnAudioCDLauncher;
#else
typedef struct WMPBurnAudioCDLauncher WMPBurnAudioCDLauncher;
#endif /* __cplusplus */

#endif 	/* __WMPBurnAudioCDLauncher_FWD_DEFINED__ */


#ifndef __WMPSkinMngr_FWD_DEFINED__
#define __WMPSkinMngr_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMPSkinMngr WMPSkinMngr;
#else
typedef struct WMPSkinMngr WMPSkinMngr;
#endif /* __cplusplus */

#endif 	/* __WMPSkinMngr_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IWMPSkinMngr_INTERFACE_DEFINED__
#define __IWMPSkinMngr_INTERFACE_DEFINED__

/* interface IWMPSkinMngr */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPSkinMngr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("076F2FA6-ED30-448B-8CC5-3F3EF3529C7A")
    IWMPSkinMngr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVisualStyle( 
            /* [in] */ BSTR bstrPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPSkinMngrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPSkinMngr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPSkinMngr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPSkinMngr __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVisualStyle )( 
            IWMPSkinMngr __RPC_FAR * This,
            /* [in] */ BSTR bstrPath);
        
        END_INTERFACE
    } IWMPSkinMngrVtbl;

    interface IWMPSkinMngr
    {
        CONST_VTBL struct IWMPSkinMngrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPSkinMngr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPSkinMngr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPSkinMngr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPSkinMngr_SetVisualStyle(This,bstrPath)	\
    (This)->lpVtbl -> SetVisualStyle(This,bstrPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMPSkinMngr_SetVisualStyle_Proxy( 
    IWMPSkinMngr __RPC_FAR * This,
    /* [in] */ BSTR bstrPath);


void __RPC_STUB IWMPSkinMngr_SetVisualStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPSkinMngr_INTERFACE_DEFINED__ */



#ifndef __WMPLauncher_LIBRARY_DEFINED__
#define __WMPLauncher_LIBRARY_DEFINED__

/* library WMPLauncher */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WMPLauncher;

EXTERN_C const CLSID CLSID_WMPPlayAsPlaylistLauncher;

#ifdef __cplusplus

class DECLSPEC_UUID("CE3FB1D1-02AE-4a5f-A6E9-D9F1B4073E6C")
WMPPlayAsPlaylistLauncher;
#endif

EXTERN_C const CLSID CLSID_WMPAddToPlaylistLauncher;

#ifdef __cplusplus

class DECLSPEC_UUID("F1B9284F-E9DC-4e68-9D7E-42362A59F0FD")
WMPAddToPlaylistLauncher;
#endif

EXTERN_C const CLSID CLSID_WMPBurnAudioCDLauncher;

#ifdef __cplusplus

class DECLSPEC_UUID("8DD448E6-C188-4aed-AF92-44956194EB1F")
WMPBurnAudioCDLauncher;
#endif

EXTERN_C const CLSID CLSID_WMPSkinMngr;

#ifdef __cplusplus


class DECLSPEC_UUID("B2A7FD52-301F-4348-B93A-638C6DE49229")
WMPSkinMngr;
#endif
#endif /* __WMPLauncher_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\thstyle.cpp ===
/*****************************************************************************\
    FILE: thStyle.cpp

    DESCRIPTION:
        This is the Autmation Object to theme style object.  This one will be
    for the Skin objects.

    BryanSt 5/13/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "theme.h"
#include "thsize.h"
#include "thstyle.h"




//===========================
// *** Class Internals & Helpers ***
//===========================



//===========================
// *** ITheme Interface ***
//===========================
HRESULT CSkinStyle::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    return HrSysAllocString(m_pszDisplayName, pbstrDisplayName);
}


HRESULT CSkinStyle::put_DisplayName(IN BSTR bstrDisplayName)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrDisplayName)
    {
        Str_SetPtr(&m_pszDisplayName, bstrDisplayName);
        hr = (m_pszDisplayName ? S_OK : E_OUTOFMEMORY);
    }

    return hr;
}


HRESULT CSkinStyle::get_Name(OUT BSTR * pbstrName)
{
    return HrSysAllocString(m_pszStyleName, pbstrName);
}


HRESULT CSkinStyle::put_Name(IN BSTR bstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrName)
    {
        Str_SetPtr(&m_pszStyleName, bstrName);
        hr = (m_pszStyleName ? S_OK : E_OUTOFMEMORY);
    }

    return hr;
}


HRESULT CSkinStyle::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pnLength)
    {
        hr = S_OK;
        if (COLLECTION_SIZE_UNINITIALIZED == m_nSize)
        {
            THEMENAMEINFO themeInfo;
            m_nSize = 0;

            while (SUCCEEDED(EnumThemeSizes(m_pszFilename, m_pszStyleName, m_nSize, &themeInfo)))
            {
                m_nSize++;
            }
        }

        *pnLength = m_nSize;
    }

    return hr;
}


HRESULT CSkinStyle::get_item(IN VARIANT varIndex, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        long nCount = 0;

        get_length(&nCount);
        *ppThemeSize = NULL;

        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
            varIndex = *(varIndex.pvarVal);

        switch (varIndex.vt)
        {
        case VT_I2:
            varIndex.lVal = (long)varIndex.iVal;
            // And fall through...

        case VT_I4:
        if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount))
        {
            THEMENAMEINFO themeInfo;

            hr = EnumThemeSizes(m_pszFilename, m_pszStyleName, varIndex.lVal, &themeInfo);
            LogStatus("EnumThemeSizes(path=\"%ls\", style=\"%ls\") returned %#08lx in CSkinStyle::get_item.\r\n", m_pszFilename, m_pszStyleName, hr);
            if (SUCCEEDED(hr))
            {
                hr = CSkinSize_CreateInstance(m_pszFilename, m_pszStyleName, themeInfo.szName, themeInfo.szDisplayName, ppThemeSize);
            }
        }
        break;
        case VT_BSTR:
        if (varIndex.bstrVal)
        {
            if (varIndex.bstrVal[0])
            {
                THEMENAMEINFO themeInfo;

                for (long nIndex = 0; FAILED(hr) && (nIndex < nCount) && SUCCEEDED(EnumThemeSizes(m_pszFilename, m_pszStyleName, nIndex, &themeInfo));
                            nIndex++)
                {
                    if (!StrCmpIW(themeInfo.szDisplayName, varIndex.bstrVal) ||
                        !StrCmpIW(themeInfo.szName, varIndex.bstrVal))
                    {
                        hr = CSkinSize_CreateInstance(m_pszFilename, m_pszStyleName, themeInfo.szName, themeInfo.szDisplayName, ppThemeSize);
                    }
                }
            }
            else
            {
                if (m_pszFilename && m_pszStyleName)
                {
                    TCHAR szColor[MAX_PATH];
                    TCHAR szSize[MAX_PATH];

                    hr = GetThemeDefaults(m_pszFilename, szColor, ARRAYSIZE(szColor), szSize, ARRAYSIZE(szSize));
                    LogStatus("GetThemeDefaults(szCurrentStyle=\"%ls\", szColor=\"%ls\", szSize=\"%ls\") returned %#08lx in CSkinStyle::get_item.\r\n", m_pszFilename, szColor, szSize, hr);
                    if (SUCCEEDED(hr) && !StrCmpI(m_pszStyleName, szColor))
                    {
                        hr = CSkinSize_CreateInstance(m_pszFilename, m_pszStyleName, szSize, ppThemeSize);
                    }
                }
            }
        }
        break;

        default:
            hr = E_NOTIMPL;
        }
    }

    return hr;
}


HRESULT CSkinStyle::get_SelectedSize(OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        WCHAR szCurrentPath[MAX_PATH];
        WCHAR szCurrentStyle[MAX_PATH];
        WCHAR szCurrentSize[MAX_PATH];

        szCurrentPath[0] = 0;
        szCurrentPath[0] = 0;
        szCurrentPath[0] = 0;

        *ppThemeSize = NULL;
        if (!m_pSelectedSize)
        {
            hr = GetCurrentThemeName(szCurrentPath, ARRAYSIZE(szCurrentPath), szCurrentStyle, ARRAYSIZE(szCurrentStyle), szCurrentSize, ARRAYSIZE(szCurrentSize));
            LogStatus("GetCurrentThemeName(path=\"%ls\", color=\"%ls\", size=\"%ls\") returned %#08lx.\r\n", szCurrentPath, szCurrentStyle, szCurrentSize, hr);
            if (SUCCEEDED(hr))
            {
                // Is this the currently selected skin and style?
                if (!StrCmpIW(m_pszFilename, szCurrentPath) &&
                    !StrCmpIW(m_pszStyleName, szCurrentStyle))
                {
                    // Yes, so get the size from that API.
                    hr = CSkinSize_CreateInstance(szCurrentPath, szCurrentStyle, szCurrentSize, &m_pSelectedSize);
                }
                else
                {
                    hr = E_FAIL;
                }
            }

            if (FAILED(hr))
            {
                // No, so find the default color style for this skin(scheme).
                hr = GetThemeDefaults(m_pszFilename, szCurrentStyle, ARRAYSIZE(szCurrentStyle), szCurrentSize, ARRAYSIZE(szCurrentSize));
                LogStatus("GetThemeDefaults(m_pszFilename=\"%ls\", szCurrentStyle=\"%ls\", szCurrentSize=\"%ls\") returned %#08lx in CSkinStyle::get_SelectedSize.\r\n", m_pszFilename, szCurrentStyle, szCurrentSize, hr);
                if (SUCCEEDED(hr))
                {
                    hr = CSkinSize_CreateInstance(m_pszFilename, szCurrentStyle, szCurrentSize, &m_pSelectedSize);
                }
            }
        }

        if (m_pSelectedSize)
        {
            IUnknown_Set((IUnknown **)ppThemeSize, m_pSelectedSize);
            if (*ppThemeSize)
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}


HRESULT CSkinStyle::put_SelectedSize(IN IThemeSize * pThemeSize)
{
    IUnknown_Set((IUnknown **)&m_pSelectedSize, pThemeSize);
    return S_OK;
}


HRESULT CSkinStyle::AddSize(OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        *ppThemeSize = NULL;
        hr = E_NOTIMPL;
    }

    return hr;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CSkinStyle::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CSkinStyle::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CSkinStyle::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CSkinStyle, IThemeStyle),
        QITABENT(CSkinStyle, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CSkinStyle::CSkinStyle(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszDisplayName) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pSelectedSize);

    Str_SetPtr(&m_pszFilename, pszFilename);
    Str_SetPtr(&m_pszDisplayName, pszDisplayName);
    Str_SetPtr(&m_pszStyleName, pszStyleName);

    m_nSize = COLLECTION_SIZE_UNINITIALIZED;
}


CSkinStyle::~CSkinStyle()
{
    ATOMICRELEASE(m_pSelectedSize);

    Str_SetPtr(&m_pszFilename, NULL);
    Str_SetPtr(&m_pszDisplayName, NULL);
    Str_SetPtr(&m_pszStyleName, NULL);

    DllRelease();
}



HRESULT CSkinStyle_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszDisplayName, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        CSkinStyle * pObject = new CSkinStyle(pszFilename, pszStyleName, pszDisplayName);

        *ppThemeStyle = NULL;
        hr = E_OUTOFMEMORY;
        if (pObject)
        {
            if (pObject->m_pszFilename && pObject->m_pszStyleName && pObject->m_pszDisplayName)
            {
                hr = pObject->QueryInterface(IID_PPV_ARG(IThemeStyle, ppThemeStyle));
            }

            pObject->Release();
        }
    }

    return hr;
}


HRESULT CSkinStyle_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        *ppThemeStyle = NULL;
        hr = S_OK;

        // Find the display name
        for (int nIndex = 0; SUCCEEDED(hr); nIndex++)
        {
            THEMENAMEINFO themeInfo;

            hr = EnumThemeColors(pszFilename, NULL, nIndex, &themeInfo);
            LogStatus("EnumThemeColors(pszFilename=\"%ls\") returned %#08lx in CSkinStyle_CreateInstance.\r\n", pszFilename, hr);
            if (SUCCEEDED(hr))
            {
                // Did we find the correct color style?
                if (!StrCmpIW(pszStyleName, themeInfo.szName))
                {
                    // Yes, now use it's display name to use the other creator function.
                    hr = CSkinStyle_CreateInstance(pszFilename, pszStyleName, themeInfo.szDisplayName, ppThemeStyle);
                    break;
                }

            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\thsize.cpp ===
/*****************************************************************************\
    FILE: thSize.cpp

    DESCRIPTION:
        This is the Autmation Object to theme size object.  This one will be
    for the Skin objects.

    BryanSt 5/13/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "thsize.h"




//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CSkinSize::_InitVisualStyle(void)
{
    HRESULT hr = S_OK;

    if (!m_hTheme)
    {
        if (m_pszFilename && m_pszStyleName && m_pszSizeName)
        {
            HTHEMEFILE hThemeFile;
            
            // Load the skin
            hr = OpenThemeFile(m_pszFilename, m_pszStyleName, m_pszSizeName, &hThemeFile, FALSE);
            LogStatus("OpenThemeFile(path=\"%ls\", color=\"%ls\", size=\"%ls\") returned %#08lx in CSkinSize::_InitVisualStyle.\r\n", m_pszFilename, m_pszStyleName, m_pszSizeName, hr);

            if (SUCCEEDED(hr))
            {
                m_hTheme = OpenThemeDataFromFile(hThemeFile, NULL, NULL, FALSE);
                LogStatus("OpenThemeDataFromFile() returned %#08lx in CSkinSize::_InitVisualStyle.\r\n", m_hTheme);
                hr = ((NULL == m_hTheme) ? E_FAIL : S_OK);

                CloseThemeFile(hThemeFile);
            }

        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}



//===========================
// *** IThemeSize Interface ***
//===========================
HRESULT CSkinSize::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    return HrSysAllocString(m_pszDisplayName, pbstrDisplayName);
}


HRESULT CSkinSize::put_DisplayName(IN BSTR bstrDisplayName)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrDisplayName)
    {
        Str_SetPtr(&m_pszDisplayName, bstrDisplayName);
        hr = (m_pszDisplayName ? S_OK : E_OUTOFMEMORY);
    }

    return hr;
}


HRESULT CSkinSize::get_Name(OUT BSTR * pbstrName)
{
    return HrSysAllocString(m_pszSizeName, pbstrName);
}


HRESULT CSkinSize::put_Name(IN BSTR bstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrName)
    {
        Str_SetPtr(&m_pszSizeName, bstrName);
        hr = (m_pszSizeName ? S_OK : E_OUTOFMEMORY);
    }

    return hr;
}


HRESULT CSkinSize::get_WebviewCSS(OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath)
    {
        *pbstrPath = NULL;
        hr = _InitVisualStyle();
        if (SUCCEEDED(hr))
        {
            WCHAR szPath[MAX_PATH];
            WCHAR szFilename[MAX_PATH];

            StringCchCopy(szPath, ARRAYSIZE(szPath), m_pszFilename);
            PathRemoveFileSpec(szPath);                     // Remove the filename ("xx.msstyles") from the path.

            hr = GetThemeSysString(m_hTheme, TMT_CSSNAME, szFilename, ARRAYSIZE(szFilename));
            LogStatus("GetThemeDefaults(szFilename=\"%ls\") returned %#08lx in CSkinSize::get_WebviewCSS.\r\n", szFilename, hr);
            if (SUCCEEDED(hr))
            {
                if (!PathAppend(szPath, szFilename))
                {
                    hr = E_FAIL;
                }
                else
                {
                    hr = HrSysAllocString(szPath, pbstrPath);
                }
            }
        }
    }

    return hr;
}


HRESULT CSkinSize::get_SystemMetricColor(IN int nSysColorIndex, OUT COLORREF * pColorRef)
{
    HRESULT hr = E_INVALIDARG;

    if (pColorRef)
    {
        *pColorRef = 0x00000000;

        hr = _InitVisualStyle();
        if (SUCCEEDED(hr))
        {
            *pColorRef = GetThemeSysColor(m_hTheme, nSysColorIndex);
            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CSkinSize::get_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, OUT int * pnSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pnSize)
    {
        *pnSize = 0;

        hr = _InitVisualStyle();
        if (SUCCEEDED(hr))
        {
            hr = S_OK;

            switch (nSystemMetricIndex)
            {
            case SMS_BORDERWIDTH:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CXBORDER);
                break;

            case SMS_SCROLLWIDTH:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CXVSCROLL);
                break;

            case SMS_SCROLLHEIGHT:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CYHSCROLL);
                break;

            case SMS_CAPTIONWIDTH:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CXSIZE);
                break;

            case SMS_CAPTIONHEIGHT:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CYSIZE);
                break;

            case SMS_SMCAPTIONWIDTH:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CXSMSIZE);
                break;

            case SMS_SMCAPTIONHEIGHT:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CYSMSIZE);
                break;

            case SMS_MENUWIDTH:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CXMENUSIZE);
                break;

            case SMS_MENUHEIGHT:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CYMENUSIZE);
                break;

            default:
                hr = E_INVALIDARG;
                break;
            }
        }
    }

    return hr;
}

HRESULT CSkinSize::GetSystemMetricFont(IN enumSystemMetricFont nSPIFontIndex, IN LOGFONTW * plfFont)
{
    HRESULT hr = E_INVALIDARG;

    if (plfFont)
    {
        hr = _InitVisualStyle();
        if (SUCCEEDED(hr))
        {
            if (!m_fFontsLoaded)
            {
                if (SUCCEEDED(hr = GetThemeSysFont96(m_hTheme, TMT_CAPTIONFONT, &m_sysMetrics.schemeData.ncm.lfCaptionFont)) &&
                    SUCCEEDED(hr = GetThemeSysFont96(m_hTheme, TMT_SMALLCAPTIONFONT, &m_sysMetrics.schemeData.ncm.lfSmCaptionFont)) &&
                    SUCCEEDED(hr = GetThemeSysFont96(m_hTheme, TMT_MENUFONT, &m_sysMetrics.schemeData.ncm.lfMenuFont)) &&
                    SUCCEEDED(hr = GetThemeSysFont96(m_hTheme, TMT_STATUSFONT, &m_sysMetrics.schemeData.ncm.lfStatusFont)) &&
                    SUCCEEDED(hr = GetThemeSysFont96(m_hTheme, TMT_MSGBOXFONT, &m_sysMetrics.schemeData.ncm.lfMessageFont)) &&
                    SUCCEEDED(hr = GetThemeSysFont96(m_hTheme, TMT_ICONTITLEFONT, &m_sysMetrics.schemeData.lfIconTitle)))
                {
                    m_fFontsLoaded = TRUE;
                }
            }

            if (SUCCEEDED(hr))
            {
                switch (nSPIFontIndex)
                {
                case SMF_CAPTIONFONT:
                    *plfFont = m_sysMetrics.schemeData.ncm.lfCaptionFont;
                    break;

                case SMF_SMCAPTIONFONT:
                    *plfFont = m_sysMetrics.schemeData.ncm.lfSmCaptionFont;
                    break;

                case SMF_MENUFONT:
                    *plfFont = m_sysMetrics.schemeData.ncm.lfMenuFont;
                    break;

                case SMF_STATUSFONT:
                    *plfFont = m_sysMetrics.schemeData.ncm.lfStatusFont;
                    break;

                case SMF_MESSAGEFONT:
                    *plfFont = m_sysMetrics.schemeData.ncm.lfMessageFont;
                    break;

                case SMF_ICONTITLEFONT:
                    *plfFont = m_sysMetrics.schemeData.lfIconTitle;
                    break;

                default:
                    hr = E_INVALIDARG;
                    break;
                }
            }
        }
    }

    return hr;
}








//===========================
// *** IPropertyBag Interface ***
//===========================
HRESULT CSkinSize::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_VSBEHAVIOR_FLATMENUS))
        {
            hr = _InitVisualStyle();
            if (SUCCEEDED(hr))
            {
                pVar->vt = VT_BOOL;
                pVar->boolVal = (GetThemeSysBool(m_hTheme, TMT_FLATMENUS) ? VARIANT_TRUE : VARIANT_FALSE);
                LogStatus("GetThemeSysBool()=%#08lx returned %#08lx in CSkinSize::Read.\r\n", pVar->boolVal, hr);
            }
        }
    }

    return hr;
}






//===========================
// *** IUnknown Interface ***
//===========================
ULONG CSkinSize::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CSkinSize::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CSkinSize::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CSkinSize, IThemeSize),
        QITABENT(CSkinSize, IPropertyBag),
        QITABENT(CSkinSize, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CSkinSize::CSkinSize(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, IN LPCWSTR pszDisplayName) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hTheme);
    m_fFontsLoaded = FALSE;

    Str_SetPtr(&m_pszFilename, pszFilename);
    Str_SetPtr(&m_pszDisplayName, pszDisplayName);
    Str_SetPtr(&m_pszStyleName, pszStyleName);
    Str_SetPtr(&m_pszSizeName, pszSizeName);
}


CSkinSize::~CSkinSize()
{
    Str_SetPtr(&m_pszFilename, NULL);
    Str_SetPtr(&m_pszDisplayName, NULL);
    Str_SetPtr(&m_pszStyleName, NULL);
    Str_SetPtr(&m_pszSizeName, NULL);

    if (m_hTheme)
    {
        CloseThemeData(m_hTheme);
    }

    DllRelease();
}


HRESULT CSkinSize_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, IN LPCWSTR pszDisplayName, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        CSkinSize * pObject = new CSkinSize(pszFilename, pszStyleName, pszSizeName, pszDisplayName);

        *ppThemeSize = NULL;
        hr = E_OUTOFMEMORY;
        if (pObject)
        {
            if (pObject->m_pszFilename && pObject->m_pszStyleName &&pObject->m_pszSizeName && pObject->m_pszDisplayName)
            {
                hr = pObject->QueryInterface(IID_PPV_ARG(IThemeSize, ppThemeSize));
            }

            pObject->Release();
        }
    }

    return hr;
}


HRESULT CSkinSize_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        *ppThemeSize = NULL;
        hr = E_FAIL;
        
        int nIndex;
        // Find the display name
        for (nIndex = 0; ; nIndex++)
        {
            THEMENAMEINFO themeInfo;

            if (SUCCEEDED(EnumThemeSizes(pszFilename, pszStyleName, nIndex, &themeInfo)))
            {
                // Did we find the correct color style?
                if (!StrCmpIW(pszSizeName, themeInfo.szName))
                {
                    // Yes, now use it's display name to use the other creator function.
                    hr = CSkinSize_CreateInstance(pszFilename, pszStyleName, pszSizeName, themeInfo.szDisplayName, ppThemeSize);
                    break;
                }

            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\util.cpp ===
/*****************************************************************************\
    FILE: util.cpp

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include <errors.h>         // \\themes\\inc
#include <ctxdef.h> // hydra stuff
#include <regapi.h> // WINSTATION_REG_NAME
#include "WMPAPITemp.h"

#define SECURITY_WIN32
#include <sspi.h>
extern "C" {
    #include <Secext.h>     // for GetUserNameEx()
}


#define DECL_CRTFREE
#include <crtfree.h>

#include "util.h"

/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////

HINSTANCE g_hinst;              // My instance handle
HANDLE g_hLogFile = INVALID_HANDLE_VALUE;


#ifdef DEBUG
DWORD g_TLSliStopWatchStartHi = 0xFFFFFFFF;
DWORD g_TLSliStopWatchStartLo = 0xFFFFFFFF;
LARGE_INTEGER g_liStopWatchFreq = {0};
#endif // DEBUG

/////////////////////////////////////////////////////////////////////
// Debug Timing Helpers
/////////////////////////////////////////////////////////////////////

#ifdef DEBUG
void DebugStartWatch(void)
{
    LARGE_INTEGER liStopWatchStart;

    if (-1 == g_TLSliStopWatchStartHi)
    {
        g_TLSliStopWatchStartHi = TlsAlloc();
        g_TLSliStopWatchStartLo = TlsAlloc();
        liStopWatchStart.QuadPart = 0;

        QueryPerformanceFrequency(&g_liStopWatchFreq);      // Only a one time call since it's value can't change while the system is running.
    }
    else
    {
        liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
        liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    }

    AssertMsg((0 == liStopWatchStart.QuadPart), TEXT("Someone else is using our perf timer.  Stop nesting.")); // If you hit this, then the stopwatch is nested.
    QueryPerformanceCounter(&liStopWatchStart);

    TlsSetValue(g_TLSliStopWatchStartHi, IntToPtr(liStopWatchStart.HighPart));
    TlsSetValue(g_TLSliStopWatchStartLo, IntToPtr(liStopWatchStart.LowPart));
}

DWORD DebugStopWatch(void)
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liStopWatchStart;
    
    QueryPerformanceCounter(&liDiff);
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    liDiff.QuadPart -= liStopWatchStart.QuadPart;

    ASSERT(0 != g_liStopWatchFreq.QuadPart);    // I don't like to fault with div 0.
    DWORD dwTime = (DWORD)((liDiff.QuadPart * 1000) / g_liStopWatchFreq.QuadPart);

    TlsSetValue(g_TLSliStopWatchStartHi, (LPVOID) 0);
    TlsSetValue(g_TLSliStopWatchStartLo, (LPVOID) 0);

    return dwTime;
}
#endif // DEBUG






/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////
HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////
// File System Wrapping Helpers
/////////////////////////////////////////////////////////////////////
HRESULT HrSHFileOpDeleteFile(HWND hwnd, FILEOP_FLAGS dwFlags, LPTSTR pszPath)
{
    HRESULT hr = S_OK;
    SHFILEOPSTRUCT FileOp = {0};

    pszPath[lstrlen(pszPath)+1] = 0;  // Ensure double terminated.

    FileOp.wFunc = FO_DELETE;
    FileOp.fAnyOperationsAborted = TRUE;
    FileOp.hwnd = hwnd;
    FileOp.pFrom = pszPath;
    FileOp.fFlags = dwFlags;

    if (SHFileOperation(&FileOp))
    {
        hr = ResultFromLastError();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////
// Registry Helpers
/////////////////////////////////////////////////////////////////////
HRESULT HrRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
    DWORD dwError = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    return ResultFromWin32(dwError);
}


HRESULT HrRegCreateKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, 
       REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
    DWORD dwError = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    return ResultFromWin32(dwError);
}


HRESULT HrRegQueryValueEx(IN HKEY hKey, IN LPCTSTR lpValueName, IN LPDWORD lpReserved, IN LPDWORD lpType, IN LPBYTE lpData, IN LPDWORD lpcbData)
{
    DWORD dwError = RegQueryValueEx(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

    return ResultFromWin32(dwError);
}


HRESULT HrRegSetValueEx(IN HKEY hKey, IN LPCTSTR lpValueName, IN DWORD dwReserved, IN DWORD dwType, IN CONST BYTE *lpData, IN DWORD cbData)
{
    DWORD dwError = RegSetValueEx(hKey, lpValueName, dwReserved, dwType, lpData, cbData);

    return ResultFromWin32(dwError);
}


HRESULT HrRegEnumValue(HKEY hKey, DWORD dwIndex, LPTSTR lpValueName, LPDWORD lpcValueName, LPDWORD lpReserved,
        LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
    DWORD dwError = RegEnumValue(hKey, dwIndex, lpValueName, lpcValueName, lpReserved, lpType, lpData, lpcbData);

    return ResultFromWin32(dwError);
}


HRESULT HrRegQueryInfoKey(HKEY hKey, LPTSTR lpClass, LPDWORD lpcClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcMaxSubKeyLen, 
            LPDWORD lpcMaxClassLen, LPDWORD lpcValues, LPDWORD lpcMaxValueNameLen, LPDWORD lpcMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
{
    DWORD dwError = RegQueryInfoKey(hKey, lpClass, lpcClass, lpReserved, lpcSubKeys, lpcMaxSubKeyLen, 
            lpcMaxClassLen, lpcValues, lpcMaxValueNameLen, lpcMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);

    return ResultFromWin32(dwError);
}


HRESULT HrBStrRegQueryValue(IN HKEY hKey, IN LPCTSTR lpValueName, OUT BSTR * pbstr)
{
    TCHAR szValue[MAX_PATH];
    DWORD dwType;
    DWORD cbSize = sizeof(szValue);
    HRESULT hr = HrRegQueryValueEx(hKey, lpValueName, 0, &dwType, (BYTE *)szValue, &cbSize);

    *pbstr = NULL;
    if (SUCCEEDED(hr))
    {
        hr = HrSysAllocStringW(szValue, pbstr);
    }

    return hr;
}


HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType,
                    OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData)
{
    DWORD dwError = SHGetValue(hKey, pszSubKey, pszValue, pdwType, pvData, pcbData);

    return ResultFromWin32(dwError);
}


HRESULT HrSHSetValue(IN HKEY hkey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwType, OPTIONAL OUT LPVOID pvData, IN DWORD cbData)
{
    DWORD dwError = SHSetValue(hkey, pszSubKey, pszValue, dwType, pvData, cbData);

    return ResultFromWin32(dwError);
}


HRESULT HrRegSetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, OUT LPCWSTR pszString)
{
    DWORD cbSize = ((lstrlenW(pszString) + 1) * sizeof(pszString[0]));

    return  HrSHSetValue(hKey, pszSubKey, pszValueName, REG_SZ, (BYTE *)pszString, cbSize);
}


HRESULT HrRegGetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, IN LPWSTR pszString, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszString[0]));

    HRESULT hr = HrSHGetValue(hKey, pszSubKey, pszValueName, &dwType, (BYTE *)pszString, &cbSize);
    if (SUCCEEDED(hr) && (REG_SZ != dwType))
    {
        hr = E_FAIL;
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        This function will store paths in the registry.  The user calls the
    fuction with full paths are they are converted to relative path.  The
    strings prefer to be stored in REG_EXPAND_SZ, but it will fallback to
    REG_SZ if needed.
\*****************************************************************************/
HRESULT HrRegSetPath(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, BOOL fUseExpandSZ, OUT LPCWSTR pszPath)
{
    TCHAR szFinalPath[MAX_PATH];

    if (!PathUnExpandEnvStrings(pszPath, szFinalPath, ARRAYSIZE(szFinalPath)))
    {
        StringCchCopy(szFinalPath, ARRAYSIZE(szFinalPath), pszPath);  // We failed so use the original.
    }

    DWORD cbSize = ((lstrlenW(szFinalPath) + 1) * sizeof(szFinalPath[0]));
    HRESULT hr = E_FAIL;

    if (fUseExpandSZ)
    {
        hr = HrSHSetValue(hKey, pszSubKey, pszValueName, REG_EXPAND_SZ, (BYTE *)szFinalPath, cbSize);
    }

    if (FAILED(hr))
    {
        // Maybe it already exists as a REG_SZ so we will store it there.  Note that we are still storing it
        // unexpanded even thought it's in REG_SZ.  If the caller does not like it, use
        // another function like SHRegSetPath().
        cbSize = ((lstrlenW(szFinalPath) + 1) * sizeof(szFinalPath[0]));
        hr = HrSHSetValue(hKey, pszSubKey, pszValueName, REG_SZ, (BYTE *)szFinalPath, cbSize);
    }

    return  hr;
}


HRESULT HrRegGetPath(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, IN LPWSTR pszPath, IN DWORD cchSize)
{
    TCHAR szFinalPath[MAX_PATH];
    DWORD dwType;
    DWORD cbSize = sizeof(szFinalPath);

    HRESULT hr = HrSHGetValue(hKey, pszSubKey, pszValueName, &dwType, (BYTE *)szFinalPath, &cbSize);
    if (SUCCEEDED(hr) &&
        ((REG_EXPAND_SZ == dwType) || (REG_SZ == dwType)))
    {
        if (0 == SHExpandEnvironmentStrings(szFinalPath, pszPath, cchSize))
        {
            StringCchCopy(pszPath, cchSize, szFinalPath);  // We failed so use the original.
        }
    }

    return  hr;
}


HRESULT HrRegDeleteValue(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName)
{
    HRESULT hr = S_OK;
    HKEY hKeySub = hKey;

    if (pszSubKey)
    {
        hr = HrRegOpenKeyEx(hKey, pszSubKey, 0, KEY_WRITE, &hKeySub);
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwError = RegDeleteValue(hKeySub, pszValueName);

        hr = ResultFromWin32(dwError);
    }

    if (hKeySub == hKey)
    {
        RegCloseKey(hKeySub);
    }

    return hr;
}


DWORD HrRegGetDWORD(HKEY hKey, LPCWSTR szKey, LPCWSTR szValue, DWORD dwDefault)
{
    DWORD dwResult = dwDefault;
    DWORD cbSize = sizeof(dwResult);
    DWORD dwType;
    DWORD dwError = SHGetValue(hKey, szKey, szValue, &dwType, &dwResult, &cbSize);

    if ((ERROR_SUCCESS != dwError) ||
        ((REG_DWORD != dwType) && (REG_BINARY != dwType)) || (sizeof(dwResult) != cbSize))
    {
        return dwDefault;
    }

    return dwResult;
}


HRESULT HrRegSetDWORD(HKEY hKey, LPCWSTR szKey, LPCWSTR szValue, DWORD dwData)
{
    DWORD dwError = SHSetValue(hKey, szKey, szValue, REG_DWORD, &dwData, sizeof(dwData));

    return ResultFromWin32(dwError);
}








/////////////////////////////////////////////////////////////////////
// Palette Helpers
/////////////////////////////////////////////////////////////////////
COLORREF GetNearestPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    PALETTEENTRY pe = {0};
    UINT nIndex = GetNearestPaletteIndex(hpal, rgb & 0x00FFFFFF);

    if (CLR_INVALID != nIndex)
    {
        GetPaletteEntries(hpal, nIndex, 1, &pe);
    }

    return RGB(pe.peRed, pe.peGreen, pe.peBlue);
}


BOOL IsPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    return GetNearestPaletteColor(hpal, rgb) == (rgb & 0xFFFFFF);
}



BOOL _InitComCtl32()
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = (ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES | ICC_COOL_CLASSES | ICC_INTERNET_CLASSES | ICC_PAGESCROLLER_CLASS | ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES | ICC_LINK_CLASS);
        fInitialized = InitCommonControlsEx(&icc);
    }
    return fInitialized;
}


DWORD GetCurrentSessionID(void)
{
    DWORD dwProcessID = (DWORD) -1;
    ProcessIdToSessionId(GetCurrentProcessId(), &dwProcessID);

    return dwProcessID;
}

typedef struct
{
    LPCWSTR pszRegKey;
    LPCWSTR pszRegValue;
} TSPERFFLAG_ITEM;

const TSPERFFLAG_ITEM s_TSPerfFlagItems[] =
{
    {L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Remote\\%d", L"ActiveDesktop"},              // TSPerFlag_NoADWallpaper
    {L"Remote\\%d\\Control Panel\\Desktop", L"Wallpaper"},                                                  // TSPerFlag_NoWallpaper
    {L"Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager\\Remote\\%d", L"ThemeActive"},            // TSPerFlag_NoVisualStyles
    {L"Remote\\%d\\Control Panel\\Desktop", L"DragFullWindows"},                                            // TSPerFlag_NoWindowDrag
    {L"Remote\\%d\\Control Panel\\Desktop", L"SmoothScroll"},                                               // TSPerFlag_NoAnimation
};


BOOL IsTSPerfFlagEnabled(enumTSPerfFlag eTSFlag)
{
    BOOL fIsTSFlagEnabled = FALSE;
    static BOOL s_fTSSession = -10;

    if (-10 == s_fTSSession)
    {
        s_fTSSession = GetSystemMetrics(SM_REMOTESESSION);
    }

    if (s_fTSSession)
    {
        TCHAR szTemp[MAX_PATH];
        DWORD dwType;
        DWORD cbSize = sizeof(szTemp);
        TCHAR szRegKey[MAX_PATH];

        StringCchPrintf(szRegKey, ARRAYSIZE(szRegKey), s_TSPerfFlagItems[eTSFlag].pszRegKey, GetCurrentSessionID());

        if (ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szRegKey, s_TSPerfFlagItems[eTSFlag].pszRegValue, &dwType, (void *)szTemp, &cbSize))
        {
            fIsTSFlagEnabled = TRUE;
        }
    }

    return fIsTSFlagEnabled;
}


HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd)
{
    HRESULT hr = S_OK;
    HINSTANCE hReturn = ShellExecute(hwnd, lpVerb, lpFile, lpParameters, lpDirectory, nShowCmd);

    if ((HINSTANCE)32 > hReturn)
    {
        hr = ResultFromLastError();
    }

    return hr;
}


HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPTSTR pszTempLastHalf = NULL;
    LPTSTR pszNextToken = pszString;

    while (0 != (pszNextToken = StrStrI(pszNextToken, pszToken)))
    {
        // We found one.
        LPTSTR pszPastToken = pszNextToken + lstrlen(pszToken);

        Str_SetPtr(&pszTempLastHalf, pszPastToken);      // Keep a copy because we will overwrite it.

        pszNextToken[0] = 0;    // Remove the rest of the string.
        StringCchCat(pszString, cchSize, pszReplaceValue);
        StringCchCat(pszString, cchSize, pszTempLastHalf);

        pszNextToken += lstrlen(pszReplaceValue);
    }

    Str_SetPtr(&pszTempLastHalf, NULL);

    return hr;
}


HRESULT HrWritePrivateProfileStringW(LPCWSTR pszAppName, LPCWSTR pszKeyName, LPCWSTR pszString, LPCWSTR pszFileName)
{
    HRESULT hr = S_OK;

    if (!WritePrivateProfileStringW(pszAppName, pszKeyName, pszString, pszFileName))
    {
        hr = ResultFromLastError();
    }

    return hr;
}


BOOL IUnknown_CompareCLSID(IN IUnknown * punk, IN CLSID clsid)
{
    BOOL fIsEqual = FALSE;

    if (punk)
    {
        CLSID clsidPageID;
        HRESULT hr = IUnknown_GetClassID(punk, &clsidPageID);

        if (SUCCEEDED(hr) && IsEqualCLSID(clsidPageID, clsid))
        {
            fIsEqual = TRUE;
        }
    }

    return fIsEqual;
}


HRESULT IEnumUnknown_FindCLSID(IN IUnknown * punk, IN CLSID clsid, OUT IUnknown ** ppunkFound)
{
    HRESULT hr = E_INVALIDARG;

    if (punk && ppunkFound)
    {
        IEnumUnknown * pEnum;

        *ppunkFound = NULL;
        hr = punk->QueryInterface(IID_PPV_ARG(IEnumUnknown, &pEnum));
        if (SUCCEEDED(hr))
        {
            IUnknown * punkToTry;
            ULONG ulFetched;

            pEnum->Reset();

            hr = E_FAIL;
            while (SUCCEEDED(pEnum->Next(1, &punkToTry, &ulFetched)) &&
                (1 == ulFetched))
            {
                if (IUnknown_CompareCLSID(punkToTry, clsid))
                {
                    *ppunkFound = punkToTry;
                    hr = S_OK;
                    break;
                }

                punkToTry->Release();
            }

            pEnum->Release();
        }
    }

    return hr;
}


BYTE WINAPI MyStrToByte(LPCTSTR sz)
{
    BYTE l=0;

    while (*sz >= TEXT('0') && *sz <= TEXT('9'))
    {
        l = (BYTE) l*10 + (*sz++ - TEXT('0'));
    }

    return l;
}


COLORREF ConvertColor(LPTSTR pszColor)
{
    BYTE RGBTemp[3];
    LPTSTR pszTemp = pszColor;
    UINT i;

    if (!pszColor || !*pszColor)
    {
        return RGB(0,0,0);
    }

    for (i =0; i < 3; i++)
    {
        // Remove leading spaces
        while (*pszTemp == TEXT(' '))
        {
            pszTemp++;
        }

        // Set pszColor to the beginning of the number
        pszColor = pszTemp;

        // Find the end of the number and null terminate
        while ((*pszTemp) && (*pszTemp != TEXT(' ')))
        {
            pszTemp++;
        }

        if (*pszTemp != TEXT('\0'))
        {
            *pszTemp = TEXT('\0');
        }

        pszTemp++;
        RGBTemp[i] = MyStrToByte(pszColor);
    }

    return (RGB(RGBTemp[0], RGBTemp[1], RGBTemp[2]));
}



// Paremeters:
//  hwndOwner  -- owner window
//  idTemplate -- specifies template (e.g., "Can't open %2%s\n\n%1%s")
//  hr         -- specifies the HRESULT error code
//  pszParam   -- specifies the 2nd parameter to idTemplate
//  dwFlags    -- flags for MessageBox
UINT ErrorMessageBox(HWND hwndOwner, LPCTSTR pszTitle, UINT idTemplate, HRESULT hr, LPCTSTR pszParam, UINT dwFlags)
{
    TCHAR szErrNumString[MAX_PATH * 2];
    TCHAR szTemplate[MAX_PATH * 2];
    TCHAR szErrMsg[MAX_PATH * 2];

    if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr, 0, szErrNumString, ARRAYSIZE(szErrNumString), NULL))
    {
        szErrNumString[0] = 0;      // We will not be able to display an error message.
    }

    // These error messages are so useless to customers, that we prefer to leave it blank.
    if ((E_INVALIDARG == hr) ||
        (ResultFromWin32(ERROR_INVALID_PARAMETER) == hr))
    {
        szErrNumString[0] = 0; 
    }

    LoadString(HINST_THISDLL, idTemplate, szTemplate, ARRAYSIZE(szTemplate));
    if (pszParam)
    {
        StringCchPrintf(szErrMsg, ARRAYSIZE(szErrMsg), szTemplate, szErrNumString, pszParam);
    }
    else
    {
        StringCchPrintf(szErrMsg, ARRAYSIZE(szErrMsg), szTemplate, szErrNumString);
    }

    return MessageBox(hwndOwner, szErrMsg, pszTitle, (MB_OK | MB_ICONERROR));
}


HRESULT DisplayThemeErrorDialog(HWND hwndParent, HRESULT hrError, UINT nTitle, UINT nTemplate)
{
    HRESULT hr = S_OK;

    if (FAILED(hrError))
    {
        hr = ResultFromWin32(ERROR_CANCELLED);
        if (!g_fInSetup &&           // Don't display an error during setup.
            (ResultFromWin32(ERROR_CANCELLED) != hrError))
        {
            //---- get error from theme manager ----
            WCHAR szErrorMsg[MAX_PATH*2];
            WCHAR szTitle[MAX_PATH];

            szErrorMsg[0] = 0;      // In case the error function fails.
            if (FAILED(hrError))
            {
                PARSE_ERROR_INFO Info = {sizeof(Info)};

                if (SUCCEEDED(GetThemeParseErrorInfo(&Info)))
                {
                    StringCchCopy(szErrorMsg, ARRAYSIZE(szErrorMsg), Info.szMsg);
                }
                else
                {
                    *szErrorMsg = 0;        // no error avail
                }
            }

            // We want to display UI if an error occured here.  We want to do
            // it instead of our parent because THEMELOADPARAMS contains
            // extra error information that we can't pass back to the caller.
            // However, we will only display error UI if our caller wants us
            // to.  We determine that by the fact that they make an hwnd available
            // to us.  We get the hwnd by getting our site pointer and getting
            // the hwnd via ::GetWindow().
            LoadString(HINST_THISDLL, nTitle, szTitle, ARRAYSIZE(szTitle));
            ErrorMessageBox(hwndParent, szTitle, nTemplate, hrError, szErrorMsg, (MB_OK | MB_ICONEXCLAMATION));
        }
    }

    return hr;
}


extern BOOL FadeEffectAvailable(void);

void LogStartInformation(void)
{
    BOOL fTemp;

    // Frequently users will report that something is broken in the Display CPL.
    // However, the real problem is that someone turned on a policy that locks UI
    // and the user didn't know that the policy was enabled.  We log those here so
    // it's quick to find those issues.
    if (SHRestricted(REST_NODISPLAYCPL)) LogStatus("POLICY ENABLED: Do not show the Display CPL.");
    if (SHRestricted(REST_NODISPLAYAPPEARANCEPAGE)) LogStatus("POLICY ENABLED: Hide the Themes and Appearance tab.");
    if (SHRestricted(REST_NOTHEMESTAB)) LogStatus("POLICY ENABLED: Hide the Themes tab.");
    if (SHRestricted(REST_NODISPBACKGROUND)) LogStatus("POLICY ENABLED: Hide the Desktop tab.");
    if (SHRestricted(REST_NODISPSCREENSAVEPG)) LogStatus("POLICY ENABLED: Hide the ScreenSaver tab.");
    if (SHRestricted(REST_NODISPSETTINGSPG)) LogStatus("POLICY ENABLED: Hide the Settings tab.");
    if (SHRestricted(REST_NOVISUALSTYLECHOICE)) LogStatus("POLICY ENABLED: User not allowed to change the Visual Style.");
    if (SHRestricted(REST_NOCOLORCHOICE)) LogStatus("POLICY ENABLED: User Not allowed to change the Visual Style Color Selection.");
    if (SHRestricted(REST_NOSIZECHOICE)) LogStatus("POLICY ENABLED: User not allowed to change the Visual Style size selection.");

    if (0 != SHGetRestriction(NULL,POLICY_KEY_EXPLORER,POLICY_VALUE_ANIMATION)) LogStatus("POLICY ENABLED: Policy disallows fade effect. (Effects dialog)");
    if (0 != SHGetRestriction(NULL,POLICY_KEY_EXPLORER, POLICY_VALUE_KEYBOARDNAV)) LogStatus("POLICY ENABLED: Policy disallows changing underline key accell. (Effects dialog)");
    if (0 != SHGetRestriction(NULL,POLICY_KEY_ACTIVEDESKTOP, SZ_POLICY_NOCHANGEWALLPAPER)) LogStatus("POLICY ENABLED: Policy disallows changing wallpaper. (Desktop tab)");
    if (0 != SHGetRestriction(NULL,POLICY_KEY_SYSTEM, SZ_POLICY_NODISPSCREENSAVERPG)) LogStatus("POLICY ENABLED: Policy hides ScreenSaver page.");
    if (0 != SHGetRestriction(SZ_REGKEY_POLICIES_DESKTOP, NULL, SZ_POLICY_SCREENSAVEACTIVE)) LogStatus("POLICY ENABLED: Policy forces screensaver on or off");
    if (0 != SHGetRestriction(NULL,POLICY_KEY_EXPLORER, POLICY_VALUE_KEYBOARDNAV)) LogStatus("POLICY ENABLED: Policy disallows changing underline key accell. (Effects dialog)");

    if (IsTSPerfFlagEnabled(TSPerFlag_NoAnimation)) LogStatus("POLICY ENABLED: TS Perf Policy disallows animations. (Effects dialog)");
    if (IsTSPerfFlagEnabled(TSPerFlag_NoWindowDrag)) LogStatus("POLICY ENABLED: TS Perf Policy disallows full window drag. (Effects dialog)");
    if (IsTSPerfFlagEnabled(TSPerFlag_NoVisualStyles)) LogStatus("POLICY ENABLED: TS Perf Policy disallows visual styles.");
    if (IsTSPerfFlagEnabled(TSPerFlag_NoWallpaper)) LogStatus("POLICY ENABLED: TS Perf Policy disallows Wallpaper.");
    if (IsTSPerfFlagEnabled(TSPerFlag_NoADWallpaper)) LogStatus("POLICY ENABLED: TS Perf Policy disallows AD Wallpaper.");

    if (!FadeEffectAvailable()) LogStatus("POLICY ENABLED: A policy forces Fade Effects off (Effects dialog)");

    if (!ClassicSystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, (PVOID)&fTemp, 0)) LogStatus("POLICY ENABLED: SPI_GETFONTSMOOTHINGTYPE hides FontSmoothing. (Effects dialog)");
    if (ClassicSystemParametersInfo(SPI_GETUIEFFECTS, 0, (PVOID) &fTemp, 0) && !fTemp) LogStatus("POLICY ENABLED: SPI_GETUIEFFECTS hides lots of UI effects. (Effects dialog)");
    if (ClassicSystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, (PVOID) &fTemp, 0) && !fTemp) LogStatus("POLICY ENABLED: SPI_GETGRADIENTCAPTIONS turns off Caption bar Gradients. (Advance Appearance)");
}


void LogStatus(LPCSTR pszMessage, ...)
{
    static int nLogOn = -1;
    va_list vaParamList;

    va_start(vaParamList, pszMessage);

    if (-1 == nLogOn)
    {
        nLogOn = (SHRegGetBoolUSValue(SZ_THEMES, SZ_REGVALUE_LOGINFO, FALSE, FALSE) ? 1 : 0);
    }

    if (1 == nLogOn)
    {
        if (INVALID_HANDLE_VALUE == g_hLogFile)
        {
            TCHAR szPath[MAX_PATH];

            if (GetWindowsDirectory(szPath, ARRAYSIZE(szPath)))
            {
                if (PathAppend(szPath, TEXT("Theme.log")))
                {
                    g_hLogFile = CreateFile(szPath, (GENERIC_READ | GENERIC_WRITE), FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                    if (INVALID_HANDLE_VALUE != g_hLogFile)
                    {
                        WCHAR szUserName[MAX_PATH];
                        CHAR szTimeDate[MAX_PATH];
                        CHAR szHeader[MAX_PATH];
                        FILETIME ftCurrentUTC;
                        FILETIME ftCurrent;
                        SYSTEMTIME stCurrent;
                        DWORD cbWritten;

                        SetFilePointer(g_hLogFile, 0, NULL, FILE_END);
                        
                        GetLocalTime(&stCurrent);
                        SystemTimeToFileTime(&stCurrent, &ftCurrent);
                        LocalFileTimeToFileTime(&ftCurrent, &ftCurrentUTC);
                        SHFormatDateTimeA(&ftCurrentUTC, NULL, szTimeDate, ARRAYSIZE(szTimeDate));

                        ULONG cchUserSize = ARRAYSIZE(szUserName);
                        if (!GetUserNameEx(NameDisplay, szUserName, &cchUserSize) &&
                            !GetUserNameEx(NameUserPrincipal, szUserName, &cchUserSize) &&
                            !GetUserNameEx(NameSamCompatible, szUserName, &cchUserSize) &&
                            !GetUserNameEx(NameUniqueId, szUserName, &cchUserSize))
                        {
                            szUserName[0] = 0;
                        }

                        TCHAR szProcess[MAX_PATH];
                        if (!GetModuleFileName(NULL, szProcess, ARRAYSIZE(szProcess)))
                        {
                            szProcess[0] = 0;
                        }

                        StringCchPrintfA(szHeader, ARRAYSIZE(szHeader), "\r\n\r\n%hs - USER: %ls (%ls)\r\n", szTimeDate, szUserName, szProcess);
                        WriteFile(g_hLogFile, szHeader, lstrlenA(szHeader), &cbWritten, NULL);

                        // Log information that we need to do on every startup.  (Like Policies that are on that confuse people)
                        LogStartInformation();
                    }
                }
            }
        }

        if (INVALID_HANDLE_VALUE != g_hLogFile)
        {
            CHAR szMessage[4000];
            DWORD cbWritten;
            StringCchVPrintfA(szMessage, ARRAYSIZE(szMessage), pszMessage, vaParamList);
            WriteFile(g_hLogFile, szMessage, lstrlenA(szMessage), &cbWritten, NULL);
        }
    }

    va_end(vaParamList);
}


void LogSystemMetrics(LPCSTR pszMessage, SYSTEMMETRICSALL * pSystemMetrics)
{
    CHAR szSysMetrics[1024];        // Random because it's big.
    
    if (pSystemMetrics)
    {
        StringCchPrintfA(szSysMetrics, ARRAYSIZE(szSysMetrics), "Sz(Brdr=%d, Scrl=%d, Cap=%d, Menu=%d, Icon=%d, DXIn=%d) Ft(Cap=%d(%d), SmCap=%d(%d), Menu=%d(%d), Stus=%d(%d), Msg=%d(%d))", 
                pSystemMetrics->schemeData.ncm.iBorderWidth,
                pSystemMetrics->schemeData.ncm.iScrollWidth,
                pSystemMetrics->schemeData.ncm.iCaptionHeight,
                pSystemMetrics->schemeData.ncm.iMenuHeight,
                pSystemMetrics->nIcon,
                pSystemMetrics->nDYIcon,
                pSystemMetrics->schemeData.ncm.lfCaptionFont.lfHeight,
                pSystemMetrics->schemeData.ncm.lfCaptionFont.lfCharSet,
                pSystemMetrics->schemeData.ncm.lfSmCaptionFont.lfHeight,
                pSystemMetrics->schemeData.ncm.lfSmCaptionFont.lfCharSet,
                pSystemMetrics->schemeData.ncm.lfMenuFont.lfHeight,
                pSystemMetrics->schemeData.ncm.lfMenuFont.lfCharSet,
                pSystemMetrics->schemeData.ncm.lfStatusFont.lfHeight,
                pSystemMetrics->schemeData.ncm.lfStatusFont.lfCharSet,
                pSystemMetrics->schemeData.ncm.lfMessageFont.lfHeight,
                pSystemMetrics->schemeData.ncm.lfMessageFont.lfCharSet);
    }
    else
    {
        szSysMetrics[0] = 0;
    }

    LogStatus("SYSMET: %s: %s\r\n", pszMessage, szSysMetrics);
}



HRESULT SHGetResourcePath(BOOL fLocaleNode, IN LPWSTR pszPath, IN DWORD cchSize)
{
    DWORD dwFlags = (CSIDL_FLAG_CREATE | CSIDL_RESOURCES);

    return SHGetFolderPath(NULL, dwFlags, NULL, 0, pszPath);
}


#define SZ_RESOURCEDIR_TOKEN        TEXT("%ResourceDir%")
#define SZ_RESOURCELDIR_TOKEN       TEXT("%ResourceDirL%")
HRESULT ExpandResourceDir(IN LPWSTR pszPath, IN DWORD cchSize)
{
    HRESULT hr = S_OK;
    BOOL fLocalized = FALSE;
    LPCTSTR pszToken = StrStrW(pszPath, SZ_RESOURCEDIR_TOKEN);

    if (!pszToken)
    {
        pszToken = StrStrW(pszPath, SZ_RESOURCELDIR_TOKEN);
    }

    // Do we have stuff to replace?
    if (pszToken)
    {
        // Yes, so get the replacement value.
        WCHAR szResourceDir[MAX_PATH];

        hr = SHGetResourcePath(fLocalized, szResourceDir, ARRAYSIZE(szResourceDir));
        if (SUCCEEDED(hr))
        {
            hr = StrReplaceToken((fLocalized ? SZ_RESOURCELDIR_TOKEN : SZ_RESOURCEDIR_TOKEN), szResourceDir, pszPath, cchSize);
        }
    }

    return hr;
}


STDAPI SHPropertyBag_WritePunk(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN IUnknown * punk)
{
    HRESULT hr = E_INVALIDARG;

    if (pPropertyPage && pwzPropName)
    {
        VARIANT va;

        va.vt = VT_UNKNOWN;
        va.punkVal = punk;

        hr = pPropertyPage->Write(pwzPropName, &va);
    }

    return hr;
}


STDAPI SHPropertyBag_ReadByRef(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN void * p, IN SIZE_T cbSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pPropertyPage && pwzPropName && p)
    {
        VARIANT va;

        hr = pPropertyPage->Read(pwzPropName, &va, NULL);
        if (SUCCEEDED(hr))
        {
            if ((VT_BYREF == va.vt) && va.byref)
            {
                CopyMemory(p, va.byref, cbSize);
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


STDAPI SHPropertyBag_WriteByRef(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN void * p)
{
    HRESULT hr = E_INVALIDARG;

    if (pPropertyPage && pwzPropName && p)
    {
        VARIANT va;

        va.vt = VT_BYREF;
        va.byref = p;
        hr = pPropertyPage->Write(pwzPropName, &va);
    }

    return hr;
}

LONG s_cSpiDummy = -1;
LONG *g_pcSpiThreads = &s_cSpiDummy;

void SPISetThreadCounter(LONG *pcThreads)
{
    if (!pcThreads)
        pcThreads = &s_cSpiDummy;
    InterlockedExchangePointer((void **) &g_pcSpiThreads, pcThreads);
}

typedef struct 
{
    LPTHREAD_START_ROUTINE pfnThreadProc;
    void *pvData;
    UINT idThread;
}SPITHREAD;

DWORD CALLBACK _SPIWrapperThreadProc(void *pv)
{
    SPITHREAD *pspi = (SPITHREAD *)pv;
    DWORD dwRet = pspi->pfnThreadProc(pspi->pvData);
    //  then we check to see 
    ASSERT( 0 != *g_pcSpiThreads );
    if (0 == InterlockedDecrement(g_pcSpiThreads))
    {
        PostThreadMessage(pspi->idThread, WM_NULL, 0, 0);
    }
    delete pspi;
    return dwRet;
}

BOOL SPICreateThread(LPTHREAD_START_ROUTINE pfnThreadProc, void *pvData)
{
    SPITHREAD *pspi = new SPITHREAD;
    if (pspi)
    {
        pspi->idThread = GetCurrentThreadId();
        pspi->pfnThreadProc = pfnThreadProc;
        pspi->pvData = pvData;
        InterlockedIncrement(g_pcSpiThreads);
        return SHCreateThread(_SPIWrapperThreadProc, pspi, (CTF_COINIT | CTF_INSIST | CTF_FREELIBANDEXIT), NULL);
    }
    else
    {
        // CTF_INSIST
        pfnThreadProc(pvData);
        return TRUE;
    }
}

void PostMessageBroadAsync(IN UINT Msg, IN WPARAM wParam, IN LPARAM lParam)
{
    // We don't want to hang our UI if other apps are hung or slow when
    // we need to tell them to update their changes.  So we choose this
    // mechanism.
    //
    // The alternatives are:
    // SendMessageCallback: Except we don't need to do anything when the apps
    //   are done.
    // SendMessageTimeout: Except we don't want to incure any timeout.
    PostMessage(HWND_BROADCAST, Msg, wParam, lParam);
}


typedef struct
{
    BOOL fFree;         // Do you need to call LocalFree() on pvData?
    UINT uiAction;
    UINT uiParam;
    UINT fWinIni;
    void * pvData;
    CDimmedWindow* pDimmedWindow;
} SPIS_INFO;

DWORD SystemParametersInfoAsync_WorkerThread(IN void *pv)
{
    SPIS_INFO * pSpisInfo = (SPIS_INFO *) pv;
    HINSTANCE hInstance = LoadLibrary(TEXT("desk.cpl"));

    if (pSpisInfo)
    {
        ClassicSystemParametersInfo(pSpisInfo->uiAction, pSpisInfo->uiParam, pSpisInfo->pvData, pSpisInfo->fWinIni);
        if (pSpisInfo->fFree && pSpisInfo->pvData)
        {
            LocalFree(pSpisInfo->pvData);
        }

        if (pSpisInfo->pDimmedWindow)
        {
            pSpisInfo->pDimmedWindow->Release();
        }

        LocalFree(pv);
    }

    if (hInstance)
    {
        FreeLibrary(hInstance);
    }

    return 0;
}


void SystemParametersInfoAsync(IN UINT uiAction, IN UINT uiParam, IN void * pvParam, IN DWORD cbSize, IN UINT fWinIni, IN CDimmedWindow* pDimmedWindow)
{
    // ClassicSystemParametersInfo() will hang if a top level window is hung (#162570) and USER will not fix that bug.
    // Therefore, we need to make that API call on a background thread because we need to
    // be more rebust than to hang.
    SPIS_INFO * pSpisInfo = (SPIS_INFO *) LocalAlloc(LPTR, sizeof(*pSpisInfo));

    if (pSpisInfo)
    {
        BOOL fAsyncOK = TRUE;

        pSpisInfo->fFree = (0 != cbSize);
        pSpisInfo->pvData = pvParam;
        pSpisInfo->uiAction = uiAction;
        pSpisInfo->uiParam = uiParam;
        pSpisInfo->fWinIni = fWinIni;
        pSpisInfo->pDimmedWindow = pDimmedWindow;
        // Spawning thread is responsible for addref dimmed window, but not releasing
        // that is the repsonsibility of the spawned thread
        if (pSpisInfo->pDimmedWindow)
        {
            pSpisInfo->pDimmedWindow->AddRef();
        }

        if (pSpisInfo->fFree)
        {
            pSpisInfo->pvData = LocalAlloc(LPTR, cbSize);
            if (!pSpisInfo->pvData)
            {
                pSpisInfo->pvData = pvParam;
                fAsyncOK = FALSE;
                pSpisInfo->fFree = FALSE;
            }
            else
            {
                CopyMemory(pSpisInfo->pvData, pvParam, cbSize);
            }
        }

        if (fAsyncOK)
            SPICreateThread(SystemParametersInfoAsync_WorkerThread, (void *)pSpisInfo);
        else
            SystemParametersInfoAsync_WorkerThread((void *)pSpisInfo);
    }
}


HRESULT GetCurrentUserCustomName(LPWSTR pszDisplayName, DWORD cchSize)
{
    HRESULT hr = S_OK;

    // It failed, so load "My Custom Theme".  This may happen on personal.
    LoadString(HINST_THISDLL, IDS_MYCUSTOMTHEME, pszDisplayName, cchSize);

    return hr;
}


HRESULT InstallVisualStyle(IThemeManager * pThemeManager, LPCTSTR pszVisualStylePath, LPCTSTR pszVisualStyleColor, LPCTSTR pszVisualStyleSize)
{
    HRESULT hr = E_OUTOFMEMORY;
    CComVariant varTheme(pszVisualStylePath);

    if (varTheme.bstrVal)
    {
        IThemeScheme * pVisualStyle;

        hr = pThemeManager->get_schemeItem(varTheme, &pVisualStyle);
        if (SUCCEEDED(hr))
        {
            CComVariant varStyleName(pszVisualStyleColor);

            if (!varStyleName.bstrVal)
                hr = E_OUTOFMEMORY;
            else
            {
                IThemeStyle * pThemeStyle;

                hr = pVisualStyle->get_item(varStyleName, &pThemeStyle);
                if (SUCCEEDED(hr))
                {
                    CComVariant varSizeName(pszVisualStyleSize);

                    if (!varSizeName.bstrVal)
                        hr = E_OUTOFMEMORY;
                    else
                    {
                        IThemeSize * pThemeSize;

                        hr = pThemeStyle->get_item(varSizeName, &pThemeSize);
                        if (SUCCEEDED(hr))
                        {
                            hr = pThemeStyle->put_SelectedSize(pThemeSize);
                            if (SUCCEEDED(hr))
                            {
                                hr = pVisualStyle->put_SelectedStyle(pThemeStyle);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pThemeManager->put_SelectedScheme(pVisualStyle);
                                }
                            }

                            pThemeSize->Release();
                        }
                    }

                    pThemeStyle->Release();
                }
            }

            pVisualStyle->Release();
        }
    }

    return hr;
}


// {B2A7FD52-301F-4348-B93A-638C6DE49229}
DEFINE_GUID(CLSID_WMPSkinMngr, 0xB2A7FD52, 0x301F, 0x4348, 0xB9, 0x3A, 0x63, 0x8C, 0x6D, 0xE4, 0x92, 0x29);

// {076F2FA6-ED30-448B-8CC5-3F3EF3529C7A}
DEFINE_GUID(IID_IWMPSkinMngr, 0x076F2FA6, 0xED30, 0x448B, 0x8C, 0xC5, 0x3F, 0x3E, 0xF3, 0x52, 0x9C, 0x7A);

HRESULT ApplyVisualStyle(LPCTSTR pszVisualStylePath, LPCTSTR pszVisualStyleColor, LPCTSTR pszVisualStyleSize)
{
    HRESULT hr = S_OK;

    // Load the skin
    hr = SetSystemVisualStyle(pszVisualStylePath, pszVisualStyleColor, pszVisualStyleSize, 0);
    LogStatus("SetSystemVisualStyle(%ls. %ls, %ls) returned hr=%#08lx.\r\n", pszVisualStylePath, pszVisualStyleColor, pszVisualStyleSize, hr);

    if (SUCCEEDED(hr))
    {
        CComBSTR bstrPath(pszVisualStylePath);

        if (pszVisualStylePath && !bstrPath)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            IWMPSkinMngr * pWMPSkinMngr;

            // Ignore failures until we are guarenteed they are in setup.
            if (SUCCEEDED(CoCreateInstance(CLSID_WMPSkinMngr, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IWMPSkinMngr, &pWMPSkinMngr))))
            {
                pWMPSkinMngr->SetVisualStyle(bstrPath);
                pWMPSkinMngr->Release();
            }
        }
    }

    return hr;
}


HRESULT GetPageByCLSID(IUnknown * punkSite, const GUID * pClsid, IPropertyBag ** ppPropertyBag)
{
    HRESULT hr = E_FAIL;

    *ppPropertyBag = NULL;
    if (punkSite)
    {
        IThemeUIPages * pThemeUI;

        hr = punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUI));
        if (SUCCEEDED(hr))
        {
            IEnumUnknown * pEnumUnknown;

            hr = pThemeUI->GetBasePagesEnum(&pEnumUnknown);
            if (SUCCEEDED(hr))
            {
                IUnknown * punk;

                // This may not exit due to policy
                hr = IEnumUnknown_FindCLSID(pEnumUnknown, *pClsid, &punk);
                if (SUCCEEDED(hr))
                {
                    hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, ppPropertyBag));
                    punk->Release();
                }

                pEnumUnknown->Release();
            }

            pThemeUI->Release();
        }
    }

    return hr;
}


DWORD QueryThemeServicesWrap(void)
{
    DWORD dwResult = QueryThemeServices();

    if (IsTSPerfFlagEnabled(TSPerFlag_NoVisualStyles))
    {
        dwResult = (dwResult & ~QTS_AVAILABLE);     // Remove the QTS_AVAILABLE flag because they are forced of because of TS Perf Flags
        LogStatus("Visual Styles Forced off because of TS Perf Flags\r\n");
    }
    LogStatus("QueryThemeServices() returned %d.  In QueryThemeServicesWrap\r\n", dwResult);

    return dwResult;
}


void PathUnExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize)
{
    TCHAR szTemp[MAX_PATH];

    StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszString);
    if (!PathUnExpandEnvStrings(szTemp, pszString, cchSize))
    {
        StringCchCopy(pszString, cchSize, szTemp);
    }
}



void PathExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize)
{
    TCHAR szTemp[MAX_PATH];

    StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszString);
    if (0 == SHExpandEnvironmentStrings(szTemp, pszString, cchSize))
    {
        StringCchCopy(pszString, cchSize, szTemp);
    }
}


// PERF: This API is INCREADIBLY slow so be very very careful when you use it.
BOOL EnumDisplaySettingsExWrap(LPCTSTR lpszDeviceName, DWORD iModeNum, LPDEVMODE lpDevMode, DWORD dwFlags)
{
    DEBUG_CODE(DebugStartWatch());

    BOOL fReturn = EnumDisplaySettingsEx(lpszDeviceName, iModeNum, lpDevMode, dwFlags);

    DEBUG_CODE(TraceMsg(TF_THEMEUI_PERF, "EnumDisplaySettingsEx() took Time=%lums", DebugStopWatch()));

    return fReturn;
}

void SystemPathAppend(TCHAR *pszPath, TCHAR *pszMore)
{
    if (!GetSystemDirectory(pszPath, MAX_PATH) || !PathAppend(pszPath, pszMore))
    {
        StringCchCopy(pszPath, MAX_PATH, pszMore);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\themeui\util.h ===
/*****************************************************************************\
    FILE: util.h

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

#include "regutil.h"

#define HINST_THISDLL       g_hinst

extern BOOL g_fInSetup;

enum enumTSPerfFlag
{
    TSPerFlag_NoADWallpaper = 0,
    TSPerFlag_NoWallpaper,
    TSPerFlag_NoVisualStyles,
    TSPerFlag_NoWindowDrag,
    TSPerFlag_NoAnimation,
};

// String Helpers
HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
void PathUnExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize);
void PathExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize);

#define SysAllocStringT(pszString)    SysAllocString(pszString)

HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize);
HRESULT HrWritePrivateProfileStringW(LPCWSTR pszAppName, LPCWSTR pszKeyName, LPCWSTR pszString, LPCWSTR pszFileName);

// File System Helpers
HRESULT HrSHFileOpDeleteFile(HWND hwnd, FILEOP_FLAGS dwFlags, LPTSTR pszPath);

// Registry Helpers
HRESULT HrRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
HRESULT HrRegCreateKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, 
       REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
HRESULT HrRegQueryValueEx(HKEY hKey, LPCTSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
HRESULT HrRegSetValueEx(IN HKEY hKey, IN LPCTSTR lpValueName, IN DWORD dwReserved, IN DWORD dwType, IN CONST BYTE *lpData, IN DWORD cbData);
HRESULT HrRegEnumKey(HKEY hKey, DWORD dwIndex, LPTSTR lpName, DWORD cbName);
HRESULT HrRegEnumValue(HKEY hKey, DWORD dwIndex, LPTSTR lpValueName, LPDWORD lpcValueName, LPDWORD lpReserved,
        LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
HRESULT HrRegQueryInfoKey(HKEY hKey, LPTSTR lpClass, LPDWORD lpcClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcMaxSubKeyLen, 
            LPDWORD lpcMaxClassLen, LPDWORD lpcValues, LPDWORD lpcMaxValueNameLen, LPDWORD lpcMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);

HRESULT HrBStrRegQueryValue(IN HKEY hKey, IN LPCTSTR lpValueName, OUT BSTR * pbstr);
HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType, OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData);
HRESULT HrSHSetValue(IN HKEY hkey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwType, OPTIONAL OUT LPVOID pvData, IN DWORD cbData);
DWORD HrRegGetDWORD(HKEY hKey, LPCWSTR szKey, LPCWSTR szValue, DWORD dwDefault);
HRESULT HrRegSetDWORD(HKEY hKey, LPCWSTR szKey, LPCWSTR szValue, DWORD dwData);
HRESULT HrRegDeleteValue(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName);

HRESULT HrRegSetValueString(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszValueName, LPCWSTR pszString);
HRESULT HrRegGetValueString(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszValueName, LPWSTR pszString, DWORD cchSize);
HRESULT HrRegSetPath(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, BOOL fUseExpandSZ, LPCWSTR pszPath);
HRESULT HrRegGetPath(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, IN LPWSTR pszPath, IN DWORD cchSize);


// Palette Helpers
COLORREF GetNearestPaletteColor(HPALETTE hpal, COLORREF rgb);
BOOL IsPaletteColor(HPALETTE hpal, COLORREF rgb);


// Theme Specific Helpers
HRESULT SHGetResourcePath(BOOL fLocaleNode, IN LPWSTR pszPath, IN DWORD cchSize);
HRESULT ExpandResourceDir(IN LPWSTR pszPath, IN DWORD cchSize);
HRESULT GetCurrentUserCustomName(LPWSTR pszDisplayName, DWORD cchSize);
HRESULT InstallVisualStyle(IThemeManager * pThemeManager, LPCTSTR pszVisualStylePath, LPCTSTR pszVisualStyleColor, LPCTSTR pszVisualStyleSize);
HRESULT ApplyVisualStyle(LPCTSTR pszVisualStylePath, LPCTSTR pszVisualStyleColor, LPCTSTR pszVisualStyleSize);


// IProperty Bag Helpers
STDAPI SHPropertyBag_WritePunk(IN IPropertyBag * ppb, IN LPCWSTR pwzPropName, IN IUnknown * punk);
STDAPI SHPropertyBag_ReadByRef(IN IPropertyBag * ppb, IN LPCWSTR pwzPropName, IN void * p, IN SIZE_T cbSize);
STDAPI SHPropertyBag_WriteByRef(IN IPropertyBag * ppb, IN LPCWSTR pwzPropName, IN void * p);
HRESULT GetPageByCLSID(IUnknown * punkSite, const GUID * pClsid, IPropertyBag ** ppPropertyBag);
HRESULT IEnumUnknown_FindCLSID(IN IUnknown * punk, IN CLSID clsid, OUT IUnknown ** ppunkFound);


// UXTheme wrappers
DWORD QueryThemeServicesWrap(void);

// Other Helpers
BOOL _InitComCtl32();
HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd);
COLORREF ConvertColor(LPTSTR pszColor);
BOOL IUnknown_CompareCLSID(IN IUnknown * punk, IN CLSID clsid);
UINT ErrorMessageBox(HWND hwndOwner, LPCTSTR pszTitle, UINT idTemplate, HRESULT hr, LPCTSTR pszParam, UINT dwFlags);
HRESULT DisplayThemeErrorDialog(HWND hwndParent, HRESULT hrError, UINT nTitle, UINT nTemplate);
BOOL EnumDisplaySettingsExWrap(LPCTSTR lpszDeviceName, DWORD iModeNum, LPDEVMODE lpDevMode, DWORD dwFlags);

void LogStatus(LPCSTR pszMessage, ...);
void LogSystemMetrics(LPCSTR pszMessage, SYSTEMMETRICSALL * pSystemMetrics);

void PostMessageBroadAsync(IN UINT Msg, IN WPARAM wParam, IN LPARAM lParam);
void SystemParametersInfoAsync(IN UINT uiAction, IN UINT uiParam, IN void * pvParam, IN DWORD cbSize, IN UINT fWinIni, IN CDimmedWindow* pDimmedWindow);
void DebugStartWatch(void);
DWORD DebugStopWatch(void);
BOOL IsTSPerfFlagEnabled(enumTSPerfFlag eTSFlag);


void SPISetThreadCounter(LONG *pcThreads);
BOOL SPICreateThread(LPTHREAD_START_ROUTINE pfnThreadProc, void *pvData);

typedef struct tagPROGRESSINFO
{
    IProgressDialog * ppd;
    ULARGE_INTEGER uliBytesCompleted;
    ULARGE_INTEGER uliBytesTotal;
} PROGRESSINFO, * LPPROGRESSINFO;


HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb);
void    GetDateString(char * szSentDateString, ULONG stringLen);
void    SystemPathAppend(TCHAR *pszPath, TCHAR *pszMore);


#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxbud\tests.cpp ===
//---------------------------------------------------------------------------
//  tests.cpp - tests for uxbud
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "uxbud.h"
#include "tests.h"
#include "winuserp.h"
#include "wingdip.h"
//---------------------------------------------------------------------------
#define MAX_PRINT_FILE_SIZE 512
//---------------------------------------------------------------------------
int GetStockAvailCount()
{
    //---- slow but better than nothing! ----
    int iCount=0;

    HANDLE *pHandles = new HANDLE[10000];
    if (pHandles)
    {
        //---- create a bunch of stock bitmaps ----
        while (1)
        {
            HBITMAP hBitmap = CreateBitmap(1, 1, 1, 24, NULL);
            if (! hBitmap)
            {
                MessageBox(NULL, L"CreateBitmap() failed", L"bummer, man!", MB_OK);
                break;
            }

            hBitmap = SetBitmapAttributes(hBitmap, SBA_STOCK);
            if (! hBitmap)
            {
                //---- finally used up all avail stock bitmaps ----
                break;
            }

            pHandles[iCount++] = hBitmap;
        }

        //---- free a bunch of stock bitmaps ----
        for (int i=0; i < iCount; i++)
        {
            HBITMAP hBitmap = ClearBitmapAttributes((HBITMAP)pHandles[i], SBA_STOCK);
            if (! hBitmap)
            {
                MessageBox(NULL, L"SetBitmapAttributes() failed to reset stock", L"bummer, man!", MB_OK);
            }
            else
            {
                DeleteObject(hBitmap);
            }
        }
            
        delete [] pHandles;
    }
    else
    {
        MessageBox(NULL, L"cannot allocate 10K handle array", L"bummer, man!", MB_OK);
    }

    return iCount;
}
//---------------------------------------------------------------------------
BOOL ZapDir(LPCWSTR pszDirName)
{
    //---- does this guy exist? ----
    DWORD dwMask = GetFileAttributes(pszDirName);
    BOOL fExists = (dwMask != 0xffffffff);

    if (! fExists)
        return TRUE;        // not an error
    
    //---- delete all files or subdirs within the dir ----
    HANDLE hFile;
    WIN32_FIND_DATA wfd;
    BOOL   bFile = TRUE;
    WCHAR szSearchPattern[MAX_PATH];

    StringCchPrintfW(szSearchPattern, ARRAYSIZE(szSearchPattern), L"%s\\*.*", pszDirName);

    for (hFile=FindFirstFile(szSearchPattern, &wfd); (hFile != INVALID_HANDLE_VALUE) && (bFile);
        bFile=FindNextFile(hFile, &wfd))
    {
        if ((lstrcmp(wfd.cFileName, TEXT("."))==0) || (lstrcmp(wfd.cFileName, TEXT(".."))==0))
            continue;

        WCHAR szFullName[MAX_PATH];
        StringCchPrintfW(szFullName, ARRAYSIZE(szFullName), L"%s\\%s", pszDirName, wfd.cFileName);

        if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (! ZapDir(szFullName))
                return FALSE;
        }
        else
        {
            if (! DeleteFile(szFullName))
                return FALSE;
        }
    }

    FindClose(hFile);

    //---- this requires an empty dir ----
    return RemoveDirectory(pszDirName);
}
//---------------------------------------------------------------------------
BOOL TestFile(LPCWSTR pszFileName)
{
    DWORD dwMask = GetFileAttributes(pszFileName);
    BOOL fExists = (dwMask != 0xffffffff);

    Output("  TestFile(%S)=%s\n", pszFileName, (fExists) ? "true" : "false");

    return fExists;
}
//---------------------------------------------------------------------------
BOOL PrintFileContents(LPCSTR pszTitle, LPCWSTR pszFileName)
{
    HANDLE hFile = NULL;
    DWORD dw;
    CHAR szBuff[MAX_PRINT_FILE_SIZE];
    BOOL fRead = FALSE;

    //---- open files ----
    hFile = CreateFile(pszFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        goto exit;

    ReadFile(hFile, szBuff, MAX_PRINT_FILE_SIZE, &dw, NULL);
    if (! dw)
        goto exit;

    szBuff[dw] = 0;     // null terminate string
    fRead = TRUE;

    Output("  %s: %s\n", pszTitle, szBuff);

exit:
    Output("  PrintFileContents: %S (fRead=%d)\n", pszFileName, fRead);

    CloseHandle(hFile);
    return fRead;
}
//---------------------------------------------------------------------------
BOOL ErrorTester(LPCSTR pszCallTitle, HRESULT hr)
{
    WCHAR szErrBuff[2*MAX_PATH];
    HRESULT hr2;
    BOOL fGotMsg = FALSE;

    if (SUCCEEDED(hr))      
    {
        //---- error - should have FAILED ----
        Output("  Error - %s Succeeded (expected error)\n");
        goto exit;
    }

    hr2 = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr, 0, szErrBuff, ARRAYSIZE(szErrBuff), NULL);
    if (FAILED(hr2))
    {
        StringCchPrintfW(szErrBuff, ARRAYSIZE(szErrBuff), L"Cannot format error=0x%x (FormatError=0x%x)", hr, hr2);
    }

    Output("  %s returned hr=0x%x, error: %S\n", pszCallTitle, hr, szErrBuff);
    fGotMsg = TRUE;
    
exit:
    return fGotMsg;
}
//---------------------------------------------------------------------------
BOOL CompareFiles(LPCWSTR pszName1, LPCWSTR pszName2)
{
    BOOL fSame = FileCompare(pszName1, pszName2);
    
    Output("  Compare(%S, %S) = %s\n", pszName1, pszName2, 
        (fSame) ? "same" : "different");

    return fSame;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
BOOL LoadTest()
{
    Output("LoadTest\n");
    BOOL fPassed = FALSE;
    HRESULT hr = S_OK;

    //---- open and close a theme file a few times; ensure working set doesn't ----
    //---- grow much for this process or for theme service ----

    for (int i=0; i < 6; i++)
    {
        Output("  LoadTest: pass %d\n", i);
  
        //---- load the luna theme ----
        HTHEMEFILE hThemeFile;
    
        //---- use "luna.msstyles" ----
        WCHAR szName[MAX_PATH];
        GetWindowsDirectoryW(szName, MAX_PATH);
        StringCchCatW(szName, ARRAYSIZE(szName), L"\\resources\\themes\\luna\\luna.msstyles");

        //---- load for local (not global) use to avoid stock brush/bitmap issues ----
        HRESULT hr = OpenThemeFile(szName, NULL, NULL, &hThemeFile, FALSE);
        if (FAILED(hr))
            goto exit;

        hr = CloseThemeFile(hThemeFile);
        if (FAILED(hr))
            goto exit;
    }

    fPassed = TRUE;

exit:
    return ReportResults(fPassed, hr, L"LoadTest");
}
//---------------------------------------------------------------------------
BOOL ApplyTest()
{
    BOOL fPassed = FALSE;
    HTHEMEFILE hThemeFile;
    WCHAR szName[MAX_PATH];
    HRESULT hr;

    Output("ApplyTest\n");

    //---- apply "classic", "luna", and "luna" themes a few times ----

    for (int i=0; i < 3; i++)
    {
        Output("  ApplyTest: pass %d\n", i);

        //---- apply "classic" ----
        Output("    Classic\n");

        ApplyTheme(NULL, 0, NULL);
        Sleep(500);

        //---- load LUNA theme ----
        Output("    LUNA\n");
        
        GetWindowsDirectoryW(szName, MAX_PATH);
        StringCchCatW(szName, ARRAYSIZE(szName), L"\\resources\\themes\\luna\\luna.msstyles");

        hr = SetSystemVisualStyle(szName, NULL, NULL, AT_LOAD_SYSMETRICS);

        if (FAILED(hr))
            goto exit;

        Output("  ApplyTest: after applying Luna, StockAvailCount=%d\n", GetStockAvailCount());
    }

    fPassed = TRUE;

exit: 
    return ReportResults(fPassed, hr, L"ApplyTest");
}
//---------------------------------------------------------------------------
BOOL PackTest()
{
    BOOL fPassed = FALSE;
    WCHAR szParams[512];
    WCHAR szWinDir[MAX_PATH];
    HRESULT hr = S_OK;

    Output("PackTest\n");

    //---- unpack luna.msstyles ----
    if (! ZapDir(L"luna"))
        goto exit;

    CreateDirectory(L"luna", NULL);

    GetWindowsDirectory(szWinDir, ARRAYSIZE(szWinDir));
    StringCchPrintfW(szParams, ARRAYSIZE(szParams), L"/a /u %s\\resources\\themes\\luna\\luna.msstyles", szWinDir);

    //---- run unpack in "luna" subdir ----
    SetCurrentDirectory(L"luna");
    BOOL fRunOk = RunCmd(L"packthem", szParams, TRUE, FALSE);
    SetCurrentDirectory(L"..");

    if (! fRunOk)
        goto exit;

    if (! TestFile(L"luna\\themes.ini"))
        goto exit;

    //---- pack it up ----
    if (! RunCmd(L"packthem", L"luna", TRUE, TRUE))
        goto exit;
    
    if (! TestFile(L"luna\\luna.msstyles"))
        goto exit;

    fPassed = TRUE;

exit:
    return ReportResults(fPassed, hr, L"PackTest");
}
//---------------------------------------------------------------------------
BOOL PackErrTest()
{
    BOOL fPassed = FALSE;
    HRESULT hr = S_OK;

    Output("PackErrTest\n");

    //---- run packthem on dir with missing "themes.ini" file ----
    if (! ZapDir(L"TestTheme"))
        goto exit;

    CreateDirectory(L"TestTheme", NULL);

    if (! RunCmd(L"packthem", L"/e TestTheme", TRUE, TRUE))
        goto exit;

    if (! TestFile(L"packthem.err"))
        goto exit;

    if (! PrintFileContents("Packthem Missing File: ", L"packthem.err"))
        goto exit;

    //---- run packthem on dir with bad syntax "themes.ini" file ----
    CopyFile(L".\\TestTheme.ini", L".\\TestTheme\\themes.ini", TRUE);

    if (! RunCmd(L"packthem", L"/e TestTheme", TRUE, TRUE))
        goto exit;

    if (! TestFile(L"packthem.err"))
        goto exit;

    if (! PrintFileContents("Packthem Bad Syntax: ", L"packthem.err"))
        goto exit;

    fPassed = TRUE;
    
exit:
    return ReportResults(fPassed, hr, L"PackErrTest");
}
//---------------------------------------------------------------------------
BOOL ApiErrTest()
{
    Output("ApiErrTest\n");

    BOOL fPassed = FALSE;
    WCHAR szErrBuff[2*MAX_PATH];
    COLORREF crValue;
    HRESULT hr;
    HTHEMEFILE hThemeFile;

    //---- GetThemeColor() with bad HTHEME ----
    hr = GetThemeColor(NULL, 1, 1, TMT_TEXTCOLOR, &crValue);
    ErrorTester("GetThemeColor()", hr);
    
    //---- OpenThemeFile() with corrupt file ----
    hr = OpenThemeFile(L"rcdll.dll", NULL, NULL, &hThemeFile, FALSE);
    ErrorTester("OpenThemeFile()", hr);

    fPassed = TRUE;
    
    return ReportResults(fPassed, hr, L"ApiErrTest");
}
//---------------------------------------------------------------------------
BOOL ImageConTest()
{
    BOOL fPassed = FALSE;
    HRESULT hr = S_OK;

    Output("ImageConTest\n");

    DeleteFile(L"image.bmp");

    if (! RunCmd(L"imagecon", L"image.png image.bmp", TRUE, TRUE))
        goto exit;

    if (! TestFile(L"image.bmp"))
        goto exit;

    fPassed = TRUE;

exit:
    return ReportResults(fPassed, hr, L"ImageConTest");
}
//---------------------------------------------------------------------------
BOOL BinaryTest()
{
    BOOL fPassed = FALSE;
    BOOL fFailed = FALSE;
    Output("BinaryTest\n");

    //---- load the luna theme ----
    HTHEMEFILE hThemeFile;

    //---- use "profesional.msstyles" ----
    WCHAR szName[MAX_PATH];
    GetWindowsDirectoryW(szName, MAX_PATH);
    StringCchCatW(szName, ARRAYSIZE(szName), L"\\resources\\themes\\luna\\luna.msstyles");

    //---- load for local (not global) use to avoid stock brush/bitmap issues ----
    HRESULT hr = OpenThemeFile(szName, NULL, NULL, &hThemeFile, FALSE);
    if (FAILED(hr))
    {
        Output("  OpenThemeFile() failed with hr=0x%x\n", hr);
        goto exit;
    }

    //---- dump out the properties to "PropDump.txt" ----
    hr = DumpLoadedThemeToTextFile(hThemeFile, L"PropDump.txt", FALSE, FALSE);
    if (FAILED(hr))
    {
        Output("  DumpLoadedThemeToTextFile() failed with hr=0x%x\n", hr);
        goto exit;
    }

    //---- compare to known good file ----
    if (! CompareFiles(L"PropDump.ok", L"PropDump.txt"))
        fFailed = TRUE;

    //---- dump out the packed object to "ObjDump.txt" ----
    hr = DumpLoadedThemeToTextFile(hThemeFile, L"ObjDump.txt", TRUE, FALSE);
    if (FAILED(hr))
    {
        Output("  DumpLoadedThemeToTextFile() failed with hr=0x%x\n", hr);
        goto exit;
    }

    //---- compare to known good file ----
    if (! CompareFiles(L"ObjDump.ok", L"ObjDump.txt"))
        fFailed = TRUE;

    if (! fFailed)
        fPassed = TRUE;

exit:
    return ReportResults(fPassed, hr, L"BinaryTest");
}
//---------------------------------------------------------------------------
WCHAR *BitmapNames[] = 
{
    L"BorderFill",
    L"BorderFill-R",
    L"ImageFile",
    L"ImageFile-R",
    L"Glyph",
    L"Glyph-R",
    L"MultiImage",
    L"MultiImage-R",
    L"Text",
    L"Text-R",
    L"Borders",
    L"Borders-R",
    L"SourceSizing",
    L"SourceSizing-R",
};
//---------------------------------------------------------------------------
BOOL DrawingTest()
{
    BOOL fPassed = FALSE;
    BOOL fFailed = FALSE;
    HRESULT hr = S_OK;

    Output("DrawingTest\n");

    //---- run "clipper -c" to produce drawing bitmaps ----
    if (! RunCmd(L"clipper", L"-c", FALSE, TRUE))
        goto exit;

    //---- compare bitmaps to known good files ----
    int iCount = ARRAYSIZE(BitmapNames);
    for (int i=0; i < iCount; i++)
    {
        WCHAR szOkName[MAX_PATH];
        WCHAR szTestName[MAX_PATH];

        StringCchPrintfW(szOkName, ARRAYSIZE(szOkName), L"%s.bok", BitmapNames[i]);
        StringCchPrintfW(szTestName, ARRAYSIZE(szTestName), L"%s.bmp", BitmapNames[i]);

        if (! CompareFiles(szOkName, szTestName))
            fFailed = TRUE;
    }

    if (! fFailed)
        fPassed = TRUE;

exit:
    return ReportResults(fPassed, hr, L"DrawingTest");
}
//---------------------------------------------------------------------------
TESTINFO TestInfo[] =
{
    {DrawingTest,   "drawing",  "test out low level drawing"},
    {PackTest,      "pack",     "test out theme file packing & unpacking"},
    {PackErrTest,   "packerr",  "test out err msgs from theme file packing"},
    {BinaryTest,    "binary",   "dump out text from binary theme data"},
    {LoadTest,      "load",     "test loading and unloading of theme files"},
    {ApplyTest,     "apply",    "test global loading & setting of themes"},
    {ApiErrTest,    "apierr",   "test err msgs from api calls"},
    //{ApiTest,       "api",      "test uxtheme public api"},
    //{PrivateTest,   "private",  "test private api calls"},
    {ImageConTest,  "imagecon", "test out theme file packing & unpacking"},
};    
//---------------------------------------------------------------------------
BOOL GetTestInfo(TESTINFO **ppTestInfo, int *piCount)
{
    *ppTestInfo = TestInfo;
    *piCount = ARRAYSIZE(TestInfo);

    return TRUE;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxbud\tests.h ===
//---------------------------------------------------------------------------
//  tests.h - tests for uxbud
//---------------------------------------------------------------------------
BOOL GetTestInfo(TESTINFO **ppTestInfo, int *piCount);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\appinfo.h ===
//---------------------------------------------------------------------------
//  AppInfo.h - manages app-level theme information (thread safe)
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "ThemeFile.h"
//---------------------------------------------------------------------------
struct THEME_FILE_ENTRY
{
    int iRefCount;
    CUxThemeFile *pThemeFile;
};
//---------------------------------------------------------------------------
class CAppInfo
{
public:
    //---- public methods ----
    CAppInfo();
    ~CAppInfo();

    void ClosePreviewThemeFile();
    BOOL AppIsThemed();
    BOOL CustomAppTheme();
    BOOL WindowHasTheme(HWND hwnd);
    HRESULT OpenWindowThemeFile(HWND hwnd, CUxThemeFile **ppThemeFile);
    HRESULT LoadCustomAppThemeIfFound();
    DWORD GetAppFlags();
    void SetAppFlags(DWORD dwFlags);
    void SetPreviewThemeFile(HANDLE handle, HWND hwnd);
    void ResetAppTheme(int iChangeNum, BOOL fMsgCheck, BOOL *pfChanged, BOOL *pfFirstMsg);
    BOOL IsSystemThemeActive();

    //---- themefile obj list ----
    HRESULT OpenThemeFile(HANDLE handle, CUxThemeFile **ppThemeFile);
    HRESULT BumpRefCount(CUxThemeFile *pThemeFile);
    void CloseThemeFile(CUxThemeFile *pThemeFile);

    //---- foreign window tracking ----
    BOOL GetForeignWindows(HWND **ppHwnds, int *piCount);
    BOOL OnWindowDestroyed(HWND hwnd);
    BOOL HasThemeChanged();

#ifdef DEBUG
void DumpFileHolders();
#endif

protected:
    //---- helper methods ----
    BOOL TrackForeignWindow(HWND hwnd);

    //---- data ----
    BOOL _fCustomAppTheme;
    CUxThemeFile *_pPreviewThemeFile;
    HWND _hwndPreview;

    CUxThemeFile *_pAppThemeFile;
    int _iChangeNum;            // last change number from theme service 
    int _iFirstMsgChangeNum;    // last change number from WM_THEMECHANGED_TRIGGER msg
    BOOL _fCompositing;
    BOOL _fFirstTimeHooksOn;
    BOOL _fNewThemeDiscovered;
    DWORD _dwAppFlags;

    //---- file list ----
    CSimpleArray<THEME_FILE_ENTRY> _ThemeEntries;

    //---- foreign window list ----
    CSimpleArray<HWND> _ForeignWindows;

    CRITICAL_SECTION _csAppInfo;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxbud\uxbud.h ===
//---------------------------------------------------------------------------
//  uxbud.h - automated buddy tests for uxtheme.dll
//---------------------------------------------------------------------------
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
//---------------------------------------------------------------------------
typedef BOOL (*TESTPROC)();
//---------------------------------------------------------------------------
struct TESTINFO
{
    TESTPROC pfnTest;
    CHAR *pszName;
    CHAR *pszDesc;
};
//---------------------------------------------------------------------------
//---- defined by test modules ----

extern BOOL GetTestInfo(TESTINFO **ppTestInfo, int *piCount);
//---------------------------------------------------------------------------
//---- used by test modulels ----

void Output(LPCSTR pszFormat, ...);
BOOL ReportResults(BOOL fPassed, HRESULT hr, LPCWSTR pszTestName);
BOOL FileCompare(LPCWSTR pszName1, LPCWSTR pszName2);
BOOL RunCmd(LPCWSTR pszExeName, LPCWSTR pszParams, BOOL fHide, BOOL fDisplayParams,
    BOOL fWait=TRUE);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\bmpcache.cpp ===
//---------------------------------------------------------------------------
//  BmpCache.cpp - single bitmap/hdc cache object for uxtheme
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "BmpCache.h"
//---------------------------------------------------------------------------
CBitmapCache::CBitmapCache()
{
    _hBitmap = NULL;
    
    _iWidth = 0;
    _iHeight = 0;

    ZeroMemory(&_csBitmapCache, sizeof(_csBitmapCache));
    if( !InitializeCriticalSectionAndSpinCount(&_csBitmapCache, 0) )
    {
        ASSERT(!VALID_CRITICALSECTION(&_csBitmapCache));
    }
}
//---------------------------------------------------------------------------
CBitmapCache::~CBitmapCache()
{
    if (_hBitmap)
    {
        DeleteObject(_hBitmap);
    }

    SAFE_DELETECRITICALSECTION(&_csBitmapCache);
}
//---------------------------------------------------------------------------
HBITMAP CBitmapCache::AcquireBitmap(HDC hdc, int iWidth, int iHeight)
{
    SAFE_ENTERCRITICALSECTION(&_csBitmapCache);

    if ((iWidth > _iWidth) || (iHeight > _iHeight) || (! _hBitmap))
    {
        if (_hBitmap)
        {
            DeleteObject(_hBitmap);

            _hBitmap = NULL;
            _iWidth = 0;
            _iHeight = 0;
        }
        
        //---- create new bitmap & hdc ----
        struct {
            BITMAPINFOHEADER    bmih;
            ULONG               masks[3];
        } bmi;

        bmi.bmih.biSize = sizeof(bmi.bmih);
        bmi.bmih.biWidth = iWidth;
        bmi.bmih.biHeight = iHeight;
        bmi.bmih.biPlanes = 1;
        bmi.bmih.biBitCount = 32;
        bmi.bmih.biCompression = BI_BITFIELDS;
        bmi.bmih.biSizeImage = 0;
        bmi.bmih.biXPelsPerMeter = 0;
        bmi.bmih.biYPelsPerMeter = 0;
        bmi.bmih.biClrUsed = 3;
        bmi.bmih.biClrImportant = 0;
        bmi.masks[0] = 0xff0000;    // red
        bmi.masks[1] = 0x00ff00;    // green
        bmi.masks[2] = 0x0000ff;    // blue

        _hBitmap = CreateDIBitmap(hdc, &bmi.bmih, CBM_CREATEDIB , NULL, (BITMAPINFO*)&bmi.bmih, 
            DIB_RGB_COLORS);

        if (_hBitmap)
        {
            _iWidth = iWidth;
            _iHeight = iHeight;
        }
    }
    
    return _hBitmap;
}
//---------------------------------------------------------------------------
void CBitmapCache::ReturnBitmap()
{
    SAFE_LEAVECRITICALSECTION(&_csBitmapCache);
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxbud\uxbud.cpp ===
//---------------------------------------------------------------------------
//  UxBud.cpp - quick cmdline test for uxtheme.dll
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "uxbud.h"
//---------------------------------------------------------------------------
BOOL fQuiet = FALSE;
HANDLE hFileOutput = NULL;

TESTINFO *pTestInfo;
int iTestCount;
//---------------------------------------------------------------------------
void Output(LPCSTR pszFormat, ...)
{
    //---- writes to both "uxbud.log" and console ----
    va_list args;
    va_start(args, pszFormat);

    //---- format caller's string ----
    CHAR szBigBuff[256];
    StringCchVPrintfA(szBigBuff, ARRAYSIZE(szBigBuff), pszFormat, args);

    if (hFileOutput != INVALID_HANDLE_VALUE)
    {
        //---- expand all LF to CR/LF ----
        CHAR szBuff2[512];
        CHAR *s = szBigBuff;
        CHAR *p = szBuff2;

        while (*s)
        {
            if (*s == '\n')
            {
                *p++ = '\r';
            }

            *p++ = *s++;
        }

        *p = 0;     // zero terminate szBuff2

        //---- write expanded buff to log file ----
        DWORD dw;
        WriteFile(hFileOutput, szBuff2, strlen(szBuff2), &dw, NULL);
    }
    
    if (! fQuiet)
        printf(szBigBuff);

    va_end(args);
}
//-----------------------------------------------------------------
BOOL ReportResults(BOOL fPassed, HRESULT hr, LPCWSTR pszTestName)
{
    Output("%S ", pszTestName);

    if (fPassed)
    {
        Output("PASSED\n\n");
    }
    else
    {
        if (hr == S_OK)
            hr = GetLastError();

        WCHAR szBuff[2*MAX_PATH];

        if (THEME_PARSING_ERROR(hr))
        {
            PARSE_ERROR_INFO Info = {sizeof(Info)};

            HRESULT hr2 = GetThemeParseErrorInfo(&Info);
            if (SUCCEEDED(hr2))
            {
                StringCchCopyW(szBuff, ARRAYSIZE(szBuff), Info.szMsg);
            }
            else
            {
                StringCchPrintfW(szBuff, ARRAYSIZE(szBuff), L"Unknown parsing error");
            }
        }
        else
        {
            // normal win32 error
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr, 0, szBuff, ARRAYSIZE(szBuff), NULL);
        }

        Output("FAILED [%S]\n\n", pszTestName, szBuff);
    }

    return fPassed;
}
//---------------------------------------------------------------------------
BOOL RunCmd(LPCWSTR pszExeName, LPCWSTR pszParams, BOOL fHide, BOOL fDisplayParams,
    BOOL fWait)
{
    HANDLE hInst;
    BOOL fRanOk = FALSE;

    STARTUPINFO si;
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(STARTUPINFO);
    si.dwFlags = STARTF_FORCEOFFFEEDBACK;       // don't mess with our cursor

    if (fHide)
    {
        si.dwFlags |= STARTF_USESHOWWINDOW;         // hide window
        si.wShowWindow = SW_HIDE;
    }

    PROCESS_INFORMATION pi;
    TCHAR szBuff[2*_MAX_PATH];

    if (pszParams)
        StringCchPrintfW(szBuff, ARRAYSIZE(szBuff), _T("%s %s"), pszExeName, pszParams);
    else
    {
        StringCchCopyW(szBuff, ARRAYSIZE(szBuff), pszExeName);
    }

    BOOL bSuccess = CreateProcess(NULL, szBuff, NULL, NULL,
        FALSE, 0, NULL, NULL, &si, &pi);
    if (! bSuccess)
        goto exit;

    hInst = pi.hProcess;
    
    if (! hInst)
        goto exit;

    if (fWait)
    {
        //---- wait for process to terminate ----
        DWORD dwVal;
        dwVal = WaitForSingleObject(hInst, INFINITE);

        if (dwVal != WAIT_OBJECT_0)
            goto exit;

        DWORD dwExitCode;
        if (! GetExitCodeProcess(hInst, &dwExitCode))
            goto exit;

        if (dwExitCode)
            goto exit;
    }

    fRanOk = TRUE;

exit:

    if (fWait)          // being used for the test...
    {
        if (fDisplayParams)
            Output("  RunCmd: %S (ranok=%d)\n", szBuff, fRanOk);
        else
            Output("  RunCmd: %S <params> (ranok=%d)\n", pszExeName, fRanOk);
    }

    CloseHandle(hInst);
    return fRanOk;
}
//---------------------------------------------------------------------------
BOOL TestAll()
{
    DWORD dwStartTicks = GetTickCount();

    for (int i=0; i < iTestCount; i++)
    {
        pTestInfo[i].pfnTest();
    }

    DWORD dwTicks = GetTickCount() - dwStartTicks;

    if (! fQuiet)
        printf("Total test time: %d secs\n", dwTicks/1000);

    return TRUE;
}
//---------------------------------------------------------------------------
void PrintTests()
{
    printf("available tests: \n");

    for (int i=0; i < iTestCount; i++)
    {
        printf("  %s \t(%s)\n", pTestInfo[i].pszName, pTestInfo[i].pszDesc);
    }
    
    printf("\n");
}
//---------------------------------------------------------------------------
void PrintHelp()
{
    printf("\nusage\n");
    printf("  uxbud [ <options> ] \n\n");

    printf("UxBud will run a set of quick tests to verify basic \"uxtheme.dll\"\n");
    printf("functionality.  If no options are specified, one pass over the normal\n");
    printf("set of tests will be run and the \"uxbud.log\" file created will be \n");
    printf("compared against the known good \"uxbud.ok\" log file.  This will result\n");
    printf("in an overall PASS or FAIL msg at the end of the uxbud run.\n\n");

    printf("<options>:\n\n");

    printf("  -r <number>    (to specify a repeat factor)\n");
    printf("  -q             (to run in quiet mode\n");
    printf("  -?             (to print this usage msg\n");
    printf("  <test>         (to run a specific test\n\n");

    PrintTests();
}
//---------------------------------------------------------------------------
BOOL HandleOptions(LPTSTR pszCmdLine, TESTPROC *ppfnTest, int *piRepeat, BOOL *pfQuiet, int *piRetVal)
{
    BOOL fContinue = TRUE;
    USES_CONVERSION;

    *piRetVal = 0;

    if ((! pszCmdLine) || (! *pszCmdLine))  // no options
        return TRUE;

    LPCSTR p = W2A(pszCmdLine);
    
    while ((p) && (*p))
    {
        while (isspace(*p))
            p++;

        //---- process switches ----
        if ((*p == '/') || (*p == '-'))    
        {
            p++;

            if ((*p == 'r') || (*p == 'R'))        // repeat factor
            {   
                p++;
                while (isspace(*p))
                    p++;

                sscanf(p, "%d", piRepeat);

                //---- skip over the scanned number ----
                while (isdigit(*p))
                    p++;
            }
            else if ((*p == 'q') || (*p == 'Q'))    // quiet mode
            {   
                p++;
                *pfQuiet = TRUE;
            }
            else if (*p == '?')        // cmdline help
            {   
                p++;
                PrintHelp();
                fContinue = FALSE;
                break;
            }

        }
        else        // test name specified
        {
            for (int i=0; i < iTestCount; i++)
            {
                if (lstrcmpiA(p, pTestInfo[i].pszName)==0)
                {
                    *ppfnTest = pTestInfo[i].pfnTest;
                    break;
                }
            }

            if (i == iTestCount)        // not found
            {
                printf("\nError - unrecognized test: %s\n\n", p);
                PrintTests();

                *piRetVal = 1;
                fContinue = FALSE;
            }

            break;
        }
    }

    return fContinue;
}
//---------------------------------------------------------------------------
BOOL FileCompare(LPCWSTR pszName1, LPCWSTR pszName2)
{
    BOOL fSame = FALSE;
    HANDLE hFile1 = NULL;
    HANDLE hFile2 = NULL;
    CHAR *pszBuff1 = NULL;
    CHAR *pszBuff2= NULL;
    DWORD dw1, dw2;

    //---- open files ----
    hFile1 = CreateFile(pszName1, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile1 == INVALID_HANDLE_VALUE)
        goto exit;

    hFile2 = CreateFile(pszName2, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile2 == INVALID_HANDLE_VALUE)
        goto exit;

    DWORD dwSize1, dwSize2;
    
    dwSize1 = GetFileSize(hFile1, NULL);
    dwSize2 = GetFileSize(hFile1, NULL);

    if ((! dwSize1) || (dwSize1 != dwSize2))
        goto exit;

    pszBuff1 = new CHAR[dwSize1];
    if (! pszBuff1)
        goto exit;

    pszBuff2 = new CHAR[dwSize1];
    if (! pszBuff2)
        goto exit;

    ReadFile(hFile1, pszBuff1, dwSize1, &dw1, NULL);
    ReadFile(hFile2, pszBuff2, dwSize1, &dw2, NULL);

    if ((dw1 != dwSize1) || (dw2 != dwSize1))
        goto exit;
    
    if (memcmp(pszBuff1, pszBuff2, dwSize1)!=0)
        goto exit;
    
    fSame = TRUE;
    
exit:
    delete [] pszBuff1;
    delete [] pszBuff2;

    CloseHandle(hFile1);
    CloseHandle(hFile2);

    return fSame;
}
//---------------------------------------------------------------------------
extern "C" WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE previnst, 
    LPTSTR pszCmdLine, int nShowCmd)
{
    //---- default run params ----
    int iRepeat = 1;
    int iRetVal = 0;
    TESTPROC pfnTest = TestAll;

    GetTestInfo(&pTestInfo, &iTestCount);

    if (! HandleOptions(pszCmdLine, &pfnTest, &iRepeat, &fQuiet, &iRetVal))
        return iRetVal;

    //---- create the log file ----
    hFileOutput = CreateFile(L"uxbud.log", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
    if (hFileOutput == INVALID_HANDLE_VALUE)
    {
        printf("\nError - could not open uxbud.log output file\n");
        return 1;
    }

	printf("\nUxBud - quick (under 3 mins) test for uxtheme.dll (version 1.0)\n\n");
    
    if (iRepeat > 1)
        Output("REPEAT FACTOR=%d\n\n", iRepeat);

    //---- run the needed test ----
    for (int i=0; i < iRepeat; i++)
    {
        if (iRepeat > 1)
            Output("TEST PASS: %d\n\n", i);

        pfnTest();
    }

    //---- close the log file ----
    if (hFileOutput)
        CloseHandle(hFileOutput);

    if ((iRepeat == 1) && (pfnTest == TestAll))     // standard run
    {
        if (FileCompare(L"uxbud.log", L"uxbud.ok"))
        {
            printf("*** UxBud PASSED ****\n");
        }
        else
        {
            printf("\nFailure detected - running: windiff uxbud.ok uxbud.log...)\n\n");
            printf("*** UxBud FAILED ****\n");

            RunCmd(L"windiff", L"uxbud.ok uxbud.log", TRUE, FALSE, FALSE);
        }
    }

	return 0;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\bmpcache.h ===
//---------------------------------------------------------------------------
//  BmpCache.cpp - single bitmap/hdc cache object for uxtheme
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
class CBitmapCache
{
public:
    //---- public methods ----
    CBitmapCache();
    ~CBitmapCache();

    HBITMAP AcquireBitmap(HDC hdc, int iWidth, int iHeight);
    void ReturnBitmap();

protected:
    //---- data ----
    HBITMAP _hBitmap;
    int _iWidth;
    int _iHeight;

    CRITICAL_SECTION _csBitmapCache;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\appinfo.cpp ===
//---------------------------------------------------------------------------
//  AppInfo.cpp - manages app-level theme information
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "info.h"
#include "AppInfo.h"
#include "sethook.h"
#include "services.h"
#include "themefile.h"
#include "tmreg.h"
#include "renderlist.h"
#include "nctheme.h"
#include "loader.h"
#include "tmutils.h"
//---------------------------------------------------------------------------
//---- values for _pThemeFile, besides valid ptrs ----

//---- if we have no windows open, we cannot track if theme is active ----
#define THEME_UNKNOWN  NULL 

//---- if we are unhooked, we no that no theme file is avail for us ----
#define THEME_NONE     (CUxThemeFile *)(-1)
//---------------------------------------------------------------------------
CAppInfo::CAppInfo()
{
    _fCustomAppTheme    = FALSE;
    _hwndPreview        = NULL;

    _pPreviewThemeFile  = NULL;

    _fFirstTimeHooksOn   = TRUE;
    _fNewThemeDiscovered = FALSE;

    _pAppThemeFile      = THEME_NONE;   // no hooks
    _iChangeNum         = -1;

    _dwAppFlags = (STAP_ALLOW_NONCLIENT | STAP_ALLOW_CONTROLS);

    //---- compositing ON by default ----
    _fCompositing       = TRUE;     
    GetCurrentUserThemeInt(THEMEPROP_COMPOSITING, TRUE, &_fCompositing);

    ZeroMemory(&_csAppInfo, sizeof(_csAppInfo));
    if( !InitializeCriticalSectionAndSpinCount(&_csAppInfo, 0) )
    {
        ASSERT(!VALID_CRITICALSECTION(&_csAppInfo));
    }
}
//---------------------------------------------------------------------------
CAppInfo::~CAppInfo()
{
    ClosePreviewThemeFile();

    //---- ignore iRefCount here - force elements to be deleted ----
    for (int i=0; i < _ThemeEntries.m_nSize; i++)
    {
        _ThemeEntries[i].pThemeFile->ValidateObj();
        delete _ThemeEntries[i].pThemeFile;
    }

    SAFE_DELETECRITICALSECTION(&_csAppInfo);
}
//---------------------------------------------------------------------------
void CAppInfo::ResetAppTheme(int iChangeNum, BOOL fMsgCheck, BOOL *pfChanged, BOOL *pfFirstMsg)
{
    CAutoCS cs(&_csAppInfo);

    if (pfChanged)
        *pfChanged = FALSE;

    //---- NOTE: "_pAppThemeFile" doesn't hold a refcount on the shared memory map file ----

    //---- this is done so that, processes who close all of their windows but continue ----
    //---- to run (like WinLogon), will not hold a refcount on old themes (since ----
    //---- they never receive any more WM_THEMECHANGED msgs until they create ----
    //---- another window.  If we were to remove HOOKS between every theme change, ----
    //---- we could use the OnHooksDisableld code to remove the theme file hold ----
    //---- but design is to let hooks stay ON why we apply and unapply themes. ----

    if ((iChangeNum == -1) || (_iChangeNum != iChangeNum) || (_fNewThemeDiscovered))
    {
        //---- new change number for this process ----
        if (HOOKSACTIVE())
            _pAppThemeFile = THEME_UNKNOWN;
        else
            _pAppThemeFile = THEME_NONE;

        Log(LOG_TMCHANGE, L"ResetAppTheme - CHANGE: iChangeNum=0x%x, _pAppThemeFile=%d", 
            iChangeNum, _pAppThemeFile);
        
        _iChangeNum = iChangeNum;
        _fNewThemeDiscovered = FALSE;

        //---- update caller's info ----
        if (pfChanged)
            *pfChanged = TRUE;
    }

    if (fMsgCheck)      
    {
        *pfFirstMsg = FALSE;

        if ((iChangeNum != -1) && (_iFirstMsgChangeNum != iChangeNum))
        {
            //---- new WM_THEMECHANGED_TRIGGER msg for this process ----
            _iFirstMsgChangeNum = iChangeNum;

            //---- update caller's info ----
            *pfFirstMsg = TRUE;
        }
    }
}
//---------------------------------------------------------------------------
BOOL CAppInfo::HasThemeChanged()
{
    CAutoCS cs(&_csAppInfo);

    BOOL fChanged = _fNewThemeDiscovered;
   _fNewThemeDiscovered = FALSE;

    return fChanged;
}
//---------------------------------------------------------------------------
void CAppInfo::ClosePreviewThemeFile()
{
    CAutoCS cs(&_csAppInfo);

    if (_pPreviewThemeFile)
    {
        CloseThemeFile(_pPreviewThemeFile);
        _pPreviewThemeFile = NULL;
    }

    _hwndPreview = NULL;
}
//---------------------------------------------------------------------------
HRESULT CAppInfo::LoadCustomAppThemeIfFound()
{
    CAutoCS cs(&_csAppInfo);
    CCurrentUser hkeyCurrentUser(KEY_READ);

    RESOURCE HKEY hklm = NULL;
    HTHEMEFILE hThemeFile = NULL;
    HRESULT hr = S_OK;
    int code32;

    if (! _fFirstTimeHooksOn)
        goto exit;

     _fFirstTimeHooksOn = FALSE;

    //---- see if this app has custom theme ----
    WCHAR szCustomKey[2*MAX_PATH];
    StringCchPrintfW(szCustomKey, ARRAYSIZE(szCustomKey), L"%s\\%s\\%s", THEMEMGR_REGKEY, 
        THEMEPROP_CUSTOMAPPS, g_szProcessName);

    //---- open hkcu ----
    code32 = RegOpenKeyEx(hkeyCurrentUser, szCustomKey, 0, KEY_READ, &hklm);
    if (code32 != ERROR_SUCCESS)       
        goto exit;

    //---- read the "DllValue" value ----
    WCHAR szDllName[MAX_PATH];
    hr = RegistryStrRead(hklm, THEMEPROP_DLLNAME, szDllName, ARRAYSIZE(szDllName));
    if (FAILED(hr))
        goto exit;

    //---- read the "color" value ----
    WCHAR szColorName[MAX_PATH];
    hr = RegistryStrRead(hklm, THEMEPROP_COLORNAME, szColorName, ARRAYSIZE(szColorName));
    if (FAILED(hr))
        *szColorName = 0;

    //---- read the "size" value ----
    WCHAR szSizeName[MAX_PATH];
    hr = RegistryStrRead(hklm, THEMEPROP_SIZENAME, szSizeName, ARRAYSIZE(szSizeName));
    if (FAILED(hr))
        *szSizeName = 0;

    Log(LOG_TMCHANGE, L"Custom app theme found: %s, %s, %s", szDllName, szColorName, szSizeName);

    hr = ::OpenThemeFile(szDllName, szColorName, szSizeName, &hThemeFile, FALSE);
    if (FAILED(hr))
        goto exit;

    _fCustomAppTheme = TRUE;

    //---- tell every window in our process that theme has changed ----
    hr = ApplyTheme(hThemeFile, AT_PROCESS, NULL);
    if (FAILED(hr))
        goto exit;

exit:
    if (FAILED(hr))
    {
        if (hThemeFile)
            ::CloseThemeFile(hThemeFile);
    }

    if (hklm)
        RegCloseKey(hklm);
    return hr;
}
//---------------------------------------------------------------------------
BOOL CAppInfo::AppIsThemed()
{
    CAutoCS cs(&_csAppInfo);

    return HOOKSACTIVE();
}
//---------------------------------------------------------------------------
BOOL CAppInfo::CustomAppTheme()
{
    CAutoCS cs(&_csAppInfo);

    return _fCustomAppTheme;
}
//---------------------------------------------------------------------------
BOOL CAppInfo::IsSystemThemeActive()
{
    HANDLE handle;
    BOOL fActive = FALSE;

    HRESULT hr = CThemeServices::GetGlobalTheme(&handle);
    if (SUCCEEDED(hr))
    {
        if (handle)
        {
            fActive = TRUE;
            CloseHandle(handle);
        }
    }

    return fActive;
}
//---------------------------------------------------------------------------
BOOL CAppInfo::WindowHasTheme(HWND hwnd)
{
    //---- keep this logic in sync with "OpenWindowThemeFile()" ----
    CAutoCS cs(&_csAppInfo);

    BOOL fHasTheme = FALSE;

    if (HOOKSACTIVE())
    {
        //---- check for preview window match ----
        if ((ISWINDOW(hwnd)) && (ISWINDOW(_hwndPreview)))
        {
            if ((hwnd == _hwndPreview) || (IsChild(_hwndPreview, hwnd)))
            {
                if (_pPreviewThemeFile)
                    fHasTheme = TRUE;
            }
        }

        //---- if not preview, just use app theme file ----
        if ((! fHasTheme) && (_pAppThemeFile != THEME_NONE))
        {
            fHasTheme = TRUE;
        }
    }

    return fHasTheme;
}
//---------------------------------------------------------------------------
HRESULT CAppInfo::OpenWindowThemeFile(HWND hwnd, CUxThemeFile **ppThemeFile)
{
    //---- keep this logic in sync with "WindowHasTheme()" ----

    HRESULT hr = S_OK;
    CUxThemeFile *pThemeFile = NULL;
    CAutoCS cs(&_csAppInfo);

    if (hwnd)
        TrackForeignWindow(hwnd);

    if (HOOKSACTIVE())
    {
        //---- check for preview window match ----
        if ((ISWINDOW(hwnd)) && (ISWINDOW(_hwndPreview)))
        {
            if ((hwnd == _hwndPreview) || (IsChild(_hwndPreview, hwnd)))
            {
                if (_pPreviewThemeFile)
                {
                    //---- bump ref count ----
                    hr = BumpRefCount(_pPreviewThemeFile);
                    if (FAILED(hr))
                        goto exit;

                    pThemeFile = _pPreviewThemeFile;
                }
            }
        }

        //---- if not preview, just use app theme file ----
        if ((! pThemeFile) && (_pAppThemeFile != THEME_NONE))
        {
            if (_pAppThemeFile == THEME_UNKNOWN || !_pAppThemeFile->IsReady())      
            {
                HANDLE handle = NULL;

                hr = CThemeServices::GetGlobalTheme(&handle);
                if (FAILED(hr))
                    goto exit;

                Log(LOG_TMCHANGE, L"New App Theme handle=0x%x", handle);

                if (handle)
                {
                    //---- get a shared CUxThemeFile object for the handle ----
                    hr = OpenThemeFile(handle, &pThemeFile);
                    if (FAILED(hr))
                    {
                        // Since it's the global theme, no need to clean stock objects
                        CloseHandle(handle);
                        goto exit;
                    }

                    //---- set our app theme file ----
                    _pAppThemeFile = pThemeFile;

                    //---- update our cached change number to match ----
                    _iChangeNum = GetLoadIdFromTheme(_pAppThemeFile);
                    _fNewThemeDiscovered = TRUE;
                }           
            }
            else
            {
                //---- bump ref count ----
                hr = BumpRefCount(_pAppThemeFile);
                if (FAILED(hr))
                    goto exit;

                pThemeFile = _pAppThemeFile;
            }
        }
    }

exit:
    if (pThemeFile)
    {
        *ppThemeFile = pThemeFile;
    }
    else
    {
        hr = MakeError32(ERROR_NOT_FOUND);   
    }

    return hr;
}
//---------------------------------------------------------------------------
DWORD CAppInfo::GetAppFlags()
{
    CAutoCS cs(&_csAppInfo);

    return _dwAppFlags;
}
//---------------------------------------------------------------------------
void CAppInfo::SetAppFlags(DWORD dwFlags)
{
    CAutoCS cs(&_csAppInfo);

    _dwAppFlags = dwFlags;
}
//---------------------------------------------------------------------------
void CAppInfo::SetPreviewThemeFile(HANDLE handle, HWND hwnd)
{
    CAutoCS cs(&_csAppInfo);

    ClosePreviewThemeFile();

    //---- set new file ----
    if (handle)
    {
        HRESULT hr = OpenThemeFile(handle, &_pPreviewThemeFile);
        if (FAILED(hr))
        {
            // We don't own the handle, so no clean up
            Log(LOG_ALWAYS, L"Failed to add theme file to list");
            _pPreviewThemeFile = NULL;
        }
    }

    _hwndPreview = hwnd;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
// If we fail, dont return a theme file and let the caller clean up
//---------------------------------------------------------------------------
HRESULT CAppInfo::OpenThemeFile(HANDLE handle, CUxThemeFile **ppThemeFile)
{
    CAutoCS autoCritSect(&_csAppInfo);
    CUxThemeFile *pFile = NULL;
    HRESULT hr = S_OK;

    BOOL fGotit = FALSE;

    if (! handle)
    {
        hr = MakeError32(ERROR_INVALID_HANDLE);
        goto exit;
    }

    for (int i=0; i < _ThemeEntries.m_nSize; i++)
    {
        THEME_FILE_ENTRY *pEntry = &_ThemeEntries[i];

        pEntry->pThemeFile->ValidateObj();

        if (pEntry->pThemeFile->_hMemoryMap == handle)
        {
            pEntry->iRefCount++;
            fGotit = TRUE;
            *ppThemeFile = pEntry->pThemeFile;
            break;
        }
    }

    if (! fGotit)
    {
        pFile = new CUxThemeFile;
        if (! pFile)
        {
            hr = MakeError32(E_OUTOFMEMORY);
            goto exit;
        }

        hr = pFile->OpenFromHandle(handle);
        if (FAILED(hr))
        {
            goto exit;
        }

        THEME_FILE_ENTRY entry = {1, pFile};

        if (! _ThemeEntries.Add(entry))
        {
            hr = MakeError32(E_OUTOFMEMORY);
            goto exit;
        }

        pFile->ValidateObj();
        *ppThemeFile = pFile;
    }

exit:
    if ((FAILED(hr)) && (pFile))
    {
        delete pFile;
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CAppInfo::BumpRefCount(CUxThemeFile *pThemeFile)
{
    HRESULT hr = S_OK;
    CAutoCS autoCritSect(&_csAppInfo);
 
    pThemeFile->ValidateObj();

    BOOL fGotit = FALSE;

    for (int i=0; i < _ThemeEntries.m_nSize; i++)
    {
        THEME_FILE_ENTRY *pEntry = &_ThemeEntries[i];

        pEntry->pThemeFile->ValidateObj();

        if (pEntry->pThemeFile == pThemeFile)
        {
            pEntry->iRefCount++;
            fGotit = TRUE;
            break;
        }
    }

    if (! fGotit)
        hr = MakeError32(ERROR_NOT_FOUND);

    return hr;
}
//---------------------------------------------------------------------------
void CAppInfo::CloseThemeFile(CUxThemeFile *pThemeFile)
{
    CAutoCS autoCritSect(&_csAppInfo);
 
    BOOL fGotit = FALSE;

    pThemeFile->ValidateObj();

    for (int i=0; i < _ThemeEntries.m_nSize; i++)
    {
        THEME_FILE_ENTRY *pEntry = &_ThemeEntries[i];

        pEntry->pThemeFile->ValidateObj();

        if (pEntry->pThemeFile == pThemeFile)
        {
            pEntry->iRefCount--;
            fGotit = TRUE;

            if (! pEntry->iRefCount)
            {
                //---- clear app themefile? ----
                if (pEntry->pThemeFile == _pAppThemeFile)
                {
                    _pAppThemeFile = THEME_UNKNOWN;
                }
                
                delete pEntry->pThemeFile;
                _ThemeEntries.RemoveAt(i);
            }

            break;
        }
    }

    if (! fGotit)
        Log(LOG_ERROR, L"Could not find ThemeFile in list: 0x%x", pThemeFile);
}
//---------------------------------------------------------------------------
#ifdef DEBUG
void CAppInfo::DumpFileHolders()
{
    CAutoCS autoCritSect(&_csAppInfo);

    if (LogOptionOn(LO_TMHANDLE))
    {
        int iCount = _ThemeEntries.m_nSize;

        if (! iCount)
        {
            Log(LOG_TMHANDLE, L"---- No CUxThemeFile objects ----");
        }
        else
        {
            Log(LOG_TMHANDLE, L"---- Dump of %d CUxThemeFile objects ----", iCount);

            for (int i=0; i < _ThemeEntries.m_nSize; i++)
            {
                THEME_FILE_ENTRY *pEntry = &_ThemeEntries[i];
                pEntry->pThemeFile->ValidateObj();

                if (pEntry->pThemeFile)
                {
                    CUxThemeFile *tf = pEntry->pThemeFile;
                    THEMEHDR *th = (THEMEHDR *)tf->_pbThemeData;

                    Log(LOG_TMHANDLE, L"CUxThemeFile[%d]: refcnt=%d, memfile=%d",
                        i, pEntry->iRefCount, th->iLoadId);
                }
            }
        }
    }
}
#endif
//---------------------------------------------------------------------------
BOOL CAppInfo::TrackForeignWindow(HWND hwnd)
{
    CAutoCS autoCritSect(&_csAppInfo);

    WCHAR szDeskName[MAX_PATH] = {0};
    BOOL fForeign = TRUE;

    //---- get desktop name for window ----
    if (GetWindowDesktopName(hwnd, szDeskName, ARRAYSIZE(szDeskName)))
    {
        if (AsciiStrCmpI(szDeskName, L"default")==0)
        {
            fForeign = FALSE;
        }
    }

    if (fForeign)
    {
        BOOL fNeedToAdd = TRUE;

        //---- see if we already know about this window ----
        for (int i=0; i < _ForeignWindows.m_nSize; i++)
        {
            if (_ForeignWindows[i] == hwnd)
            {
                fNeedToAdd = FALSE;
                break;
            }
        }

        if (fNeedToAdd)
        {
            if (_ForeignWindows.Add(hwnd))
            {
                //Log(LOG_TMHANDLE, L"**** ADDED Foreign Window: hwnd=0x%x, desktop=%s ****", hwnd, szDeskName);
            }
            else
            {
                Log(LOG_TMHANDLE, L"Could not add foreign window=0x%x to tracking list", hwnd);
            }
        }
    }

    return fForeign;
}
//---------------------------------------------------------------------------
BOOL CAppInfo::OnWindowDestroyed(HWND hwnd)
{
    CAutoCS autoCritSect(&_csAppInfo);

    BOOL fFound = FALSE;

    //---- remove from the foreign list, if present ----
    for (int i=0; i < _ForeignWindows.m_nSize; i++)
    {
        if (_ForeignWindows[i] == hwnd)
        {
            _ForeignWindows.RemoveAt(i);

            fFound = TRUE;
            //Log(LOG_TMHANDLE, L"**** REMOVED Foreign Window: hwnd=0x%x", hwnd);
            break;
        }
    }

    //---- see if preview window went away ----
    if ((_hwndPreview) && (hwnd == _hwndPreview))
    {
        ClosePreviewThemeFile();
    }


    return fFound;
}
//---------------------------------------------------------------------------
BOOL CAppInfo::GetForeignWindows(HWND **ppHwnds, int *piCount)
{
    CAutoCS autoCritSect(&_csAppInfo);

    //---- note: we don't see window creates (OpenThemeData) and  ----
    //---- destroys (WM_NCDESTROY) when hooks are off; therefore ----
    //---- this data may be incomplete.  hopefully, vtan or USER ----
    //---- can give us a more reliable way to enumerate windows ----
    //---- on secured desktops ----

    //---- validate windows in list, from last to first ----
    int i = _ForeignWindows.m_nSize;
    while (--i >= 0)
    {
        if (! IsWindow(_ForeignWindows[i]))
        {
            _ForeignWindows.RemoveAt(i);
        }
    }

    BOOL fOk = FALSE;
    int iCount = _ForeignWindows.m_nSize;

    if (iCount)
    {
        //---- allocate memory to hold window list ----
        HWND *pHwnds = new HWND[iCount];
        if (pHwnds)
        {
            //---- copy windows to caller's new list ----
            for (int i=0; i < iCount; i++)
            {
                pHwnds[i] = _ForeignWindows[i];
            }

            *ppHwnds = pHwnds;
            *piCount = iCount;
            fOk = TRUE;
        }
    }

    return fOk;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\borderfill.h ===
//---------------------------------------------------------------------------
//  BorderFill.h - implements the drawing API for bgtype = BorderFill
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "DrawBase.h"
//---------------------------------------------------------------------------
class CRenderObj;       // forward
class CSimpleFile;      // forward
//---------------------------------------------------------------------------
//    Note: draw objects like CBorderFill cannot have virtual methods
//          since they reside in the shared memory map file.
//---------------------------------------------------------------------------
class CBorderFill : public CDrawBase
{
public:
    //---- loader methods ----
    HRESULT PackProperties(CRenderObj *pRender, BOOL fNoDraw, int iPartId, int iStateId);
    
    static BOOL KeyProperty(int iPropId);

    void DumpProperties(CSimpleFile *pFile, BYTE *pbThemeData, BOOL fFullInfo);

    //---- drawing/measuring methods ----
    HRESULT DrawBackground(CRenderObj *pRender, HDC hdcOrig, const RECT *pRect, 
        OPTIONAL const DTBGOPTS *pOptions);

    HRESULT GetBackgroundRegion(CRenderObj *pRender, OPTIONAL HDC hdc, const RECT *pRect, 
        HRGN *pRegion);

    BOOL IsBackgroundPartiallyTransparent();

    HRESULT HitTestBackground(CRenderObj *pRender, OPTIONAL HDC hdc,
        DWORD dwHTFlags, const RECT *pRect, HRGN hrgn, POINT ptTest, OUT WORD *pwHitCode);

    HRESULT GetBackgroundContentRect(CRenderObj *pRender, OPTIONAL HDC hdc, 
        const RECT *pBoundingRect, RECT *pContentRect);

    HRESULT GetBackgroundExtent(CRenderObj *pRender, OPTIONAL HDC hdc, 
        const RECT *pContentRect, RECT *pExtentRect);

    HRESULT GetPartSize(HDC hdc, THEMESIZE eSize, SIZE *psz);

    //---- helper methods ----
    void GetContentMargins(CRenderObj *pRender, OPTIONAL HDC hdc, MARGINS *pMargins);

    HRESULT DrawComplexBackground(CRenderObj *pRender, HDC hdcOrig, 
        const RECT *pRect, BOOL fGettingRegion, BOOL fBorder, BOOL fContent, 
        OPTIONAL const RECT *pClipRect);

public:
    //---- general ----
    BOOL _fNoDraw;              // this is used for bgtype=none

    //---- border ----
    BORDERTYPE _eBorderType;
    COLORREF _crBorder;
    int _iBorderSize;
    int _iRoundCornerWidth;
    int _iRoundCornerHeight;

    //---- fill ----
    FILLTYPE _eFillType;
    COLORREF _crFill;
    int _iDibOffset; 

    //---- margins ----
    MARGINS _ContentMargins;
    
    //---- gradients ----
    int _iGradientPartCount;
    COLORREF _crGradientColors[5];
    int _iGradientRatios[5];

    //---- id ----
    int _iSourcePartId; 
    int _iSourceStateId;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\borderfill.cpp ===
//---------------------------------------------------------------------------
//  BorderFill.cpp - implements the drawing API for bgtype = BorderFill
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"
#include "Utils.h"
#include "gradient.h"
#include "tmutils.h"
#include "rgn.h"
#include "BorderFill.h"
#include "CacheList.h"
#include "gradient.h"
#include "drawhelp.h"
//---------------------------------------------------------------------------
HRESULT CBorderFill::PackProperties(CRenderObj *pRender, BOOL fNoDraw, int iPartId, int iStateId)
{
    memset(this, 0, sizeof(CBorderFill));     // allowed because we have no vtable
    _eBgType = BT_BORDERFILL;

    //---- save off partid, stateid for debugging ----
    _iSourcePartId = iPartId;
    _iSourceStateId = iStateId;

    if (fNoDraw)
    {
        //---- this is used to fake a bgtype=none object ----
        _fNoDraw = TRUE;
    }
    else
    {
        //---- get border type ----
        if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_BORDERTYPE, (int *)&_eBorderType)))
            _eBorderType = BT_RECT;  // TODO: Make Zero the default when no bordertype is specified.

        //---- get border color ----
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_BORDERCOLOR, &_crBorder)))
            _crBorder = RGB(0, 0, 0);

        //---- get border size ----
        if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_BORDERSIZE, &_iBorderSize)))
            _iBorderSize = 1; // TODO: Make Zero the default when no bordersize is specified.

        if (_eBorderType == BT_ROUNDRECT)
        {
            //---- get round rect width ----
            if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_ROUNDCORNERWIDTH, &_iRoundCornerWidth)))
                _iRoundCornerWidth = 80;

            //---- get round rect height ----
            if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_ROUNDCORNERHEIGHT, &_iRoundCornerHeight)))
                _iRoundCornerHeight = 80;
        }

        //---- get fill type ----
        if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_FILLTYPE, (int *)&_eFillType)))
            _eFillType = FT_SOLID;

        if (_eFillType == FT_SOLID)
        {
            //---- get fill color ----
            if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_FILLCOLOR, &_crFill)))
                _crFill = RGB(255, 255, 255);
        }
        else if (_eFillType == FT_TILEIMAGE)
        {
            _iDibOffset = pRender->GetValueIndex(iPartId, iStateId, TMT_DIBDATA);

            if (_iDibOffset == -1)      // not found
                _iDibOffset = 0;
        }
        else            // one of the graident filltypes
        {
            _iGradientPartCount = 0;
            GRADIENTPART gpParts[5];        // max is 5 for now

            for (int i=0; i < ARRAYSIZE(gpParts); i++)
            { 
                COLORREF crPart;
                if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_GRADIENTCOLOR1+i, &crPart)))
                    break;

                int iPartRatio;
                if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_GRADIENTRATIO1+i, &iPartRatio)))
                    iPartRatio = 0;

                _crGradientColors[_iGradientPartCount] = crPart;
                _iGradientRatios[_iGradientPartCount] = iPartRatio;

                _iGradientPartCount++;
            }
        }

        //---- ContentMargins ----
        if (FAILED(pRender->GetMargins(NULL, iPartId, iStateId, TMT_CONTENTMARGINS, NULL, 
            &_ContentMargins)))
        {
            _ContentMargins.cxLeftWidth = _iBorderSize;
            _ContentMargins.cxRightWidth = _iBorderSize;
            _ContentMargins.cyTopHeight = _iBorderSize;
            _ContentMargins.cyBottomHeight = _iBorderSize;
        }
    }

    return S_OK;
}
//---------------------------------------------------------------------------
BOOL CBorderFill::KeyProperty(int iPropId)
{
    BOOL fKey = FALSE;

    switch (iPropId)
    {
        case TMT_BGTYPE:
        case TMT_BORDERSIZE:
        case TMT_ROUNDCORNERWIDTH:
        case TMT_ROUNDCORNERHEIGHT:
        case TMT_GRADIENTRATIO1:
        case TMT_GRADIENTRATIO2:
        case TMT_GRADIENTRATIO3:
        case TMT_GRADIENTRATIO4:
        case TMT_GRADIENTRATIO5:
        //case TMT_IMAGEFILE:       // borrowed from imagefile
        case TMT_CONTENTMARGINS:
        case TMT_BORDERCOLOR:
        case TMT_FILLCOLOR:
        case TMT_GRADIENTCOLOR1:
        case TMT_GRADIENTCOLOR2:
        case TMT_GRADIENTCOLOR3:
        case TMT_GRADIENTCOLOR4:
        case TMT_GRADIENTCOLOR5:
        case TMT_BORDERTYPE:
        case TMT_FILLTYPE:
            fKey = TRUE;
            break;
    }

    return fKey;
}
//---------------------------------------------------------------------------
void CBorderFill::DumpProperties(CSimpleFile *pFile, BYTE *pbThemeData, BOOL fFullInfo)
{
    if (fFullInfo)
        pFile->OutLine(L"Dump of CBorderFill at offset=0x%x", (BYTE *)this - pbThemeData);
    else
        pFile->OutLine(L"Dump of CBorderFill");
    
    pFile->OutLine(L"  _eBgType=%d, _fNoDraw=%d", _eBgType, _fNoDraw);

    pFile->OutLine(L"  _eBorderType=%d, _iBorderSize=%d, _crBorder=0x%08x",
        _eBorderType, _iBorderSize, _crBorder);

    pFile->OutLine(L"  _iRoundCornerWidth=%d, _iRoundCornerHeight=%d",
        _iRoundCornerWidth, _iRoundCornerHeight);

    if (fFullInfo)
    {
        pFile->OutLine(L"  _eFillType=%d, _iDibOffset=%d, _crFill=0x%08x",
            _eFillType, _iDibOffset, _crFill);
    }
    else
    {
        pFile->OutLine(L"  _eFillType=%d, _crFill=0x%08x",
            _eFillType, _crFill);
    }
    
    pFile->OutLine(L"  _ContentMargins=%d, %d, %d, %d", 
        _ContentMargins.cxLeftWidth, _ContentMargins.cxRightWidth,
        _ContentMargins.cyTopHeight, _ContentMargins.cyBottomHeight);

    pFile->OutLine(L"  _iGradientPartCount=%d", _iGradientPartCount);

    for (int i=0; i < _iGradientPartCount; i++)
    {
        pFile->OutLine(L"  _crGradientColors[%d]=0x%08x, _iGradientRatios[%d]=%d",
            i, _iGradientRatios[i], i, _iGradientRatios[i]);
    }
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::DrawComplexBackground(CRenderObj *pRender, HDC hdcOrig, 
    const RECT *pRect, BOOL fGettingRegion, BOOL fBorder, BOOL fContent, 
        OPTIONAL const RECT *pClipRect)
{
    CSaveClipRegion scrOrig;
    HRESULT hr = S_OK;

    bool fGradient = false;
    int iWidth;
    int iHeight;

    //---- pen & brush should proceed hdc so auto-delete happens in correct order ----
    CAutoGDI<HPEN> hPen;
    CAutoGDI<HBRUSH> hBrush;
    CAutoDC hdc(hdcOrig);

    CMemoryDC memoryDC;

    //---- draw border first (along with simple fills) ----
    BOOL fHavePath = FALSE;

    int width = WIDTH(*pRect);
    int height = HEIGHT(*pRect);

    if (pClipRect)      // use GDI clipping for complex cases
    {
        //---- get previous clipping region (for restoring at end) ----
        hr = scrOrig.Save(hdc);
        if (FAILED(hr))
            goto exit;

        //---- add "pClipRect" to the GDI clipping region ----
        int iRetVal = IntersectClipRect(hdc, pClipRect->left, pClipRect->top,
            pClipRect->right, pClipRect->bottom);
        if (iRetVal == ERROR)
        {
            hr = MakeErrorLast();
            goto exit;
        }
    }

    if ((fBorder) && (_iBorderSize))
    {
        hPen = CreatePen(PS_SOLID | PS_INSIDEFRAME, _iBorderSize, _crBorder);
        if (! hPen)
        {
            hr = MakeErrorLast();
            goto exit;
        }
    }


    if (fContent)
    {
        if (_eFillType == FT_SOLID)
        {
            hBrush = CreateSolidBrush(_crFill);
            if (! hBrush)
            {
                hr = MakeErrorLast();
                goto exit;
            }
        }
        else if (_eFillType == FT_TILEIMAGE)
        {
            ASSERT(FALSE); // this fill type not supported
        }
        else
            fGradient = true;
    }

    if (fGettingRegion)
        fGradient = false;

    if (! hBrush)       // no brush wanted
        hBrush = (HBRUSH)GetStockObject(NULL_BRUSH);

    if (! hPen)         // no pen wanted
        hPen = (HPEN)GetStockObject(NULL_PEN);

    hdc.SelectPen(hPen);
    hdc.SelectBrush(hBrush);

    if (_eBorderType == BT_RECT)
    {
        if (_iBorderSize > 0)
        {
            //---- no need to create a path for region in this case ----
            Rectangle(hdc, pRect->left, pRect->top, pRect->right, pRect->bottom);
        }
        else
        {
            FillRect(hdc, pRect, hBrush);
        }
    }
    else if (_eBorderType == BT_ROUNDRECT)
    {
        int iEllipHeight = (_iRoundCornerHeight*height)/100;
        int iEllipWidth = (_iRoundCornerWidth*width)/100;

        RoundRect(hdc, pRect->left, pRect->top, pRect->right, pRect->bottom, 
            iEllipHeight, iEllipWidth);

        if (fGradient)      // create a path of the border
        {
            BeginPath(hdc);
            RoundRect(hdc, pRect->left, pRect->top, pRect->right, pRect->bottom, 
                iEllipHeight, iEllipWidth);
            EndPath(hdc);

            fHavePath = TRUE;
        }
    }
    else        //  if (_eBorderType == BT_ELLIPSE)
    {
        Ellipse(hdc, pRect->left, pRect->top, pRect->right, pRect->bottom);

        if (fGradient)      // create a path of the border
        {
            BeginPath(hdc);
            Ellipse(hdc, pRect->left, pRect->top, pRect->right, pRect->bottom);
            EndPath(hdc);

            fHavePath = TRUE;
        }
    }

    if (! fGradient)       // we're done
        goto exit;

    //---- draw gradient fill within the border drawn above ----

    //---- shrink rect to subtract border ----
    RECT rect;
    SetRect(&rect, pRect->left, pRect->top, pRect->right, pRect->bottom);

    rect.left += _iBorderSize;
    rect.top += _iBorderSize;

    rect.right -= _iBorderSize;
    rect.bottom -= _iBorderSize;

    iWidth = WIDTH(rect);
    iHeight = HEIGHT(rect);

    hr = memoryDC.OpenDC(hdc, iWidth, iHeight);
    if (FAILED(hr))
        goto exit;

    //---- paint our bounding rect into dcBitmap with our gradient ----
    RECT rect2;
    SetRect(&rect2, 0, 0, iWidth, iHeight);

    GRADIENTPART gpParts[5];        // max is 5 for now

    //---- get gradient colors & ratios ----
    for (int i=0; i < _iGradientPartCount; i++)
    { 
        COLORREF crPart = _crGradientColors[i];

        gpParts[i].Color.bRed = RED(crPart);
        gpParts[i].Color.bGreen = GREEN(crPart);
        gpParts[i].Color.bBlue = BLUE(crPart);
        gpParts[i].Color.bAlpha = 255;

        gpParts[i].Ratio = (BYTE)_iGradientRatios[i];
    };

    if (_eFillType == FT_RADIALGRADIENT)
    {
        PaintGradientRadialRect(memoryDC, rect2, _iGradientPartCount, gpParts);
    }
    else if (_eFillType == FT_VERTGRADIENT)
    {
        PaintVertGradient(memoryDC, rect2, _iGradientPartCount, gpParts);
    }
    else            //  if (_eFillType == FT_HORZGRADIENT)
    {
        PaintHorzGradient(memoryDC, rect2, _iGradientPartCount, gpParts);
    }


    if (fHavePath)
    {
        CSaveClipRegion scrCurrent;
        hr = scrCurrent.Save(hdc);       // save current clip region
        if (FAILED(hr))
            goto exit;

        //---- select our shape as the clipping region in normal hdc ----
        SelectClipPath(hdc, RGN_AND);
        
        //---- blt our gradient into the shape-clipped rect into the normal hdc ----
        BitBlt(hdc, rect.left, rect.top, iWidth, iHeight, memoryDC, 0, 0, SRCCOPY);

        scrCurrent.Restore(hdc);     // restore current clip region
    }
    else
    {
        //---- blt our gradient into the shape-clipped rect into the normal hdc ----
        BitBlt(hdc, rect.left, rect.top, iWidth, iHeight, memoryDC, 0, 0, SRCCOPY);
    }

exit:
    scrOrig.Restore(hdc);        // restore clipping region 

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::DrawBackground(CRenderObj *pRender, HDC hdcOrig, 
    const RECT *pRect, OPTIONAL const DTBGOPTS *pOptions)
{
    HRESULT hr = S_OK;

    //---- options ----
    DWORD dwOptionFlags = 0;
    BOOL fBorder = TRUE;
    BOOL fContent = TRUE;
    BOOL fGettingRegion = FALSE;
    const RECT *pClipRect = NULL;

    if (pOptions)
    {
        dwOptionFlags = pOptions->dwFlags;

        if (dwOptionFlags & DTBG_CLIPRECT)
            pClipRect = &pOptions->rcClip;

        if (dwOptionFlags & DTBG_OMITBORDER)
            fBorder = FALSE;

        if (dwOptionFlags & DTBG_OMITCONTENT)
            fContent = FALSE;

        if (dwOptionFlags & DTBG_COMPUTINGREGION)
            fGettingRegion = TRUE;
    }

    //---- optimize for perf-sensitive paths thru here ----
    if (_fNoDraw)   
    {
        //---- nothing to do ----
    }
    else if ((_eFillType == FT_SOLID) && (_eBorderType == BT_RECT)) // solid rectangle
    {
        if (! _iBorderSize)         // no border case
        {
            if (fContent)
            {
                //---- clip, if needed ----
                RECT rcContent = *pRect;
                if (pClipRect)
                    IntersectRect(&rcContent, &rcContent, pClipRect);

                //---- fastest solid rect ----
                COLORREF crOld = SetBkColor(hdcOrig, _crFill);
                ExtTextOut(hdcOrig, 0, 0, ETO_OPAQUE, &rcContent, NULL, 0, NULL);
        
                //---- restore old color ----
                SetBkColor(hdcOrig, crOld);
            }
        }
        else                    // border case
        {
            COLORREF crOld = GetBkColor(hdcOrig);   

            //---- draw clipped borders ----
            if (fBorder)
            {
                RECT rcLine;

                SetBkColor(hdcOrig, _crBorder);

                //---- draw LEFT line ----
                SetRect(&rcLine, pRect->left, pRect->top, pRect->left+_iBorderSize, 
                    pRect->bottom);

                if (pClipRect)
                    IntersectRect(&rcLine, &rcLine, pClipRect);

                ExtTextOut(hdcOrig, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

                //---- draw RIGHT line ----
                SetRect(&rcLine, pRect->right-_iBorderSize, pRect->top, pRect->right, 
                    pRect->bottom);

                if (pClipRect)
                    IntersectRect(&rcLine, &rcLine, pClipRect);

                ExtTextOut(hdcOrig, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

                //---- draw TOP line ----
                SetRect(&rcLine, pRect->left, pRect->top, pRect->right, 
                    pRect->top+_iBorderSize);

                if (pClipRect)
                    IntersectRect(&rcLine, &rcLine, pClipRect);

                ExtTextOut(hdcOrig, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

                //---- draw BOTTOM line ----
                SetRect(&rcLine, pRect->left, pRect->bottom-_iBorderSize, pRect->right, 
                    pRect->bottom);

                if (pClipRect)
                    IntersectRect(&rcLine, &rcLine, pClipRect);

                ExtTextOut(hdcOrig, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);
            }
            
            //---- remove borders from rect to draw content ----
            if (fContent)
            {
                RECT rcContent = *pRect;
                rcContent.left += _iBorderSize;
                rcContent.right -= _iBorderSize;
                rcContent.top += _iBorderSize;
                rcContent.bottom -= _iBorderSize;

                if (pClipRect)
                    IntersectRect(&rcContent, &rcContent, pClipRect);

                //---- fastest solid rect ----
                SetBkColor(hdcOrig, _crFill);
                ExtTextOut(hdcOrig, 0, 0, ETO_OPAQUE, &rcContent, NULL, 0, NULL);
            }

            //---- restore old color ----
            SetBkColor(hdcOrig, crOld);
        }
    }
    else           // all other cases
    {
        hr = DrawComplexBackground(pRender, hdcOrig, pRect, fGettingRegion,
            fBorder, fContent, pClipRect);
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::GetBackgroundRegion(CRenderObj *pRender, OPTIONAL HDC hdc, 
    const RECT *pRect, HRGN *pRegion)
{
    HRESULT hr;

    //---- see if it even has a transparent part ----
    if (! IsBackgroundPartiallyTransparent())
    {
        //---- return the bounding rect as the region ----
        HRGN hrgn = CreateRectRgn(pRect->left, pRect->top,
            pRect->right, pRect->bottom);

        if (! hrgn)
            return MakeErrorLast();

        *pRegion = hrgn;
        return S_OK;
    }

    //---- create a memory dc/bitmap to draw info ----
    CMemoryDC hdcMemory;

    //---- use maximum drawing values as size of DC ----
    hr = hdcMemory.OpenDC(NULL, RECTWIDTH(pRect), RECTHEIGHT(pRect));
    if (FAILED(hr))
        return hr;

    BOOL fOK = BeginPath(hdcMemory);
    if (! fOK)
        return MakeErrorLast();

    DTBGOPTS Opts = {sizeof(Opts), DTBG_COMPUTINGREGION};

    hr = DrawBackground(pRender, hdcMemory, pRect, &Opts);
    if (FAILED(hr))
        return hr;

    fOK = EndPath(hdcMemory);
    if (! fOK)
        return MakeErrorLast();

    HRGN hrgn = PathToRegion(hdcMemory);
    if (! hrgn)
        return MakeErrorLast();

    *pRegion = hrgn;
    return S_OK;
}  
//---------------------------------------------------------------------------
BOOL CBorderFill::IsBackgroundPartiallyTransparent()
{
    return ((_eBorderType != BT_RECT) || _fNoDraw);
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::HitTestBackground(CRenderObj *pRender, OPTIONAL HDC hdc,
    DWORD dwHTFlags, const RECT *pRect, HRGN hrgn, POINT ptTest, OUT WORD *pwHitCode)
{
    MARGINS margins;
    GetContentMargins(pRender, hdc, &margins);
    *pwHitCode = HitTestRect( dwHTFlags, pRect, margins, ptTest );
    return S_OK;
}
//---------------------------------------------------------------------------
void CBorderFill::GetContentMargins(CRenderObj *pRender, OPTIONAL HDC hdc, MARGINS *pMargins)
{
    *pMargins = _ContentMargins;

    //---- adjust for DPI scaling ----
#if 0
    int iDcDpi;

    if (DpiDiff(hdc, &iDcDpi)))
    {
        pMargins->cxLeftWidth = DpiScale(pMargins->cxLeftWidth, iDcDpi);
        pMargins->cxRightWidth = DpiScale(pMargins->cxRightWidth, iDcDpi);
        pMargins->cyTopHeight = DpiScale(pMargins->cyTopHeight, iDcDpi);
        pMargins->cyBottomHeight = DpiScale(pMargins->cyBottomHeight, iDcDpi);
    }
#endif
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::GetBackgroundContentRect(CRenderObj *pRender, OPTIONAL HDC hdc, 
    const RECT *pBoundingRect, RECT *pContentRect)
{
    MARGINS margins;
    GetContentMargins(pRender, hdc, &margins);

    pContentRect->left = pBoundingRect->left + margins.cxLeftWidth;
    pContentRect->top = pBoundingRect->top + margins.cyTopHeight;

    pContentRect->right = pBoundingRect->right - margins.cxRightWidth;
    pContentRect->bottom = pBoundingRect->bottom - margins.cyBottomHeight;

    return S_OK; 
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::GetBackgroundExtent(CRenderObj *pRender, OPTIONAL HDC hdc, 
    const RECT *pContentRect, RECT *pExtentRect)
{
    MARGINS margins;
    GetContentMargins(pRender, hdc, &margins);

    pExtentRect->left = pContentRect->left - margins.cxLeftWidth;
    pExtentRect->top = pContentRect->top-+ margins.cyTopHeight;

    pExtentRect->right = pContentRect->right + margins.cxRightWidth;
    pExtentRect->bottom = pContentRect->bottom + margins.cyBottomHeight;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::GetPartSize(HDC hdc, THEMESIZE eSize, SIZE *psz)
{
    HRESULT hr = S_OK;

    if (eSize == TS_MIN)
    {
        psz->cx = max(1, _iBorderSize*2); 
        psz->cy = max(1, _iBorderSize*2);
    }
    else if (eSize == TS_TRUE)        
    {
        psz->cx = _iBorderSize*2 + 1; 
        psz->cy = _iBorderSize*2 + 1;
    }
    else
    {
        hr = MakeError32(E_INVALIDARG);
    }

    return hr;
} 
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\cache.cpp ===
//---------------------------------------------------------------------------
//  Cache.cpp - implements the CRenderCache object
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Cache.h"
#include "Info.h"
#include "tmutils.h"
//---------------------------------------------------------------------------
CRenderCache::CRenderCache(CRenderObj *pRender, __int64 iUniqueId)
{
    StringCchCopyA(_szHead, ARRAYSIZE(_szHead), "rcache"); 
    StringCchCopyA(_szTail, ARRAYSIZE(_szTail), "end");

    _pRenderObj = pRender;
    _iUniqueId = iUniqueId;

    _hFont = NULL;

    _plfFont = NULL;
}
//---------------------------------------------------------------------------
CRenderCache::~CRenderCache()
{
    //---- delete bitmaps ----
    int cnt = _BitmapCache.GetSize();
    for (int i=0; i < cnt; i++)
    {
        Log(LOG_CACHE, L"DELETE cache bitmap: 0x%x", _BitmapCache[i].hBitmap);
        DeleteObject(_BitmapCache[i].hBitmap);
    }

    //---- delete font ----
    if (_hFont)
        DeleteObject(_hFont);

    StringCchCopyA(_szHead, ARRAYSIZE(_szHead), "deleted"); 
}
//---------------------------------------------------------------------------
HRESULT CRenderCache::GetBitmap(int iDibOffset, OUT HBITMAP *phBitmap)
{
    HRESULT hr = S_OK;
    int cnt = _BitmapCache.GetSize();

    for (int i=0; i < cnt; i++)
    {
        BITMAPENTRY *be = &_BitmapCache[i];

        if (be->iDibOffset == iDibOffset)
        {
            Log(LOG_TM, L"GetBitmap - CACHE HIT: class=%s, diboffset=%d, bitmap=0x%x", 
                SHARECLASS(_pRenderObj), be->iDibOffset, be->hBitmap);

            *phBitmap = be->hBitmap;

            goto exit;
        }
    }

    //---- no match found ----
    hr = MakeError32(ERROR_NOT_FOUND);

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderCache::AddBitmap(int iDibOffset, HBITMAP hBitmap)
{
    HRESULT hr = S_OK;
    BITMAPENTRY entry;

    //---- add new entry for our part/state ----
    entry.iDibOffset = iDibOffset;
    entry.hBitmap = hBitmap;
    //entry.iRefCount = 1;            // new entry

    Log(LOG_CACHE, L"ADD cache bitmap: 0x%x", entry.hBitmap);

    if (! _BitmapCache.Add(entry))
        hr = MakeError32(E_OUTOFMEMORY);

    return hr;
}
//---------------------------------------------------------------------------
void CRenderCache::ReturnBitmap(HBITMAP hBitmap)
{
}
//---------------------------------------------------------------------------
HRESULT CRenderCache::GetScaledFontHandle(HDC hdc, LOGFONT *plfUnscaled, HFONT *phFont)
{
    HRESULT hr = S_OK;

    //---- caches one font only ----
    if ((! _plfFont) || (! FONTCOMPARE(*_plfFont, *plfUnscaled)))
    {
        Log(LOG_TM, L"Font CACHE MISS: %s", plfUnscaled->lfFaceName);

        if (_hFont)
        {
            DeleteObject(_hFont);
            _hFont = NULL;
            _plfFont = NULL;
        }

        LOGFONT lfScaled = *plfUnscaled;
        
        //---- convert to current screen dpi ----
        ScaleFontForHdcDpi(hdc, &lfScaled);

        _hFont = CreateFontIndirect(&lfScaled);
        if (! _hFont)
        {
            hr = MakeError32(E_OUTOFMEMORY);
            goto exit;
        }

        _plfFont = plfUnscaled;
    }
    else
        Log(LOG_TM, L"Font CACHE HIT");

    *phFont = _hFont;

exit:
    return hr;
}
//---------------------------------------------------------------------------
void CRenderCache::ReturnFontHandle(HFONT hFont)
{
}
//---------------------------------------------------------------------------
BOOL CRenderCache::ValidateObj()
{
    BOOL fValid = TRUE;

    //---- check object quickly ----
    if (   (! this)                         
        || (ULONGAT(_szHead) != 'cacr')     // "rcac"
        || (ULONGAT(&_szHead[4]) != 'eh')  // "he" 
        || (ULONGAT(_szTail) != 'dne'))     // "end"
    {
        Log(LOG_ERROR, L"Corrupt CRenderCache object: 0x%08x", this);
        fValid = FALSE;
    }

    return fValid;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\cache.h ===
//---------------------------------------------------------------------------
//  Cache.h - implements the CRenderCache object
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "Render.h"
//---------------------------------------------------------------------------
struct BITMAPENTRY      // for bitmap cache
{
    int iDibOffset;   
    HBITMAP hBitmap;
    //int iRefCount;
};
//---------------------------------------------------------------------------
class CRenderCache
{
public:
	CRenderCache(CRenderObj *pRender, __int64 iUniqueId);
    ~CRenderCache();

public:
    HRESULT GetBitmap(int iDibOffset, OUT HBITMAP *pBitmap);
    HRESULT AddBitmap(int iDibOffset, HBITMAP hBitmap);
    void ReturnBitmap(HBITMAP hBitmap);

    HRESULT GetScaledFontHandle(HDC hdc, LOGFONT *plf, HFONT *phFont);
    void ReturnFontHandle(HFONT hFont);

    BOOL ValidateObj();
    
public:
    //---- data ----
    char _szHead[8];

    CRenderObj *_pRenderObj;
    __int64 _iUniqueId;

protected:
    //---- bitmap cache ----
    CSimpleArray<BITMAPENTRY> _BitmapCache;

    //---- font cache -----
    HFONT _hFont;
    LOGFONT *_plfFont;      // just keep ptr to it in shared memory

    char _szTail[4];
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\drawbase.cpp ===
//---------------------------------------------------------------------------
//    drawbase.cpp - base class for draw objects
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "drawbase.h"
#include "rgn.h"
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\cachelist.h ===
//---------------------------------------------------------------------------
//  CacheList.h - manages list of CRenderCache objects
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "Cache.h"
//---------------------------------------------------------------------------
extern DWORD _tls_CacheListIndex;
//---------------------------------------------------------------------------
class CCacheList
{
    //---- methods ----
public:
    CCacheList();
    ~CCacheList();

    HRESULT GetCacheObject(CRenderObj *pRenderObj, int iSlot, CRenderCache **ppCache);
    HRESULT Resize(int iMaxSlot);

    //---- data ----
protected:
    CSimpleArray<CRenderCache *> _CacheEntries;
};
//---------------------------------------------------------------------------
CCacheList *GetTlsCacheList(BOOL fOkToCreate);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\cachelist.cpp ===
//---------------------------------------------------------------------------
//  CacheList.cpp - manages list of CRenderCache objects
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "CacheList.h"
//---------------------------------------------------------------------------
DWORD _tls_CacheListIndex = 0xffffffff;        // index to tls pObjectPool
//---------------------------------------------------------------------------
CCacheList::CCacheList()
{
    Log(LOG_CACHE, L"CCacheList: CREATED cache list for this thread");
}
//---------------------------------------------------------------------------
CCacheList::~CCacheList()
{
    for (int i=0; i < _CacheEntries.m_nSize; i++)
    {
        if (_CacheEntries[i])
            delete _CacheEntries[i];
    }

    Log(LOG_CACHE, L"~CCacheList: DELETED cache list for this thread");
}
//---------------------------------------------------------------------------
HRESULT CCacheList::GetCacheObject(CRenderObj *pRenderObj, int iSlot, CRenderCache **ppCache)
{
    static int iPassCount = 0;

    HRESULT hr = S_OK;
    CRenderCache *pCache;

    if (iSlot >= _CacheEntries.m_nSize)
    {
        hr = Resize(iSlot);
        if (FAILED(hr))
            goto exit;
    }
    
    pCache = _CacheEntries[iSlot];

    //---- is this an old object (old objects are freed on discovery) ----
    if (pCache)
    {
        BOOL fBad = (pRenderObj->_iUniqueId != pCache->_iUniqueId);
        if (! fBad)
        {
            //---- verify integrity of cache/render design ----
            if (pRenderObj != pCache->_pRenderObj)
            {
                // should never happen
                Log(LOG_ERROR, L"cache object doesn't match CRenderObj");
                fBad = TRUE;
            }
        }

        if (fBad)
        {
            Log(LOG_CACHE, L"GetCacheObject: deleting OLD OBJECT (slot=%d)", iSlot);

            delete pCache;
            pCache = NULL;
            _CacheEntries[iSlot] = NULL;
        }
    }

    //---- create an object on demand ----
    if (! pCache)
    {
        Log(LOG_CACHE, L"GetCacheObject: creating cache obj ON DEMAND (slot=%d)", iSlot);

        pCache = new CRenderCache(pRenderObj, pRenderObj->_iUniqueId);
        if (! pCache)
        {
            hr = MakeError32(E_OUTOFMEMORY);
            goto exit;
        }

        _CacheEntries[iSlot] = pCache;

        ASSERT(pRenderObj == pCache->_pRenderObj);
    }
    else
    {
        Log(LOG_CACHE, L"GetCacheObject: using EXISTING OBJ (slot=%d)", iSlot);
    }

    *ppCache = pCache;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CCacheList::Resize(int iMaxSlotNum)
{
    HRESULT hr = S_OK;

    Log(LOG_CACHE, L"CCacheList::Resize: new MaxSlot=%d", iMaxSlotNum);

    int iOldSize = _CacheEntries.m_nSize;

    if (iMaxSlotNum >= iOldSize)
    {
        typedef CRenderCache *Entry;

        Entry *pNew = (Entry *)realloc(_CacheEntries.m_aT, 
            (iMaxSlotNum+1) * sizeof(Entry));

        if (! pNew)
            hr = MakeError32(E_OUTOFMEMORY);
        else
        {
            _CacheEntries.m_nAllocSize = iMaxSlotNum + 1;
	        _CacheEntries.m_aT = pNew;
		    _CacheEntries.m_nSize = iMaxSlotNum + 1;

            for (int i=iOldSize; i < _CacheEntries.m_nSize; i++)
                _CacheEntries[i] = NULL;
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
CCacheList *GetTlsCacheList(BOOL fOkToCreate)
{
    CCacheList *pList = NULL;

    if (_tls_CacheListIndex != 0xffffffff)     // init-ed in ProcessAttach()
    {
        pList = (CCacheList *)TlsGetValue(_tls_CacheListIndex);
        if ((! pList) && (fOkToCreate))             // not yet initialized
        {
            //---- create a thread-local cache list ----
            pList = new CCacheList();
            TlsSetValue(_tls_CacheListIndex, pList);
        }
    }

    return pList;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\drawbase.h ===
//---------------------------------------------------------------------------
//    drawbase.h - base class for draw objects
//---------------------------------------------------------------------------
#pragma once

//---------------------------------------------------------------------------
class CRenderObj;       // forward
//---------------------------------------------------------------------------
class CDrawBase
{
public:
    //---- data ----
    BGTYPE _eBgType;              // all draw objects must start with this
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\dllmain.cpp ===
//---------------------------------------------------------------------------
//  DllMain.cpp - Dll Entry point for UxTheme DLL
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Utils.h"
#include "sethook.h"
#include "CacheList.h"
#include "RenderList.h"
#include "info.h"
#include "themeldr.h"
//---------------------------------------------------------------------------
BOOL ThreadStartUp()
{
    BOOL fInit = ThemeLibStartUp(TRUE);

    Log(LOG_TMSTARTUP, L"Thread startup");
    return fInit;
}
//---------------------------------------------------------------------------
BOOL ThreadShutDown()
{
    Log(LOG_TMSTARTUP, L"Thread shutdown");

    ThemeLibShutDown(TRUE);

    //---- destroy the thread-local object pool ----
    CCacheList *pList = GetTlsCacheList(FALSE);
    if (pList)
    {
        TlsSetValue(_tls_CacheListIndex, NULL);
        delete pList;
    }

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL ProcessStartUp(HINSTANCE hModule)
{
    //---- don't init twice ----
    if (g_fUxthemeInitialized)
    {
        return TRUE;
    }
    
    g_hInst = hModule;

    _tls_CacheListIndex = TlsAlloc();
    if (_tls_CacheListIndex == (DWORD) -1)
        goto exit;
    
    if (!ThemeLibStartUp(FALSE))
        goto cleanup4;

    if (!GlobalsStartup())
        goto cleanup3;

    if (!ThemeHookStartup())
        goto cleanup2;

    // everything succeeded!
    Log(LOG_TMSTARTUP, L"Finished ProcessStartUp() (succeeded)");
    return TRUE;

cleanup2:
    GlobalsShutdown();
cleanup3:
    ThemeLibShutDown(FALSE);
cleanup4:
    TlsFree(_tls_CacheListIndex);
exit:
    // something failed
    Log(LOG_TMSTARTUP, L"Finished ProcessStartUp() (failure)");
    return FALSE;
}
//---------------------------------------------------------------------------
BOOL ProcessShutDown() 
{
    //---- beware: in case of StartUp failure, all resources may not have been allocated ----

    Log(LOG_TMSTARTUP, L"Starting ProcessShutDown()");

    ThreadShutDown();           // not called by system on last thread

    //---- process shutdown ----
    ThemeLibShutDown(FALSE);

    ThemeHookShutdown();
    GlobalsShutdown();

    TlsFree(_tls_CacheListIndex);
    _tls_CacheListIndex = 0xffffffff;

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
    BOOL fOk = TRUE;

    switch (ul_reason_for_call) 
    {
        case DLL_PROCESS_ATTACH:
            fOk = ProcessStartUp(hModule);
            break;

        case DLL_THREAD_ATTACH:
            fOk = ThreadStartUp();
            break;

        case DLL_THREAD_DETACH:
            fOk = ThreadShutDown();
            break;

        case DLL_PROCESS_DETACH:
            fOk = ProcessShutDown();
            break;
    }

    return fOk;
} 
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\drawhelp.h ===
//---------------------------------------------------------------------------
//  DrawHelp.h - flat drawing helper routines
//---------------------------------------------------------------------------
#pragma once


//---------------------------------------------------------------------------
WORD HitTestRect(DWORD dwHTFlags, LPCRECT prc, const MARGINS& margins, const POINT& pt );
WORD HitTestTemplate(DWORD dwHTFlags, LPCRECT prc, HRGN hrgn, const MARGINS& margins, const POINT& pt );
WORD HitTest9Grid( DWORD dwHTFlags, LPCRECT prc, const MARGINS& margins, const POINT& ptTest );

// UxTheme private version of DrawEdge
HRESULT _DrawEdge(HDC hdc, const RECT *pDestRect, UINT uEdge, UINT uFlags, 
    COLORREF clrLight, COLORREF clrHighlight, COLORREF clrShadow, COLORREF clrDkShadow, COLORREF clrFill,
    OPTIONAL OUT RECT *pContentRect);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\filedump.h ===
//---------------------------------------------------------------------------
//  FileDump.h - Writes the contents of a theme file as formatted
//               text to a text file.  Used for uxbud and other testing so
//               its in both FRE and DEBUG builds.
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
class CUxThemeFile;     // forward
//---------------------------------------------------------------------------
HRESULT DumpThemeFile(LPCWSTR pszFileName, CUxThemeFile *pThemeFile, BOOL fPacked,
    BOOL fFullInfo);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\drawhelp.cpp ===
//---------------------------------------------------------------------------
//  DrawHelp.cpp - flat drawing helper routines
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "DrawHelp.h"
#include "rgn.h"

#define cxRESIZE       (ClassicGetSystemMetrics(SM_CXEDGE)+ClassicGetSystemMetrics( SM_CXSIZEFRAME ))
#define cyRESIZE       (ClassicGetSystemMetrics(SM_CYEDGE)+ClassicGetSystemMetrics( SM_CYSIZEFRAME ))
#define cxRESIZEPAD    ClassicGetSystemMetrics(SM_CXVSCROLL)
#define cyRESIZEPAD    ClassicGetSystemMetrics(SM_CYHSCROLL)

//---------------------------------------------------------------------------
typedef WORD (* HITTESTRECTPROC)(LPCRECT, int, int, const POINT&, WORD);
WORD _HitTestRectCorner( HITTESTRECTPROC, HITTESTRECTPROC, LPCRECT, 
                         int, int, int, int, const POINT&, 
                         WORD, WORD, WORD, WORD );

//---------------------------------------------------------------------------
WORD _HitTestRectLeft( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return ((WORD)((pt.x <= (prc->left + cxMargin)) ? HTLEFT : wMiss));
}
//---------------------------------------------------------------------------
WORD _HitTestRectTop( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return ((WORD)((pt.y <= (prc->top + cyMargin)) ? HTTOP : wMiss));
}
//---------------------------------------------------------------------------
WORD _HitTestRectRight( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return ((WORD)((pt.x >= (prc->right - cxMargin)) ? HTRIGHT : wMiss));
}
//---------------------------------------------------------------------------
WORD _HitTestRectBottom( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return ((WORD)((pt.y >= (prc->bottom - cyMargin)) ? HTBOTTOM : wMiss));
}
//---------------------------------------------------------------------------
WORD _HitTestRectTopLeft( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return _HitTestRectCorner(
        _HitTestRectLeft, _HitTestRectTop, prc, 
        cxMargin, cyMargin, cxRESIZEPAD, cyRESIZEPAD,
        pt, HTTOPLEFT, HTLEFT, HTTOP, wMiss );
}
//---------------------------------------------------------------------------
WORD _HitTestRectTopRight( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return _HitTestRectCorner( 
        _HitTestRectRight, _HitTestRectTop, prc, 
        cxMargin, cyMargin, cxRESIZEPAD, cyRESIZEPAD,
        pt, HTTOPRIGHT, HTRIGHT, HTTOP, wMiss );
}
//---------------------------------------------------------------------------
WORD _HitTestRectBottomLeft( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return _HitTestRectCorner( 
        _HitTestRectLeft, _HitTestRectBottom, prc, 
        cxMargin, cyMargin, cxRESIZEPAD, cyRESIZEPAD,
        pt, HTBOTTOMLEFT, HTLEFT, HTBOTTOM, wMiss );
}
//---------------------------------------------------------------------------
WORD _HitTestRectBottomRight( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return _HitTestRectCorner(
        _HitTestRectRight, _HitTestRectBottom, prc, 
        cxMargin, cyMargin, cxRESIZEPAD, cyRESIZEPAD,
        pt, HTBOTTOMRIGHT, HTRIGHT, HTBOTTOM, wMiss );
}
//---------------------------------------------------------------------------
WORD _HitTestRectCorner(
    HITTESTRECTPROC pfnX, HITTESTRECTPROC pfnY, 
    LPCRECT prc,                        // target rect
    int cxMargin, int cyMargin,         // width, height of resizing borders
    int cxMargin2, int cyMargin2,       // width, height of scrollbars
    const POINT& pt,                    // test point
    WORD wHitC, WORD wHitX, WORD wHitY, // winning hittest codes
    WORD wMiss )                        // losing hittest code
{
    WORD wRetX = pfnX( prc, cxMargin, cyMargin, pt, wMiss );
    WORD wRetY = pfnY( prc, cxMargin, cyMargin, pt, wMiss );

    if( wMiss != wRetX && wMiss != wRetY )
        return wHitC;

    if( wMiss != wRetX )
    {
        wMiss = wHitX;
        if( wMiss != pfnY( prc, cxMargin2, cyMargin2, pt, wMiss ) )
            return wHitC;
    }
    else if( wMiss != wRetY )
    {
        wMiss = wHitY;
        if( wMiss != pfnX( prc, cxMargin2, cyMargin2, pt, wMiss ) )
            return wHitC;
    }

    return wMiss;
}

//---------------------------------------------------------------------------
WORD HitTest9Grid( LPCRECT prc, const MARGINS& margins, const POINT& pt )
{
    ASSERT(PtInRect(prc,pt));

    WORD wHit =  HTCLIENT;

    //  test left side
    if( HTLEFT == _HitTestRectLeft( prc, margins.cxLeftWidth, 0, pt, wHit ) )
    {
        if( HTTOP == _HitTestRectTop( prc, 0, margins.cyTopHeight, pt, wHit ) )
            return HTTOPLEFT;
        if( HTBOTTOM == _HitTestRectBottom( prc, 0, margins.cyBottomHeight, pt, wHit ) )
            return HTBOTTOMLEFT;
        wHit = HTLEFT;
    }
    else //  test right side
    if( HTRIGHT == _HitTestRectRight( prc, margins.cxRightWidth, 0, pt, wHit ) )
    {
        if( HTTOP == _HitTestRectTop( prc, 0, margins.cyTopHeight, pt, wHit ) )
            return HTTOPRIGHT;
        if( HTBOTTOM == _HitTestRectBottom( prc, 0, margins.cyBottomHeight, pt, wHit ) )
            return HTBOTTOMRIGHT;
        wHit = HTRIGHT;
    }
    else //  test top
    if( HTTOP == _HitTestRectTop( prc, 0, margins.cyTopHeight, pt, wHit ) )
    {
        return HTTOP;
    }
    else //  test bottom
    if( HTBOTTOM == _HitTestRectBottom( prc, 0, margins.cyBottomHeight, pt, wHit ) )
    {
        return HTBOTTOM;
    }

    return wHit;
}

//---------------------------------------------------------------------------
WORD _HitTestResizingRect( DWORD dwHTFlags, LPCRECT prc, const POINT& pt, 
                           WORD w9GridHit, WORD wMiss )
{
    WORD wHit = wMiss;
    BOOL fTestLeft    = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_LEFT);
    BOOL fTestTop     = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_TOP);
    BOOL fTestRight   = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_RIGHT);
    BOOL fTestBottom  = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_BOTTOM);
    BOOL fTestCaption = TESTFLAG( dwHTFlags, HTTB_CAPTION );

    switch( w9GridHit )
    {
        case HTLEFT:
            if( fTestLeft )
            {
                //  first test for a hit in the corner resizing areas, respecting caller's option flags.
                if( (fTestTop    && (wHit = _HitTestRectTopLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTLEFT) ||
                    (fTestBottom && (wHit = _HitTestRectBottomLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTLEFT) )
                    break;
                //  failed corners, just test the resizing margin within the specified 9-grid hit seg.
                wHit = _HitTestRectLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            }
            break;
        case HTTOP:
            if( fTestCaption )
                wHit = wMiss = HTCAPTION;
            
            if( fTestTop )
            {
                //  first test for a hit in the corner resizing areas, respecting caller's option flags.
                if( (fTestLeft  && (wHit = _HitTestRectTopLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTTOP) ||
                    (fTestRight && (wHit = _HitTestRectTopRight( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTTOP) )
                    break;
                //  failed corners, just test the resizing margin within the specified 9-grid hit seg.
                wHit = _HitTestRectTop( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            }
            break;
        
        case HTRIGHT:
            if( fTestRight )
            {
                //  first test for a hit in the corner resizing areas, respecting caller's option flags.
                if( (fTestTop && (wHit = _HitTestRectTopRight( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTRIGHT) ||
                    (fTestBottom && (wHit = _HitTestRectBottomRight( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTRIGHT) )
                    break;
                //  failed corners, just test the resizing margin within the specified 9-grid hit seg.
                 wHit = _HitTestRectRight( prc, cxRESIZE, cyRESIZE, pt, wMiss );
                break;
            }
        
        case HTBOTTOM:
            if( fTestBottom )
            {
                //  first test for a hit in the corner resizing areas, respecting caller's option flags.
                if( (fTestLeft  && (wHit = _HitTestRectBottomLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTBOTTOM) ||
                    (fTestRight && (wHit = _HitTestRectBottomRight( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTBOTTOM) )
                    break;
                //  failed corners, just test the resizing margin within the specified 9-grid hit seg.
                wHit = _HitTestRectBottom( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            }
            break;
        
        case HTTOPLEFT:
            if( fTestCaption )
                wHit = wMiss = HTCAPTION;
            //  first test for a resizing hit in the corner, and failing that, test the
            //  resizing margin on either side.
            if( fTestTop && fTestLeft )
                wHit = _HitTestRectTopLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestLeft )
                wHit = _HitTestRectLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss ); 
            else if( fTestTop )
                wHit = _HitTestRectTop( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            break;
        
        case HTTOPRIGHT:
            if( fTestCaption )
                wHit = wMiss = HTCAPTION;
            //  first test for a resizing hit in the corner, and failing that, test the
            //  resizing margin on either side.
            if( fTestTop && fTestRight )
                wHit = _HitTestRectTopRight( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestRight )
                wHit = _HitTestRectRight( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestTop )
                wHit = _HitTestRectTop( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            break;
        
        case HTBOTTOMLEFT:
            //  first test for a resizing hit in the corner, and failing that, test the
            //  resizing margin on either side.
            if( fTestBottom && fTestLeft )
                wHit = _HitTestRectBottomLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestLeft )
                wHit = _HitTestRectLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestBottom )
                wHit = _HitTestRectBottom( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            break;
        
        case HTBOTTOMRIGHT:
            //  first test for a resizing hit in the corner, and failing that, test the
            //  resizing margin on either side.
            if( fTestBottom && fTestRight )
                wHit = _HitTestRectBottomRight( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestRight )
                wHit = _HitTestRectRight( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestBottom )
                wHit = _HitTestRectBottom( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            break;
    }
    return wHit;
}

//---------------------------------------------------------------------------
WORD HitTestRect(DWORD dwHTFlags, LPCRECT prc, const MARGINS& margins, const POINT& pt )
{
    WORD wHit = HTNOWHERE;
    
    if( PtInRect( prc, pt ) )
    {
        wHit = HitTest9Grid( prc, margins, pt );

        if( HTCLIENT != wHit )
        {
            if( TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER) )
            {
                WORD wMiss = HTBORDER;
                wHit = _HitTestResizingRect( dwHTFlags, prc, pt, wHit, wMiss );
            }
            else if( TESTFLAG(dwHTFlags, HTTB_CAPTION|HTTB_FIXEDBORDER) )
            {
                switch( wHit )
                {
                    case HTTOP:
                    case HTTOPLEFT:
                    case HTTOPRIGHT:
                        wHit = (WORD)(TESTFLAG(dwHTFlags, HTTB_CAPTION) ? HTCAPTION : HTBORDER);
                        break;
                    default:
                        wHit = HTBORDER;
                }                
            }

        } // !HTCLIENT
    } // PtInRect

    return wHit;
}

//---------------------------------------------------------------------------
WORD _HitTestResizingTemplate( DWORD dwHTFlags, HRGN hrgn, const POINT& pt,
                               WORD w9GridHit, WORD wMiss )
{
    WORD wHit = wMiss;
    BOOL fTestLeft    = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_LEFT);
    BOOL fTestTop     = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_TOP);
    BOOL fTestRight   = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_RIGHT);
    BOOL fTestBottom  = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_BOTTOM);
    BOOL fTestCaption = TESTFLAG( dwHTFlags, HTTB_CAPTION );
    BOOL fInsideRgn;

    switch( w9GridHit )
    {
        case HTLEFT:
            if( !fTestLeft )
            {
                return wMiss;
            }
            break;
        case HTTOP:
            if( fTestCaption )
                wMiss = HTCAPTION;

            if( !fTestTop )
            {
                return wMiss;
            }
            break;
        case HTRIGHT:
            if( !fTestRight )
            {
                return wMiss;
            }
            break;
        case HTBOTTOM:
            if( !fTestBottom )
            {
                return wMiss;
            }
            break;
        case HTTOPLEFT:
            if( fTestCaption )
                wMiss = HTCAPTION;

            if( !fTestTop || !fTestLeft )
            {
                return wMiss;
            }
            break;

        case HTTOPRIGHT:
            if( fTestCaption )
                wMiss = HTCAPTION;

            if( !fTestTop || !fTestRight )
            {
                return wMiss;
            }
            break;

        case HTBOTTOMLEFT:
            if( !fTestBottom || !fTestLeft )
            {
                return wMiss;
            }
            break;

        case HTBOTTOMRIGHT:
            if( !fTestBottom || !fTestRight )
            {
                return wMiss;
            }
            break;
    }

    fInsideRgn = PtInRegion(hrgn, pt.x, pt.y);

    if( fInsideRgn )
    {
        wHit = w9GridHit;
    }
    return wHit;
}

//---------------------------------------------------------------------------
WORD HitTestTemplate(DWORD dwHTFlags, LPCRECT prc, HRGN hrgn, const MARGINS& margins, const POINT& pt )
{
    WORD wHit = HTNOWHERE;
    
    if( PtInRect( prc, pt ) )
    {
        wHit = HitTest9Grid( prc, margins, pt );

        if( HTCLIENT != wHit )
        {
            if( TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER) )
            {
                WORD wMiss = HTBORDER;
                wHit = _HitTestResizingTemplate( dwHTFlags, hrgn, pt, wHit, wMiss );
            }
            else if( TESTFLAG(dwHTFlags, HTTB_CAPTION|HTTB_FIXEDBORDER) )
            {
                switch( wHit )
                {
                    case HTTOP:
                    case HTTOPLEFT:
                    case HTTOPRIGHT:
                        wHit = (WORD)(TESTFLAG(dwHTFlags, HTTB_CAPTION) ? HTCAPTION : HTBORDER);
                        break;
                    default:
                        wHit = HTBORDER;
                }
            }

        } // !HTCLIENT
    }
    return wHit;
}

//  --------------------------------------------------------------------------
//  FillRectClr
//
//  History:    2000-12-06  lmouton     borrowed from comctl32\v6\cutils.c
//---------------------------------------------------------------------------
void FillRectClr(HDC hdc, LPRECT prc, COLORREF clr)
{
    COLORREF clrSave = SetBkColor(hdc, clr);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL);
    SetBkColor(hdc, clrSave);
}

//---------------------------------------------------------------------------
//  _DrawEdge
//
// Classic values are:
//   clrLight = 192 192 192
//   clrHighlight = 255 255 255
//   clrShadow = 128 128 128
//   clrDkShadow = 0 0 0
//   clrFill = 192 192 192
//
//  History:    2000-12-06  lmouton     borrowed from comctl32\v6\cutils.c, modified colors
//---------------------------------------------------------------------------
HRESULT _DrawEdge(HDC hdc, const RECT *pDestRect, UINT uEdge, UINT uFlags, 
    COLORREF clrLight, COLORREF clrHighlight, COLORREF clrShadow, COLORREF clrDkShadow, COLORREF clrFill,
    OUT RECT *pContentRect)
{
    if (hdc == NULL || pDestRect == NULL)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    RECT     rc, rcD;
    UINT     bdrType;
    COLORREF clrTL = 0;
    COLORREF clrBR = 0;

    // This is were we would adjust for high DPI if the new "BF_DPISCALE" flag is specified in uFlags.
    int      cxBorder = GetSystemMetrics(SM_CXBORDER);
    int      cyBorder = GetSystemMetrics(SM_CYBORDER);
    
    //
    // Enforce monochromicity and flatness
    //    

    // if (oemInfo.BitCount == 1)
    //    uFlags |= BF_MONO;
    if (uFlags & BF_MONO)
        uFlags |= BF_FLAT;    

    CopyRect(&rc, pDestRect);

    //
    // Draw the border segment(s), and calculate the remaining space as we
    // go.
    //
    bdrType = (uEdge & BDR_OUTER);
    if (bdrType)
    {
DrawBorder:
        //
        // Get colors.  Note the symmetry between raised outer, sunken inner and
        // sunken outer, raised inner.
        //

        if (uFlags & BF_FLAT)
        {
            if (uFlags & BF_MONO)
                clrBR = (bdrType & BDR_OUTER) ? clrDkShadow : clrHighlight;
            else
                clrBR = (bdrType & BDR_OUTER) ? clrShadow: clrFill;
            
            clrTL = clrBR;
        }
        else
        {
            // 5 == HILIGHT
            // 4 == LIGHT
            // 3 == FACE
            // 2 == SHADOW
            // 1 == DKSHADOW

            switch (bdrType)
            {
                // +2 above surface
                case BDR_RAISEDOUTER:           // 5 : 4
                    clrTL = ((uFlags & BF_SOFT) ? clrHighlight : clrLight);
                    clrBR = clrDkShadow;     // 1
                    break;

                // +1 above surface
                case BDR_RAISEDINNER:           // 4 : 5
                    clrTL = ((uFlags & BF_SOFT) ? clrLight : clrHighlight);
                    clrBR = clrShadow;       // 2
                    break;

                // -1 below surface
                case BDR_SUNKENOUTER:           // 1 : 2
                    clrTL = ((uFlags & BF_SOFT) ? clrDkShadow : clrShadow);
                    clrBR = clrHighlight;      // 5
                    break;

                // -2 below surface
                case BDR_SUNKENINNER:           // 2 : 1
                    clrTL = ((uFlags & BF_SOFT) ? clrShadow : clrDkShadow);
                    clrBR = clrLight;        // 4
                    break;

                default:
                    hr = E_INVALIDARG;
            }
        }

        if FAILED(hr)
        {
            return hr;
        }

        //
        // Draw the sides of the border.  NOTE THAT THE ALGORITHM FAVORS THE
        // BOTTOM AND RIGHT SIDES, since the light source is assumed to be top
        // left.  If we ever decide to let the user set the light source to a
        // particular corner, then change this algorithm.
        //
            
        // Bottom Right edges
        if (uFlags & (BF_RIGHT | BF_BOTTOM))
        {            
            // Right
            if (uFlags & BF_RIGHT)
            {       
                rc.right -= cxBorder;
                // PatBlt(hdc, rc.right, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rcD.left = rc.right;
                rcD.right = rc.right + cxBorder;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom;

                FillRectClr(hdc, &rcD, clrBR);
            }
            
            // Bottom
            if (uFlags & BF_BOTTOM)
            {
                rc.bottom -= cyBorder;
                // PatBlt(hdc, rc.left, rc.bottom, rc.right - rc.left, g_cyBorder, PATCOPY);
                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.bottom;
                rcD.bottom = rc.bottom + cyBorder;

                FillRectClr(hdc, &rcD, clrBR);
            }
        }
        
        // Top Left edges
        if (uFlags & (BF_TOP | BF_LEFT))
        {
            // Left
            if (uFlags & BF_LEFT)
            {
                // PatBlt(hdc, rc.left, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rc.left += cxBorder;

                rcD.left = rc.left - cxBorder;
                rcD.right = rc.left;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom; 

                FillRectClr(hdc, &rcD, clrTL);
            }
            
            // Top
            if (uFlags & BF_TOP)
            {
                // PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, g_cyBorder, PATCOPY);
                rc.top += cyBorder;

                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.top - cyBorder;
                rcD.bottom = rc.top;

                FillRectClr(hdc, &rcD, clrTL);
            }
        }
        
    }

    bdrType = (uEdge & BDR_INNER);
    if (bdrType)
    {
        //
        // Strip this so the next time through, bdrType will be 0.
        // Otherwise, we'll loop forever.
        //
        uEdge &= ~BDR_INNER;
        goto DrawBorder;
    }

    //
    // Fill the middle & clean up if asked
    //
    if (uFlags & BF_MIDDLE)    
        FillRectClr(hdc, &rc, (uFlags & BF_MONO) ? clrHighlight : clrFill);

    if ((uFlags & BF_ADJUST) && (pContentRect != NULL))
        CopyRect(pContentRect, &rc);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\globals.cpp ===
//---------------------------------------------------------------------------//
//  globals.cpp - variables shared by uxtheme modules
//---------------------------------------------------------------------------//
//  NOTE: global variables in this module are NOT protected by a critical 
//  section are subject to being set by 2 different threads at the same 
//  time.  Therefore, these variables should only be set during uxtheme init.
//---------------------------------------------------------------------------//
#include "stdafx.h"
#include "globals.h"
#include "AppInfo.h"
#include "services.h"
#include "ThemeFile.h"
#include "RenderList.h"
#include "CacheList.h"
#include "bmpcache.h"
//---------------------------------------------------------------------------//
HINSTANCE g_hInst                   = NULL;
WCHAR     g_szProcessName[MAX_PATH] = {0};
DWORD     g_dwProcessId             = 0;
BOOL      g_fUxthemeInitialized     = FALSE;
BOOL      g_fEarlyHookRequest       = FALSE;
HWND      g_hwndFirstHooked         = 0;

THEMEHOOKSTATE    g_eThemeHookState = HS_UNINITIALIZED;
CAppInfo          *g_pAppInfo       = NULL;
CRenderList       *g_pRenderList    = NULL;

CBitmapCache *g_pBitmapCacheScaled        = NULL;
CBitmapCache *g_pBitmapCacheUnscaled        = NULL;

#ifdef LAME_BUTTON
void InitLameText();
#else
#define InitLameText()
#endif

//---------------------------------------------------------------------------
BOOL GlobalsStartup()
{
    BOOL fInit = FALSE;

    Log(LOG_TMSTARTUP, L"GlobalsStartup");
    
    g_dwProcessId = GetCurrentProcessId();

    //---- create global objects ----
    CThemeServices::StaticInitialize();

    g_pRenderList = new CRenderList();
    if (! g_pRenderList)
        goto exit;

    g_pAppInfo = new CAppInfo();
    if (! g_pAppInfo)
        goto exit;

    WCHAR szPath[MAX_PATH];
    if (! GetModuleFileNameW( NULL, szPath, ARRAYSIZE(szPath) ))
        goto exit;

    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szExt[_MAX_EXT];
    _wsplitpath(szPath, szDrive, szDir, g_szProcessName, szExt);

    g_pBitmapCacheScaled = new CBitmapCache();
    if (! g_pBitmapCacheScaled)
        goto exit;

    g_pBitmapCacheUnscaled = new CBitmapCache();
    if (! g_pBitmapCacheUnscaled)
        goto exit;

    InitLameText();

    if (g_fEarlyHookRequest)
    {
        //---- May want to PostMessage() a request to theme ldr ----
        //---- to trigger our hooks & send us WM_THEMECHANGED msg ---
        //---- if it looks like some apps need this.  For now, ----
        //---- let's see if just relying on queued us msgs to do work ----
        //---- is sufficient. ----
    }
    
    g_fUxthemeInitialized = TRUE;
    fInit = TRUE;

exit:
    return fInit;
}
//---------------------------------------------------------------------------//
BOOL GlobalsShutdown()
{
    Log(LOG_TMSTARTUP, L"GlobalsShutDown");

    SAFE_DELETE(g_pBitmapCacheScaled);
    SAFE_DELETE(g_pBitmapCacheUnscaled);
    SAFE_DELETE(g_pAppInfo);
    SAFE_DELETE(g_pRenderList);
    CThemeServices::StaticTerminate();

    g_fUxthemeInitialized = FALSE;

    return TRUE;
}

//---------------------------------------------------------------------------//
HRESULT BumpThemeFileRefCount(CUxThemeFile *pThemeFile)
{
    HRESULT hr;

    if (g_pAppInfo)
        hr = g_pAppInfo->BumpRefCount(pThemeFile); 
    else
        hr = MakeError32(E_FAIL);

    return hr;
}
//---------------------------------------------------------------------------//
void CloseThemeFile(CUxThemeFile *pThemeFile)
{
    if (g_pAppInfo)
        g_pAppInfo->CloseThemeFile(pThemeFile);
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\globals.h ===
//---------------------------------------------------------------------------//
//  globals.h - variables shared by uxtheme modules
//---------------------------------------------------------------------------//
#pragma once
//---------------------------------------------------------------------------
class CThemeServices;       // forward
class CAppInfo;             // forward
class CRenderList;          // forward
class CUxThemeFile;         // forward
class CBitmapCache;         // forward
//---------------------------------------------------------------------------
#define PROPFLAGS_RESET_TRANSPARENT   (1 << 0)   // hwnd needs WS_EX_TRANSPARENT reset
#define PROPFLAGS_RESET_COMPOSITED    (1 << 1)   // hwnd needs WS_EX_COMPOSITED reset
//---------------------------------------------------------------------------
#define WM_THEMECHANGED_TRIGGER     WM_UAHINIT   // reuse this msgnum with WPARAM != NULL
//---------------------------------------------------------------------------//
extern HINSTANCE g_hInst;
extern WCHAR     g_szProcessName[MAX_PATH];
extern DWORD     g_dwProcessId;
extern BOOL      g_fUxthemeInitialized;
extern BOOL      g_fEarlyHookRequest;
extern HWND      g_hwndFirstHooked;
extern HWND      g_hwndFirstHooked;

extern CBitmapCache *g_pBitmapCacheScaled;
extern CBitmapCache *g_pBitmapCacheUnscaled;
//---------------------------------------------------------------------------
//  theme atoms
enum THEMEATOM
{
    THEMEATOM_Nil = -1,

    THEMEATOM_SUBIDLIST,
    THEMEATOM_SUBAPPNAME,
    THEMEATOM_HTHEME,
    THEMEATOM_PROPFLAGS,
    THEMEATOM_UNUSED__________, /// RECYCLE ME!
    THEMEATOM_SCROLLBAR,
    THEMEATOM_PRINTING,
    THEMEATOM_DLGTEXTURING,
    //  insert new theme atom indices here
    THEMEATOM_NONCLIENT,

    THEMEATOM_Count
};
//  187504:  Since whistler beta1, we use hardcoded atom values to avoid our atoms being
//           destroyed as a user logs off.
#define HARDATOM_BASE   0xA910 // arbitrary, but less than 0xC000 (real atom base).
#define HARDATOM_HIGH   0xA94F // range of 64 atoms
inline ATOM GetThemeAtom( THEMEATOM ta )    
{
    ASSERT(ta > THEMEATOM_Nil && ta < THEMEATOM_Count);
    ATOM atom = (ATOM)(HARDATOM_BASE + ta);
    ASSERT(atom <= HARDATOM_HIGH);
    return atom;
}

//---------------------------------------------------------------------------
enum THEMEHOOKSTATE
{
    HS_INITIALIZED,
    HS_UNHOOKING,
    HS_UNINITIALIZED,
};

extern  THEMEHOOKSTATE  g_eThemeHookState;
#define HOOKSACTIVE()   (HS_INITIALIZED == g_eThemeHookState)
#define UNHOOKING()     (HS_UNHOOKING   == g_eThemeHookState)

//---------------------------------------------------------------------------
extern CAppInfo          *g_pAppInfo;
extern CRenderList       *g_pRenderList;
//---------------------------------------------------------------------------
BOOL GlobalsStartup();
BOOL GlobalsShutdown();

HRESULT BumpThemeFileRefCount(CUxThemeFile *pThemeFile);
void    CloseThemeFile(CUxThemeFile *pThemeFile);
//---------------------------------------------------------------------------

#define PRINTING_ASKING                 1       
#define PRINTING_WINDOWDIDNOTHANDLE     2

//---------------------------------------------------------------------------
#define _WindowHasTheme(hwnd) (g_pAppInfo->WindowHasTheme(hwnd))
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\filedump.cpp ===
//---------------------------------------------------------------------------
//  FileDump.cpp - Writes the contents of a theme file as formatted
//               text to a text file.  Used for uxbud and other testing so
//               its in both FRE and DEBUG builds.
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Loader.h"
#include "Loader.h"
#include "borderfill.h"
#include "imagefile.h"
#include "textdraw.h"
#include "tmutils.h"
//---------------------------------------------------------------------------
int DumpType(CSimpleFile *pFile, CUxThemeFile *pThemeFile, MIXEDPTRS &u, 
    BOOL fPacked, BOOL fFullInfo)
{
    BOOL fPropDump = (! fPacked);
    UNPACKED_ENTRYHDR hdr;

    FillAndSkipHdr(u, &hdr);
    BYTE *origPd = u.pb;

    int i;

    if (fPropDump)
    {
        if (hdr.ePrimVal == TMT_DIBDATA && !fFullInfo)
        {
            pFile->OutLine(L"    type=%d, primType=%d", hdr.usTypeNum, hdr.ePrimVal);
        } 
        else
        {
            pFile->OutLine(L"    type=%d, primType=%d, len=%d", 
                hdr.usTypeNum, hdr.ePrimVal, hdr.dwDataLen);
        }
    }

    switch (hdr.ePrimVal)
    {
        case TMT_JUMPTOPARENT:
            if (fPropDump)
            {
                if (fFullInfo)
                    pFile->OutLine(L"      JumpToParent: index=%d", *u.pi);
                else
                    pFile->OutLine(L"      JumpToParent");
            }
            break;

        case TMT_PARTJUMPTABLE:
            return hdr.ePrimVal;         // let caller process data for this

        case TMT_STATEJUMPTABLE:
            return hdr.ePrimVal;         // let caller process data for this

        case TMT_STRING:
            if (fPropDump)
                pFile->OutLine(L"      String: %s", u.pc);
            break;

        case TMT_INT:
            if (fPropDump)
                pFile->OutLine(L"      Int: %d", *u.pi);
            break;

        case TMT_BOOL:
            if (fPropDump)
                pFile->OutLine(L"      Bool: %d", *u.pb);
            break;

        case TMT_COLOR:
            if (fPropDump)
            {
                int color;
                color = *u.pi;
                pFile->OutLine(L"      Color: %d, %d, %d", color & 0xff, (color >> 8) & 0xff, 
                    (color >> 16) & 0xff);
            }
            break;

        case TMT_MARGINS:
            if (fPropDump)
            {
                int vals[4];
                for (i=0; i < 4; i++)
                    vals[i] = *u.pi++;

                pFile->OutLine(L"      Margins: lw=%d, rw=%d, th=%d, bh=%d", vals[0], 
                    vals[1], vals[2], vals[3]);
            }
            break;

        case TMT_FILENAME:
            if (fPropDump)
                pFile->OutLine(L"      Filename: %s", u.pw);
            break;

        case TMT_SIZE:
            if (fPropDump)
                pFile->OutLine(L"      Size: %d", *u.pi);
            break;

        case TMT_POSITION:
            if (fPropDump)
            {
                int val1, val2;
                val1 = *u.pi++;
                val2 = *u.pi++;

                pFile->OutLine(L"      Position: x=%d, y=%d", val1, val2);
            }
            break;

        case TMT_RECT:
            if (fPropDump)
            {
                int vals[4];

                for (i=0; i < 4; i++)
                    vals[i] = *u.pi++;

                pFile->OutLine(L"      Rect: left=%d, top=%d, width=%d, height=%d", vals[0], 
                    vals[1], vals[2], vals[3]);
            }
            break;

        case TMT_FONT:
            if (fPropDump)
            {
                LOGFONT *plf;
                plf = (LOGFONT *)u.pb;

                //---- dump resolution-independent font points ----
                int iFontPoints = FontPointSize(plf->lfHeight);

                pFile->OutLine(L"      Font: name=%s, size=%d points", plf->lfFaceName, iFontPoints);
            }
            break;

        case TMT_THEMEMETRICS:
            if (fPropDump)
            {
                THEMEMETRICS *ptm;
                ptm= (THEMEMETRICS *)u.pb;

                //---- dump theme metrics: fonts ----
                for (i=0; i < TM_FONTCOUNT; i++)
                {
                    //---- dump resolution-independent font points ----
                    int iFontPoints = FontPointSize(ptm->lfFonts[i].lfHeight);

                    pFile->OutLine(L"      TM_Font[%d]: name=%s, size=%d points", 
                        i, ptm->lfFonts[i].lfFaceName, iFontPoints);
                }
                pFile->OutLine(L"      -----------------------------------------");

                //---- dump theme metrics: colors ----
                for (i=0; i < TM_COLORCOUNT; i++)
                {
                    pFile->OutLine(L"      TM_Color[%d]: %d, %d, %d", 
                        i, RED(ptm->crColors[i]), GREEN(ptm->crColors[i]), BLUE(ptm->crColors[i]));
                }
                pFile->OutLine(L"      -----------------------------------------");

                //---- dump theme metrics: sizes ----
                for (i=0; i < TM_SIZECOUNT; i++)
                {
                    pFile->OutLine(L"      TM_Size[%d]: %d",
                        i, ptm->iSizes[i]);
                }
                pFile->OutLine(L"      -----------------------------------------");

                //---- dump theme metrics: bools ----
                for (i=0; i < TM_BOOLCOUNT; i++)
                {
                    pFile->OutLine(L"      TM_Bool[%d]: %d",
                        i, ptm->fBools[i]);
                }
                pFile->OutLine(L"      -----------------------------------------");

                //---- dump theme metrics: strings ----
                for (i=0; i < TM_STRINGCOUNT; i++)
                {
                    WCHAR *psz;
            
                    if (ptm->iStringOffsets[i])
                        psz = (LPWSTR)(pThemeFile->_pbThemeData + ptm->iStringOffsets[i]);
                    else
                        psz = L"";

                    pFile->OutLine(L"      TM_String[%d]: %s", i, psz);
                }
                pFile->OutLine(L"      -----------------------------------------");
            }

            break;

        case TMT_ENUM:
            if (fPropDump)
                pFile->OutLine(L"      Enum: dtype=%d, val=%d", hdr.usTypeNum, *u.pi);
            break;

        case TMT_DIBDATA:
            if (fPropDump)
            {
                TMBITMAPHEADER    *pThemeBitmapHeader;

                pThemeBitmapHeader = reinterpret_cast<TMBITMAPHEADER*>(u.pb);

                if (pThemeBitmapHeader->hBitmap == NULL)
                {
                    BITMAPINFOHEADER *pHdr;

                    pHdr = BITMAPDATA(pThemeBitmapHeader);

                    if (fFullInfo)
                    {
                        pFile->OutLine(L"      DibData: width=%d, height=%d, total size: %d", 
                            pHdr->biWidth, pHdr->biHeight, hdr.dwDataLen); 
                    }
                    else
                    {
                        pFile->OutLine(L"      DibData: width=%d, height=%d",
                            pHdr->biWidth, pHdr->biHeight);
                    }
                } 
                else        // STOCKBITMAPHDR
                {
                    if (fFullInfo)
                    {
                        pFile->OutLine(L"      STOCKBITMAPHDR: dwColorDepth=%d, hBitmap=%8X, total size: %d", 
                            pThemeBitmapHeader->dwColorDepth, 
                            pThemeBitmapHeader->hBitmap, hdr.dwDataLen); 
                    }
                    else
                    {
                        pFile->OutLine(L"      STOCKBITMAPHDR: dwColorDepth=%d", 
                            pThemeBitmapHeader->dwColorDepth);
                    }
                }
            }
            break;

        default:
            if (fPropDump)
                pFile->OutLine(L"      Unexpected ptype=%d", hdr.ePrimVal);
            break;
    }

    u.pb = origPd + hdr.dwDataLen;

    return hdr.ePrimVal;
}
//---------------------------------------------------------------------------
void DumpPackedObjs(CSimpleFile *pFile, CUxThemeFile *pThemeFile, int iOffset, 
    BOOL fPacked, BOOL fFullInfo)
{
    MIXEDPTRS u;
    UNPACKED_ENTRYHDR hdr;

    u.pb = pThemeFile->_pbThemeData + iOffset;

    //---- first come the draw objects ----
    while (1)
    {
        if (*u.ps == TMT_RGNLIST)
        {
            FillAndSkipHdr(u, &hdr);

            int iStateCount = *u.pb;
            
            pFile->OutLine(L"RgnDataList: StateCount=%d", iStateCount);

            pFile->OutLine(L" ");

            u.pb += hdr.dwDataLen;
            continue;
        }

        if (*u.ps != TMT_DRAWOBJ)
            break;

        FillAndSkipHdr(u, &hdr);

        DRAWOBJHDR *ph = (DRAWOBJHDR *)u.pb;
        u.pb += sizeof(DRAWOBJHDR);

        pFile->OutLine(L"DrawObj: part=%d, state=%d", ph->iPartNum, ph->iStateNum);

        BGTYPE eBgType = *(BGTYPE *)u.pb;
        if (eBgType == BT_BORDERFILL)
        {
            CBorderFill *bfobj = (CBorderFill *)u.pb;
            u.pb += sizeof(CBorderFill);

            bfobj->DumpProperties(pFile, pThemeFile->_pbThemeData, fFullInfo);
        }
        else
        {
            CImageFile *ifobj = (CImageFile *)u.pb;
            u.pb += sizeof(CImageFile) + sizeof(DIBINFO)*ifobj->_iMultiImageCount;

            ifobj->DumpProperties(pFile, pThemeFile->_pbThemeData, fFullInfo);
        }

        pFile->OutLine(L" ");
    }

    //---- then come the text objects ----
    while (*u.ps == TMT_TEXTOBJ)        
    {
        u.pb += ENTRYHDR_SIZE;

        DRAWOBJHDR *ph = (DRAWOBJHDR *)u.pb;
        u.pb += sizeof(DRAWOBJHDR);

        pFile->OutLine(L"TextObj: part=%d, state=%d", ph->iPartNum, ph->iStateNum);

        CTextDraw *tdobj = (CTextDraw *)u.pb;
        u.pb += sizeof(CTextDraw);

        tdobj->DumpProperties(pFile, pThemeFile->_pbThemeData, fFullInfo);

        pFile->OutLine(L" ");
    }
}
//---------------------------------------------------------------------------
void DumpSectionData(CSimpleFile *pFile, CUxThemeFile *pThemeFile, int iIndex, 
    BOOL fPacked, BOOL fFullInfo)
{
    MIXEDPTRS u;

    u.pb = pThemeFile->_pbThemeData + iIndex;

    bool atend = false;

    while (! atend)
    {
        int pnum = DumpType(pFile, pThemeFile, u, fPacked, fFullInfo);

        //---- special post-handling ----
        switch (pnum)
        {
            case TMT_PARTJUMPTABLE:
                {
                    int iPackObjsOffset = *u.pi++;
                    if (! fPacked)      // property dump
                    {
                        BYTE cnt = *u.pb++;
                    
                        if (fFullInfo)
                        {
                            pFile->OutLine(L"  PartJumpTable: drawobj offset=%d, cnt=%d", 
                                iPackObjsOffset, cnt);
                        }
                        else
                        {
                            pFile->OutLine(L"  PartJumpTable: drawobj cnt=%d",
                                cnt);
                        }

                        for (int i=0; i < cnt; i++)
                        {
                            int index = *u.pi++;

                            if (fFullInfo)
                                pFile->OutLine(L"  Part[%d]: index=%d", i, index);
                            else
                                pFile->OutLine(L"  Part[%d]", i);

                            if (index > -1)
                                DumpSectionData(pFile, pThemeFile, index, fPacked, fFullInfo);
                        }
                    }
                    else                // packed object dump
                    {
                        DumpPackedObjs(pFile, pThemeFile, iPackObjsOffset, fPacked, fFullInfo);
                    }
                }
                atend = true;
                break;

            case TMT_STATEJUMPTABLE:
                {
                    if (! fPacked)
                    {
                        BYTE cnt = *u.pb++;
                        pFile->OutLine(L"    StateJumpTable: cnt=%d", cnt);
                        for (int i=0; i < cnt; i++)
                        {
                            int index = *u.pi++;

                            if (fFullInfo)
                                pFile->OutLine(L"    State[%d]: index=%d", i, index);
                            else
                                pFile->OutLine(L"    State[%d]", i);

                            if (index > -1)
                                DumpSectionData(pFile, pThemeFile, index, fPacked, fFullInfo);
                        }
                    }
                }
                atend = true;
                break;

            case TMT_JUMPTOPARENT:
                atend = true;
                break;
        }
    }
}
//---------------------------------------------------------------------------
HRESULT DumpThemeFile(LPCWSTR pszFileName, CUxThemeFile *pThemeFile, BOOL fPacked,
    BOOL fFullInfo)
{
    MIXEDPTRS u;
    CHAR szSignature[kcbBeginSignature + 1];
    CSimpleFile OutFile;
    CSimpleFile *pFile = &OutFile;

    HRESULT hr = OutFile.Create(pszFileName, TRUE);
    if (FAILED(hr))
        goto exit;

    u.pb = pThemeFile->_pbThemeData;

    pFile->OutLine(L"Loaded Theme Dump");
    pFile->OutLine(L"");        // blank line
    pFile->OutLine(L"Header Section");

    //---- dump header ----
    THEMEHDR *hdr = (THEMEHDR *)u.pb;
    u.pb += sizeof(THEMEHDR);

    if (fFullInfo)
        pFile->OutLine(L"  dwTotalLength: %d", hdr->dwTotalLength);

    CopyMemory(szSignature, hdr->szSignature, kcbBeginSignature); // hdr->szSignature is not zero-terminated.
    szSignature[kcbBeginSignature] = '\0';
    pFile->OutLine(L"  szSignature: %S", szSignature);
    
    pFile->OutLine(L"  dwVersion: 0x%x", hdr->dwVersion);
    pFile->OutLine(L"  dwFlags: 0x%x", hdr->dwFlags);

    if (fFullInfo)
        pFile->OutLine(L"  dwCheckSum: 0x%x", hdr->dwCheckSum);

    if (fFullInfo)
        pFile->OutLine(L"  DllName: %s", ThemeString(pThemeFile, hdr->iDllNameOffset));

    pFile->OutLine(L"  Color: %s", ThemeString(pThemeFile, hdr->iColorParamOffset));
    pFile->OutLine(L"  Size: %s", ThemeString(pThemeFile, hdr->iSizeParamOffset));

    if (fFullInfo)
    {
        pFile->OutLine(L"  Strings: index=%d, length=%d", hdr->iStringsOffset, hdr->iStringsLength);
        pFile->OutLine(L"  SectionIndex: index=%d, length=%d", hdr->iSectionIndexOffset, hdr->iSectionIndexLength);
    
        pFile->OutLine(L"  iGlobalsOffset: %d", hdr->iGlobalsOffset);
        pFile->OutLine(L"  iGlobalsTextObjOffset: %d", hdr->iGlobalsTextObjOffset);
        pFile->OutLine(L"  iGlobalsDrawObjOffset: %d", hdr->iGlobalsDrawObjOffset);

        pFile->OutLine(L"  iSysMetricsOffset: %d", hdr->iSysMetricsOffset);
    }

    //---- dump strings section ----
    pFile->OutLine(L"");        // blank line
    if (fFullInfo)
    {
        pFile->OutLine(L"Strings Section (index=%d, length=%d)", 
            THEMEFILE_OFFSET(u.pb), hdr->iStringsLength);
    }
    else
    {
        pFile->OutLine(L"Strings Section");
    }

    u.pb = pThemeFile->_pbThemeData + hdr->iStringsOffset;
    int len = lstrlen(u.pw);
    WCHAR *pLastStringChar = (WCHAR *)(u.pb + hdr->iStringsLength - 1);

    BOOL fFirstString = TRUE;

    while (u.pw <= pLastStringChar)
    {
        if (fFullInfo)
            pFile->OutLine(L"  index=%d: %s", THEMEFILE_OFFSET(u.pb), u.pw);
        else
        {
            if (! fFirstString)     // don't show pathnames
                pFile->OutLine(L"  %s", u.pw);
        }

        u.pw += (1 + len);
        len = lstrlen(u.pw);

        if (fFirstString)
            fFirstString = FALSE;
    }
    
    //---- index section ----
    u.pb = pThemeFile->_pbThemeData + hdr->iSectionIndexOffset;

    pFile->OutLine(L"");        // blank line

    if (fFullInfo)
    {
        pFile->OutLine(L"Index Section (index=%d, length=%d)", 
            THEMEFILE_OFFSET(u.pb), hdr->iSectionIndexLength);
    }
    else
    {
        pFile->OutLine(L"Index Section");
    }

    APPCLASSLIVE *ac = (APPCLASSLIVE *)u.pb;
    DWORD cnt = hdr->iSectionIndexLength/sizeof(APPCLASSLIVE);
    for (DWORD i=0; i < cnt; i++)
    {
        LPCWSTR pszApp = ThemeString(pThemeFile, ac->dwAppNameIndex);
        LPCWSTR pszClass = ThemeString(pThemeFile, ac->dwClassNameIndex);

        if (fFullInfo)
        {
            pFile->OutLine(L"[%s::%s] (index=%d, length=%d)", pszApp, pszClass,
                ac->iIndex, ac->iLen);
        }
        else
        {
            pFile->OutLine(L"[%s::%s]", pszApp, pszClass);
        }

        DumpSectionData(pFile, pThemeFile, ac->iIndex, fPacked, fFullInfo);

        ac++;
    }

    pFile->OutLine(L"END of Live Data dump");
    pFile->OutLine(L"");        // blank line

exit:
    return hr;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\gdisemu.h ===
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the GDISEMU_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// GDISEMU_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef GDISEMU_EXPORTS
#define GDISEMU_API __declspec(dllexport)
#else
#define GDISEMU_API __declspec(dllimport)
#endif

#define DS_MAGIC                'DrwS'
#define DS_SETTARGETID          0
#define DS_SETSOURCEID          1
#define DS_COPYTILEID           2
#define DS_SOLIDFILLID          3
#define DS_TRANSPARENTTILEID    4
#define DS_ALPHATILEID          5
#define DS_STRETCHID            6
#define DS_TRANSPARENTSTRETCHID 7
#define DS_ALPHASTRETCHID       8

typedef struct _DS_HEADER
{
    ULONG   magic;
} DS_HEADER;

typedef struct _DS_SETTARGET
{
    ULONG   ulCmdID;
    HDC     hdc;
    RECTL   rclBounds;
} DS_SETTARGET;

typedef struct _DS_SETSOURCE
{
    ULONG   ulCmdID;
    HDC     hdc;
} DS_SETSOURCE;

typedef struct _DS_COPYTILE
{
    ULONG   ulCmdID;
    RECTL   rclDst;
    RECTL   rclSrc;
    POINTL  ptlOrigin;
} DS_COPYTILE;

typedef struct _DS_SOLIDFILL
{
    ULONG       ulCmdID;
    RECTL       rclDst;
    COLORREF    crSolidColor;
} DS_SOLIDFILL;

typedef struct _DS_TRANSPARENTTILE
{
    ULONG       ulCmdID;
    RECTL       rclDst;
    RECTL       rclSrc;
    POINTL      ptlOrigin;
    COLORREF    crTransparentColor;
} DS_TRANSPARENTTILE;

typedef struct _DS_ALPHATILE
{
    ULONG           ulCmdID;
    RECTL           rclDst;
    RECTL           rclSrc;
    POINTL          ptlOrigin;
    BLENDFUNCTION   blendFunction;
} DS_ALPHATILE;

typedef struct _DS_STRETCHC
{
    ULONG       ulCmdID;
    RECTL       rclDst;
    RECTL       rclSrc;
} DS_STRETCH;

typedef struct _DS_TRANSPARENTSTRETCHC
{
    ULONG       ulCmdID;
    RECTL       rclDst;
    RECTL       rclSrc;
    COLORREF    crTransparentColor;
} DS_TRANSPARENTSTRETCH;

typedef struct _DS_ALPHASTRETCHC
{
    ULONG       ulCmdID;
    RECTL       rclDst;
    RECTL       rclSrc;
    BLENDFUNCTION   blendFunction;
} DS_ALPHASTRETCH;

/*GDISEMU_API */int DrawStream(int cjIn, void * pvIn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\gdisemu.cpp ===
// gdisemu.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "gdisemu.h"

// This is an example of an exported variable
//GDISEMU_API int nGdisemu=0;

int StreamCopyTile(
    HDC				hdcTarget,
    HDC				hdcSource,
	DS_COPYTILE *	cmd)
{
    RECTL *     dstRect = &cmd->rclDst;
    RECTL *     srcRect = &cmd->rclSrc;
    POINTL *    tileOrigin = &cmd->ptlOrigin;

    // brain dead for now

    LONG    tileWidth = srcRect->right - srcRect->left;
    LONG    tileHeight = srcRect->bottom - srcRect->top;
    LONG    y = dstRect->top;
    LONG    yEnd = dstRect->bottom;
    LONG    xEnd = dstRect->right;

    if(tileWidth <= 0 || tileHeight <= 0)
        return FALSE;

	if(tileOrigin->x >= tileWidth || tileOrigin->y >= tileHeight)
		return FALSE;

	LONG	sy = tileOrigin->y;

    while(y < yEnd)
    {
        LONG    dy = yEnd - y;

        if(dy > (tileHeight - sy)) dy = (tileHeight - sy);

        LONG x = dstRect->left;

		LONG sx = tileOrigin->x;

        while(x < xEnd)
        {
            LONG dx = xEnd - x;

            if(dx > (tileWidth - sx)) dx = (tileWidth - sx);

            if(!BitBlt(hdcTarget, x, y, dx, dy, hdcSource, srcRect->left + sx, srcRect->top + sy, SRCCOPY))
                return FALSE;

            x += dx;
			sx = 0;
        }

        y += dy;
		sy = 0;
    }

    return TRUE;
}

int StreamTransparentTile(
    HDC						hdcTarget,
    HDC						hdcSource,
	DS_TRANSPARENTTILE *	cmd)
{
    RECTL *     dstRect = &cmd->rclDst;
    RECTL *     srcRect = &cmd->rclSrc;
    POINTL *    tileOrigin = &cmd->ptlOrigin;

    // brain dead for now

    LONG    tileWidth = srcRect->right - srcRect->left;
    LONG    tileHeight = srcRect->bottom - srcRect->top;
    LONG    y = dstRect->top;
    LONG    yEnd = dstRect->bottom;
    LONG    xEnd = dstRect->right;

    if(tileWidth <= 0 || tileHeight <= 0)
        return FALSE;

	if(tileOrigin->x >= tileWidth || tileOrigin->y >= tileHeight)
		return FALSE;

	LONG	sy = tileOrigin->y;

    while(y < yEnd)
    {
        LONG    dy = yEnd - y;

        if(dy > (tileHeight - sy)) dy = (tileHeight - sy);

        LONG x = dstRect->left;

		LONG sx = tileOrigin->x;

        while(x < xEnd)
        {
            LONG dx = xEnd - x;

            if(dx > (tileWidth - sx)) dx = (tileWidth - sx);

            if(!GdiTransparentBlt(hdcTarget, x, y, dx, dy, hdcSource, srcRect->left + sx, srcRect->top + sy, dx, dy, cmd->crTransparentColor))
                return FALSE;

            x += dx;
			sx = 0;
        }

        y += dy;
		sy = 0;
    }

    return TRUE;
}

int StreamAlphaTile(
    HDC						hdcTarget,
    HDC						hdcSource,
	DS_ALPHATILE *			cmd)
{
    RECTL *     dstRect = &cmd->rclDst;
    RECTL *     srcRect = &cmd->rclSrc;
    POINTL *    tileOrigin = &cmd->ptlOrigin;

    // brain dead for now

    LONG    tileWidth = srcRect->right - srcRect->left;
    LONG    tileHeight = srcRect->bottom - srcRect->top;
    LONG    y = dstRect->top;
    LONG    yEnd = dstRect->bottom;
    LONG    xEnd = dstRect->right;

    if(tileWidth <= 0 || tileHeight <= 0)
        return FALSE;

	if(tileOrigin->x >= tileWidth || tileOrigin->y >= tileHeight)
		return FALSE;

	LONG	sy = tileOrigin->y;

    while(y < yEnd)
    {
        LONG    dy = yEnd - y;

        if(dy > (tileHeight - sy)) dy = (tileHeight - sy);

        LONG x = dstRect->left;

		LONG sx = tileOrigin->x;

        while(x < xEnd)
        {
            LONG dx = xEnd - x;

            if(dx > (tileWidth - sx)) dx = (tileWidth - sx);

            if(!GdiAlphaBlend(hdcTarget, x, y, dx, dy, hdcSource, srcRect->left + sx, srcRect->top + sy, dx, dy, cmd->blendFunction))
                return FALSE;

            x += dx;
			sx = 0;
        }

        y += dy;
		sy = 0;
    }

    return TRUE;
}

int StreamSolidFill(
    HDC				hdcTarget,
	DS_SOLIDFILL *	cmd)
{
	HBRUSH	hbr = CreateSolidBrush(cmd->crSolidColor);
	FillRect(hdcTarget, (RECT *) &cmd->rclDst, hbr);
	DeleteObject(hbr);

	return TRUE;
}

int StreamStretch(
    HDC				hdcTarget,
	HDC				hdcSource,
	DS_STRETCH *	cmd)
{
	StretchBlt(hdcTarget, cmd->rclDst.left,
						  cmd->rclDst.top,
						  (cmd->rclDst.right - cmd->rclDst.left),
						  (cmd->rclDst.bottom - cmd->rclDst.top),
			   hdcSource, cmd->rclSrc.left,
						  cmd->rclSrc.top,
						  (cmd->rclSrc.right - cmd->rclSrc.left),
						  (cmd->rclSrc.bottom - cmd->rclSrc.top),
						  SRCCOPY);
	return TRUE;
}

int StreamTransparentStretch(
    HDC				hdcTarget,
	HDC				hdcSource,
	DS_TRANSPARENTSTRETCH *	cmd)
{
	GdiTransparentBlt(hdcTarget, cmd->rclDst.left,
						  cmd->rclDst.top,
						  (cmd->rclDst.right - cmd->rclDst.left),
						  (cmd->rclDst.bottom - cmd->rclDst.top),
			   hdcSource, cmd->rclSrc.left,
						  cmd->rclSrc.top,
						  (cmd->rclSrc.right - cmd->rclSrc.left),
						  (cmd->rclSrc.bottom - cmd->rclSrc.top),
						  cmd->crTransparentColor);
	return TRUE;
}

int StreamAlphaStretch(
    HDC				hdcTarget,
	HDC				hdcSource,
	DS_ALPHASTRETCH *	cmd)
{
	GdiAlphaBlend(hdcTarget, cmd->rclDst.left,
						  cmd->rclDst.top,
						  (cmd->rclDst.right - cmd->rclDst.left),
						  (cmd->rclDst.bottom - cmd->rclDst.top),
			   hdcSource, cmd->rclSrc.left,
						  cmd->rclSrc.top,
						  (cmd->rclSrc.right - cmd->rclSrc.left),
						  (cmd->rclSrc.bottom - cmd->rclSrc.top),
						  cmd->blendFunction);
	return TRUE;
}

/*GDISEMU_API*/ int DrawStream(int cjIn, void * pvIn)
{
    HDC     hdcTarget = NULL;
    HDC     hdcSource = NULL;

    if(cjIn < sizeof(ULONG))
       return FALSE;

    ULONG * pul = (ULONG *) pvIn;

	// All streams should begin with DS_MAGIC
    if(*pul++ != DS_MAGIC)
        return FALSE;

    cjIn -= sizeof(ULONG);

    while(cjIn >= sizeof(ULONG))
    {
        ULONG   command = pul[0];
        int     commandSize;

        switch(command)
        {
        case DS_SETTARGETID: // set target

            commandSize = sizeof(DS_SETTARGET);

            if(cjIn < commandSize)
                return FALSE;

            hdcTarget = (HDC) pul[1];

            break;

        case DS_SETSOURCEID: // set source

            commandSize = sizeof(DS_SETSOURCE);

            if(cjIn < commandSize)
                return FALSE;

            hdcSource = (HDC) pul[1];

            break;

		case DS_SOLIDFILLID:

            commandSize = sizeof(DS_SOLIDFILL);

            if(cjIn < commandSize)
                return FALSE;

			if(!StreamSolidFill(hdcTarget, (DS_SOLIDFILL*) pul))
				return FALSE;

			break;

        case DS_COPYTILEID: // tile copy bits

            commandSize = sizeof(DS_COPYTILE);

            if(cjIn < commandSize)
                return FALSE;

            if(!StreamCopyTile(hdcTarget, hdcSource, (DS_COPYTILE*) pul))
                return FALSE;

            break;

        case DS_TRANSPARENTTILEID: // tile copy bits

            commandSize = sizeof(DS_TRANSPARENTTILE);

            if(cjIn < commandSize)
                return FALSE;

            if(!StreamTransparentTile(hdcTarget, hdcSource, (DS_TRANSPARENTTILE*) pul))
                return FALSE;

			break;

        case DS_ALPHATILEID: // tile copy bits

            commandSize = sizeof(DS_TRANSPARENTTILE);

            if(cjIn < commandSize)
                return FALSE;

            if(!StreamAlphaTile(hdcTarget, hdcSource, (DS_ALPHATILE*) pul))
                return FALSE;

            break;

        case DS_STRETCHID: // tile copy bits

            commandSize = sizeof(DS_STRETCH);

            if(cjIn < commandSize)
                return FALSE;

            if(!StreamStretch(hdcTarget, hdcSource, (DS_STRETCH*) pul))
                return FALSE;

            break;

        case DS_TRANSPARENTSTRETCHID: // tile copy bits

            commandSize = sizeof(DS_TRANSPARENTSTRETCH);

            if(cjIn < commandSize)
                return FALSE;

            if(!StreamTransparentStretch(hdcTarget, hdcSource, (DS_TRANSPARENTSTRETCH*) pul))
                return FALSE;

            break;

        case DS_ALPHASTRETCHID: // tile copy bits

            commandSize = sizeof(DS_ALPHASTRETCH);

            if(cjIn < commandSize)
                return FALSE;

            if(!StreamAlphaStretch(hdcTarget, hdcSource, (DS_ALPHASTRETCH*) pul))
                return FALSE;

            break;

        default:
            return FALSE;
        }

        cjIn -= commandSize;
        pul += commandSize / 4;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\gradient.h ===
//---------------------------------------------------------------------------
//  Gradient.h - gradient drawing support
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#define SYSCOLOR(c) (c|0x80000000)

#define RGBA2WINCOLOR(color) (color.bBlue << 16) | (color.bGreen << 8) | (color.bRed);
#define FIXCOLORVAL(val)     ((val > 255) ? 255 : ((val < 0) ? 0 : val))
//---------------------------------------------------------------------------
struct RGBA
{
    BYTE bRed;
    BYTE bGreen;
    BYTE bBlue;
    BYTE bAlpha;     // not currently supported   
};
//---------------------------------------------------------------------------
struct GRADIENTPART
{
    BYTE Ratio;     // 0-255 ratio for this color (sum of ratios must be <= 255)
    RGBA Color;
};
//---------------------------------------------------------------------------
//---- public ----
HRESULT PaintGradientRadialRect(HDC hdc, RECT &rcBounds, int iPartCount, 
    GRADIENTPART *pGradientParts);

HRESULT PaintHorzGradient(HDC hdc, RECT &rcBounds, int iPartCount, 
    GRADIENTPART *pGradientParts);

HRESULT PaintVertGradient(HDC hdc, RECT &rcBounds, int iPartCount, 
    GRADIENTPART *pGradientParts);

//---- helpers ----
void PaintGradientVertBand(HDC hdc, RECT &rcBand, COLORREF color1, COLORREF color2);
void PaintGradientHorzBand(HDC hdc, RECT &rcBand, COLORREF color1, COLORREF color2);
void PaintGradientRadialBand(HDC hdc, RECT &rcBand, int radiusOffset,
    int radius, COLORREF color1, COLORREF color2);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\handlers.cpp ===
#include "stdafx.h"
#include "handlers.h"

//-------------------------------------------------------------------------//
//  Declare registered message vars **here**
//-------------------------------------------------------------------------//
#define __NO_APPHACKS__
//-------------------------------------------------------------------------//
//  Message Handlers
//-------------------------------------------------------------------------//

//  Rules for message handlers [scotthan]:
//
//  (1) Use DECL_ macros to declare message handler prototype and
//      table entries for message handlers below.
//  (2) A message handler implementation should NOT:
//      1. call DefWindowProc or CallWindowProc directly,
//         but rather use DoMsgDefault().
//      2. delete the incoming CThemeWnd* object,
//  (3) A message handler SHOULD:
//      1. Honor the codepage value in the message block when
//         handling messages that carry string args.
//         If the codepage member is CP_WINUNICODE, the widechar
//         string processing should be assumed; otherwise, multibyte
//         string processing should be assumed.
//      2. If a message should not be forwarded for default processing,
//         mark the message as handled using MsgHandled().
//  (4) Handlers should be listed in the BEGIN/ENDMSG() block
//      below in decreasing order of expected frequency.


//---------------------//
//  WndProc overrides
//---------------------//

//  msg handler decls:
DECL_MSGHANDLER( OnOwpPostCreate );
DECL_MSGHANDLER( OnOwpPreStyleChange );
DECL_MSGHANDLER( OnOwpPreWindowPosChanging );
DECL_MSGHANDLER( OnOwpPreWindowPosChanged );
DECL_MSGHANDLER( OnOwpPostWindowPosChanged );
DECL_MSGHANDLER( OnOwpPostSettingChange );
DECL_MSGHANDLER( OnOwpPreMeasureItem );
DECL_MSGHANDLER( OnOwpPreDrawItem );
DECL_MSGHANDLER( OnOwpPreMenuChar );
DECL_MSGHANDLER( OnOwpPostThemeChanged );
DECL_MSGHANDLER( OnOwpPreNcPaint );
DECL_MSGHANDLER( OnOwpPostNcPaint );

//  handler table:
BEGIN_HANDLER_TABLE(_rgOwpHandlers)
    // frequent messages
    DECL_MSGENTRY( WM_NCPAINT,           OnOwpPreNcPaint, OnOwpPostNcPaint )
    DECL_MSGENTRY( WM_WINDOWPOSCHANGING, OnOwpPreWindowPosChanging, NULL )
    DECL_MSGENTRY( WM_WINDOWPOSCHANGED,  OnOwpPreWindowPosChanged, OnOwpPostWindowPosChanged )
    DECL_MSGENTRY( WM_SETTINGCHANGE,     NULL, OnOwpPostSettingChange )
    DECL_MSGENTRY( WM_MEASUREITEM,       OnOwpPreMeasureItem, NULL )
    DECL_MSGENTRY( WM_DRAWITEM,          OnOwpPreDrawItem, NULL )
    DECL_MSGENTRY( WM_MDISETMENU,        NULL, NULL )

    // rare messages:
    DECL_MSGENTRY( WM_MENUCHAR,          OnOwpPreMenuChar, NULL )
    DECL_MSGENTRY( WM_STYLECHANGING,     OnOwpPreStyleChange, NULL )
    DECL_MSGENTRY( WM_STYLECHANGED,      OnOwpPreStyleChange, NULL )
    DECL_MSGENTRY( WM_NCCREATE,          NULL, NULL )
    DECL_MSGENTRY( WM_CREATE,            NULL, OnOwpPostCreate )
    DECL_MSGENTRY( WM_NCDESTROY,         NULL, NULL )
    DECL_MSGENTRY( WM_THEMECHANGED,      NULL, OnOwpPostThemeChanged  )      // we handle in line in ThemePreWndProc()
    DECL_MSGENTRY( WM_THEMECHANGED_TRIGGER,    NULL, NULL )      // we handle in line in ThemePreWndProc()
END_HANDLER_TABLE()

//  Note: values of high owp message must be in sync w/ table.
#define WNDPROC_MSG_LAST  WM_THEMECHANGED_TRIGGER   // 0x031B (alias for WM_UAHINIT)


//------------------------//
//  DefDlgProc overrides
//------------------------//

//  msg handler decls:
DECL_MSGHANDLER( OnDdpPostCtlColor );
DECL_MSGHANDLER( OnDdpCtlColor );
DECL_MSGHANDLER( OnDdpPrint );
DECL_MSGHANDLER( OnDdpPostInitDialog );

//  handler table:
BEGIN_HANDLER_TABLE(_rgDdpHandlers)
    // frequent messages:
    DECL_MSGENTRY( WM_CTLCOLORDLG,       NULL, OnDdpPostCtlColor )
    DECL_MSGENTRY( WM_CTLCOLORSTATIC,    NULL, OnDdpCtlColor)
    DECL_MSGENTRY( WM_CTLCOLORBTN,       NULL, OnDdpCtlColor)
    DECL_MSGENTRY( WM_CTLCOLORMSGBOX,    NULL, OnDdpPostCtlColor )
    DECL_MSGENTRY( WM_PRINTCLIENT,       NULL, OnDdpPrint )
    // rare messages:
    DECL_MSGENTRY( WM_INITDIALOG,        NULL, OnDdpPostInitDialog )
END_HANDLER_TABLE()

//  Note: values of high ddp message must be in sync w/ table.
#define DEFDLGPROC_MSG_LAST   WM_PRINTCLIENT   // 0x0318


//--------------------------//
//  DefWindowProc override
//--------------------------//

//  msg handler decls:
DECL_MSGHANDLER( OnDwpNcPaint );
DECL_MSGHANDLER( OnDwpNcHitTest );
DECL_MSGHANDLER( OnDwpNcActivate );
DECL_MSGHANDLER( OnDwpNcLButtonDown );
DECL_MSGHANDLER( OnDwpNcThemeDrawCaption );
DECL_MSGHANDLER( OnDwpNcThemeDrawFrame );
DECL_MSGHANDLER( OnDwpNcMouseMove );
DECL_MSGHANDLER( OnDwpNcMouseLeave );
DECL_MSGHANDLER( OnDwpWindowPosChanged );
DECL_MSGHANDLER( OnDwpSysCommand );
DECL_MSGHANDLER( OnDwpSetText );
DECL_MSGHANDLER( OnDwpSetIcon );
DECL_MSGHANDLER( OnDwpStyleChanged );
DECL_MSGHANDLER( OnDwpPrint );
DECL_MSGHANDLER( OnDwpPrintClient );
DECL_MSGHANDLER( OnDwpContextMenu );

//  handler table:
BEGIN_HANDLER_TABLE(_rgDwpHandlers)
    // frequent messages:
    DECL_MSGENTRY( WM_NCHITTEST,          OnDwpNcHitTest,     NULL )
    DECL_MSGENTRY( WM_NCPAINT,            OnDwpNcPaint,       NULL )
    DECL_MSGENTRY( WM_NCACTIVATE,         OnDwpNcActivate,    NULL )
    DECL_MSGENTRY( WM_NCMOUSEMOVE,        OnDwpNcMouseMove,   NULL )
    DECL_MSGENTRY( WM_NCMOUSELEAVE,       OnDwpNcMouseLeave,  NULL )
    DECL_MSGENTRY( WM_WINDOWPOSCHANGED,   OnDwpWindowPosChanged, NULL )
    DECL_MSGENTRY( WM_SYSCOMMAND,         OnDwpSysCommand,    NULL )
    DECL_MSGENTRY( WM_NCLBUTTONDOWN,      OnDwpNcLButtonDown, NULL )
    DECL_MSGENTRY( WM_NCUAHDRAWCAPTION,   OnDwpNcThemeDrawCaption, NULL )
    DECL_MSGENTRY( WM_NCUAHDRAWFRAME,     OnDwpNcThemeDrawFrame, NULL )
    DECL_MSGENTRY( WM_PRINT,              OnDwpPrint,  NULL )
    DECL_MSGENTRY( WM_PRINTCLIENT,        OnDwpPrintClient, NULL )
    DECL_MSGENTRY( WM_CTLCOLORMSGBOX,     OnDdpPostCtlColor, NULL)         // Strange: Sent to DefWindowProc, but is a Dialog message
    DECL_MSGENTRY( WM_CTLCOLORSTATIC,     OnDdpCtlColor, NULL)
    DECL_MSGENTRY( WM_CTLCOLORBTN,        OnDdpCtlColor, NULL)
    // rare messages:
    DECL_MSGENTRY( WM_SETTEXT,            OnDwpSetText,       NULL )
    DECL_MSGENTRY( WM_SETICON,            OnDwpSetIcon,       NULL )
    DECL_MSGENTRY( WM_STYLECHANGED,       OnDwpStyleChanged,  NULL )
    DECL_MSGENTRY( WM_CONTEXTMENU,        OnDwpContextMenu,   NULL )
    DECL_MSGENTRY( WM_THEMECHANGED_TRIGGER,    NULL, NULL )
    DECL_MSGENTRY( WM_NCDESTROY,          NULL, NULL )
END_HANDLER_TABLE()

//  Note: values of high dwp message must be in sync w/ handler table.
#define DEFWNDPROC_MSG_LAST  WM_THEMECHANGED_TRIGGER // 0x031B

//---------------------------------------------------------------------------
BOOL _FindMsgHandler( UINT, MSGENTRY [], int, IN HOOKEDMSGHANDLER*, IN HOOKEDMSGHANDLER* );
BOOL _SetMsgHandler( UINT, MSGENTRY [], int, IN HOOKEDMSGHANDLER, BOOL );

//---------------------------------------------------------------------------
//  Special case hook handling
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
BOOL _IsExcludedSystemProcess( LPCWSTR pszProcess )
{
    static  const WCHAR*    _rgszSystemProcessList[]   =
    {
        L"lsass",       //  Local Security Authority sub-system
        L"services",    //  Service Control Manager
        L"svchost",     //  Service Host
        L"mstask",      //  Microsoft Task Scheduler
        L"dfssvc",      //  Distributed File System Service
        L"winmgmt",     //  Windows Management Instrumentation
        L"spoolsv",     //  Print Spool Service
        L"msdtc",       //  Microsoft Distributed Transaction Co-ordinator
        L"regsvc",      //  Remote Registry Service
        L"webclnt",     //  Web Client
        L"mspmspsv",    //  WMDM PMSP Service (what is this?)
        L"ntvdm"        //  NT virtual DOS machine
    };

    return AsciiScanStringList( pszProcess, _rgszSystemProcessList, 
                           ARRAYSIZE(_rgszSystemProcessList), TRUE );
}

//---------------------------------------------------------------------------
BOOL _IsProcessOnInteractiveWindowStation() // check if we're on winsta0.
{
    BOOL    fRet    = FALSE;
    HWINSTA hWinSta = GetProcessWindowStation();
    
    if( hWinSta != NULL )
    {
        DWORD   cbLength = 0;
        WCHAR   wszName[32];

        if (GetUserObjectInformationW(hWinSta, UOI_NAME, wszName, sizeof(wszName), &cbLength))
        {
            fRet = (0 == AsciiStrCmpI(wszName, L"winsta0"));
        }
        else
        {
            //  Problem!  It's either:
            //      - our buffer was too small (in which case it can't be winsta0)
            //      - or some other failure we cannot overcome anyhow
        }
    }
    return(fRet);
}

//---------------------------------------------------------------------------
BOOL _IsWin16App() // check if this is a 16-bit process
{
    GUITHREADINFO gti;
    gti.cbSize = sizeof(gti);
    gti.flags  = GUI_16BITTASK;

    return GetGUIThreadInfo( GetCurrentThreadId(), &gti ) && 
           TESTFLAG(gti.flags, GUI_16BITTASK );
}

//---------------------------------------------------------------------------
BOOL ApiHandlerInit( const LPCTSTR pszProcess, USERAPIHOOK* puahTheme, const USERAPIHOOK* puahReal )
{
    //  exclude known non-UI system processes
    if( _IsExcludedSystemProcess( pszProcess ) )
        return FALSE;

    //  exclude any process not hosted on winsta0.
    if( !_IsProcessOnInteractiveWindowStation() )
        return FALSE;

    if( _IsWin16App() )
        return FALSE;
    
    //  SHIMSHIM [scotthan]:

#ifdef _DEBUG
    //---- temp patch against msvcmon ----
    if( 0 == AsciiStrCmpI(pszProcess, L"msvcmon") )
    {
        return FALSE;
    }

    //---- temp patch against msdev ----
    if( 0 == AsciiStrCmpI(pszProcess, L"msdev") )
    {
        return FALSE;
    }

    //---- Aid in debugging classic/themed differences: ---
    if( 0 == AsciiStrCmpI( pszProcess, L"mditest1" ) )
    {
        return FALSE;
    }
#endif

#ifndef __NO_APPHACKS__

    static  const WCHAR* _rgszExcludeAppList[] =
    {
#ifdef THEME_CALCSIZE
        // Invoking SetWindowPos from CThemeWnd::SetFrameTheme on our Post-WM_CREATE handler 
        // causes emacs to divide by zero after receiving meaningless rects from two 
        // successive calls to AdjustWindowRectEx from his WM_WINDOWPOSCHANGING handler.   
        // I don't believe it is related to the fact that AdjustWindowRectEx has yet 
        // to be implemented for themed windows (raid# 140989), but rather that the wndproc
        // is not ready for a WM_WINDOWPOSCHANGING message on the abrubtly on the 
        // heels of a WM_CREATE handler.
        L"emacs",

        L"neoplanet", // 247283: We rush in to theme neoplanet's dialogs, which we almost
        L"np",        // immediately revoke, but not before sizing the dialog to theme-compatible
                      // client rect. When we withdraw, we leave it clipped.  No good way to deal 
                      // with this for beta2.

        // HTML Editor++ v.8: 286676:
        // This guy recomputes his nonclient area, and then AVs dereferencing a 
        // WM_WINDOWPOSCHANGING message under themes.
        L"coffee", 
#endif THEME_CALCSIZE

        L"refcntr", // 205059: Corel Reference Center; lower 10% of window is clipped.

        L"KeyFramerPro", // 336456: Regardless of whether themes are enabled, Boris KeyFramer Pro v.5 
                         //         does two SetWindowRgn() calls for every WM_PAINT, the first with a region, 
                         //         the next with NULL,  Is the app trying to clip his painting?  
                         //         If so, this is not what SetWindowRgn was intended for, and explains why this
                         //         app is so clunky at window resizing. Rather, SelectClipRgn is the
                         //         correct API.
                         //         When themes are enabled, we keep revoking and re-attatching with each
                         //         SetWindowRgn call, so we get substantial flicker.
                         //         The ISV should be notified of this bug.

        // Applications that do custom non-client painting and hence look broken when 
        // themed. Our only recourse at the moment it to exclude them from non-client 
        // themeing so that we don't stomp whatever they are trying to do.
        L"RealJBox",    // 273370: Real JukeBox
        L"RealPlay",    // 285368: Real AudioPlayer
        L"TeamMgr",     // 286654: Microsoft Team Manager97
        L"TrpMaker",    // 307107: Rand McNally TripMaker 2000
        L"StrFindr",    // 307535: Rand McNally StreetFinder 2000
        L"Exceed",      // 276244: Hummingbird Exceed 6.2/7.0
        L"VP30",        // 328676: Intel Video Phone

        //  313407: Groove, build 760
        //  Calls DefWindowProc for NCPAINT, then paints his own caption over it.
        //  Note: this just might work correctly if we had a DrawFrameControl hook.
        L"groove", // filever 1.1.0.760, 1/22/2001 tested.

        // 303756: Exclude all Lotus SmartSuite apps to provide consistency among their 
        // apps. All of them draw into the caption bar.
        L"WordPro",     // 285065: Lotus WordPro, a particularly poorly implemented app.
        L"SmartCtr",    //         It's WordPerfect compat menu is the elephant man of modern software.
        L"123w",
        L"Approach",
        L"FastSite",
        L"F32Main",
        L"Org5",

        // 358337: Best Technology - GCC Developer Lite.  Custom caption bar fights with Luna.
        L"GCCDevL",     // install point: http://www.besttechnology.co.jp/download/GDL1_0_3_6.EXE

        // 360422: J Zenrin The Real Digital Map Z3(T1):Max/Min/Close buttons are overlapped on classic buttons in title bar.
        L"emZmain", 

        // 364337:  Encarta World English Dictionary: Luna system buttons are overlaid on top of app's custom ones when mousing over
        L"ewed.exe",

        // 343171:  Reaktor Realtime Instrument: pressing the close button while themed causes this app to 
        //          spin in a tight loop running at realtime priority, effectively hanging the machine. 
        //          The message loop for this app is extremely timing sensitive, the additional overhead 
        //          introduced by theming alters the timing enough to break this app.
        L"Reaktor",
    };

    if( AsciiScanStringList( pszProcess, _rgszExcludeAppList, 
                        ARRAYSIZE(_rgszExcludeAppList), TRUE ) )
    {
        return FALSE;
    }

#ifdef THEME_CALCSIZE
    // Winstone 99 needs modified NC_CALCSIZE behavior for Netscape or it will hang.
    if ( 0 == AsciiStrCmpI( pszProcess, L"Netscape" ))
    {
        if (FindWindowEx(NULL, NULL, L"ZDBench32Frame", NULL) != NULL)
        {
            _SetMsgHandler( WM_NCCALCSIZE, _rgDwpHandlers, ARRAYSIZE(_rgDwpHandlers),
                         OnDwpNcCalcSize2, FALSE );
            return TRUE;
        }
    }
#endif THEME_CALCSIZE

    //-------------------------
    // This AppHack was once fixed, but got broke again with 
    // addition of logic for partial-screen maximized windows.
    //
    // Something in our answer to NCCALCSIZE causes quick time player 
    // to continously flood its 'control' frame window's winproc with 
    // WM_PAINTS by repeatedly calling InvalidateRgn + UpdateWindow.   My
    // suspicion is that he looks at what DefWindowProc returns from
    // NCCALCSIZE to determine the area he needs to manage, and when
    // this doesn't hash with other SYSMET values and/or AdjustWindowRect, 
    // he redundantly invalidates himself,
    //
    // This only repros if qtp is launched w/ .mov file, works fine if 
    // launched without a file and then a file is loaded.
#ifdef THEME_CALCSIZE
    if( 0 == AsciiStrCmpI( pszProcess, L"QuickTimePlayer" ))
    {
        _SetMsgHandler( WM_NCCALCSIZE, _rgDwpHandlers, ARRAYSIZE(_rgDwpHandlers),
                     OnDwpNcCalcSize2, FALSE );
        return TRUE;
    }

    //  SEANHI DID NOT RECEIVE THE S/W FROM APPLIB AND SO WAS UNABLE TO VERIFY THIS 
    //  NO LONGER REPROS W/ ELIMINATION OF THEMED SYSMETS
    //-------------------------
    // Paradox 9 appHack for nonclient button sizes:
    //
    // Paradox table schema view uses DrawFrameControl to render both
    // a classic toolframe (small) caption and buttons, but uses the 
    // themed values of SM_CYSIZE instead of SM_CYSMSIZE to size the buttons. 
    // This apphack redirects requests in this process for SM_CX/YSIZE to SM_CX/YSMSIZE.
    if( 0 == AsciiStrCmpI( pszProcess, L"pdxwin32" ) )
    {
        _SetGsmHandler( SM_CXSIZE, OnGsmCxSmBtnSize );
        _SetGsmHandler( SM_CYSIZE, OnGsmCySmBtnSize );
        return TRUE;
    }
#endif THEME_CALCSIZE



    //-------------------------
#else
#   pragma message("App hacks disabled")
#endif __NO_APPHACKS__


    return TRUE;
}

//---------------------------------------------------------------------------
//  Handler table utility functions
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
void HandlerTableInit() {}

//---------------------------------------------------------------------------
BOOL _InitMsgMask( LPBYTE prgMsgMask, DWORD dwMaskBytes, MSGENTRY* prgEntries, int cEntries, 
    IN OUT BOOL& fInit )
{
    if( !fInit )
    {
        for( int i = 0; i < cEntries; i++ )
        {
            if( -1 == prgEntries[i].nMsg )
            {
                ASSERT(prgEntries[i].pnRegMsg);
                //  Initialize registered message entry
                prgEntries[i].nMsg = *prgEntries[i].pnRegMsg;

                Log(LOG_TMHANDLE, L"InitMsgMsg corrected registered msg: 0x%x", prgEntries[i].nMsg);
            }

            //---- ensure we set up limit on table correctly ----
            ASSERT((prgEntries[i].nMsg)/8 < dwMaskBytes);
            
            SET_MSGMASK( prgMsgMask, prgEntries[i].nMsg );
        }
        fInit = TRUE;
    }

    return fInit;
}

//---------------------------------------------------------------------------
//  Scan of MSG table as linear array:
inline int _FindMsgHandler(
    UINT nMsg,
    MSGENTRY rgEntries[],
    int cEntries,
    OUT OPTIONAL HOOKEDMSGHANDLER* ppfnHandler,
    OUT OPTIONAL HOOKEDMSGHANDLER* ppfnHandler2 )
{
    ASSERT( nMsg );
    ASSERT( nMsg != (UINT)-1 );

    if( ppfnHandler )  *ppfnHandler  = NULL;
    if( ppfnHandler2 ) *ppfnHandler2 = NULL;

    for( int i = 0; i < cEntries; i++ )
    {
        if( rgEntries[i].nMsg == nMsg )
        {
            //  If no handler requested, return success
            if( NULL == ppfnHandler && NULL == ppfnHandler2 )
                return i;

            //  Assign outbound handler values
            if( ppfnHandler )  *ppfnHandler  = rgEntries[i].pfnHandler;
            if( ppfnHandler2 ) *ppfnHandler2 = rgEntries[i].pfnHandler2;

            //  return TRUE iif caller got what he asked for.
            return ((ppfnHandler && *ppfnHandler) || (ppfnHandler2 && *ppfnHandler2)) ? i : -1;
        }
    }
    return -1;
}

//---------------------------------------------------------------------------
//  Modify existing handler
inline BOOL _SetMsgHandler(
    UINT nMsg,
    MSGENTRY rgEntries[],
    int cEntries,
    IN HOOKEDMSGHANDLER pfnHandler, 
    BOOL fHandler2 )
{
    int i = _FindMsgHandler( nMsg, rgEntries, cEntries, NULL, NULL );
    if( i >= 0 )
    {
        if( fHandler2 )
            rgEntries[i].pfnHandler2 = pfnHandler;
        else
            rgEntries[i].pfnHandler = pfnHandler;
        return TRUE;
    }
    return FALSE;
}


#define CBMSGMASK(msgHigh)  (((msgHigh)+1)/8 + ((((msgHigh)+1) % 8) ? 1: 0))

//---------------------------------------------------------------------------
DWORD GetOwpMsgMask( LPBYTE* prgMsgMask )
{
    static BOOL _fOwpMask = FALSE; // initialized?
    static BYTE _rgOwpMask[CBMSGMASK(WNDPROC_MSG_LAST)] = {0};

    if( _InitMsgMask( _rgOwpMask, ARRAYSIZE(_rgOwpMask), _rgOwpHandlers, ARRAYSIZE(_rgOwpHandlers), _fOwpMask ) )
    {
        *prgMsgMask = _rgOwpMask;
        return ARRAYSIZE(_rgOwpMask);
    }
    return 0;
}

//---------------------------------------------------------------------------
DWORD GetDdpMsgMask( LPBYTE* prgMsgMask )
{
    static BOOL _fDdpMask = FALSE; // initialized?
    static BYTE _rgDdpMask[CBMSGMASK(DEFDLGPROC_MSG_LAST)] = {0};

    if( _InitMsgMask( _rgDdpMask, ARRAYSIZE(_rgDdpMask), _rgDdpHandlers, ARRAYSIZE(_rgDdpHandlers), _fDdpMask ) )
    {
        *prgMsgMask = _rgDdpMask;
        return ARRAYSIZE(_rgDdpMask);
    }
    return 0;
}

//---------------------------------------------------------------------------
DWORD GetDwpMsgMask( LPBYTE* prgMsgMask )
{
    static BOOL _fDwpMask = FALSE; // initialized?
    static BYTE _rgDwpMask[CBMSGMASK(DEFWNDPROC_MSG_LAST)] = {0};

    if( _InitMsgMask( _rgDwpMask, ARRAYSIZE(_rgDwpMask), _rgDwpHandlers, ARRAYSIZE(_rgDwpHandlers), _fDwpMask ) )
    {
        *prgMsgMask = _rgDwpMask;
        return ARRAYSIZE(_rgDwpMask);
    }
    return 0;
}

//---------------------------------------------------------------------------
BOOL FindOwpHandler(
    UINT nMsg, HOOKEDMSGHANDLER* ppfnPre, HOOKEDMSGHANDLER* ppfnPost )
{
    return _FindMsgHandler( nMsg, _rgOwpHandlers, ARRAYSIZE(_rgOwpHandlers),
                         ppfnPre, ppfnPost ) >= 0;
}

//---------------------------------------------------------------------------
BOOL FindDdpHandler(
    UINT nMsg, HOOKEDMSGHANDLER* ppfnPre, HOOKEDMSGHANDLER* ppfnPost )
{
    return _FindMsgHandler( nMsg, _rgDdpHandlers, ARRAYSIZE(_rgDdpHandlers),
                         ppfnPre, ppfnPost ) >= 0;
}

//---------------------------------------------------------------------------
BOOL FindDwpHandler( UINT nMsg, HOOKEDMSGHANDLER* ppfnPre )
{
    HOOKEDMSGHANDLER pfnPost;
    return _FindMsgHandler( nMsg, _rgDwpHandlers, ARRAYSIZE(_rgDwpHandlers),
                         ppfnPre, &pfnPost ) >= 0;
}

//---------------------------------------------------------------------------
//  Performs default message processing.
LRESULT WINAPI DoMsgDefault( const THEME_MSG *ptm )
{
    ASSERT( ptm );
    if( ptm->pfnDefProc )
    {
        MsgHandled( ptm );
        if( MSGTYPE_DEFWNDPROC == ptm->type )
            return ptm->pfnDefProc( ptm->hwnd, ptm->uMsg, ptm->wParam, ptm->lParam );
        else
        {
            ASSERT( NULL == ptm->pfnDefProc ); // bad initialization (_InitThemeMsg)
        }
    }
    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\gradient.cpp ===
//---------------------------------------------------------------------------
//  Gradient.cpp - gradient drawing support
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"
#include "Utils.h"
#include "gradient.h"
//---------------------------------------------------------------------------
HRESULT PaintGradientRadialRect(HDC hdc, RECT &rcBand, int iPartCount, 
    GRADIENTPART *pGradientParts)
{ 
    if (iPartCount < 2)
        return MakeError32(E_INVALIDARG);

    int width = WIDTH(rcBand);
    int height = HEIGHT(rcBand);

    int radius = width;
    if (height > width)
        radius = height;

    radius = radius/2;

    int radiusOffset = 0;
    int ratioTotal = 0;
    UCHAR ratio;
    bool firstColor = true;
    COLORREF color, prevcolor = 0;

    for (int i=0; i <= iPartCount; i++)        // go thru 1 extra time at end
    {
        if (i == iPartCount)       // solid part of last color for remaining ratio
        {
            color = prevcolor;
            ratio = static_cast<UCHAR>(255 - ratioTotal);
        }
        else
        {
            color = RGBA2WINCOLOR(pGradientParts[i].Color);
            ratio = pGradientParts[i].Ratio;
        }

        if (firstColor)
        {
            prevcolor = color;
            firstColor = false;
        }

        int radius2 = radius*ratio/255;
        if (radius2)
            PaintGradientRadialBand(hdc, rcBand, radiusOffset, radius2, prevcolor, color);

        radiusOffset += radius2;
        prevcolor = color;
        ratioTotal += ratio;
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT PaintHorzGradient(HDC hdc, RECT &rcBand, int iPartCount, 
    GRADIENTPART *pGradientParts)
{
    if (iPartCount < 2)
        return MakeError32(E_INVALIDARG);

    int width = WIDTH(rcBand);
    int xoffset = rcBand.left;
    int ratioTotal = 0;
    UCHAR ratio;
    bool firstColor = true;
    COLORREF color, prevcolor = 0;

    for (int i=0; i <= iPartCount; i++)        // go thru 1 extra time at end
    {
        if (i == iPartCount)       // solid part of last color for remaining ratio
        {
            color = prevcolor;
            ratio = static_cast<UCHAR>(255 - ratioTotal);
        }
        else
        {
            color = RGBA2WINCOLOR(pGradientParts[i].Color);
            ratio = pGradientParts[i].Ratio;
        }

        if (firstColor)
        {
            prevcolor = color;
            firstColor = false;
        }

        int width2 = width*ratio/255;
        if (width2)
        {
            RECT rect2 = {xoffset, rcBand.top, xoffset+width2, rcBand.bottom};
            PaintGradientHorzBand(hdc, rect2, prevcolor, color);
        }

        xoffset += width2;
        prevcolor = color;
        ratioTotal += ratio;
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT PaintVertGradient(HDC hdc, RECT &rcBounds, int iPartCount, 
    GRADIENTPART *pGradientParts)
{
    if (iPartCount < 2)
        return MakeError32(E_INVALIDARG);

    int iHeight = HEIGHT(rcBounds);
    int yoffset = rcBounds.top;
    int ratioTotal = 0;
    UCHAR ratio;
    bool firstColor = true;
    COLORREF color, prevcolor = 0;

    for (int i=0; i <= iPartCount; i++)        // go thru 1 extra time at end
    {
        if (i == iPartCount)       // solid part of last color for remaining ratio
        {
            color = prevcolor;
            ratio = static_cast<UCHAR>(255 - ratioTotal);
        }
        else
        {
            color = RGBA2WINCOLOR(pGradientParts[i].Color);
            ratio = pGradientParts[i].Ratio;
        }

        if (firstColor)
        {
            prevcolor = color;
            firstColor = false;
        }

        int iHeight2 = iHeight*ratio/255;
        if (iHeight2)
        {
            RECT rect2 = {rcBounds.left, yoffset, rcBounds.right, yoffset+iHeight2};
            PaintGradientVertBand(hdc, rect2, prevcolor, color);
        }

        yoffset += iHeight2;
        prevcolor = color;
        ratioTotal += ratio;
    }

    return S_OK;
}
//---------------------------------------------------------------------------
void DrawGradient(HDC hdc, RECT &rcBand, COLORREF color1, COLORREF color2, BOOL fHorz)
{
    TRIVERTEX vert[2];
    GRADIENT_RECT gRect;

    vert[0].x = rcBand.left;
    vert[0].y = rcBand.top;
    vert[1].x = rcBand.right;
    vert[1].y = rcBand.bottom; 

    // first vertex
    vert[0].Red   = (USHORT)(GetRValue(color1) << 8);
    vert[0].Green = (USHORT)(GetGValue(color1) << 8);
    vert[0].Blue  = (USHORT)(GetBValue(color1) << 8);
    vert[0].Alpha = 0x0000;

    // second vertex
    vert[1].Red   = (USHORT)(GetRValue(color2) << 8);
    vert[1].Green = (USHORT)(GetGValue(color2) << 8);
    vert[1].Blue  = (USHORT)(GetBValue(color2) << 8);
    vert[1].Alpha = 0x0000;

    gRect.UpperLeft  = 0;
    gRect.LowerRight = 1;

    GdiGradientFill(hdc, vert, 2, &gRect, 1, fHorz ? GRADIENT_FILL_RECT_H : GRADIENT_FILL_RECT_V);
}
//---------------------------------------------------------------------------
void PaintGradientHorzBand(HDC hdc, RECT &rcBand, COLORREF color1, COLORREF color2)
{
    DrawGradient(hdc, rcBand, color1, color2, TRUE);
}
//---------------------------------------------------------------------------
void PaintGradientVertBand(HDC hdc, RECT &rcBand, COLORREF color1, COLORREF color2)
{
    DrawGradient(hdc, rcBand, color1, color2, FALSE);
}
//---------------------------------------------------------------------------
void PaintGradientRadialBand(HDC hdc, RECT &rcBand, int radiusOffset,
    int radius, COLORREF color1, COLORREF color2)
{
    int red1 = RED(color1);
    int red2 = RED(color2);
    int green1 = GREEN(color1);
    int green2 = GREEN(color2);
    int blue1 = BLUE(color1);
    int blue2 = BLUE(color2);

    int maxcolors = abs(red1 - red2);

    int cnt = abs(green1 - green2);
    if (cnt > maxcolors)
        maxcolors = cnt;

    cnt = abs(blue1 - blue2);
    if (cnt > maxcolors)
        maxcolors = cnt;

    int linewidth;
    if (color1 == color2)               // just do solid color1
        linewidth = radius;
    else if (radius > maxcolors)
        linewidth = radius/maxcolors;
    else
        linewidth = 1;

    POINT center = {rcBand.left + WIDTH(rcBand)/2, rcBand.top + HEIGHT(rcBand)/2};
    radiusOffset += linewidth/2;        // center pen within line

    for (int r=0; r < radius; r += linewidth)
    {
        int red = (red2*r + red1*(radius-r))/radius;
        int green = (green2*r + green1*(radius-r))/radius;
        int blue = (blue2*r + blue1*(radius-r))/radius;

        int radius2 = radiusOffset + r;   // center pen within target line

        //---- calculate rcBand around "center" with "radius2" ----
        int left = center.x - radius2;
        int right = center.x + radius2;
        int top = center.y - radius2;
        int bottom = center.y + radius2;

        //---- overlap lines slightly so that bg doesn't leak thru ----
        HPEN pen = CreatePen(PS_SOLID, linewidth+2, RGB(red, green, blue));
        HPEN oldpen = (HPEN)SelectObject(hdc, pen);

        Arc(hdc, left, top, right, bottom, 0, 0, 0, 0);

        SelectObject(hdc, oldpen);
        DeleteObject(pen);
    }
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\imagefile.cpp ===
//---------------------------------------------------------------------------
//  ImageFile.cpp - implements the drawing API for bgtype = ImageFile
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"
#include "Utils.h"
#include "tmutils.h"
#include "rgn.h"
#include "ImageFile.h"
#include "CacheList.h"
#include "DrawHelp.h"
#include "TmReg.h"
#include "globals.h"
#include "bmpcache.h"
//---------------------------------------------------------------------------
void AdjustSizeMin(SIZE *psz, int ixMin, int iyMin)
{
    if (psz->cx < ixMin)
    {
        psz->cx = ixMin;
    }

    if (psz->cy < iyMin)
    {
        psz->cy = iyMin;
    }
}
//---------------------------------------------------------------------------
HRESULT CMaxImageFile::PackMaxProperties(CRenderObj *pRender, int iPartId, int iStateId,
        OUT int *piMultiDibCount)
{
    HRESULT hr = PackProperties(pRender, iPartId, iStateId);

    *piMultiDibCount = _iMultiImageCount;

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::PackProperties(CRenderObj *pRender, int iPartId, int iStateId)
{
    HRESULT hr = S_OK;

    memset(this, 0, sizeof(CImageFile));     // allowed because we have no vtable
    _eBgType = BT_IMAGEFILE;

    //---- save off partid, stateid for debugging ----
    _iSourcePartId = iPartId;
    _iSourceStateId = iStateId;

    DIBINFO *pdi = &_ImageInfo;

    pdi->iMinDpi = 96;      // only way this gets set for now

    pdi->iDibOffset = pRender->GetValueIndex(iPartId, iStateId, TMT_DIBDATA);
    if (pdi->iDibOffset == -1)      // not found
        pdi->iDibOffset = 0;
    
    //---- image-related fields ----
    if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_IMAGECOUNT, &_iImageCount)))
        _iImageCount = 1;        // default value

    if (_iImageCount < 1)        // avoid divide by zero problems
        _iImageCount = 1;

    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_IMAGELAYOUT, (int *)&_eImageLayout)))
        _eImageLayout = IL_HORIZONTAL;        // default value until we are converted

    if (pdi->iDibOffset)
    {
        //---- compute some fields from bitmap ----
        hr = SetImageInfo(pdi, pRender, iPartId, iStateId);
        if (FAILED(hr))
            goto exit;
    }

    //---- get MinSize ----
    if (FAILED(pRender->GetPosition(iPartId, iStateId, TMT_MINSIZE, (POINT *)&pdi->szMinSize)))
    {
        pdi->szMinSize.cx  = pdi->iSingleWidth;
        pdi->szMinSize.cy  = pdi->iSingleHeight;
    }
    else
    {
        AdjustSizeMin(&pdi->szMinSize, 1, 1);
    }

    //---- get TrueSizeScalingType ----
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_TRUESIZESCALINGTYPE, (int *)&_eTrueSizeScalingType)))
        _eTrueSizeScalingType = TSST_NONE;      // default
    
    //---- sizing ----
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_SIZINGTYPE, (int *)&pdi->eSizingType)))
        pdi->eSizingType = ST_STRETCH;       // default

    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_BORDERONLY, &pdi->fBorderOnly)))
        pdi->fBorderOnly = FALSE;

    if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_TRUESIZESTRETCHMARK, &_iTrueSizeStretchMark)))
        _iTrueSizeStretchMark = 0;      // default

    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_UNIFORMSIZING, &_fUniformSizing)))
        _fUniformSizing = FALSE;        // default

    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_INTEGRALSIZING, &_fIntegralSizing)))
        _fIntegralSizing = FALSE;        // default

    //---- transparency ----
    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_TRANSPARENT, &pdi->fTransparent)))
        pdi->fTransparent = FALSE;

    if (pdi->fTransparent)
    {
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_TRANSPARENTCOLOR, &pdi->crTransparent)))
            pdi->crTransparent = DEFAULT_TRANSPARENT_COLOR; 
    }

    //---- MirrorImage ----
    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_MIRRORIMAGE, &_fMirrorImage)))
        _fMirrorImage = TRUE;              // default setting

    //---- alignment ----
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_HALIGN, (int *)&_eHAlign)))
        _eHAlign = HA_CENTER;      // default value

    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_VALIGN, (int *)&_eVAlign)))
        _eVAlign = VA_CENTER;      // default value

    //---- for regular or glyph truesize images ----
    if (SUCCEEDED(pRender->GetBool(iPartId, iStateId, TMT_BGFILL, &_fBgFill)))
    {
        //---- get fill color ----
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_FILLCOLOR, &_crFill)))
            _crFill = RGB(255, 255, 255);
    }

    //---- SizingMargins ----
    if (FAILED(pRender->GetMargins(NULL, iPartId, iStateId, TMT_SIZINGMARGINS, 
        NULL, &_SizingMargins)))
    {
        _SizingMargins.cxLeftWidth = 0;
        _SizingMargins.cxRightWidth = 0;
        _SizingMargins.cyTopHeight = 0;
        _SizingMargins.cyBottomHeight = 0;
    }

    //---- ContentMargins ----
    if (FAILED(pRender->GetMargins(NULL, iPartId, iStateId, TMT_CONTENTMARGINS, 
        NULL, &_ContentMargins)))
    {
        _ContentMargins = _SizingMargins;
    }

    //---- SourceGrow ----
    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_SOURCEGROW, &_fSourceGrow)))
        _fSourceGrow = FALSE;         // default

    //---- SourceShrink ----
    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_SOURCESHRINK, &_fSourceShrink)))
        _fSourceShrink = FALSE;       // default

    //---- NormalSize ----
    if (FAILED(pRender->GetPosition(iPartId, iStateId, TMT_NORMALSIZE, (POINT *)&_szNormalSize)))
    {
        _szNormalSize.cx = 60;
        _szNormalSize.cy = 30;
    }
    else
    {
        AdjustSizeMin(&_szNormalSize, 1, 1);
    }

    //---- glphytype ----
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_GLYPHTYPE, (int *)&_eGlyphType)))
        _eGlyphType = GT_NONE;      // default value

    if (_eGlyphType == GT_FONTGLYPH)
    {
        //---- font-based glyphs ----
        if (FAILED(pRender->GetFont(NULL, iPartId, iStateId, TMT_GLYPHFONT, FALSE, &_lfGlyphFont)))
            goto exit;              // required

        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_GLYPHTEXTCOLOR, &_crGlyphTextColor)))
            _crGlyphTextColor = RGB(0, 0, 0);       // default color

        if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_GLYPHINDEX, &_iGlyphIndex)))
            _iGlyphIndex = 1;               // default index
    }
    else if (_eGlyphType == GT_IMAGEGLYPH)
    {
        //---- image-based glyphs ----
        pdi = &_GlyphInfo;

        pdi->iMinDpi = 96;      // only way this gets set for now

        pdi->iDibOffset = pRender->GetValueIndex(iPartId, iStateId, TMT_GLYPHDIBDATA);
        if (pdi->iDibOffset == -1)
            pdi->iDibOffset = 0;

        if (pdi->iDibOffset > 0)       // found 
        {
            hr = SetImageInfo(pdi, pRender, iPartId, iStateId);
            if (FAILED(hr))
                goto exit;
        }

        if (SUCCEEDED(pRender->GetBool(iPartId, iStateId, TMT_GLYPHTRANSPARENT, &pdi->fTransparent)))
        {
            if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_GLYPHTRANSPARENTCOLOR, &pdi->crTransparent)))
                pdi->crTransparent = DEFAULT_TRANSPARENT_COLOR;
        }

        pdi->eSizingType = ST_TRUESIZE;     // glyphs are always true size
        pdi->fBorderOnly = FALSE;           // glyphs are never borderonly (for now)
    }

    if (_eGlyphType != GT_NONE)
    {
        if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_GLYPHONLY, &_fGlyphOnly)))
            _fGlyphOnly = FALSE;
    }

    //---- multi files specified? ----
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_IMAGESELECTTYPE, (int *)&_eImageSelectType)))
        _eImageSelectType = IST_NONE;

    //---- fill in multi DIBINFO's ----
    if (_eImageSelectType != IST_NONE)
    {
        DIBINFO *pParent;

        if (_eGlyphType == GT_IMAGEGLYPH)
        {
            pParent = &_GlyphInfo;
        }
        else
        {
            pParent = &_ImageInfo;
        }

        for (int i=0; i < MAX_IMAGEFILE_SIZES; i++)
        {
            //---- get ImageFileN ----
            int iDibOffset = pRender->GetValueIndex(iPartId, iStateId, TMT_DIBDATA1 + i);
            if (iDibOffset == -1)
                break;

            _iMultiImageCount++;

            DIBINFO *pdi = MultiDibPtr(i);
        
            *pdi = *pParent;        // inherit some props from parent
            pdi->iDibOffset = iDibOffset;

            hr = SetImageInfo(pdi, pRender, iPartId, iStateId);
            if (FAILED(hr))
                goto exit;

            //---- get MinDpiN ----
            if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_MINDPI1 + i, &pdi->iMinDpi)))
            {
                pdi->iMinDpi = 96;     // default
            }
            else
            {
                //---- ensure value >= 1 ----
                if (pdi->iMinDpi < 1)
                {
                    pdi->iMinDpi = 1;
                }
            }

            //---- get MinSizeN ----
            if (FAILED(pRender->GetPosition(iPartId, iStateId, TMT_MINSIZE1 + i,
                (POINT *)&pdi->szMinSize)))
            {
                pdi->szMinSize.cx  = pdi->iSingleWidth;
                pdi->szMinSize.cy  = pdi->iSingleHeight;
            }
            else
            {
                AdjustSizeMin(&pdi->szMinSize, 1, 1);
            }

        }

        if (_iMultiImageCount > 0)
        {
            *pParent = *MultiDibPtr(0);     // use first multi entry as primary object
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
BOOL CImageFile::KeyProperty(int iPropId)
{
    BOOL fKey = FALSE;

    switch (iPropId)
    {
        case TMT_BGTYPE:
        case TMT_TRANSPARENT:
        case TMT_AUTOSIZE:
        case TMT_BORDERONLY:
        case TMT_IMAGECOUNT:
        case TMT_ALPHALEVEL:
        case TMT_ALPHATHRESHOLD:
        case TMT_IMAGEFILE:
        case TMT_IMAGEFILE1:
        case TMT_IMAGEFILE2:
        case TMT_IMAGEFILE3:
        case TMT_IMAGEFILE4:
        case TMT_IMAGEFILE5:
        case TMT_SIZINGMARGINS:
        case TMT_CONTENTMARGINS:
        case TMT_TRANSPARENTCOLOR:
        case TMT_SIZINGTYPE:
        case TMT_HALIGN:
        case TMT_VALIGN:
        case TMT_IMAGELAYOUT:
        case TMT_BGFILL:
        case TMT_MIRRORIMAGE:
        case TMT_TRUESIZESTRETCHMARK:
        case TMT_TRUESIZESCALINGTYPE:
        case TMT_IMAGESELECTTYPE:
        case TMT_UNIFORMSIZING:
        case TMT_INTEGRALSIZING:
        case TMT_SOURCEGROW:
        case TMT_SOURCESHRINK:
        case TMT_NORMALSIZE:
        case TMT_MINSIZE:
        case TMT_MINSIZE1:
        case TMT_MINSIZE2:
        case TMT_MINSIZE3:
        case TMT_MINSIZE4:
        case TMT_MINSIZE5:
        case TMT_MINDPI1:
        case TMT_MINDPI2:
        case TMT_MINDPI3:
        case TMT_MINDPI4:
        case TMT_MINDPI5:

        //---- glyph properties ----
        case TMT_GLYPHTYPE:
        case TMT_GLYPHIMAGEFILE:
        case TMT_GLYPHTRANSPARENT:
        case TMT_GLYPHTRANSPARENTCOLOR:
        case TMT_GLYPHFONT:
        case TMT_GLYPHINDEX:
        case TMT_GLYPHTEXTCOLOR:
        case TMT_GLYPHONLY:

        // case TMT_FILLCOLOR:  - this prop belongs to BorderFill (we borrow it)

            fKey = TRUE;
            break;
    }

    return fKey;
}
//---------------------------------------------------------------------------
DIBINFO *CImageFile::EnumImageFiles(int iIndex)
{
    DIBINFO *pdi = NULL;
    BOOL fHasGlyph = (_eGlyphType == GT_IMAGEGLYPH);

    //---- enum in this order: primary, glyph, multi images ----

    if (iIndex == 0)
    {
        pdi = &_ImageInfo;
    }
    else if (iIndex == 1)  
    {
        if (fHasGlyph)
            pdi = &_GlyphInfo;
    }

    if (! pdi)          // not yet set
    {
        if (fHasGlyph)
            iIndex -= 2;
        else
            iIndex -= 1;

        if (iIndex < _iMultiImageCount)
        {
            pdi = MultiDibPtr(iIndex);
        }
    }

    return pdi;
}
//---------------------------------------------------------------------------
void CImageFile::DumpProperties(CSimpleFile *pFile, BYTE *pbThemeData, BOOL fFullInfo)
{
    if (fFullInfo)
        pFile->OutLine(L"Dump of CImageFile at offset=0x%x", (BYTE *)this - pbThemeData);
    else
        pFile->OutLine(L"Dump of CImageFile");
    
    pFile->OutLine(L"  _eBgType=%d", _eBgType);

    DIBINFO *pdi = &_ImageInfo;

    if (fFullInfo)
    {
        pFile->OutLine(L"  iDibOffset=%d, _iImageCount=%d, _eImageLayout=%d",
            pdi->iDibOffset, _iImageCount, _eImageLayout);
    }
    else
    {
        pFile->OutLine(L"  _iImageCount=%d, _eImageLayout=%d, MinSize=(%d, %d)",
            _iImageCount, _eImageLayout, pdi->szMinSize.cx, pdi->szMinSize.cy);
    }

    pFile->OutLine(L"  _iSingleWidth=%d, _iSingleHeight=%d, _fMirrorImage=%d",
        pdi->iSingleWidth, pdi->iSingleHeight, _fMirrorImage);

    //---- dump multiple image info ----
    for (int i=0; i < _iMultiImageCount; i++)
    {
        DIBINFO *pdi = MultiDibPtr(i);

        pFile->OutLine(L"  Multi[%d]: sw=%d, sh=%d, diboff=%d, rgnoff=%d",
            i, pdi->iSingleWidth, pdi->iSingleHeight,
            (pdi->iDibOffset > 0), (pdi->iRgnListOffset > 0));

        pFile->OutLine(L"      MinDpi=%d, MinSize=(%d, %d)",
            pdi->iMinDpi, pdi->szMinSize.cx, pdi->szMinSize.cy);

        pFile->OutLine(L"    sizetype=%d, bordonly=%d, fTrans=%d, crTrans=0x%x, fAlpha=%d, iAlphaThres=%d",
            pdi->eSizingType, pdi->fBorderOnly, pdi->fTransparent, pdi->crTransparent, 
            pdi->fAlphaChannel, pdi->iAlphaThreshold);
    }

    pFile->OutLine(L"  _eSizingType=%d, _fBorderOnly=%d, _eTrueSizeScalingType=%d",
        pdi->eSizingType, pdi->fBorderOnly, _eTrueSizeScalingType);

    pFile->OutLine(L"  _fTransparent=%d, _crTransparent=0x%08x",
        pdi->fTransparent, pdi->crTransparent);

    pFile->OutLine(L"  _fAlphaChannel=%d, _iAlphaThreshold=%d",
        pdi->fAlphaChannel, pdi->iAlphaThreshold);

    pFile->OutLine(L"  _eHAlign=%d, _eVAlign=%d, _iTrueSizeStretchMark=%d",
        _eHAlign, _eVAlign, _iTrueSizeStretchMark);

    pFile->OutLine(L"  _fUniformSizing=%d, _fIntegralSizing=%d",
        _fUniformSizing, _fIntegralSizing);

    pFile->OutLine(L"  _fBgFill=%d, _crFill=0x%08x",
        _fBgFill, _crFill);

    pFile->OutLine(L"  _fSourceGrow=%d, _fSourceShrink=%d, _szNormalSize=(%d, %d)",
        _fSourceGrow, _fSourceShrink, _szNormalSize.cx, _szNormalSize.cy);

    pFile->OutLine(L"  _SizingMargins=%d, %d, %d, %d", 
        _SizingMargins.cxLeftWidth, _SizingMargins.cxRightWidth,
        _SizingMargins.cyTopHeight, _SizingMargins.cyBottomHeight);

    pFile->OutLine(L"  _ContentMargins=%d, %d, %d, %d", 
        _ContentMargins.cxLeftWidth, _ContentMargins.cxRightWidth,
        _ContentMargins.cyTopHeight, _ContentMargins.cyBottomHeight);

    pFile->OutLine(L" _fFontGlyph=%d, _iGlyphIndex=%d, _crGlyphTextColor=0x%x",
        (_eGlyphType==GT_FONTGLYPH), _iGlyphIndex, _crGlyphTextColor);

    pFile->OutLine(L" _lfGlyphFont=%s, _fGlyphOnly=%d, _fImageGlyph=%d",
        _lfGlyphFont.lfFaceName, _fGlyphOnly, (_eGlyphType==GT_IMAGEGLYPH));

    //---- dump glyph properties ----
    pdi = &_GlyphInfo;

    if (fFullInfo)
    {
        pFile->OutLine(L" Glyph: iDibOffset=%d, iSingleWidth=%d, iSingleHeight=%d",
            pdi->iDibOffset, pdi->iSingleWidth, pdi->iSingleHeight);
    }
    else
    {
        pFile->OutLine(L" _iGlyphSingleWidth=%d, _iGlyphSingleHeight=%d",
            pdi->iSingleWidth, pdi->iSingleHeight);
    }

    pFile->OutLine(L" _fGlyphTransparent=%d, _crGlyphTransparent=0x%x, _fGlyphAlpha=%d",
        pdi->fTransparent, pdi->crTransparent, pdi->fAlphaChannel);

    //pFile->OutLine(L" Glyph: iAlphaThreshold=%d", pdi->iAlphaThreshold);
}
//---------------------------------------------------------------------------
HRESULT CImageFile::SetImageInfo(DIBINFO *pdi, CRenderObj *pRender, int iPartId, int iStateId)
{
    HRESULT hr = S_OK;

    if (! pRender->_pbThemeData)
    {
        hr = E_FAIL;        
        goto exit;
    }

    TMBITMAPHEADER *pThemeBitmapHeader = NULL;

    pThemeBitmapHeader = reinterpret_cast<TMBITMAPHEADER*>(pRender->_pbThemeData + pdi->iDibOffset);
    ASSERT(pThemeBitmapHeader->dwSize == TMBITMAPSIZE);
    
    pdi->fAlphaChannel = pThemeBitmapHeader->fTrueAlpha;
    if (pdi->fAlphaChannel)
    {
        if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_ALPHATHRESHOLD, &pdi->iAlphaThreshold)))
            pdi->iAlphaThreshold = 255;
    }

    int iWidth = - 1;
    int iHeight = -1;

    if (pThemeBitmapHeader->hBitmap)
    {
        BITMAP bmInfo;
        if (GetObject(pThemeBitmapHeader->hBitmap, sizeof(bmInfo), &bmInfo))
        {
            iWidth = bmInfo.bmWidth;
            iHeight = bmInfo.bmHeight;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        BITMAPINFOHEADER* pbmInfo = BITMAPDATA(pThemeBitmapHeader);
        if (pbmInfo)
        {
            iWidth = pbmInfo->biWidth;
            iHeight = pbmInfo->biHeight;
        }
        else
        {
            hr = E_FAIL;
        }
    }

     //---- get SingleWidth/SingleHeight of bitmap ----
    if ((iWidth != -1) && (iHeight != -1))
    {
        if (_eImageLayout == IL_HORIZONTAL)
        {
            pdi->iSingleWidth = iWidth / _iImageCount;       
            pdi->iSingleHeight = iHeight;
        }
        else        // vertical
        {
            pdi->iSingleWidth = iWidth;
            pdi->iSingleHeight = iHeight / _iImageCount;       
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
BOOL CImageFile::HasRegionImageFile(DIBINFO *pdi, int *piMaxState)
{
    BOOL fGot = FALSE;

    if ((pdi->fTransparent) || (pdi->fAlphaChannel))
    {
        if (pdi->iDibOffset > 0)
        {
            fGot = TRUE;
            *piMaxState = _iImageCount;
        }
    }

    return fGot;
}
//---------------------------------------------------------------------------
void CImageFile::SetRgnListOffset(DIBINFO *pdi, int iOffset)
{
    //---- get offset to the actual jump table  ----
    pdi->iRgnListOffset = iOffset + ENTRYHDR_SIZE;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::BuildRgnData(DIBINFO *pdi, CRenderObj *pRender, int iStateId, RGNDATA **ppRgnData, 
     int *piDataLen)
{
    RESOURCE HRGN hrgn = NULL;
    RESOURCE RGNDATA *pRgnData = NULL;
    int iTotalBytes = 0;
    int iRectCount;
    DWORD len, len2;
    HBITMAP hBitmap = NULL;
    HRESULT hr = S_OK;
    BOOL fStock = FALSE;

    if ((! pdi->fAlphaChannel) && (! pdi->fTransparent))        // empty region
        goto gotit;
    
    if (pRender->_pbThemeData && pdi->iDibOffset > 0)
    {
        fStock = ((reinterpret_cast<TMBITMAPHEADER*>(pRender->_pbThemeData + pdi->iDibOffset))->hBitmap != NULL);
    }

    hr = pRender->GetBitmap(NULL, pdi->iDibOffset, &hBitmap);
    if (FAILED(hr))
        goto exit;

    int iXOffset, iYOffset;
    GetOffsets(iStateId, pdi, &iXOffset, &iYOffset);

    //---- create a region ----
    hr = CreateBitmapRgn(hBitmap, iXOffset, iYOffset, pdi->iSingleWidth, pdi->iSingleHeight,
        pdi->fAlphaChannel, pdi->iAlphaThreshold, pdi->crTransparent, 0, &hrgn);
    if (FAILED(hr))
    {
        //---- soft error - author said it was transparent but it wasn't ----
        hr = S_OK;
        goto gotit;
    }
    
    //---- extract region data ----
    len = GetRegionData(hrgn, 0, NULL);       // get required length
    if (! len)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    iRectCount = len/sizeof(RECT);     // # of rects
    len += ((sizeof(BYTE)+sizeof(BYTE))*iRectCount);        // room for grid id's for each point

    iTotalBytes = len + sizeof(RGNDATAHEADER);
    pRgnData = (RGNDATA *) new BYTE[iTotalBytes];
    len2 = GetRegionData(hrgn, len, pRgnData);
    if (! len2)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    //---- grid-ize the point values within each rect ----
    RECT  rcImage;
    SetRect( &rcImage, 0, 0, pdi->iSingleWidth, pdi->iSingleHeight ); 

    hr = pRender->PrepareRegionDataForScaling(pRgnData, &rcImage, &_SizingMargins);
    if (FAILED(hr))
        goto exit;

gotit:
    *ppRgnData = pRgnData;
    *piDataLen = iTotalBytes;

exit:

    if (hBitmap && !fStock)
    {
        pRender->ReturnBitmap(hBitmap);
    }

    if (hrgn)
        DeleteObject(hrgn);

    if (FAILED(hr))
    {
        if (pRgnData)
            delete [] pRgnData;
    }

    return hr;
}
//---------------------------------------------------------------------------
// Helper function for DrawBackgroundDS
void StreamSetSource(BYTE** pvStream, HBITMAP hbmSrc)
{
    DS_SETSOURCE* pdsSetSource = (DS_SETSOURCE*)*pvStream;
    pdsSetSource->ulCmdID = DS_SETSOURCEID;
    pdsSetSource->hbm = HandleToULong(hbmSrc);
    *pvStream += sizeof(DS_SETSOURCE);
}
//---------------------------------------------------------------------------
void StreamInit(BYTE** pvStream, HDC hdcDest, HBITMAP hbmSrc, RECTL* prcl)
{
    DS_HEADER* pdsHeader = (DS_HEADER*)*pvStream;
    pdsHeader->magic = DS_MAGIC;
    *pvStream += sizeof(DS_HEADER);

    DS_SETTARGET* pdsSetTarget = (DS_SETTARGET*)*pvStream;
    pdsSetTarget->ulCmdID = DS_SETTARGETID;
    pdsSetTarget->hdc = HandleToULong(hdcDest);
    pdsSetTarget->rclDstClip = *prcl;
    *pvStream += sizeof(DS_SETTARGET);

    StreamSetSource(pvStream, hbmSrc);
}
//---------------------------------------------------------------------------
HBITMAP CreateScaledTempBitmap(HDC hdc, HBITMAP hSrcBitmap, int ixSrcOffset, int iySrcOffset,
    int iSrcWidth, int iSrcHeight, int iDestWidth, int iDestHeight)
{
    HBITMAP hTempBitmap = NULL;

    if (hSrcBitmap)        // create a DIB from caller's bitmap (Clipper test program)
    {
        //---- reuse our bitmap ----
        hTempBitmap = g_pBitmapCacheScaled->AcquireBitmap(hdc, iDestWidth, iDestHeight);
        if (hTempBitmap)
        {
            HDC hdcDest = CreateCompatibleDC(hdc);
            if (hdcDest)
            {
                HBITMAP hOldDestBitmap = (HBITMAP)SelectObject(hdcDest, hTempBitmap);

                HDC hdcSrc = CreateCompatibleDC(hdc);
                if (hdcSrc)
                {
                    SetLayout(hdcSrc, 0);
                    SetLayout(hdcDest, 0);

                    HBITMAP hOldSrcBitmap = (HBITMAP) SelectObject(hdcSrc, hSrcBitmap);

                    int iOldSM = SetStretchBltMode(hdcDest, COLORONCOLOR);

                    //---- stretch src to dest ----
                    StretchBlt(hdcDest, 0, 0, iDestWidth, iDestHeight, 
                        hdcSrc, ixSrcOffset, iySrcOffset, iSrcWidth, iSrcHeight, 
                        SRCCOPY);

                    SetStretchBltMode(hdcDest, iOldSM);

                    SelectObject(hdcSrc, hOldSrcBitmap);
                    DeleteDC(hdcSrc);
                }

                SelectObject(hdcDest, hOldDestBitmap);
                DeleteDC(hdcDest);
            }
        }
    }

    return hTempBitmap;
}
//---------------------------------------------------------------------------
HBITMAP CreateUnscaledTempBitmap(HDC hdc, HBITMAP hSrcBitmap, int ixSrcOffset, int iySrcOffset,
    int iDestWidth, int iDestHeight)
{
    HBITMAP hTempBitmap = NULL;

    if (hSrcBitmap)        // create a DIB from caller's bitmap (Clipper test program)
    {
        //---- reuse our bitmap ----
        hTempBitmap = g_pBitmapCacheUnscaled->AcquireBitmap(hdc, iDestWidth, iDestHeight);
        if (hTempBitmap)
        {
            HDC hdcDest = CreateCompatibleDC(hdc);
            if (hdcDest)
            {
                HBITMAP hOldDestBitmap = (HBITMAP) SelectObject(hdcDest, hTempBitmap);
                
                HDC hdcSrc = CreateCompatibleDC(hdc);
                if (hdcSrc)
                {
                    SetLayout(hdcSrc, 0);
                    SetLayout(hdcDest, 0);

                    HBITMAP hOldSrcBitmap = (HBITMAP) SelectObject(hdcSrc, hSrcBitmap);

                    //---- copy src to dest ----
                    BitBlt(hdcDest, 0, 0, iDestWidth, iDestHeight, hdcSrc, ixSrcOffset, iySrcOffset, 
                        SRCCOPY);

                    SelectObject(hdcSrc, hOldSrcBitmap);
                    DeleteDC(hdcSrc);
                }

                SelectObject(hdcDest, hOldDestBitmap);
                DeleteDC(hdcDest);
            }
        }
    }

    return hTempBitmap;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::DrawBackgroundDS(DIBINFO *pdi, TMBITMAPHEADER *pThemeBitmapHeader, BOOL fStock, 
    CRenderObj *pRender, HDC hdc, int iStateId, const RECT *pRect, BOOL fForceStretch, 
    MARGINS *pmarDest, float xMarginFactor, float yMarginFactor, OPTIONAL const DTBGOPTS *pOptions)
{
    //---- bitmaps we may create ----
    HBITMAP hBitmapStock = NULL;
    HBITMAP hBitmapTempScaled = NULL;
    HBITMAP hBitmapTempUnscaled = NULL;

    //---- copy of bitmap handle to use ----
    HBITMAP hDsBitmap = NULL;
    HRESULT hr = S_OK;

    int iTempSrcWidth = pdi->iSingleWidth;
    int iTempSrcHeight = pdi->iSingleHeight;

    int iXOffset, iYOffset;
    GetOffsets(iStateId, pdi, &iXOffset, &iYOffset);

    if (pThemeBitmapHeader)    // get stock bitmap (32 bit format)
    {
        hr = pRender->GetBitmap(hdc, pdi->iDibOffset, &hBitmapStock);
        if (FAILED(hr))
            goto exit;

        hDsBitmap = hBitmapStock;
    }
    else                        // caller passed in bitmap (unknown format)
    {
        hBitmapTempUnscaled = CreateUnscaledTempBitmap(hdc, pdi->hProcessBitmap, iXOffset, iYOffset, 
            pdi->iSingleWidth, pdi->iSingleHeight);
        if (! hBitmapTempUnscaled)
        {
            hr = E_FAIL;
            goto exit;
        }

        hDsBitmap = hBitmapTempUnscaled;

        //---- src is now just a single image ----
        iXOffset = iYOffset = 0;
    }

    //---- handle scaled margins ----
    if ((xMarginFactor != 1) || (yMarginFactor != 1))  
    {
        iTempSrcWidth = int(pdi->iSingleWidth * xMarginFactor);
        iTempSrcHeight = int(pdi->iSingleHeight * yMarginFactor);

        hBitmapTempScaled = CreateScaledTempBitmap(hdc, hDsBitmap, iXOffset, iYOffset,
            pdi->iSingleWidth, pdi->iSingleHeight, iTempSrcWidth, iTempSrcHeight);
        if (! hBitmapTempScaled)
        {
            hr = E_FAIL;
            goto exit;
        }

        hDsBitmap = hBitmapTempScaled;

        //---- src is now just a single image ----
        iXOffset = iYOffset = 0;
    }

    if (hDsBitmap)
    {

        RECTL rclSrc  = { iXOffset, iYOffset, iXOffset + iTempSrcWidth, iYOffset + iTempSrcHeight };
        RECTL rclDest = { pRect->left, pRect->top, pRect->right, pRect->bottom };

        // Flip Dest Rect if someone passed us inverted co-ordinates
        if (rclDest.left > rclDest.right)
        {
            int xTemp = rclDest.left;
            rclDest.left = rclDest.right;
            rclDest.right = xTemp;
        }
        if (rclDest.top > rclDest.bottom)
        {
            int yTemp = rclDest.bottom;
            rclDest.bottom = rclDest.top;
            rclDest.top = yTemp;
        }

        DWORD dwOptionFlags = 0;
        if (pOptions)
        {
            dwOptionFlags = pOptions->dwFlags;
        }

        // Initialize Drawing Stream
        BYTE   stream[500];
        BYTE*  pvStreamStart = stream;
        BYTE*  pvStream = stream;

        RECTL  rclClip = rclDest;

        if (dwOptionFlags & DTBG_CLIPRECT)
        {
            IntersectRect((LPRECT)&rclClip, (LPRECT)&rclDest, &pOptions->rcClip);
        }

        StreamInit(&pvStream, hdc, hDsBitmap, &rclClip);

        DS_NINEGRID* pvNineGrid = (DS_NINEGRID*)pvStream;
        pvNineGrid->ulCmdID = DS_NINEGRIDID;

        if ((fForceStretch) || (pdi->eSizingType == ST_STRETCH))
        {
            pvNineGrid->ngi.flFlags = DSDNG_STRETCH;
        }
        else if (pdi->eSizingType == ST_TRUESIZE)
        {
            pvNineGrid->ngi.flFlags = DSDNG_TRUESIZE;
        }
        else 
        {
            pvNineGrid->ngi.flFlags = DSDNG_TILE;
        }

        if (pdi->fAlphaChannel)
        {
            pvNineGrid->ngi.flFlags |= DSDNG_PERPIXELALPHA;
        }
        else if (pdi->fTransparent)
        {
            pvNineGrid->ngi.flFlags |= DSDNG_TRANSPARENT;
        }

        if ((dwOptionFlags & DTBG_MIRRORDC) || (IsMirrored(hdc)))
        {
            if (_fMirrorImage)
            {
                pvNineGrid->ngi.flFlags |= DSDNG_MUSTFLIP;

                //---- workaround: needed by GdiDrawStream if we don't have a mirrored DC ----
                //---- gdi should only look at the DSDNG_MUSTFLIP flag ----
                if (! IsMirrored(hdc))
                {
                    int xTemp = rclDest.left;
                    rclDest.left = rclDest.right;
                    rclDest.right = xTemp;
                }
            }
        }

        pvNineGrid->rclDst = rclDest;
        pvNineGrid->rclSrc = rclSrc;

        if (pdi->eSizingType == ST_TRUESIZE)
        {
            pvNineGrid->ngi.ulLeftWidth    = 0;
            pvNineGrid->ngi.ulRightWidth   = 0;
            pvNineGrid->ngi.ulTopHeight    = 0;
            pvNineGrid->ngi.ulBottomHeight = 0;
        } 
        else
        {
            //---- copy scaled Src margins ----
            pvNineGrid->ngi.ulLeftWidth    = pmarDest->cxLeftWidth;
            pvNineGrid->ngi.ulRightWidth   = pmarDest->cxRightWidth;
            pvNineGrid->ngi.ulTopHeight    = pmarDest->cyTopHeight;
            pvNineGrid->ngi.ulBottomHeight = pmarDest->cyBottomHeight;
        }
        
        pvNineGrid->ngi.crTransparent  = pdi->crTransparent;

        pvStream += sizeof(DS_NINEGRID);

        GdiDrawStream(hdc, (int)(pvStream - pvStreamStart), (char*) pvStreamStart);

    }
    else
    {
        hr = E_FAIL;
    }

exit:
    //---- clean up temp bitmaps ----
    if (hBitmapTempScaled)
    {
        g_pBitmapCacheScaled->ReturnBitmap();
    }

    if (hBitmapTempUnscaled)
    {
        g_pBitmapCacheUnscaled->ReturnBitmap();
    }

    if ((hBitmapStock) && (! fStock))       // not really stock (was "create on demand")
    {
        pRender->ReturnBitmap(hBitmapStock);
    }

    return hr;
}
//---------------------------------------------------------------------------
DIBINFO *CImageFile::SelectCorrectImageFile(CRenderObj *pRender, HDC hdc, OPTIONAL const RECT *prc, 
    BOOL fForGlyph, OPTIONAL TRUESTRETCHINFO *ptsInfo)
{
    DIBINFO *pdiDefault = (fForGlyph) ? &_GlyphInfo : &_ImageInfo;
    DIBINFO *pdi = NULL;
    BOOL fForceRectSizing = FALSE;
    int iWidth = 1;      
    int iHeight = 1;    

    //---- do we need a screen dc? ----
    BOOL fReleaseDC = FALSE;
    if (! hdc)
    {
        hdc = GetWindowDC(NULL);
        if (hdc)
            fReleaseDC = TRUE;
    }

    if (prc)
    {
        iWidth = WIDTH(*prc);
        iHeight = HEIGHT(*prc);
    }

    //---- see if our clients wants to force a TRUESIZE to stretch ----
    if ((fForGlyph) || (_ImageInfo.eSizingType == ST_TRUESIZE))
    {   
        if ((pRender) && (pRender->_dwOtdFlags & OTD_FORCE_RECT_SIZING))
        {
            fForceRectSizing = TRUE;
        }
    }

    //---- find correct file by DPI or Size ----
    if ((fForGlyph) || (_eGlyphType != GT_IMAGEGLYPH))   // match multifiles to reg or glyph 
    {
        BOOL fSizing = FALSE;
        BOOL fDpi = FALSE;

        if ((fForceRectSizing) || (_eImageSelectType == IST_SIZE) || (_fSourceGrow))
        {
            if (prc)
                fSizing = TRUE;
        }
        else 
        {
            fDpi = (_eImageSelectType == IST_DPI);
        }

        if (fDpi)               // DPI-based image selection
        {
            int iMinDestDpi = __min(GetDeviceCaps(hdc, LOGPIXELSX), GetDeviceCaps(hdc, LOGPIXELSY));

            //---- search from largest to smallest ----
            for (int i=_iMultiImageCount-1; i >= 0; i--)
            {
                if (MultiDibPtr(i)->iMinDpi <= iMinDestDpi)     // got him
                {
                    pdi = MultiDibPtr(i);
                    break;
                }
            }
        }
        else if (fSizing)       // Sizing-base image selection
        {
            if (_iMultiImageCount)
            {
                //---- search from largest to smallest ----
                for (int i=_iMultiImageCount-1; i >= 0; i--)
                {
                    DIBINFO *pdii = MultiDibPtr(i);
                    if ((pdii->szMinSize.cx <= iWidth) && (pdii->szMinSize.cy <= iHeight))
                    {
                        pdi = pdii;
                        break;
                    }
                }
            }
        }
    }

    if (! pdi)      // no match found
    {
        pdi = pdiDefault;
    }

    //---- determine drawing size of selected file (MultiImage or regular) ----
    if (ptsInfo)       
    {
        ptsInfo->fForceStretch = FALSE;   
        ptsInfo->fFullStretch = FALSE;

        ptsInfo->szDrawSize.cx = 0;
        ptsInfo->szDrawSize.cy = 0;

        //---- this sizing only applies to TRUESIZE images ----
        if ((pdi->eSizingType == ST_TRUESIZE) && (_eTrueSizeScalingType != TSST_NONE))
        {
            if (prc)
            {
                //---- force an exact stretch match? ----
                if ((fForceRectSizing) || (pdi->iSingleWidth > iWidth) || (pdi->iSingleHeight > iHeight))
                {
                    //---- either Forced to stretch by caller or image is too big for dest RECT ----
                    ptsInfo->fForceStretch = TRUE;
                    ptsInfo->fFullStretch = TRUE;

                    ptsInfo->szDrawSize.cx = iWidth;
                    ptsInfo->szDrawSize.cy = iHeight;
                }
            }

            if (! ptsInfo->fForceStretch)       // keep trying..
            {
                //---- see if image is too small for dest RECT ---
                SIZE szTargetSize = {0, 0};
                
                if (_eTrueSizeScalingType == TSST_DPI)
                {
                    int ixDpiDc = GetDeviceCaps(hdc, LOGPIXELSX);
                    int iyDpiDc = GetDeviceCaps(hdc, LOGPIXELSY);
                    
                    szTargetSize.cx = MulDiv(pdi->iSingleWidth, ixDpiDc, pdi->iMinDpi);
                    szTargetSize.cy = MulDiv(pdi->iSingleHeight, iyDpiDc, pdi->iMinDpi);
                }
                else if ((_eTrueSizeScalingType == TSST_SIZE) && (prc))
                {
                    szTargetSize.cx = MulDiv(pdi->iSingleWidth, iWidth, pdi->szMinSize.cx);
                    szTargetSize.cy = MulDiv(pdi->iSingleHeight, iHeight, pdi->szMinSize.cy);
                }

                if (szTargetSize.cx)        // was set
                {
                    //---- clip targetsize against dest rect ----
                    if (prc)
                    {
                        szTargetSize.cx = __min(szTargetSize.cx, iWidth);
                        szTargetSize.cy = __min(szTargetSize.cy, iHeight);
                    }

                    int ixPercentExceed = 100*(szTargetSize.cx - pdi->iSingleWidth)/pdi->iSingleWidth;
                    int iyPercentExceed = 100*(szTargetSize.cy - pdi->iSingleHeight)/pdi->iSingleHeight;

                    if ((ixPercentExceed >= _iTrueSizeStretchMark) && (iyPercentExceed >= _iTrueSizeStretchMark))
                    {
                        ptsInfo->fForceStretch = TRUE;
                        ptsInfo->szDrawSize = szTargetSize;
                    }
                }
            }
        }
    }

    if (! pdi)
    {
        pdi = pdiDefault;
    }

    if (fReleaseDC)
    {
        ReleaseDC(NULL, hdc);
    }

    return pdi;
}
//---------------------------------------------------------------------------
void CImageFile::GetDrawnImageSize(DIBINFO *pdi, const RECT *pRect, TRUESTRETCHINFO *ptsInfo,
    SIZE *pszDraw)
{
    //---- szDraw is the size image will be drawn to ----
    if (pdi->eSizingType == ST_TRUESIZE)        
    {
        if (ptsInfo->fForceStretch) 
        {
            *pszDraw = ptsInfo->szDrawSize;

            //---- integral sizing (stretched truesize only) ----
            if ((_fIntegralSizing) && (! ptsInfo->fFullStretch))
            {
                float flFactX = float(ptsInfo->szDrawSize.cx)/pdi->iSingleWidth;
                float flFactY = float(ptsInfo->szDrawSize.cy)/pdi->iSingleHeight;

                //---- cast float's to int to get lowest int (vs. rounded) ----
                pszDraw->cx = pdi->iSingleWidth * int(flFactX);
                pszDraw->cy = pdi->iSingleHeight * int(flFactY);
            }
        }
        else        // use original image size
        {
            pszDraw->cx = pdi->iSingleWidth;
            pszDraw->cy = pdi->iSingleHeight;
        }

        //---- Uniform Sizing ----
        if (_fUniformSizing)
        {
            int iSingleWidth = pdi->iSingleWidth;
            int iSingleHeight = pdi->iSingleHeight;

            double fact1 = double(pszDraw->cx)/iSingleWidth;
            double fact2 = double(pszDraw->cy)/iSingleHeight;

            //---- select the smallest factor to use for both dims ----
            if (fact1 < fact2)
            {
                pszDraw->cy = int(iSingleHeight*fact1);
            }
            else if (fact1 > fact2)
            {
                pszDraw->cx = int(iSingleWidth*fact2);
            }
        }
    }
    else        // ST_TILE or ST_STRETCH: pRect determines size
    {
        if (pRect)
        {
            pszDraw->cx = WIDTH(*pRect);
            pszDraw->cy = HEIGHT(*pRect);
        }
        else        // void function so just return 0
        {
            pszDraw->cx = 0;
            pszDraw->cy = 0;
        }
    }
}
//---------------------------------------------------------------------------
HRESULT CImageFile::DrawImageInfo(DIBINFO *pdi, CRenderObj *pRender, HDC hdc, int iStateId,
    const RECT *pRect, const DTBGOPTS *pOptions, TRUESTRETCHINFO *ptsInfo)
{
    HRESULT hr = S_OK;
    TMBITMAPHEADER *pThemeBitmapHeader = NULL;
    BOOL fStock = FALSE;
    RECT rcLocal;
    DWORD dwFlags;
    SIZE szDraw;
    BOOL fRectFilled;
    MARGINS marDest;
    float xFactor;
    float yFactor;

    if (pOptions)
        dwFlags = pOptions->dwFlags;
    else
        dwFlags = 0;

    //---- validate bitmap header ----
    if (! pdi->hProcessBitmap)      // regular, section based DIB
    {
        if (pRender->_pbThemeData && pdi->iDibOffset > 0)
        {
            pThemeBitmapHeader = reinterpret_cast<TMBITMAPHEADER*>(pRender->_pbThemeData + pdi->iDibOffset);
            ASSERT(pThemeBitmapHeader->dwSize == TMBITMAPSIZE);
            fStock = (pThemeBitmapHeader->hBitmap != NULL);
        }

        if (!pRender->IsReady())
        {
            // Stock bitmaps in section are cleaning, don't try to paint with an old HBITMAP
            hr = E_FAIL;
            //Log(LOG_TMBITMAP, L"Obsolete theme section: class=%s", SHARECLASS(pRender));
            goto exit;
        }

        if (pThemeBitmapHeader == NULL)
        {
            hr = E_FAIL;
            Log(LOG_ALWAYS, L"No TMBITMAPHEADER: class=%s, hr=0x%x", SHARECLASS(pRender), hr);
            goto exit;
        }
    }

    //----- set szDraw to size image will be drawn at ----
    GetDrawnImageSize(pdi, pRect, ptsInfo, &szDraw);

    rcLocal = *pRect;
    fRectFilled = TRUE;

    //---- horizontal alignment ----
    if (WIDTH(rcLocal) > szDraw.cx)
    {
        fRectFilled = FALSE;

        if (_eHAlign == HA_LEFT)
        {
            rcLocal.right = rcLocal.left + szDraw.cx;
        }
        else if (_eHAlign == HA_CENTER)
        {
            rcLocal.left += (WIDTH(rcLocal) - szDraw.cx) / 2;
            rcLocal.right = rcLocal.left + szDraw.cx;
        }
        else
        {
            rcLocal.left = rcLocal.right - szDraw.cx;
        }
    }

    //---- vertical alignment ----
    if (HEIGHT(rcLocal) > szDraw.cy)
    {
        fRectFilled = FALSE;

        if (_eVAlign == VA_TOP)
        {
            rcLocal.bottom = rcLocal.top + szDraw.cy;
        }
        else if (_eVAlign == VA_CENTER)
        {
            rcLocal.top += (HEIGHT(rcLocal) - szDraw.cy) / 2;
            rcLocal.bottom = rcLocal.top + szDraw.cy;
        }
        else
        {
            rcLocal.top = rcLocal.bottom - szDraw.cy;
        }
    }

    //---- BgFill ----
    if ((! fRectFilled) && (! pdi->fBorderOnly) && (_fBgFill))
    {
        if (! (dwFlags & DTBG_OMITCONTENT))
        {
            //---- paint bg ----
            HBRUSH hbr = CreateSolidBrush(_crFill);
            if (! hbr)
            {
                hr = GetLastError();
                goto exit;
            }

            FillRect(hdc, pRect, hbr);
            DeleteObject(hbr);
        }
    }

    //---- calculate source/margin scaling factors ----
    marDest = _SizingMargins;

    if (pdi->eSizingType == ST_TRUESIZE)        // sizing margins ignored - no scaling needed
    {
        xFactor = 1;
        yFactor = 1;
    }
    else    
    {
        //---- scale destination sizing margins ----
        ScaleMargins(&marDest, hdc, pRender, pdi, &szDraw, &xFactor, &yFactor);
    }
        
    //---- new GDI drawing ----
    hr = DrawBackgroundDS(pdi, pThemeBitmapHeader, fStock, pRender, hdc, iStateId, &rcLocal, 
        ptsInfo->fForceStretch, &marDest, xFactor, yFactor, pOptions);

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::DrawBackground(CRenderObj *pRender, HDC hdc, int iStateId,
    const RECT *pRect, OPTIONAL const DTBGOPTS *pOptions)
{
    HRESULT hr = S_OK;
    TRUESTRETCHINFO tsInfo;

    if (! _fGlyphOnly)
    {
        DIBINFO *pdi = SelectCorrectImageFile(pRender, hdc, pRect, FALSE, &tsInfo);

        //---- draw normal image ----
        hr = DrawImageInfo(pdi, pRender, hdc, iStateId, pRect, pOptions, &tsInfo);
    }

    //---- draw glyph, if needed ----
    if (SUCCEEDED(hr) && (_eGlyphType != GT_NONE))
    {
        RECT rc;
        hr = GetBackgroundContentRect(pRender, hdc, pRect, &rc);
        if (SUCCEEDED(hr))
        {
            if (_eGlyphType == GT_FONTGLYPH)
            {
                hr = DrawFontGlyph(pRender, hdc, &rc, pOptions);
            }
            else
            {
                DIBINFO *pdi = SelectCorrectImageFile(pRender, hdc, &rc, TRUE, &tsInfo);

                //---- draw glyph image ----
                hr = DrawImageInfo(pdi, pRender, hdc, iStateId, &rc, pOptions, &tsInfo);
            }
        }
    }

    return hr;
}

//---------------------------------------------------------------------------
HRESULT CImageFile::DrawFontGlyph(CRenderObj *pRender, HDC hdc, RECT *prc, 
    OPTIONAL const DTBGOPTS *pOptions)
{
    HRESULT hr = S_OK;
    DWORD dwFlags = DT_SINGLELINE;
    HFONT hFont = NULL;
    HFONT hOldFont = NULL;
    COLORREF crOld = 0;
    CSaveClipRegion scrOrig;
    int iOldMode = 0;
    WCHAR szText[2] = { (WCHAR)_iGlyphIndex, 0 };

    //---- options ----
    DWORD dwOptionFlags = 0;
    const RECT *pClipRect = NULL;

    if (pOptions)
    {
        dwOptionFlags = pOptions->dwFlags;

        if (dwOptionFlags & DTBG_CLIPRECT)
            pClipRect = &pOptions->rcClip;
    }

    //---- create the font ----
    hr = pRender->GetScaledFontHandle(hdc, &_lfGlyphFont, &hFont);
    if (FAILED(hr))
        goto exit;

    //---- make it active ----
    hOldFont = (HFONT)SelectObject(hdc, hFont);
    if (! hOldFont)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    //---- set the text color ----
    crOld = SetTextColor(hdc, _crGlyphTextColor);

    //---- draw text with transparent background ----
    iOldMode = SetBkMode(hdc, TRANSPARENT);

    //---- set the HORZ alignment flags ----
    if (_eHAlign == HA_LEFT)
        dwFlags |= DT_LEFT;
    else if (_eHAlign == HA_CENTER)
        dwFlags |= DT_CENTER;
    else
        dwFlags |= DT_RIGHT;

    //---- set the VERT alignment flags ----
    if (_eVAlign == VA_TOP)
        dwFlags |= DT_TOP;
    else if (_eVAlign == VA_CENTER)
        dwFlags |= DT_VCENTER;
    else
        dwFlags |= DT_BOTTOM;

    //---- add clipping ----
    if (pClipRect)      
    {
        //---- get previous clipping region (for restoring at end) ----
        hr = scrOrig.Save(hdc);
        if (FAILED(hr))
            goto exit;

        //---- add "pClipRect" to the GDI clipping region ----
        int iRetVal = IntersectClipRect(hdc, pClipRect->left, pClipRect->top,
            pClipRect->right, pClipRect->bottom);
        if (iRetVal == ERROR)
        {
            hr = MakeErrorLast();
            goto exit;
        }
    }

    //---- draw the char ----
    if (! DrawTextEx(hdc, szText, 1, prc, dwFlags, NULL))
    {
        hr = MakeErrorLast();
        goto exit;
    }

exit:

    if (pClipRect)
        scrOrig.Restore(hdc);

    //---- reset the background mode ----
    if (iOldMode != TRANSPARENT)
        SetBkMode(hdc, iOldMode);

    //---- restore text color ----
    if (crOld != _crGlyphTextColor)
        SetTextColor(hdc, crOld);

    //---- restore font ----
    if (hOldFont)
        SelectObject(hdc, hOldFont);

    if (hFont)
        pRender->ReturnFontHandle(hFont);

    return hr;
}
//---------------------------------------------------------------------------
BOOL CImageFile::IsBackgroundPartiallyTransparent(int iStateId)
{
    DIBINFO *pdi = &_ImageInfo;     // primary image determines transparency

    return ((pdi->fAlphaChannel) || (pdi->fTransparent));
}
//---------------------------------------------------------------------------
HRESULT CImageFile::HitTestBackground(CRenderObj *pRender, OPTIONAL HDC hdc, int iStateId, 
    DWORD dwHTFlags, const RECT *pRect, HRGN hrgn, POINT ptTest, OUT WORD *pwHitCode)
{
    *pwHitCode = HTNOWHERE;

    if (! PtInRect(pRect, ptTest))
        return S_OK;    // nowhere

    //---- background might have transparent parts - get its region ----
    HRESULT hr = S_OK;
    HRGN    hrgnBk = NULL;

    if( !hrgn && IsBackgroundPartiallyTransparent(iStateId) )
    {
        hr = GetBackgroundRegion(pRender, hdc, iStateId, pRect, &hrgnBk);
        if( SUCCEEDED(hr) )
            hrgn = hrgnBk;
    }

    MARGINS margins;
    if( TESTFLAG(dwHTFlags, HTTB_SYSTEMSIZINGMARGINS) && 
        TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER) &&
        !TESTFLAG(dwHTFlags, HTTB_SIZINGTEMPLATE) )
    {
        ZeroMemory( &margins, sizeof(margins) );

        int cxBorder = ClassicGetSystemMetrics( SM_CXSIZEFRAME );
        int cyBorder = ClassicGetSystemMetrics( SM_CXSIZEFRAME );

        if( TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_LEFT) )
            margins.cxLeftWidth = cxBorder;

        if( TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_RIGHT) )
            margins.cxRightWidth = cxBorder;

        if( TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_TOP) )
            margins.cyTopHeight = cyBorder;

        if( TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_BOTTOM) )
            margins.cyBottomHeight = cyBorder;
    }
    else
    {
        hr = GetScaledContentMargins(pRender, hdc, pRect, &margins);
        if (FAILED(hr))
            goto exit;
    }

    if( hrgn )
    {
        //  122013 - we originally delegated to a sophisticated but broken
        //           resizing area region hit test algorithm for regioned windows,
        //           but for whistler we'll just do the bounding
        //           rectangle thang instead.
        //*pwHitCode = HitTestRgn( dwHTFlags, pRect, hrgn, margins, ptTest );

        RECT rcRgn;
        if( GetRgnBox( hrgn, &rcRgn ) )
        {
            if( TESTFLAG(dwHTFlags, HTTB_SIZINGTEMPLATE) )
            {
                *pwHitCode = HitTestTemplate( dwHTFlags, &rcRgn, hrgn, margins, ptTest );
            }
            else
            {
                *pwHitCode = HitTestRect( dwHTFlags, &rcRgn, margins, ptTest );
            }
        }
        SAFE_DELETE_GDIOBJ(hrgnBk);
    }
    else
    {
        *pwHitCode = HitTestRect( dwHTFlags, pRect, margins, ptTest );
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::GetBackgroundRegion(CRenderObj *pRender, OPTIONAL HDC hdc, int iStateId,
    const RECT *pRect, HRGN *pRegion)
{
    HRESULT hr = S_OK;
    RGNDATA *pRgnData;
    CMemoryDC hdcMemory;
    HRGN hrgn;
    int iRgnDataOffset = 0;
    MIXEDPTRS u;

    DIBINFO *pdi = SelectCorrectImageFile(pRender, hdc, pRect, FALSE);

    //---- get rgndata offset ----
    if ((pdi->iRgnListOffset) && (pRender->_pbThemeData))
    {
        u.pb = pRender->_pbThemeData + pdi->iRgnListOffset;
        int iMaxState = (*u.pb++) - 1;
        if (iStateId > iMaxState)
            iStateId = 0;
        iRgnDataOffset = u.pi[iStateId];
    }

    //---- see if it even has a transparent part ----
    if (iRgnDataOffset)
    {
        //---- stretch those puppies & create a new region ----
        pRgnData = (RGNDATA *)(pRender->_pbThemeData + iRgnDataOffset 
            + sizeof(RGNDATAHDR) + ENTRYHDR_SIZE);

        SIZE szSrcImage = {pdi->iSingleWidth, pdi->iSingleHeight};

        hr = _ScaleRectsAndCreateRegion(pRgnData, pRect, &_SizingMargins, &szSrcImage, &hrgn);

        if (FAILED(hr))
            goto exit;
    }
    else
    {
        //---- return the bounding rect as the region ----
        hrgn = CreateRectRgn(pRect->left, pRect->top,
            pRect->right, pRect->bottom);

        if (! hrgn)
        {
            hr = MakeErrorLast();
            goto exit;
        }
    }

    *pRegion = hrgn;

exit:
    return hr;
}  
//---------------------------------------------------------------------------
HRESULT CImageFile::GetBackgroundContentRect(CRenderObj *pRender, OPTIONAL HDC hdc, 
    const RECT *pBoundingRect, RECT *pContentRect)
{
    MARGINS margins;
    HRESULT hr = GetScaledContentMargins(pRender, hdc, pBoundingRect, &margins);
    if (FAILED(hr))
        goto exit;

    pContentRect->left = pBoundingRect->left + margins.cxLeftWidth;
    pContentRect->top = pBoundingRect->top + margins.cyTopHeight;

    pContentRect->right = pBoundingRect->right - margins.cxRightWidth;
    pContentRect->bottom = pBoundingRect->bottom - margins.cyBottomHeight;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::GetBackgroundExtent(CRenderObj *pRender, OPTIONAL HDC hdc, 
    const RECT *pContentRect, RECT *pExtentRect)
{
    MARGINS margins;
    HRESULT hr = GetScaledContentMargins(pRender, hdc, pContentRect, &margins);
    if (FAILED(hr))
        goto exit;

    pExtentRect->left = pContentRect->left - margins.cxLeftWidth;
    pExtentRect->top = pContentRect->top-+ margins.cyTopHeight;

    pExtentRect->right = pContentRect->right + margins.cxRightWidth;
    pExtentRect->bottom = pContentRect->bottom + margins.cyBottomHeight;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::GetScaledContentMargins(CRenderObj *pRender, OPTIONAL HDC hdc, 
    OPTIONAL const RECT *prcDest, MARGINS *pMargins)
{
    HRESULT hr = S_OK;
    *pMargins = _ContentMargins;

    //---- now scale the margins ----
    SIZE szDraw;
    TRUESTRETCHINFO tsInfo;

    DIBINFO *pdi = SelectCorrectImageFile(pRender, hdc, prcDest, FALSE, NULL);
    
    GetDrawnImageSize(pdi, prcDest, &tsInfo, &szDraw);

    hr = ScaleMargins(pMargins, hdc, pRender, pdi, &szDraw);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::GetPartSize(CRenderObj *pRender, HDC hdc, OPTIONAL const RECT *prc, 
    THEMESIZE eSize, SIZE *psz)
{
    HRESULT hr = S_OK;
    TRUESTRETCHINFO tsInfo;

    DIBINFO *pdi = SelectCorrectImageFile(pRender, hdc, prc, FALSE, &tsInfo);

    if (eSize == TS_MIN)
    {
        MARGINS margins;
        hr = GetScaledContentMargins(pRender, hdc, prc, &margins);
        if (FAILED(hr))
            goto exit;

        psz->cx = max(1, margins.cxLeftWidth + margins.cxRightWidth);
        psz->cy = max(1, margins.cyTopHeight + margins.cyBottomHeight);
    }
    else if (eSize == TS_TRUE)
    {
        psz->cx = pdi->iSingleWidth;
        psz->cy = pdi->iSingleHeight;
    }
    else if (eSize == TS_DRAW)
    {
        GetDrawnImageSize(pdi, prc, &tsInfo, psz);
    }
    else
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

exit:
    return hr;
} 
//---------------------------------------------------------------------------
HRESULT CImageFile::GetBitmap(CRenderObj *pRender, HDC hdc, const RECT *prc, HBITMAP *phBitmap)
{
    int iStockDibOffset = pRender->GetValueIndex(_iSourcePartId, _iSourceStateId, TMT_STOCKDIBDATA);
    if (iStockDibOffset > 0)
    {
        return pRender->GetBitmap(NULL, iStockDibOffset, phBitmap);
    }
    else
    {
        return E_INVALIDARG;
    }
}
//---------------------------------------------------------------------------
void CImageFile::GetOffsets(int iStateId, DIBINFO *pdi, int *piXOffset, int *piYOffset)
{
    if (_eImageLayout == IL_HORIZONTAL)
    {
        //---- iStateId in the image index ----
        if ((iStateId <= 0) || (iStateId > _iImageCount))
            *piXOffset = 0;
        else
            *piXOffset = (iStateId-1) * (pdi->iSingleWidth);

        *piYOffset = 0;
    }
    else        // vertical
    {
        //---- iStateId in the image index ----
        if ((iStateId <= 0) || (iStateId > _iImageCount))
            *piYOffset = 0;
        else
            *piYOffset = (iStateId-1) * (pdi->iSingleHeight);

        *piXOffset = 0;
    }

}
//---------------------------------------------------------------------------
HRESULT CImageFile::ScaleMargins(IN OUT MARGINS *pMargins, HDC hdcOrig, CRenderObj *pRender, 
    DIBINFO *pdi, const SIZE *pszDraw, OPTIONAL float *pfx, OPTIONAL float *pfy)
{
    HRESULT hr = S_OK;
    COptionalDC hdc(hdcOrig);
    BOOL fForceRectSizing = FALSE;

    if ((pRender) && (pRender->_dwOtdFlags & OTD_FORCE_RECT_SIZING))
    {
        fForceRectSizing = TRUE;
    }

    float xFactor = 1;
    float yFactor = 1;

    //---- any margins to size? ----
    if ((pMargins->cxLeftWidth) || (pMargins->cxRightWidth) || (pMargins->cyBottomHeight)
                   || (pMargins->cyTopHeight))
    {
        if ((pszDraw->cx > 0) && (pszDraw->cy > 0))
        {
            BOOL fxNeedScale = FALSE;
            BOOL fyNeedScale = FALSE;

            //---- scale if dest rect is too small in one dimension ----
            if ((_fSourceShrink) || (fForceRectSizing))
            {
                if (pszDraw->cx < pdi->szMinSize.cx) 
                {
                    fxNeedScale = TRUE;
                }

                if (pszDraw->cy < pdi->szMinSize.cy) 
                {
                    fyNeedScale = TRUE;
                }
            }

            if ((_fSourceGrow) || (fForceRectSizing))
            {
                if ((! fxNeedScale) && (! fyNeedScale))
                {
                    //---- calculate our Dest DPI ----
                    int iDestDpi;

                    if (fForceRectSizing)   
                    {
                        iDestDpi = (pRender) ? (pRender->GetDpiOverride()) : 0;

                        if (! iDestDpi)
                        {
                            //---- make up a DPI based on sizes (IE will pass us the actual DPI soon) ----
                            int ixFakeDpi = MulDiv(pdi->iMinDpi, pszDraw->cx, _szNormalSize.cx);
                            int iyFakeDpi = MulDiv(pdi->iMinDpi, pszDraw->cy, _szNormalSize.cy);

                            iDestDpi = (ixFakeDpi + iyFakeDpi)/2;
                        }
                    }
                    else
                    {
                        iDestDpi = GetDeviceCaps(hdc, LOGPIXELSX);
                    }

                    //---- scale source/margins by Dest DPI ----
                    if (iDestDpi >= 2*pdi->iMinDpi)     
                    {
                        xFactor *= iDestDpi/pdi->iMinDpi;
                        yFactor *= iDestDpi/pdi->iMinDpi;

                    }
                }
            }

            //---- scale by ratio of our image to draw size ----
            if (fxNeedScale)
            {
                xFactor *= float(pszDraw->cx)/float(_szNormalSize.cx);
            }

            if (fyNeedScale)
            {
                yFactor *= float(pszDraw->cy)/float(_szNormalSize.cy);
            }
        }

        //---- use smallest factor for both ----
        if (xFactor < yFactor)
        {
            yFactor = xFactor;
        }
        else if (yFactor < xFactor)
        {
            xFactor = yFactor;
        }

        //---- integer truncation ----
        if (xFactor > 1.0)
        {
            xFactor = float(int(xFactor));
        }

        if (yFactor > 1.0)
        {
            yFactor = float(int(yFactor));
        }

        //---- scale the margin values ----
        if (xFactor != 1)
        {
            pMargins->cxLeftWidth = ROUND(xFactor*pMargins->cxLeftWidth);
            pMargins->cxRightWidth = ROUND(xFactor*pMargins->cxRightWidth);
        }

        if (yFactor != 1)
        {
            pMargins->cyTopHeight = ROUND(yFactor*pMargins->cyTopHeight);
            pMargins->cyBottomHeight = ROUND(yFactor*pMargins->cyBottomHeight);
        }
    }

    //---- return factors to interested callers ----
    if (pfx)
    {
        *pfx = xFactor;
    }

    if (pfy)
    {
        *pfy = yFactor;
    }

    return hr;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\info.h ===
//---------------------------------------------------------------------------
//  Info.h - implements the information services of the CRenderObj object
//---------------------------------------------------------------------------
#ifndef _INFO_H
#define _INFO_H

#include <loader.h>
//---------------------------------------------------------------------------
class CRenderObj;       // forward
//---------------------------------------------------------------------------
HRESULT GetHwndThemeFile(HWND hwnd, LPCWSTR pszClassIdList, 
    CUxThemeFile **ppThemeFile);

HRESULT MatchThemeClass(LPCTSTR pszAppName, LPCTSTR pszClassId, 
    CUxThemeFile *pThemeFile, int *piOffset, int *piClassNameOffset);

HRESULT MatchThemeClassList(HWND hwnd, LPCTSTR pstClassIdList, 
    CUxThemeFile *pThemeFile, int *piOffset, int *piClassNameOffset);

HTHEME _OpenThemeDataFromFile(HTHEMEFILE hLoadedThemeFile, HWND hwnd, LPCWSTR pszClassList, DWORD dwFlags);

HTHEME _OpenThemeData(HWND hwnd, LPCWSTR pszClassIdList, DWORD dwFlags);

HRESULT _ApplyTheme(CUxThemeFile *pThemeFile, DWORD dwApplyFlags,
    OPTIONAL LPCWSTR pszTargetApp, OPTIONAL HWND hwndTarget);

HRESULT _OpenThemeFileFromData(CRenderObj *pRender, HTHEMEFILE *phThemeFile);

void ClearExStyleBits(HWND hwnd);
//---------------------------------------------------------------------------
BOOL EnumProcessWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam);
void WindowDump(LPCWSTR pszWhere);
//---------------------------------------------------------------------------
inline THEMEMETRICS *GetThemeMetricsPtr(CUxThemeFile *pThemeFile)
{
    THEMEHDR *hdr = (THEMEHDR *)(pThemeFile->_pbThemeData);
    return (THEMEMETRICS *)(pThemeFile->_pbThemeData + hdr->iSysMetricsOffset + ENTRYHDR_SIZE);
}
//---------------------------------------------------------------------------
#endif // _INFO_H
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\imagefile.h ===
//---------------------------------------------------------------------------
//  ImageFile.h - implements the drawing API for bgtype = ImageFile
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "DrawBase.h"
//---------------------------------------------------------------------------
#define MAX_IMAGEFILE_SIZES 5
//---------------------------------------------------------------------------
struct TMBITMAPHEADER;     // forward
//---------------------------------------------------------------------------
struct DIBINFO        // used for all dibs in an CImageFile object
{
    //---- the bits ----
    int iDibOffset;             // for DIB's in section
    HBITMAP hProcessBitmap;     // for process-specific objects

    //---- size of a single, state image ----
    int iSingleWidth;
    int iSingleHeight;

    //---- custom region data ----
    int iRgnListOffset;

    //---- stretching/sizing ----
    SIZINGTYPE eSizingType;
    BOOL fBorderOnly;

    //---- transparency ----
    BOOL fTransparent;
    COLORREF crTransparent;

    //---- alpha ----
    BOOL fAlphaChannel;
    int iAlphaThreshold;

    //---- usage info ----
    int iMinDpi;
    SIZE szMinSize;
};
//---------------------------------------------------------------------------
struct TRUESTRETCHINFO
{
    BOOL fForceStretch;     // forcing a TRUE SIZE image to be stretched
    BOOL fFullStretch;      // stretch to fill entire dest RECT
    SIZE szDrawSize;        // size to stretch image to
};
//---------------------------------------------------------------------------
//    Note: draw objects like CImageFile cannot have virtual methods
//          since they reside in the shared memory map file.
//---------------------------------------------------------------------------
class CImageFile : public CDrawBase
{
public:
    //---- load-time methods ----
    static BOOL KeyProperty(int iPropId);

    DIBINFO *EnumImageFiles(int iIndex);

    void DumpProperties(CSimpleFile *pFile, BYTE *pbThemeData, BOOL fFullInfo);

    BOOL HasRegionImageFile(DIBINFO *pdi, int *piMaxState);

    BOOL ImageUsesBrushes(DIBINFO *pdi, int *piBrushCount);

    void SetRgnListOffset(DIBINFO *pdi, int iOffset);

    HRESULT BuildRgnData(DIBINFO *pdi, CRenderObj *pRender, int iStateId,
        RGNDATA **ppRgnData, int *piDataLen);

    //---- draw-time methods ----
    HRESULT DrawBackground(CRenderObj *pRender, HDC hdc, int iStateId, const RECT *pRect, 
        OPTIONAL const DTBGOPTS *pOptions);

    BOOL IsBackgroundPartiallyTransparent(int iStateId);

    HRESULT HitTestBackground(CRenderObj *pRender, OPTIONAL HDC hdc, 
        int iStateId, DWORD dwHTFlags, const RECT *pRect, HRGN hrgn, 
        POINT ptTest, OUT WORD *pwHitCode);

    HRESULT GetBackgroundRegion(CRenderObj *pRender, OPTIONAL HDC hdc, int iStateId, 
        const RECT *pRect, HRGN *pRegion);

    HRESULT GetBackgroundContentRect(CRenderObj *pRender, OPTIONAL HDC hdc,
        const RECT *pBoundingRect, RECT *pContentRect);

    HRESULT GetBackgroundExtent(CRenderObj *pRender, OPTIONAL HDC hdc, 
        const RECT *pContentRect, RECT *pExtentRect);

    HRESULT GetPartSize(CRenderObj *pRender, HDC hdc, const RECT *prc, THEMESIZE eSize, SIZE *psz);

    HRESULT GetBitmap(CRenderObj *pRender, HDC hdc, const RECT *prc, HBITMAP *phBitmap);

    HRESULT ScaleMargins(IN OUT MARGINS *pMargins, HDC hdcOrig, CRenderObj *pRender, 
        DIBINFO *pdi, const SIZE *pszDraw, OPTIONAL float *pfx=NULL, OPTIONAL float *pfy=NULL);

    DIBINFO *SelectCorrectImageFile(CRenderObj *pRender, HDC hdc, const RECT *prc, 
        BOOL fForGlyph, OPTIONAL TRUESTRETCHINFO *ptsInfo=NULL);

    void GetDrawnImageSize(DIBINFO *pdi, const RECT *pRect, TRUESTRETCHINFO *ptsInfo, SIZE *pszDraw);

    //---- multi dibs must be placed just after object ----
    inline DIBINFO *MultiDibPtr(int iIndex)
    {
        DIBINFO *pdi = NULL;

        if ((iIndex < 0) && (iIndex >= _iMultiImageCount))
        {
            ASSERT(0 && L"illegal index for MultiDibPtr()");
        }
        else
        {
            DIBINFO * pDibs = (DIBINFO *)(this+1);
            pdi = &pDibs[iIndex];
        }

        return pdi;
    }

protected:
    //---- call this via CMaxImageFile::PackProperties() ----
    HRESULT PackProperties(CRenderObj *pRender, int iPartId, int iStateId);

    //---- helper methods ----
    HRESULT DrawImageInfo(DIBINFO *pdi, CRenderObj *pRender, HDC hdc, int iStateId,
        const RECT *pRect, const DTBGOPTS *pOptions, TRUESTRETCHINFO *ptsInfo);

    HRESULT DrawBackgroundDS(DIBINFO *pdi, TMBITMAPHEADER *pThemeBitmapHeader, BOOL fStock, 
        CRenderObj *pRender, HDC hdc, int iStateId, const RECT *pRect, BOOL fForceStretch, 
        MARGINS *pmarDest, float xMarginFactor, float yMarginFactor, 
        OPTIONAL const DTBGOPTS *pOptions);

    HRESULT SetImageInfo(DIBINFO *pdi, CRenderObj *pRender, int iPartId, int iStateId);

    HRESULT GetScaledContentMargins(CRenderObj *pRender, OPTIONAL HDC hdc, OPTIONAL const RECT *prcDest,
        MARGINS *pMargins);

    void GetOffsets(int iStateId, DIBINFO *pdi, int *piXOffset, int *piYOffset);

    HRESULT DrawFontGlyph(CRenderObj *pRender, HDC hdc, RECT *prc, 
        OPTIONAL const DTBGOPTS *pOptions);
    

public:
    //---- primary image ----
    DIBINFO _ImageInfo;

    //---- multiple DPI scaling images ----
    int _iMultiImageCount;            // number of DIBINFO's that immediately follow object
    IMAGESELECTTYPE _eImageSelectType;

    //---- properties common to all DIBINFO's in this object ----
    int _iImageCount;
    IMAGELAYOUT _eImageLayout;

    //---- mirroring ----
    BOOL _fMirrorImage;

    //---- TrueSize images ----
    TRUESIZESCALINGTYPE _eTrueSizeScalingType;
    HALIGN _eHAlign;
    VALIGN _eVAlign;
    BOOL _fBgFill;
    COLORREF _crFill;
    int _iTrueSizeStretchMark;       // percent at which we stretch a truesize image
    BOOL _fUniformSizing;            // both width & height must grow together
    BOOL _fIntegralSizing;           // for TRUESIZE sizing and for Border sizing           
    
    //---- margins ----
    MARGINS _SizingMargins;
    MARGINS _ContentMargins;
    BOOL _fSourceGrow;
    BOOL _fSourceShrink;
    SIZE _szNormalSize;

    //---- glyph ----
    BOOL _fGlyphOnly;
    GLYPHTYPE _eGlyphType;

    //---- font-based glyph ----
    COLORREF _crGlyphTextColor;
    LOGFONT _lfGlyphFont;
    int _iGlyphIndex;

    //---- image-based glyph ----
    DIBINFO _GlyphInfo;

    //---- id ----
    int _iSourcePartId; 
    int _iSourceStateId;

    //---- multiple DIBINFO's may follow at end ----
};
//---------------------------------------------------------------------------
class CMaxImageFile : public CImageFile
{
public:
    HRESULT PackMaxProperties(CRenderObj *pRender, int iPartId, int iStateId,
        OUT int *piMultiDibCount);

    DIBINFO MultiDibs[MAX_IMAGEFILE_SIZES];  // actual number of multi dibs varies with each obj
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\handlers.h ===
#ifndef __HANDLERS_H__
#define __HANDLERS_H__

//---------------------------------------------------------------------------//
#define _MSG_SWITCH_ // determines handler selection implementation 
                     // (switch block vs. linear array search (vs. hash table lookup?) )

//-------------------//
//  Forwards
class  CThemeWnd;
struct _NCTHEMEMET;
typedef struct _NCTHEMEMET NCTHEMEMET;

//---------------------------------------------------------------------------
//  Hook modification
BOOL ApiHandlerInit( const LPCTSTR pszTarget, USERAPIHOOK* puahTheme, const USERAPIHOOK* puahReal );


//---------------------------------------------------------------------------
//  Window message handler support
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
typedef enum _MSGTYPE
{
    MSGTYPE_PRE_WNDPROC,    // pre-wndproc override
    MSGTYPE_POST_WNDPROC,   // post-wndproc override
    MSGTYPE_PRE_DEFDLGPROC, // pre-DefDlgProc override
    MSGTYPE_POST_DEFDLGPROC,// post-DefDlgProc override
    MSGTYPE_DEFWNDPROC,     // DefWindowProc hook.
}MSGTYPE;

//---------------------------------------------------------------------------
typedef struct _THEME_MSG
{
    HWND    hwnd;        // message target.
    UINT    uMsg;        // message id.
    WPARAM  wParam;      // message WPARAM
    LPARAM  lParam;      // message LPARAM 
    MSGTYPE type;        // type of message (dwp, sent, posted)
    UINT    uCodePage;   // message codepage.  This will invariably be CP_WINUNICODE for
                         //     a message processed via the wide-char defwindowproc, or
                         //     the current user default codepage for messages passed through
                         //     the ansi defwindowproc.
    WNDPROC pfnDefProc;  // address of function handler should call to do default processing
    LRESULT lRet;        // Post overrides only: msg result from default handler.
    BOOL    fHandled;    // handler should set this value.

}THEME_MSG, *PTHEME_MSG;

//---------------------------------------------------------------------------
//  Message handler prototype
typedef LRESULT (CALLBACK * HOOKEDMSGHANDLER)(CThemeWnd* pwnd, THEME_MSG *ptm );

//---------------------------------------------------------------------------
//  Message handler array element
typedef struct _MSGENTRY 
{ 
    UINT nMsg;                      // message identifier (zero if registered message)
    UINT *pnRegMsg;                 // address of registered message var (NULL if stock message)
    HOOKEDMSGHANDLER pfnHandler;    // primary handler
    HOOKEDMSGHANDLER pfnHandler2;   // secondary handler (optional for DWP, WH handlers)
} MSGENTRY, *PMSGENTRY;

//---------------------------------------------------------------------------
//  Performs default processing on the message
LRESULT WINAPI DoMsgDefault( const THEME_MSG* ptm );

//---------------------------------------------------------------------------
inline void WINAPI MsgHandled( const THEME_MSG *ptm, BOOL fHandled = TRUE )   {
    ((PTHEME_MSG)ptm)->fHandled = fHandled;
}

//---------------------------------------------------------------------------
//  message mask helpers
#define MAKE_MSGBIT( nMsg )                ((BYTE)(1 << (nMsg & 7)))
#define SET_MSGMASK( prgMsgMask, nMsg )    (prgMsgMask[nMsg/8] |= MAKE_MSGBIT(nMsg))
#define CLEAR_MSGMASK( prgMsgMask, nMsg )  (prgMsgMask[nMsg/8] &= ~MAKE_MSGBIT(nMsg))
#define CHECK_MSGMASK( prgMsgMask, nMsg )  ((prgMsgMask[nMsg/8] & MAKE_MSGBIT(nMsg)) != 0)

//---------------------------------------------------------------------------//
//  Message handler table access
extern void HandlerTableInit();

DWORD       GetOwpMsgMask( LPBYTE* prgMsgList );
DWORD       GetDdpMsgMask( LPBYTE* prgMsgList );
DWORD       GetDwpMsgMask( LPBYTE* prgMsgList );

BOOL        FindOwpHandler( UINT uMsg, 
                            OUT OPTIONAL HOOKEDMSGHANDLER* ppfnPre, 
                            OUT OPTIONAL HOOKEDMSGHANDLER* ppfnPost );
BOOL        FindDdpHandler( UINT uMsg, 
                            OUT OPTIONAL HOOKEDMSGHANDLER* ppfnPre, 
                            OUT OPTIONAL HOOKEDMSGHANDLER* ppfnPost );
BOOL        FindDwpHandler( UINT uMsg, 
                            OUT OPTIONAL HOOKEDMSGHANDLER* ppfn );

//---------------------------------------------------------------------------//
//  table decl helpers
#define DECL_MSGHANDLER(handler)                  LRESULT CALLBACK handler(CThemeWnd*, THEME_MSG *)
#define DECL_REGISTERED_MSG(msg)                  extern UINT msg;

#define BEGIN_HANDLER_TABLE(rgEntries)            static MSGENTRY rgEntries[] = {
#define END_HANDLER_TABLE()                       };

#define DECL_MSGENTRY(msg,pfnPre,pfnPost)         {msg, NULL, pfnPre, pfnPost},

//---------------------------------------------------------------------------
//  SystemParametersInfo handler support
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//  SystemParametersInfo handler prototype
typedef BOOL (CALLBACK * SPIHANDLER)(
    NCTHEMEMET *pnctm, 
    IN UINT uiAction, IN UINT uiParam, IN OUT PVOID pvParam, IN UINT fWinIni, 
    SYSTEMPARAMETERSINFO pfnDefault, BOOL& fHandled );

BOOL FindSpiHandler( IN UINT uiAction, OUT SPIHANDLER* pfnHandler );

//---------------------------------------------------------------------------//
//  table decl helpers
#define DECL_SPIHANDLER(handler)                  BOOL CALLBACK handler(NCTHEMEMET*, UINT, UINT, PVOID, UINT, SYSTEMPARAMETERSINFO, BOOL& )
#define BEGIN_SPIHANDLER_TABLE()                  BOOL FindSpiHandler( UINT uiAction, SPIHANDLER* pfnHandler ) {\
                                                       switch(uiAction){
#define DECL_SPIENTRY(uiAction, handler)          case uiAction: {*pfnHandler = handler; return TRUE;}
#define END_SPIHANDLER_TABLE()                    }return FALSE;}


//---------------------------------------------------------------------------
//  GetSystemMetrics handler support
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//  GetSystemMetrics handler prototype
typedef int (CALLBACK * GSMHANDLER)(
    NCTHEMEMET *pnctm, IN int iMetric, 
    GETSYSTEMMETRICSPROC pfnDefault, BOOL& fHandled );

typedef struct _GSMENTRY {
    int iMetric;
    GSMHANDLER pfnHandler;
} GSMENTRY;

BOOL FindGsmHandler( IN int iMetric, OUT GSMHANDLER* pfnHandler );

#define DECL_GSMHANDLER(handler)                  int CALLBACK handler(NCTHEMEMET*, int, GETSYSTEMMETRICSPROC, BOOL& )
#define BEGIN_GSMHANDLER_TABLE(rgEntries)         static GSMENTRY rgEntries[] = {
#define END_GSMHANDLER_TABLE()                    };
#define DECL_GSMENTRY(iMetric, handler)           {iMetric, handler},

#endif __HANDLERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\info.cpp ===
//---------------------------------------------------------------------------
//  Info.cpp - implements the information services of the CRenderObj object
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"
#include "Utils.h"
#include "Loader.h"
#include "sethook.h"
#include "info.h"
#include "RenderList.h"
#include "Services.h"
#include "appinfo.h"
#include "tmutils.h"
#include "borderfill.h"
#include "imagefile.h"
#include "textdraw.h"
//---------------------------------------------------------------------------
HRESULT MatchThemeClass(LPCTSTR pszAppName, LPCTSTR pszClassId, 
    CUxThemeFile *pThemeFile, int *piOffset, int *piClassNameOffset)
{
    THEMEHDR *pHdr = (THEMEHDR *)pThemeFile->_pbThemeData; 
    MIXEDPTRS u;
    u.pb = pThemeFile->_pbThemeData + pHdr->iSectionIndexOffset;

    DWORD dwCount = pHdr->iSectionIndexLength/sizeof(APPCLASSLIVE);
    APPCLASSLIVE *acl = (APPCLASSLIVE *)u.pb;

    for (DWORD i=0; i < dwCount; i++, acl++)
    {
        if (acl->dwAppNameIndex) 
        {
            if ((! pszAppName) || (! *pszAppName))
                continue;       // not a match

            LPCWSTR pszApp = ThemeString(pThemeFile, acl->dwAppNameIndex);

            if (AsciiStrCmpI(pszAppName, pszApp) != 0)
                continue;       // not a match
        }

        if (acl->dwClassNameIndex)
        {
            LPCWSTR pszClass = ThemeString(pThemeFile, acl->dwClassNameIndex);

            if (AsciiStrCmpI(pszClassId, pszClass)==0)        // matches
            {
                *piOffset = acl->iIndex;
                *piClassNameOffset = acl->dwClassNameIndex;
                return S_OK;
            }
        }
    }

    return MakeError32(ERROR_NOT_FOUND);      // not found
}
//---------------------------------------------------------------------------
HRESULT MatchThemeClassList(HWND hwnd, LPCTSTR pszClassIdList, 
    CUxThemeFile *pThemeFile, int *piOffset, int *piClassNameOffset)
{
    LPCTSTR pszAppName = NULL;
    WCHAR *pszIdListBuff = NULL;
    WCHAR szAppSubName[MAX_PATH];
    WCHAR szIdSubName[MAX_PATH];
    int len;
    Log(LOG_TM, L"MatchThemeClassList(): classlist=%s", pszClassIdList);
    HRESULT hr = S_OK;

    if (! pszClassIdList)
        return MakeError32(E_INVALIDARG);

    //---- first check Hwnd IdList substitutions ----
    if (hwnd)
    {
        ATOM atomIdSub = (ATOM)GetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_SUBIDLIST)));

        if (atomIdSub)
        {
            if (GetAtomName(atomIdSub, szIdSubName, ARRAYSIZE(szIdSubName)))
            {
                pszClassIdList = szIdSubName;
                Log(LOG_TM, L"MatchThemeClassList: hwnd prop IdList OVERRIDE: %s", pszClassIdList);
            }
        }
    }

    //---- now check Hwnd AppName substitutions ----
    if (hwnd)
    {
        ATOM atomAppSub = (ATOM)GetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_SUBAPPNAME)));

        if (atomAppSub)
        {
            if (GetAtomName(atomAppSub, szAppSubName, ARRAYSIZE(szAppSubName)))
            {
                pszAppName = szAppSubName;
                Log(LOG_TM, L"MatchThemeClassList: hwnd prop AppName OVERRIDE: %s", pszAppName);
            }
        }
    }

    //---- make a copy of pszClassIdList ----
    len = lstrlen(pszClassIdList);
    pszIdListBuff = new WCHAR[len+1];
    if (! pszIdListBuff)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    StringCchCopyW(pszIdListBuff, len + 1, pszClassIdList);

    LPTSTR classId;
    BOOL fContinue;

    classId = pszIdListBuff;
    fContinue = TRUE;

    //---- check each ClassId in the list ----
    while (fContinue)
    {
        fContinue = lstrtoken(classId, _TEXT(';'));
        hr = MatchThemeClass(pszAppName, classId, pThemeFile, piOffset, piClassNameOffset);
        if (SUCCEEDED(hr))
            break;

        classId += lstrlen(classId)+1;
    }

exit:
    if (pszIdListBuff)
        delete [] pszIdListBuff;

    return hr;
}
//---------------------------------------------------------------------------
HTHEME _OpenThemeDataFromFile(HTHEMEFILE hLoadedThemeFile, HWND hwnd, 
    LPCWSTR pszClassIdList, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    RESOURCE CUxThemeFile *pThemeFile = (CUxThemeFile *)hLoadedThemeFile;
    int iOffset;
    int iClassNameOffset;
    HTHEME hTheme = NULL;

    //---- match classid list to theme and get the offset ----
    hr = MatchThemeClassList(hwnd, pszClassIdList, pThemeFile, &iOffset,
        &iClassNameOffset);
    if (FAILED(hr))
    {
        Log(LOG_TMOPEN, L"hLoadedThemeFile: No match for class=%s", pszClassIdList);
        goto exit;
    }
    
    hr = g_pRenderList->OpenRenderObject(pThemeFile, iOffset, iClassNameOffset, NULL,
        NULL, hwnd, dwFlags, &hTheme);
    if (FAILED(hr))
        goto exit;

    //---- store hTheme with window ----
    if (! (dwFlags & OTD_NONCLIENT))
    {
        //---- store the hTheme so we know its themed ----
        if (hwnd)
            SetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_HTHEME)), (void *)hTheme);
    }

    Log(LOG_TMOPEN, L"hLoadedThemeFile: returning hTheme=0x%x", hTheme);

exit:
    SET_LAST_ERROR(hr);
    return hTheme;
}
//---------------------------------------------------------------------------
HTHEME _OpenThemeData(HWND hwnd, LPCWSTR pszClassIdList, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    RESOURCE CUxThemeFile *pThemeFile = NULL;
    HTHEME hTheme = NULL;
    BOOL fOk;
    DWORD dwAppFlags;

    SET_LAST_ERROR(hr);

    if (! g_fUxthemeInitialized)
        goto exit;

    Log(LOG_TMOPEN, L"_OpenThemeData: hwnd=0x%x, ClassIdList=%s", hwnd, pszClassIdList);

    //---- remove previous HTHEME property ----
    if (hwnd)
        RemoveProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_HTHEME)));

    if (! g_pAppInfo->AppIsThemed())     // this process has been excluded from theming
    {
        Log(LOG_TMOPEN, L"App not themed");
        hr = MakeError32(ERROR_NOT_FOUND);
        SET_LAST_ERROR(hr);
        goto exit;
    }

    //---- ensure app allows this type of themeing ----
    dwAppFlags = g_pAppInfo->GetAppFlags();

    if (dwFlags & OTD_NONCLIENT)
    {
        fOk = ((dwAppFlags & STAP_ALLOW_NONCLIENT) != 0);    
    }
    else
    {
        fOk = ((dwAppFlags & STAP_ALLOW_CONTROLS) != 0);
    }

    if (! fOk)
    {
        Log(LOG_TMOPEN, L"AppFlags don't allow theming client/nonclient windows");
        hr = MakeError32(ERROR_NOT_FOUND);
        SET_LAST_ERROR(hr);
        goto exit;
    }

    //---- find Theme File for this HWND and REFCOUNT it for _OpenThemeDataFromFile call ----
    hr = GetHwndThemeFile(hwnd, pszClassIdList, &pThemeFile);
    if (FAILED(hr))
    {
        Log(LOG_TMOPEN, L"no theme entry for this classidlist: %s", pszClassIdList);
        SET_LAST_ERROR(hr);
        goto exit;
    }

    hTheme = _OpenThemeDataFromFile(pThemeFile, hwnd, pszClassIdList, dwFlags);
    
exit:
    //---- always close the pThemeFile here and decrement its refcnt ----
    //---- case 1: if we failed to get an HTHEME, we don't want a refcnt on it ----
    //---- case 2: if we do get an HTHEME, it get's its own refcnt on it ----
    if (pThemeFile)
        g_pAppInfo->CloseThemeFile(pThemeFile);

    return hTheme;
}
//---------------------------------------------------------------------------
HRESULT GetHwndThemeFile(HWND hwnd, LPCWSTR pszClassIdList, CUxThemeFile **ppThemeFile)
{
    HRESULT hr = S_OK;

    //----- check input params ----
    if ((! pszClassIdList) || (! *pszClassIdList))
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    //---- get a shared CUxThemeFile object for the hwnd ----
    hr = g_pAppInfo->OpenWindowThemeFile(hwnd, ppThemeFile);
    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT _OpenThemeFileFromData(CRenderObj *pRender, HTHEMEFILE *phThemeFile)
{
    LogEntry(L"OpenThemeFileFromData");

    HRESULT hr = S_OK;

    *phThemeFile = pRender->_pThemeFile;

    LogExit(L"OpenThemeFileFromData");
    return hr;
}
//---------------------------------------------------------------------------
void ClearExStyleBits(HWND hwnd)
{
    Log(LOG_COMPOSITE, L"ClearExStyleBits called for hwnd=0x%x", hwnd);
    
    //---- see if window needs its exstyle cleared ----
    DWORD dwFlags = PtrToInt(GetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_PROPFLAGS))));

    if (dwFlags & (PROPFLAGS_RESET_TRANSPARENT | PROPFLAGS_RESET_COMPOSITED))
    {
        DWORD dwExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);

        if (dwFlags & PROPFLAGS_RESET_TRANSPARENT)
        {
            Log(LOG_COMPOSITE, L"Clearning WS_EX_TRANSPARENT for hwnd=0x%x", hwnd);
            dwExStyle &= ~(WS_EX_TRANSPARENT);
        }

        if (dwFlags & PROPFLAGS_RESET_COMPOSITED)
        {
            Log(LOG_COMPOSITE, L"Clearning WS_EX_COMPOSITED for hwnd=0x%x", hwnd);
            dwExStyle &= ~(WS_EX_COMPOSITED);
        }

        //---- reset the correct ExStyle bits ----
        SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyle);

        //---- reset the property flags ----
        dwFlags &= ~(PROPFLAGS_RESET_TRANSPARENT | PROPFLAGS_RESET_COMPOSITED);
        SetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_PROPFLAGS)), IntToPtr(dwFlags));
    }
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
struct EPW
{
    WNDENUMPROC lpCallBackCaller;
    LPARAM lParamCaller;
    
    HWND *pHwnds;           // OPTIONAL list of hwnds to remove as they are enum-ed
    int iCountHwnds;        // count of remaining HWND's in pHwnds
};
//---------------------------------------------------------------------------
BOOL CALLBACK ChildWinCallBack(HWND hwnd, LPARAM lParam)
{
    BOOL fResult = TRUE;

    if (IsWindowProcess(hwnd, g_dwProcessId))
    {
        EPW *pEpw = (EPW *)lParam;
        
        fResult = pEpw->lpCallBackCaller(hwnd, pEpw->lParamCaller);

        //---- remove from list ----
        if (pEpw->pHwnds) 
        {
            for (int i=0; i < pEpw->iCountHwnds; i++)
            {
                if (pEpw->pHwnds[i] == hwnd)     // found it
                {
                    pEpw->iCountHwnds--;     

                    if (i != pEpw->iCountHwnds)       // switch last with current
                        pEpw->pHwnds[i] = pEpw->pHwnds[pEpw->iCountHwnds];

                    break;
                }
            }
        }
    }

    return fResult;
}
//---------------------------------------------------------------------------
BOOL CALLBACK TopWinCallBack(HWND hwnd, LPARAM lParam)
{
    BOOL fResult = ChildWinCallBack(hwnd, lParam);
    if (fResult)
    {
        //---- we need to check for hwnd having at least one child ----
        //---- since EnumChildWindows() of a hwnd without children ----
        //---- returns an error ----

        if (GetWindow(hwnd, GW_CHILD))      // if hwnd has at least one child
        {
            fResult = EnumChildWindows(hwnd, ChildWinCallBack, lParam);
        }
    }

    return fResult;
}
//---------------------------------------------------------------------------
BOOL CALLBACK DesktopWinCallBack(LPTSTR lpszDesktop, LPARAM lParam)
{
    //---- open the desktop ----
    HDESK hDesk = OpenDesktop(lpszDesktop, DF_ALLOWOTHERACCOUNTHOOK, FALSE, 
        DESKTOP_READOBJECTS | DESKTOP_ENUMERATE);

    if (hDesk)
    {
        //---- enum windows on desktop ----
        EnumDesktopWindows(hDesk, TopWinCallBack, lParam);

        CloseDesktop(hDesk);
    }

    return TRUE;        // return values from EnumDesktopWindows() not reliable
}
//---------------------------------------------------------------------------
BOOL EnumProcessWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam)
{
    HWND *pHwnds = NULL;
    int iCount = 0;
    EPW epw = {lpEnumFunc, lParam};

    //---- get list of themed windows on "foreign" desktops for this process ----
    BOOL fGotForeignList = g_pAppInfo->GetForeignWindows(&pHwnds, &iCount);
    if (fGotForeignList)
    {
        epw.pHwnds = pHwnds;
        epw.iCountHwnds = iCount;
    }

    //---- this will enum all windows for this process (all desktops, all child levels) ----
    BOOL fOk = EnumDesktops(GetProcessWindowStation(), DesktopWinCallBack, (LPARAM)&epw);
    if ((fOk) && (fGotForeignList) && (epw.iCountHwnds))
    {
        //---- get updated count ----
        iCount = epw.iCountHwnds;

        //---- turn off list maintainance ----
        epw.pHwnds = NULL;
        epw.iCountHwnds = 0;

        Log(LOG_TMHANDLE, L"---- Enuming %d Foreign Windows ----", iCount);

        //---- enumerate remaining hwnd's in list ----
        for (int i=0; i < iCount; i++)
        {
            fOk = ChildWinCallBack(pHwnds[i], (LPARAM)&epw);

            if (! fOk)
                break;
        }
    }

    if (pHwnds)
        delete [] pHwnds;

    return fOk;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
BOOL CALLBACK DumpCallback(HWND hwnd, LPARAM lParam)
{
    WCHAR szName[MAX_PATH];
    WCHAR szDeskName[MAX_PATH] = {0};
    BOOL fIsForeign = TRUE;

    //---- get classname of window ----
    GetClassName(hwnd, szName, MAX_PATH);

    //---- get desktop name for window ----
    if (GetWindowDesktopName(hwnd, szDeskName, ARRAYSIZE(szDeskName)))
    {
        if (AsciiStrCmpI(szDeskName, L"default")==0)
        {
            fIsForeign = FALSE;
        }
    }

    if (fIsForeign)
    {
        Log(LOG_WINDUMP, L"    hwnd=0x%x, class=%s, DESK=%s", hwnd, szName, szDeskName); 
    }
    else
    {
        Log(LOG_WINDUMP, L"    hwnd=0x%x, class=%s", hwnd, szName); 
    }

    return TRUE;
}
//---------------------------------------------------------------------------
void WindowDump(LPCWSTR pszWhere)
{
    if (LogOptionOn(LO_WINDUMP))
    {
        Log(LOG_WINDUMP, L"---- Window Dump for Process [%s] ----", pszWhere);

        EnumProcessWindows(DumpCallback, NULL);
    }
    else
    {
        Log(LOG_TMHANDLE, L"---- %s ----", pszWhere);
    }
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\themes\uxtheme\nctheme.cpp ===
//-------------------------------------------------------------------------//
//  NCTheme.cpp
//-------------------------------------------------------------------------//
//  bug: resizable dialog (themesel) doesn't repaint client when needed
//       (for test case, resize "themesel" using "bussolid" theme.
//-------------------------------------------------------------------------//
#include "stdafx.h"
#include "nctheme.h"
#include "sethook.h"
#include "info.h"
#include "rgn.h"        // AddToCompositeRgn()
#include "scroll.h"     // DrawSizeBox, DrawScrollBar, HandleScrollCmd
#include "resource.h"
#include "tmreg.h"
#include "wrapper.h"
#include "appinfo.h"

//-------------------------------------------------------------------------//
///  local macros, consts, vars
//-------------------------------------------------------------------------//
const   RECT rcNil                       = {-1,-1,-1,-1};
const   WINDOWPARTS BOGUS_WINDOWPART     = (WINDOWPARTS)0;
#define VALID_WINDOWPART(part)           ((part)!=BOGUS_WINDOWPART)
#define WS_MINMAX                        (WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define HAS_CAPTIONBAR( dwStyle )        (WS_CAPTION == ((dwStyle) & WS_CAPTION))
#define DLGWNDCLASSNAME                  TEXT("#32770")
#define DLGWNDCLASSNAMEW                 L"#32770"

#define NUMBTNSTATES                     4 /*number of defined states*/
#define MAKE_BTNSTATE(framestate, state) ((((framestate)-1) * NUMBTNSTATES) + (state))
#define MDIBTNINDEX(ncrc)                ((ncrc)-NCMDIBTNFIRST)

#ifdef  MAKEPOINT
#undef  MAKEPOINT
#endif  MAKEPOINT
#define MAKEPOINT(pt,lParam)             POINTSTOPOINT(pt, MAKEPOINTS(lParam))

#define IsHTFrameButton(htCode)             \
            (((htCode) == HTMINBUTTON) ||   \
             ((htCode) == HTMAXBUTTON) ||   \
             ((htCode) == HTCLOSE)     ||   \
             ((htCode) == HTHELP))

#define IsTopLevelWindow(hwnd)          (IsWindow(hwnd) && NULL==GetParent(hwnd))

#define IsHTScrollBar(htCode)           (((htCode) == HTVSCROLL) || ((htCode) == HTHSCROLL))

#define SIG_CTHEMEWND_HEAD              "themewnd"
#define SIG_CTHEMEWND_TAIL              "end"

//-------------------------------------------------------------------------//
HWND  _hwndFirstTop = NULL;         // first themed window in process
TCHAR _szWindowMetrics[128] = {0};  // WM_SETTINGCHANGE string param.
//-------------------------------------------------------------------------//

//  debug painting switch.
#define DEBUG_NCPAINT 

//-------------------------------------------------------------------------//
//  internal helper forwards
//-------------------------------------------------------------------------//
HDC     _GetNonclientDC( IN HWND hwnd, IN OPTIONAL HRGN hrgnUpdate );
void    _ScreenToParent( HWND, LPRECT prcWnd );
BOOL    _GetWindowMonitorRect( HWND hwnd, LPRECT prcMonitor );
BOOL    _GetMaximizedContainer( IN HWND hwnd, OUT LPRECT prcContainer );
BOOL    _IsFullMaximized( IN OPTIONAL HWND hwnd, IN LPCRECT prcWnd );
BOOL    _IsMessageWindow( HWND );
void    _MDIUpdate( HWND hwndMDIChildOrClient, UINT uSwpFlags );
BOOL    _MDIClientUpdateChildren( HWND hwndMDIClient );
void    _MDIChildUpdateParent( HWND hwndMDIChild, BOOL fSetMenu = FALSE );
HWND    _MDIGetActive( HWND, OUT OPTIONAL BOOL* pfMaximized = NULL );
HWND    _MDIGetParent( HWND hwnd, OUT OPTIONAL CThemeWnd** ppMdiFrame = NULL, OUT OPTIONAL HWND *phwndMDIClient = NULL );
int     _GetRawClassicCaptionHeight( DWORD dwStyle, DWORD dwExStyle );
int     _GetSumClassicCaptionHeight( DWORD dwStyle, DWORD dwExStyle );
void    _ComputeNcWindowStatus( IN HWND, IN DWORD dwStatus, IN OUT NCWNDMET* pncwm );
BOOL    _MNCanClose(HWND);
int     _GetWindowBorders(LONG lStyle, DWORD dwExStyle );
BOOL    _GetWindowMetrics( HWND, IN OPTIONAL HWND hwndMDIActive, OUT NCWNDMET* pncwm );
BOOL    _IsNcPartTransparent( WINDOWPARTS part, const NCTHEMEMET& nctm );
BOOL    _GetNcFrameMetrics( HWND, HTHEME hTheme, const NCTHEMEMET&, IN OUT NCWNDMET& );
BOOL    _GetNcCaptionMargins( HTHEME hTheme, IN const NCTHEMEMET& nctm, IN OUT NCWNDMET& ncwm );
LPWSTR  _AllocWindowText( IN HWND hwnd );
BOOL    _GetNcCaptionTextSize( IN HTHEME hTheme, IN HWND hwnd, IN HFONT hf, OUT SIZE* psizeCaption );
BOOL    _GetNcCaptionTextRect( IN OUT NCWNDMET* pncwm );
COLORREF _GetNcCaptionTextColor( FRAMESTATES iStateId );
void    _GetNcBtnHitTestRect( IN const NCWNDMET* pncwm, IN UINT uHitcode, BOOL fWindowRelative, OUT LPRECT prcHit );
void    _GetBrushesForPart(HTHEME hTheme, int iPart, HBITMAP* phbm, HBRUSH* phbr);
BOOL    _ShouldAssignFrameRgn( IN const NCWNDMET* pncwm, IN const NCTHEMEMET& nctm );
BOOL    _IsNcPartTransparent( WINDOWPARTS part, const NCTHEMEMET& nctm );
BOOL    _ComputeNcPartTransparency( HTHEME, IN OUT NCTHEMEMET* pnctm );
HRESULT _LoadNcThemeMetrics( HWND, IN OUT OPTIONAL NCTHEMEMET* pnctm );
HRESULT _LoadNcThemeSysMetrics( HWND hwnd, IN OUT OPTIONAL NCTHEMEMET* pnctm );
void    _NcSetPreviewMetrics( BOOL fPreview );
BOOL    _NcUsingPreviewMetrics();
BOOL    _GetNcBtnMetrics( IN OUT NCWNDMET*, IN const NCTHEMEMET*, IN HICON, IN OPTIONAL BOOL );

//-------------------------------------------------------------------------//
//  Debug painting.
#if defined(DEBUG) 
ULONG _NcTraceFlags = 0;
#   if defined(DEBUG_NCPAINT)
#       define BEGIN_DEBUG_NCPAINT()  int cgbl = 0; if(TESTFLAG(_NcTraceFlags, NCTF_NCPAINT)) {GdiSetBatchLimit(1);}
#       define END_DEBUG_NCPAINT()    if(TESTFLAG(_NcTraceFlags, NCTF_NCPAINT)) {GdiSetBatchLimit(cgbl);}
        HRESULT _DebugDrawThemeBackground(HTHEME, HDC, int, int, const RECT*, OPTIONAL const RECT*);
        HRESULT _DebugDrawThemeBackgroundEx(HTHEME, HDC, int, int, const RECT *prc, OPTIONAL const DTBGOPTS*);
        void    NcDebugClipRgn( HDC hdc, COLORREF rgbPaint );
#       define  NcDrawThemeBackground   _DebugDrawThemeBackground
#       define  NcDrawThemeBackgroundEx _DebugDrawThemeBackgroundEx
#   else  //defined(DEBUG_NCPAINT)
#       define BEGIN_DEBUG_NCPAINT()
#       define END_DEBUG_NCPAINT()
#       define  NcDrawThemeBackground   DrawThemeBackground
#       define  NcDrawThemeBackgroundEx DrawThemeBackgroundEx
#       define NcDebugClipRgn(hdc,rgbPaint)
#   endif //defined(DEBUG_NCPAINT)
#else
#   define BEGIN_DEBUG_NCPAINT()
#   define END_DEBUG_NCPAINT()
#   define  NcDrawThemeBackground   DrawThemeBackground
#   define  NcDrawThemeBackgroundEx DrawThemeBackgroundEx
#   define NcDebugClipRgn(hdc,rgbPaint)
#endif //defined(DEBUG)
#define RGBDEBUGBKGND   RGB(0xFF,0x00,0xFF) // debug background indicator fill color

//-------------------------------------------------------------------------//
//  process-global metrics
static NCTHEMEMET _nctmCurrent = {0};
CRITICAL_SECTION  _csNcSysMet = {0}; // protects access to _incmCurrent 
CRITICAL_SECTION  _csThemeMet = {0}; // protects access to _nctmCurrent 

//-------------------------------------------------------------------------//
//  process NONCLIENTMETRICS cache.
struct CInternalNonclientMetrics
//-------------------------------------------------------------------------//
{
    const NONCLIENTMETRICS& GetNcm()
    { 
        Acquire(FALSE);
        return _ncm;
    }

    HFONT GetFont( BOOL fSmallCaption )
    {
        if( _fSet)
        {
            return fSmallCaption ? _hfSmCaption : _hfCaption;
        }
        
        return NULL;
    }

    void operator =( const NONCLIENTMETRICS& ncmSrc )
    {
        _ncm = ncmSrc;

        SAFE_DELETE_GDIOBJ(_hfCaption);
        _hfCaption   = CreateFontIndirect( &_ncm.lfCaptionFont );

        SAFE_DELETE_GDIOBJ(_hfSmCaption);
        _hfSmCaption = CreateFontIndirect( &_ncm.lfSmCaptionFont );

        _fSet = TRUE;
    }

    BOOL Acquire( BOOL fRefresh )
    {
        //---- quick check for outdated metrics ----
        if (!_fPreview)
        {
            int iNewHeight = GetSystemMetrics(SM_CYSIZE);

            if (iNewHeight != _iCaptionButtonHeight)        // out of date
            {
                fRefresh = TRUE;        // force the issue   
                _iCaptionButtonHeight = iNewHeight;
            }
        }

        //  normal metrics
        if( !_fSet || fRefresh )
        {
            // save logfont checksum
            LOGFONT lfCaption   = _ncm.lfCaptionFont;
            LOGFONT lfSmCaption = _ncm.lfSmCaptionFont;

            Log(LOG_TMLOAD, L"Acquire: calling ClassicSystemParmetersInfo");

            _ncm.cbSize = sizeof(_ncm);
            _fSet = ClassicSystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &_ncm, FALSE );

            if( _fSet )
            {
                // if old, new logfont checksums don't match, recycle our fonts
                if( CompareLogfont( &lfCaption, &_ncm.lfCaptionFont) )
                {
                    SAFE_DELETE_GDIOBJ(_hfCaption);
                    _hfCaption = CreateFontIndirect(&_ncm.lfCaptionFont);
                }

                if( CompareLogfont( &lfSmCaption, &_ncm.lfSmCaptionFont) )
                {
                    SAFE_DELETE_GDIOBJ(_hfSmCaption);
                    _hfSmCaption = CreateFontIndirect(&_ncm.lfSmCaptionFont);
                }
            }
        }
        return _fSet;
    }

    void Clear() 
    { 
        SAFE_DELETE_GDIOBJ(_hfCaption); 
        SAFE_DELETE_GDIOBJ(_hfSmCaption);
        ZeroMemory( &_ncm, sizeof(_ncm) );
        _fSet = FALSE;
    }

    static int CompareLogfont( const LOGFONT* plf1, const LOGFONT* plf2 )
    {
        int n = memcmp( plf1, plf2, sizeof(LOGFONT) - sizeof(plf1->lfFaceName) );
        if( !n )
        {
            n = lstrcmp( plf1->lfFaceName, plf2->lfFaceName );
        }
        return n;
    }

    NONCLIENTMETRICS _ncm;
    int              _iCaptionButtonHeight;
    BOOL             _fSet;
    HFONT            _hfCaption;
    HFONT            _hfSmCaption;
    BOOL             _fPreview;

} _incmCurrent = {0}, _incmPreview = {0};

//-------------------------------------------------------------------------//
//  MDI sys button group abstraction
class CMdiBtns
//-------------------------------------------------------------------------//
{
public:
    CMdiBtns();
    ~CMdiBtns() { Unload(); }

    BOOL Load( IN HTHEME hTheme, IN OPTIONAL HDC hdc = NULL, IN OPTIONAL UINT uSysCmd = 0 );
    BOOL ThemeItem( HMENU hMenu, int iPos, MENUITEMINFO* pmii, BOOL fTheme );
    void Unload( IN OPTIONAL UINT uSysCmd = 0 );
    BOOL Measure( IN HTHEME hTheme, IN OUT MEASUREITEMSTRUCT* pmis );
    BOOL Draw( IN HTHEME hTheme, IN DRAWITEMSTRUCT* pdis );

private:
   
    #define MDIBTNCOUNT 3   // 1=min, 2=restore, 3=close
    //------------------------------------//
    //  MDI sys button descriptor element
    struct MDIBTN
    {
        UINT        wID;
        WINDOWPARTS iPartId;
        SIZINGTYPE  sizingType;
        SIZE        size;
        UINT        fTypePrev;
        HBITMAP     hbmPrev;
        HBITMAP     hbmTheme;

    } _rgBtns[MDIBTNCOUNT];

private:
    MDIBTN*                   _FindBtn( IN UINT wID );
    static CLOSEBUTTONSTATES  _CalcState( IN ULONG ulodAction, IN ULONG ulodState );
};

//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//  utility impl
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
void _ScreenToParent( HWND hwnd, LPRECT prcWnd )
{
    //if we have a parent, we need to convert to those coords
    HWND hwndParent = GetAncestor(hwnd, GA_PARENT);
    POINT* pp = (POINT*)prcWnd;
    
    //---- use MapWindowPoints() to account for mirrored windows ----
    MapWindowPoints(HWND_DESKTOP, hwndParent, pp, 2);
}

//-------------------------------------------------------------------------//
inline BOOL _StrictPtInRect( LPCRECT prc, const POINT& pt )
{
    //  Win32 PtInRect will test positive for an empty rectangle...
    return !IsRectEmpty(prc) &&
           PtInRect( prc, pt );
}

//-------------------------------------------------------------------------//
inline BOOL _RectInRect( LPCRECT prcTest, LPCRECT prc )
{
    if ( prc->left   < prcTest->left  &&
         prc->right  > prcTest->right &&
         prc->top    < prcTest->top   &&
         prc->bottom > prcTest->bottom   )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//-------------------------------------------------------------------------//
inline HDC _GetNonclientDC( IN HWND hwnd, IN OPTIONAL HRGN hrgnUpdate )
{
    // private GetDCEx #defines from user
    #define DCX_USESTYLE         0x00010000L
    #define DCX_NODELETERGN      0x00040000L

    DWORD dwDCX = DCX_USESTYLE|DCX_WINDOW|DCX_LOCKWINDOWUPDATE;

    if( hrgnUpdate != NULL )
        dwDCX |= (DCX_INTERSECTRGN|DCX_NODELETERGN);
    
    return GetDCEx( hwnd, hrgnUpdate, dwDCX );
}

//-------------------------------------------------------------------------//
HWND _MDIGetActive( HWND hwndMDIClient, OUT OPTIONAL BOOL* pfMaximized )
{
    BOOL fMaximized = FALSE;
    HWND hwndActive = NULL;

    if( IsWindow( hwndMDIClient ) )
        hwndActive = (HWND)SendMessage( hwndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM)&fMaximized );

    if( pfMaximized ) *pfMaximized = fMaximized;
    return hwndActive;
}

//-------------------------------------------------------------------------////
//  computes rectangle of window's default monitor
BOOL _GetWindowMonitorRect( HWND hwnd, LPRECT prcMonitor )
{
    if( IsWindow(hwnd) )
    {
        //  default to primary monitor
        SetRect( prcMonitor, 0, 0, 
                 NcGetSystemMetrics(SM_CXSCREEN), 
                 NcGetSystemMetrics(SM_CYSCREEN));

        //  try determining window's real monitor
        HMONITOR hMon = MonitorFromWindow( hwnd, MONITOR_DEFAULTTONULL );
        if( hMon )
        {
            MONITORINFO mi;
            mi.cbSize = sizeof(mi);
            if( GetMonitorInfo( hMon, &mi ) )
            {
                *prcMonitor = mi.rcWork;
            }
        }
        return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------------------------////
//  determines whether the indicate window is as large or larger than
//  the target monitor
BOOL _GetMaximizedContainer( 
    IN HWND hwnd, 
    OUT LPRECT prcContainer )
{
    ASSERT(IsWindow(hwnd));

    HWND hwndParent = GetParent(hwnd);
    if( hwndParent )
    {
        return GetWindowRect( hwndParent, prcContainer );
    }

    // top-level window: container is primary monitor
    return _GetWindowMonitorRect( hwnd, prcContainer );
}

//-------------------------------------------------------------------------////
//  determines whether the indicate window is as large or larger than
//  the target monitor
BOOL _IsFullMaximized( IN OPTIONAL HWND hwnd, IN LPCRECT prcWnd )
{
    if( !IsWindow(hwnd) ) 
        return TRUE; // assume full-screen maximized window

    if( IsZoomed(hwnd) )
    {
        RECT rcContainer = {0};
        if( !_GetMaximizedContainer( hwnd, &rcContainer ) )
            return TRUE;

        //  determine whether the rect is contained in the screen rect
        return _RectInRect( &rcContainer, prcWnd );
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
//
//  _GetRawClassicCaptionHeight() - 
//
//  Using system metrics, computes the total height of the caption bar
//  including edge and borders
//
inline int _GetRawClassicCaptionHeight( DWORD dwStyle, DWORD dwExStyle )
{
    ASSERT(HAS_CAPTIONBAR(dwStyle)); // shouldn't be here without WS_CAPTION
    return NcGetSystemMetrics( 
        TESTFLAG(dwExStyle, WS_EX_TOOLWINDOW ) ? SM_CYSMCAPTION : SM_CYCAPTION );
}

//-------------------------------------------------------------------------//
//
//  _GetSumClassicCaptionHeight() - 
//
//  Using system metrics, computes the total height of the caption bar
//  including edge and borders
//
inline int _GetSumClassicCaptionHeight( DWORD dwStyle, DWORD dwExStyle )
{
    ASSERT(HAS_CAPTIONBAR(dwStyle)); // shouldn't be here without WS_CAPTION
    //  Factor in window border width.
    return _GetWindowBorders( dwStyle, dwExStyle) +
           _GetRawClassicCaptionHeight( dwStyle, dwExStyle );
}

//-------------------------------------------------------------------------//
//
//  GetWindowBorders()  - port from win32k, rtl\winmgr.c
//
//  Computes window border dimensions based on style bits.
//
int _GetWindowBorders(LONG lStyle, DWORD dwExStyle )
{
    int cBorders = 0;

    //
    // Is there a 3D border around the window?
    //
    if( TESTFLAG(dwExStyle, WS_EX_WINDOWEDGE) )
        cBorders += 2;
    else if ( TESTFLAG(dwExStyle, WS_EX_STATICEDGE) )
        ++cBorders;

    //
    // Is there a single flat border around the window?  This is true for
    // WS_BORDER, WS_DLGFRAME, and WS_EX_DLGMODALFRAME windows.
    //
    if( TESTFLAG(lStyle, WS_CAPTION) || TESTFLAG(dwExStyle, WS_EX_DLGMODALFRAME) )
        ++cBorders;

    //
    // Is there a sizing flat border around the window?
    //
    if( TESTFLAG(lStyle, WS_THICKFRAME) && !TESTFLAG(lStyle, WS_MINIMIZE) )
    {
        NONCLIENTMETRICS ncm;
        cBorders += (NcGetNonclientMetrics( &ncm, FALSE ) ? 
                        ncm.iBorderWidth : NcGetSystemMetrics( SM_CXBORDER ));
    }

    return(cBorders);
}

//-------------------------------------------------------------------------//
//  _MNCanClose
//
//  returns TRUE only if USER32 determines that the window can be closed
//  (by checking its system menu items and their disabled state)
//
BOOL _MNCanClose(HWND hwnd)
{
    LogEntryNC(L"_MNCanClose");

    BOOL fRetVal = FALSE;
    
    TITLEBARINFO tbi = {sizeof(tbi)};

    //---- don't use GetSystemMenu() - has user handle leak issues ----
    if (GetTitleBarInfo(hwnd, &tbi))
    {
        //---- mask out the good bits ----
        DWORD dwVal = (tbi.rgstate[5] & (~(STATE_SYSTEM_PRESSED | STATE_SYSTEM_FOCUSABLE)));
        fRetVal = (dwVal == 0);     // only if no bad bits are left
    }

    if ( !fRetVal && TESTFLAG(GetWindowLong(hwnd, GWL_EXSTYLE), WS_EX_MDICHILD) )
    {
        HMENU hMenu = GetSystemMenu(hwnd, FALSE);
        MENUITEMINFO menuInfo; 

        menuInfo.cbSize = sizeof(MENUITEMINFO);
        menuInfo.fMask = MIIM_STATE;
        if ( GetMenuItemInfo(hMenu, SC_CLOSE, FALSE, &menuInfo) )
        {
            fRetVal = !(menuInfo.fState & MFS_GRAYED) ? TRUE : FALSE;
        } 
    }
    
    LogExitNC(L"_MNCanClose");
    return fRetVal;
}

//-------------------------------------------------------------------------//
void CThemeWnd::UpdateMDIFrameStuff( HWND hwndMDIClient, BOOL fSetMenu )
{
    HWND hwndMDIActive = _MDIGetActive( hwndMDIClient, NULL );

    //  cache MDIClient, maximized M window handle
    _hwndMDIClient = IsWindow(hwndMDIActive) ? hwndMDIClient : NULL;
}

//-------------------------------------------------------------------------//
BOOL CALLBACK _FreshenThemeMetricsCB( HWND hwnd, LPARAM lParam )
{
    CThemeWnd* pwnd = CThemeWnd::FromHwnd( hwnd );
    if( VALID_THEMEWND(pwnd) )
    {
        pwnd->AddRef();
        pwnd->GetNcWindowMetrics( NULL, NULL, NULL, NCWMF_RECOMPUTE );
        pwnd->Release();
    }
    return TRUE;
}

//-------------------------------------------------------------------------//
BOOL _IsMessageWindow( HWND hwnd )
{
    //  A window parented by HWND_MESSAGE has no UI and should not be themed.
    static ATOM _atomMsgWnd = 0;

    HWND hwndParent = (HWND)GetWindowLongPtr( hwnd, GWLP_HWNDPARENT );
    if( hwndParent )
    {
        ATOM atomParent = (ATOM)GetClassLong( hwndParent, GCW_ATOM );
        
        // have we seen the message window wndclass before?
        if( _atomMsgWnd ) 
            return (atomParent == _atomMsgWnd); // compare class atoms

        //  haven't seen a message window come through in this process,
        //  so compare class names.
        WCHAR szClass[128];
        if( GetClassNameW( hwndParent, szClass, ARRAYSIZE(szClass) ) )
        {
            if( 0 == AsciiStrCmpI( szClass, L"Message" ) )
            {
                _atomMsgWnd = atomParent;
                return TRUE;
            }
        }
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
//  Retrieves MDI frame and/or MDICLIENT window for an MDI child window
HWND _MDIGetParent( 
    HWND hwnd, OUT OPTIONAL CThemeWnd** ppMdiFrame, OUT OPTIONAL HWND* phwndMDIClient )
{
    if( ppMdiFrame )     *ppMdiFrame = NULL;
    if( phwndMDIClient ) *phwndMDIClient = NULL;

    if( TESTFLAG(GetWindowLong( hwnd, GWL_EXSTYLE ), WS_EX_MDICHILD)  )
    {
        HWND hwndMDIClient = GetParent(hwnd);
        if( IsWindow(hwndMDIClient) )
        {
            HWND hwndFrame = GetParent(hwndMDIClient);
            if( IsWindow(hwndFrame) )
            {
                if( phwndMDIClient ) *phwndMDIClient = hwndMDIClient;
                if( ppMdiFrame )
                    *ppMdiFrame = CThemeWnd::FromHwnd(hwndFrame);

                return hwndFrame;
            }
        }
    }
    return NULL;
}

//-------------------------------------------------------------------------//
HWND _FindMDIClient( HWND hwndFrame )
{
    for( HWND hwndChild = GetWindow(hwndFrame, GW_CHILD); hwndChild != NULL; 
         hwndChild = GetNextWindow(hwndChild, GW_HWNDNEXT))
    {
        TCHAR szClass[48];
        if( GetClassName(hwndChild, szClass, ARRAYSIZE(szClass)) )
        {
            if( 0 == lstrcmpi(szClass, TEXT("MDIClient")) )
            {
                return hwndChild;
            }
        }
    }
    return NULL;
}

//-------------------------------------------------------------------------//
// Handle MDI relative updating on WM_WINDOWPOSCHANGED
void _MDIUpdate( HWND hwnd, UINT uSwpFlags)
{
    //  Notify MDI frame if we became maximized, etc.
    BOOL bIsClient = FALSE;

    // Could be the MDI client, could be a MDI child
    if (!(TESTFLAG(uSwpFlags, SWP_NOMOVE) && TESTFLAG(uSwpFlags, SWP_NOSIZE)))
    {
        bIsClient = _MDIClientUpdateChildren( hwnd );
    }
    if (!bIsClient)
    {
        _MDIChildUpdateParent( hwnd, FALSE );
    }
}

//-------------------------------------------------------------------------//
// Post-WM_WINDOWPOSCHANGED processing for MDI client or children.
// We need to recompute each child when the MDI client moves.
BOOL _MDIClientUpdateChildren( HWND hwndMDIChildOrClient )
{
    // Find if it's the MDI client window
    HWND hWndChild = GetWindow(hwndMDIChildOrClient, GW_CHILD);
    if (IsWindow(hWndChild) && TESTFLAG(GetWindowLong(hWndChild, GWL_EXSTYLE), WS_EX_MDICHILD))
    {
        // Yes it's the MDI client, refresh each MDI child's metrics
        do
        {
            _FreshenThemeMetricsCB(hWndChild, NULL);
        } while (NULL != (hWndChild = GetWindow(hWndChild, GW_HWNDNEXT)));
        return TRUE;
    }

    return FALSE;
}

//-------------------------------------------------------------------------//
//  Informs MDI frame that a child window may
void _MDIChildUpdateParent( HWND hwndMDIChild, BOOL fSetMenu )
{
    CThemeWnd* pwndParent;
    HWND hwndMDIClient;

    if( _MDIGetParent( hwndMDIChild, &pwndParent, &hwndMDIClient ) && 
        VALID_THEMEWND(pwndParent) )
    {
        pwndParent->UpdateMDIFrameStuff( hwndMDIClient, fSetMenu );
    }
}

//-------------------------------------------------------------------------//
//  _ComputeNcWindowStatus
//
//  Assigns and translates window status bits to/in NCWNDMET block.
//
void _ComputeNcWindowStatus( IN HWND hwnd, IN DWORD dwStatus, IN OUT NCWNDMET* pncwm )
{
    BOOL fActive = TESTFLAG( dwStatus, WS_ACTIVECAPTION );

    if (fActive || !HAS_CAPTIONBAR(pncwm->dwStyle) )
    {
        pncwm->framestate  = FS_ACTIVE;
    }
    else
    {
        pncwm->framestate  = FS_INACTIVE;
    }

    if( HAS_CAPTIONBAR(pncwm->dwStyle) )
    {
        pncwm->rgbCaption = _GetNcCaptionTextColor( pncwm->framestate );
    }
}

//-------------------------------------------------------------------------////
BOOL _GetWindowMetrics( HWND hwnd, IN OPTIONAL HWND hwndMDIActive, OUT NCWNDMET* pncwm )
{
    WINDOWINFO wi;
    wi.cbSize = sizeof(wi);
    if( GetWindowInfo( hwnd, &wi ) )
    {
        pncwm->dwStyle         = wi.dwStyle;
        pncwm->dwExStyle       = wi.dwExStyle;
        pncwm->rcS0[NCRC_WINDOW] = wi.rcWindow;
        pncwm->rcS0[NCRC_CLIENT] = wi.rcClient;

        pncwm->fMin   = IsIconic(hwnd);
        pncwm->fMaxed = IsZoomed(hwnd);
        pncwm->fFullMaxed = pncwm->fMaxed ? _IsFullMaximized(hwnd, &wi.rcWindow) : FALSE;

        pncwm->dwWindowStatus  = wi.dwWindowStatus;
        
        
        //  if this window is the active MDI child and is owned by the foreground window 
        //  (which may not be the case if a popup, for example, is foremost), then
        //  fix up the status bit.
        if( hwnd == hwndMDIActive )
        {
            HWND hwndFore = GetForegroundWindow();
            if( IsChild(hwndFore, hwndMDIActive) )
            {
                pncwm->dwWindowStatus = WS_ACTIVECAPTION;
            }
        }
        

        return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL _ShouldAssignFrameRgn( 
    IN const NCWNDMET* pncwm, 
    IN const NCTHEMEMET& nctm )
{
    if( TESTFLAG( CThemeWnd::EvaluateStyle(pncwm->dwStyle, pncwm->dwExStyle), TWCF_FRAME|TWCF_TOOLFRAME) )
    {
        //  always need window region for maximized windows.
        if( pncwm->fFullMaxed )
            return TRUE;

        //  otherwise, need region only if the background is transparent
        for( int i = 0; i < ARRAYSIZE( pncwm->rgframeparts ); i++ )
        {
            if( _IsNcPartTransparent( pncwm->rgframeparts[i], nctm ) )
                return TRUE;
        }
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL _IsNcPartTransparent( WINDOWPARTS part, const NCTHEMEMET& nctm )
{
    #define GET_NCTRANSPARENCY(part,field) \
        case part: return nctm.nct.##field
    
    switch(part)
    {
        GET_NCTRANSPARENCY(WP_CAPTION,          fCaption);
        GET_NCTRANSPARENCY(WP_SMALLCAPTION,     fCaption);
        GET_NCTRANSPARENCY(WP_MINCAPTION,       fMinCaption);
        GET_NCTRANSPARENCY(WP_SMALLMINCAPTION,  fSmallMinCaption);
        GET_NCTRANSPARENCY(WP_MAXCAPTION,       fMaxCaption);
        GET_NCTRANSPARENCY(WP_SMALLMAXCAPTION,  fSmallMaxCaption);
        GET_NCTRANSPARENCY(WP_FRAMELEFT,        fFrameLeft);
        GET_NCTRANSPARENCY(WP_FRAMERIGHT,       fFrameRight);
        GET_NCTRANSPARENCY(WP_FRAMEBOTTOM,      fFrameBottom);    
        GET_NCTRANSPARENCY(WP_SMALLFRAMELEFT,   fSmFrameLeft);
        GET_NCTRANSPARENCY(WP_SMALLFRAMERIGHT,  fSmFrameRight);
        GET_NCTRANSPARENCY(WP_SMALLFRAMEBOTTOM, fSmFrameBottom);    
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL _ComputeNcPartTransparency( HTHEME hTheme, IN OUT NCTHEMEMET* pnctm )
{
    #define TEST_NCTRANSPARENCY(part)   IsThemePartDefined(hTheme,part,0) ? \
        IsThemeBackgroundPartiallyTransparent(hTheme,part,FS_ACTIVE) : FALSE;
    
    pnctm->nct.fCaption         = TEST_NCTRANSPARENCY(WP_CAPTION);
    pnctm->nct.fSmallCaption    = TEST_NCTRANSPARENCY(WP_SMALLCAPTION);
    pnctm->nct.fMinCaption      = TEST_NCTRANSPARENCY(WP_MINCAPTION);
    pnctm->nct.fSmallMinCaption = TEST_NCTRANSPARENCY(WP_SMALLMINCAPTION);
    pnctm->nct.fMaxCaption      = TEST_NCTRANSPARENCY(WP_MAXCAPTION);
    pnctm->nct.fSmallMaxCaption = TEST_NCTRANSPARENCY(WP_SMALLMAXCAPTION);

    pnctm->nct.fFrameLeft       = TEST_NCTRANSPARENCY(WP_FRAMELEFT);
    pnctm->nct.fFrameRight      = TEST_NCTRANSPARENCY(WP_FRAMERIGHT);
    pnctm->nct.fFrameBottom     = TEST_NCTRANSPARENCY(WP_FRAMEBOTTOM);
    pnctm->nct.fSmFrameLeft     = TEST_NCTRANSPARENCY(WP_SMALLFRAMELEFT);
    pnctm->nct.fSmFrameRight    = TEST_NCTRANSPARENCY(WP_SMALLFRAMERIGHT);
    pnctm->nct.fSmFrameBottom   = TEST_NCTRANSPARENCY(WP_SMALLFRAMEBOTTOM);

    return TRUE;
}

//-------------------------------------------------------------------------//
//  NCTHEMEMET implementation
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
BOOL GetCurrentNcThemeMetrics( OUT NCTHEMEMET* pnctm )
{
    *pnctm = _nctmCurrent;
    return IsValidNcThemeMetrics( pnctm );
}

//-------------------------------------------------------------------------//
void InitNcThemeMetrics( NCTHEMEMET* pnctm )
{
    if( !pnctm )
        pnctm = &_nctmCurrent;

    ZeroMemory( pnctm, sizeof(*pnctm) );
}

//---------------------------------------------------------------------------
void ClearNcThemeMetrics( NCTHEMEMET* pnctm )
{
    if( !pnctm )
        pnctm = &_nctmCurrent;

    //---- minimize THREAD-UNSAFE access to _nctmCurrent by ----
    //---- NULL-ing out the hTheme type members as soon as ----
    //---- they are closed ----

    if( pnctm->hTheme )
    {
        CloseThemeData( pnctm->hTheme );
        pnctm->hTheme = NULL;
    }

    if( pnctm->hThemeTab )
    {
        CloseThemeData( pnctm->hThemeTab );
        pnctm->hThemeTab = NULL;
    }

    SAFE_DELETE_GDIOBJ( pnctm->hbmTabDialog );
    SAFE_DELETE_GDIOBJ( pnctm->hbrTabDialog );

    InitNcThemeMetrics( pnctm );
}

//-------------------------------------------------------------------------//
//  Computes process-global, per-theme metrics for the nonclient area theme.
HRESULT AcquireNcThemeMetrics()
{
    HRESULT hr = E_FAIL;

    if( VALID_CRITICALSECTION(&_csThemeMet) )
    {
        hr = S_OK;

        EnterCriticalSection( &_csThemeMet );

        ClearNcThemeMetrics( &_nctmCurrent );
        NcGetNonclientMetrics( NULL, FALSE );
        hr = _LoadNcThemeMetrics(NULL, &_nctmCurrent);

        LeaveCriticalSection( &_csThemeMet );

        Log(LOG_TMCHANGE, L"AcquireNcThemeMetrics: got hTheme=0x%x", _nctmCurrent.hTheme);
    }

    return hr;
}

//-------------------------------------------------------------------------//
//  Computes and/or loads per-theme (as opposed to per-window)
//  system metrics and resources not managed by the theme manager.
//  
//  Called by _LoadNcThemeMetrics
HRESULT _LoadNcThemeSysMetrics( HWND hwnd, IN OUT NCTHEMEMET* pnctm )
{
    HRESULT hr = E_FAIL;
    ASSERT(pnctm);

    //  grab system metrics for nonclient area.
    NONCLIENTMETRICS ncm = {0};
    ncm.cbSize = sizeof(ncm);
    if( NcGetNonclientMetrics( &ncm, FALSE ) )
    {
        hr = S_OK;

        //  Establish minimized window size
        if( 0 >= pnctm->sizeMinimized.cx )
            pnctm->sizeMinimized.cx = NcGetSystemMetrics( SM_CXMINIMIZED );
        if( 0 >= pnctm->sizeMinimized.cy )
            pnctm->sizeMinimized.cy = NcGetSystemMetrics( SM_CYMINIMIZED );
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if( SUCCEEDED(hr) )
            hr = E_FAIL;
    }

    //  Maximized caption height or width
    pnctm->cyMaxCaption   = _GetRawClassicCaptionHeight( WS_CAPTION|WS_OVERLAPPED, 0 );

    return hr;
}

//-------------------------------------------------------------------------//
//  Computes and/or loads per-theme (as opposed to per-window)
//  metrics and resources not managed by the theme manager
HRESULT _LoadNcThemeMetrics( HWND hwnd, NCTHEMEMET* pnctm )
{
    HRESULT hr = E_FAIL;

    //  Initialize incoming NCTHEMEMET:
    if( pnctm )
    {
        InitNcThemeMetrics( pnctm );

        HTHEME hTheme = ::OpenNcThemeData( hwnd, L"Window" );
        if( hTheme )
        {
            pnctm->hTheme = hTheme;

            //  determine transparency for each frame part.
            _ComputeNcPartTransparency(hTheme, pnctm);

            //  menubar pixels not accounted for by CalcMenuBar or PaintMenuBar
            pnctm->dyMenuBar = NcGetSystemMetrics(SM_CYMENU) - NcGetSystemMetrics(SM_CYMENUSIZE);

            //  normal caption margins
            if( FAILED( GetThemeMargins( hTheme, NULL, WP_CAPTION, CS_ACTIVE, TMT_CAPTIONMARGINS,
                                          NULL, &pnctm->marCaptionText )) )
            {
                FillMemory( &pnctm->marCaptionText, sizeof(pnctm->marCaptionText), 0 );
            }

            //  maximized caption margins
            if( FAILED( GetThemeMargins( hTheme, NULL, WP_MAXCAPTION, CS_ACTIVE, TMT_CAPTIONMARGINS,
                                          NULL, &pnctm->marMaxCaptionText )) )
            {
                FillMemory( &pnctm->marMaxCaptionText, sizeof(pnctm->marMaxCaptionText), 0 );
            }

            //  minimized caption margins
            if( FAILED( GetThemeMargins( hTheme, NULL, WP_MINCAPTION, CS_ACTIVE, TMT_CAPTIONMARGINS,
                                          NULL, &pnctm->marMinCaptionText )) )
            {
                FillMemory( &pnctm->marMinCaptionText, sizeof(pnctm->marMinCaptionText), 0 );
            }


            //  dynamically resizing small (toolframe) caption margins
            if( FAILED( GetThemeMargins( hTheme, NULL, WP_SMALLCAPTION, CS_ACTIVE, TMT_CAPTIONMARGINS,
                                          NULL, &pnctm->marSmCaptionText )) )
            {
                FillMemory( &pnctm->marSmCaptionText, sizeof(pnctm->marSmCaptionText), 0 );
            }

            //  caption and frame resizing border hittest template parts
            pnctm->fCapSizingTemplate    = IsThemePartDefined( hTheme, WP_CAPTIONSIZINGTEMPLATE, 0);
            pnctm->fLeftSizingTemplate   = IsThemePartDefined( hTheme, WP_FRAMELEFTSIZINGTEMPLATE, 0);
            pnctm->fRightSizingTemplate  = IsThemePartDefined( hTheme, WP_FRAMERIGHTSIZINGTEMPLATE, 0);
            pnctm->fBottomSizingTemplate = IsThemePartDefined( hTheme, WP_FRAMEBOTTOMSIZINGTEMPLATE, 0);

            //  toolwindow caption and frame resizing border hittest template parts
            pnctm->fSmCapSizingTemplate    = IsThemePartDefined( hTheme, WP_SMALLCAPTIONSIZINGTEMPLATE, 0);
            pnctm->fSmLeftSizingTemplate   = IsThemePartDefined( hTheme, WP_SMALLFRAMELEFTSIZINGTEMPLATE, 0);
            pnctm->fSmRightSizingTemplate  = IsThemePartDefined( hTheme, WP_SMALLFRAMERIGHTSIZINGTEMPLATE, 0);
            pnctm->fSmBottomSizingTemplate = IsThemePartDefined( hTheme, WP_SMALLFRAMEBOTTOMSIZINGTEMPLATE, 0);

            //  Minimized window size.
            //  If this is a truesize image, honor its dimensions; otherwise use
            //  width, height properties.  Fall back on system metrics.
            SIZINGTYPE st = ST_TRUESIZE;
            hr = GetThemeInt( hTheme, WP_MINCAPTION, FS_ACTIVE, TMT_SIZINGTYPE, (int*)&st );

            if( ST_TRUESIZE == st )
            {
                hr = GetThemePartSize( hTheme, NULL, WP_MINCAPTION, FS_ACTIVE, NULL, 
                                       TS_TRUE, &pnctm->sizeMinimized );

                if( FAILED(hr) )
                {
                    GetThemeMetric( hTheme, NULL, WP_MINCAPTION, FS_ACTIVE, TMT_WIDTH,
                                    (int*)&pnctm->sizeMinimized.cx );
                    GetThemeMetric( hTheme, NULL, WP_MINCAPTION, FS_ACTIVE, TMT_HEIGHT,
                                    (int*)&pnctm->sizeMinimized.cy );
                }
            }

            //  -- normal nonclient button size.
            int cy = NcGetSystemMetrics( SM_CYSIZE );
            hr = GetThemePartSize( pnctm->hTheme, NULL, WP_CLOSEBUTTON, 0, NULL, TS_TRUE, &pnctm->sizeBtn );
            if( SUCCEEDED(hr) )
            {
                pnctm->theme_sysmets.cxBtn = MulDiv( cy, pnctm->sizeBtn.cx, pnctm->sizeBtn.cy );
            }
            else
            {
                pnctm->theme_sysmets.cxBtn = 
                pnctm->sizeBtn.cx = NcGetSystemMetrics( SM_CXSIZE );
                
                pnctm->sizeBtn.cy = cy;
            }
          
            //  -- toolframe nonclient button size.
            cy = NcGetSystemMetrics( SM_CYSMSIZE );
            hr = GetThemePartSize( pnctm->hTheme, NULL, WP_SMALLCLOSEBUTTON, 0, NULL, TS_TRUE, &pnctm->sizeSmBtn );
            if( SUCCEEDED(hr) )
            {
                pnctm->theme_sysmets.cxSmBtn = MulDiv( cy, pnctm->sizeSmBtn.cx, pnctm->sizeSmBtn.cy );
            }
            else
            {
                pnctm->theme_sysmets.cxSmBtn = 
                pnctm->sizeSmBtn.cx = NcGetSystemMetrics( SM_CXSMSIZE );

                pnctm->sizeSmBtn.cy = cy;
            }
            
            //  -- validate sysmet hook values
            pnctm->theme_sysmets.fValid = TRUE;

            //  dialog background for dialogs parented by PROPSHEETs or
            //  specifically stamped via EnableThemeDialogTexture to match the tab control background.
            //
            // We need to open the tab control's theme so that we can get the background of tab dialogs
            // We can't dynamically load this because of how this cache is set up: It's all or nothing.
            pnctm->hThemeTab = ::OpenThemeData(hwnd, L"Tab");
            _GetBrushesForPart(pnctm->hThemeTab, TABP_BODY, &pnctm->hbmTabDialog, &pnctm->hbrTabDialog);

            hr = _LoadNcThemeSysMetrics( hwnd, pnctm );
        }
    }

    return hr;
}

//-------------------------------------------------------------------------//
BOOL IsValidNcThemeMetrics( NCTHEMEMET* pnctm )
{
    return pnctm->hTheme != NULL;
}

//-------------------------------------------------------------------------//
//  THREADWINDOW implementation
//-------------------------------------------------------------------------//
//
//  Note: this is a fixed length array of threads-window mappings.
//  We'll use this to keep track of the threads processing a certain message
//
//  Thread local storage would be better suited to the task, but we
//  learned early on that the unique load/unload situation of uxtheme
//  causes us to miss DLL_THREAD_DETACH in some scenarios, which would mean
//  leaking the TLS.
//

typedef struct _THREADWINDOW
{
    DWORD dwThread;
    HWND  hwnd;

} THREADWINDOW;

//-------------------------------------------------------------------------//
//  WM_NCPAINT tracking:
THREADWINDOW _rgtwNcPaint[16] = {0}; // threads processing NCPAINT in this process
int          _cNcPaintWnd = 0;       // count of threads processing NCPAINT in this process
CRITICAL_SECTION _csNcPaint = {0};   // serializes access to _rgtwNcPaint

//-------------------------------------------------------------------------//
void NcPaintWindow_Add( HWND hwnd )
{
    //  add entry to our list of threads handling WM_NCPAINT.
    if( VALID_CRITICALSECTION(&_csNcPaint) )
    {
        EnterCriticalSection( &_csNcPaint );
        for( int i = 0; i < ARRAYSIZE(_rgtwNcPaint); i++ )
        {
            if( 0 == _rgtwNcPaint[i].dwThread )
            {
                _rgtwNcPaint[i].dwThread = GetCurrentThreadId();
                _rgtwNcPaint[i].hwnd = hwnd;
                _cNcPaintWnd++;
            }
        }
        LeaveCriticalSection( &_csNcPaint );
    }
}

//-------------------------------------------------------------------------//
void NcPaintWindow_Remove()
{
    //  remove entry from our list of threads handling WM_NCPAINT.
    if( _cNcPaintWnd )
    {
        DWORD dwThread = GetCurrentThreadId();

        if( VALID_CRITICALSECTION(&_csNcPaint) )
        {
            EnterCriticalSection( &_csNcPaint );
            for( int i = 0; i < ARRAYSIZE(_rgtwNcPaint); i++ )
            {
                if( dwThread == _rgtwNcPaint[i].dwThread )
                {
                    _rgtwNcPaint[i].dwThread = 0;
                    _rgtwNcPaint[i].hwnd = 0;
                    _cNcPaintWnd--;
                    break;
                }
            }  
            LeaveCriticalSection( &_csNcPaint );
        }
    }
}

//-------------------------------------------------------------------------//
HWND NcPaintWindow_Find()
{
    HWND  hwnd = NULL;

    //  Search entries in our list of threads handling WM_NCPAINT.
    if( _cNcPaintWnd )
    {
        DWORD dwThread = GetCurrentThreadId();

        if( VALID_CRITICALSECTION(&_csNcPaint) )
        {
            EnterCriticalSection( &_csNcPaint );
            for( int i = 0; i < ARRAYSIZE(_rgtwNcPaint); i++ )
            {
                if( dwThread == _rgtwNcPaint[i].dwThread )
                {
                    hwnd = _rgtwNcPaint[i].hwnd;
                    break;
                }
            }
            LeaveCriticalSection( &_csNcPaint );
        }
    }
    return hwnd;
}

//-------------------------------------------------------------------------//
//  CThemeWnd implementation
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
LONG CThemeWnd::_cObj = 0;

//-------------------------------------------------------------------------//
CThemeWnd::CThemeWnd()
    :   _hwnd(NULL),
        _hTheme(NULL),
        _dwRenderedNcParts(0),
        _hwndMDIClient(NULL),
        _hAppIcon(NULL),
        _hrgnWnd(NULL),
        _fClassFlags(0),
        _fDirtyFrameRgn(0),
        _fFrameThemed(FALSE),
        _fThemedMDIBtns(FALSE),
        _pMdiBtns(NULL),
        _fAssigningFrameRgn(FALSE),
        _fAssignedFrameRgn(FALSE),
        _fSuppressStyleMsgs(FALSE),
        _fInThemeSettingChange(FALSE),
        _fDetached(FALSE),
        _dwRevokeFlags(0),
        _cLockRedraw(0),
        _cNcPaint(0),
        _cNcThemePaint(0),
        _htHot(HTERROR),
        _fProcessedEraseBk(0),
#ifdef LAME_BUTTON
        _hFontLame(NULL),
#endif // LAME_BUTTON
        _cRef(1)
{
    InterlockedIncrement( &_cObj );

    //  set object validation signature tags
    StringCchCopyA(_szHead, ARRAYSIZE(_szHead), SIG_CTHEMEWND_HEAD); 
    StringCchCopyA(_szTail, ARRAYSIZE(_szTail), SIG_CTHEMEWND_TAIL);

    //  cached subregion arrays
    ZeroMemory( _rghrgnParts, sizeof(_rghrgnParts) );
    ZeroMemory( _rghrgnSizingTemplates, sizeof(_rghrgnSizingTemplates) );
    
    //  initialize add'l structures.
    InitWindowMetrics();
    ZeroMemory(&_cswm, sizeof(_cswm));
    FillMemory(&_sizeRgn, sizeof(_sizeRgn), 0xFF);

#ifdef DEBUG
    *_szCaption = *_szWndClass = 0;
#endif DEBUG
}

//-------------------------------------------------------------------------//
CThemeWnd::~CThemeWnd()
{
    _CloseTheme();
    _FreeRegionHandles();
    UnloadMdiBtns();
    ClearLameResources();

    SAFE_DELETECRITICALSECTION(&_cswm);
    ASSERT( 0 != _cObj );
    InterlockedDecrement( &_cObj );
}

//-------------------------------------------------------------------------//
void CThemeWnd::_CloseTheme()
{
    if( _hTheme )
    {
        CloseThemeData(_hTheme);
        _hTheme = NULL;
    }
}    

//-------------------------------------------------------------------------//
LONG CThemeWnd::AddRef()
{
    return InterlockedIncrement( &_cRef );
}

//-------------------------------------------------------------------------//
LONG CThemeWnd::Release()
{
    ASSERT( 0 != _cRef );
    LONG cRef = InterlockedDecrement( &_cRef );

    if( 0 == cRef )
    {
        if (_hwnd)
        {
            //---- check if last window of app ----
            ShutDownCheck(_hwnd);
        }

        //Log(LOG_RFBUG, L"DELETING CThemeWnd=0x%08x", this);
        delete this;
    }
    return cRef;
}

//-------------------------------------------------------------------------//
ULONG CThemeWnd::EvaluateWindowStyle( HWND hwnd )
{
    ULONG dwStyle   = GetWindowLong( hwnd, GWL_STYLE );
    ULONG dwExStyle = GetWindowLong( hwnd, GWL_EXSTYLE );

    return EvaluateStyle( dwStyle, dwExStyle );
}

//-------------------------------------------------------------------------//
//  CThemeWnd::EvaluateStyle() - determines appropriate theming flags for the
//  specified window style bits.
ULONG CThemeWnd::EvaluateStyle( DWORD dwStyle, DWORD dwExStyle )
{
    ULONG fClassFlags = 0;

    //--- frame check ---
    if( HAS_CAPTIONBAR(dwStyle) )
    {
        fClassFlags |=
            (TESTFLAG(dwExStyle, WS_EX_TOOLWINDOW) ? TWCF_TOOLFRAME : TWCF_FRAME );
    }

    //--- client edge check ---
    if( TESTFLAG(dwExStyle, WS_EX_CLIENTEDGE) )
        fClassFlags |= TWCF_CLIENTEDGE;

    //--- scrollbar check ---
    if( TESTFLAG(dwStyle, WS_HSCROLL|WS_VSCROLL) )
        fClassFlags |= TWCF_SCROLLBARS;

    return fClassFlags;
}

//-------------------------------------------------------------------------//
//  CThemeWnd::_EvaluateExclusions() - determines special-case per-window exclusions
ULONG CThemeWnd::_EvaluateExclusions( HWND hwnd, NCEVALUATE* pnce )
{
    //  Windows parented by HWND_MESSAGE should not be themed..
    if( _IsMessageWindow(hwnd) )
    {
        pnce->fExile = TRUE;
        return 0L;
    }

    TCHAR szWndClass[128];
    *szWndClass = 0;


    if( TESTFLAG(pnce->fClassFlags, (TWCF_FRAME|TWCF_TOOLFRAME)) )
    {
        do
        {
            if( !pnce->fIgnoreWndRgn )
            {
                //--- Complex region check on frame
                RECT rcRgn = {0};
                int  nRgn = GetWindowRgnBox( hwnd, &rcRgn );
                if( COMPLEXREGION == nRgn || SIMPLEREGION == nRgn )
                {
                    pnce->fClassFlags &= ~TWCF_FRAME;
                    break;
                }
            }

//  SHIMSHIM [scotthan]:
#ifndef __NO_APPHACKS__
            //  Check for excluded window classes.
            static LPCWSTR _rgExcludedClassesW[]  = 
            { 
                L"MsoCommandBar",   //  Outlook's custom combobox control.
                                    // (122225) In OnOwpPostCreate we call SetWindowPos which causes
                                    // a WM_WINDOWPOSCHANGING to be sent to the control. However
                                    // the controls isn't ready to begin accepting messages and
                                    // the following error message is display:
                                    //
                                    // Runtime Error!
                                    // Program: Outlook.exe
                                    // R6025 - pure virtual function call

                L"Exceed",          // 150248: Hummingbird Exceed 6.xx 
                                    // The application's main window class name, a hidden window 
                                    // whose only purpose is to appear in the task bar in order to handle
                                    // his context menu. The ExceedWndProc AVs when themed due to the
                                    // additional messages generated in OnOwpPostCreate.

                //---- winlogoon hidden windows ----
                L"NDDEAgnt",            // on private desktop
                L"MM Notify Callback",  // on private desktop
                L"SAS window class",    // on private desktop
            };

            if( GetClassNameW( hwnd, szWndClass, ARRAYSIZE(szWndClass) )  &&
                AsciiScanStringList( szWndClass, _rgExcludedClassesW, 
                                ARRAYSIZE(_rgExcludedClassesW), TRUE ) )
            {
                pnce->fClassFlags &= ~TWCF_FRAME;
                pnce->fExile = TRUE;
                break;
            }
#endif __NO_APPHACKS__
        
        } while(0);
    }

    // Some applications (MsDev) create scrollbar controls and incorrectly include
    // WS_[V|H]SCROLL style bits causing us to think they are non-client scrolls. 
    // See #204191.
    if( TESTFLAG(pnce->fClassFlags, TWCF_SCROLLBARS) )
    {
        if( !*szWndClass && GetClassName( hwnd, szWndClass, ARRAYSIZE(szWndClass) ) )
        {
            if( 0 == AsciiStrCmpI(szWndClass, L"scrollbar") )
                pnce->fClassFlags &= ~TWCF_SCROLLBARS;
        }
    }

//  Fixed in longhorn [phellyar]:
#ifndef __NO_APPHACKS__
    if( *szWndClass || GetClassName( hwnd, szWndClass, ARRAYSIZE(szWndClass) ) )
    {
        // 453888: VB Grid control - setting the redraw property on this control
        // causes it to zero and reset the scrollbar range for every scroll event.
        // This causes the scrollbar to function incorrecly when themed.
        if( 0 == AsciiStrCmpI(szWndClass, L"MSFlexGridWndClass") )
        {
            pnce->fClassFlags &= ~TWCF_SCROLLBARS;
            pnce->fExile = TRUE;
        }
    }
#endif __NO_APPHACKS__

    return pnce->fClassFlags;

}

//-------------------------------------------------------------------------//
//  CThemeWnd::_Evaluate() - determines appropriate theming flags for the
//  specified window.
ULONG CThemeWnd::_Evaluate( HWND hwnd, NCEVALUATE* pnce )
{
    pnce->fClassFlags = 0;
    pnce->dwStyle   = GetWindowLong( hwnd, GWL_STYLE );
    pnce->dwExStyle = GetWindowLong( hwnd, GWL_EXSTYLE );

    if( GetClassLong( hwnd, GCW_ATOM ) == (DWORD)(DWORD_PTR)WC_DIALOG )
    {
        pnce->fClassFlags |= TWCF_DIALOG;
    }
    

#ifdef DEBUG
    //--- dialog check ---
    if( TESTFLAG( pnce->fClassFlags, TWCF_DIALOG ) )
    {
        TCHAR szWndClass[96];
        if( !GetClassNameW( hwnd, szWndClass, ARRAYSIZE(szWndClass) ) )
            return 0;
        ASSERT(0 == lstrcmpW(szWndClass, DLGWNDCLASSNAMEW));
    }
#endif DEBUG

    pnce->fClassFlags |= EvaluateStyle( pnce->dwStyle, pnce->dwExStyle );

    if( pnce->fClassFlags )
    {
        pnce->fClassFlags = _EvaluateExclusions( hwnd, pnce );
    }

    return pnce->fClassFlags;
}

//-------------------------------------------------------------------------//
//  Retrieves the address of the CThemeWnd object instance from the
//  indicated window.
CThemeWnd* CThemeWnd::FromHwnd( HWND hwnd )
{
    CThemeWnd *pwnd = NULL;

    if( IsWindow(hwnd) )
    {
        if( g_dwProcessId )
        {
            DWORD dwPid = 0;
            GetWindowThreadProcessId( hwnd, &dwPid );
            if( dwPid == g_dwProcessId )
            {
                pwnd = (CThemeWnd*)GetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)) );

                if ( VALID_THEMEWND(pwnd) )
                {
                    // verify this is a valid CThemeWnd object pointer
                    if ( IsBadReadPtr(pwnd, sizeof(CThemeWnd)) ||
                         (memcmp(pwnd->_szHead, SIG_CTHEMEWND_HEAD, ARRAYSIZE(pwnd->_szHead)) != 0) ||
                         (memcmp(pwnd->_szTail, SIG_CTHEMEWND_TAIL, ARRAYSIZE(pwnd->_szTail)) != 0) )
                    {
                        pwnd = THEMEWND_REJECT;
                    }
                }
            }
        }
    }

    return pwnd;
}

//-------------------------------------------------------------------------//
//  retrieves CThemeWnd instance from window or ancestors.
CThemeWnd* CThemeWnd::FromHdc( HDC hdc, int cAncestors )
{
    HWND hwnd = NULL;

    for( hwnd = WindowFromDC(hdc); 
         cAncestors >=0 && IsWindow(hwnd); 
         cAncestors--, hwnd = GetParent(hwnd) )
    {
        CThemeWnd* pwnd = FromHwnd(hwnd);
        if( VALID_THEMEWND(pwnd) )
        {
            return pwnd;
        }
    }

    return NULL;
}

//-------------------------------------------------------------------------//
//  Static wrapper: attaches a CThemeWnd instance to the specified window.
CThemeWnd* CThemeWnd::Attach( HWND hwnd, IN OUT OPTIONAL NCEVALUATE* pnce )
{
    LogEntryNC(L"Attach");

#ifdef LOGGING
    //---- remember first window (app window) hooked for ShutDownCheck() ----
    //---- this is only for BoundsChecker (tm) runs for finding leaks ----
    if (! g_hwndFirstHooked)
    {
        if ((GetMenu(hwnd)) && (! GetParent(hwnd)))
            g_hwndFirstHooked = hwnd;
    }
#endif

    CThemeWnd* pwnd = NULL;

    //  Note: Important not to do anything here that causes
    //  a window message to be posted or sent to the window: could
    //  mean tying ourselves up in a recursive knot (see _ThemeDefWindowProc).

    pwnd = FromHwnd( hwnd );

    if( NULL == pwnd )
    {
        HTHEME hTheme = NULL;
        NCEVALUATE nce;

        //  copy any IN params from NCEVALUATE struct
        if( !pnce )
        {
            ZeroMemory(&nce, sizeof(nce));
            pnce = &nce;
        }

        ULONG  ulTargetFlags = _Evaluate( hwnd, pnce );

        //  Anything worth theming?
        if( TESTFLAG(ulTargetFlags, TWCF_NCTHEMETARGETMASK) )
        {
            hTheme = _AcquireThemeHandle( hwnd, &ulTargetFlags );
            if( NULL == hTheme )
            {
                Fail(hwnd);
            }
        }
        else
        {
            //  reject windows with untargeted a
            Reject(hwnd, pnce->fExile);
        }

        if( NULL != hTheme )
        {
            //  Yes, create a real nctheme object for the window
            if( (pwnd = new CThemeWnd) != NULL )
            {
                if( !pwnd->_AttachInstance( hwnd, hTheme, ulTargetFlags, pnce->pvWndCompat ) )
                {
                    pwnd->Release();
                    pwnd = NULL;
                }
            }
            else        // cleanup hTheme if CThemeWnd creation failed
            {
                CloseThemeData(hTheme);
            }
        }
    }

    LogExitNC(L"Attach");
    return pwnd;
}

//-------------------------------------------------------------------------//
//  Instance method: attaches the CThemeWnd object to the specified window.
BOOL CThemeWnd::_AttachInstance( HWND hwnd, HTHEME hTheme, ULONG ulTargetFlags, PVOID pvWndCompat )
{
    if( VALID_CRITICALSECTION(&_cswm) || NT_SUCCESS(RtlInitializeCriticalSection( &_cswm )) )
    {
        Log(LOG_NCATTACH, L"_AttachInstance: Nonclient attached to hwnd=0x%x", hwnd);

        _hwnd   = hwnd;
        _hTheme = hTheme;
        _fClassFlags = ulTargetFlags;

        _fFrameThemed = TESTFLAG( ulTargetFlags, TWCF_FRAME|TWCF_TOOLFRAME );
        return SetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)), this );
    }

    return FALSE;
}

//-------------------------------------------------------------------------//
void CThemeWnd::RemoveWindowProperties(HWND hwnd, BOOL fDestroying)
{
    //---- remove properties that require theme or hooks ----
    RemoveProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_HTHEME)));

    if (fDestroying)
    {
        // Help apps by cleaning up the dialog texture.
        RemoveProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_DLGTEXTURING)));

        //---- remove all remaining theme properties ----
        ApplyStringProp(hwnd, NULL, GetThemeAtom(THEMEATOM_SUBIDLIST));
        ApplyStringProp(hwnd, NULL, GetThemeAtom(THEMEATOM_SUBAPPNAME));

        //---- notify appinfo (foreign tracking, preview) ----
        g_pAppInfo->OnWindowDestroyed(hwnd);
    }
    else
    {
        //---- only do this if hwnd is not being destroyed ----
        ClearExStyleBits(hwnd);
    }
}
//-------------------------------------------------------------------------//
//  Static wrapper: detaches and destroys the CThemeWnd instance attached to the indicated
//  window
void CThemeWnd::Detach( HWND hwnd, DWORD dwDisposition )
{
    LogEntryNC(L"Detach");

    //  DO NOT GENERATE ANY WINDOW MESSAGES FROM THIS FUNCTION!!!
    //  (unless cleaning up frame).

    //  Prevent message threads from detaching when unhook thread (DetachAll) is executing...
    if( !UNHOOKING() || TESTFLAG(dwDisposition, HMD_BULKDETACH) )
    {
        CThemeWnd* pwnd = FromHwnd( hwnd );

        if( pwnd ) // nonclient tagged
        {
            if( VALID_THEMEWND(pwnd) )
            {
                //  only one thread flips the _fDetached bit and proceeds through
                //  instance detatch and object free.   Otherwise, object can be freed
                //  simultaneously on two different threads, 
                //  e.g. (1) message thread and (2) UIAH_UNHOOK thread (ouch! scotthan).
                if( !InterlockedCompareExchange( (LONG*)&pwnd->_fDetached, TRUE, FALSE ) )
                {
                    pwnd->_DetachInstance( dwDisposition );
                    pwnd->Release();
                }
            }
            else
            {
                RemoveProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)) );
            }
        }

        if (hwnd)
        {
            RemoveWindowProperties( hwnd, ((dwDisposition & HMD_WINDOWDESTROY) != 0) );
        }
    }

    LogExitNC(L"Detach");
}

//-------------------------------------------------------------------------//
//  Instance method: detaches the CThemeWnd object from the specified window.
BOOL CThemeWnd::_DetachInstance( DWORD dwDisposition )
{
    HWND hwnd = _hwnd;

    //  untheme maxed MDI child sysbuttons.
    ThemeMDIMenuButtons(FALSE, FALSE);

    //  Here's our last chance to ensure frame theme is withdrawn cleanly.
    if( (IsFrameThemed() || IsRevoked(RF_REGION)) && AssignedFrameRgn() && 
        !TESTFLAG(dwDisposition, HMD_PROCESSDETACH|HMD_WINDOWDESTROY))
    {
        RemoveFrameTheme( FTF_REDRAW );
    }

    //SPEW_THEMEWND( pwnd, 0, TEXT("UxTheme - Detaching and deleting themewnd: %s\n") );
    DetachScrollBars( hwnd );

    _hwnd = 
    _hwndMDIClient = NULL;

    UnloadMdiBtns();

    _CloseTheme();

    Log(LOG_NCATTACH, L"_DetachInstance: Nonclient detached to hwnd=0x%x", hwnd);

    RemoveProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)) );
    return TRUE;
}

//-------------------------------------------------------------------------//
// Ensures that the specified window will not be themed during its lifetime
BOOL CThemeWnd::Reject( HWND hwnd, BOOL fExile )
{
    //  set a 'nil' tag on the window
    return hwnd ? SetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)), 
                           fExile ? THEMEWND_EXILE : THEMEWND_REJECT ) : FALSE;
}

//-------------------------------------------------------------------------//
// Ensures that the specified window will not be themed during its lifetime
BOOL CThemeWnd::Fail( HWND hwnd )
{
    //  set a failure tag on the window
    return hwnd ? SetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)), 
                           THEMEWND_FAILURE ) : FALSE;
}

//-------------------------------------------------------------------------//
// Revokes theming on a themed window
BOOL CThemeWnd::Revoke()
{
    //  Warning Will Robinson:  After we detach, the CThemeWnd::_hwnd
    //  and related members will be reset, so save this on the stack.

    BOOL fRet = TRUE;
    HWND hwnd = _hwnd;

    if( !IsRevoked(RF_INREVOKE) )
    {
        EnterRevoke();
        _dwRevokeFlags &= ~RF_DEFER;
        Detach( hwnd, HMD_REVOKE );
        fRet = Reject( hwnd, TRUE );
        LeaveRevoke();
    }
    return fRet;
}

//-------------------------------------------------------------------------//
//  cookie passed to EnumChildWindows callback for CThemeWnd::DetachAll
typedef struct 
{
    DWORD dwProcessId;
    DWORD dwDisposition;
}DETACHALL;

//-------------------------------------------------------------------------//
//  EnumChildWindows callback for CThemeWnd::DetachAll
BOOL CThemeWnd::_DetachDesktopWindowsCB( HWND hwnd, LPARAM lParam )
{
    DETACHALL* pda = (DETACHALL*)lParam;

    //  detach this window
    if( IsWindowProcess( hwnd, pda->dwProcessId ) )
    {
        //---- clear the nonclient theme ----
        CThemeWnd::Detach(hwnd, HMD_THEMEDETACH|pda->dwDisposition);

        if( !TESTFLAG(pda->dwDisposition, HMD_PROCESSDETACH) )
        {
            //---- clear the client theme now, so that we can invalidate ----
            //---- all old theme handles after this.  ----
            SafeSendMessage(hwnd, WM_THEMECHANGED, (WPARAM)-1, 0);

            Log(LOG_TMHANDLE, L"Did SEND of WM_THEMECHANGED to client hwnd=0x%x", hwnd);
        }
    }

    return TRUE;
}

//-------------------------------------------------------------------------//
//  Detaches all themed windows managed by this process.
void CThemeWnd::DetachAll( DWORD dwDisposition )
{
    DETACHALL da;
    da.dwProcessId   = GetCurrentProcessId();
    da.dwDisposition = dwDisposition;
    da.dwDisposition |= HMD_BULKDETACH;

    //---- this will enum all windows for this process (all desktops, all child levels) ----
    EnumProcessWindows( _DetachDesktopWindowsCB, (LPARAM)&da );
}

//-------------------------------------------------------------------------//
HTHEME CThemeWnd::_AcquireThemeHandle( HWND hwnd, ULONG* pfClassFlags  )
{
    HTHEME hTheme = ::OpenNcThemeData( hwnd, L"Window" );

    if( NULL == hTheme )
    {
        if( pfClassFlags )
        {
            if( TESTFLAG(*pfClassFlags, TWCF_ANY) )
                (*pfClassFlags) &= ~TWCF_ALL;
            else
                *pfClassFlags = 0;
        }
    }

    //---- Did OpenNcThemeData() discover a new theme ----
    if (g_pAppInfo->HasThemeChanged())
    {
        //---- IMPORTANT: we must refresh our theme metrics now, ----
        //---- BEFORE we do our nonclient layout calcs & build a region window ----
        AcquireNcThemeMetrics();
    }

    return hTheme;
}

//-------------------------------------------------------------------------//
//  CThemeWnd::SetFrameTheme
//
//  Initiates theming of the frame.
void CThemeWnd::SetFrameTheme( 
    IN ULONG dwFlags,
    IN OPTIONAL WINDOWINFO* pwi )
{
    LogEntryNC(L"SetFrameTheme");

    ASSERT(TestCF( TWCF_FRAME|TWCF_TOOLFRAME ));
    InitLameResources();

    DWORD fSwp = SWP_NOZORDER|SWP_NOACTIVATE;
    RECT  rcWnd = {0};
    BOOL  bSwp = FALSE;

    if( !TESTFLAG( dwFlags, FTF_NOMODIFYPLACEMENT ) )
    {
        GetWindowRect( _hwnd, &rcWnd );
        fSwp |= (SWP_NOSIZE|SWP_NOMOVE/*|SWP_FRAMECHANGED 341700: this flag causes some apps to crash on WINDOWPOSCHANGED*/);
        bSwp = TRUE;
    }

    //  Generate a WM_WINDOWPOSCHANGING message to
    //  force a SetWindowRgn + frame repaint.
    if( TESTFLAG(dwFlags, FTF_REDRAW) )
    {
        fSwp |= SWP_DRAWFRAME;
    }
    else
    {
        fSwp |= SWP_NOSENDCHANGING;
    }

    //  theme MDI menubar buttons
    _hwndMDIClient = _FindMDIClient(_hwnd);
    if( _hwndMDIClient )
    {
        ThemeMDIMenuButtons(TRUE, FALSE);
    }

    //  Kick frame region update.
    _fFrameThemed = TRUE;         // we invoked SetFrameTheme.  Must be set BEFORE SetWindowPos.so we handle NCCALCSIZE properly.
    SetDirtyFrameRgn(TRUE, TRUE); // ensure region assembly on non-resizing windows and dlgs.

    if( !TESTFLAG( dwFlags, FTF_NOMODIFYPLACEMENT ) && bSwp )
    {
        _ScreenToParent( _hwnd, &rcWnd );
        SetWindowPos( _hwnd, NULL, rcWnd.left, rcWnd.top,
                      RECTWIDTH(&rcWnd), RECTHEIGHT(&rcWnd), fSwp );
    }

    LogExitNC(L"SetFrameTheme");
}

//-------------------------------------------------------------------------//
void CThemeWnd::_FreeRegionHandles() 
{ 
#ifdef DEBUG
    if( _hrgnWnd )
    {
        SPEW_RGNRECT(NCTF_RGNWND, TEXT("_FreeRegionHandles() - deleting window region"), _hrgnWnd, -1 );
    }
#endif DEBUG

    SAFE_DELETE_GDIOBJ(_hrgnWnd);

    for( int i = 0; i < cFRAMEPARTS; i++ )
    {
#ifdef DEBUG
        if( _rghrgnParts[i] )
        {
            SPEW_RGNRECT(NCTF_RGNWND, TEXT("_FreeRegionHandles() - deleting component region"), _rghrgnParts[i], _ncwm.rgframeparts[i] );
        }

        if( _rghrgnSizingTemplates[i] )
        {
            SPEW_RGNRECT(NCTF_RGNWND, TEXT("_FreeRegionHandles() - deleting template region"), _rghrgnSizingTemplates[i], _ncwm.rgframeparts[i] );
        }
#endif DEBUG

        SAFE_DELETE_GDIOBJ(_rghrgnParts[i]);
        SAFE_DELETE_GDIOBJ(_rghrgnSizingTemplates[i]);
    }
}

//-------------------------------------------------------------------------//
//  CThemeWnd::RemoveFrameTheme
//
//  Initiates theming of the frame.    This method will not free the
//  theme handle nor update the theme index.
void CThemeWnd::RemoveFrameTheme( ULONG dwFlags )
{
    LogEntryNC(L"RemoveFrameTheme");

    ASSERT(TestCF( TWCF_FRAME|TWCF_TOOLFRAME ));

    _fFrameThemed = FALSE; // we're reverting SetFrameTheme
    ClearRenderedNcPart(RNCF_ALL);

    //  Remove region
    if( AssignedFrameRgn() && !TESTFLAG(dwFlags, FTF_NOMODIFYRGN) )
    {
        _fAssignedFrameRgn = FALSE;
        _AssignRgn( NULL, dwFlags );
        _FreeRegionHandles();
    }

    //  Force redraw
    if( TESTFLAG(dwFlags, FTF_REDRAW) )
        InvalidateRect( _hwnd, NULL, TRUE );

    ClearLameResources();

    LogExitNC(L"RemoveFrameTheme");
}

//-------------------------------------------------------------------------//
BOOL CThemeWnd::IsNcThemed()
{
    if( _hTheme != NULL && (IsRevoked(RF_DEFER) || !IsRevoked(RF_INREVOKE|RF_TYPEMASK)) &&
        TestCF(TWCF_ANY & TWCF_NCTHEMETARGETMASK) )
    {
        if( TestCF(TWCF_FRAME|TWCF_TOOLFRAME) )
        {
            //  if we're a frame window, we should be properly initialized
            //  w/ SetFrameTheme()
            return _fFrameThemed;
        }

        return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL CThemeWnd::IsFrameThemed()
{
    return IsNcThemed() && _fFrameThemed &&
           (AssignedFrameRgn() ? TRUE : TestCF( TWCF_FRAME|TWCF_TOOLFRAME ));
}

//-------------------------------------------------------------------------//
void CThemeWnd::SetDirtyFrameRgn( BOOL fDirty, BOOL fFrameChanged )
{ 
    _fDirtyFrameRgn = fDirty; 

    Log(LOG_NCATTACH, L"SetDirtyFrameRgn: fDirty=%d, fFrameChanged=%d", 
        fDirty, fFrameChanged);
    
    if( fFrameChanged )  // assure a region update despite no size change.
    {
        _sizeRgn.cx = _sizeRgn.cy = -1; 
    }
}

//-------------------------------------------------------------------------//
//  CThemeWnd::CreateCompositeRgn() - assembles a composite region from
//  non-client segment regions sized to fill the specified window rectangle.
//
HRGN CThemeWnd::CreateCompositeRgn( 
    IN const NCWNDMET* pncwm,
    OUT HRGN rghrgnParts[],
    OUT HRGN rghrgnTemplates[] )
{
    ASSERT( pncwm->fFrame == TRUE ); // shouldn't be here unless we're a frame window

    HRGN hrgnWnd = NULL, hrgnContent = NULL;
    HRGN rghrgn[cFRAMEPARTS] = {0};
    int  i;

    if( pncwm->fFullMaxed )
    {
        //  All full-screen maximized windows get a region, which is used to clip
        //  the window to the current monitor.   The window region for a maximized
        //  window consists of the maxcaption region combined with a rect region
        //  corresponding to the content area.
        RECT rcFullCaption  = pncwm->rcW0[NCRC_CAPTION];
        rcFullCaption.top   += pncwm->cnBorders;
        rcFullCaption.left  += pncwm->cnBorders;
        rcFullCaption.right -= pncwm->cnBorders;
        
        if( SUCCEEDED(GetThemeBackgroundRegion(_hTheme, NULL, pncwm->rgframeparts[iCAPTION], pncwm->framestate,
                                               &rcFullCaption, &rghrgn[iCAPTION])) )
        {
            SPEW_RGNRECT(NCTF_RGNWND, TEXT("CreateCompositeRgn() maximized caption rgn"), rghrgn[iCAPTION], pncwm->rgframeparts[iCAPTION] );
            AddToCompositeRgn(&hrgnWnd, rghrgn[iCAPTION], 0, 0);
        
            if( !IsRectEmpty( &pncwm->rcW0[NCRC_CONTENT] ) )
            {
                //  remainder of full-maxed frame region is the content area (client+menubar+scrollbars),
                //  and is always rectangular
                hrgnContent = CreateRectRgnIndirect( &pncwm->rcW0[NCRC_CONTENT] );
                SPEW_RGNRECT(NCTF_RGNWND, TEXT("CreateCompositeRgn() maximized frame content rgn"), hrgnContent, 0 );

                AddToCompositeRgn(&hrgnWnd, hrgnContent, 0, 0);
    	        SAFE_DELETE_GDIOBJ(hrgnContent);
            }
        }
    }
    else
    {
        //  Normal windows consist of either a stand-alone frame part, or a frame
        //  part plus a caption part.   In the first case, the window region is
        //  the frame region.   In the second case, the window region is a composite
        //  of the frame and caption rects.

        for( i = 0; i < ARRAYSIZE(pncwm->rgframeparts); i++ )
        {
            if( (iCAPTION == i || !pncwm->fMin) && !IsRectEmpty( &pncwm->rcW0[NCRC_FRAMEFIRST + i] ) )
            {
                if( _IsNcPartTransparent(pncwm->rgframeparts[i], _nctmCurrent) )
                {
                    if( FAILED(GetThemeBackgroundRegion( _hTheme, NULL, pncwm->rgframeparts[i], pncwm->framestate,
                                                         &pncwm->rcW0[NCRC_FRAMEFIRST+i], &rghrgn[i] )) )
                    {
                        rghrgn[i] = NULL;
                    }
                }
                else
                {
                    rghrgn[i] = CreateRectRgnIndirect( &pncwm->rcW0[NCRC_FRAMEFIRST + i] );
                }
            }

            if( rghrgn[i] != NULL )
            {
                SPEW_RGNRECT(NCTF_RGNWND, TEXT("CreateCompositeRgn() frame subrgn"), rghrgn[i], pncwm->rgframeparts[i] );
                AddToCompositeRgn(&hrgnWnd, rghrgn[i], 0, 0);
            }
        }

        //  don't forget window content area (client+menubar+scrollbars), which is always rectangular
        if( !pncwm->fMin && !IsRectEmpty( &pncwm->rcW0[NCRC_CONTENT] ) )
        {
            hrgnContent = CreateRectRgnIndirect( &pncwm->rcW0[NCRC_CONTENT] );
            SPEW_RGNRECT(NCTF_RGNWND, TEXT("CreateCompositeRgn() normal frame content rgn"), hrgnContent, 0 );

            AddToCompositeRgn(&hrgnWnd, hrgnContent, 0, 0);
    	    SAFE_DELETE_GDIOBJ(hrgnContent)