v)
    {
        CoTaskMemFree(pv);
    }
}

HRESULT DupString(LPCWSTR pszSrc, LPWSTR* ppszDest)
{
    HRESULT hres;
    DWORD cch = lstrlen(pszSrc) + 1;
    *ppszDest = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));

    if (*ppszDest)
    {
        // This should not fail
        SHOULDNOTFAIL(SUCCEEDED(StringCchCopy(*ppszDest, cch, pszSrc)));
        
        hres = S_OK;
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _GetDeviceInstance(LPCWSTR pszDeviceIntfID, DEVINST* pdevinst,
    GUID* pguidInterface)
{
    HRESULT hres = S_FALSE;

    // not thread safe
    static WCHAR szDeviceIntfIDLast[MAX_DEVICEID] = TEXT("");
    static DEVINST devinstLast;
    static GUID guidInterfaceLast;

    // Cached
    if (!lstrcmpi(szDeviceIntfIDLast, pszDeviceIntfID))
    {
        // Yep
        *pdevinst = devinstLast;
        *pguidInterface = guidInterfaceLast;

        hres = S_OK;
    }
    else
    {
        // No
        HDEVINFO hdevinfo = SetupDiCreateDeviceInfoList(NULL, NULL);

        *pdevinst = NULL;

        if (INVALID_HANDLE_VALUE != hdevinfo)
        {
            SP_DEVICE_INTERFACE_DATA sdid = {0};

            sdid.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

            if (SetupDiOpenDeviceInterface(hdevinfo, pszDeviceIntfID, 0, &sdid))
            {
                DWORD cbsdidd = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                    (MAX_DEVICE_ID_LEN * sizeof(WCHAR));

                SP_DEVINFO_DATA sdd = {0};
                SP_DEVICE_INTERFACE_DETAIL_DATA* psdidd =
                    (SP_DEVICE_INTERFACE_DETAIL_DATA*)LocalAlloc(LPTR, cbsdidd);

                if (psdidd)
                {
                    psdidd->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                    sdd.cbSize = sizeof(SP_DEVINFO_DATA);

                    // SetupDiGetDeviceInterfaceDetail (below) requires that the
                    // cbSize member of SP_DEVICE_INTERFACE_DETAIL_DATA be set
                    // to the size of the fixed part of the structure, and to pass
                    // the size of the full thing as the 4th param.

                    if (SetupDiGetDeviceInterfaceDetail(hdevinfo, &sdid, psdidd,
                        cbsdidd, NULL, &sdd))
                    {
                        *pdevinst = sdd.DevInst;
                        *pguidInterface = sdid.InterfaceClassGuid;

                        hres = S_OK;
                    }

                    LocalFree((HLOCAL)psdidd);
                }

                SetupDiDeleteDeviceInterfaceData(hdevinfo, &sdid);
            }

            SetupDiDestroyDeviceInfoList(hdevinfo);
        }

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            // Cache it
            if (SUCCEEDED(SafeStrCpyN(szDeviceIntfIDLast, pszDeviceIntfID,
                ARRAYSIZE(szDeviceIntfIDLast))))
            {
                devinstLast = *pdevinst;
                guidInterfaceLast = *pguidInterface;
            }
            else
            {
                szDeviceIntfIDLast[0] = 0;
            }
        }
        else
        {
            szDeviceIntfIDLast[0] = 0;
        }
    }

    return hres;
}

HRESULT _GetDeviceInstanceFromDevNode(LPCWSTR pszDeviceNode, DEVINST* pdevinst)
{
    HRESULT hres = S_FALSE;
    HDEVINFO hdevinfo = SetupDiCreateDeviceInfoList(NULL, NULL);

    *pdevinst = NULL;

    if (INVALID_HANDLE_VALUE != hdevinfo)
    {
        SP_DEVINFO_DATA sdd = {0};
        sdd.cbSize = sizeof(SP_DEVINFO_DATA);

        if (SetupDiOpenDeviceInfo(hdevinfo, pszDeviceNode, NULL, 0, &sdd))
        {
            *pdevinst = sdd.DevInst;
            hres = S_OK;
        }

        SetupDiDestroyDeviceInfoList(hdevinfo);
    }

    return hres;
}


///////////////////////////////////////////////////////////////////////////////
//
void CHWEventDetectorHelper::TraceDiagnosticMsg(LPWSTR pszMsg, ...)
{
    WCHAR szBuf[2048];
    LPWSTR pszNext;
    size_t cchLeft;

    HRESULT hr = StringCchPrintfEx(szBuf, ARRAYSIZE(szBuf), &pszNext, &cchLeft,
        0, TEXT("~0x%08X~"), GetCurrentThreadId());
        
    if (SUCCEEDED(hr))
    {
        va_list vArgs;
        
        va_start(vArgs, pszMsg);
        
        hr = StringCchVPrintfEx(pszNext, cchLeft, &pszNext, &cchLeft, 0, pszMsg,
            vArgs);
            
        if (SUCCEEDED(hr))
        {
            hr = StringCchPrintf(pszNext, cchLeft, TEXT("\r\n"));        
        }
        
        va_end(vArgs);
    }

#ifndef FEATURE_USELIVELOGGING
    WriteToLogFileW(szBuf);
#else // FEATURE_USELIVELOGGING
    CallNamedPipe(TEXT("\\\\.\\pipe\\ShellService_Diagnostic"), szBuf,
        cch * sizeof(WCHAR), NULL, 0, NULL, NMPWAIT_NOWAIT);
#endif // FEATURE_USELIVELOGGING
}


//static
HRESULT CHWEventDetectorHelper::CheckDiagnosticAppPresence()
{
    DWORD dwNow = GetTickCount();
    BOOL fPerformCheckNow = FALSE;

    if (dwNow < _dwDiagAppLastCheck)
    {
        // We wrapped, or init case of -1
        fPerformCheckNow = TRUE;
    }
    else
    {
        if (dwNow > (_dwDiagAppLastCheck + 15 * 1000))
        {
            fPerformCheckNow = TRUE;
        }
    }

    if (fPerformCheckNow)
    {
#ifndef FEATURE_USELIVELOGGING
        DWORD dwType;
        DWORD dwUseLogFile = 0;
        DWORD cbSize = sizeof(dwUseLogFile);
        BOOL fReCheck = ((ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Services\\ShellHWDetection"), TEXT("LogFile"), &dwType, (void *)&dwUseLogFile, &cbSize)) &&
                  (REG_DWORD == dwType) &&
                  (sizeof(dwUseLogFile) == cbSize) &&
                  (0 != dwUseLogFile));
#else // FEATURE_USELIVELOGGING
        HANDLE hEvent = OpenEvent(SYNCHRONIZE, FALSE,
            TEXT("ShellService_Diagnostic"));

        BOOL fReCheck = hEvent;

        CloseHandle(hEvent);
#endif // FEATURE_USELIVELOGGING

        if (fReCheck)
        {
            // Yep, it's there!
            if (!_fDiagnosticAppPresent)
            {
                TRACE(TF_SHHWDTCTDTCT, TEXT("Diagnostic App appeared!"));
            }

            _fDiagnosticAppPresent = TRUE;
        }
        else
        {
            if (_fDiagnosticAppPresent)
            {
                TRACE(TF_SHHWDTCTDTCT, TEXT("Diagnostic App disappeared!"));
            }

            _fDiagnosticAppPresent = FALSE;
        }

        _dwDiagAppLastCheck = dwNow;
    }

    return S_OK;
}

//static
HRESULT CHWEventDetectorHelper::SetServiceStatusHandle(
    SERVICE_STATUS_HANDLE ssh)
{
    _ssh = ssh;

    return S_OK;
}

//static
HRESULT CHWEventDetectorHelper::GetList(HWEDLIST hwedlist,
    CNamedElemList** ppnel)
{
    HRESULT hres;
    CNamedElemList* pnel = _rgpnel[hwedlist];

    if (pnel)
    {
        pnel->RCAddRef();
    }

    *ppnel = pnel;

    hres = *ppnel ? S_OK : E_FAIL;

    if (S_FALSE == hres)
    {
        TRACE(TF_SHHWDTCTDTCT, TEXT("CHWEventDetectorHelper::GetList S_FALSE'd"));
    }

    return hres;
}

//static
HRESULT CHWEventDetectorHelper::DeleteLists()
{
    for (DWORD dw = 0; dw < ARRAYSIZE(_rgpnel); ++dw)
    {
        if (_rgpnel[dw])
        {
            _rgpnel[dw]->EmptyList();

            _rgpnel[dw]->RCRelease();
            _rgpnel[dw] = NULL;
        }
    }

    _fListCreated = FALSE;

    return S_OK;
}

//static
HRESULT CHWEventDetectorHelper::CreateLists()
{
    HRESULT hres = S_FALSE;

    if (!_fListCreated)
    {
        for (DWORD dw = 0; SUCCEEDED(hres) && (dw < ARRAYSIZE(_rgpnel)); ++dw)
        {
            _rgpnel[dw] = new CNamedElemList();

            if (!_rgpnel[dw])
            {
                hres = E_OUTOFMEMORY;

                // should RCRelease the already allocated ones
            }
        }

        if (SUCCEEDED(hres))
        {
            // Initialize them ALL first
            hres = _rgpnel[HWEDLIST_HANDLENOTIF]->Init(
                CHandleNotif::Create, NULL);

            if (SUCCEEDED(hres))
            {
                hres = _rgpnel[HWEDLIST_VOLUME]->Init(CVolume::Create,
                    CVolume::GetFillEnum);
            }

            if (SUCCEEDED(hres))
            {
                hres = _rgpnel[HWEDLIST_DISK]->Init(
                    CDisk::Create, CDisk::GetFillEnum);
            }

            if (SUCCEEDED(hres))
            {
                hres = _rgpnel[HWEDLIST_MISCDEVINTF]->Init(
                    CMiscDeviceInterface::Create, NULL);
            }

            if (SUCCEEDED(hres))
            {
                hres = _rgpnel[HWEDLIST_MISCDEVNODE]->Init(
                    CMiscDeviceNode::Create, NULL);
            }

            if (SUCCEEDED(hres))
            {
                hres = _rgpnel[HWEDLIST_MTPT]->Init(CMtPt::Create, NULL);
            }

            if (SUCCEEDED(hres))
            {
                hres = _rgpnel[HWEDLIST_ADVISECLIENT]->Init(CAdviseClient::Create, NULL);
            }

#ifdef DEBUG
            if (SUCCEEDED(hres))
            {
                _rgpnel[HWEDLIST_HANDLENOTIF]->InitDebug(TEXT("CHandleNotif"));
                _rgpnel[HWEDLIST_VOLUME]->InitDebug(TEXT("CVolume"));
                _rgpnel[HWEDLIST_DISK]->InitDebug(TEXT("CDisk"));
                _rgpnel[HWEDLIST_MISCDEVINTF]->InitDebug(TEXT("CMiscDeviceInterface"));
                _rgpnel[HWEDLIST_MISCDEVNODE]->InitDebug(TEXT("CMiscDeviceNode"));
                _rgpnel[HWEDLIST_MTPT]->InitDebug(TEXT("CMtPt"));
                _rgpnel[HWEDLIST_ADVISECLIENT]->InitDebug(TEXT("CAdviseClient"));                
            }
#endif
            if (SUCCEEDED(hres))
            {
                _fListCreated = TRUE;

                TRACE(TF_SHHWDTCTDTCT, TEXT("CNamedElemList's created"));
            }
        }
    }

    return hres;
}

//static
HRESULT CHWEventDetectorHelper::FillLists()
{
    ASSERT(_fListCreated);

    // Enumerate those having an enumerator
    HRESULT hres = _rgpnel[HWEDLIST_DISK]->ReEnum();

    if (SUCCEEDED(hres))
    {
        hres = _rgpnel[HWEDLIST_VOLUME]->ReEnum();
    }

    return hres;
}

//static
HRESULT CHWEventDetectorHelper::EmptyLists()
{
    for (DWORD dw = 0; dw < HWEDLIST_COUNT_OF_LISTS; ++dw)
    {
        _rgpnel[dw]->EmptyList();
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// static 
HRESULT CHWEventDetectorHelper::InitDockState()
{
    BOOL fDocked;
    HRESULT hr = _MachineIsDocked(&fDocked);

    if (SUCCEEDED(hr) && (S_FALSE != hr)) 
    {
        CHWEventDetectorHelper::_fDocked = fDocked;
    }

    return hr;
}

// static 
HRESULT CHWEventDetectorHelper::DockStateChanged(BOOL* pfDockStateChanged)
{
    BOOL fDocked;
    HRESULT hr = _MachineIsDocked(&fDocked);

    if (SUCCEEDED(hr) && (S_FALSE != hr)) 
    {
        if (fDocked != _fDocked)
        {
            *pfDockStateChanged = TRUE;
        }

        // Update it too
        CHWEventDetectorHelper::_fDocked = fDocked;
    }

    return hr;
}

//static
HRESULT CHWEventDetectorHelper::RegisterDeviceNotification(
    PVOID pvNotificationFilter, HDEVNOTIFY* phdevnotify,
    BOOL fAllInterfaceClasses)
{
    HRESULT hres;
    DWORD dwFlags;

    ASSERT(_ssh);

    if (fAllInterfaceClasses)
    {
        dwFlags = DEVICE_NOTIFY_ALL_INTERFACE_CLASSES;
    }
    else
    {
        dwFlags = 0;
    }

    TRACE(TF_SHHWDTCTDTCTDETAILED,
        TEXT("Entered CHWEventDetectorImpl::RegisterDeviceNotification"));

#ifndef DEBUG
    dwFlags |= DEVICE_NOTIFY_SERVICE_HANDLE;

    *phdevnotify = ::RegisterDeviceNotification(_ssh, pvNotificationFilter,
        dwFlags);
#else
    if (IsWindow((HWND)_ssh))
    {
        dwFlags |= DEVICE_NOTIFY_WINDOW_HANDLE;

        *phdevnotify = ::RegisterDeviceNotification(_ssh, pvNotificationFilter,
            dwFlags);
    }
    else
    {
        dwFlags |= DEVICE_NOTIFY_SERVICE_HANDLE;

        *phdevnotify = ::RegisterDeviceNotification(_ssh, pvNotificationFilter,
            dwFlags);
    }
#endif

    if (*phdevnotify)
    {
        TRACE(TF_SHHWDTCTDTCTDETAILED,
            TEXT("RegisterDeviceNotification SUCCEEDED: 0x%08X"),
            *phdevnotify);

        hres = S_OK;
    }
    else
    {
        hres = S_FALSE;
    }    

    return hres;
}

// static
HRESULT CHWEventDetectorHelper::Init()
{
    HRESULT hr = _cs.Init();

    if (SUCCEEDED(hr))
    {
        _fInited = TRUE;
    }

    return hr;
}

// static
HRESULT CHWEventDetectorHelper::Cleanup()
{
    _cs.Enter();

    CloseLogFile();

    if (_pieo)
    {
        _pieo->RCRelease();
        _pieo = NULL;
    }

    _fInited = FALSE;

    _cs.Leave();

    _cs.Delete();

    return S_OK;
}

// static
HRESULT CHWEventDetectorHelper::GetImpersonateEveryone(
    CImpersonateEveryone** ppieo)
{
    HRESULT hr;

    *ppieo = NULL;

    if (_fInited)
    {
        _cs.Enter();

        if (!_pieo)
        {
            _pieo = new CImpersonateEveryone();
        }

        if (_pieo)
        {
            _pieo->RCAddRef();

            *ppieo = _pieo;

            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        _cs.Leave();
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

#ifdef DEBUG
void CHWEventDetectorHelper::_DbgAssertValidState()
{
    for (DWORD dw = 0; dw < ARRAYSIZE(_rgpnel); ++dw)
    {
        if (_rgpnel[dw])
        {
//          Need to disable this since there is 2 services using this data,
//          and it is now feasible to have a refcount diff than 1 at the end
//          of an operation.
//            _rgpnel[dw]->AssertAllElemsRefCount1();
            _rgpnel[dw]->AssertNoDuplicate();
        }
    }
}
#endif
///////////////////////////////////////////////////////////////////////////////
//
CHandleNotifTarget::~CHandleNotifTarget()
{}
///////////////////////////////////////////////////////////////////////////////
// Interface enumerator
HRESULT CIntfFillEnum::Next(LPWSTR pszElemName, DWORD cchElemName,
    DWORD* pcchRequired)
{
    ASSERT (pszElemName && cchElemName && pcchRequired);
    HRESULT hr = S_FALSE;
    BOOL fFound = FALSE;

    while (SUCCEEDED(hr) && !fFound && _pszNextInterface && *_pszNextInterface)
    {
        // Do we have a filter?
        if (_iecb)
        {
            // Yep
            hr = (_iecb)(_pszNextInterface);
        }
        else
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            // Was it filtered out?
            if (S_FALSE != hr)
            {
                // No
                hr = SafeStrCpyNReq(pszElemName, _pszNextInterface,
                    cchElemName, pcchRequired);

                if (SUCCEEDED(hr))
                {
                    fFound = TRUE;

                    _pszNextInterface += lstrlen(_pszNextInterface) + 1;
                }
            }
            else
            {
                // Yes, lopp again
                _pszNextInterface += lstrlen(_pszNextInterface) + 1;
            }
        }
    }

    return hr;
}

HRESULT CIntfFillEnum::_Init(const GUID* pguidInterface,
    INTERFACEENUMFILTERCALLBACK iecb)
{
    HRESULT hr;
    HMACHINE hMachine = NULL;
    ULONG ulSize;
    ULONG ulFlags = CM_GET_DEVICE_INTERFACE_LIST_PRESENT;

    CONFIGRET cr = CM_Get_Device_Interface_List_Size_Ex(&ulSize,
        (GUID*)pguidInterface, NULL, ulFlags, hMachine);

    _iecb = iecb;

    if ((CR_SUCCESS == cr) && (ulSize > 1))
    {
        _pszNextInterface = _pszDeviceInterface =
            (LPTSTR)LocalAlloc(LPTR, ulSize * sizeof(TCHAR));

        if (_pszDeviceInterface)
        {
            cr = CM_Get_Device_Interface_List_Ex((GUID*)pguidInterface, NULL,
                _pszDeviceInterface, ulSize, ulFlags, hMachine);

            if (CR_SUCCESS == cr)
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

CIntfFillEnum::CIntfFillEnum() : _pszDeviceInterface(NULL),
    _pszNextInterface(NULL)
{}

CIntfFillEnum::~CIntfFillEnum()
{
    if (_pszDeviceInterface)
    {
        LocalFree((HLOCAL)_pszDeviceInterface);
    }
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _MachineIsDocked(BOOL* pfDocked)
{
    HRESULT hr;
    HW_PROFILE_INFO hpi;

    if (GetCurrentHwProfile(&hpi)) 
    {
        DWORD dwDockInfo = hpi.dwDockInfo &
            (DOCKINFO_DOCKED | DOCKINFO_UNDOCKED);

        if ((DOCKINFO_DOCKED | DOCKINFO_UNDOCKED) == dwDockInfo)
        {
            // Not dockable
            *pfDocked = FALSE;
        }
        else
        {
            *pfDocked = (DOCKINFO_DOCKED & dwDockInfo);

#ifdef DEBUG
            // Make sure we understand how this works
            if (!(*pfDocked))
            {
                ASSERT(DOCKINFO_UNDOCKED & dwDockInfo);
            }
#endif
        }

        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }
       
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _BuildMoniker(LPCWSTR /*pszEventHandler*/, REFCLSID rclsid,
    DWORD dwSessionID, IMoniker** ppmoniker)
{
    IMoniker* pmonikerClass;
    HRESULT hr = CreateClassMoniker(rclsid, &pmonikerClass);

    *ppmoniker = NULL;

    if (SUCCEEDED(hr))
    {
        IMoniker* pmonikerSession;
        WCHAR szSessionID[30];

        // Should not fail
        SHOULDNOTFAIL(SUCCEEDED(StringCchPrintf(szSessionID, ARRAYSIZE(szSessionID),
            TEXT("session:%d"), dwSessionID)));

        hr = CreateItemMoniker(TEXT("!"), szSessionID, &pmonikerSession);

        if (SUCCEEDED(hr))
        {
            hr = pmonikerClass->ComposeWith(pmonikerSession, FALSE, ppmoniker);

            // Do not Release, we return it!

            pmonikerSession->Release();
        }

        pmonikerClass->Release();
    }

    return hr;
}

EXTERN_C HRESULT WINAPI CreateHardwareEventMoniker(REFCLSID clsid, LPCTSTR pszEventHandler, IMoniker **ppmoniker)
{
    HRESULT hr;

    if (ppmoniker)
    {
        if (pszEventHandler && *pszEventHandler)
        {
            DWORD dwSessionID = NtCurrentPeb()->SessionId;

            hr = _BuildMoniker(pszEventHandler, clsid, dwSessionID, ppmoniker);
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\devinfo.h ===
///////////////////////////////////////////////////////////////////////////////
// HW Device
///////////////////////////////////////////////////////////////////////////////
#ifndef _DEVINFO_H
#define _DEVINFO_H

#include "unk.h"

#include <shpriv.h>

//extern const CLSID CLSID_HWDevice;

class CHWDeviceImpl : public CCOMBase, public IHWDevice
{
public:
    // Interface IHWDevice
    STDMETHODIMP Init(LPCWSTR pszDeviceID);

    STDMETHODIMP GetDeviceString(DWORD dwType,
        LPWSTR* ppsz);

    STDMETHODIMP GetDeviceEventString(LPCWSTR pszEventType, DWORD dwType,
        LPWSTR* ppsz);

    STDMETHODIMP AutoplayHandler(LPCWSTR pszEventType,
        LPCWSTR pszHandler);

public:
    CHWDeviceImpl();
    ~CHWDeviceImpl();

private:
    LPWSTR          _pszDeviceID;
    BOOL            _fInited;
};

typedef CUnkTmpl<CHWDeviceImpl> CHWDevice;

#endif // _DEVINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\cstmprop.cpp ===
#include "cstmprop.h"

#include "hwdev.h"
#include "dtctreg.h"

#include "svcsync.h"
#include "cmmn.h"

#include "str.h"
#include "misc.h"

#include "tfids.h"
#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

STDMETHODIMP CHWDeviceCustomPropertiesImpl::InitFromDeviceID(
    LPCWSTR pszDeviceID, DWORD dwFlags)
{
    HRESULT hr;

    if (pszDeviceID && *pszDeviceID)
    {
        if ((0 == dwFlags) || (HWDEVCUSTOMPROP_USEVOLUMEPROCESSING == dwFlags))
        {
            if (!_fInited)
            {
                CHWEventDetectorHelper::CheckDiagnosticAppPresence();

                _dwFlags = dwFlags;

                if (HWDEVCUSTOMPROP_USEVOLUMEPROCESSING == dwFlags)
                {
                    DIAGNOSTIC((TEXT("[0257]Using HWDEVCUSTOMPROP_USEVOLUMEPROCESSING")));

                    WCHAR szDeviceIDReal[MAX_DEVICEID];

                    hr = _GetDeviceID(pszDeviceID, szDeviceIDReal,
                        ARRAYSIZE(szDeviceIDReal));

                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                    {
                        DIAGNOSTIC((TEXT("[0258]DeviceID converted from %s to %s"), pszDeviceID, szDeviceIDReal));

                        hr = _GetHWDeviceInstFromVolumeIntfID(szDeviceIDReal,
                            &_phwdevinst, &_pelemToRelease);
                    }
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0258]NOT using HWDEVCUSTOMPROP_USEVOLUMEPROCESSING")));

                    hr = _GetHWDeviceInstFromDeviceIntfID(pszDeviceID,
                        &_phwdevinst, &_pelemToRelease);
                }

                if (SUCCEEDED(hr))
                {
                    if (S_FALSE != hr)
                    {
                        DIAGNOSTIC((TEXT("[0259]Custom Property: Initialization SUCCEEDED")));

                        _fInited = TRUE;
                    }
                    else
                    {
                        DIAGNOSTIC((TEXT("[0260]Custom Property: Initialization FAILED")));
                        hr = E_FAIL;
                    }
                }
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CHWDeviceCustomPropertiesImpl::InitFromDevNode(
    LPCWSTR pszDevNode, DWORD dwFlags)
{
    HRESULT hr;

    if (pszDevNode && *pszDevNode)
    {
        if ((0 == dwFlags))
        {
            if (!_fInited)
            {
                CHWEventDetectorHelper::CheckDiagnosticAppPresence();

                _dwFlags = dwFlags;

                hr = _GetHWDeviceInstFromDeviceNode(pszDevNode, &_phwdevinst,
                    &_pelemToRelease);

                if (SUCCEEDED(hr))
                {
                    if (S_FALSE != hr)
                    {
                        DIAGNOSTIC((TEXT("[0270]Custom Property: Initialization SUCCEEDED")));

                        _fInited = TRUE;
                    }
                    else
                    {
                        DIAGNOSTIC((TEXT("[0271]Custom Property: Initialization FAILED")));
                        hr = E_FAIL;
                    }
                }
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CHWDeviceCustomPropertiesImpl::GetDWORDProperty(
    LPCWSTR pszPropName, DWORD* pdwProp)
{
    HRESULT hr;

    if (_fInited)
    {
        *pdwProp = (DWORD)-1;

        if (pszPropName && *pszPropName && pdwProp)
        {
            DWORD dwType;
            DWORD dwProp;

            hr = _GetDevicePropertyGeneric(_phwdevinst, pszPropName,
                FALSE, &dwType, (PBYTE)&dwProp, sizeof(dwProp));

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                if (REG_DWORD == dwType)
                {
                    DIAGNOSTIC((TEXT("[0261]Found Property: '%s'"), pszPropName));
                    *pdwProp = dwProp;
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0262]Found Property: '%s', but NOT REG_DWORD type"), pszPropName));
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;    
}

STDMETHODIMP CHWDeviceCustomPropertiesImpl::GetStringProperty(
    LPCWSTR pszPropName, LPWSTR* ppszProp)
{
    HRESULT hr;

    if (_fInited)
    {
        if (pszPropName && *pszPropName && ppszProp)
        {
            DWORD dwType;

            hr = _GetDevicePropertyStringNoBuf(_phwdevinst, pszPropName,
                FALSE, &dwType, ppszProp);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                if (dwType != REG_SZ)
                {
                    DIAGNOSTIC((TEXT("[0264]Found Property: '%s', but NOT REG_SZ type"), pszPropName));
                    CoTaskMemFree(*ppszProp);

                    *ppszProp = NULL;
                    hr = E_FAIL;
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0263]Found Property: '%s'"), pszPropName));
                }
            }
            else
            {
                *ppszProp = NULL;
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

STDMETHODIMP CHWDeviceCustomPropertiesImpl::GetMultiStringProperty(
    LPCWSTR pszPropName, BOOL fMergeMultiSz, WORD_BLOB** ppblob)
{
    HRESULT hr;

    if (_fInited)
    {
        if (pszPropName && *pszPropName && ppblob)
        {
            hr = _GetDevicePropertyGenericAsMultiSz(_phwdevinst, pszPropName,
                fMergeMultiSz, ppblob);

            if (FAILED(hr) || (S_FALSE == hr))
            {
                *ppblob = NULL;
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

STDMETHODIMP CHWDeviceCustomPropertiesImpl::GetBlobProperty(
    LPCWSTR pszPropName, BYTE_BLOB** ppblob)
{
    HRESULT hr;

    if (_fInited)
    {
        if (pszPropName && *pszPropName && ppblob)
        {
            hr = _GetDevicePropertyGenericAsBlob(_phwdevinst, pszPropName,
                ppblob);

            if (FAILED(hr) || (S_FALSE == hr))
            {
                *ppblob = NULL;
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

CHWDeviceCustomPropertiesImpl::CHWDeviceCustomPropertiesImpl() :
    _fInited(FALSE), _pelemToRelease(NULL), _phwdevinst(NULL), _dwFlags(0)
{
    _CompleteShellHWDetectionInitialization();
}

CHWDeviceCustomPropertiesImpl::~CHWDeviceCustomPropertiesImpl()
{
    if (_pelemToRelease)
    {
        _pelemToRelease->RCRelease();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\cstmpropu.cpp ===
#include "cstmprop.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CHWDeviceCustomPropertiesIME[] =
{
    _INTFMAPENTRY(CHWDeviceCustomProperties, IHWDeviceCustomProperties),
};

const INTFMAPENTRY* CHWDeviceCustomProperties::_pintfmap =
    CHWDeviceCustomPropertiesIME;
const DWORD CHWDeviceCustomProperties::_cintfmap =
    (sizeof(CHWDeviceCustomPropertiesIME) /
    sizeof(CHWDeviceCustomPropertiesIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CHWDeviceCustomProperties::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\devinfou.cpp ===
#include "devinfo.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY hwdeviceIME[] =
{
    _INTFMAPENTRY(CHWDevice, IHWDevice),
};

const INTFMAPENTRY* CHWDevice::_pintfmap = hwdeviceIME;
const DWORD CHWDevice::_cintfmap =
    (sizeof(hwdeviceIME)/sizeof(hwdeviceIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CHWDevice::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\devinfo.cpp ===
#include "devinfo.h"

#include "vol.h"
#include "dtct.h"
#include "dtctreg.h"

#include "svcsync.h"

#include "cmmn.h"
#include "misc.h"

#include "tfids.h"
#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

STDMETHODIMP CHWDeviceImpl::Init(LPCWSTR pszDeviceID)
{
    HRESULT hr;

    if (!_fInited)
    {
        if (pszDeviceID && *pszDeviceID)
        {
            hr = DupString(pszDeviceID, &_pszDeviceID);

            if (SUCCEEDED(hr))
            {
                _fInited = TRUE;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        // Cannot reinit
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CHWDeviceImpl::AutoplayHandler(LPCWSTR pszEventType,
    LPCWSTR pszHandler)
{
    return _ExecuteHandler(_pszDeviceID, pszEventType,
        pszHandler);
}

CHWDeviceImpl::CHWDeviceImpl() : _pszDeviceID(NULL), _fInited(FALSE)
{
    _CompleteShellHWDetectionInitialization();
}

CHWDeviceImpl::~CHWDeviceImpl()
{
    if (_pszDeviceID)
    {
        LocalFree(_pszDeviceID);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\drvbase.h ===
#ifndef _DRVBASE_H
#define _DRVBASE_H

#include "namellst.h"

#include <objbase.h>
#include <devioctl.h>

class CDisk : public CNamedElem
{
public:
    HRESULT Init(LPCWSTR pszElemName);
    HRESULT GetDeviceNumber(ULONG* puldeviceNumber);
    HRESULT GetDeviceType(DEVICE_TYPE* pdevtype);

protected:
    HRESULT _Init();

protected:
    CDisk();

public:
    static HRESULT Create(CNamedElem** ppelem);
    static HRESULT GetFillEnum(CFillEnum** ppfillenum);

protected:
    DEVICE_TYPE                         _devtype;
    ULONG                               _ulDeviceNumber;
    ULONG                               _ulPartitionNumber;

    BOOL                                _fDeviceNumberInited;
};

#endif //_DRVBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\drvbase.cpp ===
#include "drvbase.h"

#include "cmmn.h"

#include <dbt.h>

HRESULT CDisk::Init(LPCWSTR pszElemName)
{
    HRESULT hr = _SetName(pszElemName);

    return hr;
}

HRESULT CDisk::GetDeviceNumber(ULONG* puldeviceNumber)
{
    HRESULT hr = _Init();

    if (SUCCEEDED(hr))
    {
        if (((DEVICE_TYPE)-1) != _devtype)
        {
            *puldeviceNumber = _ulDeviceNumber;
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;    
}

HRESULT CDisk::GetDeviceType(DEVICE_TYPE* pdevtype)
{
    HRESULT hr = _Init();

    if (SUCCEEDED(hr))
    {
        if (((DEVICE_TYPE)-1) != _devtype)
        {
            *pdevtype = _devtype;
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT _GetDeviceNumberInfo(LPCWSTR pszDeviceID, DEVICE_TYPE* pdevtype,
    ULONG* pulDeviceNumber, ULONG* pulPartitionNumber)
{
    HRESULT hr;

    HANDLE hDevice = _GetDeviceHandle(pszDeviceID, FILE_READ_ATTRIBUTES);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        HDEVNOTIFY hdevnotify;
        DEV_BROADCAST_HANDLE dbhNotifFilter = {0};
        BOOL fRegistered = FALSE;

        dbhNotifFilter.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
        dbhNotifFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
        dbhNotifFilter.dbch_handle = hDevice;

        hr = CHWEventDetectorHelper::RegisterDeviceNotification(
            &dbhNotifFilter, &hdevnotify, FALSE);

        if (SUCCEEDED(hr))
        {
            fRegistered = TRUE;

            hr = _GetDeviceNumberInfoFromHandle(hDevice, pdevtype,
                pulDeviceNumber, pulPartitionNumber);
        }

        _CloseDeviceHandle(hDevice);

        if (fRegistered)
        {
            UnregisterDeviceNotification(hdevnotify);
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CDisk::_Init()
{
    HRESULT hr = S_OK;

    if (!_fDeviceNumberInited)
    {
        hr = _GetDeviceNumberInfo(_pszElemName, &_devtype, &_ulDeviceNumber,
            &_ulPartitionNumber);

        _fDeviceNumberInited = TRUE;
    }

    return hr;
}

CDisk::CDisk() : _devtype((DEVICE_TYPE)-1),
    _ulDeviceNumber((ULONG)-1), _ulPartitionNumber((ULONG)-1),
    _fDeviceNumberInited(FALSE)
{}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// static
HRESULT CDisk::Create(CNamedElem** ppelem)
{
    HRESULT hr = S_OK;
    *ppelem = new CDisk();

    if (!(*ppelem))
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

class CDiskFillEnum : public CFillEnum
{
public:
    HRESULT _Init();
    HRESULT Next(LPTSTR pszElemName, DWORD cchElemName, DWORD* pcchRequired);

private:
    CIntfFillEnum       _intffillenumDisk;
    CIntfFillEnum       _intffillenumCDROM;
    BOOL                _fDiskDone;
};

//static
HRESULT CDisk::GetFillEnum(CFillEnum** ppfillenum)
{
    HRESULT hres;

    CDiskFillEnum* pfillenum = new CDiskFillEnum();

    if (pfillenum)
    {
        hres = pfillenum->_Init();

        if (FAILED(hres))
        {
            delete pfillenum;
            pfillenum = NULL;
        }
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    *ppfillenum = pfillenum;

    return hres;
}

HRESULT CDiskFillEnum::_Init()
{
    _fDiskDone = FALSE;

    return _intffillenumDisk._Init(&guidDiskClass, NULL);
}

HRESULT CDiskFillEnum::Next(LPTSTR pszElemName, DWORD cchElemName,
    DWORD* pcchRequired)
{
    HRESULT hr;
    BOOL fDoCDROM = FALSE;
        
    if (!_fDiskDone)
    {
        hr = _intffillenumDisk.Next(pszElemName, cchElemName,
            pcchRequired);

        if (S_FALSE == hr)
        {
            hr = _intffillenumCDROM._Init(&guidCdRomClass, NULL);

            _fDiskDone = TRUE;

            if (SUCCEEDED(hr))
            {
                fDoCDROM = TRUE;
            }
        }
    }
    else
    {
        fDoCDROM = TRUE;
        hr = S_OK;
    }

    if (fDoCDROM)
    {
        hr = _intffillenumCDROM.Next(pszElemName, cchElemName,
            pcchRequired);        
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\dispatch.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#undef ASSERT

#include "dtct.h"

#include "hwdev.h"

#include "dtctreg.h"

#include "users.h"

#include "cmmn.h"
#include "sfstr.h"
#include "reg.h"
#include "misc.h"

#include "dbg.h"
#include "tfids.h"

#include <shpriv.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

// {C1FB73D0-EC3A-4ba2-B512-8CDB9187B6D1}
const CLSID IID_IHWEventHandler =
    {0xC1FB73D0, 0xEC3A, 0x4ba2,
    {0xB5, 0x12, 0x8C, 0xDB, 0x91, 0x87, 0xB6, 0xD1}};

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _CreateAndInitEventHandler(LPCWSTR pszHandler, CLSID* pclsid,
    IHWEventHandler** ppihweh)
{
    IHWEventHandler* pihweh;
    HRESULT hres = _CoCreateInstanceInConsoleSession(*pclsid, NULL,
        CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IHWEventHandler, &pihweh));

    *ppihweh = NULL;

    if (SUCCEEDED(hres))
    {
        LPWSTR pszInitCmdLine;
        hres = _GetInitCmdLine(pszHandler, &pszInitCmdLine);

        if (SUCCEEDED(hres))
        {
            if (S_FALSE == hres)
            {
                ASSERT(!pszInitCmdLine);
                hres = pihweh->Initialize(TEXT(""));
            }
            else
            {
                hres = pihweh->Initialize(pszInitCmdLine);
            }

            if (SUCCEEDED(hres))
            {
                *ppihweh = pihweh;
            }

            if (pszInitCmdLine)
            {
                LocalFree((HLOCAL)pszInitCmdLine);
            }
        }

        if (FAILED(hres))
        {
            pihweh->Release();
            *ppihweh = NULL;
        }
    }

    return hres;
}

struct EXECUTEHANDLERDATA
{
    CLSID       clsidHandler;
    LPWSTR      pszDeviceIDForAutoplay;
    LPWSTR      pszEventType;
    union
    {
        LPWSTR      pszHandler;
        LPWSTR      pszInitCmdLine;
    };
};

HRESULT _CreateExecuteHandlerData(EXECUTEHANDLERDATA** ppehd)
{
    HRESULT hres;

    *ppehd = (EXECUTEHANDLERDATA*)LocalAlloc(LPTR, sizeof(EXECUTEHANDLERDATA));

    if (*ppehd)
    {
        hres = S_OK;
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

HRESULT _FreeEHDStrings(EXECUTEHANDLERDATA* pehd)
{
    if (pehd->pszHandler)
    {
        LocalFree((HLOCAL)pehd->pszHandler);
        pehd->pszHandler = NULL;
    }

    if (pehd->pszDeviceIDForAutoplay)
    {
        LocalFree((HLOCAL)pehd->pszDeviceIDForAutoplay);
        pehd->pszDeviceIDForAutoplay = NULL;
    }

    if (pehd->pszEventType)
    {
        LocalFree((HLOCAL)pehd->pszEventType);
        pehd->pszEventType = NULL;
    }

    return S_OK;
}

HRESULT _FreeExecuteHandlerData(EXECUTEHANDLERDATA* pehd)
{
    _FreeEHDStrings(pehd);

    LocalFree((HLOCAL)pehd);

    return S_OK;
}

HRESULT _SetExecuteHandlerData(EXECUTEHANDLERDATA* pehd,
    LPCWSTR pszDeviceIDForAutoplay, LPCWSTR pszEventType,
    LPCWSTR pszHandlerOrInitCmdLine, const CLSID* pclsidHandler)
{
    HRESULT hres = DupString(pszHandlerOrInitCmdLine, &(pehd->pszHandler));

    if (SUCCEEDED(hres))
    {
        hres = DupString(pszDeviceIDForAutoplay,
            &(pehd->pszDeviceIDForAutoplay));

        if (SUCCEEDED(hres))
        {
            hres = DupString(pszEventType, &(pehd->pszEventType));

            if (SUCCEEDED(hres))
            {
                pehd->clsidHandler = *pclsidHandler;
            }
        }
    }

    if (FAILED(hres))
    {
        // Free everything
        _FreeEHDStrings(pehd);
    }

    return hres;
}

DWORD WINAPI _ExecuteHandlerThreadProc(void* pv)
{
    EXECUTEHANDLERDATA* pehd = (EXECUTEHANDLERDATA*)pv;
    IHWEventHandler* pihweh;

    DIAGNOSTIC((TEXT("[0100]Attempting to execute handler for:  %s %s %s"),
        pehd->pszDeviceIDForAutoplay, pehd->pszEventType,
        pehd->pszHandler));

    TRACE(TF_SHHWDTCTDTCT,
        TEXT("_ExecuteHandlerThreadProc for: %s %s %s"),
        pehd->pszDeviceIDForAutoplay, pehd->pszEventType,
        pehd->pszHandler);

    HRESULT hres = _CreateAndInitEventHandler(pehd->pszHandler,
        &(pehd->clsidHandler), &pihweh);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        WCHAR szDeviceIDAlt[MAX_PATH];

        DIAGNOSTIC((TEXT("[0101]Got Handler Interface")));

        TRACE(TF_SHHWDTCTDTCT, TEXT("Got Handler Interface"));

        hres = _GetAltDeviceID(pehd->pszDeviceIDForAutoplay, szDeviceIDAlt,
            ARRAYSIZE(szDeviceIDAlt));

        if (S_FALSE == hres)
        {
            szDeviceIDAlt[0] = 0;
        }

        if (SUCCEEDED(hres))
        {
            hres = pihweh->HandleEvent(pehd->pszDeviceIDForAutoplay,
                szDeviceIDAlt, pehd->pszEventType);

            DIAGNOSTIC((TEXT("[0103]IHWEventHandler::HandleEvent returned: hr = 0x%08X"), hres));

            TRACE(TF_SHHWDTCTDTCT,
                TEXT("pIEventHandler->HandleEvent result: 0x%08X"), hres);
        }

        pihweh->Release();
    }
    else
    {
        DIAGNOSTIC((TEXT("[0102]Did not get Handler Interface: hr = 0x%08X"), hres));

        TRACE(TF_SHHWDTCTDTCT,
            TEXT("Did not get Handler Interface: 0x%08X"), hres);
    }

    _FreeExecuteHandlerData(pehd);

    TRACE(TF_SHHWDTCTDTCT, TEXT("Exiting _ExecuteHandlerThreadProc"));

    return (DWORD)hres;
}

HRESULT _DelegateToExecuteHandlerThread(EXECUTEHANDLERDATA* pehd,
    LPTHREAD_START_ROUTINE pThreadProc, HANDLE* phThread)
{
    HRESULT hres;

    // set thread stack size?
    *phThread = CreateThread(NULL, 0, pThreadProc, pehd, 0, NULL);

    if (*phThread)
    {
        hres = S_OK;
    }
    else
    {
        hres = E_FAIL;
    }

    return hres;
}

HRESULT _ExecuteHandlerHelper(LPCWSTR pszDeviceIDForAutoplay,
    LPCWSTR pszEventType,
    LPCWSTR pszHandlerOrInitCmdLine, LPTHREAD_START_ROUTINE pThreadProc,
    const CLSID* pclsidHandler, HANDLE* phThread)
{
    // Let's prepare to delegate to other thread
    EXECUTEHANDLERDATA* pehd;

    HRESULT hres = _CreateExecuteHandlerData(&pehd);

    *phThread = NULL;

    if (SUCCEEDED(hres))
    {
        hres = _SetExecuteHandlerData(pehd, pszDeviceIDForAutoplay,
            pszEventType, pszHandlerOrInitCmdLine,
            pclsidHandler);

        if (SUCCEEDED(hres))
        {
            hres = _DelegateToExecuteHandlerThread(pehd,
                pThreadProc, phThread);
        }

        if (FAILED(hres))
        {
            _FreeExecuteHandlerData(pehd);
        }
    }

    return hres;
}

HRESULT _ExecuteHandler(LPCWSTR pszDeviceIDForAutoplay, LPCWSTR pszEventType,
    LPCWSTR pszHandler)
{
    CLSID clsidHandler;
    HRESULT hres = _GetHandlerCLSID(pszHandler, &clsidHandler);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        HANDLE hThread;

        hres = _ExecuteHandlerHelper(pszDeviceIDForAutoplay, pszEventType,
            pszHandler, _ExecuteHandlerThreadProc,
            &clsidHandler, &hThread);

        if (SUCCEEDED(hres))
        {
            CloseHandle(hThread);
        }
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
DWORD WINAPI _PromptUserThreadProc(void* pv)
{
    IHWEventHandler* pihweh;
    EXECUTEHANDLERDATA* pehd = (EXECUTEHANDLERDATA*)pv;

    DIAGNOSTIC((TEXT("[0110]Will prompt user for preferences")));

    TRACE(TF_SHHWDTCTDTCT, TEXT("Entered _PromptUserThreadProc"));

    HRESULT hr = _CoCreateInstanceInConsoleSession(pehd->clsidHandler, NULL,
        CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IHWEventHandler, &pihweh));

    if (SUCCEEDED(hr))
    {
        hr = pihweh->Initialize(pehd->pszInitCmdLine);

        if (SUCCEEDED(hr))
        {
            WCHAR szDeviceIDAlt[MAX_PATH];
            TRACE(TF_SHHWDTCTDTCT, TEXT("Got Handler Interface"));

            hr = _GetAltDeviceID(pehd->pszDeviceIDForAutoplay, szDeviceIDAlt,
                ARRAYSIZE(szDeviceIDAlt));

            if (S_FALSE == hr)
            {
                szDeviceIDAlt[0] = 0;
            }

            if (SUCCEEDED(hr))
            {
                hr = pihweh->HandleEvent(pehd->pszDeviceIDForAutoplay,
                    szDeviceIDAlt, pehd->pszEventType);
            }
        }

        pihweh->Release();
    }

    _FreeExecuteHandlerData(pehd);

    TRACE(TF_SHHWDTCTDTCT, TEXT("Exiting _PromptUserThreadProc"));

    return (DWORD)hr;
}


HRESULT _PromptUser(LPCWSTR pszDeviceIDForAutoplay, LPCWSTR pszEventType,
    LPCWSTR pszInitCmdLine)
{
    HANDLE hThread;

    HRESULT hr = _ExecuteHandlerHelper(pszDeviceIDForAutoplay, pszEventType,
        pszInitCmdLine, _PromptUserThreadProc,
        &CLSID_ShellAutoplay, &hThread);

    if (SUCCEEDED(hr))
    {
        CloseHandle(hThread);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//

struct QUERYRUNNINGOBJECTSTRUCT
{
    IHWEventHandler* phweh;
    WCHAR szDeviceIntfID[MAX_DEVICEID];
    WCHAR szEventType[MAX_EVENTTYPE];
};

DWORD WINAPI _QueryRunningObjectThreadProc(void* pv)
{
    QUERYRUNNINGOBJECTSTRUCT* pqro = (QUERYRUNNINGOBJECTSTRUCT*)pv;
    HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);

    if (SUCCEEDED(hr))
    {
        hr = pqro->phweh->HandleEvent(pqro->szDeviceIntfID, TEXT(""), pqro->szEventType);

        CoUninitialize();
    }

    pqro->phweh->Release();
    LocalFree((HLOCAL)pqro);

    return (DWORD)hr;
}

HRESULT _QueryRunningObject(IHWEventHandler* phweh, LPCWSTR pszDeviceIntfID,
    LPCWSTR pszEventType, LPCWSTR pszHandler, BOOL* pfHandlesEvent)
{
    HRESULT hr;
    QUERYRUNNINGOBJECTSTRUCT* pqro = (QUERYRUNNINGOBJECTSTRUCT*)LocalAlloc(LPTR,
        sizeof(QUERYRUNNINGOBJECTSTRUCT));

    *pfHandlesEvent = FALSE;

    if (pqro)
    {
        phweh->AddRef();
        pqro->phweh = phweh;

        hr = SafeStrCpyN(pqro->szDeviceIntfID, pszDeviceIntfID,
            ARRAYSIZE(pqro->szDeviceIntfID));

        if (SUCCEEDED(hr))
        {
            hr = SafeStrCpyN(pqro->szEventType, pszEventType,
                ARRAYSIZE(pqro->szEventType));
        }

        if (SUCCEEDED(hr))
        {
            HANDLE hThread = CreateThread(NULL, 0, _QueryRunningObjectThreadProc, pqro,
                0, NULL);

            if (hThread)
            {
                // Wait 3 sec to see if wants to process it.  If not, it's
                // fair play for us.
                DWORD dwWait = WaitForSingleObject(hThread, 3000);
            
                if (WAIT_OBJECT_0 == dwWait)
                {
                    // Return within time and did not failed
                    DWORD dwExitCode;

                    if (GetExitCodeThread(hThread, &dwExitCode))
                    {
                        HRESULT hrHandlesEvent = (HRESULT)dwExitCode;
                    
                        // WIA will return S_FALSE if they do NOT want to process
                        // the event
                        if (SUCCEEDED(hrHandlesEvent) && (S_FALSE != hrHandlesEvent))
                        {
                            DIAGNOSTIC((TEXT("[0124]Already running handler will handle event (%s)"), pszHandler));

                            TRACE(TF_WIA,
                                TEXT("Already running handler will handle event"));

                            *pfHandlesEvent = TRUE;
                        }
                        else
                        {
                            DIAGNOSTIC((TEXT("[0125]Already running handler will *NOT* handle event(%s)"), pszHandler));
                            TRACE(TF_WIA,
                                TEXT("WIA.HandleEventOverride will NOT Handle Event"));
                        }

                        hr = S_OK;
                    }
                    else
                    {
                        hr = S_FALSE;
                    }
                }
                else
                {
                    if (WAIT_TIMEOUT == dwWait)
                    {
                        DIAGNOSTIC((TEXT("[0126]Timed out on already running handler ( > 3 sec)")));
                        TRACE(TF_WIA,
                            TEXT("Timed out waiting on already running object (%s)"), pszHandler);
                    }

                    hr = S_FALSE;
                }

                CloseHandle(hThread);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (FAILED(hr))
        {
            pqro->phweh->Release();
            LocalFree((HLOCAL)pqro);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT _FindAlreadyRunningHandler(LPCWSTR pszDeviceIntfID,
    LPCWSTR pszEventType, LPCWSTR pszEventHandler, BOOL* pfHandlesEvent)
{
    CImpersonateConsoleSessionUser icsu;

    HRESULT hr = icsu.Impersonate();

    *pfHandlesEvent = FALSE;

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        IBindCtx* pbindctx;

        hr = CreateBindCtx(0, &pbindctx);

        if (SUCCEEDED(hr))
        {
            IRunningObjectTable* prot;

            hr = pbindctx->GetRunningObjectTable(&prot);

            if (SUCCEEDED(hr))
            {
                WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlers\\"));
                hr = SafeStrCatN(szKeyName, pszEventHandler, ARRAYSIZE(szKeyName));

                if (SUCCEEDED(hr))
                {
                    HKEY hkey;

                    hr = _RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hkey);

                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                    {
                        WCHAR szHandler[MAX_HANDLER];
                        DWORD dwIndex = 0;

                        while (!*pfHandlesEvent && SUCCEEDED(hr) &&
                            SUCCEEDED(hr = _RegEnumStringValue(hkey, dwIndex,
                            szHandler, ARRAYSIZE(szHandler))) &&
                            (S_FALSE != hr))
                        {
                            CLSID clsid;

                            hr = _GetHandlerCancelCLSID(szHandler, &clsid);

                            if (SUCCEEDED(hr) && (S_FALSE != hr))
                            {
                                IMoniker* pmoniker;

                                hr = _BuildMoniker(pszEventHandler, clsid,
                                    (USER_SHARED_DATA->ActiveConsoleId), &pmoniker);

                                if (SUCCEEDED(hr))
                                {
                                    IUnknown* punk;

                                    hr = prot->GetObject(pmoniker, &punk);

                                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                                    {
                                        IHWEventHandler* phweh;

                                        hr = punk->QueryInterface(
                                            IID_IHWEventHandler, (void**)&phweh);

                                        if (SUCCEEDED(hr))
                                        {
                                            hr = _QueryRunningObject(phweh,
                                                pszDeviceIntfID, pszEventType,
                                                szHandler, pfHandlesEvent);

                                            phweh->Release();
                                        }

                                        punk->Release();
                                    }
                                    else
                                    {
                                        // if it can't find it, it return s failure
                                        hr = S_FALSE;
                                    }
                                
                                    pmoniker->Release();
                                }
                            }

                            ++dwIndex;
                        }

                        _RegCloseKey(hkey);
                    }
                }

                prot->Release();
            }

            pbindctx->Release();
        }

        icsu.RevertToSelf();
    }

    return hr;
}

HRESULT _FinalDispatch(LPCWSTR pszDeviceIntfID, LPCWSTR pszEventType,
    LPCWSTR pszEventHandler)
{
    DIAGNOSTIC((TEXT("[0111]Looking for already running handler for: %s, %s, %s"),
        pszDeviceIntfID, pszEventType, pszEventHandler));

    BOOL fHandlesEvent;
    HRESULT hres = _FindAlreadyRunningHandler(pszDeviceIntfID, pszEventType,
        pszEventHandler, &fHandlesEvent);

    if (SUCCEEDED(hres) && !fHandlesEvent)
    {
        WCHAR szHandler[MAX_HANDLER];

        hres = _GetUserDefaultHandler(pszDeviceIntfID, pszEventHandler,
            szHandler, ARRAYSIZE(szHandler), GUH_USEWINSTA0USER);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            // We have a handler
            TRACE(TF_SHHWDTCTDTCT, TEXT("Found Handler: %s"), szHandler);
            BOOL fPrompt = FALSE;
            BOOL fCheckAlwaysDoThis = FALSE;
            BOOL fExecuteHandler = FALSE;

            if (HANDLERDEFAULT_GETFLAGS(hres) &
                HANDLERDEFAULT_USERCHOSENDEFAULT)
            {
                // We have a user chosen default...
                if (HANDLERDEFAULT_GETFLAGS(hres) &
                    HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED)
                {
                    // ... but we have more recent apps that were installed
                    fPrompt = TRUE;
                }
                else
                {
                    if (lstrcmp(szHandler, TEXT("MSTakeNoAction")))
                    {
                        // The handler is *not* "Take no action"
                        if (!lstrcmp(szHandler, TEXT("MSPromptEachTime")))
                        {
                            // The handler is "Prompt each time"
                            fPrompt = TRUE;
                        }
                        else
                        {
                            fExecuteHandler = TRUE;
                        }
                    }
                }
            }
            else
            {
                // If we do not have a user chosen handler, then we always
                // prompt
                fPrompt = TRUE;
            }

            if (fPrompt)
            {
                if (HANDLERDEFAULT_GETFLAGS(hres) &
                    HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED)
                {
                    // There are more recent handlers
                    if (HANDLERDEFAULT_GETFLAGS(hres) &
                        HANDLERDEFAULT_USERCHOSENDEFAULT)
                    {
                        // The user chose a default handler
                        if (!(HANDLERDEFAULT_GETFLAGS(hres) &
                            HANDLERDEFAULT_DEFAULTSAREDIFFERENT))
                        {
                            // The handlers are the same, check the checkbox
                            fCheckAlwaysDoThis = TRUE;
                        }
                    }
                }

                _GiveAllowForegroundToConsoleShell();

                if (fCheckAlwaysDoThis)
                {
                    // Notice the '*' at the end of the string
                    hres = _PromptUser(pszDeviceIntfID, pszEventType,
                        TEXT("PromptEachTimeNoContent*"));                
                }
                else
                {
                    hres = _PromptUser(pszDeviceIntfID, pszEventType,
                        TEXT("PromptEachTimeNoContent"));
                }
            }
            else
            {
                if (fExecuteHandler)
                {
                    hres = _ExecuteHandler(pszDeviceIntfID, pszEventType,
                        szHandler);
                }
            }
        }
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _IsWIAHandlingEvent(LPCWSTR pszDeviceIDForAutoplay,
    LPCWSTR pszEventType, BOOL* pfWIAHandlingEvent)
{
    CLSID clsid = {0};
    HRESULT hr = CLSIDFromProgID(TEXT("WIA.HandleEventOverride"), &clsid);

    *pfWIAHandlingEvent = FALSE;

    if (SUCCEEDED(hr))
    {
        HANDLE hThread;

        hr = _ExecuteHandlerHelper(pszDeviceIDForAutoplay, pszEventType,
            TEXT(""), _ExecuteHandlerThreadProc, &clsid, &hThread);

        if (SUCCEEDED(hr))
        {
            // Wait 3 sec to see if WIA wants to process it.  If not, it's
            // fair play for us.
            DWORD dwWait = WaitForSingleObject(hThread, 3000);
            
            if (WAIT_OBJECT_0 == dwWait)
            {
                // Return within time and did not failed
                DWORD dwExitCode;

                if (GetExitCodeThread(hThread, &dwExitCode))
                {
                    HRESULT hrWIA = (HRESULT)dwExitCode;
                    
                    // WIA will return S_FALSE if they do NOT want to process
                    // the event
                    if (SUCCEEDED(hrWIA) && (S_FALSE != hrWIA))
                    {
                        DIAGNOSTIC((TEXT("[0114]WIA will handle event")));

                        TRACE(TF_WIA,
                            TEXT("WIA.HandleEventOverride will Handle Event"));
                        *pfWIAHandlingEvent = TRUE;
                    }
                    else
                    {
                        TRACE(TF_WIA,
                            TEXT("WIA.HandleEventOverride will NOT Handle Event"));
                    }
                }
            }
            else
            {
                if (WAIT_TIMEOUT == dwWait)
                {
                    TRACE(TF_WIA,
                        TEXT("Timed out waiting on WIA.HandleEventOverride"));
                }
            }

            CloseHandle(hThread);
        }
        else
        {
            TRACE(TF_WIA,
                TEXT("_ExecuteHandlerHelper failed for WIA.HandleEventOverride"));
        }
    }
    else
    {
        TRACE(TF_WIA,
            TEXT("Could not get CLSID for WIA.HandleEventOverride"));
    }

    return hr;
}

HRESULT _DispatchToHandler(LPCWSTR pszDeviceIntfID, CHWDeviceInst* phwdevinst,
    LPCWSTR pszEventType, BOOL* pfHasHandler)
{
    WCHAR szDeviceHandler[MAX_DEVICEHANDLER];
    HRESULT hres = _GetDeviceHandler(phwdevinst, szDeviceHandler,
        ARRAYSIZE(szDeviceHandler));

    *pfHasHandler = FALSE;

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        WCHAR szEventHandler[MAX_EVENTHANDLER];

        DIAGNOSTIC((TEXT("[0115]Found DeviceHandler: %s"), szDeviceHandler));

        TRACE(TF_SHHWDTCTDTCT,
            TEXT("Found Device Handler: %s"), szDeviceHandler);

        if (SUCCEEDED(hres))
        {
            DIAGNOSTIC((TEXT("[0117]Device does NOT Support Content")));
            TRACE(TF_SHHWDTCTDTCT, TEXT("Device does NOT Support Content"));

            BOOL fWIAHandlingEvent = FALSE;
            GUID guidInterface;
            HRESULT hres2 = phwdevinst->GetInterfaceGUID(&guidInterface);

            if (SUCCEEDED(hres2))
            {
                if ((guidInterface == guidImagingDeviceClass) ||
                    (guidInterface == guidVideoCameraClass))
                {
                    _IsWIAHandlingEvent(pszDeviceIntfID, pszEventType,
                        &fWIAHandlingEvent);
                }
            }

            if (!fWIAHandlingEvent)
            {
                hres = _GetEventHandlerFromDeviceHandler(szDeviceHandler,
                    pszEventType, szEventHandler, ARRAYSIZE(szEventHandler));

                if (SUCCEEDED(hres))
                {
                    if (S_FALSE != hres)
                    {
                        *pfHasHandler = TRUE;

                        hres = _FinalDispatch(pszDeviceIntfID, pszEventType,
                            szEventHandler);

                        TRACE(TF_SHHWDTCTDTCTDETAILED,
                            TEXT("  _GetEventHandlerFromDeviceHandler returned: %s"),
                            szEventHandler);
                    }
                }
            }
            else
            {
                DIAGNOSTIC((TEXT("[0123]WIA will handle event")));
                TRACE(TF_SHHWDTCTDTCTDETAILED, TEXT("  WIA will handle event"));
            }
        }
    }
    else
    {
        DIAGNOSTIC((TEXT("[0112]Did NOT find DeviceHandler: 0x%08X"), hres));
        TRACE(TF_SHHWDTCTDTCT, TEXT("Did not find Device Handler: 0x%08X"),
            hres);
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\dtct.cpp ===
#include "dtct.h"

#include "svcsync.h"

#include "cmmn.h"

#include "misc.h"
#include "str.h"

#include "mischlpr.h"
#include "dbg.h"
#include "tfids.h"

#include "regnotif.h"

#include <ioevent.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

///////////////////////////////////////////////////////////////////////////////
//
// {5390E909-5BDF-4218-BB1F-9A41B3143214}
extern const CLSID CLSID_HWEventDetector =
    {0x5390e909, 0x5bdf, 0x4218,
    {0xbb, 0x1f, 0x9a, 0x41, 0xb3, 0x14, 0x32, 0x14}};

///////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP CHWEventDetectorImpl::InitMinimum(DWORD UNREF_PARAM(cArg),
    LPWSTR* UNREF_PARAM(ppszArgs), LPCWSTR pszEventRelinquishControl,
    DWORD* pdwCtrlAccept, BOOL* pfWantsDeviceEvents)
{
    HRESULT hres;

    ASSERTVALIDSTATE();

    if (pszEventRelinquishControl && *pszEventRelinquishControl &&
        pdwCtrlAccept && pfWantsDeviceEvents)
    {
        _hEventRelinquishControl = OpenEvent(SYNCHRONIZE, FALSE,
            pszEventRelinquishControl);

        if (_hEventRelinquishControl)
        {
            _hEventInitCompleted = CreateEvent(NULL, TRUE, FALSE, NULL);

            if (_hEventInitCompleted)
            {
                if (DuplicateHandle(GetCurrentProcess(), _hEventInitCompleted,
                    GetCurrentProcess(), &g_hEventInitCompleted, 0, FALSE,
                    DUPLICATE_SAME_ACCESS))
                {
                    hres = _RegisterFactories();

                    if (SUCCEEDED(hres))
                    {
                        *pdwCtrlAccept = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN |
                            SERVICE_ACCEPT_PAUSE_CONTINUE | SERVICE_ACCEPT_SESSIONCHANGE;

                        *pfWantsDeviceEvents = TRUE;
                    }
                }
                else
                {
                    CloseHandle(_hEventInitCompleted);
                    _hEventInitCompleted = NULL;
                    hres = E_FAIL;
                }
            }
            else
            {
                hres = E_FAIL;
            }
        }
        else
        {
            hres = E_FAIL;
        }
    }
    else
    {
        hres = E_INVALIDARG;
    }

    ASSERTVALIDSTATE();

    return hres;
}

STDMETHODIMP CHWEventDetectorImpl::InitDeviceEventHandler(
    SERVICE_STATUS_HANDLE ssh)
{
    HRESULT hres = E_INVALIDARG;

    TRACE(TF_SHHWDTCTSVC, TEXT("Entered CHWEventDetectorImpl::InitDeviceEventHandler"));

    ASSERTVALIDSTATE();

    if (ssh)
    {
        hres = CHWEventDetectorHelper::SetServiceStatusHandle(ssh);
    }

    ASSERTVALIDSTATE();

    return hres;
}

STDMETHODIMP CHWEventDetectorImpl::InitFinal()
{
    HRESULT hres;
    HANDLE hProcess = GetCurrentProcess();

    TRACE(TF_SHHWDTCTSVC, TEXT("Entered CHWEventDetectorImpl::InitFinal"));

    ASSERTVALIDSTATE();

    ASSERT(!g_hShellHWDetectionThread);

    if (DuplicateHandle(hProcess, GetCurrentThread(), hProcess,
        &g_hShellHWDetectionThread, 0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        TRACE(TF_SVCSYNC,
            TEXT("About to set ShellHWDetection thread priority to LOWEST from itself"));

        if (SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST))
        {
            hres = CHWEventDetectorHelper::InitDockState();

            CHWEventDetectorHelper::Init();

            if (SUCCEEDED(hres))
            {
                hres = _RegisterForNotif();

                TRACE(TF_SVCSYNC,
                    TEXT("Completed registration, about to set ShellHWDetection thread priority to NORMAL from itself"));

                SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);

                //
                // Load WIA's RPC library and initalize them
                //
                HMODULE hWiaRPC = LoadLibrary(TEXT("wiarpc.dll"));
                if(hWiaRPC) {
                    HRESULT (WINAPI *WiaEventsInitialize)(void) = (HRESULT (WINAPI *)(void))
                        GetProcAddress(hWiaRPC, "WiaEventsInitialize");
                    if(WiaEventsInitialize) {
                        WiaEventsInitialize();
                    } else {
                        TRACE(TF_SVCSYNC,
                              TEXT("Failed to get WIARPC.DLL!WiaEventsInitialize entry point"));
                    }
                } else {
                    TRACE(TF_SVCSYNC,
                          TEXT("Failed to load WIARPC.DLL"));
                }
                
                TRACE(TF_SVCSYNC,
                      TEXT("Completed intialization, setting event"));

                SetEvent(_hEventInitCompleted);

                hres = S_OK;


            }
        }
        else
        {
            hres = E_FAIL;
        }
    }
    else
    {
        hres = E_FAIL;
    }

    ASSERTVALIDSTATE();

    TRACE(TF_SHHWDTCTSVC, TEXT("Exited CHWEventDetectorImpl::InitFinal: 0x%08X"),
        hres);

    return hres;
}
///////////////////////////////////////////////////////////////////////////////
//
// return S_FALSE and a non-zero dwWaitHint if pending
STDMETHODIMP CHWEventDetectorImpl::HandleServiceControl(DWORD dwControlCode,
    DWORD* pdwWaitHint)
{
    HRESULT hres;

    ASSERTVALIDSTATE();

    *pdwWaitHint = 0;

    switch (dwControlCode)
    {
        case SERVICE_CONTROL_PAUSE:
            hres = _UnregisterForNotif();
            hres = _SuspendFactories();
            break;

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
        {
            // In case _CompleteShellHWDetectionInitialization was never called
            HANDLE hTmp = InterlockedCompareExchangePointer(
                &g_hShellHWDetectionThread, NULL,
                g_hShellHWDetectionThread);

            if (hTmp)
            {
                CloseHandle(hTmp);
            }

            if (_hEventInitCompleted)
            {
                CloseHandle(_hEventInitCompleted);
                _hEventInitCompleted = NULL;
            }

            hres = _UnregisterForNotif();
            hres = CHWEventDetectorHelper::DeleteLists();
            hres = _UnregisterFactories();

            CHWEventDetectorHelper::Cleanup();

            if (_hEventRelinquishControl)
            {
                CloseHandle(_hEventRelinquishControl);
            }

            break;
        }

        case SERVICE_CONTROL_CONTINUE:
            hres = _RegisterForNotif();
            hres = _ResumeFactories();
            break;

        default:
            // do not return S_FALSE here
            hres = S_OK;
            break;
    }

    ASSERTVALIDSTATE();

    return hres;
}

STDMETHODIMP CHWEventDetectorImpl::HandleDeviceEvent(DWORD dwEventType,
    LPVOID pEventData)
{
    HRESULT hres = S_FALSE;

    ASSERTVALIDSTATE();

    CHWEventDetectorHelper::CheckDiagnosticAppPresence();

    if (pEventData)
    {
        DEV_BROADCAST_HDR* dbhdr = (DEV_BROADCAST_HDR*)pEventData;

        if (DBT_DEVTYP_DEVICEINTERFACE == dbhdr->dbch_devicetype)
        {
            DEV_BROADCAST_DEVICEINTERFACE* pdbdi =
                (DEV_BROADCAST_DEVICEINTERFACE*)pEventData;

            WCHAR szGUID[MAX_GUIDSTRING];
            LPWSTR pszEventType = TEXT("Unknown");

            if (SUCCEEDED(_StringFromGUID(&(pdbdi->dbcc_classguid), szGUID,
                ARRAYSIZE(szGUID))))
            {
                switch (dwEventType)
                {
                    case DBT_DEVICEARRIVAL:
                        pszEventType = TEXT("DBT_DEVTYP_DEVICEINTERFACE + DBT_DEVICEARRIVAL");
                        DIAGNOSTIC((TEXT("[0000]Processing Interface Arrival Event: %s, %s"), pszEventType, szGUID));
                        break;

                    case DBT_DEVICEREMOVECOMPLETE:
                        pszEventType = TEXT("DBT_DEVTYP_DEVICEINTERFACE + DBT_DEVICEREMOVECOMPLETE");
                        DIAGNOSTIC((TEXT("[0001]Processing Interface Removal Event: %s, %s"), pszEventType, szGUID));
                        break;
#ifdef DEBUG
                    case DBT_DEVICEQUERYREMOVEFAILED: pszEventType = TEXT("DBT_DEVTYP_DEVICEINTERFACE + DBT_DEVICEQUERYREMOVEFAILED"); break;
                    case DBT_DEVICEREMOVEPENDING: pszEventType = TEXT("DBT_DEVTYP_DEVICEINTERFACE + DBT_DEVICEREMOVEPENDING"); break;
                    case DBT_DEVICEQUERYREMOVE: pszEventType = TEXT("DBT_DEVTYP_DEVICEINTERFACE + DBT_DEVICEQUERYREMOVE"); break;
#endif
                }


                TRACE(TF_SHHWDTCTDTCT, TEXT("Processing Interface Event: %s, %s"),
                    pszEventType, szGUID);
            }
            
            hres = _HandleInterfaceEvent(pdbdi, dwEventType);
        }
        else
        {
            if (DBT_DEVTYP_HANDLE == dbhdr->dbch_devicetype)
            {
                DEV_BROADCAST_HANDLE* pdbh = (DEV_BROADCAST_HANDLE*)pEventData;

#ifdef DEBUG
                LPWSTR pszEventType = TEXT("Unknown");
                WCHAR szGUID[MAX_GUIDSTRING];

                if (DBT_CUSTOMEVENT == dwEventType)
                {
                    HRESULT hrTmp = S_FALSE;

                    if (GUID_IO_MEDIA_ARRIVAL == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_MEDIA_ARRIVAL");
                    else if (GUID_IO_MEDIA_REMOVAL == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_MEDIA_REMOVAL");
                    else if (GUID_IO_VOLUME_LOCK == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_VOLUME_LOCK");
                    else if (GUID_IO_VOLUME_LOCK_FAILED == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_VOLUME_LOCK_FAILED");
                    else if (GUID_IO_VOLUME_UNLOCK == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_VOLUME_UNLOCK");
                    else if (GUID_IO_VOLUME_NAME_CHANGE == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_VOLUME_NAME_CHANGE");
                    else if (GUID_IO_VOLUME_CHANGE == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_VOLUME_CHANGE");
                    else
                    {
                        hrTmp = _StringFromGUID(&(pdbh->dbch_eventguid), szGUID, ARRAYSIZE(szGUID));
                        pszEventType = szGUID;
                    }

                    if (SUCCEEDED(hrTmp))
                    {
                        TRACE(TF_SHHWDTCTDTCT,
                            TEXT("Processing Broadcast Event: %s, hdevnotify = 0x%08X"),
                            pszEventType, pdbh->dbch_hdevnotify);
                    }
                }
                else
                {
                    pszEventType = TEXT("unknown");

                    switch (dwEventType)
                    {
                        case DBT_DEVICEARRIVAL: pszEventType = TEXT("DBT_DEVTYP_HANDLE + DBT_DEVICEARRIVAL"); break;
                        case DBT_DEVICEQUERYREMOVE: pszEventType = TEXT("DBT_DEVTYP_HANDLE + DBT_DEVICEQUERYREMOVE"); break;
                        case DBT_DEVICEQUERYREMOVEFAILED: pszEventType = TEXT("DBT_DEVTYP_HANDLE + DBT_DEVICEQUERYREMOVEFAILED"); break;
                        case DBT_DEVICEREMOVEPENDING: pszEventType = TEXT("DBT_DEVTYP_HANDLE + DBT_DEVICEREMOVEPENDING"); break;
                        case DBT_DEVICEREMOVECOMPLETE: pszEventType = TEXT("DBT_DEVTYP_HANDLE + DBT_DEVICEREMOVECOMPLETE"); break;
                    }
                    TRACE(TF_SHHWDTCTDTCT, TEXT("Processing Unknown Broadcast Event: %s, dwEventType = 0x%08X"), pszEventType, dwEventType);
                }
#endif
                hres = _HandleBroadcastHandleEvent(pdbh, dwEventType);
            }
            else
            {
            }
        }
    }

    ASSERTVALIDSTATE();

    return hres;
}

STDMETHODIMP CHWEventDetectorImpl::Run()
{
    ASSERTVALIDSTATE();

    // Nothing to do for now.
    return S_OK;
}

STDMETHODIMP CHWEventDetectorImpl::HandlePowerEvent(
    DWORD UNREF_PARAM(dwEventType), LPVOID UNREF_PARAM(pEventData))
{
    HRESULT hres = E_UNEXPECTED;

    return hres;
}

STDMETHODIMP CHWEventDetectorImpl::HandleHWProfileEvent(
    DWORD UNREF_PARAM(dwEventType), LPVOID UNREF_PARAM(pEventData))
{
    HRESULT hres = E_UNEXPECTED;

    return hres;
}

STDMETHODIMP CHWEventDetectorImpl::HandleSessionChange(
    DWORD dwEventType, LPVOID UNREF_PARAM(pvEventData))
{
    HRESULT hres;

    switch (dwEventType)
    {
    case WTS_SESSION_LOGOFF:
        //
        //  When this happens, we need to check our handles to see which
        //  Explorer process went away and free its handle.
        //
        hres = CHardwareDevicesImpl::_AdviseCheckClients( );
        break;

    default:
        hres = S_OK;
        break;
    }

    return hres;
}

#ifdef DEBUG
void CHWEventDetectorImpl::_DbgAssertValidState()
{
    CHWEventDetectorHelper::_DbgAssertValidState();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\dtct.h ===
///////////////////////////////////////////////////////////////////////////////
// Hardware Event Detector
///////////////////////////////////////////////////////////////////////////////
#ifndef _SHHWDTCT_H
#define _SHHWDTCT_H

#include "unk.h"
#include "service.h"
#include "namellst.h"

#include <dbt.h>

#define HINT_NONE       0
#define HINT_NEW        1

extern const CLSID CLSID_HWEventDetector;

class CHWEventDetectorImpl : public CCOMBase, public IService
{
public:
    // Interface IService
    STDMETHODIMP InitMinimum(DWORD cArg, LPWSTR* ppszArgs,
        LPCWSTR pszEventRelinquishControl, DWORD* pdwCtrlAccept,
        BOOL* pfWantsDeviceEvents);
    STDMETHODIMP InitDeviceEventHandler(SERVICE_STATUS_HANDLE ssh);
    STDMETHODIMP InitFinal();

    STDMETHODIMP Run();

    // return S_FALSE and a non-zero dwWaitHint if pending
    STDMETHODIMP HandleServiceControl(DWORD dwControlCode, DWORD* pdwWaitHint);

    STDMETHODIMP HandlePowerEvent(DWORD dwEventType, LPVOID pEventData);
    STDMETHODIMP HandleDeviceEvent(DWORD dwEventType, LPVOID pEventData);
    STDMETHODIMP HandleHWProfileEvent(DWORD dwEventType, LPVOID pEventData);
    STDMETHODIMP HandleSessionChange(DWORD dwEventType, LPVOID pvEventData);

public:
    CHWEventDetectorImpl();
    ~CHWEventDetectorImpl();

    static HRESULT HandleVolumeMediaEvent(LPCWSTR pszDeviceIDVolume,
        class CHWDeviceInst* phwdevinst, LPCWSTR pszEventType,
        BOOL* pfHasHandler);

private:
    HRESULT _HandleInterfaceEvent(DEV_BROADCAST_DEVICEINTERFACE* pdbdi,
        DWORD dwEventType);
    HRESULT _HandleBroadcastHandleEvent(DEV_BROADCAST_HANDLE* pdbh,
        DWORD dwEventType);

    HRESULT _RegisterForNotif();
    HRESULT _UnregisterForNotif();

    // COM Server stuff
    HRESULT _RegisterFactories();
    HRESULT _UnregisterFactories();
    HRESULT _SuspendFactories();
    HRESULT _ResumeFactories();

private:
    HANDLE                          _hEventRelinquishControl;
    HDEVNOTIFY                      _hdevnotifyAllInterfaces;
    HANDLE                          _hEventInitCompleted;

#ifdef DEBUG
    void _DbgAssertValidState();
#endif
};

typedef CUnkTmpl<CHWEventDetectorImpl> CHWEventDetector;

// for now
HRESULT _ExecuteHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPCWSTR pszHandler);

HRESULT _FinalDispatch(LPCWSTR pszDeviceIntfID, LPCWSTR pszEventType,
    LPCWSTR pszEventHandler);

HRESULT _DispatchToHandler(LPCWSTR pszDeviceIntfID,
    class CHWDeviceInst* phwdevinst, LPCWSTR pszEventType,
    BOOL* pfHasHandler);

HRESULT _ProcessInterfaceSpecialCased(GUID* pguidInterface,
    LPCWSTR pszDeviceID, DWORD dwEventType);
HRESULT _IsInterfaceSpecialCased(GUID* pguidClass, BOOL* pfSpecialCased);

HRESULT _TryAutoplay(LPCWSTR pszDeviceIntfID, CHWDeviceInst* phwdevinst,
    DWORD dwEventType);

#endif // _SHHWDTCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\factdata.cpp ===
///////////////////////////////////////////////////////////////////////////////
// This file contains the component server code.  The FactoryDataArray contains
// the components that can be served.
//
// The following array contains the data used by CFactory to create components.
// Each element in the array contains the CLSID, the pointer to the creation
// function, and the name of the component to place in the Registry.

#include "factdata.h"
#include "fact.h"

#include "dtct.h"

#include "devinfo.h"
#include "settings.h"
#include "cstmprop.h"
#include "regnotif.h"

const CLSID APPID_ShellHWDetection = { /* b1b9cbb2-b198-47e2-8260-9fd629a2b2ec */
    0xb1b9cbb2,
    0xb198,
    0x47e2,
    {0x82, 0x60, 0x9f, 0xd6, 0x29, 0xa2, 0xb2, 0xec}
};

CFactoryData g_FactoryDataArray[] =
{
    {
        &CLSID_HWEventDetector,
        CHWEventDetector::UnkCreateInstance,
		L"Shell.HWEventDetector",           // Friendly name
		L"Shell.HWEventDetector.1",         // ProgID
		L"Shell.HWEventDetector",           // Version-independent
        THREADINGMODEL_FREE,          // ThreadingModel == Free
        // this is not a COM server, so following are N/A
        NULL,                         // CoRegisterClassObject context
        NULL,                         // CoRegisterClassObject flags
        NULL,                         // ServiceName
        NULL,
    },
    {
        &CLSID_HWEventSettings,
        CAutoplayHandler::UnkCreateInstance,
        L"AutoplayHandler",                // Friendly name
        L"AutoplayHandler.1",              // ProgID
        L"AutoplayHandler",                // Version-independent
        THREADINGMODEL_FREE,          // ThreadingModel == Free
        CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE,
        L"ShellHWDetection",
        &APPID_ShellHWDetection,
    },
    {
        &CLSID_AutoplayHandlerProperties,
        CAutoplayHandlerProperties::UnkCreateInstance,
        L"AutoplayHandlerProperties",                // Friendly name
        L"AutoplayHandlerProperties.1",              // ProgID
        L"AutoplayHandlerProperties",                // Version-independent
        THREADINGMODEL_FREE,          // ThreadingModel == Free
        CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE,
        L"ShellHWDetection",
        &APPID_ShellHWDetection,
    },
    {
        &CLSID_HWDevice,
        CHWDevice::UnkCreateInstance,
        L"HWDevice",                // Friendly name
        L"HWDevice.1",              // ProgID
        L"HWDevice",                // Version-independent
        THREADINGMODEL_FREE,          // ThreadingModel == Free
        CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE,
        L"ShellHWDetection",
        &APPID_ShellHWDetection,
    },
    {
        &CLSID_HardwareDevices,
        CHardwareDevices::UnkCreateInstance,
        L"HardwareDeviceNotif",                // Friendly name
        L"HardwareDeviceNotif.1",              // ProgID
        L"HardwareDeviceNotif",                // Version-independent
        THREADINGMODEL_FREE,          // ThreadingModel == Free
        CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE,
        L"ShellHWDetection",
        &APPID_ShellHWDetection,
    },
    {
        &CLSID_HWDeviceCustomProperties,
        CHWDeviceCustomProperties::UnkCreateInstance,
        L"HWDeviceCustomProperties",                // Friendly name
        L"HWDeviceCustomProperties.1",              // ProgID
        L"HWDeviceCustomProperties",                // Version-independent
        THREADINGMODEL_FREE,          // ThreadingModel == Free
        CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE,
        L"ShellHWDetection",
        &APPID_ShellHWDetection,
    },
};

const CFactoryData* CCOMBaseFactory::_pDLLFactoryData = g_FactoryDataArray;

const DWORD CCOMBaseFactory::_cDLLFactoryData = sizeof(g_FactoryDataArray) /
    sizeof(g_FactoryDataArray[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\dtctreg.h ===
#include <objbase.h>

class CHWDeviceInst;

//=============================================================================
HRESULT _GetEventHandlerFromDeviceHandler(LPCWSTR pszDeviceHandler,
    LPCWSTR pszEventType, LPWSTR pszEventHandler, DWORD cchEventHandler);

//=============================================================================
HRESULT _GetActionFromHandler(LPCWSTR pszHandler, LPWSTR pszAction,
    DWORD cchAction);

HRESULT _GetProviderFromHandler(LPCWSTR pszHandler, LPWSTR pszProvider,
    DWORD cchProvider);

HRESULT _GetIconLocationFromHandler(LPCWSTR pszHandler,
    LPWSTR pszIconLocation, DWORD cchIconLocation);

HRESULT _GetInvokeProgIDFromHandler(LPCWSTR pszHandler,
    LPWSTR pszInvokeProgID, DWORD cchInvokeProgID);

HRESULT _GetInvokeVerbFromHandler(LPCWSTR pszHandler,
    LPWSTR pszInvokeVerb, DWORD cchInvokeVerb);

// Uses the CTSTR_ flags in shpriv.idl
HRESULT _GetEventFriendlyName(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPWSTR pszFriendlyName, DWORD cchFriendlyName);

HRESULT _GetEventIconLocation(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPWSTR pszIconLocation, DWORD cchIconLocation);

//=============================================================================
HRESULT _GetDeviceHandler(CHWDeviceInst* phwdevinst,
    LPWSTR pszDeviceHandler, DWORD cchDeviceHandler);

//=============================================================================
HRESULT _GetHandlerCLSID(LPCWSTR pszEventHandler, CLSID* pclsid);
HRESULT _GetHandlerCancelCLSID(LPCWSTR pszHandler, CLSID* pclsid);
HRESULT _GetInitCmdLine(LPCWSTR pszEventHandler, LPWSTR* ppsz);

//=============================================================================
#define GUH_IMPERSONATEUSER     TRUE
#define GUH_USEWINSTA0USER      FALSE

HRESULT _GetUserDefaultHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventHandler,
    LPWSTR pszHandler, DWORD cchHandler, BOOL fImpersonateCaller);
HRESULT _SetUserDefaultHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventHandler,
    LPCWSTR pszHandler);
HRESULT _SetSoftUserDefaultHandler(LPCWSTR pszDeviceID,
    LPCWSTR pszEventHandler, LPCWSTR pszHandler);

HRESULT _GetHandlerForNoContent(LPCWSTR pszEventHandler, LPWSTR pszHandler,
    DWORD cchHandler);

//=============================================================================
HRESULT _FindDeepestSubkeyName(LPCWSTR pszSubKey, CHWDeviceInst* phwdevinst,
    LPWSTR pszKey, DWORD cchKey);

//=============================================================================
HRESULT _GetDevicePropertyAsString(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, LPCWSTR psz, DWORD cch);

HRESULT _GetDevicePropertyStringNoBuf(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, DWORD* pdwType,
    LPWSTR* ppszProp);

HRESULT _GetDevicePropertyGenericAsBlob(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BYTE_BLOB** ppblob);

HRESULT _GetDevicePropertyGenericAsMultiSz(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, WORD_BLOB** ppblob);

HRESULT _GetDevicePropertyGeneric(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, DWORD* pdwType, LPBYTE pbData,
    DWORD cbData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\gdtinfo.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <shpriv.h>

HRESULT _GetDriveTypeInfo(HANDLE hDevice, DWORD* pdwDriveType, BOOL* pfFloppy)
{
    HRESULT hr;
    FILE_FS_DEVICE_INFORMATION ffsdi = {0};
    IO_STATUS_BLOCK iosb;

    NTSTATUS ntstatus = NtQueryVolumeInformationFile(hDevice, &iosb, &ffsdi,
        sizeof(ffsdi), FileFsDeviceInformation);

    if (NT_SUCCESS(ntstatus))
    {
        switch (ffsdi.DeviceType)
        {
            case FILE_DEVICE_CD_ROM:
            case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
            case FILE_DEVICE_CHANGER:

                *pdwDriveType = HWDTS_CDROM;
                break;

            case FILE_DEVICE_DISK:
            case FILE_DEVICE_DISK_FILE_SYSTEM:

                if (FILE_REMOVABLE_MEDIA & ffsdi.Characteristics)
                {
                    *pdwDriveType = HWDTS_REMOVABLEDISK;

                    if (FILE_FLOPPY_DISKETTE & ffsdi.Characteristics)
                    {
                        *pfFloppy = TRUE;
                    }
                }
                else
                {
                    *pdwDriveType = HWDTS_FIXEDDISK;
                }

                break;

            default:
                // What the hell???
                *pdwDriveType = HWDTS_FIXEDDISK;
                break;
        }

        hr = S_OK;
    }
    else
    {
        *pdwDriveType = HWDTS_FIXEDDISK;

        hr = S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\dtctimp.cpp ===
#include "dtct.h"

#include "fact.h"

#include "vol.h"
#include "hnotif.h"
#include "miscdev.h"
#include "dtctreg.h"
#include "regnotif.h"

#include "cmmn.h"
#include "sfstr.h"
#include "misc.h"
#include "str.h"

#include "dbg.h"
#include "tfids.h"

#include <ioevent.h>
#include <dbt.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _HandleDeviceEvent(LPCWSTR pszDeviceIntfID, CHWDeviceInst* phwdevinst,
    LPCWSTR pszEventType, BOOL* pfHasHandler)
{
    HRESULT hres = _DispatchToHandler(pszDeviceIntfID, phwdevinst,
        pszEventType, pfHasHandler);

    if (SUCCEEDED(hres))
    {
        TRACE(TF_SHHWDTCTDTCT, TEXT("_DispatchToHandler SUCCEEDED"));
    }
    else
    {
        TRACE(TF_SHHWDTCTDTCT, TEXT("_DispatchToHandler FAILED: 0x%08X"),
            hres);

        hres = S_FALSE;
    }

    return hres;
}

// {A5DCBF10-6530-11D2-901F-00C04FB951ED}
const CLSID guidInterfaceUSB =
    {0xA5DCBF10, 0x6530, 0x11D2,
    {0x90, 0x1F, 0x00, 0xC0, 0x4F, 0xB9, 0x51, 0xED}};

// {53F5630A-B6BF-11D0-94F2-00A0C91EFB8B}
const CLSID guidInterfacePartition =
    {0x53F5630A, 0xB6BF, 0x11D0,
    {0x94, 0xF2, 0x00, 0xA0, 0xC9, 0x1E, 0xFB, 0x8B}};

HRESULT _IsInterfaceInList(const GUID* pguidInterface, const CLSID* rgList[], DWORD cList,
    BOOL* pfPresent)
{
    *pfPresent = FALSE;

    for (DWORD dw = 0; !(*pfPresent) && (dw < cList); ++dw)
    {
        if (*(rgList[dw]) == *pguidInterface)
        {
            *pfPresent = TRUE;
        }
    }

    return S_OK;
}

const CLSID* _rgpguidRejectedInterface[] =
{
    &guidInterfacePartition,
};

HRESULT _IsInterfaceRejected(GUID* pguidInterface, BOOL* pfRejected)
{
    return _IsInterfaceInList(pguidInterface, _rgpguidRejectedInterface,
        ARRAYSIZE(_rgpguidRejectedInterface), pfRejected);
}

const CLSID* _rgpguidSpecialInterface[] =
{
    &guidInterfaceUSB,
};

HRESULT _IsInterfaceSpecial(GUID* pguidInterface, BOOL* pfSpecial)
{
    return _IsInterfaceInList(pguidInterface, _rgpguidSpecialInterface,
        ARRAYSIZE(_rgpguidRejectedInterface), pfSpecial);
}

HRESULT _TryAutoplay(LPCWSTR pszDeviceIntfID, CHWDeviceInst* phwdevinst,
    DWORD dwEventType)
{
    LPCWSTR pszEventType = NULL;
    HRESULT hres;

    if (DBT_DEVICEARRIVAL == dwEventType)
    {
        pszEventType = TEXT("DeviceArrival");
    }   
    else
    {
        if (DBT_DEVICEREMOVECOMPLETE == dwEventType)
        {
            pszEventType = TEXT("DeviceRemoval");
        }   
        else
        {
            ASSERT(FALSE);
        }
    }

    if (pszEventType)
    {
        // Useless in this case
        BOOL fHasHandler;

        hres = _HandleDeviceEvent(pszDeviceIntfID, phwdevinst,
            pszEventType, &fHasHandler);
    }
    else
    {
        hres = S_FALSE;
    }

    return hres;
}

const CLSID* _rgpguidRequiringAdviseInterface[] =
{
    &guidInterfaceUSB,
    &guidVideoCameraClass,
    &guidImagingDeviceClass,
};

HRESULT _IsInterfaceRequiringAdvise(GUID* pguidInterface, BOOL* pfRequiringAdvise)
{
    return _IsInterfaceInList(pguidInterface, _rgpguidRequiringAdviseInterface,
        ARRAYSIZE(_rgpguidRequiringAdviseInterface), pfRequiringAdvise);
}

// If it's one of the few interfaces requiring advise, or if the device has a
// DeviceHandler we send notifications
HRESULT _AdviseDeviceArrivedOrRemovedHelper(GUID* pguidInterface,
    LPCWSTR pszDeviceIntfID, CHWDeviceInst* phwdevinst, DWORD dwEventType)
{
    BOOL fAdvise;
    HRESULT hr = _IsInterfaceRequiringAdvise(pguidInterface, &fAdvise);

    // This should never get here
    ASSERT(guidVolumeClass != *pguidInterface);

    if (SUCCEEDED(hr))
    {
        DWORD dwDeviceFlags = HWDDF_HASDEVICEHANDLER_UNDETERMINED;

        if (phwdevinst)
        {
            WCHAR szDeviceHandler[MAX_DEVICEHANDLER];
            HRESULT hrTmp = _GetDeviceHandler(phwdevinst, szDeviceHandler,
                ARRAYSIZE(szDeviceHandler));

            if (SUCCEEDED(hrTmp) && (S_FALSE != hrTmp))
            {
                fAdvise = TRUE;
                dwDeviceFlags &= ~HWDDF_HASDEVICEHANDLER_UNDETERMINED;
                dwDeviceFlags |= HWDDF_HASDEVICEHANDLER;
            }
        }

        if (fAdvise)
        {
            BOOL fRemovableDevice;
            LPCWSTR pszDeviceEvent;

            if (DBT_DEVICEARRIVAL == dwEventType)
            {
                pszDeviceEvent = TEXT("DeviceArrival");
            }
            else
            {
                ASSERT(DBT_DEVICEREMOVECOMPLETE == dwEventType);

                pszDeviceEvent = TEXT("DeviceRemoval");
            }

            dwDeviceFlags |= HWDDF_REMOVABLEDEVICE_UNDETERMINED;

            if (phwdevinst)
            {
                hr = phwdevinst->IsRemovableDevice(&fRemovableDevice);

                if (SUCCEEDED(hr))
                {
                    if (fRemovableDevice)
                    {
                        dwDeviceFlags &= ~HWDDF_REMOVABLEDEVICE_UNDETERMINED;
                        dwDeviceFlags |= HWDDF_REMOVABLEDEVICE;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = CHardwareDevicesImpl::_AdviseDeviceArrivedOrRemoved(
                    pszDeviceIntfID, pguidInterface, dwDeviceFlags,
                    pszDeviceEvent);
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

HRESULT _ProcessInterface(GUID* pguidInterface, LPCWSTR pszDeviceIntfID,
    DWORD dwEventType)
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_MISCDEVINTF, &pnel);

    if (SUCCEEDED(hr))
    {
        if (DBT_DEVICEARRIVAL == dwEventType)
        {
            CNamedElem* pelem;

            hr = pnel->GetOrAdd(pszDeviceIntfID, &pelem);

            if (SUCCEEDED(hr))
            {
                BOOL fRemoveFromList = TRUE;
                CMiscDeviceInterface* pmdi = (CMiscDeviceInterface*)pelem;

                // If we're adding it, let's finish its initialization
                hr = pmdi->InitInterfaceGUID(pguidInterface);

                if (SUCCEEDED(hr))
                {
                    CHWDeviceInst* phwdevinst;

                    hr = pmdi->GetHWDeviceInst(&phwdevinst);

                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                    {
                        BOOL f;
                        
                        _AdviseDeviceArrivedOrRemovedHelper(pguidInterface,
                            pszDeviceIntfID, phwdevinst, dwEventType);

                        hr = phwdevinst->IsRemovableDevice(&f);

                        if (SUCCEEDED(hr) & f)
                        {
                            hr = _IsInterfaceSpecial(pguidInterface, &f);

                            if (SUCCEEDED(hr) & f)
                            {
                                hr = phwdevinst->ShouldAutoplayOnSpecialInterface(
                                    pguidInterface, &f);

                                if (FAILED(hr) || (S_FALSE == hr))
                                {
                                    f = FALSE;
                                }
                            }
                            else
                            {
                                f = TRUE;
                            }

                            if (f)
                            {
                                hr = _TryAutoplay(pszDeviceIntfID, phwdevinst,
                                    dwEventType);

                                fRemoveFromList = FALSE;
                            }
                        }
                    }
                }

                if (fRemoveFromList)
                {
                    hr = pnel->Remove(pszDeviceIntfID);
                }

                pelem->RCRelease();
            }
        }
        else
        {
            CNamedElem* pelem;

            hr = pnel->Get(pszDeviceIntfID, &pelem);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                CHWDeviceInst* phwdevinst;
                CMiscDeviceInterface* pmdi = (CMiscDeviceInterface*)pelem;
                hr = pmdi->GetHWDeviceInst(&phwdevinst);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    _AdviseDeviceArrivedOrRemovedHelper(pguidInterface,
                        pszDeviceIntfID, phwdevinst, dwEventType);

                    hr = _TryAutoplay(pszDeviceIntfID, phwdevinst,
                        dwEventType);

                    // If we're removing it, let's remove it from the list
                    HRESULT hr2 = pnel->Remove(pszDeviceIntfID);

                    hr = FAILED(hr2) ? hr2 : hr;
                }

                pelem->RCRelease();
            }
            else
            {
                _AdviseDeviceArrivedOrRemovedHelper(pguidInterface,
                    pszDeviceIntfID, NULL, dwEventType);
            }
        }

        pnel->RCRelease();
    }

    return hr;
}

HRESULT CHWEventDetectorImpl::_HandleInterfaceEvent(
    DEV_BROADCAST_DEVICEINTERFACE* pdbdi, DWORD dwEventType)
{
    HRESULT hres = S_FALSE;

    if (pdbdi->dbcc_name[0])
    {
        BOOL fSpecialCased;

        hres = _IsInterfaceSpecialCased(&(pdbdi->dbcc_classguid),
            &fSpecialCased);

        if (SUCCEEDED(hres))
        {
            if (fSpecialCased)
            {
                TRACE(TF_SHHWDTCTDTCT, TEXT("---> Special case"));

                hres = _ProcessInterfaceSpecialCased(&(pdbdi->dbcc_classguid),
                    pdbdi->dbcc_name, dwEventType);
            }
            else
            {
                if ((DBT_DEVICEARRIVAL == dwEventType) ||
                    (DBT_DEVICEREMOVECOMPLETE == dwEventType))
                {
                    BOOL fRejected;

                    hres = _IsInterfaceRejected(&(pdbdi->dbcc_classguid),
                        &fRejected);

                    if (SUCCEEDED(hres))
                    {
                        if (!fRejected)
                        {
                            TRACE(TF_SHHWDTCTDTCT, TEXT("---> Regular processing"));

                            hres = _ProcessInterface(&(pdbdi->dbcc_classguid),
                                pdbdi->dbcc_name, dwEventType);
                        }
                        else
                        {
                            TRACE(TF_SHHWDTCTDTCT, TEXT("---> Rejected"));
                        }
                    }
                }
                else
                {
                    TRACE(TF_SHHWDTCTDTCT, TEXT("---> Not deviceArrival/Removal"));
                }
            }
        }
    }
    else
    {
        // why do we get this?
    }

    return hres;
}

// This is for volumes only
// static
HRESULT CHWEventDetectorImpl::HandleVolumeMediaEvent(LPCWSTR pszDeviceIDVolume,
    CHWDeviceInst* phwdevinst, LPCWSTR pszEventType, 
    BOOL* pfHasHandler)
{
    return _HandleDeviceEvent(pszDeviceIDVolume, phwdevinst, pszEventType,
        pfHasHandler);
}

// This is for volumes only
HRESULT CHWEventDetectorImpl::_HandleBroadcastHandleEvent(
    DEV_BROADCAST_HANDLE* pdbh, DWORD dwEventType)
{
    HRESULT hres = S_OK;

    if (DBT_CUSTOMEVENT == dwEventType)
    {
        if ((GUID_IO_VOLUME_MOUNT == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_DISMOUNT == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_DISMOUNT_FAILED == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_LOCK == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_UNLOCK == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_LOCK_FAILED == pdbh->dbch_eventguid) ||
            (GUID_IO_MEDIA_ARRIVAL == pdbh->dbch_eventguid) ||
            (GUID_IO_MEDIA_REMOVAL == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_CHANGE == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_NAME_CHANGE == pdbh->dbch_eventguid))
        {
            hres = CHandleNotif::HandleBroadcastHandleEvent(pdbh, dwEventType);
        }
        else
        {
#ifdef DEBUG
            WCHAR szGUID[MAX_GUIDSTRING];

            if (SUCCEEDED(_StringFromGUID(&(pdbh->dbch_eventguid), szGUID,
                ARRAYSIZE(szGUID))))
            {
                TRACE(TF_SHHWDTCTDTCT,
                    TEXT("UNHANDLED! DBT_CUSTOMEVENT + %s for '0x%08X'"),
                    szGUID, pdbh->dbch_handle);
            }
#endif
        }
    }
    else
    {
        if ((DBT_DEVICEQUERYREMOVE == dwEventType) ||
            (DBT_DEVICEREMOVEPENDING == dwEventType) ||
            (DBT_DEVICEQUERYREMOVEFAILED == dwEventType) ||
            (DBT_DEVICEREMOVECOMPLETE == dwEventType))
        {
            hres = CHandleNotif::HandleBroadcastHandleEvent(pdbh, dwEventType);
        }
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHWEventDetectorImpl::_RegisterForNotif()
{
    HRESULT hres = CHWEventDetectorHelper::CreateLists();
    
    if (SUCCEEDED(hres))
    {
        hres = CHWEventDetectorHelper::FillLists();

        if (SUCCEEDED(hres))
        {
            // Register for all Device Interface Events
            DEV_BROADCAST_DEVICEINTERFACE dbdNotifFilter = {0};

            dbdNotifFilter.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
            dbdNotifFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
            dbdNotifFilter.dbcc_classguid = guidInvalid;

            hres = CHWEventDetectorHelper::RegisterDeviceNotification(
                &dbdNotifFilter, &_hdevnotifyAllInterfaces, TRUE);
        }
    }

    return hres;
}

HRESULT CHWEventDetectorImpl::_UnregisterForNotif()
{
    CHWEventDetectorHelper::EmptyLists();
    UnregisterDeviceNotification(_hdevnotifyAllInterfaces);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHWEventDetectorImpl::_RegisterFactories()
{
    // TRUE: we want it to stay around
    HRESULT hres = (CCOMBaseFactory::_RegisterFactories(TRUE) ? S_OK : E_FAIL);

    TRACE(TF_COMSERVER, TEXT("CHWEventDetectorImpl::_RegisterFactories returns: 0x%08X"), hres);

    return hres;
}

HRESULT CHWEventDetectorImpl::_UnregisterFactories()
{
    // TRUE: we wanted it to stay around
    HRESULT hres = (CCOMBaseFactory::_UnregisterFactories(TRUE) ? S_OK : E_FAIL);
    
    TRACE(TF_COMSERVER, TEXT("CHWEventDetectorImpl::_UnregisterFactories returns: 0x%08X"), hres);

    return hres;
}

HRESULT CHWEventDetectorImpl::_SuspendFactories()
{
    HRESULT hres = (CCOMBaseFactory::_SuspendFactories() ? S_OK : E_FAIL);
    
    TRACE(TF_COMSERVER, TEXT("CHWEventDetectorImpl::_SuspendFactories returns: 0x%08X"), hres);

    return hres;
}

HRESULT CHWEventDetectorImpl::_ResumeFactories()
{
    HRESULT hres = (CCOMBaseFactory::_ResumeFactories() ? S_OK : E_FAIL);
    
    TRACE(TF_COMSERVER, TEXT("CHWEventDetectorImpl::_ResumeFactories returns: 0x%08X"), hres);

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
CHWEventDetectorImpl::CHWEventDetectorImpl() : _hEventRelinquishControl(NULL),
    _hdevnotifyAllInterfaces(NULL), _hEventInitCompleted(NULL)
{}

CHWEventDetectorImpl::~CHWEventDetectorImpl()
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\dtctu.cpp ===
#include "dtct.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY hweventdetectorIME[] =
{
    _INTFMAPENTRY(CHWEventDetector, IService),
};

const INTFMAPENTRY* CHWEventDetector::_pintfmap = hweventdetectorIME;
const DWORD CHWEventDetector::_cintfmap =
    (sizeof(hweventdetectorIME)/sizeof(hweventdetectorIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CHWEventDetector::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\dtctreg.cpp ===
#include "dtctreg.h"

#include "hwdev.h"

#include "pnp.h"

#include "cmmn.h"

#include "sfstr.h"
#include "reg.h"
#include "misc.h"

#include "shobjidl.h"
#include "shpriv.h"

#include "users.h"

#include "strsafe.h"
#include "str.h"
#include "dbg.h"

#include "mischlpr.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT _GetValueToUse(LPWSTR pszKeyName, LPWSTR psz, DWORD cch)
{
    HKEY hkey;
    HRESULT hr = _RegOpenKey(HKEY_LOCAL_MACHINE, pszKeyName, &hkey);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        // For now we take the first one.
        hr = _RegEnumStringValue(hkey, 0, psz, cch);

        _RegCloseKey(hkey);
    }

    return hr; 
}

// Return Values:
//      S_FALSE: Can't find it
HRESULT _GetEventHandlerFromKey(LPCWSTR pszKeyName, LPCWSTR pszEventType,
    LPWSTR pszEventHandler, DWORD cchEventHandler)
{
    WCHAR szEventHandler[MAX_KEY];
    DWORD cchLeft;
    LPWSTR pszNext;
    HRESULT hr = SafeStrCpyNEx(szEventHandler, pszKeyName,
        ARRAYSIZE(szEventHandler), &pszNext, &cchLeft);

    if (SUCCEEDED(hr))
    {
        hr = SafeStrCpyNEx(pszNext, TEXT("\\EventHandlers\\"), cchLeft,
            &pszNext, &cchLeft);

        if (SUCCEEDED(hr))
        {
            hr = SafeStrCpyN(pszNext, pszEventType, cchLeft);

            if (SUCCEEDED(hr))
            {
                hr = _GetValueToUse(szEventHandler, pszEventHandler,
                    cchEventHandler);
            }
        }
    }

    return hr;
}

// Return Values:
//      S_FALSE: Can't find it
HRESULT _GetEventHandlerFromDeviceHandler(LPCWSTR pszDeviceHandler,
    LPCWSTR pszEventType, LPWSTR pszEventHandler, DWORD cchEventHandler)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("DeviceHandlers\\"));
    HRESULT hr = SafeStrCatN(szKeyName, pszDeviceHandler,
        ARRAYSIZE(szKeyName));

    if (SUCCEEDED(hr))
    {
        hr = _GetEventHandlerFromKey(szKeyName, pszEventType, pszEventHandler,
            cchEventHandler);
    }

    return hr;
}

HRESULT _GetStuffFromHandlerHelper(LPCWSTR pszHandler, LPCWSTR pszValueName,
    LPWSTR psz, DWORD cch)
{
    HKEY hkey;
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("Handlers\\"));
    HRESULT hr = _RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hkey);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        hr = _RegQueryString(hkey, pszHandler,
            pszValueName, psz, cch);

        _RegCloseKey(hkey);
    }

    return hr;
}

HRESULT _GetActionFromHandler(LPCWSTR pszHandler, LPWSTR pszAction,
    DWORD cchAction)
{
    HRESULT hr = _GetStuffFromHandlerHelper(pszHandler, TEXT("Action"),
        pszAction, cchAction);

    if (SUCCEEDED(hr) && (S_FALSE == hr))
    {
        hr = _GetStuffFromHandlerHelper(pszHandler, TEXT("FriendlyName"),
            pszAction, cchAction);        
    }

    return hr;
}

HRESULT _GetProviderFromHandler(LPCWSTR pszHandler, LPWSTR pszProvider,
    DWORD cchProvider)
{
    HRESULT hr = _GetStuffFromHandlerHelper(pszHandler, TEXT("Provider"),
        pszProvider, cchProvider);

    if (SUCCEEDED(hr) && (S_FALSE == hr))
    {
        hr = SafeStrCpyN(pszProvider, TEXT("<need provider>"), cchProvider);
    }

    return hr;
}

HRESULT _GetIconLocationFromHandler(LPCWSTR pszHandler,
    LPWSTR pszIconLocation, DWORD cchIconLocation)
{
    return _GetStuffFromHandlerHelper(pszHandler, TEXT("DefaultIcon"),
        pszIconLocation, cchIconLocation);
}

HRESULT _GetInvokeProgIDFromHandler(LPCWSTR pszHandler,
    LPWSTR pszInvokeProgID, DWORD cchInvokeProgID)
{
    return _GetStuffFromHandlerHelper(pszHandler, TEXT("InvokeProgID"),
        pszInvokeProgID, cchInvokeProgID);
}

HRESULT _GetInvokeVerbFromHandler(LPCWSTR pszHandler,
    LPWSTR pszInvokeVerb, DWORD cchInvokeVerb)
{
    return _GetStuffFromHandlerHelper(pszHandler, TEXT("InvokeVerb"),
        pszInvokeVerb, cchInvokeVerb);
}

HRESULT _GetDevicePropertySize(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, DWORD* pcbSize)
{
    // Instance
    DEVINST devinst;

    HRESULT hr = phwdevinst->GetDeviceInstance(&devinst);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        BYTE rgb[1];
        ULONG ulData = sizeof(rgb);
        ULONG ulFlags = 0;

        if (fUseMergeMultiSz)
        {
            ulFlags = CM_CUSTOMDEVPROP_MERGE_MULTISZ;
        }

        CONFIGRET cr = CM_Get_DevNode_Custom_Property(devinst, pszPropName,
            NULL, rgb, &ulData, ulFlags);

        if (CR_SUCCESS != cr)
        {
            if (CR_BUFFER_SMALL == cr)
            {
                hr = S_OK;

                *pcbSize = ulData;
            }
            else
            {
                // If we do not have the data at the instance level, let's try it
                // at the DeviceGroup level.

                // DeviceGroup
                WCHAR szDeviceGroup[MAX_DEVICEGROUP];

                ulData = sizeof(szDeviceGroup);
                cr = CM_Get_DevNode_Custom_Property(devinst, TEXT("DeviceGroup"),
                    NULL, (PBYTE)szDeviceGroup, &ulData, 0);

                if (CR_SUCCESS == cr)
                {
                    WCHAR szKey[MAX_KEY] =
                        SHDEVICEEVENTROOT(TEXT("DeviceGroups\\"));
            
                    hr = SafeStrCatN(szKey, szDeviceGroup, ARRAYSIZE(szKey));

                    if (SUCCEEDED(hr))
                    {
                        hr = _GetPropertySizeHelper(szKey, pszPropName,
                            pcbSize);
                    }
                }
                else
                {
                    hr = S_FALSE;
                }
            }
        }
    }

    if (S_FALSE == hr)
    {
        // If we do not have the data at the instance level, nor the device
        // group level, let's try it at the DeviceClass level.

        // DeviceClass
        GUID guidInterface;

        hr = phwdevinst->GetInterfaceGUID(&guidInterface);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            WCHAR szKey[MAX_KEY];
            LPWSTR pszNext;
            DWORD cchLeft;

            hr = SafeStrCpyNEx(szKey,
                SHDEVICEEVENTROOT(TEXT("DeviceClasses\\")), ARRAYSIZE(szKey),
                &pszNext, &cchLeft);

            if (SUCCEEDED(hr))
            {
                hr = _StringFromGUID(&guidInterface, pszNext, cchLeft);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    hr = _GetPropertySizeHelper(szKey, pszPropName, pcbSize);
                }
            }
        }
    }

    return hr;
}

HRESULT _GetDevicePropertyGeneric(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, DWORD* pdwType, LPBYTE pbData,
    DWORD cbData)
{
    // Instance
    DEVINST devinst;

    HRESULT hr = phwdevinst->GetDeviceInstance(&devinst);

    if (CHWEventDetectorHelper::_fDiagnosticAppPresent)
    {
        WCHAR szPnpID[MAX_PNPID];
        WCHAR szGUID[MAX_GUIDSTRING];
        GUID guid;

        HRESULT hrTmp = phwdevinst->GetPnpID(szPnpID, ARRAYSIZE(szPnpID));

        if (SUCCEEDED(hrTmp) && (S_FALSE != hrTmp))
        {
            DIAGNOSTIC((TEXT("[0269]Device PnP ID: %s"), szPnpID));
        }

        hrTmp = phwdevinst->GetInterfaceGUID(&guid);

        if (SUCCEEDED(hrTmp) && (S_FALSE != hrTmp))
        {
            hrTmp = _StringFromGUID(&guid, szGUID, ARRAYSIZE(szGUID));

            if (SUCCEEDED(hrTmp))
            {
                DIAGNOSTIC((TEXT("[0270]Device Class ID: %s"), szGUID));
            }
        }
    }

    *pdwType = 0;

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        ULONG ulData = cbData;
        ULONG ulType;
        ULONG ulFlags = 0;

        if (fUseMergeMultiSz)
        {
            ulFlags = CM_CUSTOMDEVPROP_MERGE_MULTISZ;
        }

        CONFIGRET cr = CM_Get_DevNode_Custom_Property(devinst, pszPropName,
            &ulType, pbData, &ulData, ulFlags);

        if (CR_SUCCESS != cr)
        {
            // If we do not have the data at the instance level, let's try it
            // at the DeviceGroup level.

            // DeviceGroup
            WCHAR szDeviceGroup[MAX_DEVICEGROUP];

            DIAGNOSTIC((TEXT("[0252]Did NOT get Custom Property (%s) at device instance level"),
                pszPropName));

            ulData = sizeof(szDeviceGroup);
            cr = CM_Get_DevNode_Custom_Property(devinst, TEXT("DeviceGroup"),
                NULL, (PBYTE)szDeviceGroup, &ulData, 0);

            if (CR_SUCCESS == cr)
            {
                WCHAR szKey[MAX_KEY] =
                    SHDEVICEEVENTROOT(TEXT("DeviceGroups\\"));
            
                hr = SafeStrCatN(szKey, szDeviceGroup, ARRAYSIZE(szKey));

                if (SUCCEEDED(hr))
                {
                    hr = _GetPropertyHelper(szKey, pszPropName, pdwType,
                        pbData, cbData);

                    if (SUCCEEDED(hr))
                    {
                        if (S_FALSE != hr)
                        {
                            DIAGNOSTIC((TEXT("[0253]Got Custom Property (%s) at DeviceGroup level (%s)"),
                                pszPropName, szDeviceGroup));
                        }
                        else
                        {
                            DIAGNOSTIC((TEXT("[0254]Did NOT get Custom Property (%s) at DeviceGroup level (%s)"),
                                pszPropName, szDeviceGroup));
                        }
                    }
                }
            }
            else
            {
                hr = S_FALSE;
            }
        }
        else
        {
            DIAGNOSTIC((TEXT("[0251]Got Custom Property (%s) at device instance level"), pszPropName));
            *pdwType = (DWORD)ulType;
        }
    }

    if (S_FALSE == hr)
    {
        // If we do not have the data at the instance level, nor the device
        // group level, let's try it at the DeviceClass level.

        // DeviceClass
        GUID guidInterface;

        hr = phwdevinst->GetInterfaceGUID(&guidInterface);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            WCHAR szKey[MAX_KEY];
            LPWSTR pszNext;
            DWORD cchLeft;

            hr = SafeStrCpyNEx(szKey,
                SHDEVICEEVENTROOT(TEXT("DeviceClasses\\")), ARRAYSIZE(szKey),
                &pszNext, &cchLeft);

            if (SUCCEEDED(hr))
            {
                hr = _StringFromGUID(&guidInterface, pszNext, cchLeft);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    hr = _GetPropertyHelper(szKey, pszPropName, pdwType,
                        pbData, cbData);

                    if (SUCCEEDED(hr))
                    {
                        if (S_FALSE != hr)
                        {
                            DIAGNOSTIC((TEXT("[0255]Got Custom Property (%s) at DeviceClass level (%s)"),
                                pszPropName, pszNext));
                        }
                        else
                        {
                            DIAGNOSTIC((TEXT("[0256]Did NOT get Custom Property (%s) at DeviceClass level (%s)"),
                                pszPropName, pszNext));
                        }
                    }
                }
            }
        }
    }

    return hr;
}

HRESULT _GetDevicePropertyAsString(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, LPCWSTR psz, DWORD cch)
{
    DWORD dwType;
    DWORD cbData = cch * sizeof(WCHAR);

    return _GetDevicePropertyGeneric(phwdevinst, pszPropName, FALSE, &dwType,
        (PBYTE)psz, cbData);
}

HRESULT _GetDevicePropertyGenericAsMultiSz(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, WORD_BLOB** ppblob)
{
    DWORD cbSize = NULL;
    HRESULT hr = _GetDevicePropertySize(phwdevinst, pszPropName, FALSE,
        &cbSize);

    *ppblob = NULL;

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        WORD_BLOB* pblob = (WORD_BLOB*)CoTaskMemAlloc(
            sizeof(WORD_BLOB) + cbSize + sizeof(WCHAR));

        if (pblob)
        {
            DWORD dwType;
            DWORD cbSize2 = cbSize + sizeof(WCHAR);

            pblob->clSize = (cbSize + sizeof(WCHAR))/2;

            hr = _GetDevicePropertyGeneric(phwdevinst, pszPropName,
                fUseMergeMultiSz, &dwType, (PBYTE)(pblob->asData),
                cbSize2);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                if (REG_MULTI_SZ == dwType)
                {
                    DIAGNOSTIC((TEXT("[0265]Found Property: '%s'"), pszPropName));
                    *ppblob = pblob;
                    pblob = NULL;
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0266]Found Property: '%s', but NOT REG_MULTI_SZ type"), pszPropName));
                    hr = E_FAIL;
                }
            }

            if (pblob)
            {
                // It did not get assigned
                CoTaskMemFree(pblob);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT _GetDevicePropertyGenericAsBlob(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BYTE_BLOB** ppblob)
{
    DWORD cbSize = NULL;
    HRESULT hr = _GetDevicePropertySize(phwdevinst, pszPropName, FALSE,
        &cbSize);

    *ppblob = NULL;

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        BYTE_BLOB* pblob = (BYTE_BLOB*)CoTaskMemAlloc(
            sizeof(BYTE_BLOB) + cbSize);

        if (pblob)
        {
            DWORD dwType;

            pblob->clSize = cbSize;

            hr = _GetDevicePropertyGeneric(phwdevinst, pszPropName,
                FALSE, &dwType, (PBYTE)pblob->abData, pblob->clSize);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                if (REG_BINARY == dwType)
                {
                    DIAGNOSTIC((TEXT("[0267]Found Property: '%s'"), pszPropName));

                    *ppblob = pblob;
                    pblob = NULL;
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0268]Found Property: '%s', but NOT REG_BINARY type"), pszPropName));

                    hr = E_FAIL;
                }
            }

            if (pblob)
            {
                // It did not get assigned
                CoTaskMemFree(pblob);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT _GetDevicePropertyStringNoBuf(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, DWORD* pdwType,
    LPWSTR* ppszProp)
{
    DWORD cbSize = NULL;
    HRESULT hr = _GetDevicePropertySize(phwdevinst, pszPropName, FALSE,
        &cbSize);

    *ppszProp = NULL;

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        LPWSTR psz;

        cbSize += sizeof(WCHAR);

        psz = (LPWSTR)CoTaskMemAlloc(cbSize);

        if (psz)
        {
            hr = _GetDevicePropertyGeneric(phwdevinst, pszPropName,
                fUseMergeMultiSz, pdwType, (PBYTE)psz, cbSize);

            if (FAILED(hr) || (S_FALSE == hr))
            {
                CoTaskMemFree(psz);
            }
            else
            {
                *ppszProp = psz;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

// Return Values:
//      S_FALSE: Can't find it

HRESULT _GetDeviceHandler(CHWDeviceInst* phwdevinst, LPWSTR pszDeviceHandler,
    DWORD cchDeviceHandler)
{
    return _GetDevicePropertyAsString(phwdevinst, TEXT("DeviceHandlers"),
        pszDeviceHandler, cchDeviceHandler);
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _OpenHandlerRegKey(LPCWSTR pszHandler, HKEY* phkey)
{
    WCHAR szKey[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("Handlers\\"));
    HRESULT hr = SafeStrCatN(szKey, pszHandler, ARRAYSIZE(szKey));

    if (SUCCEEDED(hr))
    {
        hr = _RegOpenKey(HKEY_LOCAL_MACHINE, szKey, phkey);
    }

    return hr;
}

HRESULT _CloseHandlerRegKey(HKEY hkey)
{
    return _RegCloseKey(hkey);
}

HRESULT _GetHandlerCancelCLSID(LPCWSTR pszHandler, CLSID* pclsid)
{
    HKEY hkey;
    HRESULT hr = _OpenHandlerRegKey(pszHandler, &hkey);

    if (SUCCEEDED(hr))
    {
        WCHAR szProgID[MAX_PROGID];

        hr = _RegQueryString(hkey, NULL, TEXT("CLSIDForCancel"), szProgID,
            ARRAYSIZE(szProgID));

        if (SUCCEEDED(hr))
        {
            if (S_FALSE != hr)
            {
                hr = _GUIDFromString(szProgID, pclsid);

                DIAGNOSTIC((TEXT("[0162]Got Handler Cancel CLSID (from CLSIDForCancel): %s"), szProgID));
                TRACE(TF_SHHWDTCTDTCTREG, TEXT("Got Handler Cancel CLSID"));
            }
            else
            {
                hr = _GetHandlerCLSID(pszHandler, pclsid);

                if (CHWEventDetectorHelper::_fDiagnosticAppPresent)
                {
                    if (SUCCEEDED(hr))
                    {
                        if (S_FALSE != hr)
                        {
                            hr = _StringFromGUID(pclsid, szProgID, ARRAYSIZE(szProgID));

                            if (SUCCEEDED(hr))
                            {
                                DIAGNOSTIC((TEXT("[0164]Got Handler Cancel CLSID: %s"), szProgID));
                            }
                        }
                    }
                }
            }
        }

        _CloseHandlerRegKey(hkey);
    }

    return hr;
}

HRESULT _GetHandlerCLSID(LPCWSTR pszHandler, CLSID* pclsid)
{
    HKEY hkey;
    HRESULT hr = _OpenHandlerRegKey(pszHandler, &hkey);

    if (SUCCEEDED(hr))
    {
        WCHAR szProgID[MAX_PROGID];

        hr = _RegQueryString(hkey, NULL, TEXT("ProgID"), szProgID,
            ARRAYSIZE(szProgID));

        if (SUCCEEDED(hr))
        {
            if (S_FALSE != hr)
            {
                hr = CLSIDFromProgID(szProgID, pclsid);

                DIAGNOSTIC((TEXT("[0160]Got Handler ProgID: %s"), szProgID));

                TRACE(TF_SHHWDTCTDTCTREG, TEXT("Got Handler ProgID: %s"),
                    szProgID);
            }
            else
            {
                // Not there, maybe we have CLSID value?
                // Reuse szProgID
                hr = _RegQueryString(hkey, NULL, TEXT("CLSID"), szProgID,
                    ARRAYSIZE(szProgID));

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    hr = _GUIDFromString(szProgID, pclsid);

                    DIAGNOSTIC((TEXT("[0161]Got Handler CLSID: %s"), szProgID));
                    TRACE(TF_SHHWDTCTDTCTREG, TEXT("Got Handler CLSID"));
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0163]Did NOT get Handler ProgID or CLSID")));
                }
            }
        }

        _CloseHandlerRegKey(hkey);
    }

    return hr;
}

// Return values:
//      S_FALSE: Cannot find an InitCmdLine
//
HRESULT _GetInitCmdLine(LPCWSTR pszHandler, LPWSTR* ppsz)
{
    HKEY hkey;
    HRESULT hr = _OpenHandlerRegKey(pszHandler, &hkey);

    *ppsz = NULL;

    if (SUCCEEDED(hr))
    {
        DWORD cb = NULL;
        hr = _RegQueryValueSize(hkey, NULL, TEXT("InitCmdLine"), &cb);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            LPWSTR psz = (LPWSTR)LocalAlloc(LPTR, cb);

            if (psz)
            {
                hr = _RegQueryString(hkey, NULL, TEXT("InitCmdLine"), psz,
                    cb / sizeof(WCHAR));

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    DIAGNOSTIC((TEXT("[0158]Got InitCmdLine for Handler (%s): '%s'"), pszHandler, psz));

                    *ppsz = psz;
                }
                else
                {
                    LocalFree((HLOCAL)psz);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            DIAGNOSTIC((TEXT("[0159]NO InitCmdLine for Handler (%s)"), pszHandler));
        }

        _CloseHandlerRegKey(hkey);
    }

    return hr;
}

HRESULT _MakeUserDefaultValueString(LPCWSTR pszDeviceID,
    LPCWSTR pszEventHandler, LPWSTR pszUserDefault, DWORD cchUserDefault)
{
    DWORD cchLeft;
    LPWSTR pszNext;
    HRESULT hr = SafeStrCpyNEx(pszUserDefault, pszDeviceID, cchUserDefault,
        &pszNext, &cchLeft);

    if (SUCCEEDED(hr))
    {
        hr = SafeStrCpyNEx(pszNext, TEXT("+"), cchLeft, &pszNext, &cchLeft);

        if (SUCCEEDED(hr))
        {
            hr = SafeStrCpyN(pszNext, pszEventHandler, cchLeft);
        }
    }

    return hr;
}

// from setenum.cpp
HRESULT _GetKeyLastWriteTime(LPCWSTR pszHandler, FILETIME* pft);

HRESULT _HaveNewHandlersBeenInstalledSinceUserSelection(LPCWSTR pszEventHandler,
    FILETIME* pftUserSelection, BOOL* pfNewHandlersSinceUserSelection)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlers\\"));
    HRESULT hr = SafeStrCatN(szKeyName, pszEventHandler,
        ARRAYSIZE(szKeyName));

    ULARGE_INTEGER ulUserSelection;
    ulUserSelection.LowPart = pftUserSelection->dwLowDateTime;
    ulUserSelection.HighPart = pftUserSelection->dwHighDateTime;

    *pfNewHandlersSinceUserSelection = FALSE;

    if (SUCCEEDED(hr))
    {
        HKEY hkey;

        hr = _RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hkey);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            DWORD dw = 0;
            BOOL fGoOut = FALSE;

            do
            {
                WCHAR szHandler[MAX_HANDLER];
                hr = _RegEnumStringValue(hkey, dw, szHandler,
                    ARRAYSIZE(szHandler));

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    FILETIME ft;

                    hr = _GetKeyLastWriteTime(szHandler, &ft);
                    
                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                    {
                        ULARGE_INTEGER ul;
                        ul.LowPart = ft.dwLowDateTime;
                        ul.HighPart = ft.dwHighDateTime;

                        if (ul.QuadPart > ulUserSelection.QuadPart)
                        {
                            *pfNewHandlersSinceUserSelection = TRUE;
                            hr = S_OK;
                            fGoOut = TRUE;
                        }
                    }
                }
                else
                {
                    fGoOut = TRUE;
                }

                ++dw;
            }
            while (!fGoOut);

            if (S_FALSE == hr)
            {
                hr = S_OK;
            }

            _RegCloseKey(hkey);
        }
    }
   
    return hr;
}

struct _USERSELECTIONHIDDENDATA
{
    _USERSELECTIONHIDDENDATA() : dw(0) {}

    FILETIME    ft;
    // Set this to zero so that RegSetValueEx will not NULL terminate out stuff 
    DWORD       dw;
};

// See comment for _MakeFinalUserDefaultHandler
HRESULT _GetHandlerAndFILETIME(HKEY hkeyUser, LPCWSTR pszKeyName,
    LPCWSTR pszUserDefault, LPWSTR pszHandler, DWORD cchHandler, FILETIME* pft)
{
    DWORD cb;    
    HRESULT hr = _RegQueryValueSize(hkeyUser, pszKeyName, pszUserDefault, &cb);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        BYTE* pb = (BYTE*)LocalAlloc(LPTR, cb);

        if (pb)
        {
            DWORD dwType;

            hr = _RegQueryGenericWithType(hkeyUser, pszKeyName, pszUserDefault,
                &dwType, pb, cb);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                // We should have something like this:
                // MyHandler\0<_USERSELECTIONHIDDENDATA struct>
                hr = StringCchCopy(pszHandler, cchHandler, (LPWSTR)pb);

                if (SUCCEEDED(hr))
                {
                    DWORD cbString = (lstrlen(pszHandler) + 1) * sizeof(WCHAR);

                    // Make sure we're dealing with the right thing
                    if ((cb >= cbString + sizeof(_USERSELECTIONHIDDENDATA)) &&
                        (cb <= cbString + sizeof(_USERSELECTIONHIDDENDATA) + sizeof(void*)))
                    {
                        // Yep!  So _USERSELECTIONHIDDENDATA should be at the end of the blob
                        _USERSELECTIONHIDDENDATA* pushd = (_USERSELECTIONHIDDENDATA*)
                            (pb + (cb - sizeof(_USERSELECTIONHIDDENDATA)));

                        *pft = pushd->ft;
                    }
                    else
                    {
                        *pszHandler = 0;
                        hr = S_FALSE;
                    }
                }
            }

            LocalFree(pb);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT _GetEventHandlerDefault(HKEY hkeyUser, LPCWSTR pszEventHandler,
    LPWSTR pszHandler, DWORD cchHandler)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlersDefaultSelection\\"));

    return _RegQueryString(hkeyUser, szKeyName, pszEventHandler, pszHandler,
            cchHandler);
}

HRESULT _GetUserDefaultHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventHandler,
    LPWSTR pszHandler, DWORD cchHandler, BOOL fImpersonateCaller)
{
    WCHAR szUserDefault[MAX_USERDEFAULT] = TEXT("H:");
    HRESULT hr = _MakeUserDefaultValueString(pszDeviceID, pszEventHandler,
        &(szUserDefault[2]), ARRAYSIZE(szUserDefault) - 2);

    if (cchHandler)
    {
        *pszHandler = 0;
    }

    if (SUCCEEDED(hr))
    {
        WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("UserChosenExecuteHandlers\\"));
        HKEY hkeyUser;
        HANDLE hThreadToken;

        if (GUH_IMPERSONATEUSER == fImpersonateCaller)
        {
            hr = _CoGetCallingUserHKCU(&hThreadToken, &hkeyUser);
        }
        else
        {
            hr = _GetCurrentUserHKCU(&hThreadToken, &hkeyUser);
        }

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            FILETIME ft;
            DWORD dwHandlerDefaultFlag = 0;

            hr = _GetHandlerAndFILETIME(hkeyUser, szKeyName,
                szUserDefault, pszHandler, cchHandler, &ft);

            if (SUCCEEDED(hr))
            {
                if (S_FALSE == hr)
                {
                    // we do not have a UserChosenDefault
                    hr = SafeStrCpyN(pszHandler, TEXT("MSPromptEachTime"),
                        cchHandler);
                }
                else
                {
                    // we have a user chosen default
                    dwHandlerDefaultFlag |= HANDLERDEFAULT_USERCHOSENDEFAULT;
                }
            }

            if (SUCCEEDED(hr))
            {
                if (HANDLERDEFAULT_USERCHOSENDEFAULT & dwHandlerDefaultFlag)
                {
                    BOOL fNewHandlersSinceUserSelection;
                    hr = _HaveNewHandlersBeenInstalledSinceUserSelection(
                        pszEventHandler, &ft, &fNewHandlersSinceUserSelection);

                    if (SUCCEEDED(hr))
                    {
                        if (fNewHandlersSinceUserSelection)
                        {
                            dwHandlerDefaultFlag |=
                                HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED;
                        }
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                BOOL fUseEventHandlerDefault = FALSE;

                if (!(HANDLERDEFAULT_USERCHOSENDEFAULT & dwHandlerDefaultFlag))
                {
                    fUseEventHandlerDefault = TRUE;
                }
                else
                {
                    if (HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED &
                        dwHandlerDefaultFlag)
                    {
                        fUseEventHandlerDefault = TRUE;
                    }
                }

                if (fUseEventHandlerDefault)
                {
                    WCHAR szHandlerLocal[MAX_HANDLER];
                    hr = _GetEventHandlerDefault(hkeyUser, pszEventHandler,
                        szHandlerLocal, ARRAYSIZE(szHandlerLocal));

                    if (SUCCEEDED(hr))
                    {
                        if (S_FALSE != hr)
                        {
                            dwHandlerDefaultFlag |=
                                HANDLERDEFAULT_EVENTHANDLERDEFAULT;

                            if (HANDLERDEFAULT_USERCHOSENDEFAULT &
                                dwHandlerDefaultFlag)
                            {
                                if (lstrcmp(szHandlerLocal, pszHandler))
                                {
                                    dwHandlerDefaultFlag |=
                                        HANDLERDEFAULT_DEFAULTSAREDIFFERENT;
                                }
                            }
                            else
                            {
                                dwHandlerDefaultFlag |=
                                    HANDLERDEFAULT_DEFAULTSAREDIFFERENT;
                            }

                            hr = StringCchCopy(pszHandler, cchHandler,
                                szHandlerLocal);
                        }
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Let's build the return value
                hr = HANDLERDEFAULT_MAKERETURNVALUE(dwHandlerDefaultFlag);
            }

            if (GUH_IMPERSONATEUSER == fImpersonateCaller)
            {
                _CoCloseCallingUserHKCU(hThreadToken, hkeyUser);
            }
            else
            {
                _CloseCurrentUserHKCU(hThreadToken, hkeyUser);
            }
        }
    }

    return hr;
}

HRESULT _GetHandlerForNoContent(LPCWSTR pszEventHandler, LPWSTR pszHandler,
    DWORD cchHandler)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlers\\"));
    HRESULT hr = SafeStrCatN(szKeyName, pszEventHandler, ARRAYSIZE(szKeyName));

    if (SUCCEEDED(hr))
    {
        hr = _GetValueToUse(szKeyName, pszHandler, cchHandler);
    }

    return hr;
}

// We want to store the time this default is set.  We'll need it to check if
// other handlers for this event were installed after the user made a choice.
// If that's the case, we'll reprompt the user.
// *!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!
// We store the time as a FILETIME *after* the '\0' string terminator.  This is
// so it will be hidden in RegEdit.
// stephstm (2002-04-12)
// *!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!
HRESULT _MakeFinalUserDefaultHandler(LPCWSTR pszHandler, BYTE** ppb,
    DWORD* pcb)
{
    HRESULT hr;
    DWORD cch = lstrlen(pszHandler) + 1;
    
    DWORD cbOffset = cch * sizeof(WCHAR);

    // Round up to be aligned on all platforms
    cbOffset = (cbOffset + sizeof(void*)) / sizeof(void*) * sizeof(void*);

    DWORD cb = cbOffset + sizeof(_USERSELECTIONHIDDENDATA);

    BYTE* pb = (BYTE*)LocalAlloc(LPTR, cb);

    if (pb)
    {
        hr = StringCchCopy((LPWSTR)pb, cch, pszHandler);

        if (SUCCEEDED(hr))
        {
            _USERSELECTIONHIDDENDATA ushd;

            GetSystemTimeAsFileTime(&(ushd.ft));

            CopyMemory(pb + cb - sizeof(_USERSELECTIONHIDDENDATA), &ushd,
                sizeof(ushd));
        }

        if (SUCCEEDED(hr))
        {
            *ppb = pb;
            *pcb = cb;
        }
        else
        {
            LocalFree(pb);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT _DeleteUserDefaultHandler(HKEY hkeyUser, LPCWSTR pszDeviceID,
    LPCWSTR pszEventHandler)
{
    WCHAR szUserDefault[MAX_USERDEFAULT] = TEXT("H:");
    HRESULT hr = _MakeUserDefaultValueString(pszDeviceID, pszEventHandler,
        &(szUserDefault[2]), ARRAYSIZE(szUserDefault) - 2);

    if (SUCCEEDED(hr))
    {
        WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("UserChosenExecuteHandlers\\"));

        hr = _RegDeleteValue(hkeyUser, szKeyName, szUserDefault);
    }

    return hr;
}

HRESULT _SetSoftUserDefaultHandler(LPCWSTR pszDeviceID,
    LPCWSTR pszEventHandler, LPCWSTR pszHandler)
{
    HKEY hkey;
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlersDefaultSelection\\"));

    HKEY hkeyUser;
    HANDLE hThreadToken;

    HRESULT hr = _CoGetCallingUserHKCU(&hThreadToken, &hkeyUser);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        DWORD dwDisp;

        hr = _RegCreateKey(hkeyUser, szKeyName, &hkey, &dwDisp);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = _RegSetString(hkey, pszEventHandler, pszHandler);

            _DeleteUserDefaultHandler(hkeyUser, pszDeviceID, pszEventHandler);

            _RegCloseKey(hkey);
        }

        _CoCloseCallingUserHKCU(hThreadToken, hkeyUser);
    }

    return hr;
}

HRESULT _DeleteSoftUserDefaultHandler(HKEY hkeyUser, LPCWSTR pszEventHandler)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlersDefaultSelection\\"));

    return _RegDeleteValue(hkeyUser, szKeyName, pszEventHandler);
}

HRESULT _SetUserDefaultHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventHandler,
    LPCWSTR pszHandler)
{
    WCHAR szUserDefault[MAX_USERDEFAULT] = TEXT("H:");
    HRESULT hr = _MakeUserDefaultValueString(pszDeviceID, pszEventHandler,
        &(szUserDefault[2]), ARRAYSIZE(szUserDefault) - 2);

    if (SUCCEEDED(hr))
    {
        HKEY hkey;
        WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("UserChosenExecuteHandlers\\"));

        HKEY hkeyUser;
        HANDLE hThreadToken;

        hr = _CoGetCallingUserHKCU(&hThreadToken, &hkeyUser);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            if (!lstrcmp(pszHandler, TEXT("MSPromptEachTime")))
            {
                hr = _DeleteUserDefaultHandler(hkeyUser, pszDeviceID,
                    pszEventHandler);
            }
            else
            {
                DWORD dwDisp;

                hr = _RegCreateKey(hkeyUser, szKeyName, &hkey, &dwDisp);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    BYTE* pb;
                    DWORD cb;

                    hr = _MakeFinalUserDefaultHandler(pszHandler, &pb, &cb);

                    if (SUCCEEDED(hr))
                    {
                        // See comment above _MakeFinalUserDefaultHandler
                        // StephStm: 2002-04-09
                        if (ERROR_SUCCESS == RegSetValueEx(hkey, szUserDefault, 0,
                            REG_SZ, pb, cb))
                        {
                            _DeleteSoftUserDefaultHandler(hkeyUser,
                                pszEventHandler);

                            hr = S_OK;
                        }
                        else
                        {
                            hr = S_FALSE;
                        }

                        LocalFree(pb);
                    }

                    _RegCloseKey(hkey);
                }
            }

            _CoCloseCallingUserHKCU(hThreadToken, hkeyUser);
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\hnotif.h ===
#include "namellst.h"

#include "cmmn.h"

#include <dbt.h>

class CHandleNotif : public CNamedElem
{
public:
    // CNamedElem
    HRESULT Init(LPCWSTR pszElemName);

    // CHandleNotif
    HRESULT HNHandleEvent(DEV_BROADCAST_HANDLE* pdbh, DWORD dwEventType,
        BOOL* pfSurpriseRemoval);
    HRESULT InitNotif(CHandleNotifTarget* phnt);
    HDEVNOTIFY GetDeviceNotifyHandle();
    CHandleNotifTarget* GetHandleNotifTarget();

    static HRESULT HandleBroadcastHandleEvent(DEV_BROADCAST_HANDLE* pdbh,
        DWORD dwEventType);
    static HRESULT _HandleDeviceArrivalRemoval(DEV_BROADCAST_HANDLE* pdbh,
        DWORD dwEventType, CNamedElem* pelem);
    static HRESULT _HandleDeviceLockUnlock(DEV_BROADCAST_HANDLE* pdbh,
        DWORD dwEventType, CNamedElem* pelem);

public:
    static HRESULT Create(CNamedElem** ppelem);

public:
    CHandleNotif();
    ~CHandleNotif();

private:
    HRESULT _Register();
    HRESULT _Unregister();
    HRESULT _CloseDevice();

private:
    BOOL                                _fSurpriseRemoval;
    CHandleNotifTarget*                 _phnt;
    HDEVNOTIFY                          _hdevnotify;

    DWORD                               _cLockAttempts;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\hnotif.cpp ===
#include "hnotif.h"
#include "hwdev.h"

#include "misc.h"
#include "mischlpr.h"
#include "dbg.h"
#include "tfids.h"

#include <ioevent.h>
#include <dbt.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT CHandleNotif::Init(LPCWSTR pszElemName)
{
    return _SetName(pszElemName);
}

HRESULT CHandleNotif::InitNotif(CHandleNotifTarget* phnt)
{
    ASSERT(!_phnt);

    _phnt = phnt;

    return _Register();
}

HDEVNOTIFY CHandleNotif::GetDeviceNotifyHandle()
{
    return _hdevnotify;
}

CHandleNotifTarget* CHandleNotif::GetHandleNotifTarget()
{
    return _phnt;
}

//
// Application gets DBT_DEVICEQUERYREMOVE message with the handle of the device
// that's being removed. It should just close the handle to the device.
//
// If everything goes OK it gets DBT_DEVICEREMOVEPENDING to notify that remove
// is complete. Here it unregisters the notification that it did on the handle.
//
// If query-remove fails because somebody else in the system vetoed it, it gets
// DBT_QUERYREMOVEFAILED. Here it should first unregister the notification and
// reopen the device (if it's still interested) and register again for device
// change notification (DBT_DEVTYP_HANDLE) on the new handle.
//
HRESULT CHandleNotif::HNHandleEvent(DEV_BROADCAST_HANDLE* UNREF_PARAM(pdbh),
    DWORD dwEventType, BOOL* pfSurpriseRemoval)
{
    HRESULT hres;

    *pfSurpriseRemoval = FALSE;

    switch (dwEventType)
    {
        case DBT_DEVICEQUERYREMOVE:
            TRACE(TF_SHHWDTCTDTCT, TEXT("DBT_DEVICEQUERYREMOVE for '%s'"), _pszElemName);
            hres = S_OK;
            break;

        case DBT_DEVICEREMOVEPENDING:
            TRACE(TF_SHHWDTCTDTCT, TEXT("DBT_DEVICEREMOVEPENDING for '%s'"), _pszElemName);
            _fSurpriseRemoval = FALSE;
            hres = _Unregister();
            break;

        case DBT_DEVICEQUERYREMOVEFAILED:
            TRACE(TF_SHHWDTCTDTCT, TEXT("DBT_DEVICEQUERYREMOVEFAILED for '%s'"), _pszElemName);
            _fSurpriseRemoval = TRUE;
            hres = _Unregister();

            if (SUCCEEDED(hres))
            {
                hres = _Register();
            }
            break;

        case DBT_DEVICEREMOVECOMPLETE:
            TRACE(TF_SHHWDTCTDTCT, TEXT("DBT_DEVICEREMOVECOMPLETE for '%s'"), _pszElemName);
            if (_fSurpriseRemoval)
            {
                *pfSurpriseRemoval = TRUE;
                hres = _Unregister();
            }

            hres = S_FALSE;

            break;

        default:
            hres = S_FALSE;
            break;
    }

    return hres;
}

//static
HRESULT CHandleNotif::_HandleDeviceArrivalRemoval(
    DEV_BROADCAST_HANDLE* UNREF_PARAM(pdbh), DWORD UNREF_PARAM(dwEventType),
    CNamedElem* UNREF_PARAM(pelem))
{
#ifdef ENABLE_SURPRISEREMOVAL
    HRESULT hres = S_OK;

    BOOL fSurpriseRemoval = FALSE;
    CHandleNotif* phn = (CHandleNotif*)pelem;
    CHandleNotifTarget* phnt = phn->GetHandleNotifTarget();

    if (phnt)
    {
        if (fSurpriseRemoval && phnt->HNTIsSurpriseRemovalAware())
        {
            // Use me!
            DWORD cchReq;
            WCHAR szDeviceIntfID[MAX_DEVICEID];
            WCHAR szFriendlyName[30];

            hres = pelem->GetName(szDeviceIntfID,
                ARRAYSIZE(szDeviceIntfID), &cchReq);

            if (SUCCEEDED(hres))
            {
                CHWDeviceInst* phwdevinst;
                CNamedElem* pelemToRelease;
                hres = _GetHWDeviceInstFromDeviceOrVolumeIntfID(
                    szDeviceIntfID, &phwdevinst, &pelemToRelease);

                if (SUCCEEDED(hres) && (S_FALSE != hres))
                {
                    hres = phwdevinst->GetFriendlyName(szFriendlyName,
                        ARRAYSIZE(szFriendlyName));

                    if (SUCCEEDED(hres) && (S_FALSE != hres))
                    {
                        TRACE(TF_SHHWDTCTDTCT, TEXT("! ! ! Surprise removal for: '%s' ! ! !"),
                            szFriendlyName);
                    }
                    else
                    {
                        TRACE(TF_SHHWDTCTDTCT, TEXT("! ! ! Surprise removal for (no FriendlyName): '%s' ! ! !"),
                            szDeviceIntfID);
                    }

                    pelemToRelease->RCRelease();
                }
            }
        }
    }
#endif

    return S_OK;
}

//static
HRESULT CHandleNotif::_HandleDeviceLockUnlock(DEV_BROADCAST_HANDLE* pdbh,
    DWORD, CNamedElem* pelem)
{
    HRESULT hres = S_OK;
    CHandleNotif* phn = (CHandleNotif*)pelem;

    if (GUID_IO_VOLUME_LOCK == pdbh->dbch_eventguid)
    {
#ifdef DEBUG
        TRACE(TF_SHHWDTCTDTCT,
            TEXT("DBT_CUSTOMEVENT + GUID_IO_VOLUME_LOCK for '%s'"),
            pelem->DbgGetName());
#endif

        // nothing to do
        ++(phn->_cLockAttempts);
    }
    else
    {
        if (GUID_IO_VOLUME_LOCK_FAILED == pdbh->dbch_eventguid)
        {
#ifdef DEBUG
            TRACE(TF_SHHWDTCTDTCT,
                TEXT("DBT_CUSTOMEVENT + GUID_IO_VOLUME_LOCK_FAILED for '%s'"),
                pelem->DbgGetName());
#endif

            --(phn->_cLockAttempts);

            if (0 == (phn->_cLockAttempts))
            {
                hres = phn->_Unregister();

                if (SUCCEEDED(hres))
                {
                    hres = phn->_Register();
                }
            }
        }
        else
        {
            if (GUID_IO_VOLUME_UNLOCK == pdbh->dbch_eventguid)
            {
#ifdef DEBUG
                TRACE(TF_SHHWDTCTDTCT,
                    TEXT("DBT_CUSTOMEVENT + GUID_IO_VOLUME_UNLOCK for '%s'"),
                    pelem->DbgGetName());
#endif

                // Play it safe...
                (phn->_cLockAttempts) = 0;

                hres = phn->_Unregister();

                if (SUCCEEDED(hres))
                {
                    hres = phn->_Register();
                }
            }
        }
    }

    return hres;
}

//static
HRESULT CHandleNotif::HandleBroadcastHandleEvent(DEV_BROADCAST_HANDLE* pdbh,
    DWORD dwEventType)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_HANDLENOTIF,
        &pnel);

    if (S_OK == hres)
    {
        // Find the elem in the list
        CNamedElemEnum* penum;

        hres = pnel->GetEnum(&penum);

        if (SUCCEEDED(hres))
        {
            CNamedElem* pelem;
            BOOL fFoundIt = FALSE;

            while (!fFoundIt && SUCCEEDED(hres = penum->Next(&pelem)) &&
                (S_FALSE != hres))
            {
                CHandleNotif* phn = (CHandleNotif*)pelem;

                if (phn->GetDeviceNotifyHandle() == pdbh->dbch_hdevnotify)
                {
                    // Found it!
                    BOOL fSurpriseRemoval;
                    CHandleNotifTarget* phnt = phn->GetHandleNotifTarget();

                    hres = phn->HNHandleEvent(pdbh, dwEventType, &fSurpriseRemoval);

                    if (SUCCEEDED(hres))
                    {
                        if ((GUID_IO_MEDIA_ARRIVAL == pdbh->dbch_eventguid) ||
                            (GUID_IO_MEDIA_REMOVAL == pdbh->dbch_eventguid))
                        {
                            hres = _HandleDeviceArrivalRemoval(pdbh, dwEventType,
                                pelem);
                        }
                        else
                        {
                            if ((GUID_IO_VOLUME_LOCK == pdbh->dbch_eventguid) ||
                                (GUID_IO_VOLUME_LOCK_FAILED == pdbh->dbch_eventguid) ||
                                (GUID_IO_VOLUME_UNLOCK == pdbh->dbch_eventguid))
                            {
                                hres = _HandleDeviceLockUnlock(pdbh, dwEventType,
                                    pelem);
                            }
                        }

                        if (SUCCEEDED(hres))
                        {
                            hres = phnt->HNTHandleEvent(pdbh, dwEventType);

                            // phnt has the same life span as pelem, no need to
                            // RCAddRef/RCRelease
                        }
                    }

                    fFoundIt = TRUE;
                }

                pelem->RCRelease();
            }

            penum->RCRelease();
        }

        pnel->RCRelease();
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
//static
HRESULT CHandleNotif::Create(CNamedElem** ppelem)
{
    HRESULT hres = S_OK;

    *ppelem = new CHandleNotif();

    if (!(*ppelem))
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHandleNotif::_Register()
{
    HRESULT hres = S_FALSE;
    DEV_BROADCAST_HANDLE dbhNotifFilter = {0};

    dbhNotifFilter.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
    dbhNotifFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;

    dbhNotifFilter.dbch_handle = _GetDeviceHandle(_pszElemName,
        FILE_READ_ATTRIBUTES);

    if (INVALID_HANDLE_VALUE != dbhNotifFilter.dbch_handle)
    {
        hres = CHWEventDetectorHelper::RegisterDeviceNotification(
            &dbhNotifFilter, &_hdevnotify, FALSE);

        _CloseDeviceHandle(dbhNotifFilter.dbch_handle);
    }

    TRACE(TF_SHHWDTCTDTCT, TEXT("--- Registered for '%s'"), _pszElemName);

    return hres;
}

HRESULT CHandleNotif::_Unregister()
{
    if (_hdevnotify)
    {
        UnregisterDeviceNotification(_hdevnotify);
        _hdevnotify = NULL;

        TRACE(TF_SHHWDTCTDTCT, TEXT("--- UNRegistered for '%s'"), _pszElemName);
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
CHandleNotif::CHandleNotif() : _hdevnotify(NULL), _phnt(NULL), 
    _fSurpriseRemoval(TRUE), _cLockAttempts(0)
{}

CHandleNotif::~CHandleNotif()
{
    _Unregister();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\logging.cpp ===
/*****************************************************************************\
    FILE: logging.cpp

    DESCRIPTION:
        Logging helper functions

    BryanSt 4/23/2001 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2001-2001. All rights reserved.
\*****************************************************************************/

#include <shlwapi.h> // SHGetValue, wnsprintf, SHFormatDateTime

#include <strsafe.h>

#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))
#endif // ARRAYSIZE


HANDLE g_hLogFile = INVALID_HANDLE_VALUE;
void WriteToLogFileA(LPCSTR pszMessage, ...)
{
    va_list vaParamList;
    va_start(vaParamList, pszMessage);

    if (INVALID_HANDLE_VALUE == g_hLogFile)
    {
        TCHAR szPath[MAX_PATH];

        if (GetWindowsDirectory(szPath, ARRAYSIZE(szPath)))
        {
            PathAppend(szPath, TEXT("AutoPlay.log"));
            g_hLogFile = CreateFile(szPath, (GENERIC_READ | GENERIC_WRITE), FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if (INVALID_HANDLE_VALUE != g_hLogFile)
            {
                CHAR szTimeDate[MAX_PATH];
                CHAR szHeader[MAX_PATH];
                FILETIME ftCurrentUTC;
                FILETIME ftCurrent;
                SYSTEMTIME stCurrent;
                DWORD cbWritten;

                SetFilePointer(g_hLogFile, 0, NULL, FILE_END);
                
                GetLocalTime(&stCurrent);
                SystemTimeToFileTime(&stCurrent, &ftCurrent);
                LocalFileTimeToFileTime(&ftCurrent, &ftCurrentUTC);
                SHFormatDateTimeA(&ftCurrentUTC, NULL, szTimeDate, ARRAYSIZE(szTimeDate));

                TCHAR szProcess[MAX_PATH];
                if (!GetModuleFileName(NULL, szProcess, ARRAYSIZE(szProcess)))
                {
                    szProcess[0] = 0;
                }

                StringCchPrintfA(szHeader, ARRAYSIZE(szHeader), "\r\n\r\n%hs - (%ls)\r\n", szTimeDate, /*szUserName,*/ szProcess);
                WriteFile(g_hLogFile, szHeader, lstrlenA(szHeader), &cbWritten, NULL);
            }

        }
    }

    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        CHAR szMessage[4000];
        DWORD cbWritten;
        StringCchVPrintfA(szMessage, ARRAYSIZE(szMessage), pszMessage, vaParamList);
        WriteFile(g_hLogFile, szMessage, lstrlenA(szMessage), &cbWritten, NULL);
        FlushFileBuffers(g_hLogFile);
    }

    va_end(vaParamList);
}


void WriteToLogFileW(LPCWSTR pszMessage)
{
    DWORD cchSize = (lstrlen(pszMessage) + 1);
    LPSTR pszMessageAnsi = (LPSTR) LocalAlloc(LPTR, cchSize);

    if (pszMessageAnsi)
    {
        SHUnicodeToAnsi(pszMessage, pszMessageAnsi, cchSize);
        WriteToLogFileA(pszMessageAnsi);
    }
}


void CloseLogFile(void)
{
    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        HANDLE hLogFile = g_hLogFile;
        g_hLogFile = INVALID_HANDLE_VALUE;
        CloseHandle(hLogFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\miscdev.cpp ===
#include "miscdev.h"

HRESULT CMiscDeviceInterface::Init(LPCWSTR pszElemName)
{
    HRESULT hr = _SetName(pszElemName);

    if (SUCCEEDED(hr))
    {
        DEVINST devinst;
        GUID guidDummy;

        hr = _GetDeviceInstance(pszElemName, &devinst, &guidDummy);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = _hwdevinst.Init(devinst);
        }
    }

    return hr;
}

HRESULT CMiscDeviceInterface::InitInterfaceGUID(const GUID* pguidInterface)
{
    return _hwdevinst.InitInterfaceGUID(pguidInterface);
}

HRESULT CMiscDeviceInterface::GetHWDeviceInst(CHWDeviceInst** pphwdevinst)
{
    *pphwdevinst = &_hwdevinst;

    return S_OK;
}

//static
HRESULT CMiscDeviceInterface::Create(CNamedElem** ppelem)
{
    HRESULT hres = S_OK;

    *ppelem = new CMiscDeviceInterface();

    if (!(*ppelem))
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
CMiscDeviceInterface::CMiscDeviceInterface()
{}

CMiscDeviceInterface::~CMiscDeviceInterface()
{}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
HRESULT CMiscDeviceNode::Init(LPCWSTR pszElemName)
{
    HRESULT hr = _SetName(pszElemName);

    if (SUCCEEDED(hr))
    {
        DEVINST devinst;

        hr = _GetDeviceInstanceFromDevNode(pszElemName, &devinst);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = _hwdevinst.Init(devinst);
        }
    }

    return hr;
}

HRESULT CMiscDeviceNode::GetHWDeviceInst(CHWDeviceInst** pphwdevinst)
{
    *pphwdevinst = &_hwdevinst;

    return S_OK;
}

//static
HRESULT CMiscDeviceNode::Create(CNamedElem** ppelem)
{
    HRESULT hres = S_OK;

    *ppelem = new CMiscDeviceNode();

    if (!(*ppelem))
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
CMiscDeviceNode::CMiscDeviceNode()
{}

CMiscDeviceNode::~CMiscDeviceNode()
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\hwdev.h ===
#ifndef _HWDEV_H
#define _HWDEV_H

#include "namellst.h"

#include "cmmn.h"
#include "misc.h"

///////////////////////////////////////////////////////////////////////////////
//
// This will enumerate all the Device that we're interested in and create
// additionnal objects to do specialized work
//
///////////////////////////////////////////////////////////////////////////////

class CHWDeviceInst //: public CDeviceElem
{
public:
    // CHWDeviceInst
    HRESULT Init(DEVINST devinst);
    HRESULT InitInterfaceGUID(const GUID* pguidInterface);

    HRESULT GetPnpID(LPWSTR pszPnpID, DWORD cchPnpID);
    HRESULT GetDeviceInstance(DEVINST* pdevinst);
    HRESULT GetInterfaceGUID(GUID* pguidInterface);

    HRESULT IsRemovableDevice(BOOL* pfRemovable);
    HRESULT ShouldAutoplayOnSpecialInterface(const GUID* pguidInterface,
        BOOL* pfShouldAutoplay);

public:
    CHWDeviceInst();
    ~CHWDeviceInst();

private:
    HRESULT _GetPnpIDRecurs(DEVINST devinst, LPWSTR pszPnpID,
                                   DWORD cchPnpID);
    HRESULT _InitPnpInfo();
    HRESULT _InitPnpID();

private:
    DEVINST                             _devinst;
    WCHAR                               _szPnpID[MAX_PNPID];
    GUID                                _guidInterface;
};

#endif //_HWDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\mtpts.cpp ===
#include "mtpts.h"

#include "vol.h"

#include "sfstr.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT CMtPt::Init(LPCWSTR pszElemName)
{
    return _SetName(pszElemName);
}

HRESULT CMtPt::InitVolume(LPCWSTR pszDeviceIDVolume)
{
    return SafeStrCpyN(_szDeviceIDVolume, pszDeviceIDVolume,
        ARRAYSIZE(_szDeviceIDVolume));
}

HRESULT CMtPt::GetVolumeName(LPWSTR pszDeviceIDVolume, DWORD cchDeviceIDVolume)
{
    return SafeStrCpyN(pszDeviceIDVolume, _szDeviceIDVolume,
        cchDeviceIDVolume);
}

//static
HRESULT CMtPt::Create(CNamedElem** ppelem)
{
    HRESULT hres = S_OK;

    *ppelem = new CMtPt();

    if (!(*ppelem))
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

CMtPt::CMtPt()
{
    _szDeviceIDVolume[0] = 0;
}

CMtPt::~CMtPt()
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\hwdev.cpp ===
#include "hwdev.h"

#include "setupapi.h"

#include "dtctreg.h"
#include "reg.h"

#include "namellst.h"
#include "sfstr.h"
#include "str.h"
#include "cmmn.h"
#include "misc.h"

#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHWDeviceInst::Init(DEVINST devinst)
{
    _devinst = devinst;

    return S_OK;
}

HRESULT CHWDeviceInst::InitInterfaceGUID(const GUID* pguidInterface)
{
    _guidInterface = *pguidInterface;
    
    return S_OK;
}

HRESULT CHWDeviceInst::GetDeviceInstance(DEVINST* pdevinst)
{
    HRESULT hr;

    if (_devinst)
    {
        *pdevinst = _devinst;
        hr = S_OK;
    }
    else
    {
        *pdevinst = 0;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CHWDeviceInst::GetPnpID(LPWSTR pszPnpID, DWORD cchPnpID)
{
    HRESULT hr = _InitPnpInfo();

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        hr = SafeStrCpyN(pszPnpID, _szPnpID, cchPnpID);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CHWDeviceInst::GetInterfaceGUID(GUID* pguidInterface)
{
    ASSERT(guidInvalid != _guidInterface);

    *pguidInterface = _guidInterface;

    return S_OK;
}

HRESULT CHWDeviceInst::IsRemovableDevice(BOOL* pfRemovable)
{
    return _DeviceInstIsRemovable(_devinst, pfRemovable);    
}

HRESULT CHWDeviceInst::ShouldAutoplayOnSpecialInterface(
    const GUID* pguidInterface, BOOL* pfShouldAutoplay)
{
    WCHAR szGUID[MAX_GUIDSTRING];
    HRESULT hr = _StringFromGUID(pguidInterface, szGUID,
        ARRAYSIZE(szGUID));

    *pfShouldAutoplay = FALSE;

    if (SUCCEEDED(hr))
    {
        WCHAR szGUIDFromReg[MAX_GUIDSTRING];
        DWORD dwType;
    
        hr = _GetDevicePropertyGeneric(this,
            TEXT("AutoplayOnSpecialInterface"), FALSE, &dwType, (PBYTE)szGUIDFromReg,
            sizeof(szGUIDFromReg));

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            if (REG_SZ == dwType)
            {
                if (!lstrcmpi(szGUIDFromReg, szGUID))
                {
                    *pfShouldAutoplay = TRUE;
                }
            }
        }

        if (*pfShouldAutoplay)
        {
            DIAGNOSTIC((TEXT("[0314]Autoplay on Special Interface %s -> Autoplay!"), szGUID));
        }
        else
        {
            DIAGNOSTIC((TEXT("[0315]*NO* Autoplay on Special Interface %s -> No Autoplay!"), szGUID));
        }
    }

    return hr;
}
///////////////////////////////////////////////////////////////////////////////
//
CHWDeviceInst::CHWDeviceInst() : _devinst(0), _guidInterface(guidInvalid)
{}

CHWDeviceInst::~CHWDeviceInst()
{}
///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHWDeviceInst::_InitPnpInfo()
{
    HRESULT hres;

    // This require the _devinst to be set
    if (0 != _devinst)
    {
        hres = _InitPnpID();

        if (FAILED(hres))
        {
            // Probably not a removable device
            hres = S_FALSE;
        }
    }
    else
    {
        hres = S_FALSE;
    }

    return hres;
}

HRESULT _FindInstID(LPWSTR pszPnpID, DWORD* pcch)
{
    DWORD cToFind = 2;
    LPWSTR psz = pszPnpID;

    *pcch = 0;

    while (*psz && cToFind)
    {
        if ((TEXT('\\') == *psz))
        {
            --cToFind;
        }

        if (cToFind)
        {
            ++psz;
        }
    }

    if (*psz)
    {
        *pcch = (DWORD)(psz - pszPnpID);
    }

    return S_OK;
}

HRESULT _GetPnpIDHelper(DEVINST devinst, LPWSTR pszPnpID, DWORD cchPnpID)
{
    HRESULT hres = S_FALSE;
    HMACHINE hMachine = NULL;

    CONFIGRET cr = CM_Get_Device_ID_Ex(devinst, pszPnpID,
        cchPnpID, 0, hMachine);

    if (CR_SUCCESS == cr)
    {
        hres = S_OK;
    }

    return hres;
}

HRESULT CHWDeviceInst::_InitPnpID()
{
    HRESULT hres = _GetPnpIDHelper(_devinst, _szPnpID, ARRAYSIZE(_szPnpID));

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        DWORD cchInstIDOffset;
        hres = _FindInstID(_szPnpID, &cchInstIDOffset);

        if (SUCCEEDED(hres))
        {
            *(_szPnpID + cchInstIDOffset) = 0;
        }
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\logging.h ===
/*****************************************************************************\
    FILE: logging.h

    DESCRIPTION:
        Logging helper functions

    BryanSt 4/23/2001 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2001-2001. All rights reserved.
\*****************************************************************************/

#ifndef _LOGGING_H
#define _LOGGING_H

void WriteToLogFileA(LPCSTR pszMessage, ...);
void WriteToLogFileW(LPCWSTR pszMessage);
void CloseLogFile(void);


#endif // _LOGGING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\miscdev.h ===
#include "namellst.h"

#include "hwdev.h"

#include "cmmn.h"
#include "misc.h"

class CMiscDeviceInterface : public CNamedElem
{
public:
    // CNamedElem
    HRESULT Init(LPCWSTR pszElemName);

    // CMiscDeviceInterface
    HRESULT InitInterfaceGUID(const GUID* pguidInterface);
    HRESULT GetHWDeviceInst(CHWDeviceInst** pphwdevinst);

public:
    static HRESULT Create(CNamedElem** ppelem);

public:
    CMiscDeviceInterface();
    ~CMiscDeviceInterface();

private:
    CHWDeviceInst                       _hwdevinst;
};

class CMiscDeviceNode : public CNamedElem
{
public:
    // CNamedElem
    HRESULT Init(LPCWSTR pszElemName);

    // CMiscDeviceNode
    HRESULT GetHWDeviceInst(CHWDeviceInst** pphwdevinst);

public:
    static HRESULT Create(CNamedElem** ppelem);

public:
    CMiscDeviceNode();
    ~CMiscDeviceNode();

private:
    CHWDeviceInst                       _hwdevinst;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\misc.h ===
#ifndef _MISC_H
#define _MISC_H

// From MAX_DEVICE_ID_LEN = 200 in cfgmgr32.h
#define MAX_DEVICEID            200

#define MAX_PNPID               MAX_PATH
#define MAX_PNPINSTID           MAX_PATH

// According to documentation
#define MAX_PROGID              39

#define MAX_GUIDSTRING          39

#define MAX_AUTOPLAYGENERIC     64

#define MAX_EVENTHANDLER        MAX_AUTOPLAYGENERIC
#define MAX_DEVICEHANDLER       MAX_AUTOPLAYGENERIC
#define MAX_DEVICEGROUP         MAX_AUTOPLAYGENERIC
#define MAX_EVENTTYPE           MAX_AUTOPLAYGENERIC
#define MAX_EVENTFRIENDLYNAME   MAX_AUTOPLAYGENERIC
#define MAX_HANDLER             MAX_AUTOPLAYGENERIC
#define MAX_ACTION              MAX_AUTOPLAYGENERIC
#define MAX_PROVIDER            MAX_AUTOPLAYGENERIC

#define MAX_INVOKEPROGID        260
#define MAX_INVOKEVERB          MAX_AUTOPLAYGENERIC

#define MAX_USERDEFAULT         MAX_DEVICEID + MAX_AUTOPLAYGENERIC + 10

#define MAX_FRIENDLYNAME        MAX_AUTOPLAYGENERIC

#define MAX_VOLUMENAME          50

#define HINT_NONE               0
#define HINT_NEW                1

#define SHDEVICEEVENTROOT(a) TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoplayHandlers\\") ##a

#endif //_MISC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\mtpts.h ===
#include "namellst.h"
#include "cmmn.h"

#include "misc.h"

#include <objbase.h>

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

class CMtPt : public CNamedElem
{
public:
    // CNamedElem
    HRESULT Init(LPCWSTR pszElemName);

    // CMtPt
    HRESULT InitVolume(LPCWSTR pszDeviceIDVolume);
    HRESULT GetVolumeName(LPWSTR pszDeviceIDVolume, DWORD cchDeviceIDVolume);

public:
    static HRESULT Create(CNamedElem** ppelem);

public:
    CMtPt();
    ~CMtPt();

private:
    // Drive that host this volume (might be null, in this case no autoplay)
    WCHAR                   _szDeviceIDVolume[MAX_DEVICEID];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\pnp.h ===
#ifndef _PNP_H
#define _PNP_H

#include <objbase.h>

HRESULT _GetPropertyHelper(LPCWSTR pszKey, LPCWSTR pszPropName, DWORD* pdwType,
    PBYTE pbData, DWORD cbData);

HRESULT _GetPropertySizeHelper(LPCWSTR pszKey, LPCWSTR pszPropName,
    DWORD* pcbSize);

#endif //_PNP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\pnp.cpp ===
#include "pnp.h"

#include "reg.h"
#include "sfstr.h"

#include "misc.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

// Temporary fct to use while PnP team writes the real one
//
// First we look under the DeviceNode for the value and if not there
// we go to the "database".
//
//
HRESULT _GetPropertyHelper(LPCWSTR pszKey, LPCWSTR pszPropName, DWORD* pdwType,
    PBYTE pbData, DWORD cbData)
{
    HKEY hkey;
    HRESULT hr = _RegOpenKey(HKEY_LOCAL_MACHINE, pszKey, &hkey);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        hr = _RegQueryGenericWithType(hkey, NULL, pszPropName, pdwType,
            pbData, cbData);

        _RegCloseKey(hkey);
    }

    return hr;
}

HRESULT _GetPropertySizeHelper(LPCWSTR pszKey, LPCWSTR pszPropName,
    DWORD* pcbSize)
{
    HKEY hkey;
    HRESULT hr = _RegOpenKey(HKEY_LOCAL_MACHINE, pszKey, &hkey);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        hr = _RegQueryValueSize(hkey, NULL, pszPropName, pcbSize);

        _RegCloseKey(hkey);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\regnotif.cpp ===
#include "regnotif.h"

#include "svcsync.h"
#include "mtpts.h"
#include "vol.h"

#include "namellst.h"

#include "users.h"
#include "sfstr.h"
#include "tfids.h"
#include "dbg.h"

#include <shpriv.h>
#include <strsafe.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

#define MAGICTOKENOFFSET ((DWORD)0x57EF57EF)

LONG  CHardwareDevicesImpl::_lAdviseToken = MAGICTOKENOFFSET;
DWORD CHardwareDevicesImpl::_chwdevcb = 0;

#define MAX_ADVISETOKEN      11

STDMETHODIMP CHardwareDevicesImpl::EnumVolumes(
    DWORD dwFlags, IHardwareDevicesVolumesEnum** ppenum)
{
    HRESULT hr;

    *ppenum = NULL;

    if ((HWDEV_GETCUSTOMPROPERTIES == dwFlags) || (0 == dwFlags))
    {
        CHardwareDevicesVolumesEnum* phwdve = new CHardwareDevicesVolumesEnum(NULL);

        if (phwdve)
        {
            hr = phwdve->_Init(dwFlags);

            if (SUCCEEDED(hr))
            {
                *ppenum = phwdve;
            }
            else
            {
                phwdve->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    ASSERT((*ppenum && SUCCEEDED(hr)) || (!*ppenum && FAILED(hr)));
    return hr;
}

STDMETHODIMP CHardwareDevicesImpl::EnumMountPoints(
    IHardwareDevicesMountPointsEnum** ppenum)
{
    HRESULT hr;
    CHardwareDevicesMountPointsEnum* phwdmtpte = new CHardwareDevicesMountPointsEnum(NULL);

    *ppenum = NULL;

    if (phwdmtpte)
    {
        hr = phwdmtpte->_Init();

        if (SUCCEEDED(hr))
        {
            *ppenum = phwdmtpte;
        }
        else
        {
            phwdmtpte->Release();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    ASSERT((*ppenum && SUCCEEDED(hr)) || (!*ppenum && FAILED(hr)));
    return hr;
}

STDMETHODIMP CHardwareDevicesImpl::EnumDevices(IHardwareDevicesEnum** /*ppenum*/)
{
    return E_NOTIMPL;
}

HRESULT _GetStringAdviseToken(LONG lAdviseToken, LPWSTR szAdviseToken, DWORD cchAdviseToken)
{
    HRESULT hr;

    if (cchAdviseToken >= MAX_ADVISETOKEN)
    {
        // 0x12345678
        hr = StringCchPrintf(szAdviseToken, cchAdviseToken, TEXT("0x%08X"),
            lAdviseToken);
            
        ASSERT(SUCCEEDED(hr));
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CHardwareDevicesImpl::Advise(DWORD dwProcessID,
    ULONG_PTR hThread, ULONG_PTR pfctCallback, DWORD* pdwToken)
{
    HRESULT hr;

    TRACE(TF_ADVISE, TEXT(">>>Called ") TEXT(__FUNCTION__) TEXT(", 0x%08X, 0x%08X, 0x%08X"),
        dwProcessID, hThread, pfctCallback);
    
    if (dwProcessID && hThread && pfctCallback && pdwToken)
    {
        LONG lAdviseToken = InterlockedIncrement(&_lAdviseToken);
        WCHAR szAdviseToken[MAX_ADVISETOKEN];

        hr = _GetStringAdviseToken(lAdviseToken, szAdviseToken,
            ARRAYSIZE(szAdviseToken));
    
        if (SUCCEEDED(hr))
        {
            CNamedElemList* pnel;
            hr = CHWEventDetectorHelper::GetList(HWEDLIST_ADVISECLIENT, &pnel);

            if (S_OK == hr)
            {
                CNamedElem* pelem;

                hr = pnel->GetOrAdd(szAdviseToken, &pelem);

                if (SUCCEEDED(hr))
                {
                    CAdviseClient* pac = (CAdviseClient*)pelem;

                    hr = pac->_Init(dwProcessID,
                        hThread, pfctCallback);

                    if (SUCCEEDED(hr))
                    {
                        *pdwToken = lAdviseToken;
                    }
                    else
                    {
                        pnel->Remove(szAdviseToken);
                    }

                    pelem->RCRelease();
                }

                pnel->RCRelease();
            }
        }

        if (SUCCEEDED(hr))
        {
            TRACE(TF_ADVISE, TEXT(">>>Advise SUCCEEDED, token = 0x%08X"), lAdviseToken);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (FAILED(hr))
    {
        TRACE(TF_ADVISE, TEXT(">>>Advise FAILED"));
    }

    return hr;
}

STDMETHODIMP CHardwareDevicesImpl::Unadvise(DWORD dwToken)
{
    HRESULT hr;

    if (dwToken >= (MAGICTOKENOFFSET))
    {
        WCHAR szAdviseToken[MAX_ADVISETOKEN];

        hr = _GetStringAdviseToken(dwToken, szAdviseToken,
            ARRAYSIZE(szAdviseToken));

        if (SUCCEEDED(hr))
        {
            CNamedElemList* pnel;
            hr = CHWEventDetectorHelper::GetList(HWEDLIST_ADVISECLIENT, &pnel);

            if (S_OK == hr)
            {
                pnel->Remove(szAdviseToken);

                pnel->RCRelease();
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        TRACE(TF_ADVISE, TEXT(">>>UNAdvise SUCCEEDED, token = 0x%08X"),
            dwToken);
    }
    else
    {
        TRACE(TF_ADVISE, TEXT(">>>UNAdvise FAILED, token = 0x%08X"),
            dwToken);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
class CThreadTaskBroadcastEvent : public CThreadTask
{
public:
    CThreadTaskBroadcastEvent() : _pshhe(NULL)
    {}

    virtual ~CThreadTaskBroadcastEvent()
    {
        if (_pshhe)
        {
            _FreeMemoryChunk<SHHARDWAREEVENT*>(_pshhe);
        }
    }

protected:
    HRESULT _Broadcast()
    {
        CNamedElemList* pnel;
        HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_ADVISECLIENT, &pnel);

        if (S_OK == hr)
        {
            CNamedElemEnum* penum;

            hr = pnel->GetEnum(&penum);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                CNamedElem* pelem;

                while (SUCCEEDED(hr) && SUCCEEDED(hr = penum->Next(&pelem)) &&
                    (S_FALSE != hr))
                {
                    CAdviseClient* pac = (CAdviseClient*)pelem;
                    void* pv;

                    HRESULT hrTmp = pac->WriteMemoryChunkInOtherProcess(_pshhe,
                        _pshhe->cbSize, &pv);

                    if (SUCCEEDED(hrTmp))
                    {
                        hrTmp = pac->QueueUserAPC(pv);
                    }

                    if (FAILED(hrTmp))
                    {
                        WCHAR szAdviseToken[MAX_ADVISETOKEN];
                        DWORD cchReq;

                        TRACE(TF_ADVISE,
                            TEXT(__FUNCTION__) TEXT(": Trying to removed token because failed CB, hr = 0x%08X"),
                            hrTmp);

                        if (SUCCEEDED(pelem->GetName(szAdviseToken, ARRAYSIZE(szAdviseToken),
                            &cchReq)))
                        {
                            TRACE(TF_ADVISE, TEXT("    ") TEXT(__FUNCTION__) TEXT(": Token = %s"),
                                szAdviseToken);

                            pnel->Remove(szAdviseToken);
                        }
                    }

                    pelem->RCRelease();
                }

                penum->RCRelease();
            }

            pnel->RCRelease();
        }

        return hr;
    }

protected:
    SHHARDWAREEVENT*    _pshhe;
};

class CThreadTaskMountPointEvent : public CThreadTaskBroadcastEvent
{
public:
    HRESULT InitAdded(LPCWSTR pszMtPt, LPCWSTR pszDeviceIDVolume)
    {
        ASSERT(!_pshhe);
        DWORD cbSize = sizeof(SHHARDWAREEVENT) + sizeof(MTPTADDED);
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            MTPTADDED* pmtptadded = (MTPTADDED*)_pshhe->rgbPayLoad;

            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = SHHARDWAREEVENT_MOUNTPOINTARRIVED;

            hr = SafeStrCpyN(pmtptadded->szMountPoint, pszMtPt,
                ARRAYSIZE(pmtptadded->szMountPoint));

            if (SUCCEEDED(hr))
            {
                hr = SafeStrCpyN(pmtptadded->szDeviceIDVolume, pszDeviceIDVolume,
                    ARRAYSIZE(pmtptadded->szDeviceIDVolume));

                if (SUCCEEDED(hr))
                {
                    // We give the Shell AllowSetForegroundWindow privilege
                    _GiveAllowForegroundToConsoleShell();
                }
            }
        }

        return hr;
    }

    HRESULT InitRemoved(LPCWSTR pszMtPt)
    {
        ASSERT(!_pshhe);
        DWORD cbSize = sizeof(SHHARDWAREEVENT) + MAX_PATH * sizeof(WCHAR);
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = SHHARDWAREEVENT_MOUNTPOINTREMOVED;

            hr = SafeStrCpyN((LPWSTR)_pshhe->rgbPayLoad, pszMtPt,
                MAX_PATH);
        }

        return hr;
    }

    HRESULT _DoStuff()
    {
        return _Broadcast();
    }
};

class CThreadTaskCheckClients : public CThreadTask
{
public:
    HRESULT _DoStuff()
    {
        CNamedElemList* pnel;

        //
        //  Get the list of notify clients.
        //

        HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_ADVISECLIENT, &pnel);
        if (S_OK == hres)
        {
            CNamedElemEnum* penum;

            hres = pnel->GetEnum(&penum);
            if (SUCCEEDED(hres))
            {
                CNamedElem* pelem;

                //
                //  Enumerate the advised clients.
                //

                while (SUCCEEDED(hres = penum->Next(&pelem)) && (S_FALSE != hres))
                {
                    CAdviseClient* pac = (CAdviseClient*)pelem;

                    //
                    //  Is the process still alive?
                    //

                    HRESULT hrTmp = pac->IsProcessStillAlive( );
                    if (S_OK != hrTmp)
                    {
                        WCHAR szAdviseToken[MAX_ADVISETOKEN];
                        DWORD cchReq;

                        //
                        //  Nope (or there is some problem with it)... so remove it from the list.
                        //

                        TRACE(TF_ADVISE, TEXT(__FUNCTION__) TEXT(": Trying to removed token because process died, pac = %p"), pac);

                        hrTmp = pelem->GetName(szAdviseToken, ARRAYSIZE(szAdviseToken), &cchReq);
                        if (SUCCEEDED(hrTmp))
                        {
                            TRACE(TF_ADVISE, TEXT("    ") TEXT(__FUNCTION__) TEXT(": Token = %s"), szAdviseToken);

                            pnel->Remove(szAdviseToken);
                        }
                    }

                    pelem->RCRelease();
                }

                //
                //  Reset the HRESULT if it is the expected exit condition.
                //

                if ( S_FALSE == hres )
                {
                    hres = S_OK;
                }

                penum->RCRelease();
            }

            pnel->RCRelease();
        }

        return hres;
    }
};

class CThreadTaskVolumeEvent : public CThreadTaskBroadcastEvent
{
public:
    HRESULT InitAdded(VOLUMEINFO2* pvolinfo2, LPCWSTR pszMtPts, DWORD cchMtPts)
    {
        ASSERT(!_pshhe);
        DWORD cbSize = sizeof(SHHARDWAREEVENT) + pvolinfo2->cbSize;
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = SHHARDWAREEVENT_VOLUMEARRIVED;

            CopyMemory(_pshhe->rgbPayLoad, pvolinfo2, pvolinfo2->cbSize);

            _pszDeviceIDVolume = ((VOLUMEINFO2*)_pshhe->rgbPayLoad)->szDeviceIDVolume;

            if (SUCCEEDED(hr) && pszMtPts)
            {
                hr = _DupMemoryChunk<LPCWSTR>(pszMtPts, cchMtPts * sizeof(WCHAR),
                    &_pszMtPts);
            }
        }

        return hr;
    }

    HRESULT InitUpdated(VOLUMEINFO2* pvolinfo2)
    {
        ASSERT(!_pshhe);
        DWORD cbSize = sizeof(SHHARDWAREEVENT) + pvolinfo2->cbSize;
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = SHHARDWAREEVENT_VOLUMEUPDATED;

            CopyMemory(_pshhe->rgbPayLoad, pvolinfo2, pvolinfo2->cbSize);

            _pszDeviceIDVolume = ((VOLUMEINFO2*)_pshhe->rgbPayLoad)->szDeviceIDVolume;

            // We give the Shell AllowSetForegroundWindow privilege
            _GiveAllowForegroundToConsoleShell();
        }

        return hr;
    }

    HRESULT InitRemoved(LPCWSTR pszDeviceIDVolume, LPCWSTR pszMtPts, DWORD cchMtPts)
    {
        ASSERT(!_pshhe);
        DWORD cbSize = sizeof(SHHARDWAREEVENT) + MAX_DEVICEID * sizeof(WCHAR);
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = SHHARDWAREEVENT_VOLUMEREMOVED;
            _pszDeviceIDVolume = ((VOLUMEINFO2*)_pshhe->rgbPayLoad)->szDeviceIDVolume;

            hr = SafeStrCpyN((LPWSTR)_pshhe->rgbPayLoad, pszDeviceIDVolume,
                MAX_DEVICEID);

            if (SUCCEEDED(hr) && pszMtPts)
            {
                hr = _DupMemoryChunk<LPCWSTR>(pszMtPts, cchMtPts * sizeof(WCHAR),
                    &_pszMtPts);
            }
        }

        return hr;
    }

    HRESULT _DoStuff()
    {
        HRESULT hr;

        switch (_pshhe->dwEvent)
        {
            case SHHARDWAREEVENT_VOLUMEARRIVED:
            case SHHARDWAREEVENT_VOLUMEUPDATED:
            {
                hr = _SendVolumeInfo();

                if (SUCCEEDED(hr) && (SHHARDWAREEVENT_VOLUMEARRIVED == _pshhe->dwEvent))
                {
                    // We need to enum the mountpoints too.  We were not
                    // registered to get the notif since this volume was not there
                    hr = _SendMtPtsInfo();
                }
                
                break;
            }
            case SHHARDWAREEVENT_VOLUMEREMOVED:
            {
                hr = _SendMtPtsInfo();

                if (SUCCEEDED(hr))
                {
                    hr = _SendVolumeInfo();
                }

                break;
            }
            default:
            {
                TRACE(TF_ADVISE, TEXT("DoStuff with unknown SHHARDWAREEVENT_* value"));
                hr = E_FAIL;
                break;
            }
        }

        return hr;
    }

private:
    HRESULT _SendMtPtsInfo()
    {
        if (_pszMtPts)
        {
            for (LPCWSTR psz = _pszMtPts; *psz; psz += (lstrlen(psz) + 1))
            {
                CThreadTaskMountPointEvent task;
                HRESULT hr;

                if (SHHARDWAREEVENT_VOLUMEREMOVED == _pshhe->dwEvent)
                {
                    hr = task.InitRemoved(psz);
                }
                else
                {
                    hr = task.InitAdded(psz, _pszDeviceIDVolume);
                }

                if (SUCCEEDED(hr))
                {
                    task.RunSynchronously();
                }
            }
        }

        return S_OK;
    }

    HRESULT _SendVolumeInfo()
    {
        return _Broadcast();
    }

public:
    CThreadTaskVolumeEvent() : _pszMtPts(NULL)
    {}

    ~CThreadTaskVolumeEvent()
    {
        if (_pszMtPts)
        {
            _FreeMemoryChunk<LPCWSTR>(_pszMtPts);
        }
    }

private:
    LPCWSTR             _pszMtPts;
    LPCWSTR             _pszDeviceIDVolume;
};

class CThreadTaskGenericEvent : public CThreadTaskBroadcastEvent
{
public:
    HRESULT Init(LPCWSTR pszPayload, DWORD dwEvent)
    {
        ASSERT(!_pshhe);
        //  maybe use lstrlen()?
        DWORD cbSize = (DWORD)(sizeof(SHHARDWAREEVENT) + (pszPayload ?  MAX_DEVICEID * sizeof(WCHAR) : 0));
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            LPWSTR pszPayloadLocal = (LPWSTR)_pshhe->rgbPayLoad;

            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = dwEvent;

            if (pszPayload)
            {
                hr = SafeStrCpyN(pszPayloadLocal, pszPayload, MAX_DEVICEID);
            }
        }

        return hr;
    }

    HRESULT _DoStuff()
    {
        return _Broadcast();
    }
};

class CThreadTaskDeviceEvent : public CThreadTaskBroadcastEvent
{
public:
    HRESULT Init(LPCWSTR pszDeviceIntfID, GUID* pguidInterface,
        DWORD dwDeviceFlags, DWORD dwEvent)
    {
        ASSERT(!_pshhe);

        DWORD cbSize = (DWORD)(sizeof(SHHARDWAREEVENT) + (sizeof(HWDEVICEINFO)));
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            HWDEVICEINFO* phwdevinfo = (HWDEVICEINFO*)_pshhe->rgbPayLoad;

            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = dwEvent;

            hr = SafeStrCpyN(phwdevinfo->szDeviceIntfID, pszDeviceIntfID,
                ARRAYSIZE(phwdevinfo->szDeviceIntfID));

            if (SUCCEEDED(hr))
            {
                phwdevinfo->cbSize = sizeof(*phwdevinfo);
                phwdevinfo->guidInterface = *pguidInterface;
                phwdevinfo->dwDeviceFlags = dwDeviceFlags;
            }
        }

        return hr;
    }

    HRESULT _DoStuff()
    {
        return _Broadcast();
    }
};

HRESULT CHardwareDevicesImpl::_AdviseDeviceArrivedOrRemoved(
    LPCWSTR pszDeviceIntfID, GUID* pguidInterface, DWORD dwDeviceFlags,
    LPCWSTR pszEventType)
{
    HRESULT hr;
    CThreadTaskDeviceEvent* pTask = new CThreadTaskDeviceEvent();

    if (pTask)
    {
        DWORD dwEvent;

        if (!lstrcmpi(pszEventType, TEXT("DeviceArrival")))
        {
            dwEvent =  SHHARDWAREEVENT_DEVICEARRIVED;
        }
        else
        {
            dwEvent =  SHHARDWAREEVENT_DEVICEREMOVED;
        }
            
        hr = pTask->Init(pszDeviceIntfID, pguidInterface, dwDeviceFlags, dwEvent);
        if (SUCCEEDED(hr))
        {
            hr = pTask->Run();
        }
        
        if (FAILED(hr))
        {
            delete pTask;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//static
HRESULT CHardwareDevicesImpl::_AdviseVolumeArrivedOrUpdated(
    VOLUMEINFO2* pvolinfo2, LPCWSTR pszMtPts, DWORD cchMtPts, BOOL fAdded)
{
    HRESULT hr;
    TRACE(TF_ADVISE, TEXT(">>>_AdviseVolumeArrivedOrUpdated: fAdded = %d"), fAdded);

    CThreadTaskVolumeEvent* pTask = new CThreadTaskVolumeEvent();

    if (pTask)
    {
        if (fAdded)
        {
            hr = pTask->InitAdded(pvolinfo2, pszMtPts, cchMtPts);
        }
        else
        {
            hr = pTask->InitUpdated(pvolinfo2);
        }

        if (SUCCEEDED(hr))
        {
            hr = pTask->Run();
        }
        
        if (FAILED(hr))
        {
            delete pTask;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// static
HRESULT CHardwareDevicesImpl::_AdviseVolumeRemoved(LPCWSTR pszDeviceIDVolume,
    LPCWSTR pszMtPts, DWORD cchMtPts)
{
    HRESULT hr;
    TRACE(TF_ADVISE, TEXT(">>>_AdviseVolumeRemoved"));

    CThreadTaskVolumeEvent* pTask = new CThreadTaskVolumeEvent();

    if (pTask)
    {
        hr = pTask->InitRemoved(pszDeviceIDVolume, pszMtPts, cchMtPts);
        if (SUCCEEDED(hr))
        {
            hr = pTask->Run();
        }
        
        if (FAILED(hr))
        {
            delete pTask;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;    
}

//static
HRESULT CHardwareDevicesImpl::_AdviseVolumeMountingEvent(
    LPCWSTR pszDeviceIDVolume, DWORD dwEvent)
{
    TRACE(TF_ADVISE, TEXT(">>>_AdviseVolumeMountingEvent: %s, dwEvent = 0x%08X"),
        pszDeviceIDVolume, dwEvent);

    HRESULT hr;
    CThreadTaskGenericEvent* pTask = new CThreadTaskGenericEvent();

    if (pTask)
    {
        hr = pTask->Init(pszDeviceIDVolume, dwEvent);
        if (SUCCEEDED(hr))
        {
            hr = pTask->Run();
        }
        
        if (FAILED(hr))
        {
            delete pTask;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//static
HRESULT CHardwareDevicesImpl::_AdviseMountPointHelper(LPCWSTR pszMtPt,
    LPCWSTR pszDeviceIDVolume, BOOL fAdded)
{
    TRACE(TF_ADVISE, TEXT(">>>_AdviseMountPointHelper: %s, fAdded = %d"),
        pszMtPt, fAdded);

    HRESULT hr;
    CThreadTaskMountPointEvent* pTask = new CThreadTaskMountPointEvent();

    if (pTask)
    {
        if (fAdded)
        {
            hr = pTask->InitAdded(pszMtPt, pszDeviceIDVolume);
        }
        else
        {
            hr = pTask->InitRemoved(pszMtPt);            
        }

        if (SUCCEEDED(hr))
        {
            hr = pTask->Run();
        }
        
        if (FAILED(hr))
        {
            delete pTask;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;    
}
//static
HRESULT CHardwareDevicesImpl::_AdviseCheckClients(void)
{
    HRESULT hr;

    CThreadTaskCheckClients* pTask = new CThreadTaskCheckClients();
    if (pTask)
    {
        hr = pTask->Run();
        if (FAILED(hr))
        {
            delete pTask;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Impl
CHardwareDevicesImpl::CHardwareDevicesImpl()
{
    _CompleteShellHWDetectionInitialization();
}

CHardwareDevicesImpl::~CHardwareDevicesImpl()
{}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP CHardwareDevicesEnumImpl::Next(
    LPWSTR* /*ppszDeviceID*/,
    GUID* /*pguidDeviceID*/)
{
    return E_NOTIMPL;
}

CHardwareDevicesEnumImpl::CHardwareDevicesEnumImpl()
{}

CHardwareDevicesEnumImpl::~CHardwareDevicesEnumImpl()
{}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHardwareDevicesVolumesEnumImpl::_Init(DWORD dwFlags)
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_VOLUME, &pnel);

    _dwFlags = dwFlags;

    if (S_OK == hr)
    {
        hr = pnel->GetEnum(&_penum);

        pnel->RCRelease();
    }

    return hr;
}

STDMETHODIMP CHardwareDevicesVolumesEnumImpl::Next(VOLUMEINFO* pvolinfo)
{
    HRESULT hr;
    
    if (pvolinfo)
    {
        if (_penum)
        {
            CNamedElem* pelem;

            hr = _penum->Next(&pelem);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                // Const Info
                WCHAR szVolName[MAX_DEVICEID];
                WCHAR szVolGUID[50];
                WCHAR szLabel[MAX_LABEL];
                WCHAR szFileSystem[MAX_FILESYSNAME];
                WCHAR szAutorunIconLocation[MAX_ICONLOCATION];
                WCHAR szAutorunLabel[MAX_LABEL];
                WCHAR szIconLocationFromService[MAX_ICONLOCATION];
                WCHAR szNoMediaIconLocationFromService[MAX_ICONLOCATION];
                // We can now have a @%SystemRoot%\system32\shell32.dll,-1785 for MUI stuff
                WCHAR szLabelFromService[MAX_ICONLOCATION];
                CVolume* pvol = (CVolume*)pelem;

                // Misc
                DWORD cchReq;

                ZeroMemory(pvolinfo, sizeof(VOLUMEINFO));

                hr = pvol->GetName(szVolName, ARRAYSIZE(szVolName), &cchReq);

                if (SUCCEEDED(hr))
                {
                    hr = pvol->GetVolumeConstInfo(szVolGUID,
                        ARRAYSIZE(szVolGUID), &(pvolinfo->dwVolumeFlags),
                        &(pvolinfo->dwDriveType),
                        &(pvolinfo->dwDriveCapability));
                }

                if (SUCCEEDED(hr))
                {
                    hr = pvol->GetVolumeMediaInfo(szLabel, ARRAYSIZE(szLabel), 
                        szFileSystem, ARRAYSIZE(szFileSystem),
                        &(pvolinfo->dwFileSystemFlags),
                        &(pvolinfo->dwMaxFileNameLen),
                        &(pvolinfo->dwRootAttributes),
                        &(pvolinfo->dwSerialNumber), &(pvolinfo->dwDriveState),
                        &(pvolinfo->dwMediaState), &(pvolinfo->dwMediaCap));
                }

                if (SUCCEEDED(hr))
                {
                    if (HWDEV_GETCUSTOMPROPERTIES & _dwFlags)
                    {
                        szAutorunIconLocation[0] = 0;
                        szAutorunLabel[0] = 0;
                        szIconLocationFromService[0] = 0;
                        szNoMediaIconLocationFromService[0] = 0;
                        szLabelFromService[0] = 0;

                        hr = pvol->GetIconAndLabelInfo(szAutorunIconLocation,
                            ARRAYSIZE(szAutorunIconLocation), szAutorunLabel,
                            ARRAYSIZE(szAutorunLabel),
                            szIconLocationFromService,
                            ARRAYSIZE(szIconLocationFromService),
                            szNoMediaIconLocationFromService,
                            ARRAYSIZE(szNoMediaIconLocationFromService),
                            szLabelFromService,
                            ARRAYSIZE(szLabelFromService));

                        if (SUCCEEDED(hr))
                        {
                            if (*szAutorunIconLocation)
                            {
                                hr = _CoTaskMemCopy(szAutorunIconLocation,
                                    &(pvolinfo->pszAutorunIconLocation));
                            }
                            if (SUCCEEDED(hr) && *szAutorunLabel)
                            {
                                hr = _CoTaskMemCopy(szAutorunLabel,
                                    &(pvolinfo->pszAutorunLabel));
                            }
                            if (SUCCEEDED(hr) && *szIconLocationFromService)
                            {
                                hr = _CoTaskMemCopy(szIconLocationFromService,
                                    &(pvolinfo->pszIconLocationFromService));
                            }
                            if (SUCCEEDED(hr) && *szNoMediaIconLocationFromService)
                            {
                                hr = _CoTaskMemCopy(szNoMediaIconLocationFromService,
                                    &(pvolinfo->pszNoMediaIconLocationFromService));
                            }
                            if (SUCCEEDED(hr) && *szLabelFromService)
                            {
                                hr = _CoTaskMemCopy(szLabelFromService,
                                    &(pvolinfo->pszLabelFromService));
                            }
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    hr = _CoTaskMemCopy(szVolName, &(pvolinfo->pszDeviceIDVolume));

                    if (SUCCEEDED(hr))
                    {
                        hr = _CoTaskMemCopy(szVolGUID, &(pvolinfo->pszVolumeGUID));
                    }
                    if (SUCCEEDED(hr))
                    {
                        hr = _CoTaskMemCopy(szLabel, &(pvolinfo->pszLabel));
                    }
                    if (SUCCEEDED(hr))
                    {
                        hr = _CoTaskMemCopy(szFileSystem, &(pvolinfo->pszFileSystem));
                    }
                }

                if (FAILED(hr))
                {
                    _CoTaskMemFree(pvolinfo->pszDeviceIDVolume);
                    _CoTaskMemFree(pvolinfo->pszVolumeGUID);
                    _CoTaskMemFree(pvolinfo->pszLabel);
                    _CoTaskMemFree(pvolinfo->pszFileSystem);

                    _CoTaskMemFree(pvolinfo->pszAutorunIconLocation);
                    _CoTaskMemFree(pvolinfo->pszAutorunLabel);
                    _CoTaskMemFree(pvolinfo->pszIconLocationFromService);
                    _CoTaskMemFree(pvolinfo->pszNoMediaIconLocationFromService);
                    _CoTaskMemFree(pvolinfo->pszLabelFromService);

                    ZeroMemory(pvolinfo, sizeof(VOLUMEINFO));
                }
            
                pelem->RCRelease();
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

CHardwareDevicesVolumesEnumImpl::CHardwareDevicesVolumesEnumImpl() :
    _penum(NULL)
{}

CHardwareDevicesVolumesEnumImpl::~CHardwareDevicesVolumesEnumImpl()
{
    if (_penum)
    {
        _penum->RCRelease();
    }
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHardwareDevicesMountPointsEnumImpl::_Init()
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_MTPT, &pnel);

    if (S_OK == hr)
    {
        hr = pnel->GetEnum(&_penum);

        pnel->RCRelease();
    }

    return hr;
}

STDMETHODIMP CHardwareDevicesMountPointsEnumImpl::Next(
    LPWSTR* ppszMountPoint,     // "c:\", or "d:\MountFolder\"
    LPWSTR* ppszDeviceIDVolume) // \\?\STORAGE#Volume#...{...GUID...}
{
    HRESULT hr;
    
    *ppszMountPoint = NULL;
    *ppszDeviceIDVolume = NULL;

    if (_penum)
    {
        CNamedElem* pelem;

        hr = _penum->Next(&pelem);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            // Const Info
            WCHAR szMtPtName[MAX_PATH];
            WCHAR szVolName[MAX_DEVICEID];
            CMtPt* pmtpt = (CMtPt*)pelem;

            // Misc
            DWORD cchReq;

            hr = pmtpt->GetName(szMtPtName, ARRAYSIZE(szMtPtName), &cchReq);

            if (SUCCEEDED(hr))
            {
                hr = pmtpt->GetVolumeName(szVolName, ARRAYSIZE(szVolName));
            }

            if (SUCCEEDED(hr))
            {
                hr = _CoTaskMemCopy(szMtPtName, ppszMountPoint);

                if (SUCCEEDED(hr))
                {
                    hr = _CoTaskMemCopy(szVolName, ppszDeviceIDVolume);
                }
                else
                {
                    CoTaskMemFree(*ppszMountPoint);
                    *ppszMountPoint = NULL;
                }
            }

            pelem->RCRelease();
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

CHardwareDevicesMountPointsEnumImpl::CHardwareDevicesMountPointsEnumImpl() :
    _penum(NULL)
{}

CHardwareDevicesMountPointsEnumImpl::~CHardwareDevicesMountPointsEnumImpl()
{
    if (_penum)
    {
        _penum->RCRelease();
    }
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
HRESULT CAdviseClient::Init(LPCWSTR pszElemName)
{
    ASSERT(pszElemName);

    return _SetName(pszElemName);
}

HRESULT CAdviseClient::_Cleanup()
{
    if (_hProcess)
    {
        CloseHandle(_hProcess);
        _hProcess = NULL;
    }

    if (_hThread)
    {
        CloseHandle(_hThread);
        _hThread = NULL;
    }

    return S_OK;
}

HRESULT CAdviseClient::_Init(DWORD dwProcessID, ULONG_PTR hThread,
    ULONG_PTR pfctCallback)
{
    HRESULT hr = E_FAIL;

    _Cleanup();

    _pfct = (PAPCFUNC)pfctCallback;

    // rename hProcess!
    _hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE | SYNCHRONIZE |
        PROCESS_DUP_HANDLE, FALSE, dwProcessID);

    if (_hProcess)
    {
        if (DuplicateHandle(_hProcess, (HANDLE)hThread,
            GetCurrentProcess(), &_hThread, THREAD_ALL_ACCESS, FALSE, 0))
        {
            hr = S_OK;
        }
    }

    return hr;        
}

HRESULT CAdviseClient::WriteMemoryChunkInOtherProcess(SHHARDWAREEVENT* pshhe,
    DWORD cbSize, void** ppv)
{
    HRESULT hr = E_FAIL;

	void* pv = VirtualAllocEx(_hProcess, NULL, cbSize,
		MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,
		PAGE_READWRITE);

	*ppv = NULL;

	if (pv)
	{
		SIZE_T cbWritten;

		if (WriteProcessMemory(_hProcess, pv, pshhe, cbSize, &cbWritten)
			&& (cbWritten == cbSize))
		{
			*ppv = pv;
			hr = S_OK;
		}
		else
		{
			VirtualFreeEx(_hProcess, pv, 0, MEM_RELEASE);
		}
	}
	else
	{
		// Out of mem, but in the other process...
		hr = E_OUTOFMEMORY;
	}

    return hr;
}

HRESULT CAdviseClient::QueueUserAPC(void* pv)
{
    HRESULT hr;

    if (::QueueUserAPC(_pfct, _hThread, (ULONG_PTR)pv))
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CAdviseClient::IsProcessStillAlive(void)
{
    HRESULT hr;

    DWORD dwResult = WaitForSingleObject( _hProcess, 0 );
    switch (dwResult) 
    {
    case WAIT_OBJECT_0:
        hr = S_FALSE;   // process has died.
        break;

    case WAIT_TIMEOUT:
        hr = S_OK;      // process is still alive
        break;

    default:
        {
            //  problem with handle
            DWORD dwErr = GetLastError( );
            hr = HRESULT_FROM_WIN32( dwErr );
        }
        break;
    }

    return hr;
}

CAdviseClient::CAdviseClient() : _hProcess(NULL), _hThread(NULL), _pfct(NULL)
{}

CAdviseClient::~CAdviseClient()
{
    _Cleanup();
}
// static
HRESULT CAdviseClient::Create(CNamedElem** ppelem)
{
    HRESULT hr = S_OK;
    *ppelem = new CAdviseClient();

    if (!(*ppelem))
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\setenum.cpp ===
#include "setenum.h"

#include "dtctreg.h"
#include "cmmn.h"

#include "misc.h"
#include "reg.h"
#include "sfstr.h"

#include "tfids.h"
#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

STDMETHODIMP CEnumAutoplayHandlerImpl::Next(LPWSTR* ppszHandler,
    LPWSTR* ppszAction, LPWSTR* ppszProvider, LPWSTR* ppszIconLocation)
{
    HRESULT hr;

    if (ppszHandler && ppszAction && ppszProvider && ppszIconLocation)
    {
        *ppszHandler = NULL;
        *ppszAction = NULL;
        *ppszProvider = NULL;
        *ppszIconLocation = NULL;

        if (!_fTakeNoActionDone)
        {
            LPCWSTR pszHandler = TEXT("MSTakeNoAction");
            WCHAR szAction[MAX_ACTION];
            WCHAR szProvider[MAX_PROVIDER];
            WCHAR szIconLocation[MAX_ICONLOCATION];

            if (_rghkiHandlers)
            {
                if (_dwIndex < _cHandlers)
                {
                    pszHandler = _rghkiHandlers[_dwIndex].szHandler;
                }
                else
                {
                    _fTakeNoActionDone = TRUE;
                }
            }
            else
            {
                _fTakeNoActionDone = TRUE;
            }

            hr = _GetActionFromHandler(pszHandler, szAction, ARRAYSIZE(szAction));

            if (SUCCEEDED(hr))
            {
                hr = _GetIconLocationFromHandler(pszHandler, szIconLocation,
                    ARRAYSIZE(szIconLocation));

                if (SUCCEEDED(hr))
                {
                    hr = _GetProviderFromHandler(pszHandler, szProvider,
                        ARRAYSIZE(szProvider));

                    if (SUCCEEDED(hr))
                    {
                        hr = _CoTaskMemCopy(pszHandler, ppszHandler);

                        if (SUCCEEDED(hr))
                        {
                            hr = _CoTaskMemCopy(szAction,
                                ppszAction);

                            if (SUCCEEDED(hr))
                            {
                                hr = _CoTaskMemCopy(szIconLocation,
                                    ppszIconLocation);

                                if (SUCCEEDED(hr))
                                {
                                    hr = _CoTaskMemCopy(szProvider,
                                        ppszProvider);
                                }
                            }
                        }
                    }
                }
            }

            if (FAILED(hr))
            {
                if (*ppszHandler)
                {
                    CoTaskMemFree((PVOID)*ppszHandler);
                    *ppszHandler = NULL;
                }
                if (*ppszAction)
                {
                    CoTaskMemFree((PVOID)*ppszAction);
                    *ppszAction = NULL;
                }
                if (*ppszProvider)
                {
                    CoTaskMemFree((PVOID)*ppszProvider);
                    *ppszProvider = NULL;
                }
                if (*ppszIconLocation)
                {
                    CoTaskMemFree((PVOID)*ppszIconLocation);
                    *ppszIconLocation = NULL;
                }
            }
        }
        else
        {
            hr = S_FALSE;
        }

        ++_dwIndex;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT _GetKeyLastWriteTime(LPCWSTR pszHandler, FILETIME* pft)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("Handlers\\"));

    HRESULT hr = SafeStrCatN(szKeyName, pszHandler, ARRAYSIZE(szKeyName));

    if (SUCCEEDED(hr))
    {
        HKEY hkey;

        hr = _RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hkey);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            if (ERROR_SUCCESS != RegQueryInfoKey(hkey,
                NULL,           // class buffer
                0,              // size of class buffer
                NULL,           // reserved
                NULL,           // number of subkeys
                NULL,           // longest subkey name
                NULL,           // longest class string
                NULL,           // number of value entries
                NULL,           // longest value name
                NULL,           // longest value data
                NULL,           // descriptor length
                pft             // last write time
                ))
            {
                // Bad.  Set it to right now
                GetSystemTimeAsFileTime(pft);
            }

            hr = S_OK;

            _RegCloseKey(hkey);
        }
    }
    
    return hr;
}

HRESULT CEnumAutoplayHandlerImpl::_Init(LPWSTR pszEventHandler)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlers\\"));
    HRESULT hr = SafeStrCatN(szKeyName, pszEventHandler,
        ARRAYSIZE(szKeyName));

    if (SUCCEEDED(hr))
    {
        HKEY hkey;

        hr = _RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hkey);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            if (ERROR_SUCCESS == RegQueryInfoKey(hkey,
                NULL,           // class buffer
                0,              // size of class buffer
                NULL,           // reserved
                NULL,           // number of subkeys
                NULL,           // longest subkey name
                NULL,           // longest class string
                &_cHandlers,    // number of value entries
                NULL,           // longest value name
                NULL,           // longest value data
                NULL,           // descriptor length
                NULL            // last write time
                ))
            {
                hr = _AllocMemoryChunk<_HANDLERKEYINFO*>(_cHandlers *
                    sizeof(_HANDLERKEYINFO), &_rghkiHandlers);

                if (SUCCEEDED(hr))
                {
                    for (DWORD dw = 0; SUCCEEDED(hr) && (dw < _cHandlers); ++dw)
                    {
                        hr = _RegEnumStringValue(hkey, dw, _rghkiHandlers[dw].szHandler,
                            ARRAYSIZE(_rghkiHandlers[dw].szHandler));

                        if (SUCCEEDED(hr))
                        {
                            if (S_FALSE != hr)
                            {
                                hr = _GetKeyLastWriteTime(
                                    _rghkiHandlers[dw].szHandler,
                                    &(_rghkiHandlers[dw].ftLastWriteTime));
                            }
                            else
                            {
                                // There's less then there was when we queried for it...
                                _cHandlers = dw;

                                break;
                            }
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        // We don't care if this fails
                        _SortHandlers();
                    }
                    else
                    {
                        _FreeMemoryChunk<_HANDLERKEYINFO*>(_rghkiHandlers);
                        _rghkiHandlers = NULL;
                        _cHandlers = 0;
                    }
                }
                else
                {
                    _cHandlers = 0;
                }
            }
            else
            {
                hr = S_FALSE;
            }

            _RegCloseKey(hkey);
        }
    }
   
    return hr;
}

HRESULT CEnumAutoplayHandlerImpl::_SwapHandlerKeyInfo(DWORD dwLeft,
    DWORD dwRight)
{
    _HANDLERKEYINFO hkiTmp = _rghkiHandlers[dwLeft];

    _rghkiHandlers[dwLeft] = _rghkiHandlers[dwRight];
    _rghkiHandlers[dwRight] = hkiTmp;

    return S_OK;
}

HRESULT CEnumAutoplayHandlerImpl::_SortHandlers()
{
    HRESULT hr;

    if (_rghkiHandlers)
    {
        hr = S_OK;

        for (DWORD dwOuter = 0; dwOuter < _cHandlers; ++dwOuter)
        {
            _HANDLERKEYINFO* phkiOuter = &(_rghkiHandlers[dwOuter]);
            ULARGE_INTEGER ulOuter;
            ulOuter.LowPart = phkiOuter->ftLastWriteTime.dwLowDateTime;
            ulOuter.HighPart = phkiOuter->ftLastWriteTime.dwHighDateTime;

            for (DWORD dwInner = dwOuter + 1; dwInner < _cHandlers; ++dwInner)
            {
                _HANDLERKEYINFO* phkiInner = &(_rghkiHandlers[dwInner]);

                ULARGE_INTEGER ulInner;
                ulInner.LowPart = phkiInner->ftLastWriteTime.dwLowDateTime;
                ulInner.HighPart = phkiInner->ftLastWriteTime.dwHighDateTime;
            
                if (ulOuter.QuadPart > ulInner.QuadPart)
                {
                    hr = _SwapHandlerKeyInfo(dwOuter, dwInner);
                }
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

CEnumAutoplayHandlerImpl::CEnumAutoplayHandlerImpl() : _dwIndex(0), _rghkiHandlers(NULL),
    _cHandlers(0), _fTakeNoActionDone(FALSE)
{}

CEnumAutoplayHandlerImpl::~CEnumAutoplayHandlerImpl()
{
    if (_rghkiHandlers)
    {
        _FreeMemoryChunk<_HANDLERKEYINFO*>(_rghkiHandlers);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\setenum.h ===
///////////////////////////////////////////////////////////////////////////////
// HW Event Handler Enum
///////////////////////////////////////////////////////////////////////////////
#ifndef _SETENUM_H
#define _SETENUM_H

#include "unk.h"
#include "misc.h"

#include <shpriv.h>

class CEnumAutoplayHandlerImpl : public CCOMBase, public IEnumAutoplayHandler
{
public:
    // Interface IEnumAutoplayHandler
	STDMETHODIMP Next(LPWSTR* ppszHandler, LPWSTR* ppszAction,
        LPWSTR* ppszProvider, LPWSTR* ppszIconLocation);

public:
    HRESULT _Init(LPWSTR pszEventHandler);
    CEnumAutoplayHandlerImpl();
    ~CEnumAutoplayHandlerImpl();

private:
    HRESULT _SwapHandlerKeyInfo(DWORD dwLeft, DWORD dwRight);
    HRESULT _SortHandlers();

private:
    struct _HANDLERKEYINFO
    {
        WCHAR           szHandler[MAX_HANDLER];
        FILETIME        ftLastWriteTime;
    };

    DWORD               _dwIndex;
    DWORD               _cHandlers;
    _HANDLERKEYINFO*    _rghkiHandlers;
    BOOL                _fTakeNoActionDone;
};

typedef CUnkTmpl<CEnumAutoplayHandlerImpl> CEnumAutoplayHandler;

#endif // _SETENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\regnotif.h ===
///////////////////////////////////////////////////////////////////////////////
// HardwareDevices Registration
///////////////////////////////////////////////////////////////////////////////
#ifndef _REGNOTIF_H
#define _REGNOTIF_H

#include "unk.h"
#include "namellst.h"

#include <shpriv.h>

extern const CLSID CLSID_HardwareDevices;

class CHardwareDevicesImpl : public CCOMBase, public IHardwareDevices
{
public:
    // Interface IHardwareDevices
    STDMETHODIMP EnumVolumes(DWORD dwFlags, IHardwareDevicesVolumesEnum** ppenum);
    STDMETHODIMP EnumMountPoints(IHardwareDevicesMountPointsEnum** ppenum);
    STDMETHODIMP EnumDevices(IHardwareDevicesEnum** ppenum);
 
    STDMETHODIMP Advise(DWORD dwProcessID, ULONG_PTR hThread,
        ULONG_PTR pfctCallback, DWORD* pdwToken);
    STDMETHODIMP Unadvise(DWORD dwToken);

public:
    static HRESULT _AdviseVolumeArrivedOrUpdated(
        VOLUMEINFO2* pvolinfo2, LPCWSTR pszMtPts, DWORD cchMtPts, BOOL fAdded);
    static HRESULT _AdviseVolumeRemoved(LPCWSTR pszDeviceIDVolume,
        LPCWSTR pszMtPts, DWORD cchMtPts);
    static HRESULT _AdviseMountPointHelper(LPCWSTR pszMtPt,
        LPCWSTR pszDeviceIDVolume, BOOL fAdded);
    static HRESULT _AdviseVolumeMountingEvent(LPCWSTR pszDeviceIDVolume,
        DWORD dwEvent);
    static HRESULT _AdviseCheckClients(void);
    static HRESULT _AdviseDeviceArrivedOrRemoved(LPCWSTR pszDeviceIntfID,
        GUID* pguidInterface, DWORD dwDeviceFlags, LPCWSTR pszEventType);

public:
    CHardwareDevicesImpl();
    ~CHardwareDevicesImpl();

private:
    static DWORD _chwdevcb;
    static LONG  _lAdviseToken;
};

typedef CUnkTmpl<CHardwareDevicesImpl> CHardwareDevices;

///////////////////////////////////////////////////////////////////////////////
//
class CHardwareDevicesEnumImpl : public CCOMBase, public IHardwareDevicesEnum
{
public:
    // Interface IHardwareDevicesEnum
	STDMETHODIMP Next(
		LPWSTR* ppszDeviceID,
		GUID* pguidDeviceID);

public:
    CHardwareDevicesEnumImpl();
    ~CHardwareDevicesEnumImpl();
};

typedef CUnkTmpl<CHardwareDevicesEnumImpl> CHardwareDevicesEnum;

///////////////////////////////////////////////////////////////////////////////
//
class CHardwareDevicesVolumesEnumImpl : public CCOMBase,
    public IHardwareDevicesVolumesEnum
{
public:
    // Interface IHardwareDevicesVolumesEnum
	STDMETHODIMP Next(VOLUMEINFO* pvolinfo);

public: // for CHardwareDevicesImpl usage only
    HRESULT _Init(DWORD dwFlags);

public:
    CHardwareDevicesVolumesEnumImpl();
    ~CHardwareDevicesVolumesEnumImpl();

private:
    class CNamedElemEnum*       _penum;
    DWORD                       _dwFlags;
};

typedef CUnkTmpl<CHardwareDevicesVolumesEnumImpl> CHardwareDevicesVolumesEnum;

///////////////////////////////////////////////////////////////////////////////
//
class CHardwareDevicesMountPointsEnumImpl : public CCOMBase,
    public IHardwareDevicesMountPointsEnum
{
public:
    // Interface IHardwareDevicesMountPointsEnum
	STDMETHODIMP Next(
        LPWSTR* ppszMountPoint,     // "c:\", or "d:\MountFolder\"
        LPWSTR* ppszDeviceIDVolume);// \\?\STORAGE#Volume#...{...GUID...}

public: // for CHardwareDevicesImpl usage only
    HRESULT _Init();

public:
    CHardwareDevicesMountPointsEnumImpl();
    ~CHardwareDevicesMountPointsEnumImpl();

private:
    class CNamedElemEnum*       _penum;
};

typedef CUnkTmpl<CHardwareDevicesMountPointsEnumImpl>
    CHardwareDevicesMountPointsEnum;

///////////////////////////////////////////////////////////////////////////////
//
class CAdviseClient : public CNamedElem
{
public:
    HRESULT Init(LPCWSTR pszElemName);

    HRESULT _Init(DWORD dwProcessID, ULONG_PTR hThread,
        ULONG_PTR pfctCallback);
    HRESULT _Cleanup();
    HRESULT WriteMemoryChunkInOtherProcess(SHHARDWAREEVENT* pshhe,
        DWORD cbSize, void** ppv);
    HRESULT QueueUserAPC(void* pv);
    HRESULT IsProcessStillAlive(void);

protected:
    CAdviseClient();
    ~CAdviseClient();

public:
    static HRESULT Create(CNamedElem** ppelem);

private:
    PAPCFUNC    _pfct;
    HANDLE      _hProcess;
    HANDLE      _hThread;
};

#endif // _REGNOTIF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\regnotifu.cpp ===
#include "regnotif.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CHardwareDevicesIME[] =
{
    _INTFMAPENTRY(CHardwareDevices, IHardwareDevices),
};

const INTFMAPENTRY* CHardwareDevices::_pintfmap = CHardwareDevicesIME;
const DWORD CHardwareDevices::_cintfmap =
    (sizeof(CHardwareDevicesIME)/sizeof(CHardwareDevicesIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CHardwareDevices::_cfcb = NULL;

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CHardwareDevicesVolumesEnumIME[] =
{
    _INTFMAPENTRY(CHardwareDevicesVolumesEnum, IHardwareDevicesVolumesEnum),
};

const INTFMAPENTRY* CHardwareDevicesVolumesEnum::_pintfmap =
    CHardwareDevicesVolumesEnumIME;
const DWORD CHardwareDevicesVolumesEnum::_cintfmap =
    (sizeof(CHardwareDevicesVolumesEnumIME) /
    sizeof(CHardwareDevicesVolumesEnumIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CHardwareDevicesVolumesEnum::_cfcb = NULL;

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CHardwareDevicesMountPointsEnumIME[] =
{
    _INTFMAPENTRY(CHardwareDevicesMountPointsEnum,
        IHardwareDevicesMountPointsEnum),
};

const INTFMAPENTRY* CHardwareDevicesMountPointsEnum::_pintfmap =
    CHardwareDevicesMountPointsEnumIME;
const DWORD CHardwareDevicesMountPointsEnum::_cintfmap =
    (sizeof(CHardwareDevicesMountPointsEnumIME) /
    sizeof(CHardwareDevicesMountPointsEnumIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CHardwareDevicesMountPointsEnum::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\setenumu.cpp ===
#include "setenum.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CEnumAutoplayHandlerIME[] =
{
    _INTFMAPENTRY(CEnumAutoplayHandler, IEnumAutoplayHandler),
};

const INTFMAPENTRY* CEnumAutoplayHandler::_pintfmap = CEnumAutoplayHandlerIME;
const DWORD CEnumAutoplayHandler::_cintfmap =
    (sizeof(CEnumAutoplayHandlerIME)/sizeof(CEnumAutoplayHandlerIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CEnumAutoplayHandler::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\settings.h ===
///////////////////////////////////////////////////////////////////////////////
// Autoplay Handler
///////////////////////////////////////////////////////////////////////////////
#ifndef _SETTINGS_H
#define _SETTINGS_H

#include "unk.h"
#include "misc.h"

#include <shpriv.h>

class CAutoplayHandlerImpl : public CCOMBase, public IAutoplayHandler
{
public:
    // Interface IAutoplayHandler
    STDMETHODIMP Init(LPCWSTR pszDeviceID, LPCWSTR pszEventType);
    STDMETHODIMP InitWithContent(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
		LPCWSTR pszContentTypeHandler);

    STDMETHODIMP EnumHandlers(IEnumAutoplayHandler** ppenum);

    STDMETHODIMP GetDefaultHandler(LPWSTR* ppszHandler);
    STDMETHODIMP SetDefaultHandler(LPCWSTR pszHandler);

public:
    CAutoplayHandlerImpl();

private:
    HRESULT _Init(LPCWSTR pszDeviceID, LPCWSTR pszEventType);

private:
    WCHAR           _szEventHandler[MAX_EVENTHANDLER];
    WCHAR           _szDeviceIDReal[MAX_DEVICEID];
    BOOL            _fInited;
};

typedef CUnkTmpl<CAutoplayHandlerImpl> CAutoplayHandler;

class CAutoplayHandlerPropertiesImpl : public CCOMBase,
    public IAutoplayHandlerProperties
{
public:
    // Interface IAutoplayHandlerProperties
    STDMETHODIMP Init(LPCWSTR pszHandler);

    STDMETHODIMP GetInvokeProgIDAndVerb(LPWSTR* ppszInvokeProgID,
		LPWSTR* ppszInvokeVerb);

public:
    CAutoplayHandlerPropertiesImpl();

private:
    WCHAR           _szHandler[MAX_HANDLER];
    BOOL            _fInited;
};

typedef CUnkTmpl<CAutoplayHandlerPropertiesImpl> CAutoplayHandlerProperties;

#endif // _SETTINGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\svcsync.h ===
#include <objbase.h>

extern HANDLE g_hShellHWDetectionThread;
extern HANDLE g_hEventInitCompleted;

HRESULT _CompleteShellHWDetectionInitialization();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\settingsu.cpp ===
#include "settings.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CAutoplayHandlerIME[] =
{
    _INTFMAPENTRY(CAutoplayHandler, IAutoplayHandler),
};

const INTFMAPENTRY* CAutoplayHandler::_pintfmap = CAutoplayHandlerIME;
const DWORD CAutoplayHandler::_cintfmap =
    (sizeof(CAutoplayHandlerIME)/sizeof(CAutoplayHandlerIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CAutoplayHandler::_cfcb = NULL;

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CAutoplayHandlerPropertiesIME[] =
{
    _INTFMAPENTRY(CAutoplayHandlerProperties, IAutoplayHandlerProperties),
};

const INTFMAPENTRY* CAutoplayHandlerProperties::_pintfmap = CAutoplayHandlerPropertiesIME;
const DWORD CAutoplayHandlerProperties::_cintfmap =
    (sizeof(CAutoplayHandlerPropertiesIME)/sizeof(CAutoplayHandlerPropertiesIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CAutoplayHandlerProperties::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\svcsync.cpp ===
#include "svcsync.h"

#include "dbg.h"
#include "tfids.h"

extern HANDLE g_hShellHWDetectionThread = NULL;
extern HANDLE g_hEventInitCompleted = NULL;

HRESULT _CompleteShellHWDetectionInitialization()
{
    static BOOL fCompleted = FALSE;

    if (!fCompleted)
    {
        // Just in case race condition of 2 threads in this fct
        HANDLE hEvent = InterlockedExchangePointer(
            &g_hEventInitCompleted, NULL);

        TRACE(TF_SVCSYNC,
            TEXT("ShellHWDetection Initialization NOT completed yet"));

        if (hEvent)
        {
            DWORD dwWait = WaitForSingleObject(hEvent, 0);

            if (WAIT_OBJECT_0 == dwWait)
            {
                // It's signaled!
                fCompleted = TRUE;

                TRACE(TF_SVCSYNC,
                    TEXT("ShellHWDetectionInitCompleted event was already signaled!"));
            }
            else
            {
                // Not signaled
                TRACE(TF_SVCSYNC,
                    TEXT("ShellHWDetectionInitCompleted event was NOT already signaled!"));
                
                if (g_hShellHWDetectionThread)
                {
                    if (!SetThreadPriority(g_hShellHWDetectionThread,
                        THREAD_PRIORITY_NORMAL))
                    {
                        TRACE(TF_SVCSYNC,
                            TEXT("FAILED to set ShellHWDetection thread priority to NORMAL from ShellCOMServer"));
                    }
                    else
                    {
                        TRACE(TF_SVCSYNC,
                            TEXT("Set ShellHWDetection thread priority to NORMAL from ShellCOMServer"));
                    }
                }

                Sleep(0);

                dwWait = WaitForSingleObject(hEvent, 30000);

                if (g_hShellHWDetectionThread)
                {
                    // No code should need this handle anymore.  If it's
                    // signaled it was signaled by the other thread, and will
                    // not be used over there anymore.
                    CloseHandle(g_hShellHWDetectionThread);
                    g_hShellHWDetectionThread = NULL;
                }

                if (WAIT_OBJECT_0 == dwWait)
                {
                    // It's signaled!
                    fCompleted = TRUE;

                    TRACE(TF_SVCSYNC,
                        TEXT("ShellHWDetection Initialization COMPLETED"));
                }               
                else
                {
                    // Out of luck, the ShellHWDetection service cannot
                    // complete its initialization...
                    TRACE(TF_SVCSYNC,
                        TEXT("ShellHWDetection Initialization lasted more than 30 sec: FAILED, dwWait = 0x%08X"),
                        dwWait);
                }
            }

            CloseHandle(hEvent);
        }
    }

    return (fCompleted ? S_OK : E_FAIL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\settings.cpp ===
#include "settings.h"

#include "setenum.h"
#include "dtctreg.h"

#include "svcsync.h"

#include "sfstr.h"
#include "cmmn.h"
#include "misc.h"
#include <shlwapi.h>

#include "tfids.h"
#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT _GetEventHandlerHelper(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPWSTR pszEventHandler, DWORD cchEventHandler)
{
    CHWDeviceInst* phwdevinst;
    CNamedElem* pelemToRelease;
    HRESULT hr = _GetHWDeviceInstFromDeviceOrVolumeIntfID(pszDeviceID,
        &phwdevinst, &pelemToRelease);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        WCHAR szDeviceHandler[MAX_DEVICEHANDLER];

        hr = _GetDeviceHandler(phwdevinst, szDeviceHandler,
            ARRAYSIZE(szDeviceHandler));

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = _GetEventHandlerFromDeviceHandler(szDeviceHandler,
                pszEventType, pszEventHandler, cchEventHandler);
        }

        pelemToRelease->RCRelease();
    }

    return hr;
}

HRESULT CAutoplayHandlerImpl::_Init(LPCWSTR pszDeviceID, LPCWSTR pszEventType)
{
    HRESULT hr = _GetDeviceID(pszDeviceID, _szDeviceIDReal,
        ARRAYSIZE(_szDeviceIDReal));
    
    if (SUCCEEDED(hr))
    {
        hr = _GetEventHandlerHelper(_szDeviceIDReal, pszEventType,
            _szEventHandler, ARRAYSIZE(_szEventHandler));

        if (SUCCEEDED(hr))
        {
            if (S_FALSE != hr)
            {
                _fInited = TRUE;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            TRACE(TF_SHHWDTCTDTCTREG,
                TEXT("_Init, _GetEventHandlerHelper FAILED or S_FALSE'd: 0x%08X"),
                hr);
        }
    }
    else
    {
        TRACE(TF_SHHWDTCTDTCTREG, TEXT("_Init, _GetDeviceID FAILED: 0x%08X"),
            hr);
    }

    return hr;
}

STDMETHODIMP CAutoplayHandlerImpl::Init(LPCWSTR pszDeviceID,
    LPCWSTR pszEventType)
{
    HRESULT hr;

    if (pszDeviceID && *pszDeviceID && pszEventType && *pszEventType)
    {
        hr = _Init(pszDeviceID, pszEventType);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CAutoplayHandlerImpl::InitWithContent(LPCWSTR pszDeviceID,
    LPCWSTR /*pszEventType*/, LPCWSTR pszContentTypeHandler)
{
    HRESULT hr;
        
    if (pszDeviceID && *pszDeviceID && pszContentTypeHandler && *pszContentTypeHandler)
    {
        hr = _GetDeviceID(pszDeviceID, _szDeviceIDReal,
            ARRAYSIZE(_szDeviceIDReal));

        if (SUCCEEDED(hr))
        {
            if (!lstrcmpi(pszContentTypeHandler, TEXT("CDAudioContentHandler")))
            {
                hr = SafeStrCpyN(_szEventHandler, TEXT("PlayCDAudioOnArrival"), ARRAYSIZE(_szEventHandler));
            }
            else if (!lstrcmpi(pszContentTypeHandler, TEXT("DVDMovieContentHandler")))
            {
                hr = SafeStrCpyN(_szEventHandler, TEXT("PlayDVDMovieOnArrival"), ARRAYSIZE(_szEventHandler));
            }
            else if (!lstrcmpi(pszContentTypeHandler, TEXT("BlankCDContentHandler")))
            {
                hr = SafeStrCpyN(_szEventHandler, TEXT("HandleCDBurningOnArrival"), ARRAYSIZE(_szEventHandler));
            }
            else if (!lstrcmpi(pszContentTypeHandler, TEXT("MusicFilesContentHandler")))
            {
                hr = SafeStrCpyN(_szEventHandler, TEXT("PlayMusicFilesOnArrival"), ARRAYSIZE(_szEventHandler));
            }
            else if (!lstrcmpi(pszContentTypeHandler, TEXT("PicturesContentHandler")))
            {
                hr = SafeStrCpyN(_szEventHandler, TEXT("ShowPicturesOnArrival"), ARRAYSIZE(_szEventHandler));
            }
            else if (!lstrcmpi(pszContentTypeHandler, TEXT("VideoFilesContentHandler")))
            {
                hr = SafeStrCpyN(_szEventHandler, TEXT("PlayVideoFilesOnArrival"), ARRAYSIZE(_szEventHandler));
            }
            else if (!lstrcmpi(pszContentTypeHandler, TEXT("MixedContentHandler")))
            {
                hr = SafeStrCpyN(_szEventHandler, TEXT("MixedContentOnArrival"), ARRAYSIZE(_szEventHandler));
            }
            else
            {
                hr = E_FAIL;
            }

            if (SUCCEEDED(hr))
            {
                _fInited = TRUE;
            }
        }
        else
        {
            TRACE(TF_SHHWDTCTDTCTREG, TEXT("_Init, _GetDeviceID FAILED: 0x%08X"),
                hr);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CAutoplayHandlerImpl::GetDefaultHandler(LPWSTR* ppszHandler)
{
    HRESULT hr;

    TRACE(TF_SHHWDTCTDTCTREG, TEXT("Entered CAutoplayHandlerImpl"));

    if (ppszHandler)
    {
        *ppszHandler = NULL;

        if (_fInited)
        {
            WCHAR szHandler[MAX_HANDLER];

            hr = _GetUserDefaultHandler(_szDeviceIDReal, _szEventHandler,
                szHandler, ARRAYSIZE(szHandler), GUH_IMPERSONATEUSER);

            if (SUCCEEDED(hr))
            {
                if (S_FALSE != hr)
                {
                    // Watch out!  The hr from _GetUserDefaultHandler is more
                    // than just S_OK/S_FALSE.  Keep its value, unless we fail!
                    HRESULT hrTmp = _CoTaskMemCopy(szHandler, ppszHandler);

                    if (FAILED(hrTmp))
                    {
                        hr = hrTmp;
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

#define SOFTPREFIX      TEXT("[soft]")

STDMETHODIMP CAutoplayHandlerImpl::SetDefaultHandler(LPCWSTR pszHandler)
{
    HRESULT hr;

    if (_fInited)
    {
        if (pszHandler && *pszHandler)
        {
            if (StrNCmp(SOFTPREFIX, pszHandler, (ARRAYSIZE(SOFTPREFIX) - 1)))
            {
                hr = _SetUserDefaultHandler(_szDeviceIDReal, _szEventHandler,
                    pszHandler);
            }
            else
            {
                hr = _SetSoftUserDefaultHandler(_szDeviceIDReal,
                    _szEventHandler, pszHandler + ARRAYSIZE(SOFTPREFIX) - 1);
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CAutoplayHandlerImpl::EnumHandlers(IEnumAutoplayHandler** ppenum)
{
    HRESULT hr;

    if (ppenum)
    {
        *ppenum = NULL;

        if (_fInited)
        {
            CEnumAutoplayHandler* penum = new CEnumAutoplayHandler(NULL);

            if (penum)
            {
                hr = penum->_Init(_szEventHandler);

                if (SUCCEEDED(hr))
                {
                    *ppenum = penum;
                }
                else
                {
                    delete penum;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

CAutoplayHandlerImpl::CAutoplayHandlerImpl() : _fInited(FALSE)
{
    _CompleteShellHWDetectionInitialization();
}

//
CAutoplayHandlerPropertiesImpl::CAutoplayHandlerPropertiesImpl() : _fInited(FALSE)
{
    _CompleteShellHWDetectionInitialization();
}

STDMETHODIMP CAutoplayHandlerPropertiesImpl::Init(LPCWSTR pszHandler)
{
    HRESULT hr;

    if (pszHandler && *pszHandler)
    {
        if (!_fInited)
        {
            hr = SafeStrCpyN(_szHandler, pszHandler, ARRAYSIZE(_szHandler));

            if (SUCCEEDED(hr))
            {
                _fInited = TRUE;
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CAutoplayHandlerPropertiesImpl::GetInvokeProgIDAndVerb(
    LPWSTR* ppszInvokeProgID, LPWSTR* ppszInvokeVerb)
{
    HRESULT hr;

    if (ppszInvokeProgID && ppszInvokeVerb)
    {
        *ppszInvokeProgID = NULL;
        *ppszInvokeVerb = NULL;

        if (_fInited)
        {
            WCHAR szInvokeProgID[MAX_INVOKEPROGID];

            hr = _GetInvokeProgIDFromHandler(_szHandler, szInvokeProgID,
                ARRAYSIZE(szInvokeProgID));

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                WCHAR szInvokeVerb[MAX_INVOKEVERB];

                hr = _GetInvokeVerbFromHandler(_szHandler, szInvokeVerb,
                    ARRAYSIZE(szInvokeVerb));

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    hr = _CoTaskMemCopy(szInvokeProgID, ppszInvokeProgID);

                    if (SUCCEEDED(hr))
                    {
                        hr = _CoTaskMemCopy(szInvokeVerb, ppszInvokeVerb);

                        if (FAILED(hr))
                        {
                            if (*ppszInvokeProgID)
                            {
                                CoTaskMemFree((PVOID)*ppszInvokeProgID);
                                *ppszInvokeProgID = NULL;
                            }
                        }
                    }
                }
            }

            if (S_FALSE == hr)
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\sources.inc ===
USE_MSVCRT=1
UMTYPE=windows

!include ..\..\shsrvice.inc
SOURCES_USED = $(SOURCES_USED) ..\..\shsrvice.inc

TARGETNAME=shhwdtct
TARGETPATH=obj

SOURCES = \
    ..\cmmn.cpp      \
    ..\cstmprop.cpp  \
    ..\cstmpropu.cpp \
    ..\devinfo.cpp   \
    ..\devinfou.cpp  \
    ..\dispatch.cpp  \
    ..\drvbase.cpp   \
    ..\dtct.cpp      \
    ..\dtctimp.cpp   \
    ..\dtctreg.cpp   \
    ..\dtctu.cpp     \
    ..\factdata.cpp  \
    ..\gdtinfo.cpp   \
    ..\logging.cpp   \
    ..\hnotif.cpp    \
    ..\hwdev.cpp     \
    ..\miscdev.cpp   \
    ..\mtpts.cpp     \
    ..\pnp.cpp       \
    ..\regnotif.cpp  \
    ..\regnotifu.cpp \
    ..\setenum.cpp   \
    ..\setenumu.cpp  \
    ..\settings.cpp  \
    ..\settingsu.cpp \
    ..\special.cpp   \
    ..\svcsync.cpp   \
    ..\vol.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\special.cpp ===
#include "dtct.h"

#include "regnotif.h"
#include "vol.h"

#include "cmmn.h"

#include <dbt.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT _ProcessInterfaceDiskGenericArrival(LPCWSTR pszDeviceIntfID,
    BOOL )
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_DISK, &pnel);

    if (SUCCEEDED(hr))
    {
        CNamedElem* pelem;

        hr = pnel->GetOrAdd(pszDeviceIntfID, &pelem);

        if (SUCCEEDED(hr))
        {
            pelem->RCRelease();
        }

        pnel->RCRelease();
    }
       
    return hr;
}

HRESULT _ProcessInterfaceVolumeArrival(LPCWSTR pszDeviceIntfID)
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_VOLUME, &pnel);

    if (SUCCEEDED(hr))
    {
        CNamedElem* pelem;
        
        hr = pnel->GetOrAdd(pszDeviceIntfID, &pelem);

        if (SUCCEEDED(hr))
        {
            // Was it already there, or just added?
            if (S_FALSE == hr)
            {
                // Added
                CVolume* pvol = (CVolume*)pelem;

                hr = pvol->HandleArrival();
            }
            
            pelem->RCRelease();
        }
        else
        {
            if (E_FAIL == hr)
            {
                hr = S_FALSE;
            }
        }

        pnel->RCRelease();
    }
       
    return hr;
}

HRESULT _ProcessInterfaceVolumeRemoval(LPCWSTR pszDeviceIntfID)
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_VOLUME, &pnel);

    if (SUCCEEDED(hr))
    {
        CNamedElem* pelem;
        
        hr = pnel->Get(pszDeviceIntfID, &pelem);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            CHWDeviceInst* phwdevinst;
            CVolume* pvol = (CVolume*)pelem;

            pvol->HandleRemoval();

            hr = pvol->GetHWDeviceInst(&phwdevinst);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                hr = _TryAutoplay(pszDeviceIntfID, phwdevinst,
                    DBT_DEVICEREMOVECOMPLETE);
            }

            // If we're removing it, let's remove it from the list
            HRESULT hr2 = pnel->Remove(pszDeviceIntfID);

            hr = FAILED(hr2) ? hr2 : hr;

            pelem->RCRelease();
        }

        pnel->RCRelease();
    }
       
    return hr;
}

HRESULT _ProcessInterfaceCDROMArrival(LPCWSTR pszDeviceIntfID)
{
    return _ProcessInterfaceDiskGenericArrival(pszDeviceIntfID, TRUE);
}

HRESULT _ProcessInterfaceDiskArrival(LPCWSTR pszDeviceIntfID)
{
    return _ProcessInterfaceDiskGenericArrival(pszDeviceIntfID, FALSE);
}

HRESULT _ProcessInterfaceDiskRemoval(LPCWSTR pszDeviceIntfID)
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_DISK, &pnel);

    if (S_OK == hr)
    {
        hr = pnel->Remove(pszDeviceIntfID);

        pnel->RCRelease();
    }
       
    return hr;
}

typedef HRESULT (*PROCESSINTERFACESPECIALCASEDFCT)(LPCWSTR pszDeviceIntfID);

struct INTERFACESPECIALCASED
{
    const GUID*                         pguid;
    PROCESSINTERFACESPECIALCASEDFCT     piscfctArrival;
    PROCESSINTERFACESPECIALCASEDFCT     piscfctRemoval;
};

const INTERFACESPECIALCASED _rgInterfaceSpecialCased[] =
{
    { &guidVolumeClass, _ProcessInterfaceVolumeArrival, _ProcessInterfaceVolumeRemoval, },
    { &guidCdRomClass, _ProcessInterfaceCDROMArrival, _ProcessInterfaceDiskRemoval, },
    { &guidDiskClass, _ProcessInterfaceDiskArrival, _ProcessInterfaceDiskRemoval, },
};

HRESULT _IsInterfaceSpecialCased(GUID* pguidClass, BOOL* pfSpecialCased)
{
    *pfSpecialCased = FALSE;

    for (DWORD dw = 0; !(*pfSpecialCased) &&
        (dw < ARRAYSIZE(_rgInterfaceSpecialCased)); ++dw)
    {
        if (*pguidClass == *(_rgInterfaceSpecialCased[dw].pguid))
        {
            *pfSpecialCased = TRUE;
        }
    }

    return S_OK;
}

HRESULT _ProcessInterfaceSpecialCased(GUID* pguidInterface,
    LPCWSTR pszDeviceIntfID, DWORD dwEventType)
{
    HRESULT hr;

    if ((DBT_DEVICEARRIVAL == dwEventType) ||
        (DBT_DEVICEREMOVECOMPLETE == dwEventType))
    {
        BOOL fExit = FALSE;

        hr = E_UNEXPECTED;

        for (DWORD dw = 0; !fExit &&
            (dw < ARRAYSIZE(_rgInterfaceSpecialCased)); ++dw)
        {
            if (*pguidInterface == *(_rgInterfaceSpecialCased[dw].pguid))
            {
                PROCESSINTERFACESPECIALCASEDFCT piscfct;

                if (DBT_DEVICEARRIVAL == dwEventType)
                {
                    piscfct = _rgInterfaceSpecialCased[dw].piscfctArrival;
                }
                else
                {
                    piscfct = _rgInterfaceSpecialCased[dw].piscfctRemoval;
                }

                fExit = TRUE;

                hr = (piscfct)(pszDeviceIntfID);
            }
        }

        if (!fExit)
        {
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        // Don't care about others for now
        hr = S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shsrvice\svchost.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "shsrvice.h"
#include "HDService.h"

void WINAPI HardwareDetectionServiceMain(DWORD cArg, LPWSTR* ppszArgs)
{
    CGenericServiceManager::_ServiceMain(cArg, ppszArgs);
}

HRESULT CHDService::Install(BOOL fInstall, LPCWSTR)
{
    if (fInstall)
    {
        CGenericServiceManager::Install();
    }
    else
    {
        CGenericServiceManager::UnInstall();
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\apiconnection.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: APIConnectionThread.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class that listens to an LPC connection port waiting for requests from
//  a client to connect to the port or a request which references a previously
//  established connection.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "APIConnection.h"

#include <lpcgeneric.h>

#include "Access.h"
#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CAPIConnection::CAPIConnection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CAPIConnectionThread. Store the CServerAPI
//              function table. This describes how to react to LPC messages.
//              This function also creates the server connection port.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//              2000-09-01  vtan        use explicit security descriptor
//  --------------------------------------------------------------------------

CAPIConnection::CAPIConnection (CServerAPI* pServerAPI) :
    _status(STATUS_NO_MEMORY),
    _fStopListening(false),
    _pServerAPI(pServerAPI),
    _hPort(NULL),
    _pAPIDispatchSync(NULL)

{
    OBJECT_ATTRIBUTES       objectAttributes;
    UNICODE_STRING          portName;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;

    //  Increment the reference on the interface.

    pServerAPI->AddRef();

    //  Get the name from the interface.

    RtlInitUnicodeString(&portName, pServerAPI->GetPortName());

    //  Build a security descriptor for the port that allows:
    //      S-1-5-18        NT AUTHORITY\SYSTEM     PORT_ALL_ACCESS
    //      S-1-5-32-544    <local administrators>  READ_CONTROL | PORT_CONNECT

    static  SID_IDENTIFIER_AUTHORITY    s_SecurityNTAuthority       =   SECURITY_NT_AUTHORITY;

    static  const CSecurityDescriptor::ACCESS_CONTROL   s_AccessControl[]   =
    {
        {
            &s_SecurityNTAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            PORT_ALL_ACCESS
        },
        {
            &s_SecurityNTAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            READ_CONTROL | PORT_CONNECT
        }
    };

    //  Build a security descriptor that allows the described access above.

    pSecurityDescriptor = CSecurityDescriptor::Create(ARRAYSIZE(s_AccessControl), s_AccessControl);

    //  Initialize the object attributes.

    InitializeObjectAttributes(&objectAttributes,
                               &portName,
                               0,
                               NULL,
                               pSecurityDescriptor);

    //  Create the port.

    _status = NtCreatePort(&_hPort,
                           &objectAttributes,
                           128, // Max connection info length (kernel accepts (MaxMessageLength - 68) maximum (188 here)),
                                // used for client validation
                           PORT_MAXIMUM_MESSAGE_LENGTH, // MaxMessageLength
                           16 * PORT_MAXIMUM_MESSAGE_LENGTH);

    //  Release the security descriptor memory.

    ReleaseMemory(pSecurityDescriptor);

    if (!NT_SUCCESS(_status))
    {
        pServerAPI->Release();
    }
}

//  --------------------------------------------------------------------------
//  CAPIConnection::~CAPIConnection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CAPIConnectionThread. Close the port. Release
//              the interface referrence.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CAPIConnection::~CAPIConnection (void)

{
    ReleaseHandle(_hPort);
    _pServerAPI->Release();
    _pServerAPI = NULL;
}

//  --------------------------------------------------------------------------
//  CAPIConnection::ConstructorStatusCode
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Returns the constructor status code back to the caller.
//
//  History:    2000-10-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::ConstructorStatusCode (void)    const

{
    return(_status);
}

//  --------------------------------------------------------------------------
//  CAPIConnection::Listen
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Listens for server API connections and requests.
//
//  History:    2000-11-28  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::Listen (CAPIDispatchSync* pAPIDispatchSync)

{
    NTSTATUS    status;

    //  If a connection port was created then start listening.

    if (_hPort != NULL)
    {
        _pAPIDispatchSync = pAPIDispatchSync;
        do
        {
            (NTSTATUS)ListenToServerConnectionPort();
        } while (!_fStopListening);
        status = STATUS_SUCCESS;
    }
    else
    {
        status = STATUS_OBJECT_NAME_NOT_FOUND;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIConnection::AddAccess
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds access allowed to the ACL of the port.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::AddAccess (PSID pSID, DWORD dwMask)

{
    CSecuredObject  object(_hPort, SE_KERNEL_OBJECT);

    return(object.Allow(pSID, dwMask, 0));
}

//  --------------------------------------------------------------------------
//  CAPIConnection::RemoveAccess
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Removes access allowed from the ACL of the port.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::RemoveAccess (PSID pSID)

{
    CSecuredObject  object(_hPort, SE_KERNEL_OBJECT);

    return(object.Remove(pSID));
}

//  --------------------------------------------------------------------------
//  CAPIConnection::ListenToServerConnectionPort
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Calls ntdll!NtReplyWaitReceivePort to listen to the LPC port
//              for a message. Respond to the message. Messages understood are
//              LPC_REQUEST / LPC_CONNECTION_REQUEST / LPC_PORT_CLOSED.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::ListenToServerConnectionPort (void)

{
    NTSTATUS        status;
    CAPIDispatcher  *pAPIDispatcher;
    CPortMessage    portMessage;

    status = NtReplyWaitReceivePort(_hPort,
                                    reinterpret_cast<void**>(&pAPIDispatcher),
                                    NULL,
                                    portMessage.GetPortMessage());
    if (NT_SUCCESS(status))
    {
        switch (portMessage.GetType())
        {
            case LPC_REQUEST:
                status = HandleServerRequest(portMessage, pAPIDispatcher);
                break;
            case LPC_CONNECTION_REQUEST:
                (NTSTATUS)HandleServerConnectionRequest(portMessage);
                break;
            case LPC_PORT_CLOSED:
                status = HandleServerConnectionClosed(portMessage, pAPIDispatcher);
                break;
            default:
                break;
        }
        TSTATUS(status);
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIConnection::HandleServerRequest
//
//  Arguments:  portMessage     =   CPortMessage containing the message.
//              pAPIDispatcher  =   CAPIDispatcher to handle request.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Queue the PORT_MESSAGE request to the handling dispatcher and
//              wait for the next message. The queue operation will queue the
//              request and either queue a work item if no work item is
//              currently executing or just add it to the currently executing
//              work item.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::HandleServerRequest (const CPortMessage& portMessage, CAPIDispatcher *pAPIDispatcher)

{
    NTSTATUS            status;
    unsigned long       ulAPINumber;
    const API_GENERIC   *pAPI;

    pAPI = reinterpret_cast<const API_GENERIC*>(portMessage.GetData());
    ulAPINumber = pAPI->ulAPINumber;
    if ((ulAPINumber & API_GENERIC_SPECIAL_MASK) != 0)
    {
        switch (pAPI->ulAPINumber & API_GENERIC_SPECIAL_MASK)
        {
            case API_GENERIC_STOPSERVER:
            {
                //  Here, our job is to tear down the API port management infrastructure.

                //  First, verify that we received this from ourselves, and not some
                //  other random process.
                if (HandleToULong(portMessage.GetUniqueProcess()) == GetCurrentProcessId())
                {
                    status = STATUS_SUCCESS;

                    // Cause our LPC port listening loop to exit.  After this we're 
                    //  no longer monitoring the port for new requests.
                    _fStopListening = true; 
                }
                else
                {
                    status = STATUS_ACCESS_DENIED;
                }

                //  Blow the message back to our caller. Even though this is
                //  RejectRequest(), it'll cause the calling thread's NtRequestWaitReplyPort
                //  to return.
                TSTATUS(pAPIDispatcher->RejectRequest(portMessage, status));

                //  Wait a reasonable about of time for any outstanding requests to 
                //  come home and be dequeued.
                if( CAPIDispatchSync::WaitForZeroDispatches(_pAPIDispatchSync, DISPATCHSYNC_TIMEOUT) 
                    != WAIT_TIMEOUT )
                {
                    int i, iLimit;

                    //  Now iterate all the CAPIDispatchers we know of and close them.
                    //  this will reject any further requests and not have clients
                    //  block in NtRequestWaitReplyPort.
                    
                    _dispatchers_lock.Acquire();  // protect vs. competing cleanup threads 
                                                 // (eg. Listen() --> HandleServerConnectionClosed() )

                    iLimit = _dispatchers.GetCount();
                    for (i = iLimit - 1; i >= 0; --i)
                    {
                        CAPIDispatcher *p;

                        p = static_cast<CAPIDispatcher*>(_dispatchers.Get(i));
                        if (p != NULL)
                        {
                            p->CloseConnection();
                            p->Release();
                        }
                        _dispatchers.Remove(i);
                    }
                    _dispatchers_lock.Release();

                    //  Proceed w/ shutdown sequence
                    CAPIDispatchSync::SignalPortShutdown(_pAPIDispatchSync); 
                }
                else
                {
                    _fStopListening = false;
                    status = STATUS_TIMEOUT;
                }

                break;
            }
            default:
                status = STATUS_NOT_IMPLEMENTED;
                DISPLAYMSG("Invalid API number special code passed to CAPIConnection::HandleServerRequest");
                break;
        }
    }
    else if ((pAPI->ulAPINumber & API_GENERIC_OPTIONS_MASK) != 0)
    {
        switch (pAPI->ulAPINumber & API_GENERIC_OPTIONS_MASK)
        {
            case API_GENERIC_EXECUTE_IMMEDIATELY:
                status = pAPIDispatcher->ExecuteRequest(portMessage);
                break;
            default:
                status = STATUS_NOT_IMPLEMENTED;
                DISPLAYMSG("Invalid API number option passed to CAPIConnection::HandleServerRequest");
                break;
        }
    }
    else
    {
        status = pAPIDispatcher->QueueRequest(portMessage, _pAPIDispatchSync);
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIConnection::HandleServerConnectionRequest
//
//  Arguments:  portMessage     =   CPortMessage containing the message.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Ask the interface whether this connection should be accepted.
//              If the connection is accepted then create the dispatcher that
//              handles requests from this particular client. Either way
//              inform the kernel that the request is either rejected or
//              accepted. If the connection is accepted then complete the
//              connection and give the dispatcher that will handle the
//              requests the port to reply to.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::HandleServerConnectionRequest (const CPortMessage& portMessage)

{
    NTSTATUS        status;
    bool            fConnectionAccepted;
    HANDLE          hPort;
    CAPIDispatcher  *pAPIDispatcher;

    //  Should the connection be accepted?

    fConnectionAccepted = _pServerAPI->ConnectionAccepted(portMessage);
    if (fConnectionAccepted)
    {

        //  If so then create the dispatcher to handle this client.

        pAPIDispatcher = _pServerAPI->CreateDispatcher(portMessage);
        if (pAPIDispatcher != NULL)
        {

            //  First try to add the CAPIDispatcher object to the static array.
            //  If this fails then reject the connection and release the memory.

            if (!NT_SUCCESS(_dispatchers.Add(pAPIDispatcher)))
            {
                pAPIDispatcher->Release();
                pAPIDispatcher = NULL;
            }
        }
    }
    else
    {
        pAPIDispatcher = NULL;
    }

    //  Without a CAPIDispatcher object reject the connection.

    if (pAPIDispatcher == NULL)
    {
        fConnectionAccepted = false;
    }

    //  Tell the kernel what the result is.

    status = NtAcceptConnectPort(&hPort,
                                 pAPIDispatcher,
                                 const_cast<PORT_MESSAGE*>(portMessage.GetPortMessage()),
                                 fConnectionAccepted,
                                 NULL,
                                 NULL);
    if (fConnectionAccepted)
    {

        //  If we tried to accept the connection but NtAcceptConnectPort
        //  couldn't allocate the port objects or something then we need
        //  to clean up the _dispatchers array CAPIDispatcher entry added.

        if (NT_SUCCESS(status))
        {
            pAPIDispatcher->SetPort(hPort);

            //  If the connection is accepted then complete the connection and set
            //  the reply port to the CAPIDispatcher that will process requests.

            TSTATUS(NtCompleteConnectPort(hPort));
        }
        else
        {
            int     iIndex;

            //  Otherwise find the CAPIDispatcher that was added and remove it
            //  from the array. There's no need to wake the client up because
            //  NtAcceptConnectPort wakes it up in cases of failure.
            iIndex = FindIndexDispatcher(pAPIDispatcher);
            if (iIndex >= 0)
            {
                TSTATUS(_dispatchers.Remove(iIndex));
            }
            TSTATUS(pAPIDispatcher->CloseConnection());
            pAPIDispatcher->Release();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIConnection::HandleServerConnectionClosed
//
//  Arguments:  portMessage     =   CPortMessage containing the message.
//              pAPIDispatcher  =   CAPIDispatcher to handle request.
//
//  Returns:    NTSTATUS
//
//  Purpose:    The port associated with the CAPIDispatcher client was
//              closed. This is probably because the client process went away.
//              Let the dispatcher clean itself up.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::HandleServerConnectionClosed (const CPortMessage& portMessage, CAPIDispatcher *pAPIDispatcher)

{
    UNREFERENCED_PARAMETER(portMessage);

    NTSTATUS    status;

    if (pAPIDispatcher != NULL)
    {
        int     iIndex;

        status = pAPIDispatcher->CloseConnection();
        pAPIDispatcher->Release();

       _dispatchers_lock.Acquire(); // protect vs. competing cleanup threads (eg. API_GENERIC_STOPSERVER).

        iIndex = FindIndexDispatcher(pAPIDispatcher);
        if (iIndex >= 0)
        {
            _dispatchers.Remove(iIndex);
        }

        _dispatchers_lock.Release(); 
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIConnection::FindIndexDispatcher
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher to find.
//
//  Returns:    int
//
//  Purpose:    Finds the index in the dynamic counted object array of the
//              dispatcher.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

int     CAPIConnection::FindIndexDispatcher (CAPIDispatcher *pAPIDispatcher)

{
    int     i, iLimit, iResult;

    iResult = -1;
    iLimit = _dispatchers.GetCount();
    for (i = 0; (iResult < 0) && (i < iLimit); ++i)
    {
        if (pAPIDispatcher == static_cast<CAPIDispatcher*>(_dispatchers.Get(i)))
        {
            iResult = i;
        }
    }
    return(iResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shsrvice\shsrvice.h ===
#include "service.h"

///////////////////////////////////////////////////////////////////////////////
//
struct CTRLEVENT;

struct SERVICEENTRY
{
    HANDLE                      _hEventRelinquishControl;
    IService*                   _pservice;
    SERVICE_STATUS              _servicestatus;
    SERVICE_STATUS_HANDLE       _ssh;
    BOOL                        _fWantsDeviceEvents;
    CTRLEVENT*                  _peventQueueHead;
    CTRLEVENT*                  _peventQueueTail;
    BOOL                        _fSkipTerminatingEvents;
    HANDLE                      _hEventSynchProcessing;
    WCHAR                       _szServiceEventName[100];
#ifdef DEBUG
    DWORD                       _cEvents;
    WCHAR                       _szServiceName[256];
#endif
};

///////////////////////////////////////////////////////////////////////////////
//
class CGenericServiceManager
{
public:
    static HRESULT Install();
    static HRESULT UnInstall();

public:
    // call publicly in process.cpp only
    static void WINAPI _ServiceMain(DWORD cArg, LPWSTR* ppszArgs);
    static DWORD WINAPI _ServiceHandler(DWORD dwControl, DWORD dwEventType,
        LPVOID pEventData, LPVOID lpContext);
    static HRESULT _HandleWantsDeviceEvents(LPCWSTR pszServiceName,
        BOOL fWantsDeviceEvents);

    // called from dll.cpp
    static HRESULT DllAttach(HINSTANCE hinst);
    static HRESULT DllDetach();

private:
    static HRESULT _ProcessServiceControlCodes(SERVICEENTRY* pse);

    static HRESULT _GetServiceIndex(LPCWSTR pszServiceName, DWORD* pdw);
    static HRESULT _GetServiceCLSID(LPCWSTR pszServiceName, CLSID* pclsid);
    static HRESULT _CreateIService(LPCWSTR pszServiceName,
        IService** ppservice);

    static HRESULT _InitServiceEntry(LPCWSTR pszServiceName,
        SERVICEENTRY** ppse);
    static HRESULT _CleanupServiceEntry(SERVICEENTRY* pse);

    static HRESULT _RegisterServiceCtrlHandler(LPCWSTR pszServiceName,
        SERVICEENTRY* pse);
    static BOOL _SetServiceStatus(SERVICEENTRY* pse);

    static HRESULT _HandleServiceControls(SERVICEENTRY* pse, DWORD dwControl,
        DWORD dwEventType, PVOID pvEventData);
    static HRESULT _HandlePreState(SERVICEENTRY* pse, DWORD dwControl);
    static HRESULT _HandlePostState(SERVICEENTRY* pse, DWORD dwControl,
        BOOL fPending);

    static HRESULT _QueueEvent(SERVICEENTRY* pse, DWORD dwControl,
        DWORD dwEventType, PVOID pEventData);
    static HRESULT _DeQueueEvent(SERVICEENTRY* pse, CTRLEVENT** ppevent);
    static HRESULT _MakeEvent(DWORD dwControl, DWORD dwEventType,
        PVOID pvEventData, CTRLEVENT** ppevent);
    static HRESULT _EventNeedsToBeProcessedSynchronously(DWORD dwControl,
        DWORD dwEventType, LPVOID pvEventData, SERVICEENTRY* pse,
        BOOL* pfBool);

    static HRESULT _Init();
    static HRESULT _Cleanup();

public:
    static SERVICE_TABLE_ENTRY  _rgste[];

    struct SUBSERVICE
    {
        LPWSTR          pszProgID;
        UINT            uFriendlyName;
        LPWSTR          pszDependencies; // double null-terminated array of
                                         // null-separated names
        LPWSTR          pszLoadOrderGroup;
        UINT            uDescription;
        SERVICEENTRY    se;
    };

    static SUBSERVICE           _rgsubservice[];

private:
    static DWORD                _cste;

    static CRITICAL_SECTION     _csQueue;
    static BOOL                 _fCritSectInit;
    static HANDLE               _hEventInitCS;

#ifdef DEBUG
public:
    static BOOL                 _fRunAsService;
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\vol.h ===
#include "namellst.h"

#include "hwdev.h"

#include "cmmn.h"

#include "misc.h"

#include <objbase.h>
#include <shpriv.h>

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

class CVolume : public CNamedElem, public CHandleNotifTarget
{
public:
    // CNamedElem
    HRESULT Init(LPCWSTR pszElemName);

    // CHandleNotifTarget
    HRESULT HNTHandleEvent(DEV_BROADCAST_HANDLE* pdbh, DWORD dwEventType);

    // CVolume
    //      Returns S_FALSE if can't find it
    HRESULT GetHWDeviceInst(CHWDeviceInst** pphwdevinst);

    HRESULT GetVolumeConstInfo(LPWSTR pszVolumeGUID, DWORD cchVolumeGUID,
        DWORD* pdwVolumeFlags, DWORD* pdwDriveType, DWORD* pdwDriveCap);

    HRESULT GetVolumeMediaInfo(LPWSTR pszLabel, DWORD cchLabel, 
        LPWSTR pszFileSystem, DWORD cchFileSystem, DWORD* pdwFileSystemFlags,
        DWORD* pdwMaxFileNameLen, DWORD* pdwRootAttributes,
        DWORD* pdwSerialNumber, DWORD* pdwDriveState, DWORD* pdwMediaState,
        DWORD* pdwMediaCap);

    HRESULT GetIconAndLabelInfo(LPWSTR pszAutorunIconLocation,
        DWORD cchAutorunIconLocation, LPWSTR pszAutorunLabel, DWORD cchAutorunLabel,
        LPWSTR pszIconLocationFromService, DWORD cchIconLocationFromService,
        LPWSTR pszNoMediaIconLocationFromService,
        DWORD cchNoMediaIconLocationFromService,
        LPWSTR pszLabelFromService, DWORD cchLabelFromService);

    HRESULT HandleArrival();
    HRESULT HandleRemoval();

public:
    static HRESULT Create(CNamedElem** ppelem);
    static HRESULT GetFillEnum(CFillEnum** ppfillenum);

public:
    CVolume();
    ~CVolume();

private:
    HRESULT _InitHelper(LPCWSTR pszElemName);
    void _HandleAccessDenied();

    HRESULT _CreateMountPoints();
    HRESULT _UpdateMountPoints();
    HRESULT _GetMountPoints(LPWSTR* ppsz, DWORD* pcch);
    HRESULT _CreateMtPt(LPWSTR pszMtPt);
    HRESULT _RemoveMtPt(LPWSTR pszMtPt);

    HRESULT _RegisterNotif();
    HRESULT _UnregisterNotif();

    HRESULT _InitDriveType(HANDLE hDevice);
    HRESULT _InitHWDeviceInst();
    HRESULT _UpdateConstInfo(HANDLE hDevice);
    HRESULT _UpdateMediaInfo(HANDLE hDevice, BOOL fGetYourOwnHandle);
    HRESULT _UpdateMediaInfoOnRemove();

    HRESULT _UpdateSoftEjectCaps();
    HRESULT _UpdateRemovableDevice();
    HRESULT _UpdateHasMedia(HANDLE hDevice);
    HRESULT _UpdateSpecialFilePresence();
    HRESULT _UpdateTrackInfo(HANDLE hDevice);
    HRESULT _FillMMC2CD(HANDLE hDevice);
    HRESULT _UpdateMMC2CDInfo(HANDLE hDevice);

    HRESULT _ExtractAutorunIconAndLabel();

    HRESULT _GetDeviceHandleSafe(HANDLE* phDevice, BOOL fGenericReadRequired);
    HRESULT _CloseDeviceHandleSafe(HANDLE hDevice);

    HRESULT _HandleMediaArrival();
    HRESULT _HandleMediaRemoval();
    HRESULT _HandleVolumeChange();

    HRESULT _AdviseVolumeChangeHelper(BOOL fAdded);
    HRESULT _AdviseMountPointHelper(LPCWSTR pszMountPoint, BOOL fAdded);
    HRESULT _AdviseVolumeMountingEvent(DWORD dwEvent);
    HRESULT _GetVOLUMEINFO2(VOLUMEINFO2** ppvolinfo2);

    HRESULT _ShouldTryAutoplay(BOOL* pfTry);

    HRESULT _GetDeviceIDDisk(LPWSTR pszDeviceIDDisk,
        DWORD cchDeviceIDDisk);

    HRESULT _DVDRAMHack(HANDLE hDevice);

public:
    DWORD                               _dwState;

private:
    DWORD                               _dwMediaPresentFromEvent;

    DWORD                               _dwMediaState;
    DWORD                               _dwMediaCap;

    WCHAR                               _szVolumeGUID[50];
    DWORD                               _dwVolumeFlags;
    DWORD                               _dwDriveType;
    DWORD                               _dwDriveCap;
    DWORD                               _dwDriveState;
    WCHAR                               _szDeviceIDDisk[MAX_DEVICEID];

    WCHAR                               _szLabel[MAX_LABEL];
    DWORD                               _dwSerialNumber;
    DWORD                               _dwMaxFileNameLen;
    DWORD                               _dwFileSystemFlags;
    WCHAR                               _szFileSystem[MAX_FILESYSNAME];

    DWORD                               _dwRootAttributes;

    DEVICE_TYPE                         _devtype;
    ULONG                               _ulDeviceNumber;
    ULONG                               _ulPartitionNumber;

    LPWSTR                              _pszMountPoints;
    DWORD                               _cchMountPoints;

    CHWDeviceInst                       _hwdevinst;
    BOOL                                _fHWDevInstInited;

    DWORD*                              _prgMMC2Features;
    BOOL                                _fFirstTime;

    CCritSect                           _cs;

    DEVINST                             _devinst;

    HDEVNOTIFY                          _hdevnotify;
#ifdef DEBUG
    BOOL                                _fGenericReadRequired;
#endif

public: //for now, and for CStorageInfoImpl only
    WCHAR                               _szAutorunIconLocation[MAX_ICONLOCATION];
    WCHAR                               _szAutorunLabel[MAX_LABEL];
};

class CVolumeFillEnum : public CFillEnum
{
public:
    HRESULT Next(LPWSTR pszElemName, DWORD cchElemName, DWORD* pcchRequired);

public:
    HRESULT _Init();

private:
    CIntfFillEnum   _intffillenum;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shsrvice\service.cpp ===
#include "shsrvice.h"

#include "mischlpr.h"

#include "dbg.h"
#include "tfids.h"

#include <strsafe.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

//static
HRESULT CGenericServiceManager::_RegisterServiceCtrlHandler(
    LPCWSTR pszServiceName, SERVICEENTRY* pse)
{
    ASSERT(pse);
    HRESULT hres = E_FAIL;
    TRACE(TF_SERVICE, TEXT("Entered _RegisterServiceCtrlHandler"));

    pse->_ssh = RegisterServiceCtrlHandlerExW(pszServiceName,
        _ServiceHandler, pse);

    if (pse->_ssh)
    {
#ifdef DEBUG
        SHOULDNOTFAIL(SUCCEEDED(StringCchCopy(pse->_szServiceName, ARRAYSIZE(pse->_szServiceName),
            pszServiceName)));
#endif        
        hres = S_OK;
    }
    else
    {
        // convert GetLastError to some HRESULT
    }

    return hres;
}

BOOL CGenericServiceManager::_SetServiceStatus(SERVICEENTRY* pse)
{
#ifdef DEBUG
    WCHAR sz[256];
    
    SHOULDNOTFAIL(SUCCEEDED(StringCchCopy(sz, ARRAYSIZE(sz), pse->_szServiceName)));

    switch (pse->_servicestatus.dwCurrentState)
    {
        case SERVICE_STOPPED:
            SHOULDNOTFAIL(SUCCEEDED(StringCchCat(sz, ARRAYSIZE(sz), TEXT(": SERVICE_STOPPED"))));
            break;
        case SERVICE_START_PENDING:
            SHOULDNOTFAIL(SUCCEEDED(StringCchCat(sz, ARRAYSIZE(sz), TEXT(": SERVICE_START_PENDING"))));
            break;
        case SERVICE_STOP_PENDING:
            SHOULDNOTFAIL(SUCCEEDED(StringCchCat(sz, ARRAYSIZE(sz), TEXT(": SERVICE_STOP_PENDING"))));
            break;
        case SERVICE_RUNNING:
            SHOULDNOTFAIL(SUCCEEDED(StringCchCat(sz, ARRAYSIZE(sz), TEXT(": SERVICE_RUNNING"))));
            break;
        case SERVICE_CONTINUE_PENDING:
            SHOULDNOTFAIL(SUCCEEDED(StringCchCat(sz, ARRAYSIZE(sz), TEXT(": SERVICE_CONTINUE_PENDING"))));
            break;
        case SERVICE_PAUSE_PENDING:
            SHOULDNOTFAIL(SUCCEEDED(StringCchCat(sz, ARRAYSIZE(sz), TEXT(": SERVICE_PAUSE_PENDING"))));
            break;
        case SERVICE_PAUSED:
            SHOULDNOTFAIL(SUCCEEDED(StringCchCat(sz, ARRAYSIZE(sz), TEXT(": SERVICE_PAUSED"))));
            break;
        default:
            SHOULDNOTFAIL(SUCCEEDED(StringCchCat(sz, ARRAYSIZE(sz), TEXT(": Unknown state"))));
            break;
    }

    TRACE(TF_SERVICE, sz);
#endif

    BOOL b = SetServiceStatus(pse->_ssh, &(pse->_servicestatus));

#ifdef DEBUG
    if (!b)
    {
        TRACE(TF_SERVICE, TEXT("SetServiceStatus FAILED: GLE = 0x%08X"), GetLastError());
    }
#endif

    return b;
}

// static
HRESULT CGenericServiceManager::_HandleWantsDeviceEvents(
    LPCWSTR UNREF_PARAM(pszServiceName), BOOL fWantsDeviceEvents)
{
    if (fWantsDeviceEvents)
    {
        TRACE(TF_SERVICE, TEXT("Wants Device Events"));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\vol.cpp ===
#include "vol.h"

#include "hwdev.h"
#include "hnotif.h"
#include "mtpts.h"
#include "regnotif.h"
#include "drvbase.h"
#include "dtctreg.h"
#include "users.h"

//
// ISSUE-2001/01/08-StephStm  that's bad, vol should not depend on dtct...
//
#include "dtct.h"

#include "reg.h"
#include "sfstr.h"
#include "misc.h"

#pragma warning(disable: 4201)
#include <winioctl.h>
#pragma warning(default: 4201)

#include <ntddcdrm.h>
#include <ntddmmc.h>
#include <ioevent.h>
#include <shpriv.h>

#include <setupapi.h>

#include "mischlpr.h"
#include "dbg.h"

#include <strsafe.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

#define STATE_DRIVETYPE                 0x00000001
#define STATE_UPDATECONSTINFO           0x00000002
#define STATE_DEVICENUMBERINFO          0x00000004
#define STATE_DEVICEINST                0x00000008
#define STATE_HWDEVICEINST              0x00000010
#define STATE_MEDIAINFO                 0x00000020
#define STATE_GVIFAILED                 0x10000000
#define STATE_GFAFAILED                 0x20000000
#define STATE_UPDATEHASMEDIAFAILED      0x40000000

#define INVALID_DWORD                   ((DWORD)-1)

#define MPFE_UNDETERMINED               ((DWORD)0x0DEF0DEF)
#define MPFE_FALSE                      ((DWORD)0)
#define MPFE_TRUE                       ((DWORD)1)

///////////////////////////////////////////////////////////////////////////////
// Public
// No need for the critical section, since it will not be added to the
// NamedList until init is finsihed and has succeeded.  Until it's in the
// namedlist, no code can grab a pointer to this object and call it.
HRESULT CVolume::Init(LPCWSTR pszElemName)
{
    HRESULT hres = _cs.Init();

    if (SUCCEEDED(hres))
    {
        hres = _SetName(pszElemName);

        if (SUCCEEDED(hres))
        {
            CImpersonateEveryone* pieo;

            hres = CHWEventDetectorHelper::GetImpersonateEveryone(&pieo);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
                hres = pieo->Impersonate();

                if (SUCCEEDED(hres) && (S_FALSE != hres))
                {
                    hres = _InitHelper(pszElemName);

                    pieo->RevertToSelf();
                }

                pieo->RCRelease();
            }
        }
    }

    return hres;
}

HRESULT _IsDeviceFullyInstalled(LPCWSTR pszDeviceIntfID, BOOL* pfDeviceFullyInstalled)
{
    HRESULT hr = E_FAIL;
    HDEVINFO hdevinfo = SetupDiCreateDeviceInfoList(NULL, NULL);

    *pfDeviceFullyInstalled = FALSE;

    if (INVALID_HANDLE_VALUE != hdevinfo)
    {
        SP_DEVICE_INTERFACE_DATA sdid = {0};

        sdid.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        if (SetupDiOpenDeviceInterface(hdevinfo, pszDeviceIntfID, 0, &sdid))
        {
            DWORD cbsdidd = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                (MAX_DEVICE_ID_LEN * sizeof(WCHAR));

            SP_DEVINFO_DATA sdd = {0};
            SP_DEVICE_INTERFACE_DETAIL_DATA* psdidd =
                (SP_DEVICE_INTERFACE_DETAIL_DATA*)LocalAlloc(LPTR, cbsdidd);

            if (psdidd)
            {
                psdidd->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                sdd.cbSize = sizeof(SP_DEVINFO_DATA);

                // SetupDiGetDeviceInterfaceDetail (below) requires that the
                // cbSize member of SP_DEVICE_INTERFACE_DETAIL_DATA be set
                // to the size of the fixed part of the structure, and to pass
                // the size of the full thing as the 4th param.

                if (SetupDiGetDeviceInterfaceDetail(hdevinfo, &sdid, psdidd,
                    cbsdidd, NULL, &sdd))
                {
                    DWORD dw;

                    if (SetupDiGetDeviceRegistryProperty(hdevinfo, &sdd,
                        SPDRP_INSTALL_STATE, 0, (PBYTE)&dw, sizeof(dw), NULL))
                    {
                        TRACE(TF_VOLUME, TEXT(">>>> Got SPDRP_INSTALL_STATE property: 0x%08X"), dw);

                        if (CM_INSTALL_STATE_INSTALLED == dw)
                        {
                            *pfDeviceFullyInstalled = TRUE;
                        }

                        hr = S_OK;
                    }
                }

                LocalFree((HLOCAL)psdidd);
            }

            SetupDiDeleteDeviceInterfaceData(hdevinfo, &sdid);
        }

        SetupDiDestroyDeviceInfoList(hdevinfo);
    }

    return hr;
}

HRESULT CVolume::_InitHelper(LPCWSTR pszElemName)
{
    BOOL fDeviceFullyInstalled;
    HRESULT hres = _IsDeviceFullyInstalled(_pszElemName, &fDeviceFullyInstalled);

    if (SUCCEEDED(hres))
    {
        if (!fDeviceFullyInstalled)
        {
            TRACE(TF_VOLUME,
                TEXT("!!!!!!!!!!!! Device not fully installed!\n   %s"),
                pszElemName);

            hres = E_FAIL;
        }
        else
        {
            HANDLE hDevice;
            BOOL fCloseHandle = TRUE;

            hres = _GetDeviceHandleSafe(&hDevice, FALSE);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
                hres = _InitDriveType(hDevice);

                if (SUCCEEDED(hres))
                {
                    _dwState |= STATE_DRIVETYPE;

                    hres = S_OK;

                    if ((HWDTS_FIXEDDISK != _dwDriveType) &&
                        (HWDTS_FLOPPY35 != _dwDriveType) &&
                        (HWDTS_FLOPPY525 != _dwDriveType))
                    {
                        _CloseDeviceHandleSafe(hDevice);

                        fCloseHandle = FALSE;

                        // Removable disk drives + CD require access to
                        // the media to query all the required info
                        hres = _GetDeviceHandleSafe(&hDevice, TRUE);
                    }

                    if (SUCCEEDED(hres) && (S_FALSE != hres))
                    {
                        hres = _UpdateConstInfo(hDevice);

                        if (SUCCEEDED(hres))
                        {
                            _dwState |= STATE_UPDATECONSTINFO;
                        }

                        if ((HWDTS_FLOPPY35 != _dwDriveType) &&
                            (HWDTS_FLOPPY525 != _dwDriveType))
                        {
                            if (SUCCEEDED(hres))
                            {
                                fCloseHandle = TRUE;

                                hres = _GetDeviceNumberInfoFromHandle(hDevice,
                                    &_devtype, &_ulDeviceNumber,
                                    &_ulPartitionNumber);

                                if (SUCCEEDED(hres))
                                {
                                    if (S_FALSE != hres)
                                    {
                                        _dwState |= STATE_DEVICENUMBERINFO;
                                    }

                                    GUID guidDummy;

                                    hres = _GetDeviceInstance(pszElemName,
                                        &_devinst, &guidDummy);

                                    if (SUCCEEDED(hres) && (S_FALSE != hres))
                                    {
                                        _dwState |= STATE_DEVICEINST;

                                        hres = _InitHWDeviceInst();

                                        if (SUCCEEDED(hres) && (S_FALSE != hres))
                                        {
                                            hres = _UpdateSoftEjectCaps();

                                            if (SUCCEEDED(hres))
                                            {
                                                hres = _UpdateRemovableDevice();
                                            }
                                        }
                                    }
                                }

                                // We need to do this anyway, even if the
                                // DeviceNumber stuff and/or the deviceInst stuff
                                // fails.  Otherwise we'll have a very sorry volume.
                                if (SUCCEEDED(hres))
                                {
                                    hres = _UpdateMediaInfo(hDevice, FALSE);

                                    if (SUCCEEDED(hres))
                                    {
                                        if (S_FALSE != hres)
                                        {
                                            _dwState |= STATE_MEDIAINFO;
                                        }

                                        hres = _RegisterNotif();
                                    }
                                }
                            }
                        }

                        if (SUCCEEDED(hres))
                        {
                            hres = _CreateMountPoints();
                        }
                    }
                    else
                    {
                        _HandleAccessDenied();
                    }
                }

                if (fCloseHandle)
                {
                    _CloseDeviceHandleSafe(hDevice);
                }
            }
            else
            {
                _HandleAccessDenied();
            }
        }
    }

    return hres;
}

void CVolume::_HandleAccessDenied()
{
    if (ERROR_ACCESS_DENIED == GetLastError())
    {
        _dwVolumeFlags |= HWDVF_STATE_ACCESSDENIED;
    }
}

// *pdwFloppy
//      0: not a floppy
//     35: 3.5" flopy
//    525: 5.25" floppy
HRESULT _DeviceIsFloppy(HANDLE hDevice, DWORD* pdwFloppy, BOOL* pfFloppySupportsSoftEject)
{
    HRESULT hres = S_FALSE;
    DISK_GEOMETRY dg[12] = {0};
    DWORD cbBuf = sizeof(dg);
    DWORD dwReturned;

    *pdwFloppy = 0;
    *pfFloppySupportsSoftEject = FALSE;

    // Should be IOCTL_..._DISK_GEOMETRY...
    if (DeviceIoControl(hDevice, IOCTL_DISK_GET_MEDIA_TYPES,
        NULL, 0, dg, cbBuf, &dwReturned, NULL))
    {
        DWORD cMediaInfo = dwReturned / sizeof(DISK_GEOMETRY);

        for (DWORD dw = 0; !(*pdwFloppy) && (dw < cMediaInfo); ++dw)
        {
            switch (dg[dw].MediaType)
            {
                case F5_1Pt2_512: // Cap: 1200
                case F5_360_512: // Cap: 360
                case F5_320_512: // Cap: 360
                case F5_320_1024: // Cap: 360
                case F5_180_512: // Cap: 360
                case F5_160_512: // Cap: 360
                    *pdwFloppy = 525;
                    break;

                case F3_120M_512:  // Cap: 120MB
                    *pfFloppySupportsSoftEject = TRUE;

                case F3_1Pt44_512: // Cap: 1440
                case F3_2Pt88_512: // Cap: 2880
                case F3_20Pt8_512: // Cap: 2880
                case F3_720_512:  // Cap: 720
                    *pdwFloppy = 35;
                    break;
                //
                // Japanese specific device types from here.
                //
                case F5_1Pt23_1024: // Cap: 1200
                case F5_640_512: // Cap: 260
                case F5_720_512: // Cap: 360
                    *pdwFloppy = 525;
                    break;

                case F3_640_512: // Cap: 720
                case F3_1Pt2_512: // Cap: 1440 
                case F3_1Pt23_1024: // Cap: 1440
                    *pdwFloppy = 35;
                    break;

                case F3_128Mb_512: // Cap: ?
                case F3_230Mb_512: // Cap: ?
                case F3_200Mb_512:
                    *pdwFloppy = 35;
                    break;
            }

            if (*pdwFloppy)
            {
                hres = S_OK;
            }
        }
    }

    return hres;
}

HRESULT _GetDriveTypeInfo(HANDLE hDevice, DWORD* pdwDriveType, BOOL* pfFloppy);

HRESULT CVolume::_InitDriveType(HANDLE hDevice)
{
    BOOL fFloppy = FALSE;

    HRESULT hr = _GetDriveTypeInfo(hDevice, &_dwDriveType, &fFloppy);

    if (SUCCEEDED(hr))
    {
        if (fFloppy)
        {
            DWORD dwFloppy;
            BOOL fFloppySupportsSoftEject;

            hr = _DeviceIsFloppy(hDevice, &dwFloppy, &fFloppySupportsSoftEject);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                if (fFloppySupportsSoftEject)
                {
                    _dwDriveCap |= HWDDC_FLOPPYSOFTEJECT;
                }

                switch (dwFloppy)
                {
                    case 35:
                        _dwDriveType = HWDTS_FLOPPY35;
                        break;
                    case 525:
                        _dwDriveType = HWDTS_FLOPPY525;
                }
            }
        }
    }

    return hr;
}

HRESULT _GetRemovableDeviceInstRecurs(DEVINST devinst,
    DEVINST* pdevinst)
{
    BOOL fRemovable;
    HRESULT hres = _DeviceInstIsRemovable(devinst, &fRemovable);

    if (SUCCEEDED(hres))
    {
        if (fRemovable)
        {
            // Found it!
            *pdevinst = devinst;
        }
        else
        {
            // Recurse
            DEVINST devinstParent;

            CONFIGRET cr = CM_Get_Parent_Ex(&devinstParent, devinst, 0,
                NULL);

            if (CR_SUCCESS == cr)
            {
                hres = _GetRemovableDeviceInstRecurs(devinstParent, pdevinst);
            }
            else
            {
                hres = S_FALSE;
            }
        }
    }

    return hres;
}

HRESULT CVolume::_GetDeviceIDDisk(LPWSTR pszDeviceIDDisk,
    DWORD cchDeviceIDDisk)
{
    HRESULT hr;

    _cs.Enter();

    if (_szDeviceIDDisk[0])
    {
        hr = SafeStrCpyN(pszDeviceIDDisk, _szDeviceIDDisk, cchDeviceIDDisk);
    }
    else
    {
        if (((ULONG)-1) != _ulDeviceNumber)
        {
            CNamedElemList* pnel;
            hr = CHWEventDetectorHelper::GetList(HWEDLIST_DISK, &pnel);

            if (S_OK == hr)
            {
                CNamedElemEnum* penum;

                hr = pnel->GetEnum(&penum);

                if (SUCCEEDED(hr))
                {
                    CNamedElem* pelem;
                    BOOL fFoundIt = FALSE;

                    while (!fFoundIt && SUCCEEDED(hr = penum->Next(&pelem)) &&
                        (S_FALSE != hr))
                    {
                        CDisk* pdisk = (CDisk*)pelem;
                        ULONG ulDeviceNumber;

                        hr = pdisk->GetDeviceNumber(&ulDeviceNumber);

                        if (SUCCEEDED(hr) && (S_FALSE != hr))
                        {
                            if (_ulDeviceNumber == ulDeviceNumber)
                            {
                                DEVICE_TYPE devtype;

                                hr = pdisk->GetDeviceType(&devtype);

                                if (SUCCEEDED(hr) && (S_FALSE != hr))
                                {
                                    if (_devtype == devtype)
                                    {
                                        // Use me!
                                        DWORD cchReq;

                                        hr = pelem->GetName(pszDeviceIDDisk,
                                            cchDeviceIDDisk, &cchReq);

                                        fFoundIt = TRUE;
                                    }
                                }
                            }
                        }

                        pelem->RCRelease();
                    }

                    penum->RCRelease();
                }

                pnel->RCRelease();
            }
        }
        else
        {
            hr = S_FALSE;
        }

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            if (FAILED(SafeStrCpyN(_szDeviceIDDisk, pszDeviceIDDisk,
                ARRAYSIZE(_szDeviceIDDisk))))
            {
                _szDeviceIDDisk[0] = 0;
            }
        }
    }

    _cs.Leave();

    return hr;
}

HRESULT CVolume::_InitHWDeviceInst()
{
    WCHAR szDeviceIDDisk[MAX_DEVICEID];

    HRESULT hr = _GetDeviceIDDisk(szDeviceIDDisk, ARRAYSIZE(szDeviceIDDisk));

    if (SUCCEEDED(hr))
    {
        DEVINST devinstFinal = 0;
        GUID guidDummy;

        if (S_FALSE != hr)
        {
            DEVINST devinstDisk;

            hr = _GetDeviceInstance(szDeviceIDDisk, &devinstDisk, &guidDummy);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                hr = _GetRemovableDeviceInstRecurs(devinstDisk, &devinstFinal);

                if (SUCCEEDED(hr))
                {
                    if (S_FALSE == hr)
                    {
                        // Maybe this is not a removable device (not talking
                        // about removable disk).
                        BOOL fFoundProp;
                        WCHAR szProp[1];
                        ULONG ulData = sizeof(szProp);

                        // First check if the disk interface has customn properties associated with it.
                        CONFIGRET cr = CM_Get_DevNode_Custom_Property(devinstDisk, TEXT("DeviceGroup"),
                            NULL, (PBYTE)szProp, &ulData, 0);

                        if ((CR_SUCCESS == cr) || (CR_BUFFER_SMALL == cr))
                        {
                            fFoundProp = TRUE;
                        }
                        else
                        {
                            ulData = sizeof(szProp);
                            cr = CM_Get_DevNode_Custom_Property(devinstDisk, TEXT("Icons"),
                                NULL, (PBYTE)szProp, &ulData, 0);

                            if ((CR_SUCCESS == cr) || (CR_BUFFER_SMALL == cr))
                            {
                                fFoundProp = TRUE;
                            }
                            else
                            {
                                fFoundProp = FALSE;
                            }
                        }

                        if (fFoundProp)
                        {
                            devinstFinal = devinstDisk;
                            hr = S_OK;
                        }
                        else
                        {
                            // Let's get the parent devinst of this devinst.
                            if (CR_SUCCESS == CM_Get_Parent_Ex(&devinstFinal,
                                devinstDisk, 0, NULL))
                            {
                                hr = S_OK;
                                DIAGNOSTIC((TEXT("[0303]Got DeviceInst from parent of disk")));

                                TRACE(TF_VOLUME,
                                    TEXT("HWDevInst: Got devinst from parent of Disk for Disk\n    %s"),
                                    _pszElemName);
                            }
                        }
                    }
                    else
                    {
                        DIAGNOSTIC((TEXT("[0302]Got DeviceInst from Removable Device")));

                        TRACE(TF_VOLUME,
                            TEXT("HWDevInst: Got devinst from Removable Device for Volume\n    %s"),
                            _pszElemName);
                    }
                }
            }
            else
            {
                DIAGNOSTIC((TEXT("[0304]Did NOT get DeviceInst from the disk")));

                TRACE(TF_VOLUME,
                    TEXT("HWDevInst: Did not get a devinst from the Disk for Volume\n    %s"),
                    _pszElemName);
            }
        }
        else
        {
            DIAGNOSTIC((TEXT("[0305]Got DeviceInst from Volume itself")));

            TRACE(TF_VOLUME,
                TEXT("HWDevInst: Did not get a Disk, get devinst from Volume itself for Volume\n    (%s)"),
                _pszElemName);

            // We did not get a device number for the volume
            // Let's get the device instance from the volume then, maybe there's no
            // volume-disk-device hierarchy
            hr = _GetDeviceInstance(_pszElemName, &devinstFinal, &guidDummy);
        }

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = _hwdevinst.Init(devinstFinal);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                hr = _hwdevinst.InitInterfaceGUID(&guidVolumeClass);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    _fHWDevInstInited = TRUE;
                }
            }
        }
    }

    return hr;
}

HRESULT CVolume::GetHWDeviceInst(CHWDeviceInst** pphwdevinst)
{
    HRESULT hr;

    if (_fHWDevInstInited)
    {
        *pphwdevinst = &_hwdevinst;
        hr = S_OK;
    }
    else
    {
        *pphwdevinst = NULL;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CVolume::_ShouldTryAutoplay(BOOL* pfTry)
{
    HRESULT hr;

    if (_dwMediaState & HWDMS_PRESENT)
    {
        if (_dwMediaState & HWDMS_FORMATTED)
        {
            if (!(_dwMediaCap & HWDMC_HASDVDMOVIE))
            {
                if (!(_dwMediaCap & HWDMC_HASAUTORUNINF) ||
                    (_dwMediaCap & HWDMC_HASUSEAUTOPLAY))
                {
                    WCHAR szVolumeGUID[MAX_PATH + 50];
                    LPWSTR pszFile;

                    if (_dwMediaCap & HWDMC_HASUSEAUTOPLAY)
                    {
                        DIAGNOSTIC((TEXT("[0316]Autorun.inf, BUT as a UseAutoPLAY entry -> try Autoplay!")));
                    }

                    hr = SafeStrCpyN(szVolumeGUID, _szVolumeGUID,
                        ARRAYSIZE(szVolumeGUID));

                    *pfTry = TRUE;

                    if (SUCCEEDED(hr))
                    {
                        HKEY hkey;
                        pszFile = szVolumeGUID + lstrlen(szVolumeGUID);

                        TRACE(TF_LEAK, TEXT("Special files - BEGIN"));

                        hr = _RegOpenKey(HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoplayHandlers\\CancelAutoplay\\Files"),
                            &hkey);

                        if (SUCCEEDED(hr) && (S_FALSE != hr))
                        {
                            DWORD dwIndex = 0;

                            while ((*pfTry) && SUCCEEDED(hr = _RegEnumStringValue(hkey, dwIndex, pszFile,
                                (DWORD)(ARRAYSIZE(szVolumeGUID) - (pszFile - szVolumeGUID)))) &&
                                (S_FALSE != hr))
                            {
                                WIN32_FIND_DATA w32fd;
                                HANDLE h;

                                h = FindFirstFile(szVolumeGUID, &w32fd);

                                if (INVALID_HANDLE_VALUE != h)
                                {
                                    FindClose(h);

                                    *pfTry = FALSE;

                                    DIAGNOSTIC((TEXT("[0307]Detected special file : '%s' (%s) -> No Autoplay!"),
                                        w32fd.cFileName, pszFile));

                                    TRACE(TF_VOLUME,
                                        TEXT("Detected %s (%s) -> No Autoplay!"),
                                        w32fd.cFileName , pszFile);
                                }
                                
                                ++dwIndex;
                            }

                            _RegCloseKey(hkey);
                        }

                        TRACE(TF_LEAK, TEXT("Special files - END"));
                    }
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0313]Autorun.inf -> No Content Autoplay!")));
                    hr = S_OK;
                    *pfTry = FALSE;
                }
            }
            else
            {
                DIAGNOSTIC((TEXT("[0312]DVD Movie -> No Content Autoplay!")));
                hr = S_OK;
                *pfTry = FALSE;
            }
        }
        else
        {
            DIAGNOSTIC((TEXT("[0317]Media *NOT* formatted -> No Content Autoplay!")));
            hr = S_OK;
            *pfTry = FALSE;
        }
    }
    else
    {
        DIAGNOSTIC((TEXT("[0306]NO media -> No Content Autoplay!")));
        hr = S_OK;
        *pfTry = FALSE;
    }

    return hr;
}

HRESULT CVolume::_HandleMediaArrival()
{
    DIAGNOSTIC((TEXT("[0002]Processing Media Arrival Event: %s"), _pszElemName));

    _dwMediaPresentFromEvent = MPFE_TRUE;
    
    _cs.Enter();

    HRESULT hr = _UpdateMediaInfo(INVALID_HANDLE_VALUE, TRUE);

    _cs.Leave();

    if (SUCCEEDED(hr))
    {
        if (_fHWDevInstInited)
        {
            // Try Autoplay?
            BOOL fTryAutoplay;

            hr = _ShouldTryAutoplay(&fTryAutoplay);

            if (SUCCEEDED(hr))
            {
                if (fTryAutoplay)
                {
                    BOOL fHasHandler;

                    hr = CHWEventDetectorImpl::HandleVolumeMediaEvent(
                        _pszElemName, &_hwdevinst, TEXT("MediaArrival"),
                        &fHasHandler);

                    if (SUCCEEDED(hr) && fHasHandler)
                    {
                        _dwVolumeFlags |= HWDVF_STATE_HASAUTOPLAYHANDLER;
                    }
                }
                else
                {
                    _dwVolumeFlags |= HWDVF_STATE_DONOTSNIFFCONTENT;
                }
            }
        }
        else
        {
            DIAGNOSTIC((TEXT("[0308]Cannot find hardware device for this volume -> No Autoplay!")));
        }

        if (SUCCEEDED(hr))
        {
            _AdviseVolumeChangeHelper(FALSE);
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CVolume::_AdviseVolumeMountingEvent(DWORD dwEvent)
{
    return CHardwareDevicesImpl::_AdviseVolumeMountingEvent(_pszElemName,
        dwEvent);
}

HRESULT CVolume::_AdviseVolumeChangeHelper(BOOL fAdded)
{
    HRESULT hr;
    VOLUMEINFO2* pvolinfo2;

    _cs.Enter();

    hr = _GetVOLUMEINFO2(&pvolinfo2);

    _cs.Leave();

    if (SUCCEEDED(hr))
    {
        LPWSTR pszMtPts;
        DWORD cchMtPts;
        hr = _GetMountPoints(&pszMtPts, &cchMtPts);

        if (SUCCEEDED(hr))
        {
            CHardwareDevicesImpl::_AdviseVolumeArrivedOrUpdated(pvolinfo2,
                pszMtPts, cchMtPts, fAdded);

            if (S_FALSE != hr)
            {
                LocalFree((HLOCAL)pszMtPts);
            }
        }

        _FreeMemoryChunk<VOLUMEINFO2*>(pvolinfo2);
    }

    return hr;
}

HRESULT CVolume::_HandleMediaRemoval()
{
    HRESULT hr;

    DIAGNOSTIC((TEXT("[0003]Processing Media Removal Event: %s"), _pszElemName));

    _dwMediaPresentFromEvent = MPFE_FALSE;

    _cs.Enter();

    hr = _UpdateMediaInfoOnRemove();

    _cs.Leave();

    if (SUCCEEDED(hr))
    {
        _AdviseVolumeChangeHelper(FALSE);

        if (_fHWDevInstInited)
        {
            // Useless in this case, since there's no content, so we won't sniff
            BOOL fHasHandler;

            hr = CHWEventDetectorImpl::HandleVolumeMediaEvent(_pszElemName,
                &_hwdevinst, TEXT("MediaRemoval"), &fHasHandler);
        }
        else
        {
            DIAGNOSTIC((TEXT("[0309]Cannot find hardware device for this volume -> No Autoplay!")));
        }
    }

    return hr;
}

HRESULT CVolume::_HandleVolumeChange()
{
    HRESULT hr;

    _cs.Enter();

    hr = _UpdateMediaInfo(INVALID_HANDLE_VALUE, TRUE);

    _cs.Leave();

    if (SUCCEEDED(hr))
    {
        _AdviseVolumeChangeHelper(FALSE);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CVolume::HNTHandleEvent(DEV_BROADCAST_HANDLE* pdbh,
    DWORD dwEventType)
{
    HRESULT hres = S_OK;

    if (DBT_CUSTOMEVENT == dwEventType)
    {
        if (GUID_IO_MEDIA_ARRIVAL == pdbh->dbch_eventguid)
        {
            // This notification arrive very soon when the media is inserted
            // in the device.  Often the Volume driver has not been loaded on
            // the drive and calls like GetVolumeInformation will fail.
            // Instead of doing something right now, flag the event, and
            // process on the first GUID_IO_VOLUME_MOUNT below.
            TRACE(TF_SHHWDTCTDTCT,
                TEXT("****CVolume GUID_IO_MEDIA_ARRIVAL"));

            hres = _HandleMediaArrival();
        }
        else if (GUID_IO_MEDIA_REMOVAL == pdbh->dbch_eventguid)
        {
            TRACE(TF_SHHWDTCTDTCT,
                TEXT("****CVolume GUID_IO_MEDIA_REMOVAL"));

            hres = _HandleMediaRemoval();
        }
        else if (GUID_IO_VOLUME_MOUNT == pdbh->dbch_eventguid)
        {
            TRACE(TF_SHHWDTCTDTCT,
                TEXT("****CVolume GUID_IO_VOLUME_MOUNT"));

            if (_dwVolumeFlags & HWDVF_STATE_DISMOUNTED)
            {
                _dwVolumeFlags &= ~HWDVF_STATE_DISMOUNTED;

                hres = _AdviseVolumeMountingEvent(
                    SHHARDWAREEVENT_VOLUMEMOUNTED);

                _HandleVolumeChange();
            }
        }
        else if (GUID_IO_VOLUME_NAME_CHANGE == pdbh->dbch_eventguid)
        {
            TRACE(TF_SHHWDTCTDTCT,
                TEXT("****CVolume GUID_IO_VOLUME_NAME_CHANGE"));

            _cs.Enter();

            hres = _UpdateMountPoints();

            _cs.Leave();
        }
        else if (GUID_IO_VOLUME_CHANGE == pdbh->dbch_eventguid)
        {
            TRACE(TF_SHHWDTCTDTCT,
                TEXT("****CVolume GUID_IO_VOLUME_CHANGE"));

            _cs.Enter();

            // This is for bug 645878.  Basically, it's to cover the case of a
            // volume mounted on another volume's folder and then transfered
            // to another clustered machine.  We use to miss the volume
            // mounted on the folder.  Even thought the right event to send
            // would have been GUID_IO_VOLUME_NAME_CHANGE, it swas not
            // possible unless the cluster guys would have unmounted the volume
            // from the folder and remounted it, which is overkill just for an
            // icon.
            hres = _UpdateMountPoints();

            _cs.Leave();

            hres = _HandleVolumeChange();
        }
        else if (GUID_IO_VOLUME_DISMOUNT == pdbh->dbch_eventguid)
        {
            _dwVolumeFlags |= HWDVF_STATE_DISMOUNTED;

            hres = _AdviseVolumeMountingEvent(
                SHHARDWAREEVENT_VOLUMEDISMOUNTED);
        }
        else if (GUID_IO_VOLUME_DISMOUNT_FAILED == pdbh->dbch_eventguid)
        {
            _dwVolumeFlags &= ~HWDVF_STATE_DISMOUNTED;

            hres = _AdviseVolumeMountingEvent(
                SHHARDWAREEVENT_VOLUMEMOUNTED);
        }
    }

    return hres;
}

HRESULT CVolume::_GetDeviceHandleSafe(HANDLE* phDevice,
    BOOL fGenericReadRequired)
{
    ASSERT(!_hdevnotify);
    HRESULT hr;
    HANDLE hDevice = _GetDeviceHandle(_pszElemName,
        fGenericReadRequired ? GENERIC_READ : FILE_READ_ATTRIBUTES);

    *phDevice = INVALID_HANDLE_VALUE;

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        DEV_BROADCAST_HANDLE dbhNotifFilter = {0};

        dbhNotifFilter.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
        dbhNotifFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
        dbhNotifFilter.dbch_handle = hDevice;

        hr = CHWEventDetectorHelper::RegisterDeviceNotification(
                &dbhNotifFilter, &_hdevnotify, FALSE);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            *phDevice = hDevice;

#ifdef DEBUG
            _fGenericReadRequired = fGenericReadRequired;
#endif
        }
        else
        {
            _CloseDeviceHandle(hDevice);
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CVolume::_CloseDeviceHandleSafe(HANDLE hDevice)
{
    ASSERT(_hdevnotify);

    _CloseDeviceHandle(hDevice);
    UnregisterDeviceNotification(_hdevnotify);

    _hdevnotify = NULL;

    return S_OK;
}

HRESULT CVolume::_UnregisterNotif()
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_HANDLENOTIF,
        &pnel);

    if (S_OK == hres)
    {
        hres = pnel->Remove(_pszElemName);

        if (_szDeviceIDDisk[0])
        {
            hres = pnel->Remove(_szDeviceIDDisk);
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT CVolume::_RegisterNotif()
{
    CNamedElemList* pnel;

    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_HANDLENOTIF,
        &pnel);

    if (S_OK == hres)
    {
        CNamedElem* pelem;

        // register for handle notification
        hres = pnel->GetOrAdd(_pszElemName, &pelem);

        // Was it already there or added?
        if (SUCCEEDED(hres) && (S_FALSE == hres))
        {
            // Added.  Initialize it.
            CHandleNotif* phnotif = (CHandleNotif*)pelem;

            hres = phnotif->InitNotif(this);

            if (SUCCEEDED(hres))
            {
                if (HWDTS_REMOVABLEDISK == _dwDriveType)
                {
                    // Removable disk drives receive their notifications for
                    // media arrival/removal on the disk interface, not the
                    // volume one, so register for this too.
                    WCHAR szDeviceIDDisk[MAX_DEVICEID];

                    hres = _GetDeviceIDDisk(szDeviceIDDisk,
                        ARRAYSIZE(szDeviceIDDisk));

                    if (SUCCEEDED(hres) && (S_FALSE != hres)) 
                    {
                        CNamedElem* pelem2;

                        // register for handle notification
                        hres = pnel->GetOrAdd(szDeviceIDDisk, &pelem2);

                        // Was it already there or added?
                        if (SUCCEEDED(hres) && (S_FALSE == hres))
                        {
                            // Added.  Initialize it.
                            CHandleNotif* phnotif2 = (CHandleNotif*)pelem2;

                            hres = phnotif2->InitNotif(this);

                            if (FAILED(hres))
                            {
                                pnel->Remove(szDeviceIDDisk);
                            }

                            pelem2->RCRelease();
                        }
                    }
                }
            }

            if (FAILED(hres))
            {
                pnel->Remove(_pszElemName);
            }

            pelem->RCRelease();
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT CVolume::_RemoveMtPt(LPWSTR pszMtPt)
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_MTPT, &pnel);
    
    if (S_OK == hr)
    {
        hr = pnel->Remove(pszMtPt);

        pnel->RCRelease();
    }

    return hr;
}

HRESULT CVolume::_CreateMtPt(LPWSTR pszMtPt)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_MTPT, &pnel);
    
    if (S_OK == hres)
    {
        CNamedElem* pelem;
        hres = pnel->GetOrAdd(pszMtPt, &pelem);

        if (SUCCEEDED(hres))
        {
            // Init one way or the other
            CMtPt* pmtpt = (CMtPt*)pelem;

            hres = pmtpt->InitVolume(_pszElemName);

            if (FAILED(hres))
            {
                pnel->Remove(pszMtPt);
            }

            pelem->RCRelease();
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT CVolume::_AdviseMountPointHelper(LPCWSTR pszMountPoint, BOOL fAdded)
{
    // I'd like to not call this from outside the crit sect
    ASSERT(_cs.IsInside());

    WCHAR szDeviceIDVolume[MAX_DEVICEID];
    DWORD cchReq;

    HRESULT hr = GetName(szDeviceIDVolume, ARRAYSIZE(szDeviceIDVolume), &cchReq);

    if (SUCCEEDED(hr))
    {
        CHardwareDevicesImpl::_AdviseMountPointHelper(pszMountPoint,
            szDeviceIDVolume, fAdded);                
    }

    return hr;
}

HRESULT CVolume::_UpdateMountPoints()
{
    LPWSTR pszMtPtNew;
    DWORD cchMtPtNew;
    HRESULT hr = _GetMountPoints(&pszMtPtNew, &cchMtPtNew);

#ifdef DEBUG
    if (_pszMountPoints)
    {
        TRACE(TF_VOLUME, TEXT("_UpdateMountPoints: OLD mountPoints for %s:"), _pszElemName);

        for (LPWSTR psz = _pszMountPoints; *psz; psz += lstrlen(psz) + 1)
        {
            TRACE(TF_VOLUME, TEXT("    %s"), psz);
        }
    }
#endif

    if (SUCCEEDED(hr))
    {
        if (S_FALSE != hr)
        {
#ifdef DEBUG
            TRACE(TF_VOLUME, TEXT("_UpdateMountPoints: NEW mountPoints:"));

            for (LPWSTR psz = pszMtPtNew; *psz; psz += lstrlen(psz) + 1)
            {
                TRACE(TF_VOLUME, TEXT("    %s"), psz);
            }
#endif
            // Was there at least one?
            if (_pszMountPoints)
            {
                // Yep, find the removed ones
                for (LPWSTR pszOld = _pszMountPoints; *pszOld;
                    pszOld += lstrlen(pszOld) + 1)
                {
                    BOOL fFoundInNew = FALSE;

                    for (LPWSTR pszNew = pszMtPtNew; !fFoundInNew && *pszNew;
                        pszNew += lstrlen(pszNew) + 1)
                    {
                        if (!lstrcmpi(pszNew, pszOld))
                        {
                            fFoundInNew = TRUE;
                        }
                    }

                    if (!fFoundInNew)
                    {
                        TRACE(TF_VOLUME, TEXT("_UpdateMountPoints: Found DELETED one: %s"), pszOld);

                        // That's a deleted one
                        _RemoveMtPt(pszOld);

                        _AdviseMountPointHelper(pszOld, FALSE);
                    }
                }
            }
            else
            {
                TRACE(TF_VOLUME, TEXT("_UpdateMountPoints: There was NO mountpoints before"));
            }

            // Find the new ones
            for (LPWSTR pszNew = pszMtPtNew; *pszNew;
                pszNew += lstrlen(pszNew) + 1)
            {
                BOOL fFoundInOld = FALSE;

                if (_pszMountPoints)
                {
                    for (LPWSTR pszOld = _pszMountPoints;
                        !fFoundInOld && *pszOld; pszOld += lstrlen(pszOld) + 1)
                    {
                        if (!lstrcmpi(pszNew, pszOld))
                        {
                            fFoundInOld = TRUE;
                        }
                    }
                }

                if (!fFoundInOld)
                {
                    TRACE(TF_VOLUME, TEXT("_UpdateMountPoints: Found ADDED one: %s"), pszNew);

                    // That's a new one
                    _CreateMtPt(pszNew);

                    _AdviseMountPointHelper(pszNew, TRUE);
                }
            }

            LocalFree(_pszMountPoints);
            _pszMountPoints = pszMtPtNew;
            _cchMountPoints = cchMtPtNew;
        }
        else
        {
            TRACE(TF_VOLUME, TEXT("_UpdateMountPoints: NO MountPoints left, remove all old ones"));

            if (_pszMountPoints && *_pszMountPoints)
            {
                for (LPWSTR pszOld = _pszMountPoints; *pszOld;
                    pszOld += lstrlen(pszOld) + 1)
                {
                    _RemoveMtPt(pszOld);

                    _AdviseMountPointHelper(pszOld, FALSE);
                }

                LocalFree(_pszMountPoints);
                _pszMountPoints = NULL;
                _cchMountPoints = 0;
            }
        }
    }

    return hr;
}

HRESULT CVolume::_CreateMountPoints()
{
    HRESULT hr = _GetMountPoints(&_pszMountPoints, &_cchMountPoints);

    if (SUCCEEDED(hr))
    {
        if (S_FALSE != hr)
        {
            for (LPWSTR psz = _pszMountPoints; *psz;
                psz += lstrlen(psz) + 1)
            {
                _CreateMtPt(psz);
                // go on even if error
            }
        }
        else
        {
            hr = S_OK;
        }
    }

    return hr;
}

// Caller must free returned data using LocalFree
HRESULT CVolume::_GetMountPoints(LPWSTR* ppsz, DWORD* pcch)
{
    HRESULT hr;
    LPWSTR psz = NULL;
    DWORD cch;

    *ppsz = NULL;
    *pcch = 0;

    if (GetVolumePathNamesForVolumeName(_szVolumeGUID, NULL, 0, &cch))
    {
        // no mountpoint, we're done
        hr = S_FALSE; 
    }
    else
    {
        // Expected, even wanted...
        if (ERROR_MORE_DATA == GetLastError())
        {
            psz = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));

            if (psz)
            {
                if (GetVolumePathNamesForVolumeName(_szVolumeGUID,
                    psz, cch, &cch))
                {
                    *ppsz = psz;
                    *pcch = cch;
                    hr = S_OK;
                }
                else
                {
                    LocalFree(psz);
                    hr = S_FALSE; 
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = S_FALSE; 
        }
    }

    return hr;
}

HRESULT _DeviceMediaIsAccessible(HANDLE hDevice, BOOL* pfAccessible)
{
    HRESULT hres = S_FALSE;
    DWORD dwDummy;

    *pfAccessible = FALSE;

    // requires GENERIC_READ access on the handle
    BOOL b = DeviceIoControl(hDevice, IOCTL_STORAGE_CHECK_VERIFY, NULL, 0, NULL, 0, &dwDummy, NULL);
    if (ERROR_MEDIA_CHANGED == GetLastError())
    {
        // try one more time, ERROR_MEDIA_CHANGED means it's still pending for a little bit.
        b = DeviceIoControl(hDevice, IOCTL_STORAGE_CHECK_VERIFY, NULL, 0, NULL, 0, &dwDummy, NULL);
    }

    if (b)
    {
        *pfAccessible = TRUE;
        hres = S_OK;
    }
    else
    {
        // ERROR_NOT_READY == GetLastError() means no media
        if (ERROR_NOT_READY == GetLastError())
        {
            hres = S_OK;
        }
        else
        {
            hres = S_FALSE;
        }
    }

    return hres;
}

HRESULT CVolume::_UpdateHasMedia(HANDLE hDevice)
{
    HRESULT hr = S_FALSE;

    switch (_dwDriveType)
    {
        case HWDTS_FIXEDDISK:
            _dwMediaState |= HWDMS_PRESENT;
            hr = S_OK;
            break;

        case HWDTS_REMOVABLEDISK:
        case HWDTS_CDROM:
        {
#if 0
 This does not work on my laptop
            if (_dwDriveCap & HWDDC_CAPABILITY_SUPPORTDETECTION)
            {
                // It's MMC2
                if (_dwMediaCap & (HWDMC_CDROM | HWDMC_CDRECORDABLE |
                    HWDMC_CDREWRITABLE | HWDMC_DVDROM | HWDMC_DVDRECORDABLE |
                    HWDMC_DVDRAM))
                {
                    _dwMediaState |= HWDMS_PRESENT;
                }
                else
                {
                    _dwMediaState &= ~HWDMS_PRESENT;
                }
            }
            else
#endif
            if (MPFE_UNDETERMINED != _dwMediaPresentFromEvent)
            {
                hr = S_OK;

                if (MPFE_TRUE == _dwMediaPresentFromEvent)
                {
                    _dwMediaState |= HWDMS_PRESENT;
                }
                else
                {
                    _dwMediaState &= ~HWDMS_PRESENT;
                }
            }
            else
            {
                BOOL fAccessible;

                ASSERT(_fGenericReadRequired);

                hr = _DeviceMediaIsAccessible(hDevice, &fAccessible);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    if (fAccessible)
                    {
                        _dwMediaState |= HWDMS_PRESENT;
                    }
                    else
                    {
                        _dwMediaState &= ~HWDMS_PRESENT;
                    }
                }
                else
                {
                    _dwMediaState &= ~HWDMS_PRESENT;
                }
            }

            break;
        }

        default:
        // ISSUE-2000/10/23-StephStm: We do not handle CD Changer, maybe we should            
        //
        // case HWDTS_CDCHANGER:
        case HWDTS_FLOPPY35:
        case HWDTS_FLOPPY525:
            _dwMediaState &= ~HWDMS_PRESENT;
            break;
    }

    return hr;
}

HRESULT CVolume::_ExtractAutorunIconAndLabel()
{
    WCHAR szInfFile[MAX_PATH + 50];
    LPWSTR pszNext;
    DWORD cchLeft;

    HRESULT hr = SafeStrCpyNEx(szInfFile, _szVolumeGUID, ARRAYSIZE(szInfFile),
        &pszNext, &cchLeft);

    if (SUCCEEDED(hr))
    {
        hr = SafeStrCpyN(pszNext, TEXT("Autorun.inf"), cchLeft);

        if (SUCCEEDED(hr))
        {
            WCHAR szDummy[4];
#if defined(_X86_)
            LPWSTR pszSection = TEXT("AutoRun.x86");
#elif defined(_AMD64_)
            LPWSTR pszSection = TEXT("AutoRun.Amd64");
#elif defined(_IA64_)
            LPWSTR pszSection = TEXT("AutoRun.Ia64");
#else
#error "No Target Architecture"
#endif

            // Flush some buffer somewhere
            WritePrivateProfileString(NULL, NULL, NULL, szInfFile);

            if (!GetPrivateProfileString(pszSection, TEXT("Icon"), TEXT(""),
                _szAutorunIconLocation, ARRAYSIZE(_szAutorunIconLocation),
                szInfFile))
            {
                pszSection = TEXT("AutoRun");

                _HandleAccessDenied();

                if (!GetPrivateProfileString(pszSection, TEXT("Icon"),
                    TEXT(""), _szAutorunIconLocation,
                    ARRAYSIZE(_szAutorunIconLocation), szInfFile))
                {
                    _szAutorunIconLocation[0] = 0;
                    _HandleAccessDenied();
                }
            }

            if (!GetPrivateProfileString(pszSection, TEXT("Label"), TEXT(""),
                _szAutorunLabel, ARRAYSIZE(_szAutorunLabel), szInfFile))
            {
                _szAutorunLabel[0] = 0;
                _HandleAccessDenied();
            }

            if (GetPrivateProfileString(pszSection, TEXT("Open"), TEXT(""),
                szDummy, ARRAYSIZE(szDummy), szInfFile) ||
                GetPrivateProfileString(pszSection, TEXT("ShellExecute"), TEXT(""),
                szDummy, ARRAYSIZE(szDummy), szInfFile))
            {
                _dwMediaCap |= HWDMC_HASAUTORUNCOMMAND;
            }
            else
            {
                _HandleAccessDenied();
            }

            if (GetPrivateProfileString(pszSection, TEXT("UseAutoPLAY"), TEXT(""),
                szDummy, ARRAYSIZE(szDummy), szInfFile))
            {
                _dwMediaCap |= HWDMC_HASUSEAUTOPLAY;
            }
            else
            {
                _HandleAccessDenied();
            }
        }
    }

    return hr;
}

HRESULT CVolume::_UpdateSpecialFilePresence()
{
    struct SPECIALFILEINFO
    {
        LPCWSTR     pszFile;
        DWORD       dwCapBit;
    };

    HRESULT hr;
    WCHAR szPath[50 + 1 + ARRAYSIZE(TEXT("video_ts\\video_ts.ifo"))];

    static const SPECIALFILEINFO rgsfi[] =
    {
        { TEXT("autorun.inf"), HWDMC_HASAUTORUNINF }, 
        { TEXT("desktop.ini"), HWDMC_HASDESKTOPINI }, 
        { TEXT("video_ts\\video_ts.ifo"), HWDMC_HASDVDMOVIE }, 
    };

    LPWSTR pszNext;
    DWORD cchLeft;

    hr = SafeStrCpyNEx(szPath, _szVolumeGUID,
        ARRAYSIZE(szPath), &pszNext, &cchLeft);

    if (SUCCEEDED(hr))
    {
        for (DWORD dw = 0; dw < ARRAYSIZE(rgsfi); ++dw)
        {
            hr = SafeStrCpyN(pszNext, rgsfi[dw].pszFile, cchLeft);

            if (SUCCEEDED(hr))
            {
                DWORD dwGFA = GetFileAttributes(szPath);
        
                if (-1 != dwGFA)
                {
                    _dwMediaCap |= (rgsfi[dw].dwCapBit);
                }
                else
                {
                    _HandleAccessDenied();
                }
            }
        }
    }
    
    // To fix bug 425431
    if (HWDMC_HASDVDMOVIE & _dwMediaCap)
    {
        // This better be a CD/DVD drive.
        if (HWDTS_CDROM != _dwDriveType)
        {
            // No.  Remove the flag otherwise, Hard Disks get a Play verb
            // when they have the ts_video\video_ts.ifo file in their root.
            _dwMediaCap &= ~HWDMC_HASDVDMOVIE;
        }
    }

    return hr;
}

#define TRACK_TYPE_MASK 0x04
#define AUDIO_TRACK     0x00
#define DATA_TRACK      0x04

HRESULT CVolume::_UpdateTrackInfo(HANDLE hDevice)
{
    HRESULT hr;

    ASSERT(!(_dwMediaCap & (HWDMC_HASDATATRACKS | HWDMC_HASAUDIOTRACKS)));

    hr = S_OK;
    // To be compatible with Win95, we'll only return TRUE from this
    // function if the disc has ONLY audio tracks (and NO data tracks).

    // FEATURE: Post NT-SUR beta 1, we should consider adding a new
    // DriveType flag for "contains data tracks" and revamp the commands
    // available on a CD-ROM drive.  The current code doesn't handle
    // mixed audio/data and audio/autorun discs very usefully. --JonBe

    // First try the new IOCTL which gives us a ULONG with bits indicating
    // the presence of either/both data & audio tracks

    CDROM_DISK_DATA data;
    DWORD dwDummy;

    // Requires GENERIC_READ access on the handle
    if (DeviceIoControl(hDevice, IOCTL_CDROM_DISK_TYPE, NULL, 0, &data,
        sizeof(data), &dwDummy, NULL))
    {
        if (data.DiskData & CDROM_DISK_AUDIO_TRACK)
        {
            _dwMediaCap |= HWDMC_HASAUDIOTRACKS;
        }

        if (data.DiskData & CDROM_DISK_DATA_TRACK)
        {
            _dwMediaCap |= HWDMC_HASDATATRACKS;
        }
    }
    else
    {
        // else that failed, so try to look for audio tracks the old way, by
        // looking throught the table of contents manually.  Note that data tracks
        // are supposed to be hidden in the TOC by CDFS now on mixed audio/data
        // discs (at least if the data tracks follow the audio tracks).
        CDROM_TOC  toc = {0};

        if (!DeviceIoControl(hDevice, IOCTL_CDROM_READ_TOC, NULL, 0, &toc,
            sizeof(toc), &dwDummy, NULL))
        {
            SUB_Q_CHANNEL_DATA subq = {0};
            CDROM_SUB_Q_DATA_FORMAT df = {0};

            // We might not have been able to read the TOC because the drive
            // was busy playing audio.  Lets try querying the audio position.
            df.Format = IOCTL_CDROM_CURRENT_POSITION;
            df.Track = 0;

            if (DeviceIoControl(hDevice, IOCTL_CDROM_READ_Q_CHANNEL, &df,
                sizeof(df), &subq, sizeof(subq), &dwDummy, NULL))
            {
                if (AUDIO_DATA_TRACK & subq.CurrentPosition.Control)
                {
                    _dwMediaCap |= HWDMC_HASDATATRACKS;
                }
                else
                {
                    _dwMediaCap |= HWDMC_HASAUDIOTRACKS;
                }
            }

            // Is there the equivalent of IOCTL_CDROM_READ_Q_CHANNEL for data?
            _dwMediaCap |= HWDMC_HASDATATRACKS_UNDETERMINED;
        }
        else
        {
            int nTracks = (toc.LastTrack - toc.FirstTrack) + 1;
            int iTrack = 0;

            // Now iterate through the tracks looking for Audio data
            while ((iTrack < nTracks) &&
                ((_dwMediaCap & (HWDMC_HASDATATRACKS | HWDMC_HASDATATRACKS)) !=
                (HWDMC_HASDATATRACKS | HWDMC_HASDATATRACKS))
                )
            {
                if ((toc.TrackData[iTrack].Control & TRACK_TYPE_MASK) == AUDIO_TRACK)
                {
                    _dwMediaCap |= HWDMC_HASAUDIOTRACKS;
                }
                else
                {
                    if ((toc.TrackData[iTrack].Control & TRACK_TYPE_MASK) == DATA_TRACK)
                    {
                        _dwMediaCap |= HWDMC_HASDATATRACKS;
                    }
                }
                ++iTrack;
            }
        }
    }

    return hr;
}

HRESULT CVolume::_UpdateMediaInfoOnRemove()
{
    _dwMediaCap = 0;
    _dwMediaState = 0;

    _szAutorunIconLocation[0] = 0;
    _szAutorunLabel[0] = 0;
    _dwSerialNumber = 0xBADBADBD;

    SafeStrCpyN(_szLabel, TEXT("Invalid"), ARRAYSIZE(_szLabel));
    SafeStrCpyN(_szFileSystem, TEXT("Invalid"), ARRAYSIZE(_szFileSystem));
    _dwRootAttributes = 0xBADBADBD;
    _dwMaxFileNameLen = 0xBADBADBD;
    _dwFileSystemFlags = 0xBADBADBD;

    _dwVolumeFlags &= ~(HWDVF_STATE_HASAUTOPLAYHANDLER |
        HWDVF_STATE_DONOTSNIFFCONTENT | HWDVF_STATE_JUSTDOCKED);

    return S_OK;
}

inline BOOL _XOR(BOOL bA, BOOL bB)
{
    return (bA && !bB) || (!bA && bB);
}

HRESULT CVolume::_UpdateMediaInfo(HANDLE hDevice, BOOL fGetYourOwnHandle)
{
    HRESULT hr;
    CImpersonateEveryone* pieo = NULL;

    ASSERT(_XOR((hDevice != INVALID_HANDLE_VALUE), fGetYourOwnHandle));

    if (fGetYourOwnHandle)
    {
        hr = CHWEventDetectorHelper::GetImpersonateEveryone(&pieo);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = pieo->Impersonate();

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                hr = _GetDeviceHandleSafe(&hDevice, TRUE);

                if (FAILED(hr) || (S_FALSE == hr))
                {
                    pieo->RCRelease();
                    pieo = NULL;
                }
            }
        }
    }
    else
    {
        hr = S_OK;
    }

    _dwVolumeFlags &= ~(HWDVF_STATE_HASAUTOPLAYHANDLER |
        HWDVF_STATE_DONOTSNIFFCONTENT | HWDVF_STATE_JUSTDOCKED);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        if (HWDTS_CDROM == _dwDriveType)
        {
            ASSERT(_fGenericReadRequired);

            // optimization
            if (_fFirstTime)
            {
                // already updated by _UpdateConstInfo
                _fFirstTime = FALSE;
            }
            else
            {
                _dwMediaCap = 0;

                hr = _UpdateMMC2CDInfo(hDevice);
            }
        }
        else
        {
            _dwMediaCap = 0;
        }

        if (SUCCEEDED(hr))
        {
            hr = _UpdateHasMedia(hDevice);

            if (SUCCEEDED(hr) && (_dwMediaState & HWDMS_PRESENT))
            {
                if (GetVolumeInformation(_szVolumeGUID, _szLabel,
                        ARRAYSIZE(_szLabel), &_dwSerialNumber,
                        &_dwMaxFileNameLen, &_dwFileSystemFlags, _szFileSystem,
                        ARRAYSIZE(_szFileSystem)))
                {
                    // use this?
                    // UINT err = SetErrorMode(SEM_FAILCRITICALERRORS);

                    // Root folder attributes
                    _dwRootAttributes = GetFileAttributes(_szVolumeGUID);

                    if (-1 != _dwRootAttributes)
                    {
                        // File presence
                        hr = _UpdateSpecialFilePresence();

                        if (SUCCEEDED(hr))
                        {
                            if (HWDTS_CDROM == _dwDriveType)
                            {
                                hr = _UpdateTrackInfo(hDevice);
                            }

                            if (HWDMC_HASAUTORUNINF & _dwMediaCap)
                            {
                                hr = _ExtractAutorunIconAndLabel();

                                // not critical
                                if (FAILED(hr))
                                {
                                    hr = S_FALSE;
                                }
                            }
                        }
                    }
                    else
                    {
                        _HandleAccessDenied();
                        _dwState |= STATE_GFAFAILED;

                        hr = S_FALSE;
                    }

                    _dwMediaState |= HWDMS_FORMATTED;
                }
                else
                {
                    if (ERROR_NOT_READY == GetLastError())
                    {
                        // We get this for offline cluster volumes.  Setting
                        // dismounted gets us the right Shell behavior.
                        _dwVolumeFlags |= HWDVF_STATE_DISMOUNTED;
                    }
                    else
                    {
                        _HandleAccessDenied();
                        _dwMediaState &= ~HWDMS_FORMATTED;
                    }

                    // To help us debug, even in retail
                    _dwState |= STATE_GVIFAILED;
                    _dwSerialNumber = GetLastError();

                    hr = S_FALSE;
                }
            }
            else
            {
                _dwState |= STATE_UPDATEHASMEDIAFAILED;

                _dwMediaCap = 0;

                hr = S_FALSE;
            }
        }

        if (S_FALSE == hr)
        {
            // We don't care if they fail
            SafeStrCpyN(_szLabel, TEXT("Invalid"), ARRAYSIZE(_szLabel));
            SafeStrCpyN(_szFileSystem, TEXT("Invalid"), ARRAYSIZE(_szFileSystem));
            _dwRootAttributes = 0xBADBADBD;
            _dwMaxFileNameLen = 0xBADBADBD;
            _dwFileSystemFlags = 0xBADBADBD;
        }

        if (fGetYourOwnHandle)
        {
            _CloseDeviceHandleSafe(hDevice);

            pieo->RevertToSelf();
            pieo->RCRelease();
        }
    }

    return hr;
}

const FEATURE_NUMBER _rgfnInteresting[] = 
{
    // FeatureProfileList needs to remain the first one
    FeatureProfileList, //                  = 0x0000,
    FeatureCdRead, //                       = 0x001e,
    FeatureDvdRead, //                      = 0x001f,
    FeatureRandomWritable, //               = 0x0020,
    FeatureIncrementalStreamingWritable, // = 0x0021,
    FeatureFormattable, //                  = 0x0023,
    FeatureDefectManagement, //             = 0x0024,
    FeatureRestrictedOverwrite, //          = 0x0026,
    FeatureCdTrackAtOnce, //                = 0x002d,
    FeatureCdMastering,  //                 = 0x002e,
    FeatureDvdRecordableWrite, //           = 0x002f,
    FeatureCDAudioAnalogPlay, //            = 0x0103,
};

struct CAPABILITYFEATURESMAP
{
    DWORD                   dwCapability;
    DWORD                   dwCapabilityDependent;
    const FEATURE_NUMBER*   prgFeature;
    DWORD                   cFeature;
};

const FEATURE_NUMBER rgfnWRITECAP[] =
{
    FeatureProfileList,
};

const FEATURE_NUMBER rgfnCDROM[] =
{
    FeatureCdRead,
};

const FEATURE_NUMBER rgfnCDRECORDABLE[] =
{
    FeatureIncrementalStreamingWritable,
    FeatureCdTrackAtOnce,
    FeatureCdMastering,
};

const FEATURE_NUMBER rgfnCDREWRITABLE[] =
{
    FeatureFormattable,
};

const FEATURE_NUMBER rgfnDVDROM[] =
{
    FeatureDvdRead,
};

const FEATURE_NUMBER rgfnDVDRECORDABLE[] =
{
    FeatureDvdRecordableWrite,
};

const FEATURE_NUMBER rgfnDVDREWRITABLE[] =
{
    FeatureFormattable,
};

const FEATURE_NUMBER rgfnDVDRAM[] =
{
    FeatureRandomWritable,
    FeatureDefectManagement,
};

const FEATURE_NUMBER rgfnANALOGAUDIOOUT[] =
{
    FeatureCDAudioAnalogPlay,
};

const CAPABILITYFEATURESMAP _rgcapfeaturemap[] =
{
    {
        HWDMC_WRITECAPABILITY_SUPPORTDETECTION,
        0,
        rgfnWRITECAP,
        ARRAYSIZE(rgfnWRITECAP),
    },
    {
        HWDMC_CDROM,
        HWDMC_WRITECAPABILITY_SUPPORTDETECTION,
        rgfnCDROM,
        ARRAYSIZE(rgfnCDROM),
    },
    {
        HWDMC_CDRECORDABLE,
        HWDMC_WRITECAPABILITY_SUPPORTDETECTION,
        rgfnCDRECORDABLE,
        ARRAYSIZE(rgfnCDRECORDABLE),
    },
    {
        HWDMC_CDREWRITABLE,
        HWDMC_CDRECORDABLE,
        rgfnCDREWRITABLE,
        ARRAYSIZE(rgfnCDREWRITABLE),
    },
    {
        HWDMC_DVDROM,
        HWDMC_WRITECAPABILITY_SUPPORTDETECTION,
        rgfnDVDROM,
        ARRAYSIZE(rgfnDVDROM),
    },
    {
        HWDMC_DVDRECORDABLE,
        HWDMC_WRITECAPABILITY_SUPPORTDETECTION,
        rgfnDVDRECORDABLE,
        ARRAYSIZE(rgfnDVDRECORDABLE),
    },
    {
        HWDMC_DVDREWRITABLE,
        HWDMC_DVDRECORDABLE,
        rgfnDVDREWRITABLE,
        ARRAYSIZE(rgfnDVDREWRITABLE),
    },
    {
        HWDMC_DVDRAM,
        HWDMC_DVDROM,
        rgfnDVDRAM,
        ARRAYSIZE(rgfnDVDRAM),
    },
    {
        HWDMC_ANALOGAUDIOOUT,
        HWDMC_WRITECAPABILITY_SUPPORTDETECTION,
        rgfnANALOGAUDIOOUT,
        ARRAYSIZE(rgfnANALOGAUDIOOUT),
    },
};

#define MMC2_NOTSUPPORTED       0
#define MMC2_DRIVESUPPORTED     1
#define MMC2_MEDIASUPPORTED     2

HRESULT CVolume::_FillMMC2CD(HANDLE hDevice)
{
    HRESULT hr;

    if (!_prgMMC2Features)
    {
        _prgMMC2Features = (DWORD*)LocalAlloc(LPTR,
            ARRAYSIZE(_rgfnInteresting) * sizeof(DWORD));
    }

    if (_prgMMC2Features)
    {
        DWORD cbHeader = sizeof(GET_CONFIGURATION_HEADER) +
            sizeof(FEATURE_HEADER);
        GET_CONFIGURATION_HEADER* pheader = (GET_CONFIGURATION_HEADER*)
            LocalAlloc(LPTR, cbHeader);

        if (pheader)
        {
            GET_CONFIGURATION_IOCTL_INPUT gcii;

            gcii.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE;
            gcii.Reserved[0] = NULL;
            gcii.Reserved[1] = NULL;

            for (DWORD dw = 0; dw < ARRAYSIZE(_rgfnInteresting); ++dw)
            {
                FEATURE_HEADER* pfh;

                DWORD cbReturned;
                gcii.Feature = _rgfnInteresting[dw];

                _prgMMC2Features[dw] = MMC2_NOTSUPPORTED;

                // Requires GENERIC_READ access on the handle
                if (DeviceIoControl(hDevice, IOCTL_CDROM_GET_CONFIGURATION,
                    &gcii, sizeof(GET_CONFIGURATION_IOCTL_INPUT), pheader,
                    cbHeader, &cbReturned, NULL))
                {
                    pfh = (FEATURE_HEADER*)(pheader->Data);

                    WORD w = (pfh->FeatureCode[0]) << 8 | (pfh->FeatureCode[1]);

                    if (w == _rgfnInteresting[dw])
                    {
                        _prgMMC2Features[dw] = MMC2_DRIVESUPPORTED;

                        if (pfh->Current)
                        {
                            _prgMMC2Features[dw] |= MMC2_MEDIASUPPORTED;
                        }
                        else
                        {
                            _prgMMC2Features[dw] &= ~MMC2_MEDIASUPPORTED;
                        }
                    }
                }
            }

            LocalFree(pheader);
        }       

        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// Rainier drive exposes features which perfectly matches DVD-RAM
// required feature set.  But they are CD-R/RW.  For drives
// we think are DVD-RAM, check if they also expose a DVD_RAM profile.
// We cannot use profiles all the way because they are not reliable.
// The same Rainier drive that expose bug 446652 exposes only
// the CDRewritable profile but it does support CDRecordable and
// CD-ROM.

HRESULT CVolume::_DVDRAMHack(HANDLE hDevice)
{
    BOOL fSupported = FALSE;
    BOOL fCurrent = FALSE;

    if (HWDDC_DVDRAM & _dwDriveCap)
    {
        // Do the check
        const DWORD cbHeaderInitial = sizeof(GET_CONFIGURATION_HEADER) + sizeof(FEATURE_HEADER);

        DWORD cbReturned;
        DWORD cbHeader = cbHeaderInitial;
        BYTE rgbBuffer[cbHeaderInitial];
        GET_CONFIGURATION_IOCTL_INPUT input;
        GET_CONFIGURATION_HEADER* pheader = (GET_CONFIGURATION_HEADER*)rgbBuffer;

        ZeroMemory(&input, sizeof(GET_CONFIGURATION_IOCTL_INPUT));
        ZeroMemory(rgbBuffer, sizeof(rgbBuffer));

        // Ask for the profile list
        input.Feature = FeatureProfileList;

        // We want only this feature back
        input.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ALL;

        BOOL f = DeviceIoControl(hDevice,
                             IOCTL_CDROM_GET_CONFIGURATION,
                             &input,
                             sizeof(GET_CONFIGURATION_IOCTL_INPUT),
                             pheader,
                             cbHeader,             
                             &cbReturned,
                             NULL);
        
        if (f)
        {
            cbHeader = pheader->DataLength[0] << 24 |
                       pheader->DataLength[1] << 16 |
                       pheader->DataLength[2] << 8  |
                       pheader->DataLength[3] << 0;

            GET_CONFIGURATION_HEADER* pheader2 = (GET_CONFIGURATION_HEADER*)LocalAlloc(LPTR, 
                cbHeader);

            if (pheader2)
            {
                // We want all the profiles back
                input.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ALL;

                f = DeviceIoControl(hDevice,
                                     IOCTL_CDROM_GET_CONFIGURATION,
                                     &input,
                                     sizeof(GET_CONFIGURATION_IOCTL_INPUT),
                                     pheader2,
                                     cbHeader,             
                                     &cbReturned,
                                     NULL);

                if (f)
                {
                    FEATURE_DATA_PROFILE_LIST* pproflist =
                        (FEATURE_DATA_PROFILE_LIST*)pheader2->Data;

                    for (DWORD dw = 0; dw < (DWORD)(pproflist->Header.AdditionalLength / 4); ++dw)
                    {
                        FEATURE_DATA_PROFILE_LIST_EX* pprofile = &(pproflist->Profiles[dw]);

                        if (ProfileDvdRam == (pprofile->ProfileNumber[0] << 8 |
                            pprofile->ProfileNumber[1] << 0))
                        {
                            // It does support it!  Is it current?
                            fSupported = TRUE;
                        
                            if (pprofile->Current)
                            {
                                fCurrent = TRUE;
                            }

                            break;
                        }
                    }
                }

                LocalFree(pheader2);
            }
        }

        if (fSupported)
        {
            if (!fCurrent)
            {
                _dwMediaCap &= ~HWDMC_DVDRAM;
            }
        }
        else
        {
            _dwDriveCap &= ~HWDDC_DVDRAM;
            _dwMediaCap &= ~HWDMC_DVDRAM;
        }
    }

    return S_OK;
}

// Not worth updating only Const Info vs Media Info, do both
HRESULT CVolume::_UpdateMMC2CDInfo(HANDLE hDevice)
{
    HRESULT hr = _FillMMC2CD(hDevice);

    if (SUCCEEDED(hr))
    {
        for (DWORD dwCap = 0; dwCap < ARRAYSIZE(_rgcapfeaturemap); ++dwCap)
        {
            DWORD dwGoOn = MMC2_NOTSUPPORTED;

            if (_rgcapfeaturemap[dwCap].dwCapabilityDependent)
            {
                // This capability is dependent on another one, let's
                // check if the other is on
                if (_dwDriveCap &
                    _rgcapfeaturemap[dwCap].dwCapabilityDependent)
                {
                    dwGoOn |= MMC2_DRIVESUPPORTED;

                    if (_dwMediaCap &
                        _rgcapfeaturemap[dwCap].dwCapabilityDependent)
                    {
                        dwGoOn |= MMC2_MEDIASUPPORTED;
                    }
                }
            }
            else
            {
                dwGoOn = MMC2_DRIVESUPPORTED | MMC2_MEDIASUPPORTED;
            }

            for (DWORD dwFeature = 0;
                dwFeature < (_rgcapfeaturemap[dwCap].cFeature);
                ++dwFeature)
            {
                for (DWORD dwFeatureOn = 0; (MMC2_DRIVESUPPORTED & dwGoOn) &&
                        (dwFeatureOn < ARRAYSIZE(_rgfnInteresting));
                    ++dwFeatureOn)
                {
                    if (_rgfnInteresting[dwFeatureOn] ==
                        _rgcapfeaturemap[dwCap].prgFeature[dwFeature])
                    {
                        if (_prgMMC2Features[dwFeatureOn] &
                            MMC2_DRIVESUPPORTED)
                        {
                            if (!(dwGoOn & MMC2_MEDIASUPPORTED) ||
                                !(_prgMMC2Features[dwFeatureOn] &
                                MMC2_MEDIASUPPORTED))
                            {
                                dwGoOn &= ~MMC2_MEDIASUPPORTED;
                            }
                        }
                        else
                        {
                            dwGoOn = MMC2_NOTSUPPORTED;
                        }

                        break;
                    }
                }

                if (MMC2_DRIVESUPPORTED & dwGoOn)
                {
                    _dwDriveCap |= _rgcapfeaturemap[dwCap].dwCapability;

                    if (MMC2_MEDIASUPPORTED & dwGoOn)
                    {
                        _dwMediaCap |= _rgcapfeaturemap[dwCap].
                            dwCapability;
                    }
                    else
                    {
                        _dwMediaCap &= ~(_rgcapfeaturemap[dwCap].
                            dwCapability);
                    }
                }
                else
                {
                    _dwDriveCap &= ~(_rgcapfeaturemap[dwCap].dwCapability);
                    _dwMediaCap &= ~(_rgcapfeaturemap[dwCap].dwCapability);
                }
            }
        }
    }

    _DVDRAMHack(hDevice);

    return hr;
}

HRESULT CVolume::_UpdateRemovableDevice()
{
    HRESULT hr = S_OK;

    if (_fHWDevInstInited)
    {
        BOOL fRemovable;

        hr = _hwdevinst.IsRemovableDevice(&fRemovable);

        if (SUCCEEDED(hr))
        {
            if (fRemovable)
            {
                _dwDriveCap |= HWDDC_REMOVABLEDEVICE;
            }
        }
    }

    return hr;
}

HRESULT CVolume::_UpdateSoftEjectCaps()
{
    HRESULT hr = S_OK;

    if (_fHWDevInstInited)
    {
        DWORD dw;
        DWORD dwType;

        hr = _GetDevicePropertyGeneric(&_hwdevinst, TEXT("NoSoftEject"),
            FALSE, &dwType, (PBYTE)&dw, sizeof(dw));

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = S_OK;

            if (REG_DWORD == dwType)
            {
                if (1 == dw)
                {
                    _dwDriveCap |= HWDDC_NOSOFTEJECT;
                }
            }
        }
    }

    return hr;
}

HRESULT CVolume::_UpdateConstInfo(HANDLE hDevice)
{
    HRESULT hr;

    _dwVolumeFlags = 0;

    if (HWDTS_CDROM == _dwDriveType)
    {
        _dwVolumeFlags = HWDVF_STATE_SUPPORTNOTIFICATION;

        hr = _UpdateMMC2CDInfo(hDevice);
    }
    else
    {
        if (HWDTS_REMOVABLEDISK == _dwDriveType)
        {
            _dwVolumeFlags = HWDVF_STATE_SUPPORTNOTIFICATION;
        }
        else
        {
            if ((HWDTS_FLOPPY35 != _dwDriveType) &&
                (HWDTS_FLOPPY525 != _dwDriveType))
            {
                // Do something for the 120MB floppy
                _dwVolumeFlags = HWDVF_STATE_SUPPORTNOTIFICATION;
            }
        }

        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        hr = _GetVolumeName(_pszElemName, _szVolumeGUID,
            ARRAYSIZE(_szVolumeGUID));
    }

    if (SUCCEEDED(hr))
    {
        if (HWDTS_CDROM != _dwDriveType)
        {
            _dwDriveCap |= HWDMC_WRITECAPABILITY_SUPPORTDETECTION |
                HWDDC_RANDOMWRITE;
        }
    }

    return hr;
}

HRESULT CVolume::GetVolumeConstInfo(LPWSTR pszVolumeGUID, DWORD cchVolumeGUID,
    DWORD* pdwVolumeFlags, DWORD* pdwDriveType, DWORD* pdwDriveCap)
{
    HRESULT hr;

    _cs.Enter();

    hr = SafeStrCpyN(pszVolumeGUID, _szVolumeGUID, cchVolumeGUID);

    if (SUCCEEDED(hr))
    {
        if (!(_dwVolumeFlags & HWDVF_STATE_ACCESSDENIED))
        {
            *pdwVolumeFlags = _dwVolumeFlags;
            *pdwDriveType = _dwDriveType;
            *pdwDriveCap = _dwDriveCap;
        }
        else
        {
            *pdwVolumeFlags = HWDVF_STATE_ACCESSDENIED;
            *pdwDriveType = 0xBADBADBD;
            *pdwDriveCap = 0xBADBADBD;
        }
    }

    _cs.Leave();

    return hr;
}

HRESULT CVolume::GetVolumeMediaInfo(LPWSTR pszLabel, DWORD cchLabel, 
    LPWSTR pszFileSystem, DWORD cchFileSystem, DWORD* pdwFileSystemFlags,
    DWORD* pdwMaxFileNameLen, DWORD* pdwRootAttributes, DWORD* pdwSerialNumber,
    DWORD* pdwDriveState, DWORD* pdwMediaState, DWORD* pdwMediaCap)
{
    HRESULT hr;

    _cs.Enter();

    if (!(_dwVolumeFlags & HWDVF_STATE_ACCESSDENIED))
    {
        if (_dwMediaState & HWDMS_PRESENT)
        {
            hr = SafeStrCpyN(pszLabel, _szLabel, cchLabel);

            if (SUCCEEDED(hr))
            {
                hr = SafeStrCpyN(pszFileSystem, _szFileSystem, cchFileSystem);
            }

            if (SUCCEEDED(hr))
            {
                *pdwFileSystemFlags = _dwFileSystemFlags;
                *pdwMaxFileNameLen = _dwMaxFileNameLen; 
                *pdwRootAttributes = _dwRootAttributes;
                *pdwSerialNumber = _dwSerialNumber;

                *pdwDriveState = _dwDriveState;

                *pdwMediaState = _dwMediaState;
            }
        }
        else
        {
            *pdwMediaState = _dwMediaState;

            // We don't care if they fail
            SafeStrCpyN(pszLabel, TEXT("Invalid"), cchLabel);
            SafeStrCpyN(pszFileSystem, TEXT("Invalid"), cchFileSystem);
            *pdwSerialNumber = 0xBADBADBD;
            *pdwMaxFileNameLen = 0xBADBADBD;
            *pdwFileSystemFlags = 0xBADBADBD;
            *pdwRootAttributes = 0xBADBADBD;
            *pdwDriveState = 0xBADBADBD;

            hr = S_OK;
        }

        *pdwMediaCap = _dwMediaCap;
    }
    else
    {
        *pdwMediaState = 0xBADBADBD;

        // We don't care if they fail
        SafeStrCpyN(pszLabel, TEXT("Access Denied"), cchLabel);
        SafeStrCpyN(pszFileSystem, TEXT("Access Denied"), cchFileSystem);
        *pdwSerialNumber = 0xBADBADBD;
        *pdwMaxFileNameLen = 0xBADBADBD;
        *pdwFileSystemFlags = 0xBADBADBD;
        *pdwRootAttributes = 0xBADBADBD;
        *pdwDriveState = 0xBADBADBD;
        *pdwMediaCap = 0xBADBADBD;

        hr = S_OK;
    }

    _cs.Leave();

    return hr;
}

HRESULT CVolume::GetIconAndLabelInfo(LPWSTR pszAutorunIconLocation,
    DWORD cchAutorunIconLocation, LPWSTR pszAutorunLabel, DWORD cchAutorunLabel,
    LPWSTR pszIconLocationFromService, DWORD cchIconLocationFromService,
    LPWSTR pszNoMediaIconLocationFromService, DWORD cchNoMediaIconLocationFromService,
    LPWSTR pszLabelFromService, DWORD cchLabelFromService)
{
    HRESULT hrTmp;

    *pszAutorunIconLocation = NULL;
    *pszAutorunLabel = NULL;
    *pszIconLocationFromService = NULL;
    *pszNoMediaIconLocationFromService = NULL;
    *pszLabelFromService = NULL;

    _cs.Enter();

    if (!(_dwVolumeFlags & HWDVF_STATE_ACCESSDENIED))
    {
        if (_dwMediaCap & HWDMC_HASAUTORUNINF)
        {
            if (_szAutorunIconLocation[0])
            {
                hrTmp = SafeStrCpyN(pszAutorunIconLocation, _szAutorunIconLocation,
                    cchAutorunIconLocation);

                if (FAILED(hrTmp))
                {
                    *pszAutorunIconLocation = 0;
                }
            }

            if (_szAutorunLabel[0])
            {
                hrTmp = SafeStrCpyN(pszAutorunLabel, _szAutorunLabel,
                    cchAutorunLabel);

                if (FAILED(hrTmp))
                {
                    *pszAutorunLabel = 0;
                }
            }
        }

        if (_fHWDevInstInited)
        {
            WORD_BLOB* pblob;

            hrTmp = _GetDevicePropertyGenericAsMultiSz(&_hwdevinst, TEXT("Icons"),
                TRUE, &pblob);

            if (SUCCEEDED(hrTmp) && (S_FALSE != hrTmp))
            {
                hrTmp = SafeStrCpyN(pszIconLocationFromService, pblob->asData,
                    cchIconLocationFromService);

                if (FAILED(hrTmp))
                {
                    *pszIconLocationFromService = 0;
                }

                CoTaskMemFree(pblob);
            }
            else
            {
                *pszIconLocationFromService = 0;
                hrTmp = S_FALSE;
            }

            hrTmp = _GetDevicePropertyGenericAsMultiSz(&_hwdevinst, TEXT("NoMediaIcons"),
                TRUE, &pblob);

            if (SUCCEEDED(hrTmp) && (S_FALSE != hrTmp))
            {
                hrTmp = SafeStrCpyN(pszNoMediaIconLocationFromService, pblob->asData,
                    cchNoMediaIconLocationFromService);

                if (FAILED(hrTmp))
                {
                    *pszNoMediaIconLocationFromService = 0;
                }

                CoTaskMemFree(pblob);
            }
            else
            {
                *pszNoMediaIconLocationFromService = 0;
                hrTmp = S_FALSE;
            }

            if (SUCCEEDED(hrTmp))
            {
                hrTmp = _GetDevicePropertyAsString(&_hwdevinst, TEXT("Label"),
                    pszLabelFromService, cchLabelFromService);

                if (FAILED(hrTmp) || (S_FALSE == hrTmp))
                {
                    *pszLabelFromService = 0;
                }
            }
        }
    }

    _cs.Leave();

    return S_OK;
}

HRESULT CVolume::_GetVOLUMEINFO2(VOLUMEINFO2** ppvolinfo2)
{
    ASSERT(_cs.IsInside());

    DWORD cchReq;

    // We allocate this buffer just to be stack friendly, otherwise it could
    // have been on the stack
    VOLUMEINFO2* pvolinfo2;
    const DWORD cbvolinfo2 = MAX_VOLUMEINFO2;
    
    HRESULT hr = _AllocMemoryChunk<VOLUMEINFO2*>(cbvolinfo2, &pvolinfo2);

    *ppvolinfo2 = NULL;

    if (SUCCEEDED(hr))
    {
        pvolinfo2->cbSize = MAX_VOLUMEINFO2;

        hr = GetName(pvolinfo2->szDeviceIDVolume,
            ARRAYSIZE(pvolinfo2->szDeviceIDVolume), &cchReq);

        if (SUCCEEDED(hr))
        {
            // Const info
            hr = SafeStrCpyN(pvolinfo2->szVolumeGUID, _szVolumeGUID,
                ARRAYSIZE(pvolinfo2->szVolumeGUID));

            if (_dwVolumeFlags & HWDVF_STATE_ACCESSDENIED)
            {
                pvolinfo2->dwVolumeFlags = HWDVF_STATE_ACCESSDENIED;
            }
            else
            {
                if (SUCCEEDED(hr))
                {
                    pvolinfo2->dwVolumeFlags = _dwVolumeFlags;
                    pvolinfo2->dwDriveType = _dwDriveType;
                    pvolinfo2->dwDriveCapability = _dwDriveCap;
                }

                pvolinfo2->dwState = _dwState;

                // Media info
                if (SUCCEEDED(hr))
                {
                    // This fct should be called from within the Volume critsect
                    if (_dwMediaState & HWDMS_PRESENT)
                    {
                        hr = SafeStrCpyN(pvolinfo2->szLabel, _szLabel,
                            ARRAYSIZE(pvolinfo2->szLabel));

                        if (SUCCEEDED(hr))
                        {
                            hr = SafeStrCpyN(pvolinfo2->szFileSystem, _szFileSystem,
                                ARRAYSIZE(pvolinfo2->szFileSystem));
                        }

                        if (SUCCEEDED(hr))
                        {
                            pvolinfo2->dwFileSystemFlags = _dwFileSystemFlags;
                            pvolinfo2->dwMaxFileNameLen = _dwMaxFileNameLen; 
                            pvolinfo2->dwRootAttributes = _dwRootAttributes;
                            pvolinfo2->dwSerialNumber = _dwSerialNumber;

                            pvolinfo2->dwDriveState = _dwDriveState;
                            pvolinfo2->dwMediaCap = _dwMediaCap;

                            pvolinfo2->dwMediaState = _dwMediaState;
                        }
                    }
                    else
                    {
                        pvolinfo2->dwMediaState = _dwMediaState;

                        // We don't care if they fail
                        SafeStrCpyN(pvolinfo2->szLabel, TEXT("Invalid"),
                            ARRAYSIZE(pvolinfo2->szLabel));
                        SafeStrCpyN(pvolinfo2->szFileSystem, TEXT("Invalid"),
                            ARRAYSIZE(pvolinfo2->szFileSystem));
                        pvolinfo2->dwSerialNumber = 0xBADBADBD;
                        pvolinfo2->dwMaxFileNameLen = 0xBADBADBD;
                        pvolinfo2->dwFileSystemFlags = 0xBADBADBD;
                        pvolinfo2->dwRootAttributes = 0xBADBADBD;
                        pvolinfo2->dwDriveState = 0xBADBADBD;

                        hr = S_OK;
                    }

                    pvolinfo2->dwMediaCap = _dwMediaCap;
                }

                if (SUCCEEDED(hr))
                {
                    WCHAR szAutorunIconLocation[MAX_ICONLOCATION];
                    WCHAR szAutorunLabel[MAX_LABEL];
                    WCHAR szIconLocationFromService[MAX_ICONLOCATION];
                    WCHAR szNoMediaIconLocationFromService[MAX_ICONLOCATION];
                    // We can now have a @%SystemRoot%\system32\shell32.dll,-1785 for MUI stuff
                    WCHAR szLabelFromService[MAX_ICONLOCATION];

                    pvolinfo2->oAutorunIconLocation = INVALID_DWORD;
                    pvolinfo2->oAutorunLabel = INVALID_DWORD;
                    pvolinfo2->oIconLocationFromService = INVALID_DWORD;
                    pvolinfo2->oNoMediaIconLocationFromService = INVALID_DWORD;
                    pvolinfo2->oLabelFromService = INVALID_DWORD;

                    hr = GetIconAndLabelInfo(szAutorunIconLocation,
                        ARRAYSIZE(szAutorunIconLocation), szAutorunLabel,
                        ARRAYSIZE(szAutorunLabel), szIconLocationFromService,
                        ARRAYSIZE(szIconLocationFromService), szNoMediaIconLocationFromService,
                        ARRAYSIZE(szNoMediaIconLocationFromService), szLabelFromService,
                        ARRAYSIZE(szLabelFromService));

                    if (SUCCEEDED(hr))
                    {
                        LPWSTR pszNext = pvolinfo2->szOptionalStrings;
                        size_t cchLeft = (cbvolinfo2 - sizeof(*pvolinfo2) + 
                            sizeof(pvolinfo2->szOptionalStrings)) / sizeof(WCHAR);
                        size_t cchLeftBeginWith = cchLeft;
                        
                         // The following five strings are optional
                        if (szAutorunIconLocation[0])
                        {
                            pvolinfo2->oAutorunIconLocation = (DWORD)(cchLeftBeginWith - cchLeft);

                            hr = StringCchCopyEx(pszNext, cchLeft, szAutorunIconLocation, &pszNext, &cchLeft, 0);
                            
                            ++pszNext;
                            --cchLeft;
                        }

                        if (SUCCEEDED(hr) && szAutorunLabel[0])
                        {
                            pvolinfo2->oAutorunLabel = (DWORD)(cchLeftBeginWith - cchLeft);

                            hr = StringCchCopyEx(pszNext, cchLeft, szAutorunLabel, &pszNext, &cchLeft, 0);
                            
                            ++pszNext;
                            --cchLeft;
                        }

                        if (SUCCEEDED(hr) && szIconLocationFromService[0])
                        {
                            pvolinfo2->oIconLocationFromService = (DWORD)(cchLeftBeginWith - cchLeft);
                            
                            hr = StringCchCopyEx(pszNext, cchLeft, szIconLocationFromService, &pszNext, &cchLeft, 0);
                            
                            ++pszNext;
                            --cchLeft;
                        }

                        if (SUCCEEDED(hr) && szNoMediaIconLocationFromService[0])
                        {
                            pvolinfo2->oNoMediaIconLocationFromService = (DWORD)(cchLeftBeginWith - cchLeft);
                            
                            hr = StringCchCopyEx(pszNext, cchLeft, szNoMediaIconLocationFromService, &pszNext, &cchLeft, 0);
                            
                            ++pszNext;
                            --cchLeft;
                        }

                        if (SUCCEEDED(hr) && szLabelFromService[0])
                        {
                            pvolinfo2->oLabelFromService = (DWORD)(cchLeftBeginWith - cchLeft);

                            hr = StringCchCopy(pszNext, cchLeft, szLabelFromService);
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            *ppvolinfo2 = pvolinfo2;
        }
        else
        {
            _FreeMemoryChunk<VOLUMEINFO2*>(pvolinfo2);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CVolume::HandleRemoval()
{
    WCHAR szDeviceIDVolume[MAX_DEVICEID];
    DWORD cchReq;

    HRESULT hr = GetName(szDeviceIDVolume, ARRAYSIZE(szDeviceIDVolume), &cchReq);

    if (SUCCEEDED(hr))
    {
        // This will launch a thread
        CHardwareDevicesImpl::_AdviseVolumeRemoved(szDeviceIDVolume,
            _pszMountPoints, _cchMountPoints);
    }

    return hr;
}

HRESULT CVolume::HandleArrival()
{
    BOOL fJustDocked = FALSE;

    HRESULT hr = CHWEventDetectorHelper::DockStateChanged(&fJustDocked);

    if (SUCCEEDED(hr))
    {
        //
        // ISSUE-2001/01/13-StephStm  Pass the Docking change in there so
        //                            that the Shell knows if it should
        //                            Autorun or not.
        //
        if (_fHWDevInstInited)
        {
            BOOL fTryAutoplay = TRUE;

            if ((_dwDriveType & HWDTS_CDROM) ||
                (_dwDriveType & HWDTS_REMOVABLEDISK))
            {
                if (_dwMediaState & HWDMS_PRESENT)
                {
                    // Not removable disk, but device
                    BOOL fRemovable;

                    hr = _hwdevinst.IsRemovableDevice(&fRemovable);

                    if (SUCCEEDED(hr))
                    {
                        if (fRemovable)
                        {
                            // We need to Autoplay these since cameras
                            // are removable-disk devices.  And we want
                            // to autorun them when they come in.
                            fTryAutoplay = TRUE;
                        }
                        else
                        {
                            // For removable-disk drives/CD drives with
                            // media inserted when they are plugged,
                            // we do not Autoplay.
                            fTryAutoplay = FALSE;

                            DIAGNOSTIC((TEXT("[0311]Non removable device plugged with media in it -> No Autoplay!")));
                        }
                    }
                }
            }
            if (!fJustDocked && fTryAutoplay)
            {
                HANDLE hDevice;

                // Get a handle to regsiter for notification so that the
                // FindFirstFile does not veto a PnP/Driver transition
                hr = _GetDeviceHandleSafe(&hDevice, FALSE);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    hr = _ShouldTryAutoplay(&fTryAutoplay);

                    if (SUCCEEDED(hr))
                    {
                        if (fTryAutoplay)
                        {
                            BOOL fHasHandler;

                            hr = CHWEventDetectorImpl::HandleVolumeMediaEvent(
                                _pszElemName, &_hwdevinst, TEXT("DeviceArrival"),
                                &fHasHandler);

                            if (SUCCEEDED(hr) && fHasHandler)
                            {
                                _dwVolumeFlags |= HWDVF_STATE_HASAUTOPLAYHANDLER;
                            }
                        }
                        else
                        {
                            _dwVolumeFlags |= HWDVF_STATE_DONOTSNIFFCONTENT;
                        }
                    }

                    _CloseDeviceHandleSafe(hDevice);
                }
            }
            else
            {
                if (fJustDocked)
                {
                    DIAGNOSTIC((TEXT("[0301]Just docked -> No Autoplay!")));
                    TRACE(TF_VOLUME, TEXT("Just docked -> No Autoplay!"));

                    _dwVolumeFlags |= HWDVF_STATE_JUSTDOCKED;
                }
            }
        }
        else
        {
            DIAGNOSTIC((TEXT("[0310]Cannot find hardware device for this volume -> No Autoplay!")));
            hr = S_FALSE;
        }

        if (SUCCEEDED(hr))
        {
            _AdviseVolumeChangeHelper(TRUE);
        }
    }

    return hr;
}
///////////////////////////////////////////////////////////////////////////////
//
CVolume::CVolume() : _dwMediaState(0),
    _devtype((DEVICE_TYPE)-1), _ulDeviceNumber((ULONG)-1),
    _ulPartitionNumber((ULONG)-1), _fHWDevInstInited(FALSE), _dwDriveType(0),
    _dwDriveCap(0), _dwVolumeFlags(0), _prgMMC2Features(NULL),
    _fFirstTime(TRUE), _dwMediaCap(0), _pszMountPoints(NULL), _dwDriveState(0),
    _hdevnotify(NULL), _dwState(0),
    _dwMediaPresentFromEvent(MPFE_UNDETERMINED)
{
    _szVolumeGUID[0] = 0;
    _szDeviceIDDisk[0] = 0;
}

CVolume::~CVolume()
{
    _UnregisterNotif();

    if (_pszMountPoints)
    {
        CNamedElemList* pnel;
        HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_MTPT, &pnel);

        if (S_OK == hres)
        {
            for (LPWSTR psz = _pszMountPoints; *psz; psz += (lstrlen(psz) + 1))
            {
                hres = pnel->Remove(psz);
            }            

            pnel->RCRelease();
        }

        LocalFree(_pszMountPoints);
    }

    if (_prgMMC2Features)
    {
        LocalFree(_prgMMC2Features);
    }

    _cs.Delete();
}
///////////////////////////////////////////////////////////////////////////////
//
//static
HRESULT CVolume::Create(CNamedElem** ppelem)
{
    HRESULT hres = S_OK;

    *ppelem = new CVolume();

    if (!(*ppelem))
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

//static
HRESULT CVolume::GetFillEnum(CFillEnum** ppfillenum)
{
    HRESULT hres;

    CVolumeFillEnum* pfillenum = new CVolumeFillEnum();

    if (pfillenum)
    {
        hres = pfillenum->_Init();

        if (FAILED(hres))
        {
            delete pfillenum;
            pfillenum = NULL;
        }
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    *ppfillenum = pfillenum;

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT CVolumeFillEnum::Next(LPWSTR pszElemName, DWORD cchElemName,
    DWORD* pcchRequired)
{
    return _intffillenum.Next(pszElemName, cchElemName, pcchRequired);
}

HRESULT CVolumeFillEnum::_Init()
{
    return _intffillenum._Init(&guidVolumeClass, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\apiconnection.h ===
//  --------------------------------------------------------------------------
//  Module Name: APIConnectionThread.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class that listens to an LPC connection port waiting for requests from
//  a client to connect to the port or a request which references a previously
//  established connection.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _APIConnectionThread_
#define     _APIConnectionThread_

#include "APIRequest.h"
#include "DynamicArray.h"
#include "PortMessage.h"
#include "ServerAPI.h"

//  --------------------------------------------------------------------------
//  CAPIConnection
//
//  Purpose:    This class listens to the server connection port for an LPC
//              connection request, an LPC request or an LPC connect closed
//              message. It correctly handles each request. LPC requests are
//              queued to the managing CAPIDispatcher.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//              2000-11-28  vtan        removed thread functionality
//  --------------------------------------------------------------------------

class   CAPIConnection : public CCountedObject
{
    private:
                                            CAPIConnection (void);
    public:
                                            CAPIConnection (CServerAPI* pServerAPI);
                                            ~CAPIConnection (void);

                NTSTATUS                    ConstructorStatusCode (void)    const;
                NTSTATUS                    Listen ( CAPIDispatchSync* pAPIDispatchSync );

                NTSTATUS                    AddAccess (PSID pSID, DWORD dwMask);
                NTSTATUS                    RemoveAccess (PSID pSID);
    private:
                NTSTATUS                    ListenToServerConnectionPort (void);

                NTSTATUS                    HandleServerRequest (const CPortMessage& portMessage, CAPIDispatcher *pAPIDispatcher);
                NTSTATUS                    HandleServerConnectionRequest (const CPortMessage& portMessage);
                NTSTATUS                    HandleServerConnectionClosed (const CPortMessage& portMessage, CAPIDispatcher *pAPIDispatcher);

                int                         FindIndexDispatcher (CAPIDispatcher *pAPIDispatcher);
    private:
                NTSTATUS                    _status;
                bool                        _fStopListening;
                CServerAPI*                 _pServerAPI;
                HANDLE                      _hPort;
                CAPIDispatchSync*           _pAPIDispatchSync;

                CCriticalSection            _dispatchers_lock;
                CDynamicCountedObjectArray  _dispatchers;
};

#endif  /*  _APIConnectionThread_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shsrvice\shsrvice.cpp ===
#include "shsrvice.h"
#include "service.h"

#include "mischlpr.h"

#include "sfstr.h"
#include "str.h"
#include "reg.h"

#include "resource.h"

#include "dbg.h"
#include "tfids.h"

#include <dbt.h>
#include <initguid.h>
#include <ioevent.h>

#include <shlwapi.h>
#include <shlwapip.h>
#include <strsafe.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

struct CTRLEVENT
{
    CTRLEVENT*  peventNext;
    DWORD       dwControl;
    DWORD       dwEventType;
    BYTE        rgbEventData[1];
};

const LPWSTR pszSVCHostGroup = TEXT("netsvcs");

///////////////////////////////////////////////////////////////////////////////
//
SERVICE_TABLE_ENTRY CGenericServiceManager::_rgste[] = 
{
    { TEXT("ShellHWDetection"), CGenericServiceManager::_ServiceMain },
    { NULL, NULL },
};

CGenericServiceManager::SUBSERVICE CGenericServiceManager::_rgsubservice[] =
{
    { TEXT("Shell.HWEventDetector"), IDS_SHELLHWDETECTION_FRIENDLYNAME,
      TEXT("RpcSs\0"), TEXT("ShellSvcGroup"), IDS_SHELLHWDETECTION_DESCRIPTION,
      {0} },
};

// "- 1": Last entry of both arrays are NULL terminators
DWORD CGenericServiceManager::_cste =
    ARRAYSIZE(CGenericServiceManager::_rgste) - 1;

CRITICAL_SECTION CGenericServiceManager::_csQueue = {0};

BOOL CGenericServiceManager::_fCritSectInit = FALSE;
HANDLE CGenericServiceManager::_hEventInitCS = NULL;

#ifdef DEBUG
BOOL CGenericServiceManager::_fRunAsService = TRUE;
#endif
///////////////////////////////////////////////////////////////////////////////
//

// static
BOOL _IsAlreadyInstalled(LPCWSTR pszRegStr, LPCWSTR pszServiceName)
{
    LPCWSTR psz = pszRegStr;
    BOOL fThere = FALSE;

    do
    {
        if (!lstrcmp(psz, pszServiceName))
        {
            fThere = TRUE;
            break;
        }

        psz += lstrlen(psz) + 1;
    }
    while (*psz);

    return fThere;
}

HRESULT _UnInstall(LPCWSTR pszServiceName)
{
    HRESULT hres = E_FAIL;
    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    // Need to do it for all services
    if (hSCM)
    {
        hres = S_OK;

        SC_HANDLE hService = OpenService(hSCM, pszServiceName,
            DELETE);

        if (hService)
        {
            DeleteService(hService);
            CloseServiceHandle(hService);
        }
        else
        {
            // Don't fail, if somebody manually removed the service n
            // from the reg, then all n + x services will not uninstall.
            hres = S_FALSE;
        }

        CloseServiceHandle(hSCM);
    }
   
    return hres;
}

HRESULT _InstSetSVCHostInfo(LPWSTR pszServiceName)
{
    HRESULT hres = E_FAIL;
    HKEY hkey;
    DWORD dwDisp;
    BOOL fAlreadyThere = FALSE;

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost"),
        0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hkey,
        &dwDisp))
    {
        DWORD cbSize;
        DWORD cbSizeNew;
        BOOL fEmpty = FALSE;
        LPWSTR pszNew;

        if (ERROR_SUCCESS != RegQueryValueEx(hkey, pszSVCHostGroup, 0, NULL,
            NULL, &cbSize))
        {
            fEmpty = TRUE;
            // Set cbSize to the size of the 2nd NULL terminator
            cbSize = sizeof(WCHAR);
        }

        cbSizeNew = cbSize + (lstrlen(pszServiceName) + 1) * sizeof(WCHAR);
        pszNew = (LPWSTR)LocalAlloc(LPTR, cbSizeNew);

        if (pszNew)
        {
            DWORD cbSize2 = cbSizeNew;

            hres = S_OK;

            if (!fEmpty)
            {
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, pszSVCHostGroup, 0,
                    NULL, (PBYTE)pszNew, &cbSize2))
                {
                    if (cbSize2 == cbSize)
                    {
                        fAlreadyThere = _IsAlreadyInstalled(pszNew,
                            pszServiceName);
                    }
                    else
                    {
                        hres = E_FAIL;
                    }
                }
                else
                {
                    hres = E_FAIL;
                }
            }
            else
            {
                cbSize2 = sizeof(WCHAR);
            }

            if (SUCCEEDED(hres) && !fAlreadyThere)
            {
                // We just allocated the buffer for this, it should not fail.
                SHOULDNOTFAIL(SUCCEEDED(StringCchCopy(pszNew + (cbSize2 / sizeof(WCHAR)) - 1,
                    (cbSizeNew / sizeof(WCHAR)) - (cbSize2 / sizeof(WCHAR)) + 1,
                    pszServiceName)));

                if (ERROR_SUCCESS != RegSetValueEx(hkey, pszSVCHostGroup, 0,
                    REG_MULTI_SZ, (PBYTE)pszNew, cbSizeNew))
                {
                    hres = E_FAIL;
                }
            }

            LocalFree((HLOCAL)pszNew);
        }
        else
        {
            hres = E_OUTOFMEMORY;
        }

        // We should have an entry in the SUBSERVICE array for this...
        if (SUCCEEDED(hres))
        {
            HKEY hkey2;

            if (ERROR_SUCCESS == RegCreateKeyEx(hkey, pszSVCHostGroup,
                0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL,
                &hkey2, &dwDisp))
            {
                DWORD dwSec = 0x00000001;
                DWORD cbSec = sizeof(dwSec);

                // We set this magic value of 1 and svchost.exe will 
                // call CoInitializeSecurity for us
                if (ERROR_SUCCESS != RegSetValueEx(hkey2,
                    TEXT("CoInitializeSecurityParam"), 0, REG_DWORD,
                    (PBYTE)&dwSec, cbSec))
                {
                    hres = E_FAIL;
                }
            }

            RegCloseKey(hkey2);
        }

        RegCloseKey(hkey);
    }

    return hres;
}

HRESULT _InstSetParameters(LPWSTR pszServiceName)
{
    HKEY hkeyServices;
    HRESULT hres = E_FAIL;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Services\\"), 0,
            MAXIMUM_ALLOWED, &hkeyServices))
    {
        HKEY hkeySvc;

        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyServices, pszServiceName, 0,
            MAXIMUM_ALLOWED, &hkeySvc))
        {
            HKEY hkeyParam;

            if (ERROR_SUCCESS == RegCreateKeyEx(hkeySvc,
                TEXT("Parameters"), 0, NULL,
                REG_OPTION_NON_VOLATILE,
                MAXIMUM_ALLOWED, NULL, &hkeyParam, NULL))
            {
                // Watch out!  Hard coded path and filename!
                WCHAR szServiceDll[] =
                    TEXT("%SystemRoot%\\System32\\shsvcs.dll");

                if (ERROR_SUCCESS == RegSetValueEx(hkeyParam,
                    TEXT("ServiceDll"), 0, REG_EXPAND_SZ,
                    (PBYTE)szServiceDll, sizeof(szServiceDll)))
                {
                    WCHAR szServiceMain[] =
                        TEXT("HardwareDetectionServiceMain");

                    if (ERROR_SUCCESS == RegSetValueEx(
                        hkeyParam, TEXT("ServiceMain"), 0,
                        REG_SZ, (PBYTE)szServiceMain,
                        sizeof(szServiceMain)))
                    {
                        hres = S_OK;
                    }
                }

                RegCloseKey(hkeyParam);
            }

            RegCloseKey(hkeySvc);
        }

        RegCloseKey(hkeyServices);
    }

    return hres;
}

// static
HRESULT CGenericServiceManager::UnInstall()
{
    HRESULT hr = S_FALSE;

    for (DWORD dw = 0; SUCCEEDED(hr) && (dw < _cste); ++dw)
    {
        hr = _UnInstall(_rgste[dw].lpServiceName);
    }

    return hr;
}

HRESULT _GetFriendlyStrings(CGenericServiceManager::SUBSERVICE* psubservice,
    LPWSTR pszFriendlyName, DWORD cchFriendlyName, LPWSTR pszDescription,
    DWORD cchDescription)
{
    *pszFriendlyName = 0;
    *pszDescription = 0;

    HMODULE hmodule = GetModuleHandle(TEXT("shsvcs.dll"));

    if (hmodule)
    {
        LoadString(hmodule, psubservice->uFriendlyName, pszFriendlyName,
            cchFriendlyName);

        LoadString(hmodule, psubservice->uDescription, pszDescription,
            cchDescription);
    }

    return S_OK;
}

// static
HRESULT CGenericServiceManager::Install()
{
    HRESULT     hres = S_FALSE;
        
    if (!IsOS(OS_WOW6432))
    {
        hres = E_FAIL;
        SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
        DWORD dwStartType = SERVICE_AUTO_START;

        if (hSCM)
        {
            WCHAR szFriendlyName[200];
            // Doc says limit is 1024 bytes
            WCHAR szDescription[1024 / sizeof(WCHAR)];

            // Need to do it for all services
            hres = S_OK;

            for (DWORD dw = 0; SUCCEEDED(hres) && (dw < _cste); ++dw)
            {
                WCHAR szCmd[MAX_PATH] =
                    TEXT("%SystemRoot%\\System32\\svchost.exe -k ");

                hres = SafeStrCatN(szCmd, pszSVCHostGroup, ARRAYSIZE(szCmd));

                if (SUCCEEDED(hres))
                {
                    _GetFriendlyStrings(&(_rgsubservice[dw]), szFriendlyName,
                        ARRAYSIZE(szFriendlyName), szDescription,
                        ARRAYSIZE(szDescription));

                    SC_HANDLE hService = CreateService(hSCM,
                        _rgste[dw].lpServiceName,
                        szFriendlyName,
                        SERVICE_CHANGE_CONFIG,
                        SERVICE_WIN32_SHARE_PROCESS,
                        dwStartType, SERVICE_ERROR_IGNORE, 
                        szCmd,
                        _rgsubservice[dw].pszLoadOrderGroup, 
                        NULL, _rgsubservice[dw].pszDependencies,
                        NULL, NULL);

                    if (hService)
                    {
                        SERVICE_DESCRIPTION sd;

                        sd.lpDescription = szDescription;

                        ChangeServiceConfig2(hService,
                            SERVICE_CONFIG_DESCRIPTION, &sd);

                        CloseServiceHandle(hService);

                        hres = _InstSetParameters(_rgste[dw].lpServiceName);

                        if (SUCCEEDED(hres))
                        {
                            hres = _InstSetSVCHostInfo(
                                _rgste[dw].lpServiceName);
                        }
                    }
                    else
                    {
                        if (ERROR_SERVICE_EXISTS == GetLastError())
                        {
                            // We had this problem on upgrade.  The service is
                            // already there, so CreateService fails.  As a result the
                            // StartType was not switched from Demand Start to Auto Start.
                            // The following lines will do just that.
                            // This code should be expanded for general upgraded cases.
                            // All the other values in the structure should be passed here.
                            hService = OpenService(hSCM,
                                _rgste[dw].lpServiceName, SERVICE_CHANGE_CONFIG);

                            if (hService)
                            {
                                if (ChangeServiceConfig(
                                    hService,           // handle to service
                                    SERVICE_NO_CHANGE,  // type of service
                                    dwStartType,        // when to start service
                                    SERVICE_NO_CHANGE,  // severity of start failure
                                    szCmd,              // service binary file name
                                    _rgsubservice[dw].pszLoadOrderGroup, // load ordering group name
                                    NULL,               // tag identifier
                                    NULL,               // array of dependency names
                                    NULL,               // account name
                                    NULL,               // account password
                                    NULL                // display name
                                    ))
                                {
                                    // Do this un upgrade too
                                    hres = _InstSetSVCHostInfo(
                                        _rgste[dw].lpServiceName);

                                    if (SUCCEEDED(hres))
                                    {
                                        hres = _InstSetParameters(_rgste[dw].lpServiceName);
                                    }
                                }
                                else
                                {
                                    hres = E_FAIL;
                                }

                                SERVICE_DESCRIPTION sd;

                                sd.lpDescription = szDescription;

                                ChangeServiceConfig2(hService,
                                    SERVICE_CONFIG_DESCRIPTION, &sd);

                                CloseServiceHandle(hService);
                            }

                        }
                        else
                        {
                            hres = E_FAIL;
                        }
                    }
                }
            }

            CloseServiceHandle(hSCM);
        }
 
        // We don't need the ShellCOMServer anymore, so let's nuke it away on upgrades
        _UnInstall(TEXT("ShellCOMServer"));
    
        // Also remove the following reg entry on upgrade
        _RegDeleteValue(HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\SvcHost"), TEXT("shsvc"));
    }

    return hres;    
}

// static
HRESULT CGenericServiceManager::DllAttach(HINSTANCE UNREF_PARAM(hinst))
{
    HRESULT hr;

    if (InitializeCriticalSectionAndSpinCount(&_csQueue, 0))
    {
        _fCritSectInit = TRUE;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

// static
HRESULT CGenericServiceManager::DllDetach()
{
    if (_fCritSectInit)
    {
        DeleteCriticalSection(&_csQueue);
        _fCritSectInit = FALSE;
    }            

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Private
// static
HRESULT CGenericServiceManager::_Init()
{
    ASSERT(ARRAYSIZE(_rgste) == (ARRAYSIZE(_rgsubservice) + 1));

    // Per thread
    return CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
}

// static
HRESULT CGenericServiceManager::_Cleanup()
{
    // Per thread
    CoUninitialize();

    return S_OK;
}

__inline void _TraceServiceCode(DWORD
#ifdef DEBUG
                                dwControl
#endif
                                )
{
#ifdef DEBUG
    LPWSTR pszControl = TEXT("Unknown");

    switch (dwControl)
    {
        case SERVICE_CONTROL_STOP: pszControl = TEXT("SERVICE_CONTROL_STOP"); break;
        case SERVICE_CONTROL_PAUSE: pszControl = TEXT("SERVICE_CONTROL_PAUSE"); break;
        case SERVICE_CONTROL_CONTINUE: pszControl = TEXT("SERVICE_CONTROL_CONTINUE"); break;
        case SERVICE_CONTROL_INTERROGATE: pszControl = TEXT("SERVICE_CONTROL_INTERROGATE"); break;
        case SERVICE_CONTROL_SHUTDOWN: pszControl = TEXT("SERVICE_CONTROL_SHUTDOWN"); break;
        case SERVICE_CONTROL_PARAMCHANGE: pszControl = TEXT("SERVICE_CONTROL_PARAMCHANGE"); break;
        case SERVICE_CONTROL_NETBINDADD: pszControl = TEXT("SERVICE_CONTROL_NETBINDADD"); break;
        case SERVICE_CONTROL_NETBINDREMOVE: pszControl = TEXT("SERVICE_CONTROL_NETBINDREMOVE"); break;
        case SERVICE_CONTROL_NETBINDENABLE: pszControl = TEXT("SERVICE_CONTROL_NETBINDENABLE"); break;
        case SERVICE_CONTROL_NETBINDDISABLE: pszControl = TEXT("SERVICE_CONTROL_NETBINDDISABLE"); break;
        case SERVICE_CONTROL_DEVICEEVENT: pszControl = TEXT("SERVICE_CONTROL_DEVICEEVENT"); break;
        case SERVICE_CONTROL_HARDWAREPROFILECHANGE: pszControl = TEXT("SERVICE_CONTROL_HARDWAREPROFILECHANGE"); break;
        case SERVICE_CONTROL_POWEREVENT: pszControl = TEXT("SERVICE_CONTROL_POWEREVENT"); break;
        case SERVICE_CONTROL_SESSIONCHANGE: pszControl = TEXT("SERVICE_CONTROL_SESSIONCHANGE"); break;
    }

    TRACE(TF_SERVICE, TEXT("Received Service Control code: %s (0x%08X)"),
        pszControl, dwControl);
#endif
}

///////////////////////////////////////////////////////////////////////////////
// Private
//static 
DWORD WINAPI CGenericServiceManager::_ServiceHandler(DWORD dwControl,
    DWORD dwEventType, LPVOID pvEventData, LPVOID lpContext)
{
    // We don't want to deny any request, so return NO_ERROR whatever happens
    DWORD dwRet = NO_ERROR;

    // This is called on the main thread not the thread of the specific
    // service, so keep it short and sweet
    SERVICEENTRY* pse = (SERVICEENTRY*)lpContext;

    if (pse)
    {
        BOOL fProcess = FALSE;
        BOOL fSynch = FALSE;
        HRESULT hres = S_OK;

        switch (dwControl)
        {
            case SERVICE_CONTROL_STOP:
            case SERVICE_CONTROL_SHUTDOWN:
                TRACE(TF_SERVICE, TEXT("Received SERVICE_CONTROL_SHUTDOWN or STOP, will skip all other terminating events"));

                if (!pse->_fSkipTerminatingEvents)
                {
                    fProcess = TRUE;
                    pse->_fSkipTerminatingEvents = TRUE;
                }
                else
                {
                    TRACE(TF_SERVICE, TEXT("Skipping terminating event"));
                }

                break;

            case SERVICE_CONTROL_INTERROGATE:
                // Special case SERVICE_CONTROL_INTERROGATE.  We don't really need the
                // IService impl to process this.  The service will also be more
                // responsive this way.  The state can be queried in the middle of
                // execution.
                TRACE(TF_SERVICE, TEXT("Received SERVICE_CONTROL_INTERROGATE"));

                _SetServiceStatus(pse);
                break;

            default:
                if (!pse->_fSkipTerminatingEvents)
                {
                    fProcess = TRUE;

                    hres = _EventNeedsToBeProcessedSynchronously(dwControl,
                        dwEventType, pvEventData, pse, &fSynch);
                }
                break;
        }

        if (SUCCEEDED(hres) && fProcess)
        {
            _TraceServiceCode(dwControl);

            EnterCriticalSection(&_csQueue);

            hres = _QueueEvent(pse, dwControl, dwEventType, pvEventData);

            if (SUCCEEDED(hres))
            {
                // Let the service process events
                SetEvent(pse->_hEventRelinquishControl);

                ResetEvent(pse->_hEventSynchProcessing);
            }

            LeaveCriticalSection(&_csQueue);

            if (SUCCEEDED(hres) && fSynch)
            {
                Sleep(0);

                TRACE(TF_SERVICE,
                    TEXT("=========== Processing SYNCHRONOUSLY ==========="));

                // We have to wait before we return... (at most 20 sec)
                DWORD dwWait = WaitForSingleObject(pse->_hEventSynchProcessing,
                   20000);

                if (WAIT_TIMEOUT == dwWait)
                {
                    TRACE(TF_SERVICE,
                        TEXT("=========== WAIT TIMED OUT ==========="));
                }

                TRACE(TF_SERVICE,
                    TEXT("=========== FINISHED processing SYNCHRONOUSLY ==========="));

#ifdef DEBUG
                // If we get the notifs from a windowproc, return TRUE,
                // or else we'll deny any request to remove, lock, ...
                if (!_fRunAsService)
                {
                    if (SERVICE_CONTROL_DEVICEEVENT == dwControl)
                    {
                        dwRet = TRUE;
                    }
                }
#endif
            }
        }
    }

    return dwRet;
}

//static
void WINAPI CGenericServiceManager::_ServiceMain(DWORD cArg, LPWSTR* ppszArgs)
{
    SERVICEENTRY* pse;
    LPCWSTR pszServiceName = *ppszArgs;

    HRESULT hres = _Init();

    if (SUCCEEDED(hres))
    {
        hres = _InitServiceEntry(pszServiceName, &pse);

        if (SUCCEEDED(hres))
        {
            hres = _RegisterServiceCtrlHandler(pszServiceName, pse);

            if (SUCCEEDED(hres))
            {
                pse->_servicestatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
                pse->_servicestatus.dwCurrentState = SERVICE_START_PENDING;

                _SetServiceStatus(pse);

                hres = _CreateIService(pszServiceName, &(pse->_pservice));

                if (SUCCEEDED(hres))
                {
                    hres = pse->_pservice->InitMinimum(cArg, ppszArgs,
                        pse->_szServiceEventName,
                        &(pse->_servicestatus.dwControlsAccepted),
                        &(pse->_fWantsDeviceEvents));

                    if (SUCCEEDED(hres))
                    {
                        hres = _HandleWantsDeviceEvents(pszServiceName,
                            pse->_fWantsDeviceEvents);

                        if (SUCCEEDED(hres))
                        {
                            if (pse->_fWantsDeviceEvents)
                            {
                                hres = pse->_pservice->InitDeviceEventHandler(
                                    pse->_ssh);
                            }

                            if (SUCCEEDED(hres))
                            {
                                pse->_servicestatus.dwCurrentState =
                                    SERVICE_RUNNING;

                                _SetServiceStatus(pse);

                                hres = pse->_pservice->InitFinal();

                                if (SUCCEEDED(hres))
                                {
                                    do
                                    {
                                        hres = pse->_pservice->Run();

                                        if (SUCCEEDED(hres))
                                        {
                                            // The service has finished its business or it
                                            // relinquished control because
                                            // _hEventRelinquishControl is set
                                            //
                                            // If it relinquished control because of a
                                            // service control event, then let's process it
                                            DWORD dwWait = WaitForSingleObject(
                                                pse->_hEventRelinquishControl,
                                                INFINITE);

                                            TRACE(TF_SERVICEDETAILED,
                                                TEXT("WaitForSingleObj returned with: 0x%08X"),
                                                dwWait);

                                            if (WAIT_OBJECT_0 == dwWait)
                                            {
                                                // Process all Service Control codes
                                                // received.
                                                hres = _ProcessServiceControlCodes(
                                                    pse);
                                            }
                                            else
                                            {
                                                hres = E_FAIL;
                                            }
                                        }
                                    }
                                    while (SUCCEEDED(hres) &&
                                        (SERVICE_STOPPED !=
                                        pse->_servicestatus.dwCurrentState));
                                }
                            }
                        }
                        // What do we do with hres?
                    }
                }
            }
            else
            {
#ifdef DEBUG
                TRACE(TF_SERVICEDETAILED,
                    TEXT("%s: _RegisterServiceCtrlHandler FAILED: 0x%08X"),
                    pse->_szServiceName, hres);
#endif
            }

            _CleanupServiceEntry(pse);
        }

        if (SUCCEEDED(hres) &&
            (SERVICE_STOPPED == pse->_servicestatus.dwCurrentState))
        {
            _SetServiceStatus(pse);
        }

        _Cleanup();
    }

    TRACE(TF_SERVICE, TEXT("Exiting _ServiceMain for Service: %s"), pszServiceName);
}

//static
HRESULT CGenericServiceManager::_ProcessServiceControlCodes(SERVICEENTRY* pse)
{
    HRESULT hres;
    BOOL fEndLoop = FALSE;

    TRACE(TF_SERVICEDETAILED, TEXT("Entered _ProcessServiceControlCodes"));

    do
    {
        CTRLEVENT*  pevent;

        EnterCriticalSection(&_csQueue);

        TRACE(TF_SERVICEDETAILED, TEXT("Entered _ProcessServiceControlCodes' Critical Section"));

        hres = _DeQueueEvent(pse, &pevent);

        TRACE(TF_SERVICE, TEXT("DeQueued Event: 0x%08X"), hres);

        if (!pse->_peventQueueHead)
        {
            ASSERT(!pse->_cEvents);

            fEndLoop = TRUE;

            ResetEvent(pse->_hEventRelinquishControl);
        }

        LeaveCriticalSection(&_csQueue);

        if (SUCCEEDED(hres))
        {
            ///////////////////////////////////////////////////////////////////
            // If we're here then we should have received some service control,
            // or the IService decided it had nothing more to process
            //
            TRACE(TF_SERVICEDETAILED, TEXT("Will call _HandleServiceControls (dwControl = 0x%08X)"),
                pevent->dwControl);

            hres = _HandleServiceControls(pse, pevent->dwControl, 
                pevent->dwEventType, (PVOID)(pevent->rgbEventData));

            if (SERVICE_CONTROL_DEVICEEVENT == pevent->dwControl)
            {
                // Never ever return something else than NO_ERROR (S_OK) for these
                hres = NO_ERROR;
            }

            TRACE(TF_SERVICE, TEXT("_HandleServiceControls returned: 0x%08X"), hres);

            LocalFree((HLOCAL)pevent);
        }

        if (fEndLoop)
        {
            TRACE(TF_SERVICEDETAILED, TEXT("Resetting RelinquishEvent"));

            SetEvent(pse->_hEventSynchProcessing);
        }
    }
    while (!fEndLoop && SUCCEEDED(hres));

    TRACE(TF_SERVICEDETAILED, TEXT("Exiting _ProcessServiceControlCodes"));

    return hres;
}

#pragma warning(push)
// FALSE positive below: fPending
#pragma warning(disable : 4701)
//static
HRESULT CGenericServiceManager::_HandleServiceControls(SERVICEENTRY* pse,
    DWORD dwControl, DWORD dwEventType, PVOID pvEventData)
{
    HRESULT hres = _HandlePreState(pse, dwControl);

    TRACE(TF_SERVICEDETAILED, TEXT("_HandlePreState returned: 0x%08X, status: 0x%08X"), hres,
        pse->_servicestatus.dwCurrentState);

    if (SUCCEEDED(hres))
    {
        if (S_OK == hres)
        {
            switch (dwControl)
            {
                case SERVICE_CONTROL_STOP:
                case SERVICE_CONTROL_PAUSE:
                case SERVICE_CONTROL_CONTINUE:
                case SERVICE_CONTROL_SHUTDOWN:
                {
                    BOOL fPending;

                    do
                    {
                        // This will return S_FALSE if it's pending
                        hres = pse->_pservice->HandleServiceControl(dwControl,
                            &(pse->_servicestatus.dwWaitHint));

                        if (SUCCEEDED(hres))
                        {
                            if (S_FALSE == hres)
                            {
                                ASSERT(pse->_servicestatus.dwWaitHint);

                                fPending = TRUE;
                            }
                            else
                            {
                                fPending = FALSE;
                            }

                            TRACE(TF_SERVICE, TEXT("Will call _HandlePostState (fPending = %d)"),
                                fPending);

                            hres = _HandlePostState(pse, dwControl, fPending);

                            TRACE(TF_SERVICE, TEXT("_HandlePostState returned: 0x%08X, status: 0x%08X"),
                                hres, pse->_servicestatus.dwCurrentState);
                        }
                    }
                    while (SUCCEEDED(hres) && fPending);

                    break;
                }

                case SERVICE_CONTROL_DEVICEEVENT:
                    TRACE(TF_SERVICE, TEXT("Received SERVICE_CONTROL_DEVICEEVENT"));

                    if (!(pse->_fSkipTerminatingEvents))
                    {
                        hres = pse->_pservice->HandleDeviceEvent(dwEventType,
                            pvEventData);
                    }
                    else
                    {
                        hres = S_OK;
                    }
                    
                    break;

                case SERVICE_CONTROL_SESSIONCHANGE:
                    TRACE(TF_SERVICE, TEXT("Received: SERVICE_CONTROL_SESSIONCHANGE"));

                    if (!(pse->_fSkipTerminatingEvents))
                    {
                        hres = pse->_pservice->HandleSessionChange(dwEventType, pvEventData);
                    }
                    else
                    {
                        hres = S_OK;
                    }

                    break;

                default:
                    TRACE(TF_SERVICE, TEXT("Received unhandled service control"));

                    hres = S_FALSE;
                    break;
            }
        }
    }

    return hres;
}
#pragma warning(pop)

// static
HRESULT CGenericServiceManager::_GetServiceIndex(LPCWSTR pszServiceName,
    DWORD* pdw)
{
    HRESULT hres = E_FAIL;

    ASSERT(pszServiceName);
    ASSERT(pdw);

    for (DWORD dw = 0; FAILED(hres) && (dw < _cste); ++dw)
    {
        if (!lstrcmp(pszServiceName, _rgste[dw].lpServiceName))
        {
            // Found it
            *pdw = dw;

            hres = S_OK;
        }
    }    

    return hres;
}

HRESULT CGenericServiceManager::_GetServiceCLSID(LPCWSTR pszServiceName,
    CLSID* pclsid)
{
    ASSERT(pszServiceName);
    ASSERT(pclsid);

    DWORD dw;
    HRESULT hres = _GetServiceIndex(pszServiceName, &dw);

    if (SUCCEEDED(hres))
    {
        // Found it
        hres = CLSIDFromProgID(_rgsubservice[dw].pszProgID, pclsid);
    }

    return hres;
}

HRESULT CGenericServiceManager::_CreateIService(LPCWSTR pszServiceName,
    IService** ppservice)
{
    CLSID clsid;
    HRESULT hres = _GetServiceCLSID(pszServiceName, &clsid);

    *ppservice = NULL;

    if (SUCCEEDED(hres))
    {
        hres = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
            IID_PPV_ARG(IService, ppservice));
    }

    return hres;
}

HRESULT CGenericServiceManager::_InitServiceEntry(LPCWSTR pszServiceName,
    SERVICEENTRY** ppse)
{
    DWORD dw;
    HRESULT hres = _GetServiceIndex(pszServiceName, &dw);

    if (SUCCEEDED(hres))
    {
        *ppse = &(_rgsubservice[dw].se);

        ZeroMemory(*ppse, sizeof(**ppse));

        // We use a GUID so that the name cannot be guessed and the event
        // spoofed.
        hres = _CreateGUID((*ppse)->_szServiceEventName,
            ARRAYSIZE((*ppse)->_szServiceEventName));

        if (SUCCEEDED(hres))
        {
            hres = SafeStrCatN((*ppse)->_szServiceEventName, pszServiceName,
                ARRAYSIZE((*ppse)->_szServiceEventName));
        }

        if (SUCCEEDED(hres))
        {
            (*ppse)->_hEventRelinquishControl = CreateEvent(NULL, TRUE, FALSE,
                (*ppse)->_szServiceEventName);

            if (!((*ppse)->_hEventRelinquishControl))
            {
                hres = E_FAIL;
            }

            if (SUCCEEDED(hres))
            {
                (*ppse)->_hEventSynchProcessing = CreateEvent(NULL, TRUE, TRUE,
                    NULL);

                if (!((*ppse)->_hEventSynchProcessing))
                {
                    hres = E_FAIL;
                }
            }

            if (FAILED(hres))
            {
                _CleanupServiceEntry(*ppse);
            }
        }
    }

    return hres;
}

HRESULT CGenericServiceManager::_CleanupServiceEntry(SERVICEENTRY* pse)
{
    if (pse->_pservice)
    {
        pse->_pservice->Release();
    }

    if (pse->_hEventRelinquishControl)
    {
        CloseHandle(pse->_hEventRelinquishControl);
    }

    if (pse->_hEventSynchProcessing)
    {
        CloseHandle(pse->_hEventSynchProcessing);
    }

    return S_OK;
}

//static
HRESULT CGenericServiceManager::_HandlePreState(SERVICEENTRY* pse,
    DWORD dwControl)
{
    HRESULT hres;
    BOOL fSetServiceStatus = TRUE;

    // _HandleServiceControls will loop until we are not in a pending state.
    // All incoming ctrl events are queued, and will be processed on this same
    // thread, so we should never enter this fct in a pending state.
    ASSERT(SERVICE_STOP_PENDING != pse->_servicestatus.dwCurrentState);
    ASSERT(SERVICE_START_PENDING != pse->_servicestatus.dwCurrentState);
    ASSERT(SERVICE_CONTINUE_PENDING != pse->_servicestatus.dwCurrentState);
    ASSERT(SERVICE_PAUSE_PENDING != pse->_servicestatus.dwCurrentState);

    // Should have been processed in _ServiceHandler
    ASSERT(SERVICE_CONTROL_INTERROGATE != dwControl);

    // We cleanup a bit.  If the request is incompatible with the current state
    // then we return S_FALSE to instruct _HandleServiceControls to not call
    // the IService impl for nothing.
    switch (dwControl)
    {
        case SERVICE_CONTROL_STOP:
            switch (pse->_servicestatus.dwCurrentState)
            {
                case SERVICE_STOPPED:
                    hres = S_FALSE;
                    break;

                case SERVICE_RUNNING:
                case SERVICE_PAUSED:
                default:
                    pse->_servicestatus.dwCurrentState = SERVICE_STOP_PENDING;
                    hres = S_OK;
                    break;
            }
            break;
        case SERVICE_CONTROL_PAUSE:
            ASSERT(SERVICE_STOPPED != pse->_servicestatus.dwCurrentState);

            switch (pse->_servicestatus.dwCurrentState)
            {
                case SERVICE_PAUSED:
                    hres = S_FALSE;
                    break;

                case SERVICE_STOPPED:
                    // Weird, think about it...
                    hres = S_FALSE;
                    break;

                case SERVICE_RUNNING:
                default:
                    pse->_servicestatus.dwCurrentState = SERVICE_PAUSE_PENDING;
                    hres = S_OK;
                    break;
            }
            break;
        case SERVICE_CONTROL_CONTINUE:
            ASSERT(SERVICE_STOPPED != pse->_servicestatus.dwCurrentState);

            switch (pse->_servicestatus.dwCurrentState)
            {
                case SERVICE_RUNNING:
                    hres = S_FALSE;
                    break;

                case SERVICE_STOPPED:
                    // Weird, think about it...
                    hres = S_FALSE;
                    break;

                case SERVICE_PAUSED:
                default:
                    pse->_servicestatus.dwCurrentState = SERVICE_CONTINUE_PENDING;
                    hres = S_OK;
                    break;
            }
            break;

        case SERVICE_CONTROL_SHUTDOWN:

            fSetServiceStatus = FALSE;

            hres = S_OK;
            break;

        case SERVICE_CONTROL_DEVICEEVENT:

            fSetServiceStatus = FALSE;

            if (pse->_fWantsDeviceEvents)
            {
                hres = S_OK;
            }
            else
            {
                hres = S_FALSE;
            }
            break;

        case SERVICE_CONTROL_SESSIONCHANGE:

            fSetServiceStatus = FALSE;

            hres = S_OK;
            
            break;

        default:
            hres = S_FALSE;
            break;
    }

    if (fSetServiceStatus)
    {
        _SetServiceStatus(pse);
    }

    return hres;
}

//static
HRESULT CGenericServiceManager::_HandlePostState(SERVICEENTRY* pse,
    DWORD dwControl, BOOL fPending)
{
    HRESULT hres = S_FALSE;

    // All incoming ctrl events are queued, and will be processed on this same
    // thread, so if we are pending, the dwControl should be compatible with
    // our current pending state.  We call _SetServiceStatus to update the
    // dwWaitHint.

    // We should already be in a pending state.  This should have been set
    // by _HandlePreState.  Just make sure of this.

    // Should have been processed in _ServiceHandler
    ASSERT(SERVICE_CONTROL_INTERROGATE != dwControl);

    switch (dwControl)
    {
        case SERVICE_CONTROL_STOP:
            ASSERT(SERVICE_STOP_PENDING == pse->_servicestatus.dwCurrentState);

            if (!fPending)
            {
                pse->_servicestatus.dwCurrentState = SERVICE_STOPPED;
            }

            break;

        case SERVICE_CONTROL_PAUSE:
            ASSERT(SERVICE_PAUSE_PENDING ==
                pse->_servicestatus.dwCurrentState);

            if (!fPending)
            {
                pse->_servicestatus.dwCurrentState = SERVICE_PAUSED;
            }

            break;

        case SERVICE_CONTROL_CONTINUE:
            ASSERT(SERVICE_CONTINUE_PENDING ==
                pse->_servicestatus.dwCurrentState);

            if (!fPending)
            {
                pse->_servicestatus.dwCurrentState = SERVICE_RUNNING;
            }

            break;

        case SERVICE_CONTROL_SHUTDOWN:
            ASSERT(!fPending);

            pse->_servicestatus.dwCurrentState = SERVICE_STOPPED;

            break;
    }

    if (SERVICE_STOPPED != pse->_servicestatus.dwCurrentState)
    {
        _SetServiceStatus(pse);
    }

    return hres;
}

// static
HRESULT CGenericServiceManager::_EventNeedsToBeProcessedSynchronously(
    DWORD dwControl, DWORD dwEventType, LPVOID pvEventData, SERVICEENTRY*,
    BOOL* pfBool)
{
    *pfBool = FALSE;

    if (SERVICE_CONTROL_DEVICEEVENT == dwControl)
    {
        if (pvEventData)
        {
            DEV_BROADCAST_HDR* dbhdr = (DEV_BROADCAST_HDR*)pvEventData;

            if (DBT_DEVTYP_HANDLE == dbhdr->dbch_devicetype)
            {
                if (DBT_DEVICEQUERYREMOVE == dwEventType)
                {
                    TRACE(TF_SERVICE, TEXT("Received DBT_DEVICEQUERYREMOVE"));

                    *pfBool = TRUE;
                }
                else
                {
                    if (DBT_CUSTOMEVENT == dwEventType)
                    {
                        DEV_BROADCAST_HANDLE* pdbh =
                            (DEV_BROADCAST_HANDLE*)dbhdr;

                        if ((GUID_IO_VOLUME_LOCK == pdbh->dbch_eventguid))
                        {
                            TRACE(TF_SERVICE, TEXT("------------Received GUID_IO_VOLUME_LOCK------------"));
                        }

                        if ((GUID_IO_VOLUME_LOCK_FAILED == pdbh->dbch_eventguid))
                        {
                            TRACE(TF_SERVICE, TEXT("------------Received GUID_IO_VOLUME_LOCK_FAILED------------"));
                        }

                        if ((GUID_IO_VOLUME_UNLOCK == pdbh->dbch_eventguid))
                        {
                            TRACE(TF_SERVICE, TEXT("------------Received GUID_IO_VOLUME_UNLOCK------------"));
                        }

                        if ((GUID_IO_VOLUME_LOCK == pdbh->dbch_eventguid) ||
                            (GUID_IO_VOLUME_LOCK_FAILED == pdbh->dbch_eventguid) ||
                            (GUID_IO_VOLUME_UNLOCK == pdbh->dbch_eventguid))
                        {
                            *pfBool = TRUE;
                        }
                    }
                }
            }
        }
    }

    return S_OK;
}

// static
HRESULT CGenericServiceManager::_MakeEvent(DWORD dwControl, DWORD dwEventType,
    PVOID pvEventData, CTRLEVENT** ppevent)
{
    HRESULT hres = S_OK;

    DWORD cbSize = sizeof(CTRLEVENT);
    CTRLEVENT* pevent;

    if (SERVICE_CONTROL_DEVICEEVENT == dwControl)
    {
        if (pvEventData)
        {
            cbSize += ((DEV_BROADCAST_HDR*)pvEventData)->dbch_size;
        }
    }

    pevent = (CTRLEVENT*)LocalAlloc(LPTR, cbSize);

    if (pevent)
    {
        // Payload
        pevent->dwControl = dwControl;
        pevent->dwEventType = dwEventType;

        *ppevent = pevent;

        if (cbSize > sizeof(CTRLEVENT))
        {
            if (pvEventData)
            {
                CopyMemory(pevent->rgbEventData, pvEventData,
                    cbSize - sizeof(CTRLEVENT));
            }
        }
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

// static
HRESULT CGenericServiceManager::_QueueEvent(SERVICEENTRY* pse, DWORD dwControl,
    DWORD dwEventType, PVOID pvEventData)
{
    CTRLEVENT* pevent;
    HRESULT hres = _MakeEvent(dwControl, dwEventType, pvEventData, &pevent);

    if (SUCCEEDED(hres))
    {
        // We add at tail, remove at head
        // Prev: closer to head
        // Next: closer to tail

        pevent->peventNext = NULL;

        if (pse->_peventQueueTail)
        {
            ASSERT(!(pse->_peventQueueTail->peventNext));
            pse->_peventQueueTail->peventNext = pevent;
        }

        pse->_peventQueueTail = pevent;

        if (!pse->_peventQueueHead)
        {
            pse->_peventQueueHead = pse->_peventQueueTail;
        }

#ifdef DEBUG
        ++(pse->_cEvents);

        if (1 == pse->_cEvents)
        {
            ASSERT(pse->_peventQueueHead == pse->_peventQueueTail);
        }
        else
        {
            if (0 == pse->_cEvents)
            {
                ASSERT(!pse->_peventQueueHead && !pse->_peventQueueTail);
            }
            else
            {
                ASSERT(pse->_peventQueueHead && pse->_peventQueueTail && 
                    (pse->_peventQueueHead != pse->_peventQueueTail));
            }
        }
#endif
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

// static
HRESULT CGenericServiceManager::_DeQueueEvent(SERVICEENTRY* pse,
    CTRLEVENT** ppevent)
{
    ASSERT(pse->_peventQueueHead);

    // We add at tail, remove at head
    // Prev: closer to head
    // Next: closer to tail

    CTRLEVENT* peventRet = pse->_peventQueueHead;
    CTRLEVENT* peventNewHead = peventRet->peventNext;

    // Any elem left after removing head?
    if (!peventNewHead)
    {   
        // No
        pse->_peventQueueTail = NULL;
    }

    pse->_peventQueueHead = peventNewHead;

    peventRet->peventNext = NULL;
    *ppevent = peventRet;

#ifdef DEBUG
    --(pse->_cEvents);

    if (1 == pse->_cEvents)
    {
        ASSERT(pse->_peventQueueHead == pse->_peventQueueTail);
    }
    else
    {
        if (0 == pse->_cEvents)
        {
            ASSERT(!pse->_peventQueueHead && !pse->_peventQueueTail);
        }
        else
        {
            ASSERT(pse->_peventQueueHead && pse->_peventQueueTail && 
                (pse->_peventQueueHead != pse->_peventQueueTail));
        }
    }
#endif

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\apidispatcher.h ===
//  --------------------------------------------------------------------------
//  Module Name: APIDispatcher.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class that handles API requests in the server on a separate thread. Each
//  thread is dedicated to respond to a single client. This is acceptable for
//  a lightweight server.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _APIDispatcher_
#define     _APIDispatcher_

#include "KernelResources.h"
#include "PortMessage.h"
#include "Queue.h"
#include "WorkItem.h"

//  forward decls
class   CAPIRequest; 

//  --------------------------------------------------------------------------
//  CAPIDispatchSync
//
//  Purpose [scotthan]:    
//
//      This class encapsulates the events that coordinate service shutdown.   

//      Note: We could have simply synchronized on the respective thread handles,
//      had we launched them ourselves.   Our architecture is based on
//      the worker thread pool, however, so we don't have access to thread handles.  
//      Hence, this class.
//
//      In our initial entrypoint, ServiceMain, we:
//      (1) Create the port and start polling it for requests.
//      (2) Once the polling loop exits, we wait for any pending 
//          SERVICE_CONTROL_STOP/SHUTDOWN request to complete.
//      (3) Destroy the CService object and the CAPIConnection object.
//  
//      When we get a SERVICE_CONTROL_STOP/SHUTDOWN request to our SCM entrypoint 
//      (CService::HandlerEx), we:
//      (1) Set the service status to SERVICE_STOP_PENDING. 
//      (2) Signal to all blocking LPC request handler threads that the service
//          is coming down.  This should cause them to exit gracefully and
//          come home.
//      (3) Send an API_GENERIC_STOP LPC request down the port telling it to quit. 
//          (note: this request succeeds only if it originates from within the service process.).  
//      (4) Wait for this API_GENERIC_STOP LPC request to complete, which means the 
//          LPC port is shut down and cleaned up
//      (5) Signal that the SERVICE_CONTROL_STOP/SHUTDOWN handler has finished up; it's
//          save to exit ServiceMain
//
//      In our API_GENERIC_STOP LPC request handler, we 
//      (1) Make our port deaf to new LPC requests.  
//          (note: this immediately releases the ServiceMain thread,
//          which drops out of its port polling loop and must wait for completion of the 
//          SERVICE_CONTROL_STOP/SHUTDOWN request on HandlerEx() before exiting.)
//      (2) Wait for the request queue to empty.
//      (3) Destroy the request queue and the port itself.
//      (4) Signal to the SERVICE_CONTROL_STOP/SHUTDOWN handler that we're done.
//
//      The three objects that use this class are CService, CAPIConnection, and CAPIDispatcher.
//      The CService instance owns the APIDispatcherSync class instance, and passes its address 
//      off to CAPIConnection, who in turn gives the pointer to each CAPIDispatcher it owns.
//      The object expires with its owning CService instance.
//
//  History:    2002-03-18  scotthan        created.
//  --------------------------------------------------------------------------
class CAPIDispatchSync
//  --------------------------------------------------------------------------
{
public:    
    CAPIDispatchSync();
    ~CAPIDispatchSync();

    //  Signals commencement of service stop sequence.
    static void SignalServiceStopping(CAPIDispatchSync* pds);
    //  Reports whether service is in stop sequence.
    static BOOL IsServiceStopping(CAPIDispatchSync* pds);
    //  Retrieves the service stopping event.
    static HANDLE GetServiceStoppingEvent(CAPIDispatchSync* pds);

    //  API request dispatch 'anti-semaphore', signals when no more requests
    //  are pending.   Each time a request is queued, DispatchEnter() is 
    //  called.   Each time a request is unqueued, DispatchLeave() is called
    static void  DispatchEnter(CAPIDispatchSync*);
    static void  DispatchLeave(CAPIDispatchSync*);

    //  Invoked by the CAPIConnection API_GENERIC_STOP handler to wait for 
    //  all outstanding LPC requests to come home and be dequeued.
    static DWORD WaitForZeroDispatches(CAPIDispatchSync* pds, DWORD dwTimeout);

    //  The CAPIConnection API_GENERIC_STOP handler calls this to signal 
    //  that the port has been shut down and cleaned up.
    static void  SignalPortShutdown(CAPIDispatchSync* pds);

    //  Invoked by CService::HandlerEx to await port cleanup.
    static DWORD WaitForPortShutdown(CAPIDispatchSync* pds, DWORD dwTimeout);

    //  CService::HandlerEx calls this to signal ServiceMain that the
    //  SERVICE_CONTROL_STOP/SHUTDOWN sequence has completed, and its safe to exit.
    static void  SignalServiceControlStop(CAPIDispatchSync* pds);

    //  Invoked by ServiceMain (in CService::Start) to wait for completion of
    //  the stop control process is done.   
    static DWORD WaitForServiceControlStop(CAPIDispatchSync* pds, DWORD dwTimeout);


    #define DISPATCHSYNC_TIMEOUT  60000

private:
    
    void Lock();
    void Unlock();

    CRITICAL_SECTION _cs;           // serializes signalling of events
    LONG             _cDispatches;  // count of outstanding asynchronous API request dispatches.
    

    //  Since we're architected based entirely on nt worker threads, 
    //  we have no thread handles to wait on.   Instead, we rely on the sequential 
    //  firing of the following events.   
    
    //  In chronologoical order of firing:
    HANDLE           _hServiceStopping;    // Signaled when service begins stop sequence.
    HANDLE           _hZeroDispatches;     // This is fired when API request queue is empty.  
                                           //   The API_GENERIC_STOP handler shuts down the port and 
                                           //   then waits on this before proceeding with queue destruction.
    HANDLE           _hPortShutdown;       // This is fired when the API_GENERIC_STOP handler is done 
                                           //   cleaning up the request queue.  The service's control SERVICE_CONTROL_STOP
                                           //   code path in HandlerEx waits on this before signalling
                                           //   _hServiceControlStop and returning to the SCM.
    HANDLE           _hServiceControlStop; // ServiceMain waits on this before completing shutdown by 
                                           //   destroying the CService instance and exiting.
};


//  --------------------------------------------------------------------------
//  CAPIDispatcher
//
//  Purpose:    This class processes requests from a client when signaled to.
//              CAPIDispatcher::QueueRequest is called by a thread which
//              monitors an LPC port. Once the request is queued an event is
//              signaled to wake the thread which processes client requests.
//              The thread processes all queued requests and wait for the
//              event to be signaled again.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CAPIDispatcher : public CWorkItem
{
    private:
        friend  class   CCatchCorruptor;

                                    CAPIDispatcher (void);
    public:
                                    CAPIDispatcher (HANDLE hClientProcess);
        virtual                     ~CAPIDispatcher (void);

                HANDLE              GetClientProcess (void)     const;
                DWORD               GetClientSessionID (void)   const;
                void                SetPort (HANDLE hPort);
                HANDLE              GetSection (void);
                void*               GetSectionAddress (void)    const;
                NTSTATUS            CloseConnection (void);
                NTSTATUS            QueueRequest (const CPortMessage& portMessage, CAPIDispatchSync* pAPIDispatchSync);
                NTSTATUS            ExecuteRequest (const CPortMessage& portMessage);
                NTSTATUS            RejectRequest (const CPortMessage& portMessage, NTSTATUS status)    const;
        virtual NTSTATUS            CreateAndQueueRequest (const CPortMessage& portMessage) = 0;
        virtual NTSTATUS            CreateAndExecuteRequest (const CPortMessage& portMessage) = 0;
    protected:
        virtual void                Entry (void);
                NTSTATUS            Execute (CAPIRequest *pAPIRequest)  const;
        virtual NTSTATUS            CreateSection (void);

                NTSTATUS            SignalRequestPending (void);
    private:
                NTSTATUS            SendReply (const CPortMessage& portMessage)     const;
#ifdef      DEBUG
        static  bool                ExcludedStatusCodeForDebug (NTSTATUS status);
#endif  /*  DEBUG   */
        static  LONG        WINAPI  DispatcherExceptionFilter (struct _EXCEPTION_POINTERS *pExceptionInfo);
    protected:
                HANDLE              _hSection;
                void*               _pSection;
                CQueue              _queue;
                CAPIDispatchSync*   _pAPIDispatchSync;
    private:
                HANDLE              _hProcessClient;
                HANDLE              _hPort;
                bool                _fRequestsPending,
                                    _fConnectionClosed;
                CCriticalSection    _lock;
};

#endif  /*  _APIDispatcher_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\apirequest.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: APIRequest.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class that uses multiple inheritence to allow a CPortMessage to be
//  included in a queue as a CQueueElement.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "APIRequest.h"

#include "StatusCode.h"

#define STRSAFE_LIB
#include <strsafe.h>

//  --------------------------------------------------------------------------
//  CAPIRequest::CAPIRequest
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher object to handle
//                                      this request.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CAPIRequest. Store a reference to the
//              CAPIDispatcher and add a reference to the object.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CAPIRequest::CAPIRequest (CAPIDispatcher* pAPIDispatcher) :
    CQueueElement(),
    CPortMessage(),
    _pAPIDispatcher(pAPIDispatcher)

{
    pAPIDispatcher->AddRef();
}

//  --------------------------------------------------------------------------
//  CAPIRequest::CAPIRequest
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher object to handle
//                                      this request.
//              portMessage         =   CPortMessage to copy construct.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CAPIRequest. Store a reference to the
//              CAPIDispatcher and add a reference to the object.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CAPIRequest::CAPIRequest (CAPIDispatcher* pAPIDispatcher, const CPortMessage& portMessage) :
    CQueueElement(),
    CPortMessage(portMessage),
    _pAPIDispatcher(pAPIDispatcher)

{
    pAPIDispatcher->AddRef();
}

//  --------------------------------------------------------------------------
//  CAPIRequest::~CAPIRequest
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CAPIRequest. Release the reference to the
//              CAPIDispatcher object.
//
//  History:    99-11-07    vtan        created
//  --------------------------------------------------------------------------

CAPIRequest::~CAPIRequest (void)

{
    _pAPIDispatcher->Release();
    _pAPIDispatcher = NULL;
}


//  --------------------------------------------------------------------------
//  _ValidateMappedClientString
//
//  Arguments:  pszMapped = String successfully mapped from the client memory space
//                          using _AllocAndMapClientString().
//              cchIn     = client's count of characters, including NULL.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Ensures that the length of the string is what the client said it was.
//
//  History:    2002-02-26  scotthan    created
//  --------------------------------------------------------------------------

NTSTATUS _ValidateMappedClientString( 
    IN LPCWSTR pszMapped,
    IN ULONG   cchIn )
{
    size_t   cch;
    
    //  note: cchIn includes the NULL terminus.
    return (SUCCEEDED(StringCchLengthW((LPWSTR)pszMapped, cchIn, &cch)) &&
            cchIn == (cch + 1)) ? STATUS_SUCCESS : STATUS_INVALID_PARAMETER;
}

//  --------------------------------------------------------------------------
//  _FreeMappedClientString
//
//  Arguments:  pszMapped = String successfully mapped from the client memory space
//                          using _AllocAndMapClientString().
//
//  Returns:    NTSTATUS
//
//  Purpose:    Release memory for mapped client string.
//
//  History:    2002-02-26  scotthan    created
//  --------------------------------------------------------------------------

void _FreeMappedClientString(IN LPWSTR pszMapped)
{
    delete [] pszMapped;
}

//  --------------------------------------------------------------------------
//  _AllocAndMapClientString
//
//  Arguments:  hProcessClient = client process handle
//              pszIn  = client's address of string
//              cchIn  = client's count of characters, including NULL.
//              cchMax = maximum allowed characters
//              ppszMapped = outbound mapped string.   Should be freed with _FreeClientString()
//
//  Returns:    NTSTATUS
//
//  Purpose:    Ensures that the length of the string is what the client said it was.
//
//  History:    2002-02-26  scotthan    created
//  --------------------------------------------------------------------------

NTSTATUS _AllocAndMapClientString( 
    IN HANDLE   hProcessClient,
    IN LPCWSTR  pszIn,
    IN UINT     cchIn,
    IN UINT     cchMax,
    OUT LPWSTR*  ppszMapped )
{
    NTSTATUS status;

    ASSERTMSG(ppszMapped != NULL, "_AllocAndMapClientString: NULL outbound parameter, LPWSTR*.");
    ASSERTMSG(hProcessClient != NULL, "_AllocAndMapClientString: NULL process handle.");

    *ppszMapped = NULL;

    if( pszIn && cchIn > 0 && cchIn <= cchMax )
    {
        LPWSTR pszMapped = new WCHAR[cchIn];
        if( pszMapped )
        {
            SIZE_T dwNumberOfBytesRead;
            if( ReadProcessMemory(hProcessClient, pszIn, pszMapped, cchIn * sizeof(WCHAR),
                                  &dwNumberOfBytesRead) )
            {
                status = _ValidateMappedClientString(pszMapped, cchIn);

                if( NT_SUCCESS(status) )
                {
                    *ppszMapped = pszMapped;
                }
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }

            if( !NT_SUCCESS(status) )
            {
                _FreeMappedClientString(pszMapped);
            }
        }
        else
        {
            status = STATUS_NO_MEMORY;
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\apidispatcher.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: APIDispatcher.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class that handles API requests in the server on a separate thread. Each
//  thread is dedicated to respond to a single client. This is acceptable for
//  a lightweight server.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "APIDispatcher.h"

#include "APIRequest.h"
#include "SingleThreadedExecution.h"
#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CAPIDispatcher::CAPIDispatcher
//
//  Arguments:  hClientProcess  =   HANDLE to the client process.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CAPIDispatcher. The handle to the client
//              process is transferred to this object.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CAPIDispatcher::CAPIDispatcher (HANDLE hClientProcess) :
    _hSection(NULL),
    _pSection(NULL),
    _hProcessClient(hClientProcess),
    _hPort(NULL),
    _fRequestsPending(false),
    _fConnectionClosed(false),
    _pAPIDispatchSync(NULL)
{
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::~CAPIDispatcher
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CAPIDispatcher. Release the port handle if
//              present. Release the process handle.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CAPIDispatcher::~CAPIDispatcher (void)

{
    ASSERTMSG(_fConnectionClosed, "Destructor invoked without connection being closed in CAPIDispatcher::~CAPIDispatcher");
    if (_pSection != NULL)
    {
        TBOOL(UnmapViewOfFile(_pSection));
        _pSection = NULL;
    }
    ReleaseHandle(_hSection);
    ReleaseHandle(_hPort);
    ReleaseHandle(_hProcessClient);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::GetClientProcess
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Returns the handle to the client process. This is not
//              duplicated. DO NOT CLOSE THIS HANDLE.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

HANDLE  CAPIDispatcher::GetClientProcess (void)     const

{
    return(_hProcessClient);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::GetClientSessionID
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Returns the client session ID.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

DWORD   CAPIDispatcher::GetClientSessionID (void)   const

{
    DWORD                           dwSessionID;
    ULONG                           ulReturnLength;
    PROCESS_SESSION_INFORMATION     processSessionInformation;

    if (NT_SUCCESS(NtQueryInformationProcess(_hProcessClient,
                                             ProcessSessionInformation,
                                             &processSessionInformation,
                                             sizeof(processSessionInformation),
                                             &ulReturnLength)))
    {
        dwSessionID = processSessionInformation.SessionId;
    }
    else
    {
        dwSessionID = 0;
    }
    return(dwSessionID);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::SetPort
//
//  Arguments:  hPort   =   Reply port received from
//                          ntdll!NtAcceptConnectionPort.
//
//  Returns:    <none>
//
//  Purpose:    Sets the given port handle into this object. The handle
//              ownership is transferred. Wait until the thread processing
//              requests is ready before returning.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

void    CAPIDispatcher::SetPort (HANDLE hPort)

{
    _hPort = hPort;
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::GetSection
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Returns a handle to a section used to communicate large
//              quantities of data from client to server. If the section has
//              not been created then create it.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CAPIDispatcher::GetSection (void)

{
    if (_hSection == NULL)
    {
        TSTATUS(CreateSection());
    }
    return(_hSection);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::GetSectionAddress
//
//  Arguments:  <none>
//
//  Returns:    void*
//
//  Purpose:    Returns the mapped address of the section.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

void*   CAPIDispatcher::GetSectionAddress (void)    const

{
    return(_pSection);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::CloseConnection
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Sets the member variable indicating the dispatcher's port has
//              been closed and that any pending requests are now invalid.
//              The object is reference counted so if there are any pending
//              requests they will release their reference when they're done.
//              The caller of this function releases its reference.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//              2000-11-08  vtan        reference counted object
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::CloseConnection (void)

{
    CSingleThreadedExecution    requestsPendingLock(_lock);

    _fConnectionClosed = true;
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::QueueRequest
//
//  Arguments:  portMessage     =   CPortMessage of request.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Checks if the connection has been closed. If closed then it
//              rejects the request. Otherwise it queues it.
//
//  History:    2000-12-02  vtan        created
//              2002-03-21  scotthan    Copy APIDispatchSync address,
//                                      update count of queued requests
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::QueueRequest (const CPortMessage& portMessage, CAPIDispatchSync* pAPIDispatchSync)

{
    NTSTATUS    status;

    if (_fConnectionClosed)
    {
        status = RejectRequest(portMessage, STATUS_PORT_DISCONNECTED);
    }
    else
    {
        //  Note: we should receive one and the same CAPIDispatchSync address for the lifetime
        //  of this CAPIDispatcher instance.   We do not own this pointer, but only maintain a copy.
#ifdef DEBUG
        if( NULL == _pAPIDispatchSync )
        {
#endif DEBUG

            _pAPIDispatchSync = pAPIDispatchSync;

#ifdef DEBUG
        }
        else
        {
            ASSERTBREAKMSG(pAPIDispatchSync == _pAPIDispatchSync, "CAPIDispatcher::QueueRequest - invalid APIDispatchSync");
        }
#endif DEBUG

        //  track this request queue.
        CAPIDispatchSync::DispatchEnter(_pAPIDispatchSync);
        
        status = CreateAndQueueRequest(portMessage);

        //  on failure to queue the request, remove counter reference.
        if( !NT_SUCCESS(status) )
        {
            CAPIDispatchSync::DispatchLeave(_pAPIDispatchSync);
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::ExecuteRequest
//
//  Arguments:  portMessage     =   CPortMessage of request.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Checks if the connection has been closed. If closed then it
//              rejects the request. Otherwise it executes it.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::ExecuteRequest (const CPortMessage& portMessage)
{
    NTSTATUS    status;

    if (_fConnectionClosed)
    {
        status = RejectRequest(portMessage, STATUS_PORT_DISCONNECTED);
    }
    else
    {
        status = CreateAndExecuteRequest(portMessage);
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::RejectRequest
//
//  Arguments:  portMessage     =   CPortMessage of request.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Sends back a reply to the caller STATUS_PORT_DISCONNECTED to
//              reject the request.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::RejectRequest (const CPortMessage& portMessage, NTSTATUS status)    const

{
    CPortMessage    portMessageOut(portMessage);

    //  Send the message back to the client.

    portMessageOut.SetDataLength(sizeof(NTSTATUS));
    portMessageOut.SetReturnCode(status);
    return(SendReply(portMessageOut));
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::Entry
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Main entry point for processing LPC requests. If there are
//              pending requests in the queue pick them off and process them.
//              While processing them more items can get queued. Keep
//              processing until there are no more queued items. There is a
//              possible overlap where a newly queued item can be missed. In
//              that case a new work item is queued to execute those requests.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//              2002-03-21  scotthan    Add queue synchronization via CAPIDispatchSynch.
//  --------------------------------------------------------------------------

void    CAPIDispatcher::Entry (void)

{
    CAPIRequest     *pAPIRequest;

    // artificial addref our dispatch sync to prevent us from signalling prematurely,
    //  before we can safely allow ourselves to be destroyed by our parent APIConnection.
    CAPIDispatchSync::DispatchEnter(_pAPIDispatchSync);  

    //  Acquire the requests pending lock before fetching the first
    //  request. This will ensure an accurate result.
    _lock.Acquire();
    pAPIRequest = static_cast<CAPIRequest*>(_queue.Get());

    //  If there are more requests in the queue keep looping.

    while (pAPIRequest != NULL)
    {

        //  Release the requests pending lock to allow more requests to
        //  get queued to this dispatcher while the dispatch is executing.

        if (!_fConnectionClosed)
        {
            NTSTATUS    status;

            //  Before executing the API request release the lock to allow
            //  more requests to get queued while executing this one.

            _lock.Release();

            //  Execute the request.

            status = Execute(pAPIRequest);

            //  Acquire the requests pending lock again before getting
            //  the next available request. If the loop continues the
            //  lock will be released at the top of the loop. If the loop
            //  exits then the lock must be released outside.

            _lock.Acquire();

            //  On debug builds ignore STATUS_REPLY_MESSAGE_MISMATCH.
            //  This typically happens on stress machines where timing
            //  causes the thread waiting on the reply to go away before
            //  the service has a chance to reply to the LPC request.

#ifdef      DEBUG
            if (!_fConnectionClosed && !ExcludedStatusCodeForDebug(status))
            {
                TSTATUS(status);
            }
#endif  /*  DEBUG   */

        }

        //  Remove this processed request.

        _queue.Remove();

        //  Decrement dispatch sync object.   The matching DispatchEnter() 
        //  took place at time of queuing, in CAPIDispatcher::QueueRequest().
        CAPIDispatchSync::DispatchLeave(_pAPIDispatchSync);

        //  Get the next request. A request may have been queued while
        //  processing the request just processed. So keep looping until
        //  there really are no requests left.

        pAPIRequest = static_cast<CAPIRequest*>(_queue.Get());
    }

    //  Set the state to no longer processing requests so that any
    //  further queued requests will cause the dispatcher to be
    //  re-invoked in a new worker thread. Release the lock.

    _fRequestsPending = false;
    _lock.Release();

    // remove defensive addref
    CAPIDispatchSync::DispatchLeave(_pAPIDispatchSync);  
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::Execute
//
//  Arguments:  pAPIRequest     =   API request to execute.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Execute the API request. This can be done from a queued work
//              item executing on a different thread or execute in the server
//              port listen thread.
//
//  History:    2000-10-19  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::Execute (CAPIRequest *pAPIRequest)  const

{
    
    NTSTATUS    status;

    //  Set the return data size to NTSTATUS by default. Execute the
    //  request. Store the result. If the executed function has more
    //  data to return it will set the size itself.

    pAPIRequest->SetDataLength(sizeof(NTSTATUS));

    //  Protect the execution with an exception block. If the code
    //  throws an exception it would normally just kill the worker
    //  thread. However, the CAPIDispatcher would be left in a state
    //  where it was marked as still executing requests even though
    //  the thread died. If an exception is thrown the function is
    //  considered unsuccessful.

    __try
    {
        status = pAPIRequest->Execute(_pAPIDispatchSync);
    }
    __except (DispatcherExceptionFilter(GetExceptionInformation()))
    {
        status = STATUS_UNSUCCESSFUL;
    }

    pAPIRequest->SetReturnCode(status);

    //  Reply to the client with the result.

    return(SendReply(*pAPIRequest));
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::CreateSection
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Overridable function that creates a section object. Because
//              size is not determinable it can be inheritable.
//
//              The default implementation does nothing.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::CreateSection (void)

{
    return(STATUS_NOT_IMPLEMENTED);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::SignalRequestPending
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Signals the event to wake up the thread processing requests.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::SignalRequestPending (void)

{
    NTSTATUS                    status;
    CSingleThreadedExecution    requestsPendingLock(_lock);

    //  Only check the validity of _fRequestsPending after acquiring the
    //  lock. This will guarantee that the value of this variable is
    //  100% correct in a multi worker threaded environment.

    if (!_fRequestsPending)
    {
        _fRequestsPending = true;
        status = Queue();
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::SendReply
//
//  Arguments:  portMessage     =   CPortMessage to send in the reply.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Sends a reply to the LPC port so the caller can be unblocked.
//
//  History:    2000-10-19  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::SendReply (const CPortMessage& portMessage)     const

{
    return(NtReplyPort(_hPort, const_cast<PORT_MESSAGE*>(portMessage.GetPortMessage())));
}

#ifdef      DEBUG

//  --------------------------------------------------------------------------
//  CAPIDispatcher::ExcludedStatusCodeForDebug
//
//  Arguments:  status  =   NTSTATUS code to check.
//
//  Returns:    bool
//
//  Purpose:    Returns whether this status code should be ignored on asserts.
//
//  History:    2001-03-30  vtan        created
//  --------------------------------------------------------------------------

bool    CAPIDispatcher::ExcludedStatusCodeForDebug (NTSTATUS status)

{
    return((status == STATUS_REPLY_MESSAGE_MISMATCH) ||
           (status == STATUS_INVALID_CID));
}

#endif  /*  DEBUG   */

//  --------------------------------------------------------------------------
//  CAPIDispatcher::DispatcherExceptionFilter
//
//  Arguments:  <none>
//
//  Returns:    LONG
//
//  Purpose:    Filters exceptions that occur when dispatching API requests.
//
//  History:    2000-10-13  vtan        created
//  --------------------------------------------------------------------------

LONG    WINAPI  CAPIDispatcher::DispatcherExceptionFilter (struct _EXCEPTION_POINTERS *pExceptionInfo)

{
    (LONG)RtlUnhandledExceptionFilter(pExceptionInfo);
    return(EXCEPTION_EXECUTE_HANDLER);
}



//  --------------------------------------------------------------------------
//  CAPIDispatchSync impl
//  History:    2002-03-18  scotthan        created.
//  --------------------------------------------------------------------------

//  --------------------------------------------------------------------------
CAPIDispatchSync::CAPIDispatchSync()
    :     _cDispatches(0)
        , _hServiceStopping(NULL)
        , _hZeroDispatches(NULL)
        , _hPortShutdown(NULL)
        , _hServiceControlStop(NULL)
{
    if( !InitializeCriticalSectionAndSpinCount(&_cs, 0) )
    {
        ZeroMemory(&_cs, sizeof(_cs));
    }
    
    _hServiceStopping    = CreateEvent(NULL, TRUE  /* manual-rest */, FALSE /* unsignalled */, NULL);
    _hZeroDispatches     = CreateEvent(NULL, TRUE  /* manual-rest */, TRUE  /* signalled */,   NULL);
    _hPortShutdown       = CreateEvent(NULL, FALSE /* auto-reset */,  FALSE /* unsignalled */, NULL);
    _hServiceControlStop = CreateEvent(NULL, FALSE /* auto-reset */,  FALSE /* unsignalled */, NULL);
}

//  --------------------------------------------------------------------------
CAPIDispatchSync::~CAPIDispatchSync()
{
    HANDLE h;

    h = _hServiceStopping;
    _hServiceStopping = NULL;
    if( h )
    {
        CloseHandle(h);
    }

    h = _hZeroDispatches;
    _hZeroDispatches = NULL;
    if( h )
    {
        CloseHandle(h);
    }

    h = _hPortShutdown;
    _hPortShutdown = NULL;
    if( h )
    {
        CloseHandle(h);
    }

    h = _hServiceControlStop;
    _hServiceControlStop = NULL;
    if( h )
    {
        CloseHandle(h);
    }

    
    if( _cs.DebugInfo )
    {
        DeleteCriticalSection(&_cs);
    }
}

//  --------------------------------------------------------------------------
void CAPIDispatchSync::SignalServiceStopping(CAPIDispatchSync* pds)
{
    if( pds )
    {
        pds->Lock();
        if( pds->_hServiceStopping )
        {
            SetEvent(pds->_hServiceStopping);
        }
        pds->Unlock();
    }
}

//  --------------------------------------------------------------------------
BOOL CAPIDispatchSync::IsServiceStopping(CAPIDispatchSync* pds)
{
    BOOL fRet = FALSE;
    if( pds )
    {
        if( pds->_hServiceStopping )
        {
            fRet = (WaitForSingleObject(pds->_hPortShutdown, 0) != WAIT_TIMEOUT);
        }
    }
    return fRet;
}

//  --------------------------------------------------------------------------
HANDLE CAPIDispatchSync::GetServiceStoppingEvent(CAPIDispatchSync* pds)
{
    return pds ? pds->_hServiceStopping : NULL;
}

//  --------------------------------------------------------------------------
void CAPIDispatchSync::DispatchEnter(CAPIDispatchSync* pds)
{
    if( pds )
    {
        pds->Lock();
        if( (++(pds->_cDispatches) > 0) && pds->_hZeroDispatches )
        {
            ResetEvent(pds->_hZeroDispatches);
        }
        pds->Unlock();
    }
}

//  --------------------------------------------------------------------------
void CAPIDispatchSync::DispatchLeave(CAPIDispatchSync* pds)
{
    if( pds )
    {
        pds->Lock();
        if( (--(pds->_cDispatches) == 0) && pds->_hZeroDispatches )
        {
            SetEvent(pds->_hZeroDispatches);
        }
        ASSERTMSG(pds->_cDispatches >= 0, "CAPIDispatchSync::Leave - refcount < 0: Mismatched Enter/Leave");
        pds->Unlock();
    }
}

//  --------------------------------------------------------------------------
DWORD CAPIDispatchSync::WaitForZeroDispatches(CAPIDispatchSync* pds, DWORD dwTimeout)
{
    if( pds )
    {
        if( pds->_hZeroDispatches )
        {
            return WaitForSingleObject(pds->_hZeroDispatches, dwTimeout);
        }
    }
    return WAIT_ABANDONED;
}

//  --------------------------------------------------------------------------
void CAPIDispatchSync::SignalPortShutdown(CAPIDispatchSync* pds)
{
    if( pds )
    {
        pds->Lock();
        if( pds->_hPortShutdown )
        {
            SetEvent(pds->_hPortShutdown);
        }
        pds->Unlock();
    }
}

//  --------------------------------------------------------------------------
DWORD CAPIDispatchSync::WaitForPortShutdown(CAPIDispatchSync* pds, DWORD dwTimeout)
{
    if( pds )
    {
        if( pds->_hPortShutdown )
        {
            return WaitForSingleObject(pds->_hPortShutdown, dwTimeout);
        }
    }
    return WAIT_ABANDONED;
}

//  --------------------------------------------------------------------------
void CAPIDispatchSync::SignalServiceControlStop(CAPIDispatchSync* pds)
{
    if( pds )
    {
        pds->Lock();
        if( pds->_hServiceControlStop )
        {
            SetEvent(pds->_hServiceControlStop);
        }
        pds->Unlock();
    }
}

//  --------------------------------------------------------------------------
DWORD CAPIDispatchSync::WaitForServiceControlStop(CAPIDispatchSync* pds, DWORD dwTimeout)
{
    if( pds )
    {
        if( pds->_hServiceControlStop )
        {
            return WaitForSingleObject(pds->_hServiceControlStop, dwTimeout);
        }
    }
    return WAIT_ABANDONED;
}
//  --------------------------------------------------------------------------
void CAPIDispatchSync::Lock()
{
    if( _cs.DebugInfo )
    {
        EnterCriticalSection(&_cs);
    }
}

//  --------------------------------------------------------------------------
void CAPIDispatchSync::Unlock()
{
    if( _cs.DebugInfo )
    {
        LeaveCriticalSection(&_cs);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\apirequest.h ===
//  --------------------------------------------------------------------------
//  Module Name: APIRequest.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class that uses multiple inheritence to allow a CPortMessage to be
//  included in a queue as a CQueueElement.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//              2002-03-24  scotthan    propagate DispatchSync to API request instance.
//  --------------------------------------------------------------------------

#ifndef     _APIRequest_
#define     _APIRequest_

#include "APIDispatcher.h"
#include "PortMessage.h"
#include "Queue.h"

//  --------------------------------------------------------------------------
//  CAPIRequest
//
//  Purpose:    This class combines CPortMessage and CQueueElement to allow
//              the PORT_MESSAGE struct in CPortMessage to be used in a queue.
//              This allows the server to queue requests to the thread that
//              is handling the client.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//              2002-02-24  scotthan    Propagate DispatchSync arg
//  --------------------------------------------------------------------------

class   CAPIRequest : public CQueueElement, public CPortMessage
{
    private:
                                    CAPIRequest (void);
    public:
                                    CAPIRequest (CAPIDispatcher* pAPIDispatcher);
                                    CAPIRequest (CAPIDispatcher* pAPIDispatcher, const CPortMessage& portMessage);

        virtual                     ~CAPIRequest (void);

        virtual NTSTATUS            Execute (CAPIDispatchSync* pAPIDispatchSync) = 0;
    protected:
                CAPIDispatcher*     _pAPIDispatcher;
};

//  --------------------------------------------------------------------------
//  _AllocAndMapClientString
//
//  Arguments:  hProcessClient = client process handle
//              pszIn  = client's address of string
//              cchIn  = client's count of characters, including NULL.
//              cchMax = maximum allowed characters
//              ppszMapped = outbound mapped string.   Should be freed with _FreeClientString()
//
//  Returns:    NTSTATUS
//
//  Purpose:    Ensures that the length of the string is what the client said it was.
//
//  History:    2002-02-26  scotthan    created
//  --------------------------------------------------------------------------
NTSTATUS _AllocAndMapClientString( 
    IN HANDLE   hProcessClient,
    IN LPCWSTR  pszIn,
    IN UINT     cchIn,
    IN UINT     cchMax,
    OUT LPWSTR*  ppszMapped );

//  --------------------------------------------------------------------------
//  _FreeMappedClientString
//
//  Arguments:  pszMapped = String successfully mapped from the client memory space
//                          using _AllocAndMapClientString().
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases memory for mapped client string.
//
//  History:    2002-02-26  scotthan    created
//  --------------------------------------------------------------------------
void _FreeMappedClientString(IN LPWSTR pszMapped);


#endif  /*  _APIRequest_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\queue.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Queue.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file contains a class to handle a queue element and a class to handle
//  a queue of queue elements.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "Queue.h"

#include "SingleThreadedExecution.h"

//  --------------------------------------------------------------------------
//  CQueueElement::CQueueElement
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CQueueElement.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CQueueElement::CQueueElement (void) :
    _pNextElement(NULL)

{
}

//  --------------------------------------------------------------------------
//  CQueueElement::~CQueueElement
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CQueueElement.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CQueueElement::~CQueueElement (void)

{
}

//  --------------------------------------------------------------------------
//  CQueue::CQueue
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CQueue.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CQueue::CQueue (void) :
    _pQueue(NULL)

{
}

//  --------------------------------------------------------------------------
//  CQueue::~CQueue
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CQueue.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CQueue::~CQueue (void)

{
    while (_pQueue != NULL)
    {
        CQueueElement   *pNextElement;

        pNextElement = _pQueue->_pNextElement;
        delete _pQueue;
        _pQueue = pNextElement;
    }
}

//  --------------------------------------------------------------------------
//  CQueue::Add
//
//  Arguments:  pQueueElement   =   CQueueElement to add to the queue.
//
//  Returns:    <none>
//
//  Purpose:    Adds the CQueueElement to the queue. Queue manipulation is
//              guarded by a critical section because one thread may be
//              queuing elements while another thread is processesing them.
//
//              You must provide a dynamically created CQueueElement object.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

void    CQueue::Add (CQueueElement *pQueueElement)

{
    if (pQueueElement != NULL)
    {
        CQueueElement               *pCurrentElement, *pLastElement;
        CSingleThreadedExecution    queueLock(_lock);

        pLastElement = pCurrentElement = _pQueue;
        while (pCurrentElement != NULL)
        {
            pLastElement = pCurrentElement;
            pCurrentElement = pCurrentElement->_pNextElement;
        }
        if (pLastElement != NULL)
        {
            pLastElement->_pNextElement = pQueueElement;
        }
        else
        {
            _pQueue = pQueueElement;
        }
    }
}

//  --------------------------------------------------------------------------
//  CQueue::Remove
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Removes the first element from the queue. The queue is a
//              standard FIFO structure. The CQueueElement is deleted. There
//              is no reference counting because these are internal items.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

void    CQueue::Remove (void)

{
    CSingleThreadedExecution    queueLock(_lock);

    if (_pQueue != NULL)
    {
        CQueueElement   *pNextElement;

        pNextElement = _pQueue->_pNextElement;
        delete _pQueue;
        _pQueue = pNextElement;
    }
}

//  --------------------------------------------------------------------------
//  CQueue::Get
//
//  Arguments:  <none>
//
//  Returns:    CQueueElement*
//
//  Purpose:    Returns the first CQueueElement in the queue.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CQueueElement*  CQueue::Get (void)  const

{
    return(_pQueue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\queue.h ===
//  --------------------------------------------------------------------------
//  Module Name: Queue.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file contains a class to handle a queue element and a class to handle
//  a queue of queue elements.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _Queue_
#define     _Queue_

#include "DynamicObject.h"
#include "KernelResources.h"

//  --------------------------------------------------------------------------
//  CQueueElement
//
//  Purpose:    This is the queue element base class. It contains a field
//              which the queue manages.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CQueueElement : public CDynamicObject
{
    private:
        friend  class   CQueue;
    public:
                                    CQueueElement (void);
        virtual                     ~CQueueElement (void);
    private:
                CQueueElement*      _pNextElement;
};

//  --------------------------------------------------------------------------
//  CQueue
//
//  Purpose:    This is the queue manager class. It manages queue elements.
//              Because the queue may be called from two threads that act on
//              the same object (one thread reads the queue to process
//              requests and the other adds to the queue to queue requests)
//              a critical section is required to process queue manipulation.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CQueue
{
    public:
                                    CQueue (void);
                                    ~CQueue (void);

                void                Add (CQueueElement *pQueueElement);
                void                Remove (void);
                CQueueElement*      Get (void)  const;
    private:
                CQueueElement*      _pQueue;
                CCriticalSection    _lock;
};

#endif  /*  _Queue_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\portmessage.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: PortMessage.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class to wrap a PORT_MESSAGE struct within an object. It contains space
//  for PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(PORT_MESSAGE) bytes of data. Subclass 
//  this class to write typed functions that access this data. Otherwise use
//  CPortMessage::GetData and type case the pointer returned.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "PortMessage.h"

#include "LPCGeneric.h"

//  --------------------------------------------------------------------------
//  CPortMessage::CPortMessage
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CPortMessage. Zero the memory.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CPortMessage::CPortMessage (void)

{
    ZeroMemory(&_portMessage, sizeof(_portMessage));
    ZeroMemory(_data, sizeof(_data));
}

//  --------------------------------------------------------------------------
//  CPortMessage::CPortMessage
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Copy constructor for CPortMessage. Copies the given
//              CPortMessage and all the data in it to the member variable.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CPortMessage::CPortMessage (const CPortMessage& portMessage) :
    _portMessage(*portMessage.GetPortMessage())

{
    CSHORT sDataSize = portMessage.GetDataLength();
    ASSERTMSG(sDataSize <= sizeof(_data), "Impending heap corruption (illegal PORT_MESSAGE) in CPortMessage::CPortMessage");

    if (sDataSize <= sizeof(_data))
    {
        CopyMemory(_data, portMessage.GetPortMessage() + 1, sDataSize);
    }
    else
    {
        // If the source object is corrupted, ignore its data
        _portMessage.u1.s1.DataLength = 0;
        _portMessage.u1.s1.TotalLength = sizeof(PORT_MESSAGE);
    }
}

//  --------------------------------------------------------------------------
//  CPortMessage::~CPortMessage
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CPortMessage.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CPortMessage::~CPortMessage (void)

{
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetPortMessage
//
//  Arguments:  <none>
//
//  Returns:    const PORT_MESSAGE*
//
//  Purpose:    Returns a pointer to the PORT_MESSAGE struct for const
//              objects.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

const PORT_MESSAGE*     CPortMessage::GetPortMessage (void)               const

{
    return(&_portMessage);
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetPortMessage
//
//  Arguments:  <none>
//
//  Returns:    const PORT_MESSAGE*
//
//  Purpose:    Returns a pointer to the PORT_MESSAGE struct for non-const
//              objects.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

PORT_MESSAGE*   CPortMessage::GetPortMessage (void)

{
    return(&_portMessage);
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetData
//
//  Arguments:  <none>
//
//  Returns:    const char*
//
//  Purpose:    Returns a pointer to the data area for const objects.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

const char*     CPortMessage::GetData (void)                      const

{
    return(_data);
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetData
//
//  Arguments:  <none>
//
//  Returns:    char*
//
//  Purpose:    Returns a pointer to the data area for non-const objects.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

char*     CPortMessage::GetData (void)

{
    return(_data);
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetDataLength
//
//  Arguments:  <none>
//
//  Returns:    CSHORT
//
//  Purpose:    Returns the length of the data sent in the PORT_MESSAGE.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CSHORT  CPortMessage::GetDataLength (void)                const

{
    return(_portMessage.u1.s1.DataLength);
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetType
//
//  Arguments:  <none>
//
//  Returns:    CSHORT
//
//  Purpose:    Returns the type of message sent in the PORT_MESSAGE.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CSHORT  CPortMessage::GetType (void)                      const

{
    #pragma warning (disable:4310)
    return(static_cast<CSHORT>(_portMessage.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE));
    #pragma warning (default:4310)
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetUniqueProcess
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Returns the process ID of the client process sent in the
//              PORT_MESSAGE.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

HANDLE  CPortMessage::GetUniqueProcess (void)             const

{
    return(_portMessage.ClientId.UniqueProcess);
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetUniqueThread
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Returns the thread ID of the client process sent in the
//              PORT_MESSAGE.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

HANDLE  CPortMessage::GetUniqueThread (void)              const

{
    return(_portMessage.ClientId.UniqueThread);
}

//  --------------------------------------------------------------------------
//  CPortMessage::SetReturnCode
//
//  Arguments:  status  =   NTSTATUS to send back to client.
//
//  Returns:    <none>
//
//  Purpose:    Sets the return NTSTATUS code in the PORT_MESSAGE to send
//              back to the client.
//
//  History:    1999-11-12  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

void    CPortMessage::SetReturnCode (NTSTATUS status)

{
    reinterpret_cast<API_GENERIC*>(&_data)->status = status;
}

//  --------------------------------------------------------------------------
//  CPortMessage::SetData
//
//  Arguments:  pData       =   Pointer to data passed in.
//              ulDataSize  =   Size of data passed in.
//
//  Returns:    <none>
//
//  Purpose:    Copies the given data to the port message buffer that follows
//              the PORT_MESSAGE struct and set the PORT_MESSAGE sizes to
//              match the data size.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

void    CPortMessage::SetData (const void *pData, CSHORT sDataSize)

{
    ASSERTMSG(sDataSize <= sizeof(_data), "Too much data passed to CPortMessage::SetData");

    if (sDataSize <= sizeof(_data))
    {
        CopyMemory(_data, pData, sDataSize);
        _portMessage.u1.s1.DataLength = sDataSize;
        _portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(PORT_MESSAGE) + sDataSize);
    }
}

//  --------------------------------------------------------------------------
//  CPortMessage::SetDataLength
//
//  Arguments:  ulDataSize  =   Size of data.
//
//  Returns:    <none>
//
//  Purpose:    Set the PORT_MESSAGE sizes to match the data size.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

void    CPortMessage::SetDataLength (CSHORT sDataSize)

{
    ASSERTMSG(sDataSize <= sizeof(_data), "Length too large in CPortMessage::SetDataLength");
    if (sDataSize <= sizeof(_data))
    {
        _portMessage.u1.s1.DataLength = sDataSize;
        _portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(PORT_MESSAGE) + sDataSize);
    }
}

//  --------------------------------------------------------------------------
//  CPortMessage::OpenClientToken
//
//  Arguments:  hToken  =   HANDLE to the token of the client.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Gets the token of the client. This can be the thread
//              impersonation token, the process primary token or failure.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CPortMessage::OpenClientToken (HANDLE& hToken)    const

{
    NTSTATUS            status;
    HANDLE              hThread;
    OBJECT_ATTRIBUTES   objectAttributes;
    CLIENT_ID           clientID;

    hToken = NULL;
    InitializeObjectAttributes(&objectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);
    clientID.UniqueProcess = NULL;
    clientID.UniqueThread = GetUniqueThread();
    status = NtOpenThread(&hThread, THREAD_QUERY_INFORMATION, &objectAttributes, &clientID);
    if (NT_SUCCESS(status))
    {
        (NTSTATUS)NtOpenThreadToken(hThread, TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY, FALSE, &hToken);
        TSTATUS(NtClose(hThread));
    }
    if (hToken == NULL)
    {
        HANDLE  hProcess;

        clientID.UniqueProcess = GetUniqueProcess();
        clientID.UniqueThread = NULL;
        status = NtOpenProcess(&hProcess, PROCESS_QUERY_INFORMATION, &objectAttributes, &clientID);
        if (NT_SUCCESS(status))
        {
            (NTSTATUS)NtOpenProcessToken(hProcess, TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY, &hToken);
        }
        TSTATUS(NtClose(hProcess));
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\portmessage.h ===
//  --------------------------------------------------------------------------
//  Module Name: PortMessage.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class to wrap a PORT_MESSAGE struct within an object. It contains space
//  for PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(PORT_MESSAGE) bytes of data. Subclass 
//  this class to write typed functions that access this data. Otherwise use
//  CPortMessage::GetData and type case the pointer returned.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _PortMessage_
#define     _PortMessage_

//  --------------------------------------------------------------------------
//  CPortMessage
//
//  Purpose:    This class wraps a PORT_MESSAGE structure. Subclass it to
//              write functions that access the internal data.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CPortMessage
{
    public:
                                CPortMessage (void);
                                CPortMessage (const CPortMessage& portMessage);
        virtual                 ~CPortMessage (void);
    public:
        const PORT_MESSAGE*     GetPortMessage (void)               const;
        PORT_MESSAGE*           GetPortMessage (void);
        const char*             GetData (void)                      const;
        char*                   GetData (void);

        CSHORT                  GetDataLength (void)                const;
        CSHORT                  GetType (void)                      const;
        HANDLE                  GetUniqueProcess (void)             const;
        HANDLE                  GetUniqueThread (void)              const;

        void                    SetReturnCode (NTSTATUS status);
        void                    SetData (const void *pData, CSHORT sDataSize);
        void                    SetDataLength (CSHORT sDataSize);

        NTSTATUS                OpenClientToken (HANDLE& hToken)    const;
    protected:
        PORT_MESSAGE            _portMessage;
        char                    _data[PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(PORT_MESSAGE)];
};

#endif  /*  _PortMessage_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\workitem.h ===
//  --------------------------------------------------------------------------
//  Module Name: WorkItem.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements the handling of queuing a work item and calling the
//  entry point of the work item function when entered in a worker thread.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _WorkItem_
#define     _WorkItem_

#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CWorkItem
//
//  Purpose:    A class to hide the work of queuing a work item to a worker
//              thread for execution.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CWorkItem : public CCountedObject
{
    public:
                                CWorkItem (void);
        virtual                 ~CWorkItem (void);

                NTSTATUS        Queue (void);
    protected:
        virtual void            Entry (void) = 0;
    private:
        static  DWORD   WINAPI  WorkItemEntryProc (void *pParameter);
};

#endif  /*  _WorkItem_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\service.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Service.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements generic portions of a Win32
//  serivce.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#define STRSAFE_LIB
#include <strsafe.h>

#include "Service.h"

#include "RegistryResources.h"
#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CService::CService
//
//  Arguments:  pAPIConnection  =   CAPIConnection used to implement service.
//              pServerAPI      =   CServerAPI used to stop service.
//              pszServiceName  =   Name of service.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CService.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CService::CService (CAPIConnection *pAPIConnection, CServerAPI *pServerAPI, const TCHAR *pszServiceName) :
    _hService(NULL),
    _pszServiceName(pszServiceName),
    _pAPIConnection(pAPIConnection),
    _pServerAPI(pServerAPI),
    _pAPIDispatchSync(NULL)
{
    CopyMemory(_szTag, CSVC_TAG, CB_CSVC_TAG);

    ZeroMemory(&_serviceStatus, sizeof(_serviceStatus));
    pAPIConnection->AddRef();
    pServerAPI->AddRef();
}

//  --------------------------------------------------------------------------
//  CService::~CService
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CService. Release used resources.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CService::~CService (void)

{
    CopyMemory(_szTag, DEAD_CSVC_TAG, CB_CSVC_TAG);

    _pServerAPI->Release();
    _pServerAPI = NULL;
    _pAPIConnection->Release();
    _pAPIConnection = NULL;

    delete _pAPIDispatchSync;
    _pAPIDispatchSync = NULL;

    ASSERTMSG(_hService == NULL, "_hService should be released in CService::~CService");
}

//  --------------------------------------------------------------------------
//  CService::IsValid
//
//  Arguments:  address of CService instance
//
//  Returns:    <none>
//
//  Purpose:    Reports whether the specified address points to a valid
//              CService object.
//
//              Found that there are cases when SCM launches a thread to
//              interrogate the service (SERVICE_CONTROL_INTERROGATE) when
//              trying to restart a CService who has already been deleted, but
//              whose status has not yet gone from STOP_PENDING to STOPPED.   
//
//              This is unavoidable because SCM will dump the service process once
//              STOPPED, not giving us a chance to delete the CService.  Thus
//              we assign STOPPED as late as possible.
//
//  History:    2002-03-21  scotthan        created
//  --------------------------------------------------------------------------
BOOL CService::IsValid(CService* pService)
{
    return pService ? 
        (0 == memcmp(pService->_szTag, CSVC_TAG, CB_CSVC_TAG)) : 
        FALSE;
}

//  --------------------------------------------------------------------------
//  CService::Start
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Called from ServiceMain of the service. This registers the
//              handler and starts the service (listens to the API port).
//              When the listen call returns it sets the status of the service
//              as stopped and exits.
//
//  History:    2000-11-29  vtan        created
//              2002-03-21  scotthan    add robustness.
//  --------------------------------------------------------------------------

void    CService::Start (void)
{
    AddRef();   // defensive addref

    _hService = RegisterServiceCtrlHandlerEx(_pszServiceName, CB_HandlerEx, this);
    
    if (_hService != NULL)
    {
        NTSTATUS    status;
        BOOL        fExit = FALSE;
        ASSERTMSG(_pAPIDispatchSync == NULL, "CService::Start - _pAPIDispatchSync != NULL: reentered before shutdown\n");

        _pAPIDispatchSync = new CAPIDispatchSync;

        if( _pAPIDispatchSync != NULL )
        {
            _serviceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
            _serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;

            _serviceStatus.dwWin32ExitCode = NO_ERROR;
            _serviceStatus.dwCheckPoint = 0;
            _serviceStatus.dwWaitHint = 0;

            TSTATUS(SignalStartStop(TRUE));

            //  Add a reference for the HandlerEx callback. When the handler receives
            //  a stop code it will release its reference.
            AddRef();

            _serviceStatus.dwCurrentState = SERVICE_RUNNING;
            TBOOL(_SetServiceStatus(_hService, &_serviceStatus, this));

            status = _pAPIConnection->Listen(_pAPIDispatchSync);

            if( CAPIDispatchSync::WaitForServiceControlStop(
                    _pAPIDispatchSync, DISPATCHSYNC_TIMEOUT) != WAIT_TIMEOUT )
            {
                fExit = TRUE;
            }
            else
            {
                _serviceStatus.dwCurrentState = SERVICE_STOPPED;
                _serviceStatus.dwWin32ExitCode = ERROR_TIMEOUT;

                DISPLAYMSG("CService::Start - Timed out waiting for SERVICE_CONTROL_STOP/SHUTDOWN.");
                TBOOL(_SetServiceStatus(_hService, &_serviceStatus, this));
            }
        }
        else
        {
            _serviceStatus.dwCurrentState = SERVICE_STOPPED;
            _serviceStatus.dwWin32ExitCode = ERROR_OUTOFMEMORY;

            TBOOL(_SetServiceStatus(_hService, &_serviceStatus, this));
        }
    }

    Release();   // defensive addref
}

//  --------------------------------------------------------------------------
//  CService::Install
//
//  Arguments:  pszName             =   Name of the service.
//              pszImage            =   Executable image of the service.
//              pszGroup            =   Group to which the service belongs.
//              pszAccount          =   Account under which the service runs.
//              pszDllName          =   Name of the hosting dll.
//              pszDependencies     =   Any dependencies the service has.
//              pszSvchostGroup     =   The svchost group.
//              dwStartType         =   Start type of the service.
//              hInstance           =   HINSTANCE for resources.
//              uiDisplayNameID     =   Resource ID of the display name.
//              uiDescriptionID     =   Resource ID of the description.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Use the service control manager to create the service. Add
//              additional information that CreateService does not allow us to
//              directly specify and add additional information that is
//              required to run in svchost.exe as a shared service process.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CService::Install (const TCHAR *pszName,
                               const TCHAR *pszImage,
                               const TCHAR *pszGroup,
                               const TCHAR *pszAccount,
                               const TCHAR *pszDllName,
                               const TCHAR *pszDependencies,
                               const TCHAR *pszSvchostGroup,
                               const TCHAR *pszServiceMainName,
                               DWORD dwStartType,
                               HINSTANCE hInstance,
                               UINT uiDisplayNameID,
                               UINT uiDescriptionID,
                               SERVICE_FAILURE_ACTIONS *psfa)

{
    NTSTATUS    status;

    status = AddService(pszName, pszImage, pszGroup, pszAccount, pszDependencies, dwStartType, hInstance, uiDisplayNameID, psfa);
    if (NT_SUCCESS(status))
    {
        status = AddServiceDescription(pszName, hInstance, uiDescriptionID);
        if (NT_SUCCESS(status))
        {
            status = AddServiceParameters(pszName, pszDllName, pszServiceMainName);
            if (NT_SUCCESS(status))
            {
                status = AddServiceToGroup(pszName, pszSvchostGroup);
            }
        }
    }
    if (!NT_SUCCESS(status))
    {
        TSTATUS(Remove(pszName));
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CService::Remove
//
//  Arguments:  pszName     =   Name of service to remove.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Use the service control manager to delete the service. This
//              doesn't clean up the turds left for svchost usage.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CService::Remove (const TCHAR *pszName)

{
    NTSTATUS    status;
    SC_HANDLE   hSCManager;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (hSCManager != NULL)
    {
        SC_HANDLE   hSCService;

        hSCService = OpenService(hSCManager, pszName, DELETE);
        if (hSCService != NULL)
        {
            if (DeleteService(hSCService) != FALSE)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
            TBOOL(CloseServiceHandle(hSCService));
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
        TBOOL(CloseServiceHandle(hSCManager));
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CService::SignalStartStop
//
//  Arguments:  BOOL fStart
//
//  Returns:    NTSTATUS
//
//  Purpose:    Base class implementation of signal service started function.
//              MUST BE INVOKED BY CHILD OVERRIDE!
//
//  History:    2000-11-29  vtan        created
//              2002-03-11  scotthan    renamed to 'SignalStartStop' from 'Signal', 
//                                      added boolean arg, 
//              2002-03-24  scotthan    added firing of 'stopping'notification
//  --------------------------------------------------------------------------

NTSTATUS    CService::SignalStartStop (BOOL fStart)
{
    if( !fStart )
    {
        CAPIDispatchSync::SignalServiceStopping(_pAPIDispatchSync);
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  Default return codes for SCM control requests
typedef struct 
{
    DWORD dwControl;
    DWORD dwRet;
} SERVICE_CONTROL_RETURN;

const SERVICE_CONTROL_RETURN _rgDefaultControlRet[] = 
{
    { SERVICE_CONTROL_STOP,           NO_ERROR},
    { SERVICE_CONTROL_SHUTDOWN,       NO_ERROR},
    { SERVICE_CONTROL_INTERROGATE,    NO_ERROR},
    { SERVICE_CONTROL_PAUSE,          ERROR_CALL_NOT_IMPLEMENTED},
    { SERVICE_CONTROL_CONTINUE,       ERROR_CALL_NOT_IMPLEMENTED},
    { SERVICE_CONTROL_PARAMCHANGE,    ERROR_CALL_NOT_IMPLEMENTED},
    { SERVICE_CONTROL_NETBINDADD,     ERROR_CALL_NOT_IMPLEMENTED},
    { SERVICE_CONTROL_NETBINDREMOVE,  ERROR_CALL_NOT_IMPLEMENTED},
    { SERVICE_CONTROL_NETBINDENABLE,  ERROR_CALL_NOT_IMPLEMENTED},
    { SERVICE_CONTROL_NETBINDDISABLE, ERROR_CALL_NOT_IMPLEMENTED},
    { SERVICE_CONTROL_DEVICEEVENT,    ERROR_CALL_NOT_IMPLEMENTED},
    { SERVICE_CONTROL_HARDWAREPROFILECHANGE, ERROR_CALL_NOT_IMPLEMENTED},
    { SERVICE_CONTROL_POWEREVENT,     ERROR_CALL_NOT_IMPLEMENTED},
};

//  --------------------------------------------------------------------------
DWORD _GetDefaultControlRet(DWORD dwControl)
{
    for(int i = 0; i < ARRAYSIZE(_rgDefaultControlRet); i++)
    {
        if( dwControl == _rgDefaultControlRet[i].dwControl )
            return _rgDefaultControlRet[i].dwRet;
    }

    DISPLAYMSG("Unknown service control code passed to CService::CB_HandlerEx");
    return ERROR_CALL_NOT_IMPLEMENTED;
}


//  --------------------------------------------------------------------------
//  CService::HandlerEx
//
//  Arguments:  dwControl   =   Control code from service control manager.
//
//  Returns:    DWORD
//
//  Purpose:    HandlerEx function for the service. The base class implements
//              most of the useful things that the service will want to do.
//              It's declared virtual in case overriding is required.
//
//  History:    2000-11-29  vtan        created
//              2002-03-21  scotthan    Make shutdown more robust.
//  --------------------------------------------------------------------------

DWORD   CService::HandlerEx (DWORD dwControl)

{
    DWORD                   dwErrorCode = _GetDefaultControlRet(dwControl);
    SERVICE_STATUS_HANDLE   hService = _hService;

    if( hService != NULL )
    {
        switch (dwControl)
        {
            case SERVICE_CONTROL_STOP:
            case SERVICE_CONTROL_SHUTDOWN:
            {
                //  In the stop/shutdown case, we do the following: 
                //  (1) respond to the message by setting the status to SERVICE_STOP_PENDING. 
                //  (2) Signal to all blocking LPC request handler threads that the service
                //      is coming down.  This should cause them to terminate gracefully and
                //      come home.
                //  (3) Send an API_GENERIC_STOP request down the LPC port, telling it to quit. 
                //      (this call can only succeed if it comes from within this process.)
                //  (4) Wait until the port finishes shutting down.
                //  (5) Signal to ServiceMain that the SERVICE_CONTROL_STOP/SHUTDOWN has completed.
                //  (6) ServiceMain exits.

                //  Step (1): update status to SERVICE_STOP_PENDING.
                _serviceStatus.dwCurrentState = SERVICE_STOP_PENDING;
                TBOOL(_SetServiceStatus(hService, &_serviceStatus, this));

                //  Step (2): Call home any waiting LPC request handler threads
                SignalStartStop(FALSE);

                //  Step (3) Send an API_GENERIC_STOP LPC request to stop listening on 
                //      the port (this will immediately release ServiceMain, 
                //      who in turn needs to wait until we're completely finished here before exiting.)
                NTSTATUS status;
                TSTATUS((status = _pServerAPI->Stop()));

                if( NT_SUCCESS(status) )
                {
                    //  Step (4): Wait until the API_GENERIC_STOP is finished.
                    if( CAPIDispatchSync::WaitForPortShutdown(
                            _pAPIDispatchSync, DISPATCHSYNC_TIMEOUT) != WAIT_TIMEOUT )
                    {
                        _serviceStatus.dwCurrentState = SERVICE_STOPPED;
                        _serviceStatus.dwWin32ExitCode = CStatusCode::ErrorCodeOfStatusCode(status);
                        TBOOL(_SetServiceStatus(_hService, &_serviceStatus, this));
                        _hService = hService = NULL;

                        //  Release reference on ourselves.  
                        //  The matching AddRef occurs in CService::Start.
                        Release();
                    }
                    else
                    {
                        dwErrorCode = ERROR_TIMEOUT;
                        DISPLAYMSG("CService::HandlerEx - Timed out waiting for port shutdown.");
                    }
                }
                else
                {
                    _serviceStatus.dwCurrentState = SERVICE_RUNNING;
                    TBOOL(_SetServiceStatus(hService, &_serviceStatus, this));
                    dwErrorCode = CStatusCode::ErrorCodeOfStatusCode(status);
                }

                //  Step (5): signal to ServiceMain that SERVICE_CONTROL_STOP/SHUTDOWN 
                //  has completed; now he's safe to exit.
                CAPIDispatchSync::SignalServiceControlStop(_pAPIDispatchSync);
                break;
            }

            default:
            {
                //  Report current status:
                TBOOL(_SetServiceStatus(hService, &_serviceStatus, this));
                break;
            }
        }
    }

    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CService::CB_HandlerEx
//
//  Arguments:  See the platform SDK under HandlerEx.
//
//  Returns:    DWORD
//
//  Purpose:    Static function stub to call into the class.
//
//  History:    2000-11-29  vtan        created
//              2002-03-21  scotthan    Add robustness.
//  --------------------------------------------------------------------------

DWORD   WINAPI  CService::CB_HandlerEx (DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)

{
    UNREFERENCED_PARAMETER(dwEventType);
    UNREFERENCED_PARAMETER(lpEventData);

    DWORD     dwRet = ERROR_SUCCESS;
    CService* pService = reinterpret_cast<CService*>(lpContext);

    DEBUG_TRY();

    if( CService::IsValid(pService) )
    {
        pService->AddRef();    // purely defensive; not until we call SetServiceStatus(SERVICE_STOPPED)
                               // will SCM stop calling into us via HandlerEx, so we need to ensure we stay alive.
        dwRet = pService->HandlerEx(dwControl);

        pService->Release();   // remove defensive AddRef().
    }
    else
    {
        DISPLAYMSG("CService::CB_HandlerEx - Warning: SCM control entrypoint invoked vs. invalid CService instance");
        dwRet = _GetDefaultControlRet(dwControl);
    }

    DEBUG_EXCEPT("Breaking in CService::CB_HandlerEx exception handler");

    return dwRet;
}

//  --------------------------------------------------------------------------
//  CService:AddService
//
//  Arguments:  pszName             =   Name of the service.
//              pszImage            =   Executable image of the service.
//              pszGroup            =   Group to which the service belongs.
//              pszAccount          =   Account under which the service runs.
//              pszDependencies     =   Any dependencies the service has.
//              dwStartType         =   Start type of the service.
//              hInstance           =   HINSTANCE for resources.
//              uiDisplayNameID     =   Resource ID of the display name.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Uses the service control manager to create the service and add
//              it into the database.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CService::AddService (const TCHAR *pszName,
                                  const TCHAR *pszImage,
                                  const TCHAR *pszGroup,
                                  const TCHAR *pszAccount,
                                  const TCHAR *pszDependencies,
                                  DWORD dwStartType,
                                  HINSTANCE hInstance,
                                  UINT uiDisplayNameID,
                                  SERVICE_FAILURE_ACTIONS *psfa)

{
    DWORD       dwErrorCode;
    SC_HANDLE   hSCManager;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (hSCManager != NULL)
    {
        TCHAR   sz[256];

        if (LoadString(hInstance, uiDisplayNameID, sz, ARRAYSIZE(sz)) != 0)
        {
            SC_HANDLE   hSCService;

            hSCService = CreateService(hSCManager,
                                       pszName,
                                       sz,
                                       SERVICE_ALL_ACCESS,
                                       SERVICE_WIN32_SHARE_PROCESS,
                                       dwStartType,
                                       SERVICE_ERROR_NORMAL,
                                       pszImage,
                                       pszGroup,
                                       NULL,
                                       pszDependencies,
                                       pszAccount,
                                       NULL);
            if (hSCService != NULL)
            {
                // Apply the failure action configuration, if any
                if (psfa != NULL)
                {
                    // If CreateService succeeded, why would this fail?
                    TBOOL(ChangeServiceConfig2(hSCService, SERVICE_CONFIG_FAILURE_ACTIONS, psfa));
                }

                TBOOL(CloseServiceHandle(hSCService));
                dwErrorCode = ERROR_SUCCESS;
            }
            else
            {

                //  Blow off ERROR_SERVICE_EXISTS. If in the future the need
                //  to change the configuration arises add the code here.

                dwErrorCode = GetLastError();
                if (dwErrorCode == ERROR_SERVICE_EXISTS)
                {
                    dwErrorCode = ERROR_SUCCESS;

                    // Update service information for upgrade cases
                    hSCService = OpenService(hSCManager, pszName, SERVICE_ALL_ACCESS);
                    if (hSCService != NULL)
                    {
                        // Update the start type
                        TBOOL(ChangeServiceConfig(hSCService, 
                            SERVICE_NO_CHANGE,  // dwServiceType 
                            dwStartType,
                            SERVICE_NO_CHANGE,  // dwErrorControl 
                            NULL,               // lpBinaryPathName 
                            NULL,               // lpLoadOrderGroup 
                            NULL,               // lpdwTagId 
                            NULL,               // lpDependencies 
                            NULL,               // lpServiceStartName 
                            NULL,               // lpPassword 
                            NULL                // lpDisplayName
                            ));

                        // Apply the failure action configuration, if any
                        if (psfa != NULL)
                        {
                            TBOOL(ChangeServiceConfig2(hSCService, SERVICE_CONFIG_FAILURE_ACTIONS, psfa));
                        }

                        TBOOL(CloseServiceHandle(hSCService));
                    }
                }
            }
            TBOOL(CloseServiceHandle(hSCManager));
        }
        else
        {
            dwErrorCode = GetLastError();
        }
    }
    else
    {
        dwErrorCode = GetLastError();
    }
    return(CStatusCode::StatusCodeOfErrorCode(dwErrorCode));
}

//  --------------------------------------------------------------------------
//  CService:AddServiceDescription
//
//  Arguments:  pszName             =   Name of service.
//              hInstance           =   HINSTANCE of module.
//              uiDescriptionID     =   Resource ID of description.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Reads the string resource from the given location and writes
//              it as the description of the given service in the registry.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CService::AddServiceDescription (const TCHAR *pszName, HINSTANCE hInstance, UINT uiDescriptionID)

{
    LONG        lErrorCode;
    TCHAR       szKeyName[256];
    CRegKey     regKeyService;

    if (!pszName || !pszName[0])
    {
        lErrorCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        StringCchCopy(szKeyName, ARRAYSIZE(szKeyName), TEXT("SYSTEM\\CurrentControlSet\\Services\\"));
        StringCchCatN(szKeyName, ARRAYSIZE(szKeyName), pszName, (ARRAYSIZE(szKeyName) - 1) - lstrlen(szKeyName));
        lErrorCode = regKeyService.Open(HKEY_LOCAL_MACHINE,
                                        szKeyName,
                                        KEY_SET_VALUE);
        if (ERROR_SUCCESS == lErrorCode)
        {
            TCHAR   sz[256];

            if (LoadString(hInstance, uiDescriptionID, sz, ARRAYSIZE(sz)) != 0)
            {
                lErrorCode = regKeyService.SetString(TEXT("Description"), sz);
            }
            else
            {
                lErrorCode = GetLastError();
            }
        }
    }
    
    return CStatusCode::StatusCodeOfErrorCode(lErrorCode);
}

//  --------------------------------------------------------------------------
//  CService:AddServiceParameters
//
//  Arguments:  pszName     =   Name of service.
//              pszDllName  =   Name of DLL hosting service.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds parameters required for svchost to host this service.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CService::AddServiceParameters (const TCHAR* pszName, const TCHAR* pszDllName, const TCHAR* pszServiceMainName)

{
    LONG        lErrorCode;
    TCHAR       szKeyName[256];
    CRegKey     regKey;

    // we handle a null pszServiceMainName
    if (!pszName    || !pszName[0]  || 
        !pszDllName || !pszDllName[0])
    {
        lErrorCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        StringCchCopy(szKeyName, ARRAYSIZE(szKeyName), TEXT("SYSTEM\\CurrentControlSet\\Services\\"));
        StringCchCatN(szKeyName, ARRAYSIZE(szKeyName), pszName, (ARRAYSIZE(szKeyName) - 1) - lstrlen(szKeyName));
        StringCchCatN(szKeyName, ARRAYSIZE(szKeyName), TEXT("\\Parameters"), (ARRAYSIZE(szKeyName) - 1) - lstrlen(szKeyName));
        lErrorCode = regKey.Create(HKEY_LOCAL_MACHINE,
                                   szKeyName,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_SET_VALUE,
                                   NULL);
        if (ERROR_SUCCESS == lErrorCode)
        {
            TCHAR   sz[256];

            StringCchCopy(sz, ARRAYSIZE(sz), TEXT("%SystemRoot%\\System32\\"));
            StringCchCatN(sz, ARRAYSIZE(sz), pszDllName, (ARRAYSIZE(sz) - 1) - lstrlen(sz));
            lErrorCode = regKey.SetPath(TEXT("ServiceDll"), sz);
            if (ERROR_SUCCESS == lErrorCode)
            {
                if (!pszServiceMainName || !pszServiceMainName[0])
                {
                    StringCchCopy(sz, ARRAYSIZE(sz), TEXT("ServiceMain"));
                    pszServiceMainName = sz;
                }
                lErrorCode = regKey.SetString(TEXT("ServiceMain"), pszServiceMainName);
            }
        }
    }

    return CStatusCode::StatusCodeOfErrorCode(lErrorCode);
}

//  --------------------------------------------------------------------------
//  CService:AddServiceToGroup
//
//  Arguments:  pszName             =   Name of service.
//              pszSvchostGroup     =   Group to which the service belongs.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds the service as part of the group of services hosted in
//              a single instance of svchost.exe.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CService::AddServiceToGroup (const TCHAR *pszName, const TCHAR *pszSvchostGroup)

{
    LONG        lErrorCode;
    CRegKey     regKey;

    lErrorCode = regKey.Open(HKEY_LOCAL_MACHINE,
                             TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost"),
                             KEY_QUERY_VALUE | KEY_SET_VALUE);
    if (ERROR_SUCCESS == lErrorCode)
    {
        DWORD   dwType, dwBaseDataSize, dwDataSize;

        dwType = dwBaseDataSize = dwDataSize = 0;
        lErrorCode = regKey.QueryValue(pszSvchostGroup,
                                       &dwType,
                                       NULL,
                                       &dwBaseDataSize);
        if ((REG_MULTI_SZ == dwType) && (dwBaseDataSize != 0))
        {
            TCHAR   *pszData;

            dwDataSize = dwBaseDataSize + ((lstrlen(pszName) + 1) * sizeof(TCHAR));
            pszData = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, dwDataSize));
            if (pszData != NULL)
            {
                lErrorCode = regKey.QueryValue(pszSvchostGroup,
                                               NULL,
                                               pszData,
                                               &dwBaseDataSize);
                if (ERROR_SUCCESS == lErrorCode)
                {
                    if (*(pszData + (dwBaseDataSize / sizeof(TCHAR)) - 1) == L'\0')
                    {
                        if (!StringInMulitpleStringList(pszData, pszName))
                        {
                            StringInsertInMultipleStringList(pszData, pszName, dwDataSize);
                            lErrorCode = regKey.SetValue(pszSvchostGroup,
                                                        dwType,
                                                        pszData,
                                                        dwDataSize);
                        }
                    }
                    else
                    {
                        lErrorCode = ERROR_INVALID_DATA;
                    }
                }
                (HLOCAL)LocalFree(pszData);
            }
            else
            {
                lErrorCode = ERROR_OUTOFMEMORY;
            }
        }
        else
        {
            lErrorCode = ERROR_INVALID_DATA;
        }
    }
    return(CStatusCode::StatusCodeOfErrorCode(lErrorCode));
}

//  --------------------------------------------------------------------------
//  CService:StringInMulitpleStringList
//
//  Arguments:  pszStringList   =   String list to search.
//              pszString       =   String to search for.
//
//  Returns:    bool
//
//  Purpose:    Searches the REG_MULTI_SZ string list looking for matches.
//
//  History:    2000-12-01  vtan        created
//  --------------------------------------------------------------------------

bool    CService::StringInMulitpleStringList (const TCHAR *pszStringList, const TCHAR *pszString)

{
    bool    fFound;

    fFound = false;
    while (!fFound && (pszStringList[0] != TEXT('\0')))
    {
        fFound = (lstrcmpi(pszStringList, pszString) == 0);
        if (!fFound)
        {
            pszStringList += (lstrlen(pszStringList) + 1);
        }
    }
    return(fFound);
}

//  --------------------------------------------------------------------------
//  CService:StringInsertInMultipleStringList
//
//  Arguments:  pszStringList       =   String list to insert string in.
//              pszString           =   String to insert.
//              cbStringListSize    =   Byte count of string list.
//
//  Returns:    bool
//
//  Purpose:    Inserts the given string into the multiple string list in
//              the first alphabetical position encountered. If the list is
//              kept alphabetical then this preserves it.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

void    CService::StringInsertInMultipleStringList (TCHAR *pszStringList, const TCHAR *pszString, DWORD cbStringListSize)

{
    int     iResult, cchSize;
    TCHAR   *pszFirstString, *pszLastString;

    pszFirstString = pszLastString = pszStringList;
    cchSize = lstrlen(pszString) + 1;
    iResult = -1;
    while ((iResult < 0) && (pszStringList[0] != TEXT('\0')))
    {
        pszLastString = pszStringList;
        iResult = lstrcmpi(pszStringList, pszString);
        ASSERTMSG(iResult != 0, "Found exact match in StringInsertInMultipleStringList");
        // 1 is for the '\0' terminator
        pszStringList += (lstrlen(pszStringList) + 1);
    }
    if (iResult < 0)
    {
        pszLastString = pszStringList;
    }

    int cbLenToMove = cbStringListSize - (int(pszLastString - pszFirstString) * sizeof(TCHAR)) - (cchSize * sizeof(TCHAR));

    if (cbLenToMove > 0) // Means that pszLastString + cchSize < pszFirstString + cbStringListSize
    {
        MoveMemory(pszLastString + cchSize, pszLastString, cbLenToMove);
        StringCchCopy(pszLastString, cchSize, pszString);
    }
}

//  --------------------------------------------------------------------------
//  CServiceWorkItem::CServiceWorkItem
//
//  Arguments:  pServerAPI  =   CServerAPI to use.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CServiceWorkItem.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CServiceWorkItem::CServiceWorkItem (CServerAPI *pServerAPI) :
    _pServerAPI(pServerAPI)

{
    pServerAPI->AddRef();
}

//  --------------------------------------------------------------------------
//  CServiceWorkItem::~CServiceWorkItem
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CServiceWorkItem. Release resources used.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CServiceWorkItem::~CServiceWorkItem (void)

{
    _pServerAPI->Release();
    _pServerAPI = NULL;
}

//  --------------------------------------------------------------------------
//  CServiceWorkItem::Entry
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Executes work item request (stop the server).
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

void    CServiceWorkItem::Entry (void)

{
    TSTATUS(_pServerAPI->Stop());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\workitem.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: WorkItem.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements the handling of queuing a work item and calling the
//  entry point of the work item function when entered in a worker thread.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "WorkItem.h"

#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CWorkItem::CWorkItem
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CWorkItem.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CWorkItem::CWorkItem (void)

{
}

//  --------------------------------------------------------------------------
//  CWorkItem::~CWorkItem
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CWorkItem.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CWorkItem::~CWorkItem (void)

{
}

//  --------------------------------------------------------------------------
//  CWorkItem::Queue
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Queues the work item entry function to be executed.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CWorkItem::Queue (void)

{
    NTSTATUS    status;

    //  Initially add a reference to this work item. If the queue succeeds
    //  then leave the reference for WorkItemEntryProc to release. Otherwise
    //  on failure release the reference.

    AddRef();
    if (QueueUserWorkItem(WorkItemEntryProc, this, WT_EXECUTEDEFAULT) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        Release();
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CWorkItem::WorkItemEntryProc
//
//  Arguments:  pParameter  =   Context pointer passed in when queued.
//
//  Returns:    DWORD
//
//  Purpose:    Callback entry point for queued work item. Takes the context
//              pointer and calls the virtual function that implements the
//              actual work.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

DWORD   WINAPI  CWorkItem::WorkItemEntryProc (void *pParameter)

{
    CWorkItem   *pWorkItem;

    DEBUG_TRY();

    pWorkItem = reinterpret_cast<CWorkItem*>(pParameter);
    pWorkItem->Entry();
    pWorkItem->Release();

    DEBUG_EXCEPT("Breaking in CWorkItem::WorkItemEntryProc exception handler...");

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\serverapi.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ServerAPI.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  An abstract base class containing virtual functions that allow the basic
//  port functionality code to be reused to create another server. These
//  virtual functions create other objects with pure virtual functions which
//  the basic port functionality code invokes thru the v-table.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#define STRSAFE_LIB
#include <strsafe.h>

#include "ServerAPI.h"

#include <lpcgeneric.h>

#include "APIConnection.h"
#include "StatusCode.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CServerAPI::CServerAPI
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the abstract base class.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CServerAPI::CServerAPI (void)

{
}

//  --------------------------------------------------------------------------
//  CServerAPI::~CServerAPI
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the abstract base class.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CServerAPI::~CServerAPI (void)

{
}

//  --------------------------------------------------------------------------
//  CServerAPI::Start
//
//  Arguments:  
//
//  Returns:    NTSTATUS
//
//  Purpose:    Uses the service control manager to start the service.
//
//  History:    2000-10-13  vtan        created
//              2000-11-28  vtan        rewrote for Win32 services
//  --------------------------------------------------------------------------

NTSTATUS    CServerAPI::Start (void)

{
    NTSTATUS    status;
    SC_HANDLE   hSCManager;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSCManager != NULL)
    {
        SC_HANDLE   hSCService;

        hSCService = OpenService(hSCManager, GetServiceName(), SERVICE_START);
        if (hSCService != NULL)
        {
            if (StartService(hSCService, 0, NULL) != FALSE)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
            TBOOL(CloseServiceHandle(hSCService));
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
        TBOOL(CloseServiceHandle(hSCManager));
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CServerAPI::Stop
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Use the service control manager to stop the service.
//
//  History:    2000-10-17  vtan        created
//              2000-11-28  vtan        rewrote for Win32 services
//  --------------------------------------------------------------------------

NTSTATUS    CServerAPI::Stop (void)

{
    NTSTATUS    status;
    HANDLE      hPort;

    //  First try connecting to the server and asking it to stop. This is
    //  cleanest method.

    status = Connect(&hPort);
    if (NT_SUCCESS(status))
    {
        API_GENERIC     apiRequest;
        CPortMessage    portMessageIn, portMessageOut;

        apiRequest.ulAPINumber = API_GENERIC_STOPSERVER;
        portMessageIn.SetData(&apiRequest, sizeof(apiRequest));
        status = NtRequestWaitReplyPort(hPort,
                                        portMessageIn.GetPortMessage(),
                                        portMessageOut.GetPortMessage());
        if (NT_SUCCESS(status))
        {
            status = reinterpret_cast<const API_GENERIC*>(portMessageOut.GetData())->status;
        }
        TBOOL(CloseHandle(hPort));
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CServerAPI::IsRunning
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Use the service control manager to query whether the service
//              is running.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

bool    CServerAPI::IsRunning (void)

{
    bool        fRunning;
    SC_HANDLE   hSCManager;

    fRunning = false;
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSCManager != NULL)
    {
        SC_HANDLE   hSCService;

        hSCService = OpenService(hSCManager, GetServiceName(), SERVICE_QUERY_STATUS);
        if (hSCService != NULL)
        {
            SERVICE_STATUS  serviceStatus;

            if (QueryServiceStatus(hSCService, &serviceStatus) != FALSE)
            {
                fRunning = (serviceStatus.dwCurrentState == SERVICE_RUNNING);
            }
            TBOOL(CloseServiceHandle(hSCService));
        }
        TBOOL(CloseServiceHandle(hSCManager));
    }
    return(fRunning);
}

//  --------------------------------------------------------------------------
//  CServerAPI::IsAutoStart
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Use the service contorl manager to find out if the service
//              is configured to be an automatically started service.
//
//  History:    2000-11-30  vtan        created
//  --------------------------------------------------------------------------

bool    CServerAPI::IsAutoStart (void)

{
    bool        fAutoStart;
    SC_HANDLE   hSCManager;

    fAutoStart = false;
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSCManager != NULL)
    {
        SC_HANDLE   hSCService;

        hSCService = OpenService(hSCManager, GetServiceName(), SERVICE_QUERY_CONFIG);
        if (hSCService != NULL)
        {
            DWORD                   dwBytesNeeded;
            QUERY_SERVICE_CONFIG    *pServiceConfig;

            (BOOL)QueryServiceConfig(hSCService, NULL, 0, &dwBytesNeeded);
            pServiceConfig = static_cast<QUERY_SERVICE_CONFIG*>(LocalAlloc(LMEM_FIXED, dwBytesNeeded));
            if (pServiceConfig != NULL)
            {
                if (QueryServiceConfig(hSCService, pServiceConfig, dwBytesNeeded, &dwBytesNeeded) != FALSE)
                {
                    fAutoStart = (pServiceConfig->dwStartType == SERVICE_AUTO_START);
                }
                (HLOCAL)LocalFree(pServiceConfig);
            }
            TBOOL(CloseServiceHandle(hSCService));
        }
        TBOOL(CloseServiceHandle(hSCManager));
    }
    return(fAutoStart);
}

//  --------------------------------------------------------------------------
//  CServerAPI::Wait
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Waits for the service control manager to return the state that
//              the service is running. This does not check that the service
//              is auto start or not. You can only call this function if the
//              service is auto start or you demand started the service.
//              Otherwise the function will timeout.
//
//  History:    2000-11-28  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CServerAPI::Wait (DWORD dwTimeout)

{
    NTSTATUS    status;
    SC_HANDLE   hSCManager;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSCManager != NULL)
    {
        SC_HANDLE   hSCService;

        hSCService = OpenService(hSCManager, GetServiceName(), SERVICE_QUERY_STATUS);
        if (hSCService != NULL)
        {
            SERVICE_STATUS  serviceStatus;

            if (QueryServiceStatus(hSCService, &serviceStatus) != FALSE)
            {
                status = STATUS_SUCCESS;
                if (serviceStatus.dwCurrentState != SERVICE_RUNNING)
                {
                    bool    fTimedOut;
                    DWORD   dwTickStart;

                    dwTickStart = GetTickCount();
                    fTimedOut = ((GetTickCount() - dwTickStart) >= dwTimeout);
                    while (NT_SUCCESS(status) &&
                           !fTimedOut &&
                           (serviceStatus.dwCurrentState != SERVICE_RUNNING) &&
                           (serviceStatus.dwCurrentState != SERVICE_STOP_PENDING))
                    {
                        Sleep(50);
                        if (QueryServiceStatus(hSCService, &serviceStatus) != FALSE)
                        {
                            fTimedOut = ((GetTickCount() - dwTickStart) >= dwTimeout);
                        }
                        else
                        {
                            status = CStatusCode::StatusCodeOfLastError();
                        }
                    }
                    if (serviceStatus.dwCurrentState == SERVICE_RUNNING)
                    {
                        status = STATUS_SUCCESS;
                    }
                    else if (fTimedOut)
                    {
                        status = STATUS_TIMEOUT;
                    }
                    else
                    {
                        status = STATUS_UNSUCCESSFUL;
                    }
#ifdef      DBG
                    char    sz[256];

                    StringCchPrintfA(sz, ARRAYSIZE(sz), "Waited %d ticks for theme service", GetTickCount() - dwTickStart);
                    INFORMATIONMSG(sz);
#endif  /*  DBG     */
                }
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
            TBOOL(CloseServiceHandle(hSCService));
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
        TBOOL(CloseServiceHandle(hSCManager));
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CServerAPI::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initializes static member variables for this class. Must be
//              called by subclasses of this class.
//
//  History:    2000-10-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CServerAPI::StaticInitialize (void)

{
#ifdef  DBG
    TSTATUS(CDebug::StaticInitialize());
#endif
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CServerAPI::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases static resources used by this class.
//
//  History:    2000-10-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CServerAPI::StaticTerminate (void)

{
#ifdef  DBG
    TSTATUS(CDebug::StaticTerminate());
#endif
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CServerAPI::IsClientTheSystem
//
//  Arguments:  portMessage     =   CPortMessage from the client.
//
//  Returns:    bool
//
//  Purpose:    Determines whether the client in the port message is the local
//              system account.
//
//  History:    1999-12-13  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

bool    CServerAPI::IsClientTheSystem (const CPortMessage& portMessage)

{
    bool    fResult;
    HANDLE  hToken;

    if (NT_SUCCESS(portMessage.OpenClientToken(hToken)))
    {
        CTokenInformation   tokenInformation(hToken);

        fResult = tokenInformation.IsUserTheSystem();
        ReleaseHandle(hToken);
    }
    else
    {
        fResult = false;
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CServerAPI::IsClientAnAdministrator
//
//  Arguments:  portMessage     =   CPortMessage from the client.
//
//  Returns:    bool
//
//  Purpose:    Determines whether the client in the port message is an
//              administrator.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

bool    CServerAPI::IsClientAnAdministrator (const CPortMessage& portMessage)

{
    bool    fResult;
    HANDLE  hToken;

    if (NT_SUCCESS(portMessage.OpenClientToken(hToken)))
    {
        CTokenInformation   tokenInformation(hToken);

        fResult = tokenInformation.IsUserAnAdministrator();
        ReleaseHandle(hToken);
    }
    else
    {
        fResult = false;
    }
    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\serverapi.h ===
//  --------------------------------------------------------------------------
//  Module Name: ServerAPI.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  An abstract base class containing virtual functions that allow the basic
//  port functionality code to be reused to create another server. These
//  virtual functions create other objects with pure virtual functions which
//  the basic port functionality code invokes thru the v-table.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _ServerAPI_
#define     _ServerAPI_

#include "APIDispatcher.h"
#include "CountedObject.h"
#include "PortMessage.h"

class   CAPIConnection;         //  This would be circular otherwise

//  --------------------------------------------------------------------------
//  CServerAPI
//
//  Purpose:    The abstract base class which the server connection monitor
//              thread uses to determine whether server connection should be
//              accepted or rejected as well as creating threads to process
//              client requests.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CServerAPI : public CCountedObject
{
    protected:
                                    CServerAPI (void);
        virtual                     ~CServerAPI (void);
    public:
        virtual const WCHAR*        GetPortName (void) = 0;
        virtual const TCHAR*        GetServiceName (void) = 0;
        virtual bool                ConnectionAccepted (const CPortMessage& portMessage) = 0;
        virtual CAPIDispatcher*     CreateDispatcher (const CPortMessage& portMessage) = 0;
        virtual NTSTATUS            Connect (HANDLE* phPort) = 0;

                NTSTATUS            Start (void);
                NTSTATUS            Stop (void);
                bool                IsRunning (void);
                bool                IsAutoStart (void);
                NTSTATUS            Wait (DWORD dwTimeout);

        static  NTSTATUS            StaticInitialize (void);
        static  NTSTATUS            StaticTerminate (void);
    protected:
        static  bool                IsClientTheSystem (const CPortMessage& portMessage);
        static  bool                IsClientAnAdministrator (const CPortMessage& portMessage);
};

#endif  /*  _ServerAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\lpc\service.h ===
//  --------------------------------------------------------------------------
//  Module Name: Service.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements generic portions of a Win32
//  serivce.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _Service_
#define     _Service_

#include "APIConnection.h"

//  --------------------------------------------------------------------------
//  CService
//
//  Purpose:    Base class implementation of a service for the service control
//              manager.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

class   CService : public CCountedObject
{
    private:
        friend  class   CServiceWorkItem;

                                        CService (void);
    protected:
                                        CService (CAPIConnection *pAPIConnection, CServerAPI *pServerAPI, const TCHAR *pszServiceName);
        virtual                         ~CService (void);
    public:
        static  BOOL                    IsValid(CService* pService);

                void                    Start (void);

        static  NTSTATUS                Install (const TCHAR *pszName,
                                                 const TCHAR *pszImage,
                                                 const TCHAR *pszGroup,
                                                 const TCHAR *pszAccount,
                                                 const TCHAR *pszDllName,
                                                 const TCHAR *pszDependencies,
                                                 const TCHAR *pszSvchostGroup,
                                                 const TCHAR *pszServiceMainName,
                                                 DWORD dwStartType,
                                                 HINSTANCE hInstance,
                                                 UINT uiDisplayNameID,
                                                 UINT uiDescriptionID,
                                                 SERVICE_FAILURE_ACTIONS *psfa = NULL);
        static  NTSTATUS                Remove (const TCHAR *pszName);

    protected:
        virtual NTSTATUS                SignalStartStop (BOOL fStart /* FALSE == stop/shutdown */);
        virtual DWORD                   HandlerEx (DWORD dwControl);
    private:
        static  DWORD   WINAPI          CB_HandlerEx (DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);

        static  NTSTATUS                AddService (const TCHAR *pszName,
                                                    const TCHAR *pszImage,
                                                    const TCHAR *pszGroup,
                                                    const TCHAR *pszAccount,
                                                    const TCHAR *pszDependencies,
                                                    DWORD dwStartType,
                                                    HINSTANCE hInstance,
                                                    UINT uiDisplayNameID,
                                                    SERVICE_FAILURE_ACTIONS *psfa = NULL);
        static  NTSTATUS                AddServiceDescription (const TCHAR *pszName, HINSTANCE hInstance, UINT uiDescriptionID);
        static  NTSTATUS                AddServiceParameters (const TCHAR *pszName, const TCHAR *pszDllName, const TCHAR *pszServiceMainName);
        static  NTSTATUS                AddServiceToGroup (const TCHAR *pszName, const TCHAR *pszSvchostGroup);
        static  bool                    StringInMulitpleStringList (const TCHAR *pszStringList, const TCHAR *pszString);
        static  void                    StringInsertInMultipleStringList (TCHAR *pszStringList, const TCHAR *pszString, DWORD dwStringListSize);

    protected:
                #define CSVC_TAG        "CSVC"
                #define DEAD_CSVC_TAG   "DEAD"
                #define CB_CSVC_TAG     4

                CHAR                    _szTag[CB_CSVC_TAG];
                SERVICE_STATUS_HANDLE   _hService;
                SERVICE_STATUS          _serviceStatus;
                const TCHAR*            _pszServiceName;
                CAPIConnection*         _pAPIConnection;
                CAPIDispatchSync*       _pAPIDispatchSync;
                CServerAPI*             _pServerAPI;
};


//  --------------------------------------------------------------------------
//  CServiceWorkItem
//
//  Purpose:    Work item class to stop the server using the CServerAPI class.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

class   CServiceWorkItem : public CWorkItem
{
    private:
                                        CServiceWorkItem (void);
    public:
                                        CServiceWorkItem (CServerAPI *pServerAPI);
        virtual                         ~CServiceWorkItem (void);
    protected:
        virtual void                    Entry (void);
    private:
                CServerAPI*             _pServerAPI;
};

//  --------------------------------------------------------------------------
//  Debug wrap of SetServiceStatus
//  --------------------------------------------------------------------------
//  uncomment to activate:
// #define DEBUG_SERVICE_STATUS  

#ifdef  DEBUG_SERVICE_STATUS

    BOOL _DebugSetServiceStatus(
      SERVICE_STATUS_HANDLE h, LPSERVICE_STATUS pStatus, CService* pService )
    {
        char* pszStatus = NULL;

        switch(pStatus->dwCurrentState)
        {
            #define ASSIGN_STATUS_STRING(scs)   case scs: pszStatus = #scs; break
            ASSIGN_STATUS_STRING(SERVICE_CONTINUE_PENDING);
            ASSIGN_STATUS_STRING(SERVICE_PAUSE_PENDING);
            ASSIGN_STATUS_STRING(SERVICE_PAUSED);
            ASSIGN_STATUS_STRING(SERVICE_RUNNING);
            ASSIGN_STATUS_STRING(SERVICE_START_PENDING);
            ASSIGN_STATUS_STRING(SERVICE_STOP_PENDING);
            ASSIGN_STATUS_STRING(SERVICE_STOPPED); 
        }

        CHAR szMsg[512];
        StringCchPrintfA(szMsg, ARRAYSIZE(szMsg),
                         "\nCService (%08lx) assigning dwCurrentState: %s, dwWin32ExitCode: %08lX\n",
                         pService, pszStatus, pStatus->dwWin32ExitCode);
        DISPLAYMSG(szMsg);

        return SetServiceStatus(h, pStatus);
    }

#   define _SetServiceStatus(h, pStatus, pService)   _DebugSetServiceStatus(h, pStatus, pService)

#else   // DEBUG_SERVICE_STATUS

#   define _SetServiceStatus(h, pStatus, pService)   SetServiceStatus(h, pStatus)

#endif  // DEBUG_SERVICE_STATUS


#endif  /*  _Service_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\thememanagerapirequest.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerAPIRequest.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the work for the theme server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifndef     _ThemeManagerAPIRequest_
#define     _ThemeManagerAPIRequest_

#include "APIRequest.h"
#include "DynamicArray.h"
#include "ThemeManagerSessionData.h"

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest
//
//  Purpose:    This is an intermediate class that contains a common method
//              that can be used by sub-classes.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//              2002-03-21  scotthan    add Execute_ProcessLoadTheme, Execute_ProcessAssignSection.
//              2002-03-24  scotthan    propagate DispatchSync to API request instance.
//  --------------------------------------------------------------------------

class   CThemeManagerAPIRequest : public CAPIRequest
{
    private:
                                                CThemeManagerAPIRequest (void);
    public:
                                                CThemeManagerAPIRequest (CAPIDispatcher* pAPIDispatcher);
                                                CThemeManagerAPIRequest (CAPIDispatcher* pAPIDispatcher, const CPortMessage& portMessage);
        virtual                                 ~CThemeManagerAPIRequest (void);

        virtual NTSTATUS                        Execute (CAPIDispatchSync* pAPIDispatchSync);

        static  NTSTATUS                        SessionDestroy (DWORD dwSessionID);

        static  NTSTATUS                        InitializeServerChangeNumber (void);

        static  NTSTATUS                        StaticInitialize (void);
        static  NTSTATUS                        StaticTerminate (void);
        static  NTSTATUS                        ArrayInitialize (void);
        static  NTSTATUS                        ArrayTerminate (void);
    private:
                NTSTATUS                        ImpersonateClientIfRequired (void);
                NTSTATUS                        ClientHasTcbPrivilege (void);
        static  int                             FindIndexSessionData (DWORD dwSessionID);
                NTSTATUS                        GetClientSessionData (void);

                NTSTATUS                        Execute_ThemeHooksOn (void);
                NTSTATUS                        Execute_ThemeHooksOff (void);
                NTSTATUS                        Execute_GetStatusFlags (void);
                NTSTATUS                        Execute_GetCurrentChangeNumber (void);
                NTSTATUS                        Execute_GetNewChangeNumber (void);
                NTSTATUS                        Execute_SetGlobalTheme (void);
                NTSTATUS                        Execute_MarkSection (void);
                NTSTATUS                        Execute_GetGlobalTheme (void);
                NTSTATUS                        Execute_CheckThemeSignature (void);
                NTSTATUS                        Execute_LoadTheme (void);
                NTSTATUS                        Execute_ProcessLoadTheme (CAPIDispatchSync* pAPIDispatchSync);
                NTSTATUS                        Execute_ProcessAssignSection (void);

    //  These are internal and typically require SE_TCB_PRIVILEGE to execute.

                NTSTATUS                        Execute_UserLogon (void);
                NTSTATUS                        Execute_UserLogoff (void);
                NTSTATUS                        Execute_SessionCreate (void);
                NTSTATUS                        Execute_SessionDestroy (void);
                NTSTATUS                        Execute_Ping (void);
    private:
                HANDLE                          _hToken;
                CThemeManagerSessionData*       _pSessionData;

        static  CDynamicCountedObjectArray*     s_pSessionData;
        static  CCriticalSection*               s_pLock;
        static  DWORD                           s_dwServerChangeNumber;

        static  const TCHAR                     s_szServerChangeNumberValue[];
};

#endif  /*  _ThemeManagerAPIRequest_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\thememanagerapirequest.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerAPIRequest.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the work for the theme server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ThemeManagerAPIRequest.h"
#include "ThemeManagerService.h"

#include <LPCThemes.h>
#include <uxthemep.h>
#include <UxThemeServer.h>

#include "RegistryResources.h"
#include "SingleThreadedExecution.h"
#include "StatusCode.h"
#include "TokenInformation.h"

#define STRSAFE_LIB
#include <strsafe.h>

//  --------------------------------------------------------------------------
//  Static member variables.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

CDynamicCountedObjectArray*     CThemeManagerAPIRequest::s_pSessionData                 =   NULL;
CCriticalSection*               CThemeManagerAPIRequest::s_pLock                        =   NULL;
DWORD                           CThemeManagerAPIRequest::s_dwServerChangeNumber         =   0;
const TCHAR                     CThemeManagerAPIRequest::s_szServerChangeNumberValue[]  =   TEXT("ServerChangeNumber");

#ifdef DEBUG
#define     PROCESSLOADERWAIT   DISPATCHSYNC_TIMEOUT * 10 
#else 
#define     PROCESSLOADERWAIT   DISPATCHSYNC_TIMEOUT
#endif DEBUG

//  --------------------------------------------------------------------------
//  Forward decls
//
//  History:    2002-02-26  scotthan     created
//  --------------------------------------------------------------------------
inline NTSTATUS _CheckTokenPrivilege( HANDLE hToken, DWORD dwPrivilege )
{
    CTokenInformation   tokenInformation(hToken);
    return tokenInformation.UserHasPrivilege(dwPrivilege) ? 
        STATUS_SUCCESS : STATUS_ACCESS_DENIED;
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::CThemeManagerAPIRequest
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher that calls this object.
//              pAPIConnection  =   CAPIConnection for access change.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CThemeManagerAPIRequest class. It just passes the
//              control to the super class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerAPIRequest::CThemeManagerAPIRequest (CAPIDispatcher* pAPIDispatcher) :
    CAPIRequest(pAPIDispatcher),
    _hToken(NULL),
    _pSessionData(NULL)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::CThemeManagerAPIRequest
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher that calls this object.
//              pAPIConnection  =   CAPIConnection for access change.
//              portMessage     =   CPortMessage to copy construct.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CThemeManagerAPIRequest class. It just
//              passes the control to the super class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerAPIRequest::CThemeManagerAPIRequest (
    CAPIDispatcher* pAPIDispatcher, const CPortMessage& portMessage)
        : CAPIRequest(pAPIDispatcher, portMessage),
          _hToken(NULL),
          _pSessionData(NULL)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::~CThemeManagerAPIRequest
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CThemeManagerAPIRequest class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerAPIRequest::~CThemeManagerAPIRequest (void)

{
    ASSERTMSG(_hToken == NULL, "Impersonation token not released in CThemeManagerAPIRequest::~CThemeManagerAPIRequest");
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute
//
//  Arguments:  pAPIDispatchSync - allows request execution access to various
//              service notifications and events
//
//  Returns:    NTSTATUS
//
//  Purpose:    Execute implementation for theme manager API requests. This
//              function dispatches requests based on the API request number.
//
//  History:    2000-10-10  vtan        created
//              2002-03-11  scotthan    add API_THEMES_PROCESSLOADTHEME, 
//                                          API_THEMES_PROCESSASSIGNSECTION handlers
//              2002-03-24  scotthan    add DispatchSync arg
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute (CAPIDispatchSync* pAPIDispatchSync)

{
    NTSTATUS        status;
    unsigned long   ulAPINumber;

    ulAPINumber = reinterpret_cast<API_THEMES*>(&_data)->apiGeneric.ulAPINumber & API_GENERIC_NUMBER_MASK;

    //  First try and get the client session data. If this fails then
    //  there's no object to execute the request on. Fail it.
    //  Exception to this is API_THEMES_SESSIONCREATE which creates one.

    //  Note: GetClientSessionData will store the session data in the
    //  _pSessionData member variable. While doing so it will increase
    //  reference count on this so that it doesn't get pulled from the
    //  array while the API request is being executed. The reference is
    //  released at the end of this function.

    status = GetClientSessionData();
    if (NT_SUCCESS(status) || (ulAPINumber == API_THEMES_SESSIONCREATE))
    {
        switch (ulAPINumber)
        {
            case API_THEMES_THEMEHOOKSON:
                status = Execute_ThemeHooksOn();
                break;
            case API_THEMES_THEMEHOOKSOFF:
                status = Execute_ThemeHooksOff();
                break;
            case API_THEMES_GETSTATUSFLAGS:
                status = Execute_GetStatusFlags();
                break;
            case API_THEMES_GETCURRENTCHANGENUMBER:
                status = Execute_GetCurrentChangeNumber();
                break;
            case API_THEMES_GETNEWCHANGENUMBER:
                status = Execute_GetNewChangeNumber();
                break;
            case API_THEMES_SETGLOBALTHEME:
                status = Execute_SetGlobalTheme();
                break;
            case API_THEMES_MARKSECTION:
                status = Execute_MarkSection();
                break;
            case API_THEMES_GETGLOBALTHEME:
                status = Execute_GetGlobalTheme();
                break;
            case API_THEMES_CHECKTHEMESIGNATURE:
                status = Execute_CheckThemeSignature();
                break;
            case API_THEMES_LOADTHEME:
                status = Execute_LoadTheme();
                break;
            case API_THEMES_PROCESSLOADTHEME:
                status = Execute_ProcessLoadTheme(pAPIDispatchSync);
                break;
            case API_THEMES_PROCESSASSIGNSECTION:
                status = Execute_ProcessAssignSection();
                break;
            case API_THEMES_USERLOGON:
                status = Execute_UserLogon();
                break;
            case API_THEMES_USERLOGOFF:
                status = Execute_UserLogoff();
                break;
            case API_THEMES_SESSIONCREATE:
                status = Execute_SessionCreate();
                break;
            case API_THEMES_SESSIONDESTROY:
                status = Execute_SessionDestroy();
                break;
            case API_THEMES_PING:
                status = Execute_Ping();
                break;
            default:
                DISPLAYMSG("Unknown API request in CThemeManagerAPIRequest::Execute");
                status = STATUS_NOT_IMPLEMENTED;
                break;
        }
    }

    //  If the execution function needed to impersonate the client then
    //  revert here and release the token used.

    if (_hToken != NULL)
    {
        if (RevertToSelf() == FALSE)
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
        ReleaseHandle(_hToken);
    }

    //  Release the _pSessionData object now. NULL it out to prevent
    //  accidentally using it after being released.

    if (_pSessionData != NULL)
    {
        _pSessionData->Release();
        _pSessionData = NULL;
    }

    //  Return to caller.

    TSTATUS(status);
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::SessionDestroy
//
//  Arguments:  dwSessionID     =   Session ID to destroy.
//
//  Returns:    NTSTATUS
//
//  Purpose:    External entry point for session client (winlogon) watcher.
//              When winlogon dies we clean up the session information for
//              that session and release resources.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::SessionDestroy (DWORD dwSessionID)

{
    NTSTATUS                    status;
    int                         iIndex;
    CSingleThreadedExecution    lock(*s_pLock);

    iIndex = FindIndexSessionData(dwSessionID);
    if (iIndex >= 0)
    {
        status = s_pSessionData->Remove(iIndex);
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::InitializeServerChangeNumber
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initializes the static server change number. Every time the
//              service starts up this number is incremented. If the number
//              isn't present then 0 is used.
//
//  History:    2000-12-09  vtan        created
//              2000-12-09  vtan        split from StaticInitialize
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::InitializeServerChangeNumber (void)

{
    LONG        lErrorCodeOpen, lErrorCodeRead;
    DWORD       dwServerChangeNumber;
    CRegKey     regKey;

    dwServerChangeNumber = s_dwServerChangeNumber;

    //  Initialize the static member variable now in case of failure.
    //  We ignore failures because at GUI setup the key does NOT exist
    //  because the server dll hasn't been regsvr'd yet. After GUI setup
    //  this gets regsvr'd and the key exists and we are happy campers.

    lErrorCodeOpen = regKey.Open(HKEY_LOCAL_MACHINE,
                                 TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"),
                                 KEY_QUERY_VALUE | KEY_SET_VALUE);
    if (ERROR_SUCCESS == lErrorCodeOpen)
    {
        lErrorCodeRead = regKey.GetDWORD(s_szServerChangeNumberValue, dwServerChangeNumber);
    }
    else
    {
        lErrorCodeRead = ERROR_FILE_NOT_FOUND;
    }
    dwServerChangeNumber = static_cast<WORD>(dwServerChangeNumber + 1);
    if ((ERROR_SUCCESS == lErrorCodeOpen) && (ERROR_SUCCESS == lErrorCodeRead))
    {
        TW32(regKey.SetDWORD(s_szServerChangeNumberValue, dwServerChangeNumber));
    }
    s_dwServerChangeNumber = dwServerChangeNumber;
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Static initializer for the class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::StaticInitialize (void)

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;
    if (s_pLock == NULL)
    {
        s_pLock = new CCriticalSection;
        if (s_pLock != NULL)
        {
            status = s_pLock->Status();
            if (!NT_SUCCESS(status))
            {
                delete s_pLock;
                s_pLock = NULL;
            }
        }
        else
        {
            status = STATUS_NO_MEMORY;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Static destructor for the class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::StaticTerminate (void)

{
    if (s_pLock != NULL)
    {
        delete s_pLock;
        s_pLock = NULL;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::ArrayInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initializes (allocates) the session array.
//
//  History:    2001-01-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::ArrayInitialize (void)

{
    NTSTATUS                    status;
    CSingleThreadedExecution    lock(*s_pLock);

    status = STATUS_SUCCESS;
    if (s_pSessionData == NULL)
    {
        s_pSessionData = new CDynamicCountedObjectArray;
        if (s_pSessionData == NULL)
        {
            status = STATUS_NO_MEMORY;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::ArrayTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases all objects in the session array (removes the waits)
//              and releases the session array object.
//
//  History:    2001-01-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::ArrayTerminate (void)

{
    CSingleThreadedExecution    lock(*s_pLock);

    if (s_pSessionData != NULL)
    {
        int     i, iLimit;

        iLimit = s_pSessionData->GetCount();
        for (i = iLimit - 1; i >= 0; --i)
        {
            TSTATUS(static_cast<CThemeManagerSessionData*>(s_pSessionData->Get(i))->Cleanup());
            TSTATUS(s_pSessionData->Remove(i));
        }
        delete s_pSessionData;
        s_pSessionData = NULL;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::ImpersonateClientIfRequired
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Impersonates the client if the client is NOT the SYSTEM.
//              There's usually no point impersonating the system unless the
//              token is actually a filtered token.
//
//  History:    2000-10-19  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::ImpersonateClientIfRequired (void)

{
    NTSTATUS    status;

    status = OpenClientToken(_hToken);
    if (NT_SUCCESS(status))
    {
        CTokenInformation   tokenInformation(_hToken);

        if (tokenInformation.IsUserTheSystem())
        {
            ReleaseHandle(_hToken);
            status = STATUS_SUCCESS;
        }
        else if (ImpersonateLoggedOnUser(_hToken) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::ClientHasTcbPrivilege
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Returns whether the client has the SE_TCB_PRIVILEGE as a
//              status code.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::ClientHasTcbPrivilege (void)

{
    NTSTATUS    status;
    HANDLE      hTokenClient;

    if (OpenProcessToken(_pAPIDispatcher->GetClientProcess(),
                         TOKEN_QUERY,
                         &hTokenClient) != FALSE)
    {
        status = _CheckTokenPrivilege(hTokenClient, SE_TCB_PRIVILEGE);

        TBOOL(CloseHandle(hTokenClient));
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::FindIndexSessionData
//
//  Arguments:  dwSessionID     =   Session ID to find.
//
//  Returns:    int
//
//  Purpose:    Iterates the session data array looking for the sessions that
//              matches the given session.
//
//  History:    2000-11-30  vtan        created
//  --------------------------------------------------------------------------

int     CThemeManagerAPIRequest::FindIndexSessionData (DWORD dwSessionID)

{
    int     iIndex;

    iIndex = -1;
    if ((s_pLock != NULL) && (s_pSessionData != NULL))
    {
        int     i, iLimit;

        ASSERTMSG(s_pLock->IsOwned(), "s_pLock must be acquired in CThemeManagerAPIRequest::FindIndexSessionData");
        iLimit = s_pSessionData->GetCount();
        for (i = 0; (iIndex < 0) && (i < iLimit); ++i)
        {
            CThemeManagerSessionData    *pSessionData;

            pSessionData = static_cast<CThemeManagerSessionData*>(s_pSessionData->Get(i));
            if ((pSessionData != NULL) && (pSessionData->EqualSessionID(dwSessionID)))
            {
                iIndex = i;
            }
        }
    }
    return(iIndex);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::GetClientSessionData
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Retrieves the session data associated with the client's
//              session ID. This abstracts the information from uxtheme's
//              loader code and just passes it an object it knows how to deal
//              with.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::GetClientSessionData (void)

{
    NTSTATUS                    status;
    int                         iIndex;
    CSingleThreadedExecution    lock(*s_pLock);

    status = STATUS_UNSUCCESSFUL;
    iIndex = FindIndexSessionData(_pAPIDispatcher->GetClientSessionID());
    if (iIndex >= 0)
    {
        _pSessionData = static_cast<CThemeManagerSessionData*>(s_pSessionData->Get(iIndex));
        if (_pSessionData != NULL)
        {
            _pSessionData->AddRef();
            status = STATUS_SUCCESS;
        }
    }
    else
    {
        _pSessionData = NULL;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_ThemeHooksOn
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_THEMEHOOKSON.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_ThemeHooksOn (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        API_THEMES_THEMEHOOKSON_OUT     *pAPIOut;

        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiThemeHooksOn.out;
        pAPIOut->hr = ThemeHooksOn(_pSessionData->GetData());
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_ThemeHooksOff
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_THEMEHOOKSOFF.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_ThemeHooksOff (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        API_THEMES_THEMEHOOKSOFF_OUT    *pAPIOut;

        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiThemeHooksOff.out;
        pAPIOut->hr = ThemeHooksOff(_pSessionData->GetData());
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_GetStatusFlags
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_GETSTATUSFLAGS.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_GetStatusFlags (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        DWORD                           dwFlags;
        API_THEMES_GETSTATUSFLAGS_OUT   *pAPIOut;

        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiGetStatusFlags.out;
        dwFlags = QTS_AVAILABLE;
        if (AreThemeHooksActive(_pSessionData->GetData()))
        {
            dwFlags |= QTS_RUNNING;
        }
        pAPIOut->dwFlags = dwFlags;
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_GetCurrentChangeNumber
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_GETCURRENTCHANGENUMBER.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_GetCurrentChangeNumber (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        API_THEMES_GETCURRENTCHANGENUMBER_OUT   *pAPIOut;

        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiGetCurrentChangeNumber.out;
        pAPIOut->iChangeNumber = GetCurrentChangeNumber(_pSessionData->GetData());
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_GetNewChangeNumber
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_GETNEWCHANGENUMBER.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_GetNewChangeNumber (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        API_THEMES_GETNEWCHANGENUMBER_OUT   *pAPIOut;

        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiGetNewChangeNumber.out;
        pAPIOut->iChangeNumber = GetNewChangeNumber(_pSessionData->GetData());
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_SetGlobalTheme
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_SETGLOBALTHEME.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_SetGlobalTheme (void)

{
    NTSTATUS    status;

    // Note: we must not impersonate the user here, since we need write access to the section

    HANDLE                          hSection;
    API_THEMES_SETGLOBALTHEME_IN    *pAPIIn;
    API_THEMES_SETGLOBALTHEME_OUT   *pAPIOut;

    pAPIIn = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiSetGlobalTheme.in;
    pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiSetGlobalTheme.out;
    if (pAPIIn->hSection != NULL)
    {
        if (DuplicateHandle(_pAPIDispatcher->GetClientProcess(),
                            pAPIIn->hSection,
                            GetCurrentProcess(),
                            &hSection,
                            FILE_MAP_ALL_ACCESS,
                            FALSE,
                            0) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        hSection = NULL;
        status = STATUS_SUCCESS;
    }
    if (NT_SUCCESS(status))
    {
        pAPIOut->hr = SetGlobalTheme(_pSessionData->GetData(), hSection);
        if (hSection != NULL)
        {
            TBOOL(CloseHandle(hSection));
        }
    }
    else
    {
        pAPIOut->hr = HRESULT_FROM_NT(status);
    }

    SetDataLength(sizeof(API_THEMES));
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_MarkSection
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_MARKSECTION.
//
//  History:    2001-05-08  lmouton     created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_MarkSection (void)

{
    NTSTATUS    status;

    // Note: we must not impersonate the user here, since we need write access to the section

    HANDLE                          hSection;
    DWORD                           dwAdd;
    DWORD                           dwRemove;
    API_THEMES_MARKSECTION_IN       *pAPIIn;
    API_THEMES_MARKSECTION_OUT      *pAPIOut;

    pAPIIn = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiMarkSection.in;
    pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiMarkSection.out;
    dwAdd = pAPIIn->dwAdd;
    dwRemove = pAPIIn->dwRemove;

    if (pAPIIn->hSection != NULL)
    {
        if (DuplicateHandle(_pAPIDispatcher->GetClientProcess(),
                            pAPIIn->hSection,
                            GetCurrentProcess(),
                            &hSection,
                            FILE_MAP_ALL_ACCESS,
                            FALSE,
                            0) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
            DISPLAYMSG("Execute_MarkSection: Can't get a write handle");
        }
    }
    else
    {
        hSection = NULL;
        status = STATUS_SUCCESS;
    }
    if (NT_SUCCESS(status))
    {
        if (hSection != NULL)
        {
            MarkSection(hSection, dwAdd, dwRemove);
            TBOOL(CloseHandle(hSection));
        }
    }

    SetDataLength(sizeof(API_THEMES));
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_GetGlobalTheme
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_GETGLOBALTHEME.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_GetGlobalTheme (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        HRESULT                         hr;
        HANDLE                          hSection;
        API_THEMES_GETGLOBALTHEME_OUT   *pAPIOut;

        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiGetGlobalTheme.out;
        hr = GetGlobalTheme(_pSessionData->GetData(), &hSection);
        if (SUCCEEDED(hr) && (hSection != NULL))
        {
            if (DuplicateHandle(GetCurrentProcess(),
                                hSection,
                                _pAPIDispatcher->GetClientProcess(),
                                &pAPIOut->hSection,
                                FILE_MAP_READ,
                                FALSE,
                                0) != FALSE)
            {
                hr = S_OK;
            }
            else
            {
                DWORD   dwErrorCode;

                dwErrorCode = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErrorCode);
            }
            TBOOL(CloseHandle(hSection));
        }
        pAPIOut->hr = hr;
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  LOADTHEME_STRINGS + supporting functions
//
//  Purpose:    Manages and validates LoadTheme string parameters
//
//  History:    2002-02-26  scotthan        created
//  --------------------------------------------------------------------------
typedef struct 
{
    LPWSTR pszFilename;
    LPWSTR pszColor;
    LPWSTR pszSize;

} LOADTHEME_STRINGS;

#define MAX_THEME_STRING    MAX_PATH

//  --------------------------------------------------------------------------
void _FreeThemeStrings( IN LOADTHEME_STRINGS* plts )
{
    if( plts )
    {
        _FreeMappedClientString(plts->pszFilename);
        _FreeMappedClientString(plts->pszColor);
        _FreeMappedClientString(plts->pszSize);
        delete plts;
    }
}

//  --------------------------------------------------------------------------
NTSTATUS _AllocAndMapThemeStrings( 
    IN HANDLE   hProcessClient,
    IN LPCWSTR  pszFilenameIn,
    IN UINT     cchFilenameIn,
    IN LPCWSTR  pszColorIn,
    IN UINT     cchColorIn,
    IN LPCWSTR  pszSizeIn,
    IN UINT     cchSizeIn,
    OUT LOADTHEME_STRINGS** pplts )
{
    NTSTATUS status;

    ASSERTMSG(pplts != NULL, "_AllocAndMapThemeStrings: NULL outbound parameter, LOADTHEME_STRINGS**.");
    ASSERTMSG(hProcessClient != NULL, "_AllocAndMapThemeStrings: NULL process handle.");

    //  note: cchFileNameIn, cchColorIn, cchSizeIn are char counts that include the NULL terminus.
    if( pszFilenameIn && pszColorIn && pszSizeIn &&
        cchFilenameIn > 0 && cchColorIn > 0 && cchSizeIn > 0 &&
        cchFilenameIn <= MAX_THEME_STRING && cchColorIn <= MAX_THEME_STRING && cchSizeIn <= MAX_THEME_STRING )
    {
        *pplts = NULL;

        LOADTHEME_STRINGS *plts = new LOADTHEME_STRINGS;

        if( plts != NULL )
        {
            ZeroMemory(plts, sizeof(*plts));

            status = _AllocAndMapClientString(hProcessClient, pszFilenameIn, cchFilenameIn, MAX_THEME_STRING, &plts->pszFilename);
            if( NT_SUCCESS(status) )
            {
                status = _AllocAndMapClientString(hProcessClient, pszColorIn, cchColorIn, MAX_THEME_STRING, &plts->pszColor);
                if( NT_SUCCESS(status) )
                {
                    status = _AllocAndMapClientString(hProcessClient, pszSizeIn, cchSizeIn, MAX_THEME_STRING, &plts->pszSize);
                    if( NT_SUCCESS(status) )
                    {
                        *pplts = plts;
                    }
                }
            }

            if( !NT_SUCCESS(status) )
            {
                _FreeThemeStrings(plts);
            }
        }
        else
        {
            status = STATUS_NO_MEMORY;
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;       
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_CheckThemeSignature
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_CHECKTHEMESIGNATURE.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_CheckThemeSignature (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        API_THEMES_CHECKTHEMESIGNATURE_IN   *pAPIIn;
        API_THEMES_CHECKTHEMESIGNATURE_OUT  *pAPIOut;
        LPWSTR                              pszThemeFileName;

        pAPIIn = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiCheckThemeSignature.in;
        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiCheckThemeSignature.out;

        status = _AllocAndMapClientString(_pAPIDispatcher->GetClientProcess(), 
                                          pAPIIn->pszName, 
                                          pAPIIn->cchName, 
                                          MAX_PATH, 
                                          &pszThemeFileName);
        if( NT_SUCCESS(status) )
        {
            pAPIOut->hr = CheckThemeSignature(pszThemeFileName);
            status = STATUS_SUCCESS;

            _FreeMappedClientString(pszThemeFileName);
        }
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_LoadTheme
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_LOADTHEME.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_LoadTheme (void)

{
    NTSTATUS    status;

    BOOL fTcb = NT_SUCCESS(ClientHasTcbPrivilege());


    status = ImpersonateClientIfRequired();

    if (NT_SUCCESS(status))
    {
        HANDLE                      hProcessClient;
        API_THEMES_LOADTHEME_IN     *pAPIIn;
        API_THEMES_LOADTHEME_OUT    *pAPIOut;
        LOADTHEME_STRINGS*          plts;

        hProcessClient = _pAPIDispatcher->GetClientProcess();
        pAPIIn = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiLoadTheme.in;
        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiLoadTheme.out;

        status = _AllocAndMapThemeStrings( hProcessClient, pAPIIn->pszName, pAPIIn->cchName,
                                           pAPIIn->pszColor, pAPIIn->cchColor,
                                           pAPIIn->pszSize, pAPIIn->cchSize,
                                           &plts );
        if( NT_SUCCESS(status) )
        {
            HANDLE  hSectionIn, hSectionOut;

            if (DuplicateHandle(hProcessClient,
                                pAPIIn->hSection,
                                GetCurrentProcess(),
                                &hSectionIn,
                                FILE_MAP_ALL_ACCESS,
                                FALSE,
                                0) != FALSE)
            {
                status = STATUS_SUCCESS;

                //  Only clients with TCB privilege can load a global theme section.
                //  We don't want stock object ownership here; let the client clean them up on failure.
                DWORD dwLoadFlags = fTcb ? LTF_GLOBALPRIVILEGEDCLIENT : 0;
                
                // Warning: this function will revert to self in order to create the section in system context.
                // Impersonate the user again after it if needed
                pAPIOut->hr = LoadTheme(_pSessionData->GetData(), hSectionIn, &hSectionOut, 
                                        plts->pszFilename, plts->pszColor, plts->pszSize, dwLoadFlags);

                if (SUCCEEDED(pAPIOut->hr))
                {
                    // Still running in the system context here
                    if (DuplicateHandle(GetCurrentProcess(),
                                        hSectionOut,
                                        hProcessClient,
                                        &pAPIOut->hSection,
                                        FILE_MAP_READ,
                                        FALSE,
                                        0) == FALSE)
                    {
                        status = CStatusCode::StatusCodeOfLastError();
                    }
                    TBOOL(CloseHandle(hSectionOut));
                }
                TBOOL(CloseHandle(hSectionIn));
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }

            _FreeThemeStrings(plts);
        }
    }

    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_ProcessLoadTheme
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_PROCESSLOADTHEME.
//
//  History:    2002-02-26  scotthan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_ProcessLoadTheme(
    CAPIDispatchSync* pAPIDispatchSync)

{
    NTSTATUS                        status;
    CLoaderProcess                  *pLoader = NULL;
    API_THEMES_PROCESSLOADTHEME_IN  *pAPIIn;
    API_THEMES_PROCESSLOADTHEME_OUT *pAPIOut;
    HANDLE                          hProcessClient;
    HANDLE                          hLoaderProcess = NULL;

    s_pLock->Acquire();

    pAPIIn  = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiProcessLoadTheme.in;
    pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiProcessLoadTheme.out;
    hProcessClient = _pAPIDispatcher->GetClientProcess();

    if( !CAPIDispatchSync::IsServiceStopping(pAPIDispatchSync) )
    {
        status = _pSessionData->GetLoaderProcess(&pLoader);

        if( NT_SUCCESS(status) )
        {
            status = 
            //  do we already have a loader?
            status = pLoader->IsAlive() ? STATUS_ACCESS_DENIED : STATUS_SUCCESS;

            if( NT_SUCCESS(status) )
            {
                status = ImpersonateClientIfRequired();
        
                if (NT_SUCCESS(status))
                {
                    LOADTHEME_STRINGS*                  plts;

                    if( NT_SUCCESS(status) )
                    {
                        status = _AllocAndMapThemeStrings( hProcessClient, 
                                                           pAPIIn->pszName, pAPIIn->cchName,
                                                           pAPIIn->pszColor, pAPIIn->cchColor,
                                                           pAPIIn->pszSize, pAPIIn->cchSize,
                                                           &plts );
                        if( NT_SUCCESS(status) )
                        {
                            HANDLE  hTokenClient;

                            if( OpenProcessToken(hProcessClient, 
                                                 TOKEN_ASSIGN_PRIMARY| TOKEN_DUPLICATE | TOKEN_QUERY, 
                                                 &hTokenClient) )
                            {
                                //  SECURITY: Launch process with client credentials to load the theme.
                                status = pLoader->Create(_pSessionData->GetData(), hTokenClient, NULL, 
                                                         plts->pszFilename, plts->pszColor, plts->pszSize, 
                                                         &hLoaderProcess);
                                CloseHandle(hTokenClient);

                            }
                            else
                            {
                                status = CStatusCode::StatusCodeOfLastError();
                            }
                    
                            _FreeThemeStrings(plts);
                        }
                    }
                }
            }
        }
    }
    else // !CThemeManagerService::'()
    {
        status = STATUS_PORT_DISCONNECTED;
    }

    s_pLock->Release();

    pAPIOut->hSection = NULL;
    pAPIOut->hr = E_FAIL;

    
    //  If we launched a loader process, block until its finished
    if( NT_SUCCESS(status) )
    {
        ASSERTMSG(hLoaderProcess != NULL, "CThemeManagerAPIRequest::Execute_ProcessLoadTheme - NULL loader process.");

        HANDLE hStopEvent = CAPIDispatchSync::GetServiceStoppingEvent(pAPIDispatchSync);
        ASSERTMSG(hStopEvent != NULL, "CThemeManagerAPIRequest::Execute_ProcessLoadTheme - NULL Stop event");
        
        HANDLE rgHandles[2];
        
        rgHandles[0] = hLoaderProcess;
        rgHandles[1] = hStopEvent;

         // paranoia: assign default status in case we fall out
        status = STATUS_REQUEST_ABORTED;

        DWORD dwWait = WaitForMultipleObjects(ARRAYSIZE(rgHandles), rgHandles, FALSE, PROCESSLOADERWAIT);

        switch(dwWait)
        {
            case WAIT_OBJECT_0:    // hLoaderProcess
                status = STATUS_SUCCESS;
                break;

            case WAIT_OBJECT_0+1:  // hStopEvent
                status = STATUS_PORT_DISCONNECTED;
                break;

            case WAIT_TIMEOUT:
                status = STATUS_TIMEOUT;
                DISPLAYMSG("Execute_ProcessLoadTheme - Timed out waiting for loader process.");
                break;
        }

        //  default the LPC return code to current status code
        pAPIOut->hr = HRESULT_FROM_NT(status);

        //  By the time the process is finished, we'll have a theme memory section
        //  stored in the loader process object, transacted via API_THEMES_PROCESSASSIGNSECTION.
        //  Let's fetch it and hand it back to our caller.

        s_pLock->Acquire();

        NTSTATUS statusLoader = _pSessionData->GetLoaderProcess(&pLoader);

        if( NT_SUCCESS(statusLoader) )
        {
            HANDLE hSectionOut = pLoader->GetSectionHandle(TRUE);

            //  did we unblock from the loader?
            if( NT_SUCCESS(status) )
            {
                pAPIOut->hr = pLoader->GetHResult();

#ifdef DEBUG
                if( SUCCEEDED(pAPIOut->hr) )
                {
                    ASSERTMSG(hSectionOut != NULL, "CThemeManagerAPIRequest::Execute_ProcessLoadTheme - Success means valid section handle!");
                }
#endif DEBUG

                if( hSectionOut )
                {
                    BOOL fDuped = DuplicateHandle(GetCurrentProcess(),
                                                  hSectionOut,
                                                  hProcessClient,
                                                  &pAPIOut->hSection,
                                                  FILE_MAP_READ,
                                                  FALSE,
                                                  0);
            
                    // Still running in the system context here
                    if( !fDuped )
                    {
                        // couldn't duplicate handle.  This means we'll never clean stock objects.
                        ASSERTMSG(fDuped, "Failed to duplicate theme handle; leaking visual style stock objects");

                        status = CStatusCode::StatusCodeOfLastError();
                        pAPIOut->hr = HRESULT_FROM_NT(status); 
                    }
                }
            }
            else
            {
                ASSERTMSG(pAPIOut->hr == HRESULT_FROM_NT(status), 
                          "CThemeManagerAPIRequest::Execute_ProcessLoadTheme - failing to preserve proper status errror code.");

                if( hSectionOut )
                {
                    THR(ServiceClearStockObjects(_pSessionData->GetData(), hSectionOut));
                    pAPIOut->hSection = NULL;
                }
            }

            if( hSectionOut )
            {
                CloseHandle(hSectionOut);
            }

            //  prepare the loader object for the next request.
            pLoader->Clear(_pSessionData->GetData(), TRUE);
        }
        else  // NT_SUCCESS(_pSessionData->GetLoaderProcess).
        {
            status = statusLoader;
            pAPIOut->hr = HRESULT_FROM_NT(status); 
        }
    
        s_pLock->Release();
    }
    else
    {
        pAPIOut->hr = HRESULT_FROM_NT(status); 
    }

    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_ProcessAssignSection
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_PROCESSASSIGNSECTION.
//
//  History:    2002-02-26  scotthan        created
//  --------------------------------------------------------------------------

NTSTATUS CThemeManagerAPIRequest::Execute_ProcessAssignSection (void)
{
    //  Note: The following must be true for this part of the 
    //        Load/ApplySecureTheme sequence to be truly secure:
    //
    //        1. There is a theme service worker thread handling API_THEMES_PROCESSLOADTHEME
    //           now.  That handler launched a secure session loader process, 
    //        2. The API_THEMES_PROCESSLOADTHEME handler's thread is waiting for 
    //           secure session loader process to terminate.
    //        3. The only process that should be sending the API_THEMES_PROCESSASSIGNSECTION request 
    //           is the same secure session loader process.

    // _data is a hippo-union; store off in params to init out params
    API_THEMES_PROCESSASSIGNSECTION_IN  *pAPIIn;

    pAPIIn = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiProcessAssignSection.in;
    HRESULT hrClient       = pAPIIn->hrLoad;
    HANDLE  hClientSection = pAPIIn->hSection;

    // init out params
    API_THEMES_PROCESSASSIGNSECTION_OUT *pAPIOut;

    pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiProcessAssignSection.out;
    pAPIOut->hr = E_FAIL;

    //  all of this takes place under the session data lock.
    s_pLock->Acquire();

    CLoaderProcess* pLoader = NULL;
    NTSTATUS        status = _pSessionData->GetLoaderProcess(&pLoader);

    if( NT_SUCCESS(status) )
    {
        HANDLE hProcessClient = _pAPIDispatcher->GetClientProcess();
        if( pLoader->IsProcessLoader(hProcessClient) )
        {
            //  manage errors as nt status codes until the very end.
            status = hrClient & ~FACILITY_NT_BIT;
   
            //  any work to do?
            if( NT_SUCCESS(status) )
            {
                status = ImpersonateClientIfRequired();

                if( NT_SUCCESS(status) )
                {
                    HANDLE hSectionReadWrite = NULL;
                    //  Map the incoming read-write section handle to 
                    //  theme service's address space
                    if (DuplicateHandle(hProcessClient,
                                        hClientSection,
                                        GetCurrentProcess(),
                                        &hSectionReadWrite,
                                        FILE_MAP_ALL_ACCESS,
                                        FALSE,
                                        0) != FALSE)
                    {
                        // Copy the incoming read-write section to a read-only section, update the theme change count

                        // Warning: this function will revert to self in order to create the 
                        //          section in the system context. Impersonate the user again after it if needed

                        HANDLE  hSectionReadOnly = NULL;
                        status = pLoader->ValidateAndCopySection(_pSessionData->GetData(), 
                                                                 hSectionReadWrite, 
                                                                 &hSectionReadOnly);

                        //  no longer don't need our dupe of the incoming, read-write section.
                        CloseHandle(hSectionReadWrite);
                    }
                    else // DuplicateHandle
                    {
                        status = CStatusCode::StatusCodeOfLastError();
                        pLoader->SetHResult(HRESULT_FROM_NT(status));
                    }
                }
                else // NT_SUCCESS(ImpersonateClientIfRequired)
                {
                    status = CStatusCode::StatusCodeOfLastError();
                    pLoader->SetHResult(HRESULT_FROM_NT(status));
                }
            }
            else // SUCCEEDED(hrClient)
            {
                pLoader->SetHResult(HRESULT_FROM_NT(status));
                DISPLAYMSG("CThemeManagerAPIRequest::Execute_ProcessAssignSection: client failed section creation");
            }
        }
        else  // CLoaderProcess::IsProcessLoader
        {
            status = E_ACCESSDENIED;
            DISPLAYMSG("CThemeManagerAPIRequest::Execute_ProcessAssignSection::IsProcessLoader failed");
        }
    }

    pAPIOut->hr = HRESULT_FROM_NT(status);

    s_pLock->Release();
    SetDataLength(sizeof(API_THEMES));
    return(status);
}


//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_UserLogon
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_USERLOGON. To call this API you must have
//              the SE_TCB_PRIVILEGE in your token.
//
//  History:    2000-10-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_UserLogon (void)

{
    NTSTATUS    status;

    status = ClientHasTcbPrivilege();
    if (NT_SUCCESS(status))
    {
        HANDLE                      hToken;
        API_THEMES_USERLOGON_IN     *pAPIIn;

        pAPIIn = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiUserLogon.in;
        if (DuplicateHandle(_pAPIDispatcher->GetClientProcess(),
                            pAPIIn->hToken,
                            GetCurrentProcess(),
                            &hToken,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS) != FALSE)
        {
            status = _pSessionData->UserLogon(hToken);
            TBOOL(CloseHandle(hToken));
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_UserLogoff
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_USERLOGOFF. To call this API you must have
//              the SE_TCB_PRIVILEGE in your token.
//
//  History:    2000-10-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_UserLogoff (void)

{
    NTSTATUS    status;

    status = ClientHasTcbPrivilege();
    if (NT_SUCCESS(status))
    {
        status = _pSessionData->UserLogoff();
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_SessionCreate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_SESSIONCREATE. To call this API you must
//              have the SE_TCB_PRIVILEGE in your token.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_SessionCreate (void)

{
    NTSTATUS    status;

    status = ClientHasTcbPrivilege();
    if (NT_SUCCESS(status))
    {
        HANDLE                      hProcessClient;
        CThemeManagerSessionData    *pSessionData;

        ASSERTMSG(_pSessionData == NULL, "Session data already exists in CThemeManagerAPIRequest::Execute_SessionCreate");
        if (DuplicateHandle(GetCurrentProcess(),
                            _pAPIDispatcher->GetClientProcess(),
                            GetCurrentProcess(),
                            &hProcessClient,
                            PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE,
                            FALSE,
                            0) != FALSE)
        {
            DWORD   dwSessionID;

            dwSessionID = _pAPIDispatcher->GetClientSessionID();
            pSessionData = new CThemeManagerSessionData(dwSessionID);
            if (pSessionData != NULL)
            {
                API_THEMES_SESSIONCREATE_IN     *pAPIIn;

                pAPIIn = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiSessionCreate.in;
                status = pSessionData->Allocate(hProcessClient,
                                                s_dwServerChangeNumber,
                                                pAPIIn->pfnRegister,
                                                pAPIIn->pfnUnregister,
                                                pAPIIn->pfnClearStockObjects,
                                                pAPIIn->dwStackSizeReserve,
                                                pAPIIn->dwStackSizeCommit);
                if (NT_SUCCESS(status))
                {
                    int                         iIndex;
                    CSingleThreadedExecution    lock(*s_pLock);

                    //  Find the session data in the static array. If found
                    //  then remove the entry (don't allow duplicates).

                    iIndex = FindIndexSessionData(dwSessionID);
                    if (iIndex >= 0)
                    {
                        status = s_pSessionData->Remove(iIndex);
                    }

                    //  If the static array has been destroyed (the service has been
                    //  stopped) then don't do anything - this is not an error.

                    if (NT_SUCCESS(status) && (s_pSessionData != NULL))
                    {
                        status = s_pSessionData->Add(pSessionData);
                    }
                }
                pSessionData->Release();
            }
            else
            {
                status = STATUS_NO_MEMORY;
            }
            TBOOL(CloseHandle(hProcessClient));
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_SessionDestroy
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_SESSIONDESTROY. To call this API you must
//              have the SE_TCB_PRIVILEGE in your token.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_SessionDestroy (void)

{
    NTSTATUS    status;

    status = ClientHasTcbPrivilege();
    if (NT_SUCCESS(status))
    {
        int                         iIndex;
        CSingleThreadedExecution    lock(*s_pLock);

        iIndex = FindIndexSessionData(_pAPIDispatcher->GetClientSessionID());
        if (iIndex >= 0)
        {
            status = s_pSessionData->Remove(iIndex);
        }
        else
        {
            status = STATUS_SUCCESS;
        }
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_Ping
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_PING. Tell the client we're alive.
//
//  History:    2000-11-30  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_Ping (void)

{
    SetDataLength(sizeof(API_THEMES));
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\thememanagerapiserver.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerAPIServer.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains several classes that implemention virtual functions
//  for complete LPC functionality.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#define STRSAFE_LIB
#include <strsafe.h>

#include "ThemeManagerAPIServer.h"

#include <lpcthemes.h>

#include "ThemeManagerDispatcher.h"
#include "ThemeManagerService.h"

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::CThemeManagerAPIServer
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CThemeManagerAPIServer class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerAPIServer::CThemeManagerAPIServer (void)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::~CThemeManagerAPIServer
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CThemeManagerAPIServer class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerAPIServer::~CThemeManagerAPIServer (void)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::ConnectToServer
//
//  Arguments:  phPort  =   Handle to the port received on connection.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Connects to the server.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIServer::ConnectToServer (HANDLE *phPort)

{
    ULONG                           ulConnectionInfoLength;
    UNICODE_STRING                  portName;
    SECURITY_QUALITY_OF_SERVICE     sqos;
    WCHAR                           szConnectionInfo[64];

    RtlInitUnicodeString(&portName, GetPortName());
    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = TRUE;
    StringCchCopyW(szConnectionInfo, ARRAYSIZE(szConnectionInfo), THEMES_CONNECTION_REQUEST);
    ulConnectionInfoLength = sizeof(szConnectionInfo);
    return(NtConnectPort(phPort,
                         &portName,
                         &sqos,
                         NULL,
                         NULL,
                         NULL,
                         szConnectionInfo,
                         &ulConnectionInfoLength));
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::GetPortName
//
//  Arguments:  <none>
//
//  Returns:    const WCHAR*
//
//  Purpose:    Uses a common routine to get the theme API port name.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

const WCHAR*    CThemeManagerAPIServer::GetPortName (void)

{
    return(THEMES_PORT_NAME);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::GetPortName
//
//  Arguments:  <none>
//
//  Returns:    const TCHAR*
//
//  Purpose:    Uses a common routine to get the theme service name.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

const TCHAR*    CThemeManagerAPIServer::GetServiceName (void)

{
    return(CThemeManagerService::GetName());
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::ConnectionAccepted
//
//  Arguments:  portMessage     =   PORT_MESSAGE from client.
//
//  Returns:    bool
//
//  Purpose:    Accepts or rejects a port connection request. Accepts all
//              connections currently.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

bool    CThemeManagerAPIServer::ConnectionAccepted (const CPortMessage& portMessage)

{
    return(lstrcmpW(reinterpret_cast<const WCHAR*>(portMessage.GetData()), THEMES_CONNECTION_REQUEST) == 0);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::CreateDispatcher
//
//  Arguments:  portMessage     =   PORT_MESSAGE from client.
//
//  Returns:    CAPIDispatcher*
//
//  Purpose:    Called by the LPC connection request handler to create a new
//              thread to handle client requests.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CAPIDispatcher*     CThemeManagerAPIServer::CreateDispatcher (const CPortMessage& portMessage)

{
    HANDLE              hClientProcess;
    OBJECT_ATTRIBUTES   objectAttributes;
    CLIENT_ID           clientID;
    CAPIDispatcher      *pAPIDispatcher;

    pAPIDispatcher = NULL;
    InitializeObjectAttributes(&objectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);
    clientID.UniqueProcess = portMessage.GetUniqueProcess();
    clientID.UniqueThread = NULL;

    //  Open a handle to the client process. The handle must have PROCESS_DUP_HANDLE
    //  for the server to be able to deliver handles to the client. It also needs
    //  PROCESS_VM_READ | PROCESS_VM_WRITE if it's to read and write the client
    //  address space to store data that's too big for the LPC port.

    //  That handle is stored by the thread handler. It's not closed here.

    if (NT_SUCCESS(NtOpenProcess(&hClientProcess,
                                 PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
                                 &objectAttributes,
                                 &clientID)))
    {
        pAPIDispatcher = new CThemeManagerDispatcher(hClientProcess);
    }
    return(pAPIDispatcher);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::Connect
//
//  Arguments:  phPort  =   Connection port returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Connects to the server.
//
//  History:    2000-10-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIServer::Connect (HANDLE* phPort)

{
    return(ConnectToServer(phPort));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\thememanagerapiserver.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerAPIServer.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains several classes that implemention virtual functions
//  for complete LPC functionality.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ThemeManagerAPIServer_
#define     _ThemeManagerAPIServer_

#include "ServerAPI.h"

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer
//
//  Purpose:    This class implements the interface that the
//              CAPIConnectionThread uses to create create the LPC port,
//              accept or reject connections to the LPC port and create the
//              LPC request handling thread.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

class   CThemeManagerAPIServer : public CServerAPI
{
    public:
                                    CThemeManagerAPIServer (void);
        virtual                     ~CThemeManagerAPIServer (void);

                NTSTATUS            ConnectToServer (HANDLE *phPort);
    protected:
        virtual const WCHAR*        GetPortName (void);
        virtual const TCHAR*        GetServiceName (void);
        virtual bool                ConnectionAccepted (const CPortMessage& portMessage);
        virtual CAPIDispatcher*     CreateDispatcher (const CPortMessage& portMessage);
        virtual NTSTATUS            Connect (HANDLE* phPort);
};

#endif  /*  _ThemeManagerAPIServer_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\thememanagerdispatcher.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerDispatcher.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements dispatching work for the
//  theme server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifndef     _ThemeManagerDispatcher_
#define     _ThemeManagerDispatcher_

#include "APIDispatcher.h"
#include "PortMessage.h"
#include "ServerAPI.h"

//  --------------------------------------------------------------------------
//  CThemeManagerDispatcher
//
//  Purpose:    This sub-class implements CAPIDispatcher::QueueRequest to
//              create a CThemeManagerRequest which knows how to handle
//              API requests for the theme manager.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

class   CThemeManagerDispatcher : public CAPIDispatcher
{
    private:
                                    CThemeManagerDispatcher (void);
    public:
                                    CThemeManagerDispatcher (HANDLE hClientProcess);
        virtual                     ~CThemeManagerDispatcher (void);

        virtual NTSTATUS            CreateAndQueueRequest (const CPortMessage& portMessage);
        virtual NTSTATUS            CreateAndExecuteRequest (const CPortMessage& portMessage);
};

#endif  /*  _ThemeManagerDispatcher_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\thememanagerdispatcher.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerDispatcher.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements dispatching work for the
//  theme server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ThemeManagerDispatcher.h"

#include "ThemeManagerAPIRequest.h"

//  --------------------------------------------------------------------------
//  CThemeManagerDispatcher::CThemeManagerDispatcher
//
//  Arguments:  hClientProcess  =   HANDLE to the client process.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CThemeManagerDispatcher class. This
//              stores the client handle. It does not duplicate it.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerDispatcher::CThemeManagerDispatcher (HANDLE hClientProcess) :
    CAPIDispatcher(hClientProcess)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerDispatcher::~CThemeManagerDispatcher
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CThemeManagerDispatcher class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerDispatcher::~CThemeManagerDispatcher (void)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerDispatcher::CreateAndQueueRequest
//
//  Arguments:  portMessage     =   PORT_MESSAGE request to queue to handler.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Queues the client request to the dispatcher. Tells the
//              handler thread that there is input waiting. This function
//              knows what kind of CAPIRequest to create so that
//              CAPIRequest::Execute will work correctly.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerDispatcher::CreateAndQueueRequest (const CPortMessage& portMessage)

{
    NTSTATUS        status;
    CQueueElement   *pQueueElement;

    pQueueElement = new CThemeManagerAPIRequest(this, portMessage);
    if (pQueueElement != NULL)
    {
        _queue.Add(pQueueElement);
        status = SignalRequestPending();
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerDispatcher::CreateAndExecuteRequest
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Executes the given request immediately and returns the result
//              back to the caller. The API request is done on the server
//              listen thread.
//
//  History:    2000-10-19  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerDispatcher::CreateAndExecuteRequest (const CPortMessage& portMessage)

{
    NTSTATUS        status;
    CAPIRequest     *pAPIRequest;

    pAPIRequest = new CThemeManagerAPIRequest(this, portMessage);
    if (pAPIRequest != NULL)
    {
        status = Execute(pAPIRequest);
        delete pAPIRequest;
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\thememanagersessiondata.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerSessionData.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements information the encapsulates a
//  client TS session for the theme server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ThemeManagerSessionData.h"

#define STRSAFE_LIB
#include <strsafe.h>

#include <uxthemep.h>
#include <UxThemeServer.h>

#include "SingleThreadedExecution.h"
#include "StatusCode.h"
#include "ThemeManagerAPIRequest.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::s_pAPIConnection
//
//  Purpose:    Static member variables.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

CAPIConnection*     CThemeManagerSessionData::s_pAPIConnection  =   NULL;

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::CThemeManagerSessionData
//
//  Arguments:  pAPIConnection  =   CAPIConnection for port access control.
//              dwSessionID     =   Session ID.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CThemeManagerSessionData.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerSessionData::CThemeManagerSessionData (DWORD dwSessionID) :
    _dwSessionID(dwSessionID),
    _pvThemeLoaderData(NULL),
    _hToken(NULL),
    _hProcessClient(NULL),
    _pLoader(NULL),
    _hWait(NULL)
{
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::~CThemeManagerSessionData
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CThemeManagerSessionData.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerSessionData::~CThemeManagerSessionData (void)

{
    ASSERTMSG(_hWait == NULL, "Wait not executed or removed in CThemeManagerSessionData::~CThemeManagerSessionData");
    ASSERTMSG(_hProcessClient == NULL, "_hProcessClient not closed in CThemeManagerSessionData::~CThemeManagerSessionData");

    //   if this session's theme loader process is still alive, clear and delete it.
    if( _pLoader )
    {
        _pLoader->Clear(_pvThemeLoaderData, TRUE);
        delete _pLoader;
        _pLoader = NULL;
    }

    TSTATUS(UserLogoff());
    if (_pvThemeLoaderData != NULL)
    {
        SessionFree(_pvThemeLoaderData);
        _pvThemeLoaderData = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::GetData
//
//  Arguments:  <none>
//
//  Returns:    void*
//
//  Purpose:    Returns the internal data blob allocated by SessionCreate.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

void*   CThemeManagerSessionData::GetData (void)  const

{
    return(_pvThemeLoaderData);
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::EqualSessionID
//
//  Arguments:  dwSessionID
//
//  Returns:    bool
//
//  Purpose:    Returns whether the given session ID matches this session
//              data.
//
//  History:    2000-11-30  vtan        created
//  --------------------------------------------------------------------------

bool    CThemeManagerSessionData::EqualSessionID (DWORD dwSessionID)  const

{
    return(dwSessionID == _dwSessionID);
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::Allocate
//
//  Arguments:  hProcessClient  =   Handle to the client process.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Allocates a data blob via SessionCreate which also keeps a
//              handle to the client process that initiated the session. This
//              is always winlogon in the client session ID.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerSessionData::Allocate (HANDLE hProcessClient, DWORD dwServerChangeNumber, void *pfnRegister, void *pfnUnregister, void *pfnClearStockObjects, DWORD dwStackSizeReserve, DWORD dwStackSizeCommit)

{
    NTSTATUS    status;

    if (DuplicateHandle(GetCurrentProcess(),
                        hProcessClient,
                        GetCurrentProcess(),
                        &_hProcessClient,
                        SYNCHRONIZE,
                        FALSE,
                        0) != FALSE)
    {
        ASSERTMSG(_hWait == NULL, "_hWait already exists in CThemeManagerSessionData::Allocate");
        AddRef();
        if (RegisterWaitForSingleObject(&_hWait,
                                        _hProcessClient,
                                        CB_SessionTermination,
                                        this,
                                        INFINITE,
                                        WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE) != FALSE)
        {
            _pvThemeLoaderData = SessionAllocate(hProcessClient, dwServerChangeNumber, pfnRegister, pfnUnregister, pfnClearStockObjects, dwStackSizeReserve, dwStackSizeCommit);
            if (_pvThemeLoaderData != NULL)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                status = STATUS_NO_MEMORY;
            }
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
        if (!NT_SUCCESS(status))
        {
            HANDLE  hWait;

            //  In the case of failure grab the _hWait and try to unregister it.
            //  If the unregister fails then the callback is already executing
            //  and there's little we can to stop it. This means that the winlogon
            //  for the client session died between the time we entered this function
            //  and registered the wait and now. If the unregister worked then then
            //  callback hasn't executed so just release the resources.

            hWait = InterlockedExchangePointer(&_hWait, NULL);
            if (hWait != NULL)
            {
                if (UnregisterWait(hWait) != FALSE)
                {
                    Release();
                }
                ReleaseHandle(_hProcessClient);
                if (_pvThemeLoaderData != NULL)
                {
                    SessionFree(_pvThemeLoaderData);
                    _pvThemeLoaderData = NULL;
                }
            }
        }
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::Cleanup
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Used to unregister the wait on the client process. This is
//              necessary to prevent the callback from occurring after the
//              service has been shut down which will cause access to a static
//              member variable that is NULL'd out.
//
//  History:    2001-01-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerSessionData::Cleanup (void)

{
    HANDLE  hWait;

    hWait = InterlockedExchangePointer(&_hWait, NULL);
    if (hWait != NULL)
    {
        if (UnregisterWait(hWait) != FALSE)
        {
            Release();
        }
        ReleaseHandle(_hProcessClient);
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::UserLogon
//
//  Arguments:  hToken  =   Handle to the token of the user logging on.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Saves a copy of the token for use at log off. Allows access
//              to the theme port to the logon SID of the token.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerSessionData::UserLogon (HANDLE hToken)

{
    NTSTATUS    status;

    if (_hToken == NULL)
    {
        if (DuplicateHandle(GetCurrentProcess(),
                            hToken,
                            GetCurrentProcess(),
                            &_hToken,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS) != FALSE)
        {
            PSID                pSIDLogon;
            CTokenInformation   token(hToken);

            pSIDLogon = token.GetLogonSID();
            if (pSIDLogon != NULL)
            {
                if (s_pAPIConnection != NULL)
                {
                    status = s_pAPIConnection->AddAccess(pSIDLogon, PORT_CONNECT);
                }
                else
                {
                    status = STATUS_SUCCESS;
                }
            }
            else
            {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::UserLogoff
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Remove access to the theme port for the user being logged off.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerSessionData::UserLogoff (void)

{
    NTSTATUS    status;

    if (_hToken != NULL)
    {
        PSID                pSIDLogon;
        CTokenInformation   token(_hToken);

        pSIDLogon = token.GetLogonSID();
        if (pSIDLogon != NULL)
        {
            if (s_pAPIConnection != NULL)
            {
                status = s_pAPIConnection->RemoveAccess(pSIDLogon);
            }
            else
            {
                status = STATUS_SUCCESS;
            }
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
        ReleaseHandle(_hToken);
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::SetAPIConnection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Sets the static CAPIConnection for port access changes.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

void    CThemeManagerSessionData::SetAPIConnection (CAPIConnection *pAPIConnection)

{
    pAPIConnection->AddRef();
    s_pAPIConnection = pAPIConnection;
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::ReleaseAPIConnection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases the static CAPIConnection for port access changes.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

void    CThemeManagerSessionData::ReleaseAPIConnection (void)

{
    s_pAPIConnection->Release();
    s_pAPIConnection = NULL;
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::GetLoaderProcess
//
//  Arguments:  (none)
//
//  Returns:    (n/a)
//
//  Purpose:    STATUS_SUCCESS if it worked, otherwise an error status code K
//
//  History:    2002-02-26  scotthan        created
//  --------------------------------------------------------------------------
NTSTATUS CThemeManagerSessionData::GetLoaderProcess( OUT CLoaderProcess** ppLoader )
{
    ASSERTBREAKMSG(ppLoader != NULL, "CThemeManagerSessionData::GetLoaderProcess - invalid output address.");
    *ppLoader = NULL;

    if( (NULL == _pLoader) && (NULL == (_pLoader = new CLoaderProcess)) )
    {
        return STATUS_NO_MEMORY;
    }

    *ppLoader = _pLoader;
    return STATUS_SUCCESS;
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::SessionTermination
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Callback on winlogon process termination for a given session.
//              We clean up the session specific data blob when this happens.
//              This allows the process handles on winlogon to be released.
//              If this isn't done then a zombie lives and the session is
//              never reclaimed.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

void    CThemeManagerSessionData::SessionTermination (void)

{
    HANDLE  hWait;

    hWait = InterlockedExchangePointer(&_hWait, NULL);
    if (hWait != NULL)
    {
        (BOOL)UnregisterWait(hWait);
        ReleaseHandle(_hProcessClient);
    }
    CThemeManagerAPIRequest::SessionDestroy(_dwSessionID);
    Release();
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::CB_SessionTermination
//
//  Arguments:  pParameter          =   This object.
//              TimerOrWaitFired    =   Not used.
//
//  Returns:    <none>
//
//  Purpose:    Callback stub to member function.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CThemeManagerSessionData::CB_SessionTermination (void *pParameter, BOOLEAN TimerOrWaitFired)

{
    UNREFERENCED_PARAMETER(TimerOrWaitFired);

    static_cast<CThemeManagerSessionData*>(pParameter)->SessionTermination();
}

//  --------------------------------------------------------------------------
//  CLoaderProcess::CLoaderProcess
//
//  Arguments:  n/a
//
//  Returns:    <none>
//
//  Purpose:    CLoaderProcess constructor
//
//  History:    2002-03-06   scotthan        created
//  --------------------------------------------------------------------------
CLoaderProcess::CLoaderProcess()
    : _pszFile(NULL),
      _pszColor(NULL),
      _pszSize(NULL),
      _hSection(NULL),
      _hr(0)
{
    ZeroMemory(&_process_info, sizeof(_process_info));
}

//  --------------------------------------------------------------------------
//  CLoaderProcess::~CLoaderProcess
//
//  Arguments:  n/a
//
//  Returns:    <none>
//
//  Purpose:    CLoaderProcess destructor
//
//  History:    2002-03-06   scotthan        created
//  --------------------------------------------------------------------------
CLoaderProcess::~CLoaderProcess()
{
    Clear(NULL, TRUE);
}

//  --------------------------------------------------------------------------
//  CLoaderProcess::IsProcessLoader
//
//  Arguments:  hProcess - Handle of process to test.
//
//  Returns:    BOOL
//
//  Purpose:    Determines whether the process identified by hProcess is
//              matches the process spawned by CLoaderProcess::Create()
//  
//              Note: THIS MUST BE CALLED FROM THE PROCESS OWNER"S SECURITY CONTEXT.
//
//  History:    2002-03-06   scotthan        created
//  --------------------------------------------------------------------------
BOOL CLoaderProcess::IsProcessLoader( IN HANDLE hProcess )
{
    if( _process_info.hProcess && _process_info.dwProcessId )
    {
        PROCESS_BASIC_INFORMATION bi;
        ULONG cbOut;
        if( NT_SUCCESS(NtQueryInformationProcess(hProcess, 
                                                 ProcessBasicInformation,
                                                 &bi, sizeof(bi), &cbOut)) )
        {
            if( bi.UniqueProcessId == _process_info.dwProcessId 
                || bi.InheritedFromUniqueProcessId == _process_info.dwProcessId 
              )
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}

//  --------------------------------------------------------------------------
//  CLoaderProcess::Create
//
//  Arguments:  pvSessionData - Session instance data (CThemeManagerSessionData::GetData()).
//              hTokenClient - token handle of LPC client.  This is needed to
//              ensure the process loader is created on the correct desktop if
//              pszDesktop is NULL.
//              pszDesktop - optional; desktop on which to create the loader.
//                  (Note: the client token handle will establish the correct session.)
//              pszFile - valid msstyles source file spec.
//              pszColor - valid color variant name.
//              pszSize - valid size variant name.
//              phLoader - optional address to receive loader process handle.
//
//  Returns:    STATUS_SUCCESS if it worked, otherwise an NT status error code.
//
//  Purpose:    Spawns a loader process.
//
//  History:    2002-03-06   scotthan        created
//  --------------------------------------------------------------------------
NTSTATUS CLoaderProcess::Create(
    IN PVOID  pvSessionData,
    IN HANDLE hTokenClient, 
    IN OPTIONAL LPWSTR pszDesktop,
    IN LPCWSTR pszFile,
    IN LPCWSTR pszColor,
    IN LPCWSTR pszSize,
    OUT OPTIONAL HANDLE* phLoader )
{
    ASSERTMSG( 0 == _process_info.dwProcessId, "CLoaderProcess::Create - synchronization error: loader process already exists");
    ASSERTMSG( (pszFile && *pszFile), "CLoaderProcess::Create - invalid source file spec.");
    ASSERTMSG( (pszColor && *pszColor), "CLoaderProcess::Create - invalid color variant name.");
    ASSERTMSG( (pszSize && *pszSize),   "CLoaderProcess::Create - invalid size variant name.");

    NTSTATUS       status = STATUS_SUCCESS;
    const LPCWSTR  _pszFmt = L"rundll32.exe uxtheme.dll,#64 %s?%s?%s";
    const LPWSTR   _pszDesktopDefault = L"WinSta0\\Default";
    LPWSTR         pszRunDll = NULL;

    if( phLoader )
    {
        *phLoader = NULL;
    }

    //  clear out existing state
    Clear(pvSessionData, TRUE);

    //  Establish desktop
    //  Note: the client token handle will establish the correct session.
    if( NULL == pszDesktop )
    {
        pszDesktop = _pszDesktopDefault;
    }
    
    //  Allocate strings
    ULONG cchFile   = lstrlen(pszFile);
    ULONG cchColor  = lstrlen(pszColor);
    ULONG cchSize   = lstrlen(pszSize);
    ULONG cchRunDll = lstrlen(_pszFmt) + cchFile + cchColor + cchSize;

    _pszFile  = new WCHAR[cchFile + 1];
    _pszColor = new WCHAR[cchColor + 1];
    _pszSize  = new WCHAR[cchSize + 1];
    pszRunDll = new WCHAR[cchRunDll + 1];

    if( (_pszFile && _pszColor && _pszSize && pszRunDll) )
    {
        STARTUPINFO   si;

        ZeroMemory(&si, sizeof(si));
        si.cb = sizeof(si);
        si.dwFlags      = STARTF_FORCEOFFFEEDBACK;
        si.lpDesktop    = pszDesktop;
   
        StringCchPrintfW( pszRunDll, cchRunDll + 1, _pszFmt, 
                          pszFile, pszColor, pszSize );

        if( CreateProcessAsUser(hTokenClient, 
                                NULL,
                                pszRunDll, 
                                NULL, 
                                NULL,
                                FALSE, 
                                0, 
                                NULL, 
                                NULL, 
                                &si, 
                                &_process_info) )
        {
            //  make copies of the inbound parameters
            StringCchCopyW(_pszFile, cchFile + 1, pszFile);
            StringCchCopyW(_pszColor, cchColor + 1, pszColor);
            StringCchCopyW(_pszSize, cchSize + 1,   pszSize);
            _hr = STATUS_ABANDONED; // initialize the return with something appropriate if the process never comes back

#ifdef DEBUG
            DWORD dwCurrentProcessID = GetCurrentProcessId();
            UNREFERENCED_PARAMETER(dwCurrentProcessID);

            PROCESS_BASIC_INFORMATION bi;
            ULONG cbOut;
            if( NT_SUCCESS(NtQueryInformationProcess(_process_info.hProcess, 
                                                     ProcessBasicInformation,
                                                     &bi, sizeof(bi), &cbOut)) )
            {
            }
#endif DEBUG

            if( phLoader )
            {
                *phLoader = _process_info.hProcess;
            }
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        Clear(pvSessionData, FALSE);
        status = STATUS_NO_MEMORY;
    }

    delete [] pszRunDll;
    _hr = HRESULT_FROM_NT(status);

    return status;                                            
}

//  --------------------------------------------------------------------------
//  CLoaderProcess::ValidateAndCopySection
//
//  Arguments:  pvSessionData  = Session cookie returned from CThemeManagerSessionData->GetData().
//              hProcessClient = Optional, process handle of LPC client, used to validate 
//                               the client is the loader process.  If NULL is supplied, the client
//                               will not be validated.
//              hSectionIn     = Read-write section handle from loader, mapped to local memory space.
//              *phSectionOut  = Read-only section handle, mapped to local memory space.
//
//  Returns:    STATUS_SUCCESS if it worked, otherwise an NT status error code.
//
//  Purpose:    Validates section handle received from loader process, and creates a read-only copy.
//              Note: IsProcessLoader should already have been verified.
//
//  History:    2002-03-06   scotthan        created
//  --------------------------------------------------------------------------
NTSTATUS CLoaderProcess::ValidateAndCopySection( 
    IN PVOID   pvSessionData, 
    IN HANDLE  hSectionIn, 
    OUT HANDLE *phSectionOut )
{
    NTSTATUS status = STATUS_SUCCESS;

    *phSectionOut = NULL;

    ASSERTMSG(_process_info.hProcess != NULL, "CLoaderProcess::ValidateAndCopySection - possible synchronization error; no loader process is active!");
    ASSERTMSG(NULL == _hSection, "CLoaderProcess::ValidateAndCopySection - possible synchronization error; section already assigned!");

    //  The loader process is privileged to load global themes, and we want to
    //  transfer ownership of the stock objects to the output section so that the 
    //  API_THEMES_PROCESSLOADTHEME client does not attempt to free them on failure.
    _hr = LoadTheme(pvSessionData, hSectionIn, &_hSection, _pszFile, _pszColor, _pszSize, 
                    LTF_GLOBALPRIVILEGEDCLIENT | LTF_TRANSFERSTOCKOBJOWNERSHIP);
    status = _hr &= ~FACILITY_NT_BIT;

    if( NT_SUCCESS(status) )
    {
        *phSectionOut = _hSection;
    }

    return status;
}


//  --------------------------------------------------------------------------
//  CLoaderProcess::SetSectionHandle
//
//  Arguments:  hSection - section handle
//
//  Returns:    STATUS_SUCCESS if it worked, otherwise an NT status error code.
//
//  Purpose:    Spawns a loader process.
//
//  History:    2002-03-06   scotthan        created
//  --------------------------------------------------------------------------
NTSTATUS CLoaderProcess::SetSectionHandle( 
    IN HANDLE hSection )
{
    ASSERTMSG(_hSection == NULL, "CLoaderProcess::SetSectionHandle - synchronization error; reassigning section handle");
    _hSection = hSection;
    return STATUS_SUCCESS;
}

//  --------------------------------------------------------------------------
//  CLoaderProcess::GetSectionHandle
//
//  Arguments:  fTakeOwnership - TRUE if caller wishes to manage the section
//              (including closing the handle and/or clearing stock objects).
//
//  Returns:    STATUS_SUCCESS if it worked, otherwise an NT status error code.
//
//  Purpose:    Spawns a loader process.
//
//  History:    2002-03-06   scotthan        created
//  --------------------------------------------------------------------------
HANDLE CLoaderProcess::GetSectionHandle( BOOL fTakeOwnership )
{
    HANDLE hSection = _hSection;
    if( fTakeOwnership )
    {
        _hSection = NULL;
    }
    return hSection;
}

//  --------------------------------------------------------------------------
//  CLoaderProcess::Clear
//
//  Arguments:  fClearHResult - TRUE to clear the HRESULT as well as the
//              other loader process data.
//              
//              pvSessionData - Session instance data (CThemeManagerSessionData::GetData()).
//
//  Returns:    n/a
//
//  Purpose:    Cleans up loader process state info.
//
//  History:    2002-03-06   scotthan        created
//  --------------------------------------------------------------------------
void     CLoaderProcess::Clear(
    IN PVOID OPTIONAL pvSessionData, 
    IN BOOL OPTIONAL fClearHResult)
{
    if( _process_info.hThread != NULL )
    {
        CloseHandle(_process_info.hThread);
    }
    if( _process_info.hProcess != NULL )
    {
        CloseHandle(_process_info.hProcess);
    }
    ZeroMemory(&_process_info, sizeof(_process_info));

    delete [] _pszFile;
    _pszFile = NULL;
    
    delete [] _pszColor;
    _pszColor = NULL;

    delete [] _pszSize;
    _pszSize = NULL;

    if( _hSection )
    {
        ASSERTMSG(pvSessionData != NULL, "CLoaderProcess::Clear - Exiting service without clearing stock objects from loader process block")
        
        if( pvSessionData )
        {
            THR(ServiceClearStockObjects(pvSessionData, _hSection));
        }

        CloseHandle(_hSection);
        _hSection = NULL;
    }

    if( fClearHResult )
    {
        _hr = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\thememanagerservice.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerService.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the theme server service
//  specifics.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ThemeManagerService_
#define     _ThemeManagerService_

#include "Service.h"

//  --------------------------------------------------------------------------
//  CThemeManagerService
//
//  Purpose:    Implements theme manager server specific functionality to the
//              CService class.
//
//  History:    2000-11-29  vtan        created
//              2002-03-11  scotthan    update override of SignalStartStop().
//  --------------------------------------------------------------------------

class   CThemeManagerService : public CService
{
    private:
                                CThemeManagerService (void);
    public:
                                CThemeManagerService (CAPIConnection *pAPIConnection, CServerAPI *pServerAPI);
        virtual                 ~CThemeManagerService (void);
    protected:
        virtual NTSTATUS        SignalStartStop (BOOL fStart);
    public:
        static  const TCHAR*    GetName (void);
        static  HANDLE          OpenStartEvent (DWORD dwSessionID, DWORD dwDesiredAccess);
        static  DWORD   WINAPI  SignalSessionEvents (void *pParameter);
    private:
        static  const TCHAR     s_szName[];
};

#endif  /*  _ThemeManagerService_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\thememanagerservice.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerService.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the theme server service
//  specifics.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#define STRSAFE_LIB
#include <strsafe.h>

#include "ThemeManagerService.h"

#include <lpcthemes.h>
#include <winsta.h>

#include "Access.h"
#include "StatusCode.h"

const TCHAR     CThemeManagerService::s_szName[]    =   TEXT("Themes");

//  --------------------------------------------------------------------------
//  CThemeManagerService::CThemeManagerService
//
//  Arguments:  pAPIConnection  =   CAPIConnection passed to base class.
//              pServerAPI      =   CServerAPI passed to base class.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CThemeManagerService.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerService::CThemeManagerService (CAPIConnection *pAPIConnection, CServerAPI *pServerAPI) :
    CService(pAPIConnection, pServerAPI, GetName())

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerService::~CThemeManagerService
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CThemeManagerService.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerService::~CThemeManagerService (void)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerService::SignalStartStop
//
//  Arguments:  BOOL fStart
//
//  Returns:    NTSTATUS
//
//  Purpose:    Used to signal that the service is starting or stopping.

//              In the case of serivce start, Winlogon (via
//              msgina) is listening for this event in its own session. This
//              function queues a request to execute the real work done on a
//              worker thread to prevent blocking the main service thread. If
//              this is not possible then execute the signal inline.
//
//  History:    2000-11-29  vtan        created
//              2002-03-11  scotthan    renamed to 'SignalStartStop' from 'Signal', 
//                                      added boolean arg, add call to base class
//                                      implementation.
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerService::SignalStartStop (BOOL fStart)

{
    if( fStart )
    {
        if (QueueUserWorkItem(SignalSessionEvents, NULL, WT_EXECUTEDEFAULT) == FALSE)
        {
            (DWORD)SignalSessionEvents(NULL);
        }
    }
    return CService::SignalStartStop(fStart);
}

//  --------------------------------------------------------------------------
//  CThemeManagerService::GetName
//
//  Arguments:  <none>
//
//  Returns:    const TCHAR*
//
//  Purpose:    Returns the name of the service (ThemeService).
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

const TCHAR*    CThemeManagerService::GetName (void)

{
    return(s_szName);
}

//  --------------------------------------------------------------------------
//  CThemeManagerService::OpenStartEvent
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Opens or creates the theme service recovery event. This allows
//              a process that has registered for the event to be signaled
//              when the theme server is demand started. Currently only
//              winlogon listens for this event and is required so that it can
//              reestablish a server connection and re-create the session data
//              which holds the hooks for theming.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CThemeManagerService::OpenStartEvent (DWORD dwSessionID, DWORD dwDesiredAccess)

{
    HANDLE              hEvent;
    NTSTATUS            status;
    UNICODE_STRING      eventName;
    OBJECT_ATTRIBUTES   objectAttributes;
    WCHAR               szEventName[64];

    if (dwSessionID == 0)
    {
        StringCchPrintfW(szEventName, ARRAYSIZE(szEventName), L"\\BaseNamedObjects\\%s", THEMES_START_EVENT_NAME);
    }
    else
    {
        StringCchPrintfW(szEventName, ARRAYSIZE(szEventName), L"\\Sessions\\%d\\BaseNamedObjects\\%s", dwSessionID, THEMES_START_EVENT_NAME);
    }
    RtlInitUnicodeString(&eventName, szEventName);
    InitializeObjectAttributes(&objectAttributes,
                               &eventName,
                               0,
                               NULL,
                               NULL);
    status = NtOpenEvent(&hEvent, dwDesiredAccess, &objectAttributes);
    if (!NT_SUCCESS(status))
    {

        //  Build a security descriptor for the event that allows:
        //      S-1-5-18            NT AUTHORITY\SYSTEM     EVENT_ALL_ACCESS
        //      S-1-5-32-544        <local administrators>  SYNCHRONIZE | READ_CONTROL
        //      S-1-1-0             <everyone>              SYNCHRONIZE

        static  SID_IDENTIFIER_AUTHORITY    s_SecurityNTAuthority       =   SECURITY_NT_AUTHORITY;
        static  SID_IDENTIFIER_AUTHORITY    s_SecurityWorldAuthority    =   SECURITY_WORLD_SID_AUTHORITY;

        static  const CSecurityDescriptor::ACCESS_CONTROL   s_AccessControl[]   =
        {
            {
                &s_SecurityNTAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0, 0, 0, 0, 0, 0, 0,
                EVENT_ALL_ACCESS
            },
            {
                &s_SecurityNTAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                SYNCHRONIZE | READ_CONTROL
            },
            {
                // Review: Is synchronize for Everyone really necessary?
                &s_SecurityWorldAuthority,
                1,
                SECURITY_WORLD_RID,
                0, 0, 0, 0, 0, 0, 0,
                SYNCHRONIZE
            },
        };

        PSECURITY_DESCRIPTOR    pSecurityDescriptor;

        //  Build a security descriptor that allows the described access above.

        pSecurityDescriptor = CSecurityDescriptor::Create(ARRAYSIZE(s_AccessControl), s_AccessControl);

        InitializeObjectAttributes(&objectAttributes,
                                   &eventName,
                                   0,
                                   NULL,
                                   pSecurityDescriptor);
        status = NtCreateEvent(&hEvent,
                               EVENT_ALL_ACCESS,
                               &objectAttributes,
                               NotificationEvent,
                               FALSE);
        ReleaseMemory(pSecurityDescriptor);
        if (!NT_SUCCESS(status))
        {
            hEvent = NULL;
            SetLastError(CStatusCode::ErrorCodeOfStatusCode(status));
        }
    }
    return(hEvent);
}

//  --------------------------------------------------------------------------
//  CThemeManagerService::SignalSessionEvents
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Opens or creates the theme service recovery event. This allows
//              a process that has registered for the event to be signaled
//              when the theme server is demand started.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  CThemeManagerService::SignalSessionEvents (void *pParameter)

{
    UNREFERENCED_PARAMETER(pParameter);

    HANDLE      hEvent;
    HANDLE      hServer;

    //  First try and use terminal server to enumerate the sessions available.

    hServer = WinStationOpenServerW(reinterpret_cast<WCHAR*>(SERVERNAME_CURRENT));
    if (hServer != NULL)
    {
        ULONG       ulEntries;
        PLOGONID    pLogonIDs;

        if (WinStationEnumerate(hServer, &pLogonIDs, &ulEntries))
        {
            ULONG       ul;
            PLOGONID    pLogonID;

            for (ul = 0, pLogonID = pLogonIDs; ul < ulEntries; ++ul, ++pLogonID)
            {
                if ((pLogonID->State == State_Active) || (pLogonID->State == State_Connected) || (pLogonID->State == State_Disconnected))
                {
                    hEvent = OpenStartEvent(pLogonID->SessionId, EVENT_MODIFY_STATE);
                    if (hEvent != NULL)
                    {
                        TBOOL(SetEvent(hEvent));
                        TBOOL(CloseHandle(hEvent));
                    }
                }
            }
            (BOOLEAN)WinStationFreeMemory(pLogonIDs);
        }
        (BOOLEAN)WinStationCloseServer(hServer);
    }
    else
    {

        //  If terminal services is not available then assume session 0 only.

        hEvent = OpenStartEvent(0, EVENT_MODIFY_STATE);
        if (hEvent != NULL)
        {
            TBOOL(SetEvent(hEvent));
            TBOOL(CloseHandle(hEvent));
        }
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\thememanagersessiondata.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerSessionData.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements information the encapsulates a
//  client TS session for the theme server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifndef     _ThemeManagerSessionData_
#define     _ThemeManagerSessionData_

#include "APIConnection.h"

//  --------------------------------------------------------------------------
//  CLoaderProcess
//
//  Purpose:    Manages per-session process loader data.
//  
//  Note:       all loader methods should be invoked only under session-wide lock.
//
//  History:    2002-03-06  scotthan        created
//  --------------------------------------------------------------------------
class CLoaderProcess
{
public:
    CLoaderProcess();
    ~CLoaderProcess();

    //  create, destroy.
    NTSTATUS            Create(IN PVOID pvSessionData, 
                               IN HANDLE hTokenClient, 
                               IN OPTIONAL LPWSTR pszDesktop, 
                               IN LPCWSTR pszFile, 
                               IN LPCWSTR pszColor, 
                               IN LPCWSTR pszSize,
                               OUT HANDLE* phLoader);

    //  section validation, ownership
    NTSTATUS            ValidateAndCopySection( PVOID pvSessionData, IN HANDLE hSectionIn, OUT HANDLE *phSectionOut );

    //  section cleanup
    void                Clear(PVOID pvContext, BOOL fClearHResult);

    //  query methods
    BOOL                IsProcessLoader( IN HANDLE hProcess );
    BOOL                IsAlive() const  {return _process_info.hProcess != NULL;}

    //  access functions
    NTSTATUS            SetHResult( IN HRESULT hr )  {_hr = hr; return STATUS_SUCCESS;}
    HANDLE              GetSectionHandle( BOOL fTakeOwnership );
    HRESULT             GetHResult() const        { return _hr; }

private:
    //  access functions
    
    NTSTATUS            SetSectionHandle( IN HANDLE hSection );

    //  data
    PROCESS_INFORMATION _process_info;   // secure loader process information.
    LPWSTR              _pszFile;
    LPWSTR              _pszColor;
    LPWSTR              _pszSize;
    HANDLE              _hSection;  // secure theme section handle, valid in service's address space.  
                                    // This member is assigned by API_THEMES_SECUREAPPLYTHEME, and propagated
                                    // to caller of API_THEMES_SECURELOADTHEME.
                                    // The lifetime of this value should not exceed that of the 
                                    // API_THEMES_SECURELOADTHEME's handler (i.e, uninitialized on handler's entry, 
                                    // uninitialized on handler's exit)
    HRESULT             _hr ;       // HRESULT associated with _hSection.  Assigned in API_THEMES_SECUREAPPLYTHEME, 
                                    //     propagated to caller of API_THEMES_SECURELOADTHEME.
};


//  --------------------------------------------------------------------------
//  CThemeManagerSessionData
//
//  Purpose:    This class encapsulates all the information that the theme
//              manager needs to maintain a client session.
//
//  History:    2000-11-17  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

class   CThemeManagerSessionData : public CCountedObject
{
    private:
                                    CThemeManagerSessionData (void);
    public:
                                    CThemeManagerSessionData (DWORD dwSessionID);
                                    ~CThemeManagerSessionData (void);

                void*               GetData (void)  const;
                bool                EqualSessionID (DWORD dwSessionID)  const;

                NTSTATUS            Allocate (HANDLE hProcessClient, DWORD dwServerChangeNumber, void *pfnRegister, void *pfnUnregister, void *pfnClearStockObjects, DWORD dwStackSizeReserve, DWORD dwStackSizeCommit);
                NTSTATUS            Cleanup (void);
                NTSTATUS            UserLogon (HANDLE hToken);
                NTSTATUS            UserLogoff (void);

                //  secure loader process access methods.
                //  note: all loader methods should be invoked only under session-wide lock.
                NTSTATUS            GetLoaderProcess( OUT CLoaderProcess** ppLoader );

        static  void                SetAPIConnection (CAPIConnection *pAPIConnection);
        static  void                ReleaseAPIConnection (void);
    private:
                void                SessionTermination (void);
        static  void    CALLBACK    CB_SessionTermination (void *pParameter, BOOLEAN TimerOrWaitFired);
        static  DWORD   WINAPI      CB_UnregisterWait (void *pParameter);
    private:
                DWORD               _dwSessionID;
                void*               _pvThemeLoaderData;
                HANDLE              _hToken;
                HANDLE              _hProcessClient;
                HANDLE              _hWait;

                CLoaderProcess*     _pLoader;

        static  CAPIConnection*     s_pAPIConnection;
};

#endif  /*  _ThemeManagerSessionData_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\themeserverclient.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeServerClient.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the theme server functions that
//  are executed in a client context (winlogon context).
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#define STRSAFE_LIB
#include <strsafe.h>

#include "ThemeServerClient.h"

#include <lpcthemes.h>
#include <uxthemep.h>
#include <UxThemeServer.h>

#include "SingleThreadedExecution.h"
#include "StatusCode.h"
#include "ThemeManagerService.h"
#include <Impersonation.h>

//  --------------------------------------------------------------------------
//  CThemeManagerAPI::s_pThemeManagerAPIServer
//  CThemeManagerAPI::s_hPort
//  CThemeManagerAPI::s_hToken
//  CThemeManagerAPI::s_hEvent
//  CThemeManagerAPI::s_hWaitObject
//  CThemeManagerAPI::s_pLock
//
//  Purpose:    Static member variables.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerAPIServer*     CThemeServerClient::s_pThemeManagerAPIServer    =   NULL;
HANDLE                      CThemeServerClient::s_hPort                     =   NULL;
HANDLE                      CThemeServerClient::s_hToken                    =   NULL;
HANDLE                      CThemeServerClient::s_hEvent                    =   NULL;
HANDLE                      CThemeServerClient::s_hWaitObject               =   NULL;
HMODULE                     CThemeServerClient::s_hModuleUxTheme            =   NULL;
CCriticalSection*           CThemeServerClient::s_pLock                     =   NULL;

//  --------------------------------------------------------------------------
//  CThemeServerClient::WaitForServiceReady
//
//  Arguments:  dwTimeout   =   Number of ticks to wait.
//
//  Returns:    DWORD
//
//  Purpose:    Check if the service is autostart. If so then wait the
//              designated amount of time for the service. If the service
//              is then running or was running but isn't autostart then
//              re-establish the connection to the server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        converted to a Win32 service
//  --------------------------------------------------------------------------

DWORD   CThemeServerClient::WaitForServiceReady (DWORD dwTimeout)

{
    DWORD       dwWaitResult;
    NTSTATUS    status;

    dwWaitResult = WAIT_TIMEOUT;
    if (s_pThemeManagerAPIServer->IsAutoStart())
    {
        status = s_pThemeManagerAPIServer->Wait(dwTimeout);
#ifdef      DBG
        if (STATUS_TIMEOUT == status)
        {
            INFORMATIONMSG("Wait on auto start theme service timed out.");
        }
#endif  /*  DBG     */
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    if (NT_SUCCESS(status) && s_pThemeManagerAPIServer->IsRunning())
    {
        status = ReestablishConnection();
        if (NT_SUCCESS(status))
        {
            THR(InitUserRegistry());
            THR(InitUserTheme(FALSE));
            dwWaitResult = WAIT_OBJECT_0;
        }
    }
    return(dwWaitResult);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::WatchForStart
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Opens or creates the theme server announce event. This is a
//              manual reset event which the theme server pulses when it
//              starts up. This allows winlogon to initiate new connections
//              to the theme server without having to wait for logon or
//              logoff events to happen.
//
//              This event is intentionally leaked and cleaned up when the
//              winlogon process for the session goes away.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::WatchForStart (void)

{
    NTSTATUS    status;

    s_hEvent = CThemeManagerService::OpenStartEvent(NtCurrentPeb()->SessionId, SYNCHRONIZE);
    if (s_hEvent != NULL)
    {
        if (RegisterWaitForSingleObject(&s_hWaitObject,
                                        s_hEvent,
                                        CB_ServiceStart,
                                        NULL,
                                        INFINITE,
                                        WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::UserLogon
//
//  Arguments:  hToken  =   Token of user logging on.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Signals the server that a user is logging on and gives the
//              server the handle to the token. The server will grant access
//              to the port based on the user's logon SID. Then perform work
//              to initialize the environment for the user logging on.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        converted to a Win32 service
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::UserLogon (HANDLE hToken)

{
    NTSTATUS    status;

    status = NotifyUserLogon(hToken);
    if (STATUS_PORT_DISCONNECTED == status)
    {
        status = ReestablishConnection();
        if (NT_SUCCESS(status))
        {
            status = NotifyUserLogon(hToken);
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::UserLogoff
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Signals the server that the current user for this session is
//              logging off. The server will remove the access that was
//              granted at logon and reinitialize the theme settings to the
//              ".Default" settings.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        converted to a Win32 service
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::UserLogoff (void)

{
    NTSTATUS    status;

    status = NotifyUserLogoff();
    if (STATUS_PORT_DISCONNECTED == status)
    {
        status = ReestablishConnection();
        if (NT_SUCCESS(status))
        {
            status = NotifyUserLogoff();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::UserInitTheme
//
//  Arguments:  BOOL
//
//  Returns:    NTSTATUS
//
//  Purpose:    Called at logon, or when Terminal Server connects a user to a 
//              remote session or reconnects to a local session.  Needs to 
//              evaluate the environment and decide if themes need to be loaded
//              or unloaded.
//
//  History:    2000-01-18  rfernand        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::UserInitTheme (BOOL fPolicyCheckOnly)

{
    bool    fSuccessfulImpersonation;

    //  If there's a token impersonate the user. Otherwise use the system context.

    if (s_hToken != NULL)
    {
        fSuccessfulImpersonation = NT_SUCCESS(CImpersonation::ImpersonateUser(GetCurrentThread(), s_hToken));
    }
    else
    {
        fSuccessfulImpersonation = true;
    }
    if (fSuccessfulImpersonation)
    {
        (HRESULT)InitUserTheme(fPolicyCheckOnly);
    }
    if (fSuccessfulImpersonation && (s_hToken != NULL))
    {
        if (RevertToSelf() == FALSE)
        {
            return CStatusCode::StatusCodeOfLastError();
        }
    } 
    return STATUS_SUCCESS;
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initializes static member variables. Allocate a
//              CThemeManagerAPIServer and a lock for this object.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::StaticInitialize (void)

{
    NTSTATUS    status;

    if (s_pThemeManagerAPIServer == NULL)
    {
        status = STATUS_NO_MEMORY;
        s_pThemeManagerAPIServer = new CThemeManagerAPIServer;
        if (s_pThemeManagerAPIServer != NULL)
        {
            s_pLock = new CCriticalSection;
            if (s_pLock != NULL)
            {
                status = STATUS_SUCCESS;
            }
        }
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Release static member variables initialized.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::StaticTerminate (void)

{
    if (s_pLock != NULL)
    {
        delete s_pLock;
        s_pLock = NULL;
    }
    if (s_pThemeManagerAPIServer != NULL)
    {
        s_pThemeManagerAPIServer->Release();
        s_pThemeManagerAPIServer = NULL;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::NotifyUserLogon
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Execute the send message to the server and tell it that the
//              given user is now logged on. This will instruct the server
//              to grant access to the ThemeApiPort.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::NotifyUserLogon (HANDLE hToken)

{
    NTSTATUS status = STATUS_NO_MEMORY;

    if (s_pLock != NULL)
    {
        CSingleThreadedExecution    lock(*s_pLock);

        if (s_hPort != NULL)
        {
            status = InformServerUserLogon(hToken);
        }
        else
        {
            status = STATUS_PORT_DISCONNECTED;
        }

        //  Keep a copy of the token as well in case of demand start of
        //  the theme server so we can impersonate the user when we load
        //  their theme using InitUserTheme. Don't copy it if it already
        //  exists.

        if (s_hToken == NULL)
        {
            TBOOL(DuplicateHandle(GetCurrentProcess(),
                                hToken,
                                GetCurrentProcess(),
                                &s_hToken,
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS));
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::NotifyUserLogoff
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Tell the server that the logged on user is logged off. This
//              will remove access to ThemeApiPort.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::NotifyUserLogoff (void)

{
    NTSTATUS status = STATUS_NO_MEMORY;

    if (s_pLock != NULL)
    {
        CSingleThreadedExecution    lock(*s_pLock);

        if (s_hToken != NULL)
        {
            ReleaseHandle(s_hToken);
            if (s_hPort != NULL)
            {
                status = InformServerUserLogoff();
            }
            else
            {
                status = STATUS_PORT_DISCONNECTED;
            }
        }
        else
        {
            status = STATUS_SUCCESS;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::InformServerUserLogon
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Tell the server that the logged on user is logged off. This
//              will remove access to ThemeApiPort.
//
//  History:    2000-12-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::InformServerUserLogon (HANDLE hToken)

{
    NTSTATUS                status;
    THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

    ZeroMemory(&portMessageIn, sizeof(portMessageIn));
    ZeroMemory(&portMessageOut, sizeof(portMessageOut));
    portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_USERLOGON;
    portMessageIn.apiThemes.apiSpecific.apiUserLogon.in.hToken = hToken;
    portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
    portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
    status = NtRequestWaitReplyPort(s_hPort,
                                    &portMessageIn.portMessage,
                                    &portMessageOut.portMessage);
    if (NT_SUCCESS(status))
    {
        status = portMessageOut.apiThemes.apiGeneric.status;
        if (NT_SUCCESS(status))
        {
            THR(InitUserTheme(FALSE));
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::InformServerUserLogoff
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Tell the server that the logged on user is logged off. This
//              will remove access to ThemeApiPort.
//
//  History:    2000-12-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::InformServerUserLogoff (void)

{
    NTSTATUS                status;
    THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

    ZeroMemory(&portMessageIn, sizeof(portMessageIn));
    ZeroMemory(&portMessageOut, sizeof(portMessageOut));
    portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_USERLOGOFF;
    portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
    portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
    status = NtRequestWaitReplyPort(s_hPort,
                                    &portMessageIn.portMessage,
                                    &portMessageOut.portMessage);
    if (NT_SUCCESS(status))
    {
        status = portMessageOut.apiThemes.apiGeneric.status;
        if (NT_SUCCESS(status))
        {
            THR(InitUserRegistry());
            THR(InitUserTheme(FALSE));
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::SessionCreate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Signal the server that a new session is being created. This
//              allows the server to allocate a data blob for this session.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::SessionCreate (void)

{
    NTSTATUS status = STATUS_NO_MEMORY;

    if (s_pLock != NULL)
    {
        CSingleThreadedExecution    lock(*s_pLock);

        if (s_hModuleUxTheme == NULL)
        {
            s_hModuleUxTheme = LoadLibrary(TEXT("uxtheme.dll"));
        }
        if (s_hModuleUxTheme != NULL)
        {
            void    *pfnRegister, *pfnUnregister, *pfnClearStockObjects;

            //  Get the uxtheme function addresses in this process address space.
            //      34  =   ThemeHooksInstall
            //      35  =   ThemeHooksRemove
            //      62  =   ServerClearStockObjects

            pfnRegister = GetProcAddress(s_hModuleUxTheme, MAKEINTRESOURCEA(34));
            pfnUnregister = GetProcAddress(s_hModuleUxTheme, MAKEINTRESOURCEA(35));
            pfnClearStockObjects = GetProcAddress(s_hModuleUxTheme, MAKEINTRESOURCEA(62));

            if ((pfnRegister != NULL) && (pfnUnregister != NULL) && (pfnClearStockObjects != NULL))
            {
                DWORD                       dwStackSizeReserve, dwStackSizeCommit;
                ULONG                       ulReturnLength;
                IMAGE_NT_HEADERS            *pNTHeaders;
                SYSTEM_BASIC_INFORMATION    systemBasicInformation;
                THEMESAPI_PORT_MESSAGE      portMessageIn, portMessageOut;

                //  Get system basic information for stack size defaults.

                status = NtQuerySystemInformation(SystemBasicInformation,
                                                &systemBasicInformation,
                                                sizeof(systemBasicInformation),
                                                &ulReturnLength);
                if (NT_SUCCESS(status))
                {
                    dwStackSizeReserve = systemBasicInformation.AllocationGranularity;
                    dwStackSizeCommit = systemBasicInformation.PageSize;
                }
                else
                {
                    dwStackSizeReserve = dwStackSizeCommit = 0;
                }

                //  Go to the image header for this process and get the stack size
                //  defaults if they are specified. Otherwise use system defaults (above).

                pNTHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);
                if (pNTHeaders != NULL)
                {
                    dwStackSizeReserve = static_cast<DWORD>(pNTHeaders->OptionalHeader.SizeOfStackReserve);
                    dwStackSizeCommit = static_cast<DWORD>(pNTHeaders->OptionalHeader.SizeOfStackCommit);
                }

                //  Make the call.

                ZeroMemory(&portMessageIn, sizeof(portMessageIn));
                ZeroMemory(&portMessageOut, sizeof(portMessageOut));
                portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_SESSIONCREATE;
                portMessageIn.apiThemes.apiSpecific.apiSessionCreate.in.pfnRegister = pfnRegister;
                portMessageIn.apiThemes.apiSpecific.apiSessionCreate.in.pfnUnregister = pfnUnregister;
                portMessageIn.apiThemes.apiSpecific.apiSessionCreate.in.pfnClearStockObjects = pfnClearStockObjects;
                portMessageIn.apiThemes.apiSpecific.apiSessionCreate.in.dwStackSizeReserve = dwStackSizeReserve;
                portMessageIn.apiThemes.apiSpecific.apiSessionCreate.in.dwStackSizeCommit = dwStackSizeCommit;
                portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
                portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
                status = NtRequestWaitReplyPort(s_hPort,
                                                &portMessageIn.portMessage,
                                                &portMessageOut.portMessage);
                if (NT_SUCCESS(status))
                {
                    status = portMessageOut.apiThemes.apiGeneric.status;
                }
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::SessionDestroy
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Signal the server that the current session is about to be
//              destroyed. This allows the server to release the data blob
//              allocated.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::SessionDestroy (void)

{
    NTSTATUS status = STATUS_NO_MEMORY;

    if (s_pLock != NULL)
    {
        THEMESAPI_PORT_MESSAGE      portMessageIn, portMessageOut;
        CSingleThreadedExecution    lock(*s_pLock);

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_SESSIONDESTROY;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
        }
        if (s_hModuleUxTheme != NULL)
        {
            TBOOL(FreeLibrary(s_hModuleUxTheme));
            s_hModuleUxTheme = NULL;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::ReestablishConnection
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Reconnects to theme server. If the reconnection is established
//              the re-create the session data. This will not correct any
//              disconnected ports that some clients may have but because this
//              is called in winlogon it re-establish this correctly for
//              session 0 in all cases.
//
//              UnregisterUserApiHook must be called to clear any left over
//              registrations from a server that died. Then go ahead and
//              re-initialize the environment anyway.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::ReestablishConnection (void)

{
    NTSTATUS    status;

    ReleaseHandle(s_hPort);
    status = s_pThemeManagerAPIServer->ConnectToServer(&s_hPort);
    if (NT_SUCCESS(status))
    {
        status = SessionCreate();
        if (NT_SUCCESS(status))
        {
            (BOOL)UnregisterUserApiHook();
            THR(ReestablishServerConnection());
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::CB_ServiceStart
//
//  Arguments:  pParameter          =   User parameter.
//              TimerOrWaitFired    =   Timer or wait fired.
//
//  Returns:    <none>
//
//  Purpose:    Callback called when the theme server ready event is signaled.
//              This indicates that the service was demand started or
//              restarted in the event of failure.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CThemeServerClient::CB_ServiceStart (void *pParameter, BOOLEAN TimerOrWaitFired)

{
    UNREFERENCED_PARAMETER(pParameter);
    UNREFERENCED_PARAMETER(TimerOrWaitFired);

    NTSTATUS status = STATUS_NO_MEMORY;

    if (s_pLock != NULL)
    {
        CSingleThreadedExecution    lock(*s_pLock);

        //  If there is a connection ping it.

        if (s_hPort != NULL)
        {
            THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

            ZeroMemory(&portMessageIn, sizeof(portMessageIn));
            ZeroMemory(&portMessageOut, sizeof(portMessageOut));
            portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_PING;
            portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
            portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
            status = NtRequestWaitReplyPort(s_hPort,
                                            &portMessageIn.portMessage,
                                            &portMessageOut.portMessage);
            if (NT_SUCCESS(status))
            {
                status = portMessageOut.apiThemes.apiGeneric.status;
            }
        }
        else
        {
            status = STATUS_PORT_DISCONNECTED;
        }
        if (STATUS_PORT_DISCONNECTED == status)
        {
            HDESK   hDeskCurrent, hDeskInput;

            //  Set this thread's desktop to the input desktop so
            //  that the theme change can be broadcast to the input
            //  desktop. This is Default in most cases where a logged
            //  on user is active but in the non-logged on user case
            //  this will be Winlogon. Restore the thread's desktop
            //  when done.

            TSTATUS(ReestablishConnection());
            hDeskCurrent = hDeskInput = NULL;
            if (s_hToken != NULL)
            {
                hDeskCurrent = GetThreadDesktop(GetCurrentThreadId());
                hDeskInput = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
                if ((hDeskCurrent != NULL) && (hDeskInput != NULL))
                {
                    TBOOL(SetThreadDesktop(hDeskInput));
                }
                if (NT_SUCCESS(CImpersonation::ImpersonateUser(GetCurrentThread(), s_hToken)))
                {
                    TSTATUS(InformServerUserLogon(s_hToken));
                }
                if ((hDeskCurrent != NULL) && (hDeskInput != NULL))
                {
                    SetThreadDesktop(hDeskCurrent);
                    (BOOL)CloseDesktop(hDeskInput);
                }
                TBOOL(RevertToSelf()); 
                // Not much we can do if RevertToSelf() fails. We probably failed the ImpersonateUser() call above, 
                // meaning we didn't do actual work.
            }
            else
            {
                THR(InitUserRegistry());
                THR(InitUserTheme(FALSE));
            }
        }

        //  Reset the event here and now.

        TBOOL(ResetEvent(s_hEvent));

        //  Unregister the original wait (it only executes once anyway). This
        //  call will return a failure code with the callback in progress.
        //  Ignore this error. The thread pool will clean up the wait.

        (BOOL)UnregisterWait(s_hWaitObject);

        //  Reregister the wait as execute once only again waiting for
        //  the next time the event is signaled.

        TBOOL(RegisterWaitForSingleObject(&s_hWaitObject,
                                        s_hEvent,
                                        CB_ServiceStart,
                                        NULL,
                                        INFINITE,
                                        WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\themeserverclient.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeServerClient.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the theme server functions that
//  are executed in a client context (winlogon context).
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ThemeServerClient_
#define     _ThemeServerClient_

#include "KernelResources.h"
#include "ThemeManagerAPIServer.h"

//  --------------------------------------------------------------------------
//  CThemeServerClient
//
//  Purpose:    This class implements external entry points for the theme
//              server (typically used by winlogon).
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

class   CThemeServerClient
{
    private:
                                            CThemeServerClient (void);
                                            ~CThemeServerClient (void);
    public:
        static  DWORD                       WaitForServiceReady (DWORD dwTimeout);
        static  NTSTATUS                    WatchForStart (void);
        static  NTSTATUS                    UserLogon (HANDLE hToken);
        static  NTSTATUS                    UserLogoff (void);
        static  NTSTATUS                    UserInitTheme (BOOL fPolicyCheckOnly);

        static  NTSTATUS                    StaticInitialize (void);
        static  NTSTATUS                    StaticTerminate (void);
    private:
        static  NTSTATUS                    NotifyUserLogon (HANDLE hToken);
        static  NTSTATUS                    NotifyUserLogoff (void);
        static  NTSTATUS                    InformServerUserLogon (HANDLE hToken);
        static  NTSTATUS                    InformServerUserLogoff (void);
        static  NTSTATUS                    SessionCreate (void);
        static  NTSTATUS                    SessionDestroy (void);
        static  NTSTATUS                    ReestablishConnection (void);

        static  void    CALLBACK            CB_ServiceStart (void *pParameter, BOOLEAN TimerOrWaitFired);
    private:
        static  CThemeManagerAPIServer*     s_pThemeManagerAPIServer;
        static  HANDLE                      s_hPort;
        static  HANDLE                      s_hToken;
        static  HANDLE                      s_hEvent;
        static  HANDLE                      s_hWaitObject;
        static  HMODULE                     s_hModuleUxTheme;
        static  CCriticalSection*           s_pLock;
};

#endif  /*  _ThemeServerClient_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\themeserverexports.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeServerExports.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains functions that exported from the theme services module.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#include "StatusCode.h"
#include "ThemeServerClient.h"
#include <uxthemep.h>

//  --------------------------------------------------------------------------
//  ::ThemeWaitForServiceReady
//
//  Arguments:  dwTimeout   =   Number of ticks to wait.
//
//  Returns:    DWORD
//
//  Purpose:    External C entry point to DLL to wait for the service to
//              enter the running state.
//
//  History:    2000-10-13  vtan        created
//              2000-11-29  vtan        converted to a Win32 service
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI      ThemeWaitForServiceReady (DWORD dwTimeout)

{
    return(CThemeServerClient::WaitForServiceReady(dwTimeout));
}

//  --------------------------------------------------------------------------
//  ::ThemeWatchForStart
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    External C entry point to DLL to watch for the service
//              recovering or demand starting.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI      ThemeWatchForStart (void)

{
    bool        fResult;
    NTSTATUS    status;

    status = CThemeServerClient::WatchForStart();
    fResult = NT_SUCCESS(status);
    if (!fResult)
    {
        SetLastError(CStatusCode::ErrorCodeOfStatusCode(status));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  ::ThemeUserLogon
//
//  Arguments:  hToken  =   Token of user that logged on.
//
//  Returns:    BOOL
//
//  Purpose:    External C entry point to DLL to signal a user logon.
//
//  History:    2000-10-12  vtan        created
//              2000-11-29  vtan        converted to a Win32 service
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ThemeUserLogon (HANDLE hToken)

{
    bool        fResult;
    NTSTATUS    status;

    status = CThemeServerClient::UserLogon(hToken);
    fResult = NT_SUCCESS(status);
    if (!fResult)
    {
        SetLastError(CStatusCode::ErrorCodeOfStatusCode(status));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  ::ThemeUserLogoff
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    External C entry point to DLL to signal a user logoff.
//
//  History:    2000-10-12  vtan        created
//              2000-11-29  vtan        converted to a Win32 service
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ThemeUserLogoff (void)

{
    bool        fResult;
    NTSTATUS    status;

    status = CThemeServerClient::UserLogoff();
    fResult = NT_SUCCESS(status);
    if (!fResult)
    {
        SetLastError(CStatusCode::ErrorCodeOfStatusCode(status));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  ::ThemeUserTSReconnect
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    External C entry point to DLL to signal terminal server
//              "reconnect" (remote connect to a session or reestablish
//              local connect to a session).
//
//  History:    2001-01-18  rfernand    created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ThemeUserTSReconnect (void)

{
    //---- this may turn theme on/off based on local/remote conditions ----
    CThemeServerClient::UserInitTheme(FALSE);

    return(true);       // always succeeds
}

//  --------------------------------------------------------------------------
//  ::ThemeUserStartShell
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Load the theme for this user
//
//  History:    2001-03-29  lmouton     created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ThemeUserStartShell (void)

{
    //---- this may turn theme on/off based on local/remote conditions ----
    CThemeServerClient::UserInitTheme(TRUE);

    return(true);       // always succeeds
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\airesize.cpp ===
#include "priv.h"
#include <iehelpid.h>
#include <pstore.h>
#include "hlframe.h"
#include "shldisp.h"
#include "opsprof.h"
#include "resource.h"
#include <mluisupp.h>
#include "htmlstr.h"
#include "airesize.h"
#include "mshtmcid.h"
#include "util.h"
#include "winuser.h"

//////////////////////////////////////////////////////////////////////////////////
//
// filename:    airesize.cpp
//
// description: implements the autoimageresize feature
//
// notes:       
//
// history:     03.07.2001 by jeffdav
//
//////////////////////////////////////////////////////////////////////////////////

extern HINSTANCE g_hinst;

#define TF_AIRESIZE TF_CUSTOM2

CAutoImageResizeEventSinkCallback::EventSinkEntry CAutoImageResizeEventSinkCallback::EventsToSink[] =
{
    { EVENT_MOUSEOVER,   L"onmouseover",   L"mouseover"  }, 
    { EVENT_MOUSEOUT,    L"onmouseout",    L"mouseout"   }, 
    { EVENT_SCROLL,      L"onscroll",      L"scroll"     }, 
    { EVENT_RESIZE,      L"onresize",      L"resize"     },
    { EVENT_BEFOREPRINT, L"onbeforeprint", L"beforeprint"},
    { EVENT_AFTERPRINT,  L"onafterprint",  L"afterprint" }
};

// autoimage resize states
enum
{
    AIRSTATE_BOGUS = 0,
    AIRSTATE_INIT,
    AIRSTATE_NORMAL,
    AIRSTATE_RESIZED,
    AIRSTATE_WAITINGTORESIZE
};

// button states
enum
{
    AIRBUTTONSTATE_BOGUS = 0,
    AIRBUTTONSTATE_HIDDEN,
    AIRBUTTONSTATE_VISIBLE,
    AIRBUTTONSTATE_WAITINGTOSHOW,
    AIRBUTTONSTATE_NOBUTTON
};

////////////////////////////////////////////////////////////////////////////
// QI, AddRef, Release:

STDMETHODIMP CAutoImageResize::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if ((IID_IPropertyNotifySink == riid) || (IID_IUnknown == riid)) 
    {
        *ppv = (IPropertyNotifySink *)this;
    }

    if (*ppv) 
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CAutoImageResize::AddRef(void) 
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CAutoImageResize::Release(void) 
{
    if (--m_cRef == 0) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////////////
// Constructor, Destructor, Init, UnInit:

// constructor
CAutoImageResize::CAutoImageResize()
{
    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::CAutoImageResize");

    m_airState          = AIRSTATE_INIT;
    m_airUsersLastChoice= AIRSTATE_BOGUS; // we don't care until the user clicks the button
    m_hWndButton        = NULL;
    m_hWnd              = NULL;
    m_wndProcOld        = NULL;
    m_pDoc2             = NULL;
    m_pEle2             = NULL;
    m_pWin3             = NULL;
    m_bWindowResizing   = FALSE;
    m_himlButtonShrink  = NULL;
    m_himlButtonExpand  = NULL;
    
    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::CAutoImageResize");
}

// destructor
CAutoImageResize::~CAutoImageResize()
{
    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::~CAutoImageResize");

    DestroyButton();

    ATOMICRELEASE(m_pEle2);
    ATOMICRELEASE(m_pDoc2);

    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::~CAutoImageResize");
}

HRESULT CAutoImageResize::Init(IHTMLDocument2 *pDoc2)
{
    HRESULT hr = S_OK;

    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::Init");

    ASSERT(pDoc2);

    //sink things
    IHTMLElement2           *pEle2       = NULL;
    IHTMLElementCollection  *pCollect    = NULL;
    IHTMLElementCollection  *pSubCollect = NULL;
    IDispatch               *pDisp       = NULL;
    VARIANT                  TagName;
    ULONG                    ulCount     = 0;
    VARIANTARG               va1;
    VARIANTARG               va2;
    IHTMLWindow3            *pWin3       = NULL;
    IOleWindow              *pOleWin     = NULL;
    
    // ...remember this...
    m_pDoc2 = pDoc2;
    pDoc2->AddRef();

    // ...remember the hwnd also...
    hr = m_pDoc2->QueryInterface(IID_IOleWindow,(void **)&pOleWin);
    if (FAILED(hr))
        goto Cleanup;
    pOleWin->GetWindow(&m_hWnd);
    
    // setup variant for finding all the IMG tags...
    TagName.vt      = VT_BSTR;
    TagName.bstrVal = (BSTR)c_bstr_IMG;
    
    //get all tags
    hr = pDoc2->get_all(&pCollect);                   
    if (FAILED(hr))
        goto Cleanup;

    //get all IMG tags
    hr = pCollect->tags(TagName, &pDisp);
    if (FAILED(hr))
        goto Cleanup;
        
    if (pDisp) 
    {
        hr = pDisp->QueryInterface(IID_IHTMLElementCollection,(void **)&pSubCollect);
        ATOMICRELEASE(pDisp);
    }
    if (FAILED(hr))
        goto Cleanup;

    //get IMG tag count
    hr = pSubCollect->get_length((LONG *)&ulCount);
    if (FAILED(hr))
        goto Cleanup;

    // highlander theorem: there can be only one!
    // bt's corollary: there must be exactally one.
    if (1 != ulCount)
        goto Cleanup;

    va1.vt = VT_I4;
    va2.vt = VT_EMPTY;
        
    pDisp    = NULL;                                
    va1.lVal = (LONG)0;
    pSubCollect->item(va1, va2, &pDisp);

    // create event sink for the image
    if (!m_pSink && pDisp)
        m_pSink = new CEventSink(this);

    if (pDisp) 
    {
        hr = pDisp->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);
        if (FAILED(hr))
            goto Cleanup;

        ASSERT(m_pSink);

        if (m_pSink && pEle2) 
        {
            EVENTS events[] = { EVENT_MOUSEOVER, EVENT_MOUSEOUT };
            m_pSink->SinkEvents(pEle2, ARRAYSIZE(events), events);
            m_pEle2=pEle2;
            pEle2->AddRef();
        }
        ATOMICRELEASE(pEle2);
        ATOMICRELEASE(pDisp);
    }

    // sink scroll event from the window, because it doesn't come from elements.
    if (m_pSink) 
    {
        Win3FromDoc2(m_pDoc2, &pWin3);

        if (pWin3) 
        {
            m_pWin3 = pWin3;
            m_pWin3->AddRef();

            EVENTS events[] = { EVENT_SCROLL, EVENT_RESIZE, EVENT_BEFOREPRINT, EVENT_AFTERPRINT };
            m_pSink->SinkEvents(pWin3, ARRAYSIZE(events), events);
        }
    }
    
    // end sinking things

    // Init() gets called when onload fires, so the image *should* be ready
    // to get adjusted, if need be...
    DoAutoImageResize();

Cleanup:

    ATOMICRELEASE(pCollect);
    ATOMICRELEASE(pSubCollect);
    ATOMICRELEASE(pWin3);
    ATOMICRELEASE(pDisp);
    ATOMICRELEASE(pEle2);
    ATOMICRELEASE(pOleWin);

    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::Init");

    return hr;
}

HRESULT CAutoImageResize::UnInit()
{
    // Unhook regular event sink

    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::UnInit");

    DestroyButton();

    if (m_pSink) 
    {
        if (m_pWin3) 
        {
            EVENTS events[] = { EVENT_SCROLL, EVENT_RESIZE, EVENT_BEFOREPRINT, EVENT_AFTERPRINT };
            m_pSink->UnSinkEvents(m_pWin3, ARRAYSIZE(events), events);
            SAFERELEASE(m_pWin3);
        }
        m_pSink->SetParent(NULL);
        ATOMICRELEASE(m_pSink);
    }

    SAFERELEASE(m_pEle2);
    SAFERELEASE(m_pDoc2);
    
    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::UnInit");

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
// AutoImageResize Functions:

HRESULT CAutoImageResize::DoAutoImageResize()
{
    HRESULT          hr         = S_OK;
    IHTMLImgElement *pImgEle    = NULL;
    LONG             lHeight    = 0;
    LONG             lWidth     = 0;
    LONG             lNewHeight = 0;
    LONG             lNewWidth  = 0;
    LONG             lScrHt     = 0;
    LONG             lScrWd     = 0;
    RECT rcBrowserWnd;
    
    ASSERT(m_pEle2);

    // get an IHTMLImgElement from the IHTMLElement cached...
    hr = m_pEle2->QueryInterface(IID_IHTMLImgElement, (void **)&pImgEle);
    if (FAILED(hr) || !pImgEle)
        goto Cleanup;

    // get the current dimensions
    if (FAILED(pImgEle->get_height(&lHeight)) || FAILED(pImgEle->get_width(&lWidth)))
        goto Cleanup;

    // if this is the first time through, we need to take care of some init stuff
    if (AIRSTATE_INIT == m_airState)
    {
        // cache orig dimensions
        m_airOrigSize.x = lWidth;
        m_airOrigSize.y = lHeight;

        // INIT done, promote to NORMAL
        m_airState = AIRSTATE_NORMAL;
    }

    // check to see if we are being called because the user is resizing the window
    // and then massage the state as necessary.
    if (m_bWindowResizing)
    {
        m_airState = AIRSTATE_NORMAL;
    }

    switch (m_airState)
    {
        case AIRSTATE_NORMAL:

        // how big is the window?
        if (GetClientRect(m_hWnd, &rcBrowserWnd)) 
        {

            lScrHt = rcBrowserWnd.bottom - rcBrowserWnd.top;
            lScrWd = rcBrowserWnd.right - rcBrowserWnd.left;
        
            // is the image bigger then the window?
            if (lScrWd < lWidth)
                m_airState=AIRSTATE_WAITINGTORESIZE;

            if (lScrHt < lHeight)
                m_airState=AIRSTATE_WAITINGTORESIZE;
        }
        else
            goto Cleanup;

        // if the window is resizing, we may need to expand the image, so massage the state again...
        // (there is a check later on to make sure we don't expand too far...)
        if (m_bWindowResizing)
        {
            m_airState = AIRSTATE_WAITINGTORESIZE;
        }

        // image didn't fit, so we must resize now
        if (AIRSTATE_WAITINGTORESIZE == m_airState)
        {
            // calculate new size:
            if (MulDiv(lWidth,1000,lScrWd) < MulDiv(lHeight,1000,lScrHt))
            {
                lNewHeight = lScrHt-AIR_SCREEN_CONSTANTY;
                lNewWidth = MulDiv(lNewHeight,m_airOrigSize.x,m_airOrigSize.y);
            }
            else
            {
                lNewWidth  = lScrWd-AIR_SCREEN_CONSTANTX;
                lNewHeight = MulDiv(lNewWidth, m_airOrigSize.y, m_airOrigSize.x);
            }

            // we don't ever want to resize to be LARGER then the original... 
            if ((lNewHeight > m_airOrigSize.y) || (lNewWidth > m_airOrigSize.x))
            {
                if (m_bWindowResizing)
                {
                    // restore orig size cause it should fit and turn off the button
                    lNewHeight = m_airOrigSize.y;
                    lNewWidth  = m_airOrigSize.x;
                    m_airButtonState = AIRBUTTONSTATE_NOBUTTON;
                }
                else
                    goto Cleanup;
            }
            
            if (FAILED(pImgEle->put_height(lNewHeight)) || FAILED(pImgEle->put_width(lNewWidth)))
            {
                goto Cleanup;
            }
            else
            {
                m_airState=AIRSTATE_RESIZED;
                if (AIRBUTTONSTATE_VISIBLE == m_airButtonState)
                {
                    // reposition button
                    HideButton();
                    ShowButton();
                }
            }
        }
        else
        {
            // It fit in the browser window so we don't need to do any work yet...
            // If they resize the window or something we need to check again...
            m_airButtonState=AIRBUTTONSTATE_NOBUTTON;
        }

        break;

        case AIRSTATE_RESIZED:

        // restore the image to its normal size
        if (FAILED(pImgEle->put_height(m_airOrigSize.y)) ||
            FAILED(pImgEle->put_width (m_airOrigSize.x)))
        {
            goto Cleanup;
        }
        else
        {
            m_airState=AIRSTATE_NORMAL;
            if (AIRBUTTONSTATE_VISIBLE == m_airButtonState)
            {
                // reposition button
                HideButton();
                ShowButton();
            }
        }

        break;

        case AIRSTATE_WAITINGTORESIZE:

            // we should never be in this state at this time!
            ASSERT(m_airState!=AIRSTATE_WAITINGTORESIZE);
            
            break;

        default:
            break;
    }
    
Cleanup:

    ATOMICRELEASE(pImgEle);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Timer Proc:

LRESULT CALLBACK CAutoImageResize::s_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAutoImageResize* pThis = (CAutoImageResize*)GetWindowPtr(hWnd, GWLP_USERDATA);    

    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::s_WndProc  hWnd=%x, pThis=%p", hWnd, pThis);

    HRESULT             hr                = S_OK;
    IOleCommandTarget  *pOleCommandTarget = NULL;   
    UINT                iToolTip          = NULL;

    switch (uMsg) 
    {
        case WM_SIZE:

            if (!pThis)
                break;

            SetWindowPos(pThis->m_hWndButton, NULL, 0, 0, LOWORD(lParam), HIWORD(lParam), SWP_NOZORDER | SWP_NOACTIVATE);
            break;

        case WM_ERASEBKGND:
            
            if (!pThis)
                break;

            {
                RECT rc;
                HBRUSH hb = GetSysColorBrush(COLOR_3DFACE);

                GetClientRect(pThis->m_hWndButton, &rc);
                FillRect((HDC)wParam, &rc, hb);
                return TRUE;
            }

        case WM_COMMAND:

            if (!pThis)
                break;

            switch(LOWORD(wParam))
            {
                case IDM_AIR_BUTTON:

                    if (AIRSTATE_NORMAL  == pThis->m_airState)
                    {
                        pThis->m_airUsersLastChoice = AIRSTATE_RESIZED;
                    }
                    else if (AIRSTATE_RESIZED == pThis->m_airState)
                    {
                        pThis->m_airUsersLastChoice = AIRSTATE_NORMAL;
                    }

                    pThis->DoAutoImageResize();
                    break;
            }
            break;

        case WM_NOTIFY:  // tooltips...

            if (!pThis)
                break;

            switch (((LPNMHDR)lParam)->code) 
            {
                case TTN_NEEDTEXT:
                {
                    if (AIRSTATE_NORMAL == pThis->m_airState)
                    {
                        iToolTip = IDS_AIR_SHRINK;
                    }
                    else if (AIRSTATE_RESIZED == pThis->m_airState)
                    {
                        iToolTip = IDS_AIR_EXPAND;
                    }

                    LPTOOLTIPTEXT lpToolTipText;
                    TCHAR szBuf[MAX_PATH];
                    lpToolTipText = (LPTOOLTIPTEXT)lParam;
                    hr = MLLoadString(iToolTip,   
                                      szBuf,
                                      ARRAYSIZE(szBuf));
                    lpToolTipText->lpszText = szBuf;
                    break;
                }
            }
            break;

        case WM_SETTINGCHANGE:
            {
                pThis->DestroyButton(); // to stop wierd window distortion
                break;
            }

        case WM_CONTEXTMENU:
            {
                // should we be consistant and have a turn-me-off/help context menu?
            }
            break;

        default:
            return(DefWindowProc(hWnd, uMsg, wParam, lParam));
    }


    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::s_WndProc  hWnd=%x, pThis=%p", hWnd, pThis);

    return (hr);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Timer Proc:

VOID CALLBACK CAutoImageResize::s_TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime) 
{
    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::TimerProc");

    CAutoImageResize* pThis = (CAutoImageResize*)GetWindowPtr(hwnd, GWLP_USERDATA);

    switch (uMsg) 
    {
        case WM_TIMER:
            KillTimer(hwnd, IDT_AIR_TIMER);  
            if (pThis && (AIRBUTTONSTATE_WAITINGTOSHOW == pThis->m_airButtonState))
            {
                // Our hover bar is waiting to be shown.
                if (pThis->m_pEle2)
                {
                    // We still have an element.  Show it.
                    pThis->m_airButtonState = AIRBUTTONSTATE_VISIBLE;

                    pThis->ShowButton();
                } 
                else
                {
                    // Our timer popped, but we don't have an element.
                    pThis->HideButton();
                }
            }
            break;
        
        default:
            break;
    }
    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::TimerProc");
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Button Functions:

HRESULT CAutoImageResize::CreateButton()
{
    HRESULT hr         = S_OK;
    SIZE    size       = {0,0};

    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::CreateHover, this=%p, m_airButtonState=%d", this, m_airButtonState);

    InitCommonControls();

    WNDCLASS wc = {0};
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = TEXT("AutoImageResizeHost");
    wc.lpfnWndProc = s_WndProc;
    wc.hInstance = g_hinst;
    wc.hbrBackground = HBRUSH(COLOR_BTNFACE);
    RegisterClass(&wc);

    if (!m_hWndButtonCont)
    {

        m_hWndButtonCont = CreateWindow(TEXT("AutoImageResizeHost"), TEXT(""), WS_DLGFRAME | WS_VISIBLE | WS_CHILD /*| WS_POPUP*/, 
                                        0, 0, 0, 0, m_hWnd, NULL, g_hinst, NULL);

        if (!m_hWndButtonCont)
        {
            TraceMsg(TF_AIRESIZE | TF_WARNING, "CAutoImageResize::CreateButton, unable to create m_hWndButtonCont");
            hr = E_FAIL;
            goto Cleanup;
        }

        // setup the window callback stuff...
        ASSERT(m_wndProcOld == NULL);
        m_wndProcOld = (WNDPROC)SetWindowLongPtr(m_hWndButtonCont, GWLP_WNDPROC, (LONG_PTR)s_WndProc);

        // pass in the this pointer so the button can call member functions
        ASSERT(GetWindowPtr(m_hWndButtonCont, GWLP_USERDATA) == NULL);
        SetWindowPtr(m_hWndButtonCont, GWLP_USERDATA, this);
    }

    // create the button
    if (!m_hWndButton)
    {

        m_hWndButton = CreateWindow(TOOLBARCLASSNAME, TEXT(""), TBSTYLE_TOOLTIPS | CCS_NODIVIDER | TBSTYLE_FLAT | WS_VISIBLE | WS_CHILD,
                                    0,0,0,0, m_hWndButtonCont, NULL, g_hinst, NULL);

        if (!m_hWndButton)
        {
            TraceMsg(TF_AIRESIZE | TF_WARNING, "CAutoImageResize::CreateButton, unable to create m_hWndButton");
            hr = E_FAIL;
            goto Cleanup;
        }
        

        ASSERT(GetWindowPtr(m_hWndButton, GWLP_USERDATA) == NULL);
        SetWindowPtr(m_hWndButton, GWLP_USERDATA, this);

        // set cc version for this too, and the sizeof tbbutton struct...
        SendMessage(m_hWndButton, CCM_SETVERSION,      COMCTL32_VERSION, 0);
        SendMessage(m_hWndButton, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);
    }

    if (!m_himlButtonExpand)
    {
        m_himlButtonExpand = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_AIR_EXPAND), 32, 0, CLR_DEFAULT, IMAGE_BITMAP, LR_CREATEDIBSECTION);
        if (!m_himlButtonExpand)
        {
            TraceMsg(TF_AIRESIZE | TF_WARNING, "CAutoImageResize::CreateButton, unable to create m_himlButtonExpand");
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    if (!m_himlButtonShrink)
    {
        m_himlButtonShrink = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_AIR_SHRINK), 32, 0, CLR_DEFAULT, IMAGE_BITMAP, LR_CREATEDIBSECTION);
        if (!m_himlButtonShrink)
        {
            TraceMsg(TF_AIRESIZE | TF_WARNING, "CAutoImageResize::CreateButton, unable to create m_himlButtonShrink");
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // set image list and hot image list
    SendMessage(m_hWndButton, TB_SETIMAGELIST,    0, (LPARAM)m_himlButtonExpand);
    SendMessage(m_hWndButton, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlButtonExpand);

    // add the buttons

    TBBUTTON tbAirButton;
    
    tbAirButton.iBitmap   = 0;
    tbAirButton.idCommand = IDM_AIR_BUTTON;
    tbAirButton.fsState   = TBSTATE_ENABLED;
    tbAirButton.fsStyle   = TBSTYLE_BUTTON;
    tbAirButton.dwData    = 0;
    tbAirButton.iString   = 0;

    SendMessage(m_hWndButton, TB_INSERTBUTTON, 0, (LPARAM)&tbAirButton);

Cleanup:

    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::CreateButton, this=%p, m_airButtonState=%d", this, m_airButtonState);

    return hr;
}

HRESULT CAutoImageResize::ShowButton()
{
    HRESULT    hr       = E_FAIL;
    IHTMLRect *pRect    = NULL;
    LONG       lLeft    = 0;              // these are the screen coords
    LONG       lRight   = 0;              // we get right and bottom to det size of image
    LONG       lTop     = 0;
    LONG       lBottom  = 0;
    DWORD      dwOffset = MP_GetOffsetInfoFromRegistry();
    RECT       rcBrowserWnd;
    WORD       wImage   = NULL;

    DWORD dw;
    SIZE  sz;
    RECT  rc;   
    
    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::ShowButton, this=%p, m_airButtonState=%d", this, m_airButtonState);

    ASSERT(m_pEle2);

    // get the coords of the image...
    if (SUCCEEDED(m_pEle2->getBoundingClientRect(&pRect)) && pRect)
    {
        pRect->get_left(&lLeft);
        pRect->get_right(&lRight);
        pRect->get_top(&lTop);
        pRect->get_bottom(&lBottom);
    }
    else
        goto Cleanup;

    // make sure we are inside the browser window...
    if (GetClientRect(m_hWnd, &rcBrowserWnd)) 
    {
        // if the browser window is less then a certain min size, we
        // don't display the button...
        if ((rcBrowserWnd.right  - rcBrowserWnd.left < AIR_MIN_BROWSER_SIZE) ||
            (rcBrowserWnd.bottom - rcBrowserWnd.top  < AIR_MIN_BROWSER_SIZE))
            goto Cleanup;

        // if the browser window is larger then the image, we don't display
        // the button...
        if ((AIRSTATE_NORMAL == m_airState) &&
            (rcBrowserWnd.left   < lLeft  ) &&
            (rcBrowserWnd.right  > lRight ) &&
            (rcBrowserWnd.top    < lTop   ) &&
            (rcBrowserWnd.bottom > lBottom))
            goto Cleanup;
        

        // adjust for scrollbars
        if (lRight > rcBrowserWnd.right - AIR_SCROLLBAR_SIZE_V)
        {
            lRight = rcBrowserWnd.right - AIR_SCROLLBAR_SIZE_V;
        }

        if (lBottom > rcBrowserWnd.bottom - AIR_SCROLLBAR_SIZE_H)
        {
            lBottom = rcBrowserWnd.bottom - AIR_SCROLLBAR_SIZE_H;
        }
    }
    else
        goto Cleanup;

    // someone tried to show the button, but it doesn't exist.
    // this is ok, if we actually have an element, so fix it for them.
    if (!m_hWndButtonCont && m_pEle2)
        CreateButton();

    // make sure the image list exists
    if (!m_himlButtonShrink || !m_himlButtonExpand)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (AIRSTATE_NORMAL == m_airState)
    {
        SendMessage(m_hWndButton, TB_SETIMAGELIST,    0, (LPARAM)m_himlButtonShrink);
        SendMessage(m_hWndButton, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlButtonShrink);
    }
    else if (AIRSTATE_RESIZED == m_airState)
    {
        SendMessage(m_hWndButton, TB_SETIMAGELIST,    0, (LPARAM)m_himlButtonExpand);
        SendMessage(m_hWndButton, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlButtonExpand);
    }		
    else if (AIRSTATE_INIT == m_airState || AIRSTATE_WAITINGTORESIZE == m_airState)
    {
        goto Cleanup;
    }

    // do some calc to get window size and position...
    dw        = (DWORD)SendMessage(m_hWndButton, TB_GETBUTTONSIZE, 0, 0);
    sz.cx     = LOWORD(dw); 
    sz.cy     = HIWORD(dw);
    rc.left   = rc.top = 0; 
    rc.right  = sz.cx; 
    rc.bottom = sz.cy;

    AdjustWindowRectEx(&rc, GetWindowLong(m_hWndButtonCont, GWL_STYLE), FALSE, GetWindowLong(m_hWndButtonCont, GWL_EXSTYLE));

    // that should be all...
    SetWindowPos(m_hWndButtonCont, NULL,
                 lRight -(rc.right-rc.left)-dwOffset,       // left
                 lBottom-(rc.bottom-rc.top)-dwOffset,       // right
                 rc.right -rc.left,                         // width
                 rc.bottom-rc.top,                          // height
                 SWP_NOZORDER | SWP_SHOWWINDOW);            // show it

    m_airButtonState = AIRBUTTONSTATE_VISIBLE;

    hr = S_OK;

Cleanup:

    ATOMICRELEASE(pRect);

    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::ShowButton, this=%p, m_airButtonState=%d", this, m_airButtonState);

    return hr;
}

HRESULT CAutoImageResize::HideButton()
{
    HRESULT hr = S_OK;

    if (m_hWndButton)
    {
        ShowWindow(m_hWndButtonCont, SW_HIDE);
        m_airButtonState=AIRBUTTONSTATE_HIDDEN;
    }
    else
        hr = E_FAIL;

    return hr;
}

HRESULT CAutoImageResize::DestroyButton()
{
    HRESULT hr = S_OK;

        TraceMsg(TF_AIRESIZE, "+CAutoImageResize::DestroyHover, this=%p, m_airButtonState=%d", this, m_airButtonState);

    if (m_hWndButton)
    {
        // first destroy the toolbar
        if (!DestroyWindow(m_hWndButton))
        {
            TraceMsg(TF_AIRESIZE, "In CAutoImageResize::DestroyHover, DestroyWindow(m_hWndButton) failed");
            hr = E_FAIL;
        }
        m_hWndButton=NULL;
    }

    // If we have a container window...
    if (m_hWndButtonCont)
    {
        if (m_wndProcOld)
        {
            // Unsubclass the window
            SetWindowLongPtr(m_hWndButtonCont, GWLP_WNDPROC, (LONG_PTR)m_wndProcOld);
            m_wndProcOld = NULL;
        }

        // Clear the window word
        SetWindowPtr(m_hWndButtonCont, GWLP_USERDATA, NULL);

        // then destroy the rebar
        if (!DestroyWindow(m_hWndButtonCont))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        m_hWndButtonCont = NULL;
    }

    // and destroy the image lists...
    if (m_himlButtonShrink)
    {
        ImageList_Destroy(m_himlButtonShrink);
        m_himlButtonShrink = NULL;
    }

    if (m_himlButtonExpand)
    {
        ImageList_Destroy(m_himlButtonExpand);
        m_himlButtonExpand = NULL;
    }


Cleanup:
    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::DestroyHover, this=%p, hr=%x", this, hr);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Event Handlers:

HRESULT CAutoImageResize::HandleMouseover()
{
    HRESULT hr = S_OK;

    if (AIRBUTTONSTATE_NOBUTTON == m_airButtonState)
    {
        return S_OK;
    }

    if (!m_hWndButton)
    {
        hr = CreateButton();
    }

    if (m_hWndButton)
    {
        m_airButtonState = AIRBUTTONSTATE_WAITINGTOSHOW;
        SetTimer(m_hWndButton, IDT_AIR_TIMER, AIR_TIMER, s_TimerProc);
    }

    return hr;
}

HRESULT CAutoImageResize::HandleMouseout()
{

    switch(m_airButtonState)
    {
        case AIRBUTTONSTATE_HIDDEN:
            break;
     
        case AIRBUTTONSTATE_VISIBLE:
            HideButton();
            break;
        
        case AIRBUTTONSTATE_WAITINGTOSHOW:
            m_airButtonState=AIRBUTTONSTATE_HIDDEN;
            KillTimer(m_hWndButton, IDT_AIR_TIMER);
            break;
    }

    return S_OK;
}

HRESULT CAutoImageResize::HandleScroll()
{
    RECT rect;

    if (AIRBUTTONSTATE_VISIBLE == m_airButtonState)
    {
        ASSERT(m_hWndButtonCont);
        ASSERT(m_pEle2);

        GetWindowRect(m_hWndButtonCont, &rect);

        HideButton();
        ShowButton();

        rect.top    -= 3*AIR_MIN_CY;
        rect.bottom += 2*AIR_MIN_CY;
        rect.left   -= 3*AIR_MIN_CX;
        rect.right  += 2*AIR_MIN_CX;

        // redraw the button
        RedrawWindow(m_hWnd, &rect, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
    }

    return S_OK;
}

HRESULT CAutoImageResize::HandleResize()
{

    // if the image previously fit in the window, but the user resized the window and now
    // we have resized the image, we should reset the button state so the user actually gets
    // a button...
    if (AIRBUTTONSTATE_NOBUTTON == m_airButtonState)
    {
        m_airButtonState = AIRBUTTONSTATE_HIDDEN;
    }

    // if the users has decided they want the image expanded by clicking the button to expand it,
    // we should honor that and not resize the image simply because the window changes size
    if (AIRSTATE_NORMAL == m_airUsersLastChoice)
    {
        return S_OK;
    }

    m_bWindowResizing = TRUE;

    DoAutoImageResize();
    
    m_bWindowResizing = FALSE;

    return S_OK;
}

HRESULT CAutoImageResize::HandleBeforePrint()
{

    m_airBeforePrintState = m_airState;

    if (AIRSTATE_RESIZED == m_airState)
    {
        DoAutoImageResize();
    }

    return S_OK;
}

HRESULT CAutoImageResize::HandleAfterPrint()
{
    if (AIRSTATE_RESIZED == m_airBeforePrintState &&
        AIRSTATE_NORMAL  == m_airState)
    {
        DoAutoImageResize();
    }

    return S_OK;
}

HRESULT CAutoImageResize::HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj) 
{
    TraceMsg(TF_AIRESIZE, "CAutoImageResize::HandleEvent Event=%ws", EventsToSink[Event].pwszEventName);

    HRESULT hr          = S_OK;

    m_eventsCurr = Event;

    switch(Event) 
    {
        case EVENT_SCROLL:
            HandleScroll();
            break;

        case EVENT_MOUSEOVER:
            hr = HandleMouseover();
            break;

        case EVENT_MOUSEOUT:
            hr = HandleMouseout();
            break;

        case EVENT_RESIZE:
            hr = HandleResize();
            break;

        case EVENT_BEFOREPRINT:
            hr = HandleBeforePrint();
            break;

        case EVENT_AFTERPRINT:
            hr = HandleAfterPrint();
            break;

        default:
            //do nothing?
            break;
    }

    return (hr);
}


////////////////////////////////////////////////////////////////////////////////////////////////

// this is stolen from iforms.cpp:

//=========================================================================
//
// Event sinking class
//
//  We simply implement IDispatch and make a call into our parent when
//   we receive a sinked event.
//
//=========================================================================

CAutoImageResize::CEventSink::CEventSink(CAutoImageResizeEventSinkCallback *pParent)
{
    TraceMsg(TF_AIRESIZE, "CAutoImageResize::CEventSink::CEventSink");
    DllAddRef();
    m_cRef = 1;
    m_pParent = pParent;
}

CAutoImageResize::CEventSink::~CEventSink()
{
    TraceMsg(TF_AIRESIZE, "CAutoImageResize::CEventSink::~CEventSink");
    ASSERT( m_cRef == 0 );
    DllRelease();
}

STDMETHODIMP CAutoImageResize::CEventSink::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if ((IID_IDispatch == riid) ||
        (IID_IUnknown == riid))
    {
        *ppv = (IDispatch *)this;
    }

    if (NULL != *ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CAutoImageResize::CEventSink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CAutoImageResize::CEventSink::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CAutoImageResize::CEventSink::SinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents)
{
    VARIANT_BOOL bSuccess = VARIANT_TRUE;

    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CAutoImageResizeEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pEle2->attachEvent(bstrEvent, (IDispatch *)this, &bSuccess);

            SysFreeString(bstrEvent);
        }
        else
        {
            bSuccess = VARIANT_FALSE;
        }

        if (!bSuccess)
            break;
    }

    return (bSuccess) ? S_OK : E_FAIL;
}

HRESULT CAutoImageResize::CEventSink::SinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents)
{
    VARIANT_BOOL bSuccess = VARIANT_TRUE;

    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CAutoImageResizeEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pWin3->attachEvent(bstrEvent, (IDispatch *)this, &bSuccess);

            SysFreeString(bstrEvent);
        }
        else
        {
            bSuccess = VARIANT_FALSE;
        }

        if (!bSuccess)
            break;
    }

    return (bSuccess) ? S_OK : E_FAIL;
}


HRESULT CAutoImageResize::CEventSink::UnSinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents)
{
    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CAutoImageResizeEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pEle2->detachEvent(bstrEvent, (IDispatch *)this);

            SysFreeString(bstrEvent);
        }
    }

    return S_OK;
}

HRESULT CAutoImageResize::CEventSink::UnSinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents)
{
    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CAutoImageResizeEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pWin3->detachEvent(bstrEvent, (IDispatch *)this);

            SysFreeString(bstrEvent);
        }
    }

    return S_OK;
}

// IDispatch
STDMETHODIMP CAutoImageResize::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAutoImageResize::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
            /* [in] */ LCID /*lcid*/,
            /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAutoImageResize::CEventSink::GetIDsOfNames(
                REFIID          riid,
                OLECHAR**       rgszNames,
                UINT            cNames,
                LCID            lcid,
                DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAutoImageResize::CEventSink::Invoke(
            DISPID dispIdMember,
            REFIID, LCID,
            WORD wFlags,
            DISPPARAMS* pDispParams,
            VARIANT* pVarResult,
            EXCEPINFO*,
            UINT* puArgErr)
{
    if (m_pParent && pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
        {
            IHTMLEventObj *pObj=NULL;

            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pObj) && pObj))
            {
                EVENTS Event=EVENT_BOGUS;
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                if (bstrEvent)
                {
                    for (int i=0; i<ARRAYSIZE(CAutoImageResizeEventSinkCallback::EventsToSink); i++)
                    {
                        if (!StrCmpCW(bstrEvent, CAutoImageResizeEventSinkCallback::EventsToSink[i].pwszEventName))
                        {
                            Event = (EVENTS) i;
                            break;
                        }
                    }

                    SysFreeString(bstrEvent);
                }

                if (Event != EVENT_BOGUS)
                {
                    IHTMLElement *pEle=NULL;

                    pObj->get_srcElement(&pEle);

                    // EVENT_SCROLL comes from our window so we won't have an
                    //  element for it
                    if (pEle || (Event == EVENT_SCROLL) || (Event == EVENT_RESIZE) || (Event == EVENT_BEFOREPRINT) || (Event == EVENT_AFTERPRINT))
                    {
                        // Call the event handler here
                        m_pParent->HandleEvent(pEle, Event, pObj);

                        if (pEle)
                        {
                            pEle->Release();
                        }
                    }
                }

                pObj->Release();
            }
        }
    }

    return S_OK;
}
#undef TF_AIRESIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\themeservice.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeService.h
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  This file contains functions that are called from the shell services DLL
//  to interact with the theme service.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ThemeService_
#define     _ThemeService_

//  --------------------------------------------------------------------------
//  CThemeService
//
//  Purpose:    Class that implements entry points for the common shell
//              service to invoke theme service functionality.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

class   CThemeService
{
    public:
        static  BOOL            Main (DWORD dwReason);
        static  NTSTATUS        RegisterServer (void);
        static  NTSTATUS        UnregisterServer (void);

    private:
        static NTSTATUS _ProcessAttach();
};

#endif  /*  _ThemeService_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\themesrv\themeservice.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeService.cpp
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  This file contains functions that are called from the shell services DLL
//  to interact with the theme service.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ThemeService.h"
#include <shlwapi.h>
#include <shlwapip.h>

#include "Resource.h"
#include "ThemeManagerAPIRequest.h"
#include "ThemeManagerService.h"
#include "ThemeServerClient.h"

extern  HINSTANCE   g_hInstance;
CRITICAL_SECTION    g_csThemeService = {0};


//  --------------------------------------------------------------------------
//  CThemeService::Main
//
//  Arguments:  See the platform SDK under DllMain.
//
//  Returns:    See the platform SDK under DllMain.
//
//  Purpose:    Performs initialization and clean up on process attach and
//              detach. Not interested in anything else.
//
//  History:    2000-10-12  vtan        created
//              2001-01-02  vtan        scoped to a C++ class
//  --------------------------------------------------------------------------
NTSTATUS CThemeService::_ProcessAttach()
{
    NTSTATUS status;

    status = CThemeManagerAPIRequest::StaticInitialize();
    if (!NT_SUCCESS(status))
        goto cleanup;

    status = CThemeServerClient::StaticInitialize();
    if (!NT_SUCCESS(status))
        goto cleanup1;

    if (!InitializeCriticalSectionAndSpinCount(&g_csThemeService, 0))
    {
        status = STATUS_NO_MEMORY;
        goto cleanup2;
    }

    status = STATUS_SUCCESS;
    goto cleanup;

cleanup2:
    CThemeServerClient::StaticTerminate();
cleanup1:
    CThemeManagerAPIRequest::StaticTerminate();

cleanup:
    return status;
}

//  --------------------------------------------------------------------------
//  CThemeService::Main
//
//  Arguments:  See the platform SDK under DllMain.
//
//  Returns:    See the platform SDK under DllMain.
//
//  Purpose:    Performs initialization and clean up on process attach and
//              detach. Not interested in anything else.
//
//  History:    2000-10-12  vtan        created
//              2001-01-02  vtan        scoped to a C++ class
//  --------------------------------------------------------------------------

BOOL CThemeService::Main (DWORD dwReason)

{
    NTSTATUS    status;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            status = _ProcessAttach();
            break;

        case DLL_PROCESS_DETACH:
            DeleteCriticalSection(&g_csThemeService);
            TSTATUS(CThemeServerClient::StaticTerminate());
            TSTATUS(CThemeManagerAPIRequest::StaticTerminate());
            status = STATUS_SUCCESS;
            break;

        default:
            status = STATUS_SUCCESS;
            break;
    }

    return NT_SUCCESS(status);
}

//  --------------------------------------------------------------------------
//  CThemeService::DllRegisterServer
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Register entry point to allow the theme server to install
//              itself into the registry.
//
//  History:    2000-11-28  vtan        created
//              2001-01-02  vtan        scoped to a C++ class
//  --------------------------------------------------------------------------

NTSTATUS    CThemeService::RegisterServer (void)

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;

    //  In upgrade cases, remove our old name service from both 32 & 64 bit systems

    (NTSTATUS)CService::Remove(TEXT("ThemeService"));

#ifdef _WIN64

    //  In upgrade cases for 64-bit, remove our current name service

    (NTSTATUS)CService::Remove(CThemeManagerService::GetName());

#else
    
    //  This is 32-bit only. Check if this is REALLY 32-bit and not 32-bit on 64-bit.

    if (!IsOS(OS_WOW6432))
    {
        // Prepare the failure actions, in order to get the service to restart automatically

        SC_ACTION ac[3];
        ac[0].Type = SC_ACTION_RESTART;
        ac[0].Delay = 60000;
        ac[1].Type = SC_ACTION_RESTART;
        ac[1].Delay = 60000;
        ac[2].Type = SC_ACTION_NONE;
        ac[2].Delay = 0;
        
        SERVICE_FAILURE_ACTIONS sf;
        sf.dwResetPeriod = 86400;
        sf.lpRebootMsg = NULL;
        sf.lpCommand = NULL;
        sf.cActions = 3;
        sf.lpsaActions = ac;

        //  Now install the new service by name.

        status = CService::Install(CThemeManagerService::GetName(),
                                 TEXT("%SystemRoot%\\System32\\svchost.exe -k netsvcs"),
                                 TEXT("UIGroup"),
                                 NULL,
                                 TEXT("shsvcs.dll"),
                                 NULL,
                                 TEXT("netsvcs"),
                                 TEXT("ThemeServiceMain"),
                                 // Disabled by default on Server SKUs
                                 IsOS(OS_ANYSERVER) ? SERVICE_DISABLED : SERVICE_AUTO_START,
                                 g_hInstance,
                                 IDS_THEMESERVER_DISPLAYNAME,
                                 IDS_THEMESERVER_DESCRIPTION,
                                 &sf);

    }

#endif

    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeService::DllUnregisterServer
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Unregister entry point to allow the theme server to uninstall
//              itself from the registry.
//
//  History:    2000-11-28  vtan        created
//              2001-01-02  vtan        scoped to a C++ class
//  --------------------------------------------------------------------------

NTSTATUS    CThemeService::UnregisterServer (void)

{
    //  Ignore any "not found", etc errors.

    (NTSTATUS)CService::Remove(CThemeManagerService::GetName());
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  ::ThemeServiceMain
//
//  Arguments:  dwArgc      =   Number of arguments.
//              lpszArgv    =   Argument array.
//
//  Returns:    <none>
//
//  Purpose:    ServiceMain entry point for theme server.
//
//  History:    2000-11-28  vtan        created
//              2001-01-02  vtan        scoped to the theme service
//              2002-03-22  scotthan    add robustness, debug exception handling
//                                      (otherwise, SCM quietly handles service exceptions).
//  --------------------------------------------------------------------------

void    WINAPI  ThemeServiceMain (DWORD dwArgc, LPWSTR *lpszArgv)

{
    UNREFERENCED_PARAMETER(dwArgc);
    UNREFERENCED_PARAMETER(lpszArgv);

    NTSTATUS    status;

    DEBUG_TRY();

    EnterCriticalSection(&g_csThemeService);

    status = CThemeManagerAPIRequest::InitializeServerChangeNumber();
    if (NT_SUCCESS(status))
    {
        CThemeManagerAPIServer  *pThemeManagerAPIServer;

        //  Bring in shell32.dll NOW so that when CheckThemeSignature is called
        //  and it tries to use SHGetFolderPath it won't cause shell32.dll to be
        //  brought in while impersonating a user. This will cause advapi32.dll
        //  to leak a key to the user's hive that won't get cleaned up at logoff.

        CModule* pModule = new CModule(TEXT("shell32.dll"));
        if( pModule != NULL )
        {
            pThemeManagerAPIServer = new CThemeManagerAPIServer;
            if (pThemeManagerAPIServer != NULL)
            {
                CAPIConnection  *pAPIConnection;

                pAPIConnection = new CAPIConnection(pThemeManagerAPIServer);
                if (pAPIConnection != NULL)
                {
                    CThemeManagerService    *pThemeManagerService;

                    pThemeManagerService = new CThemeManagerService(pAPIConnection, pThemeManagerAPIServer);
                    if (pThemeManagerService != NULL)
                    {
                        CThemeManagerSessionData::SetAPIConnection(pAPIConnection);
                        TSTATUS(CThemeManagerAPIRequest::ArrayInitialize());
                        
                        pThemeManagerService->Start();

                        pThemeManagerService->Release();

                        TSTATUS(CThemeManagerAPIRequest::ArrayTerminate());
                        CThemeManagerSessionData::ReleaseAPIConnection();
                    }
                    pAPIConnection->Release();
                }
                pThemeManagerAPIServer->Release();
            }
            delete pModule;
        }
    }
    LeaveCriticalSection(&g_csThemeService);

    DEBUG_EXCEPT("Breaking in ThemeServiceMain exception handler.");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\about.cpp ===
#include "priv.h"

#include <mluisupp.h>

//
//  The about box is now an HTML dialog. It is sent a ~ (tilde) 
//  delimited BSTR that has, in this order, version number, 
//  person software is licensed to, company software is licensed to, and 
//  whether 40, 56, or 128 bit ie is installed.
//

STDAPI_(void) IEAboutBox( HWND hWnd )
{
    TCHAR szInfo[512 + INTERNET_MAX_URL_LENGTH];  // potential for IEAK specific URL from 
                                                  // SHAboutInfo
    szInfo[0] = 0;

    SHAboutInfo(szInfo, ARRAYSIZE(szInfo));     // from shlwapi

    BSTR bstrVal = SysAllocStringT(szInfo);
    if (bstrVal)
    {
        TCHAR   szResURL[MAX_URL_STRING];
        HRESULT hr;

        hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                               HINST_THISDLL,
                               ML_CROSSCODEPAGE,
                               TEXT("about.dlg"),
                               szResURL,
                               ARRAYSIZE(szResURL),
                               TEXT("shdocvw.dll"));
        if (SUCCEEDED(hr))
        {
            VARIANT var = {0};      // variant containing version and user info
            var.vt = VT_BSTR;
            var.bstrVal = bstrVal;

            IMoniker *pmk;
            if (SUCCEEDED(CreateURLMoniker(NULL, szResURL, &pmk)))
            {
                ShowHTMLDialog(hWnd, pmk, &var, L"help: no", NULL);
                pmk->Release();
            }
        }
        SysFreeString(bstrVal);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_

#if (WINVER >= 0x0500)
#else
#define TVS_EX_NOSINGLECOLLAPSE    0x00000001 // for now make this internal
#endif


STDAPI_(DWORD) NT5_GetSaveFileNameW(LPOPENFILENAMEW pofn);
STDAPI_(PROPSHEETPAGE*) Whistler_AllocatePropertySheetPage(int numPages, DWORD* pc);
STDAPI_(HPROPSHEETPAGE) Whistler_CreatePropertySheetPageW(LPCPROPSHEETPAGEW a);


#undef GetSaveFileNameW
#define GetSaveFileNameW NT5_GetSaveFileNameW

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\atl.h ===
STDAPI_(void) AtlInit(HINSTANCE hinst);
STDAPI_(void) AtlTerm();

STDAPI        AtlGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);
STDAPI_(LONG) AtlGetLockCount();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\airesize.h ===
#ifndef __IEAIRESIZE_H_
#define __IEAIRESIZE_H_

#define AIR_SCREEN_CONSTANTY 34          // in pixels (this is a magic number)
#define AIR_SCREEN_CONSTANTX 40          // in pixels (this is a magic number)
#define AIR_TIMER            1400        // time in milliseconds to delay on mouseover/out events
#define AIR_MIN_CX           39          // minimum x size of the button
#define AIR_MIN_CY           38          // minimum y size of the button
#define AIR_NUM_TBBITMAPS    1           // number of bitmaps (only 1 button)
#define AIR_BMP_CX           32          // bitmap size
#define AIR_BMP_CY           32
#define AIR_MIN_BROWSER_SIZE 150         // min size in pixels the browser has to be to display the button

#define AIR_SCROLLBAR_SIZE_V GetSystemMetrics(SM_CXVSCROLL)
#define AIR_SCROLLBAR_SIZE_H GetSystemMetrics(SM_CYHSCROLL)

// used for sinking scroll events:
void  Win3FromDoc2(IHTMLDocument2 *pDoc2, IHTMLWindow3 **ppWin3);
DWORD MP_GetOffsetInfoFromRegistry();


// EventSink Callback Class...
class CAutoImageResizeEventSinkCallback
{
public:
    typedef enum
    {
        EVENT_BOGUS     = 100,
        EVENT_MOUSEOVER = 0,
        EVENT_MOUSEOUT,
        EVENT_SCROLL,
        EVENT_RESIZE,
        EVENT_BEFOREPRINT,
        EVENT_AFTERPRINT
    }
    EVENTS;

    typedef struct
    {
        EVENTS  Event;
        LPCWSTR pwszEventSubscribe;
        LPCWSTR pwszEventName;
    }
    EventSinkEntry;

    virtual HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj) = 0;

    static  EventSinkEntry EventsToSink[];
};

class CAutoImageResize : public CAutoImageResizeEventSinkCallback
{
    long   m_cRef;

public:
    class CEventSink;
    
    CAutoImageResize();
   ~CAutoImageResize();

    // IUnknown...
    virtual STDMETHODIMP QueryInterface(REFIID, void **);
    virtual ULONG __stdcall AddRef();
    virtual ULONG __stdcall Release();

    // CAutoImageResizeEventSinkCallback...
    HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj);
    
    // Init and UnInit (called from basesb.cpp)
    HRESULT Init(IHTMLDocument2 *pDoc2);
    HRESULT UnInit();

protected:

    // AutoImageResize Stuff
    HRESULT DoAutoImageResize();
    
    // Event Handlers
    HRESULT HandleMouseover();
    HRESULT HandleMouseout();
    HRESULT HandleScroll();
    HRESULT HandleResize();
    HRESULT HandleBeforePrint();
    HRESULT HandleAfterPrint();

    // Button Functions
    HRESULT CreateButton();
    HRESULT ShowButton();
    HRESULT HideButton();
    HRESULT DestroyButton();

    // Timer callback function
    static  VOID CALLBACK s_TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    // Button callback function
    static  LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    // CAutoImageResize member variables
    CEventSink     *m_pSink;                 // Event Sink

    HWND            m_hWndButton;            // Button hWnd
    HWND            m_hWndButtonCont;
    WNDPROC         m_wndProcOld;            // Old wind proc for button
    HIMAGELIST      m_himlButtonShrink;      // Shrink image
    HIMAGELIST      m_himlButtonExpand;		 // Expand image    
            
    UINT            m_airState;              // Current state of the AutoImageResize feature (image state)
    UINT            m_airButtonState;        // Current state of the AIR Button
    UINT            m_airUsersLastChoice;    // The last state the user put us into by clicking the button
    UINT            m_airBeforePrintState;   // OnAfterPrint uses this to restore state if necessary

    POINT           m_airOrigSize;           // Original x,y dimensions of an image thats been AIR'ed

    BOOL            m_bWindowResizing;       // True when a onresize event for the win3 object fired, but hasn't been processed yet.
                                             
    // Useful stuff for the attached document
    HWND            m_hWnd;                  // Browser hWnd
    IHTMLDocument2 *m_pDoc2;                 // Document pointer
    IHTMLElement2  *m_pEle2;                 // Pointer to the image
    IHTMLWindow3   *m_pWin3;                 // For unsinking scroll event
    EVENTS          m_eventsCurr;            // Event currently being processed

public:

    // Sinks regular Trident events. Calls back via CAutoImageResizeEventSinkCallback...
    class CEventSink : public IDispatch
    {
        ULONG   m_cRef;

    public:

        CEventSink(CAutoImageResizeEventSinkCallback *pParent);
       ~CEventSink();

        HRESULT SinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents);
        HRESULT UnSinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents);
        HRESULT SinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents);
        HRESULT UnSinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents);

        void SetParent(CAutoImageResizeEventSinkCallback *pParent) { m_pParent = pParent; }

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo);
        STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
            LCID lcid, DISPID *rgDispId);
        STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pVarResult,
            EXCEPINFO *pExcepInfo, UINT *puArgErr);

    private:
        CAutoImageResizeEventSinkCallback *m_pParent;
    };
};

#endif //__IEAIRESIZE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\apithk.c ===
//
//  APITHK.C
//
//  This file has API thunks that allow shdocvw to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//
#define UNICODE 1

#include <shlwapi.h>
#include <shlwapip.h>
#include <resource.h>
#include <shfusion.h>

BOOL NT5_GetSaveFileNameW(LPOPENFILENAMEW pofn)
{
    BOOL fRC = FALSE;
    
    if (GetUIVersion() >= 5 && pofn->lStructSize <= sizeof(OPENFILENAMEW))
    {
        // we're on Win2k or Millennium
        ULONG_PTR uCookie = 0;
        OPENFILENAMEW ofn_nt5;

        memset(&ofn_nt5, 0, sizeof(OPENFILENAMEW));

        CopyMemory(&ofn_nt5, pofn, pofn->lStructSize);
        
        ofn_nt5.lStructSize = sizeof(OPENFILENAMEW);    // New OPENFILENAME struct size

        // If we start adding more of these, make a table.
        if(pofn->lpTemplateName == MAKEINTRESOURCE(IDD_ADDTOSAVE_DIALOG))
            ofn_nt5.lpTemplateName = MAKEINTRESOURCE(IDD_ADDTOSAVE_NT5_DIALOG);

        if (SHActivateContext(&uCookie))
        {
            fRC = GetSaveFileNameWrapW(&ofn_nt5);
            if (uCookie)
            {
                SHDeactivateContext(uCookie);
            }
        }
        
        if(fRC)
        {
            ofn_nt5.lStructSize = pofn->lStructSize;    // restore old values
            ofn_nt5.lpTemplateName = pofn->lpTemplateName;
            CopyMemory(pofn, &ofn_nt5, pofn->lStructSize);  // copy to passed in struct
        }
    }
    else
    {
        fRC = GetSaveFileNameWrapW(pofn);
    }

    return fRC;
}

PROPSHEETPAGE* Whistler_AllocatePropertySheetPage(int numPages, DWORD* pc)
{
    PROPSHEETPAGE* pspArray = (PROPSHEETPAGE*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PROPSHEETPAGE)*numPages);
    if (pspArray)
    {
        int i;
        for (i=0; i<numPages; i++)
        {
            pspArray[i].dwSize = sizeof(PROPSHEETPAGE);
            pspArray[i].dwFlags = PSP_USEFUSIONCONTEXT;
            pspArray[i].hActCtx = g_hActCtx;
        }
        *pc = sizeof(PROPSHEETPAGE);
    }
    return pspArray;
}

HPROPSHEETPAGE Whistler_CreatePropertySheetPageW(LPCPROPSHEETPAGEW a)
{
    LPCPROPSHEETPAGEW ppsp = (LPCPROPSHEETPAGEW)a;
    PROPSHEETPAGEW psp;

    if (g_hActCtx && (a->dwSize<=PROPSHEETPAGE_V2_SIZE))
    {
        memset(&psp, 0, sizeof(psp));
        CopyMemory(&psp, a, a->dwSize);
        psp.dwSize = sizeof(psp);
        ppsp = &psp;
    }
    return CreatePropertySheetPageW(ppsp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\asyncrat.h ===
class CDocObjectHost;

struct PicsQuery {
	DWORD dwSerial;
	HWND hwnd;
	LPVOID lpvRatingDetails;
};

extern DWORD _AddPicsQuery(HWND hwnd);
extern void _RemovePicsQuery(DWORD dwSerial);
extern BOOL _GetPicsQuery(DWORD dwSerial, PicsQuery *pOut);
extern void _RefPicsQueries(void);
extern void _ReleasePicsQueries(void);
extern BOOL _PostPicsMessage(DWORD dwSerial, HRESULT hr, LPVOID lpvRatingDetails);

#define WM_PICS_ASYNCCOMPLETE           (WM_USER + 0x0501)
#define WM_PICS_ROOTDOWNLOADCOMPLETE    (WM_USER + 0x0502)
#define WM_PICS_ALLCHECKSCOMPLETE       (WM_USER + 0x0503)
#define WM_PICS_DOBLOCKINGUI            (WM_USER + 0x0504)
#define WM_PICS_RESULTTOPRIVWIN         (WM_USER + 0x0505)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\atl.cpp ===
#include "priv.h"
#include "atl.h"
#include "nsc.h"
#include "srchasst.h"

//ATL support
CComModule _Module;         // ATL module object

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_ShellNameSpace, CNscTree)
    OBJECT_ENTRY(CLSID_SearchAssistantOC, CSearchAssistantOC)
END_OBJECT_MAP()

STDAPI_(void) AtlInit(HINSTANCE hinst)
{
    _Module.Init(ObjectMap, hinst);
}

STDAPI_(void) AtlTerm()
{
    _Module.Term();
}

STDAPI AtlGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = _Module.GetClassObject(rclsid, riid, ppv);

#ifdef DEBUG
    //this object gets freed on DLL_PROCESS_DETACH, which happens AFTER the
    // mem leak check happens on exit.
    if (SUCCEEDED(hr))
    {
        _ASSERTE(_Module.m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = _Module.m_pObjMap;

        while (pEntry->pclsid != NULL)
        {
            if (InlineIsEqualGUID(rclsid, *pEntry->pclsid))
            {
                ASSERT(pEntry->pCF);
                break;
            }
            pEntry++;
        }
    }
#endif

    return hr;
}

STDAPI_(LONG) AtlGetLockCount()
{
    return _Module.GetLockCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\bands.cpp ===
#include "priv.h"
#include "util.h"
#include "resource.h"

#include "..\inc\bands.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\autoscrl.h ===
// stuff for doing auto scrolling
#define NUM_POINTS	3
typedef struct {	// asd
    int iNextSample;
    DWORD dwLastScroll;
    BOOL bFull;
    POINT pts[NUM_POINTS];
    DWORD dwTimes[NUM_POINTS];
} AUTO_SCROLL_DATA;

#define DAD_InitScrollData(pad) (pad)->bFull = FALSE, (pad)->iNextSample = 0, (pad)->dwLastScroll = 0
BOOL DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\bcw.cpp ===
/****************************************************************************
bcw.cpp

  Owner: Srinik
  Copyright (c) 1995 Microsoft Corporation
  
    This file contains code for BCW class which implements wrappers for IBindCtx
    and IRunningObjectTable. We use this object to trick the moniker binding
    code to create a new instance of the object (that the moniker is
    referring to) instead connecting to already running instance.
****************************************************************************/

// #include "hlmain.h"
#include "bcw.h"

ASSERTDATA

/****************************************************************************
Implementation of BCW methods.
****************************************************************************/

BCW::BCW(IBindCtx * pibc)
{
    m_pibc = pibc;
    pibc->AddRef();
    m_cObjRef = 1;
    DllAddRef();
}

BCW::~BCW()
{
    m_pibc->Release();
    DllRelease();
}

IBindCtx * BCW::Create(IBindCtx * pibc)
{
    BCW * pbcw = new BCW(pibc);
    
    if (pbcw == NULL)
        return NULL;
    
    if (! pbcw->m_ROT.FInitROTPointer())
    {
        delete pbcw;
        return NULL;
    }
    
    return pbcw;
}

STDMETHODIMP BCW::QueryInterface(REFIID riid, void **ppvObj)
{   
    if (ppvObj == NULL)
        return E_INVALIDARG;
    
    if (riid == IID_IUnknown || riid == IID_IBindCtx)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    ((IUnknown *) *ppvObj)->AddRef();
    return NOERROR; 
}

STDMETHODIMP_(ULONG) BCW::AddRef(void)
{   
    return ++m_cObjRef;
}


STDMETHODIMP_(ULONG) BCW::Release(void)
{
/* Decrement refcount, destroy object if refcount goes to zero.
    Return the new refcount. */
    if (!(--m_cObjRef))
    {
        delete this;
        return 0;
    }
    
    return m_cObjRef;
}


/****************************************************************************
Implementation of BCW_ROT methods.
****************************************************************************/

/****************************************************************************
BCW_ROT is the IRunningObjectTable imlementation of BCW_ROT.
****************************************************************************/

BCW_ROT::BCW_ROT()
{
    Debug(m_cRef = 0);
    m_piROT = NULL; 
}

BCW_ROT::~BCW_ROT()
{   
    if (m_piROT)
        m_piROT->Release();
}

BOOL_PTR BCW_ROT::FInitROTPointer(void)
{
    if (m_piROT == NULL)
    {
        if (GetRunningObjectTable(NULL/*reserved*/, &m_piROT) == NOERROR)
            m_piROT->AddRef();
    }
    
    return (BOOL_PTR) (m_piROT);
}


inline BCW * BCW_ROT::PBCW()
{
    return BACK_POINTER(this, m_ROT, BCW);
}

STDMETHODIMP BCW_ROT::QueryInterface(REFIID riid, void **ppvObj)
{
    if (riid == IID_IUnknown || riid == IID_IRunningObjectTable)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    ((IUnknown *) *ppvObj)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) BCW_ROT::AddRef(void)
{
    return PBCW()->AddRef();
}

STDMETHODIMP_(ULONG) BCW_ROT::Release(void)
{
    return PBCW()->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\bcwx.cpp ===
#include "priv.h"

#define ASSERTDATA

/* Macro to compute a back pointer to a containing class given a
   pointer to a member, the member name, and the containing class type.
   This generates no code because it results in a constant offset.
   Note: this is taken from mso96 dll code. */
#define BACK_POINTER(p, m, c) \
	((c *) (void *) (((char *) (void *) (p)) - (char *) (&((c *) 0)->m)))

#ifdef DEBUG
	#define Debug(e) e
	#define DebugElse(s, t)	s
#else
	#define Debug(e)
	#define DebugElse(s, t) t
#endif

#include "bcw.cpp"

IBindCtx * BCW_Create(IBindCtx* pibc)
{
    return BCW::Create(pibc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\bcw.h ===
/****************************************************************************
bcw.h

  Owner: Srinik
  Copyright (c) 1995 Microsoft Corporation
  
    This header file for BCW class which implements wrappers for IBindCtx 
    and IRunningObjectTable. We use this object to trick the moniker binding
    code to create a new instance of the object (that the moniker is 
    referring to) instead connecting to already running instance. 
****************************************************************************/

#ifndef BCW_H
#define BCW_H

/****************************************************************************
BCW_ROT is the IRunningObjectTable imlementation of BCW_ROT.
****************************************************************************/

class BCW_ROT: public IRunningObjectTable
{ 
    friend class BCW;
public:
    BCW_ROT(); 
    ~BCW_ROT();
    
private:
    BOOL_PTR FInitROTPointer(void);
    
private:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // *** IRunningObjectTable methods ***
    STDMETHODIMP Register(DWORD grfFlags, IUnknown *punkObject,
        IMoniker *pmkObjectName, DWORD *pdwRegister)
    {
        if (m_piROT == NULL)
            return E_FAIL;
        
        return m_piROT->Register(grfFlags, punkObject, pmkObjectName, pdwRegister);
    }
    
    STDMETHODIMP Revoke(DWORD dwRegister)
    {
        if (m_piROT == NULL)
            return E_FAIL;
        
        return m_piROT->Revoke(dwRegister);
    }
    
    STDMETHODIMP IsRunning(IMoniker *pmkObjectName)
    {
        // Trick the moniker binding code into thinking that the object is not 
        // running. This way it will try to create a new instance of the object.
        // REVIEW: we may want to check the pmkObjectName, and if is not the one
        // that we are concerned with,then we may want to delegate the call.
        return S_FALSE;
    }
    
    STDMETHODIMP GetObject(IMoniker *pmkObjectName,IUnknown **ppunkObject)
    {
        // Trick the moniker binding code into thinking that the object is not 
        // running. This way it will try to create a new instance of the object.
        // REVIEW: we may want to check the pmkObjectName, and if is not the one
        // that we are concerned with,then we may want to delegate the call.
        return MK_E_UNAVAILABLE;
    }
    
    STDMETHODIMP NoteChangeTime(DWORD dwRegister, FILETIME *pfiletime)
    {
        if  (m_piROT == NULL)
            return E_FAIL;
        
        return m_piROT->NoteChangeTime(dwRegister, pfiletime);
    }
    
    STDMETHODIMP GetTimeOfLastChange(IMoniker *pmkObjectName,  FILETIME *pfiletime)
    {
        if (m_piROT == NULL)
            return E_FAIL;
        
        return m_piROT->GetTimeOfLastChange(pmkObjectName, pfiletime);
    }
    
    STDMETHODIMP EnumRunning(IEnumMoniker **ppenumMoniker)
    {
        if (m_piROT == NULL)
            return E_FAIL;
        
        return m_piROT->EnumRunning(ppenumMoniker);
    }
    
private:
    /* Return back pointer to containing BCW object. */
    inline BCW* PBCW();
    IRunningObjectTable * m_piROT;
#ifdef DEBUG
    Debug(ULONG m_cRef); 
#endif
};


/****************************************************************************
Declaration of BCW. This class implements IBindCtx and IRunningObjectTable
This is class is used to manipulate the binding process, such that the 
moniker binding code will create a new instance of the object instead of 
binding to the existing instance
****************************************************************************/

class BCW: public IBindCtx
{ 
    friend class BCW_ROT;
    
public:
    BCW(IBindCtx * pibc); 
    ~BCW();
    
    static IBindCtx * Create(IBindCtx * pibc);
    
private:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // *** IBindCtx methods ***
    STDMETHODIMP RegisterObjectBound(IUnknown *punk)
    {   return m_pibc->RegisterObjectBound(punk); }
    
    STDMETHODIMP RevokeObjectBound(IUnknown *punk)
    {   return m_pibc->RevokeObjectBound(punk); }
    
    STDMETHODIMP ReleaseBoundObjects(void)
    {   return m_pibc->ReleaseBoundObjects(); }
    
    STDMETHODIMP SetBindOptions(BIND_OPTS *pbindopts)
    {   return m_pibc->SetBindOptions(pbindopts); }
    
    STDMETHODIMP GetBindOptions(BIND_OPTS *pbindopts)
    {   return m_pibc->GetBindOptions(pbindopts); }
    
    STDMETHODIMP GetRunningObjectTable(IRunningObjectTable **pprot)
    {   
        if (pprot == NULL)
            return E_INVALIDARG;
        
        *pprot = (IRunningObjectTable *) &m_ROT;
        ((IUnknown *) *pprot)->AddRef();
        return NOERROR;
    }
    
    STDMETHODIMP RegisterObjectParam(LPOLESTR pszKey, IUnknown *punk)
    {   return m_pibc->RegisterObjectParam(pszKey, punk); }
    
    STDMETHODIMP GetObjectParam(LPOLESTR pszKey, IUnknown **ppunk)
    {   return m_pibc->GetObjectParam(pszKey, ppunk); }
    
    STDMETHODIMP EnumObjectParam(IEnumString **ppenum)
    {   return m_pibc->EnumObjectParam(ppenum); }
    
    STDMETHODIMP RevokeObjectParam(LPOLESTR pszKey)
    {   return m_pibc->RevokeObjectParam(pszKey); }
    
private:
    BCW_ROT     m_ROT;      // IRunningObjectTable implementation
    DWORD       m_cObjRef;
    IBindCtx *  m_pibc;
};

#endif  // BCW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\basesb.h ===
#ifndef _BASESB2_H
#define _BASESB2_H

#include "iface.h"
#include "track.h"
#include "fldset.h"
#include <vervec.h>
#include <iethread.h>
#include <profsvc.h>
#include "browsext.h"
#include "airesize.h"

//  this is used to identify the top frame browsers dwBrowserIndex
#define BID_TOPFRAMEBROWSER   ((DWORD)-1)

void IECleanUpAutomationObject(void);

#define CBASEBROWSER CBaseBrowser2
class CBaseBrowser2 : public CAggregatedUnknown 
                   , public IShellBrowser
                   , public IBrowserService3
                   , public IServiceProvider
                   , public IOleCommandTarget
                   , public IOleContainer
                   , public IOleInPlaceUIWindow
                   , public IAdviseSink
                   , public IDropTarget
                   , public IInputObjectSite
                   , public IDocNavigate
                   , public IPersistHistory
                   , public IInternetSecurityMgrSite
                   , public IVersionHost
                   , public IProfferServiceImpl
                   , public ITravelLogClient
                   , public ITravelLogClient2
                   , public ITridentService2
                   , public IShellBrowserService
                   , public IInitViewLinkedWebOC
                   , public INotifyAppStart
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj) {return CAggregatedUnknown::QueryInterface(riid, ppvObj);};
    STDMETHODIMP_(ULONG) AddRef(void) { return CAggregatedUnknown::AddRef();};
    STDMETHODIMP_(ULONG) Release(void) { return CAggregatedUnknown::Release();};

    // IOleWindow
    STDMETHODIMP GetWindow(HWND * lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);
                                                                        
    // IShellBrowser (same as IOleInPlaceFrame)
    STDMETHODIMP InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHODIMP SetMenuSB(HMENU hmenuShared, HOLEMENU holemenu, HWND hwnd);
    STDMETHODIMP RemoveMenusSB(HMENU hmenuShared);
    STDMETHODIMP SetStatusTextSB(LPCOLESTR lpszStatusText);
    STDMETHODIMP EnableModelessSB(BOOL fEnable);
    STDMETHODIMP TranslateAcceleratorSB(LPMSG lpmsg, WORD wID);
    STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);
    STDMETHODIMP GetViewStateStream(DWORD grfMode, LPSTREAM  *ppStrm) {return E_NOTIMPL; };
    STDMETHODIMP GetControlWindow(UINT id, HWND * lphwnd);
    STDMETHODIMP SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    STDMETHODIMP QueryActiveShellView(struct IShellView ** ppshv);
    STDMETHODIMP OnViewWindowActive(struct IShellView * ppshv);
    STDMETHODIMP SetToolbarItems(LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags);

    // IOleInPlaceUIWindow (also IOleWindow)
    STDMETHODIMP GetBorder(LPRECT lprectBorder);
    STDMETHODIMP RequestBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IOleContainer
    STDMETHODIMP ParseDisplayName(IBindCtx  *pbc, LPOLESTR pszDisplayName, ULONG  *pchEaten, IMoniker  **ppmkOut);
    STDMETHODIMP EnumObjects(DWORD grfFlags, IEnumUnknown **ppenum);
    STDMETHODIMP LockContainer( BOOL fLock);

    // IBrowserService
    STDMETHODIMP GetParentSite(struct IOleInPlaceSite** ppipsite);
    STDMETHODIMP SetTitle(IShellView *psv, LPCWSTR pszName);
    STDMETHODIMP GetTitle(IShellView *psv, LPWSTR pszName, DWORD cchName);
    STDMETHODIMP GetOleObject(struct IOleObject** ppobjv);

    STDMETHODIMP GetTravelLog(ITravelLog **pptl);
    STDMETHODIMP ShowControlWindow(UINT id, BOOL fShow);
    STDMETHODIMP IsControlWindowShown(UINT id, BOOL *pfShown);
    STDMETHODIMP IEGetDisplayName(LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags);
    STDMETHODIMP IEParseDisplayName(UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut);
    STDMETHODIMP DisplayParseError(HRESULT hres, LPCWSTR pwszPath);
    STDMETHODIMP NavigateToPidl(LPCITEMIDLIST pidl, DWORD grfHLNF);
    STDMETHODIMP SetNavigateState(BNSTATE bnstate);
    STDMETHODIMP GetNavigateState(BNSTATE *pbnstate);
    STDMETHODIMP UpdateWindowList(void);
    STDMETHODIMP UpdateBackForwardState(void);
    STDMETHODIMP NotifyRedirect(IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse);
    STDMETHODIMP SetFlags(DWORD dwFlags, DWORD dwFlagMask);
    STDMETHODIMP GetFlags(DWORD *pdwFlags);
    STDMETHODIMP CanNavigateNow(void);
    STDMETHODIMP GetPidl(LPITEMIDLIST *ppidl);
    STDMETHODIMP SetReferrer(LPITEMIDLIST pidl);
    STDMETHODIMP_(DWORD) GetBrowserIndex(void);
    STDMETHODIMP GetBrowserByIndex(DWORD dwID, IUnknown **ppunk);
    STDMETHODIMP GetHistoryObject(IOleObject **ppole, IStream **ppstm, IBindCtx **ppbc);
    STDMETHODIMP SetHistoryObject(IOleObject *pole, BOOL fIsLocalAnchor);
    STDMETHODIMP CacheOLEServer(IOleObject *pole);
    STDMETHODIMP GetSetCodePage(VARIANT* pvarIn, VARIANT* pvarOut);
    STDMETHODIMP OnHttpEquiv(IShellView* psv, BOOL fDone, VARIANT *pvarargIn, VARIANT *pvarargOut);
    STDMETHODIMP GetPalette( HPALETTE * hpal );
    STDMETHODIMP RegisterWindow(BOOL fUnregister, int swc) {return E_NOTIMPL;}
    STDMETHODIMP_(LRESULT) WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP OnSize(WPARAM wParam);
    STDMETHODIMP OnCreate(LPCREATESTRUCT pcs);
    STDMETHODIMP_(LRESULT) OnCommand(WPARAM wParam, LPARAM lParam);
    STDMETHODIMP OnDestroy();
    STDMETHODIMP ReleaseShellView();
    STDMETHODIMP ActivatePendingView();
    STDMETHODIMP_(LRESULT) OnNotify(NMHDR * pnm);
    STDMETHODIMP OnSetFocus();
    STDMETHODIMP OnFrameWindowActivateBS(BOOL fActive);
    STDMETHODIMP SetTopBrowser();
    STDMETHODIMP UpdateSecureLockIcon(int eSecureLock);
    STDMETHODIMP Offline(int iCmd);
    STDMETHODIMP SetActivateState(UINT uActivate) { _bbd._uActivateState = uActivate; return S_OK;};
    STDMETHODIMP AllowViewResize(BOOL f) { HRESULT hres = _fDontResizeView ? S_FALSE : S_OK; _fDontResizeView = !BOOLIFY(f); return hres;};
    STDMETHODIMP InitializeDownloadManager();
    STDMETHODIMP InitializeTransitionSite();
    STDMETHODIMP CreateViewWindow(IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd);
    STDMETHODIMP GetFolderSetData(struct tagFolderSetData*) { ASSERT(0); return E_NOTIMPL;};
    STDMETHODIMP CreateBrowserPropSheetExt(REFIID, void **) { ASSERT(0); return E_NOTIMPL;};
    STDMETHODIMP GetBaseBrowserData( LPCBASEBROWSERDATA* ppbd ) { *ppbd = &_bbd; return S_OK; };
    STDMETHODIMP_(LPBASEBROWSERDATA) PutBaseBrowserData() { return &_bbd; };

    STDMETHODIMP SetAsDefFolderSettings() { TraceMsg(TF_ERROR, "CBaseBrowser2::SetAsDefFolderSettings called, returned E_NOTIMPL"); return E_NOTIMPL;};
    STDMETHODIMP GetViewRect(RECT* prc);
    STDMETHODIMP GetViewWindow(HWND * phwndView);
    STDMETHODIMP InitializeTravelLog(ITravelLog* ptl, DWORD dw);
    STDMETHODIMP _Initialize(HWND hwnd, IUnknown *pauto);

    // ITravelLogClient
    STDMETHODIMP FindWindowByIndex(DWORD dwID, IUnknown ** ppunk);
    STDMETHODIMP GetWindowData(LPWINDOWDATA pWinData);
    STDMETHODIMP LoadHistoryPosition(LPOLESTR pszUrlLocation, DWORD dwCookie);

    // ITridentService
    STDMETHODIMP FireBeforeNavigate2(IDispatch * pDispatch,
                                     LPCTSTR     lpszUrl,
                                     DWORD       dwFlags,
                                     LPCTSTR     lpszFrameName,
                                     LPBYTE      pPostData,
                                     DWORD       cbPostData,
                                     LPCTSTR     lpszHeaders,
                                     BOOL        fPlayNavSound,
                                     BOOL      * pfCancel);
    STDMETHODIMP FireNavigateComplete2(IHTMLWindow2 * pHTMLWindow2,
                                       DWORD          dwFlags);
        
    STDMETHODIMP FireDownloadBegin();
    STDMETHODIMP FireDownloadComplete();
    STDMETHODIMP FireDocumentComplete(IHTMLWindow2 * pHTMLWindow2,
                                      DWORD          dwFlags);

    STDMETHODIMP UpdateDesktopComponent(IHTMLWindow2 * pHTMLWindow);
    STDMETHODIMP GetPendingUrl(BSTR * pbstrPendingUrl);
    STDMETHODIMP ActiveElementChanged(IHTMLElement * pHTMLElement);
    STDMETHODIMP GetUrlSearchComponent(BSTR * pbstrSearch);
    STDMETHODIMP IsErrorUrl(LPCTSTR lpszUrl, BOOL *pfIsError);

    STDMETHOD(FireNavigateError)(IHTMLWindow2 * pHTMLWindow2,
                                 DWORD  dwStatusCode,
                                 BOOL * pfCancel)
    {
        ASSERT(0);
        return E_NOTIMPL;
    }

    // ITridentService2
    //
    STDMETHODIMP AttachMyPics(void *pDoc2, void **ppMyPics);
    STDMETHODIMP_(BOOL) ReleaseMyPics(void *pMyPics);
    STDMETHODIMP InitAutoImageResize();
    STDMETHODIMP UnInitAutoImageResize();
    STDMETHODIMP IsGalleryMeta(BOOL bFlag, void *pMyPics);
    STDMETHODIMP EmailPicture(BSTR bstrURL);

    STDMETHODIMP FireNavigateError(IHTMLWindow2 * pHTMLWindow2, 
                                   BSTR           bstrURL,
                                   BSTR           bstrTargetFrameName,
                                   DWORD          dwStatusCode,
                                   BOOL         * pfCancel);

    STDMETHODIMP FirePrintTemplateEvent(IHTMLWindow2 * pHTMLWindow2, DISPID dispidPrintEvent);
    STDMETHODIMP FireUpdatePageStatus(IHTMLWindow2 * pHTMLWindow2, DWORD nPage, BOOL fDone);
    STDMETHODIMP FirePrivacyImpactedStateChange(BOOL bPrivacyImpacted);

    STDMETHODIMP_(UINT) _get_itbLastFocus() { ASSERT(0); return ITB_VIEW; };
    STDMETHODIMP _put_itbLastFocus(UINT itbLastFocus) { return E_NOTIMPL; };

    // IShellBrowserService
    //
    STDMETHODIMP GetPropertyBag(DWORD dwFlags, REFIID riid, void** ppv) {ASSERT(0); return E_NOTIMPL;}
    // see _UIActivateView, below
    
    // BEGIN REVIEW:  review names and need of each.  
    // 
    // this first set could be basebrowser only members.  no one overrides
    STDMETHODIMP _CancelPendingNavigationAsync() ;
    STDMETHODIMP _CancelPendingView() ;
    STDMETHODIMP _MaySaveChanges() ; 
    STDMETHODIMP _PauseOrResumeView( BOOL fPaused) ;
    STDMETHODIMP _DisableModeless() ;
    
    // rethink these... are all of these necessary?
    STDMETHODIMP _NavigateToPidl( LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags);
    STDMETHODIMP _TryShell2Rename( IShellView* psv, LPCITEMIDLIST pidlNew);
    STDMETHODIMP _SwitchActivationNow( );

    
    // this belongs with the toolbar set.
    STDMETHODIMP _ExecChildren(IUnknown *punkBar, BOOL fBroadcast,
                              const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                              VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    STDMETHODIMP _SendChildren(HWND hwndBar, BOOL fBroadcast,
        UINT uMsg, WPARAM wParam, LPARAM lParam);

    STDMETHODIMP _GetViewBorderRect(RECT* prc);
    STDMETHODIMP _UpdateViewRectSize();
    STDMETHODIMP _ResizeNextBorder(UINT itb);
    STDMETHODIMP _ResizeView();

    // Notes: Only CDesktopBrowser may sublcass this.
    STDMETHODIMP _GetEffectiveClientArea(LPRECT lprectBorder, HMONITOR hmon);

    //END REVIEW:

    // CDesktopBrowser accesses CCommonBrowser implementations of these:
    STDMETHODIMP_(IStream*) v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName) { ASSERT(FALSE); return NULL; }
    STDMETHODIMP_(LRESULT) ForwardViewMsg(UINT uMsg, WPARAM wParam, LPARAM lParam) { ASSERT(FALSE); return 0; }
    STDMETHODIMP SetAcceleratorMenu(HACCEL hacc) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP_(int) _GetToolbarCount(THIS) { ASSERT(FALSE); return 0; }
    STDMETHODIMP_(LPTOOLBARITEM) _GetToolbarItem(THIS_ int itb) { ASSERT(FALSE); return NULL; }
    STDMETHODIMP _SaveToolbars(IStream* pstm) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP _LoadToolbars(IStream* pstm) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP _CloseAndReleaseToolbars(BOOL fClose) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP v_MayGetNextToolbarFocus(LPMSG lpMsg, UINT itbNext, int citb, LPTOOLBARITEM * pptbi, HWND * phwnd) { ASSERT(FALSE); return E_NOTIMPL; };
    STDMETHODIMP _ResizeNextBorderHelper(UINT itb, BOOL bUseHmonitor) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP_(UINT) _FindTBar(IUnknown* punkSrc) { ASSERT(FALSE); return (UINT)-1; };
    STDMETHODIMP _SetFocus(LPTOOLBARITEM ptbi, HWND hwnd, LPMSG lpMsg) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP v_MayTranslateAccelerator(MSG* pmsg) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP _GetBorderDWHelper(IUnknown* punkSrc, LPRECT lprectBorder, BOOL bUseHmonitor) { ASSERT(FALSE); return E_NOTIMPL; }

    // CShellBrowser overrides this.
    STDMETHODIMP v_CheckZoneCrossing(LPCITEMIDLIST pidl) {return S_OK;};

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void ** ppvObj);

    // IAdviseSink
    STDMETHODIMP_(void) OnDataChange(FORMATETC *, STGMEDIUM *);
    STDMETHODIMP_(void) OnViewChange(DWORD dwAspect, LONG lindex);
    STDMETHODIMP_(void) OnRename(IMoniker *);
    STDMETHODIMP_(void) OnSave();
    STDMETHODIMP_(void) OnClose();

    // IDropTarget ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IInputObjectSite
    STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);

    // IDocNavigate
    STDMETHODIMP OnReadyStateChange(IShellView* psvSource, DWORD dwReadyState);
    STDMETHODIMP get_ReadyState(DWORD * pdwReadyState);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid);

    // IPersistHistory
    STDMETHODIMP LoadHistory(IStream *pStream, IBindCtx *pbc);
    STDMETHODIMP SaveHistory(IStream *pStream);
    STDMETHODIMP SetPositionCookie(DWORD dwPositionCookie);
    STDMETHODIMP GetPositionCookie(DWORD *pdwPositioncookie);

    // IInternetSecurityMgrSite
    // STDMETHODIMP GetWindow(HWND * lphwnd) { return IOleWindow::GetWindow(lphwnd); }
    STDMETHODIMP EnableModeless(BOOL fEnable) { return EnableModelessSB(fEnable); }

    // IVersionHost
    STDMETHODIMP QueryUseLocalVersionVector( BOOL *fUseLocal);
    STDMETHODIMP QueryVersionVector( IVersionVector *pVersion);

    // ITravelLogClient2
    STDMETHODIMP GetDummyWindowData(LPWSTR pszUrl, LPWSTR pszTitle, LPWINDOWDATA pWinData);

    // This is the QueryInterface the aggregator implements
    virtual HRESULT v_InternalQueryInterface(REFIID riid, void ** ppvObj);

    // IInitViewLinkedWebOC methods

    STDMETHODIMP SetViewLinkedWebOC(BOOL bValue) 
    {
        _fIsViewLinkedWebOC = bValue;
        return S_OK;
    };

    STDMETHODIMP IsViewLinkedWebOC(BOOL* pbValue) 
    {
        ASSERT(pbValue);

        *pbValue = _fIsViewLinkedWebOC;
        return S_OK;
    };

    STDMETHODIMP SetViewLinkedWebOCFrame(IDispatch * pDisp)
    {
        HRESULT hr = E_FAIL;

        ASSERT(pDisp);

        ATOMICRELEASE(_pDispViewLinkedWebOCFrame);

        hr = IUnknown_QueryService(pDisp,
                                   SID_SWebBrowserApp,
                                   IID_PPV_ARG(IWebBrowser2, &_pDispViewLinkedWebOCFrame));

        if (FAILED(hr))
        {
            _fIsViewLinkedWebOC = FALSE;   
        }

        return hr;
    };

    STDMETHODIMP GetViewLinkedWebOCFrame(IDispatch** ppDisp)
    {
        ASSERT(_fIsViewLinkedWebOC);
        ASSERT(_pDispViewLinkedWebOCFrame);
        ASSERT(ppDisp);

        *ppDisp = _pDispViewLinkedWebOCFrame;
        _pDispViewLinkedWebOCFrame->AddRef();

        return S_OK;
    };

    STDMETHODIMP SetFrameName(BSTR bstrFrameName);

    // INotifyAppStart

    STDMETHODIMP AppStarting(void);
    STDMETHODIMP AppStarted(void);

    static BSTR GetHTMLWindowUrl(IHTMLWindow2 * pHTMLWindow);
    static LPITEMIDLIST PidlFromUrl(BSTR bstrUrl);
    
protected:

    // "protected" so derived classes can construct/destruct us too
    CBaseBrowser2(IUnknown* punkAgg);   
    virtual ~CBaseBrowser2();
    
    friend HRESULT CBaseBrowser2_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

    // topmost CBaseBrowser2 in a frameset (IE3/AOL/CIS/VB)
    virtual void        _OnNavigateComplete(LPCITEMIDLIST pidl, DWORD grfHLNF);
    virtual HRESULT     _CheckZoneCrossing(LPCITEMIDLIST pidl);
    virtual STDMETHODIMP _PositionViewWindow(HWND hwnd, LPRECT prc);
    void                _PositionViewWindowHelper(HWND hwnd, LPRECT prc);
    virtual LRESULT     _DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void        _ViewChange(DWORD dwAspect, LONG lindex);
    virtual void        _UpdateBackForwardState();
    virtual BOOL        v_OnSetCursor(LPARAM lParam);
    virtual STDMETHODIMP v_ShowHideChildWindows(BOOL fChildOnly);
    virtual void        v_PropagateMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fSend);
    virtual HRESULT     _ShowBlankPage(LPCTSTR pszAboutUrl, LPCITEMIDLIST pidlIntended);
    
    // ViewStateStream related
    
    HRESULT     _CheckInCacheIfOffline(LPCITEMIDLIST pidl, BOOL fIsAPost);
    void        _CreateShortcutOnDesktop(IUnknown *pUnk, BOOL fUI);
    void        _AddToFavorites(LPCITEMIDLIST pidl, LPCTSTR pszTitle, BOOL fDisplayUI);

    // to avoid having to pass hwnd on every message to WndProc, set it once
    void        _SetWindow(HWND hwnd) { _bbd._hwnd = hwnd; }
    void        _DoOptions(VARIANT* pvar);
    LRESULT     _OnGoto(void);
    void        _NavigateToPidlAsync(LPITEMIDLIST pidl, DWORD dwSBSP, BOOL fDontCallCancel = FALSE);
    BOOL        _CanNavigate(void);

    // inline so that lego will get the right opt.
    void        _PreActivatePendingViewAsync(void) 
    {
        _StopAsyncOperation();
    };

    BOOL        _ActivatePendingViewAsync(void);
    void        _FreeQueuedPidl(LPITEMIDLIST* ppidl);
    void        _StopAsyncOperation(void);
    void        _MayUnblockAsyncOperation();
    BOOL        _PostAsyncOperation(UINT uAction);
    LRESULT     _SendAsyncOperation(UINT uAction);
    void        _SendAsyncNavigationMsg(VARIANTARG *pvarargIn);
    HRESULT     _OnCoCreateDocument(VARIANTARG *pvarargOut);
    void        _NotifyCommandStateChange();

    BOOL        _IsViewMSHTML(IShellView * psv);

    BOOL        _ActivateView(BSTR         bstrUrl,
                              LPITEMIDLIST pidl,
                              DWORD        dwFlags,
                              BOOL         fIsErrorUrl);

    HRESULT     _GetWebBrowserForEvt(IDispatch     * pDispatch,
                                     IWebBrowser2 ** ppWebBrowser);

    void        _Exec_psbMixedZone();

#ifdef TEST_AMBIENTS
    BOOL        _LocalOffline(int iCmd);
    BOOL        _LocalSilent(int iCmd);
#endif // TEST_AMBIENTS
    
    #define NAVTYPE_ShellNavigate   0x01
    #define NAVTYPE_PageIsChanging  0x02
    #define NAVTYPE_SiteIsChanging  0x04

    void         _EnableStop(BOOL fEnable);
    LRESULT      _OnInitMenuPopup(HMENU hmenuPopup, int nIndex, BOOL fSystemMenu);
    HRESULT      _updateNavigationUI();
    HRESULT      _setDescendentNavigate(VARIANTARG *pvarargIn);
    void         _UpdateBrowserState(LPCITEMIDLIST pidl);
    void         _UpdateDocHostState(LPITEMIDLIST pidl, BOOL fIsErrorUrl) const;
    HRESULT      _FireBeforeNavigateEvent(LPCITEMIDLIST pidl, BOOL* pfUseCache);
    LPITEMIDLIST _GetPidlForDisplay(BSTR bstrUrl, BOOL * pfIsErrorUrl = NULL);

    HRESULT      _OpenNewFrame(LPITEMIDLIST pidlNew, UINT wFlags);
    STDMETHODIMP _UIActivateView(UINT uState);
    HRESULT      _CancelPendingNavigation(BOOL fDontReleaseState = FALSE);
    void         _StopCurrentView(void);

    void         _MayTrackClickStream(LPITEMIDLIST pidlThis);        // (peihwal)

    STDMETHODIMP _OnFocusChange(UINT itb);

    void         _RegisterAsDropTarget();
    void         _UnregisterAsDropTarget();

    HRESULT     _InitDocHost(IWebBrowser2 * pWebBrowser);

    enum BrowserPaletteType
    {
        BPT_DeferPaletteSupport = 0,    // we don't think we own the palette
        BPT_UnknownDisplay,             // need to decide if we need a palette
        BPT_DisplayViewChanged,         // BPT_UnknownDisplay handling notify
        BPT_UnknownPalette,             // need to decide what palette to use
        BPT_PaletteViewChanged,         // BPT_UnknownPalette handling notify
        BPT_Normal,                     // handle WM_QUERYNEWPALETTE ourselves
        BPT_ShellView,                  // forward WM_QUERYNEWPALETTE to view
        BPT_NotPalettized               // not a palettized display, do nothing
    };
    
    void            _ColorsDirty(BrowserPaletteType bptNew);
    void            _DisplayChanged(WPARAM wParam, LPARAM lParam);
    HRESULT         _UpdateBrowserPaletteInPlace(LOGPALETTE *plp);
    void            _RealizeBrowserPalette(BOOL fBackground);
    virtual void    _PaletteChanged(WPARAM wParam, LPARAM lParam);
    BOOL            _QueryNewPalette();

    void            _DLMDestroy(void);
    void            _DLMUpdate(MSOCMD* prgCmd);
    void            _DLMRegister(IUnknown* punk);

    void            CreateNewSyncShellView( void );

    void            _UpdateTravelLog(BOOL fForceUpdate = FALSE);

    virtual BOOL    _HeyMoe_IsWiseGuy(void) {return FALSE;}

    void            _ShowIEHardNavWarning();
    BOOL            _CanShowModalDialogNow();

    IBrowserService2*    _pbsOuter;
    IBrowserService3*    _pbsOuter3;
    IShellBrowser*       _psbOuter;
    IServiceProvider*    _pspOuter;
    IDockingWindowSite*  _pdwsOuter;
    // The following are intercepted by CCommonBrowser, but we don't call 'em
    //IOleCommandTarget* _pctOuter;
    //IInputObjectSite*  _piosOuter;

    BASEBROWSERDATA _bbd;
    IUnknown *_pauto;

    BrowserPaletteType  _bptBrowser;
    HPALETTE            _hpalBrowser;

    IViewObject *_pvo;  // view object implementation on the shell view
    UINT  _cRefUIActivateSV;

    DWORD  _dwBrowserIndex;
    DWORD       _dwReadyState;

    DWORD       _dwReadyStateCur;
    LPWSTR      _pszTitleCur;
    
    IDropTarget * _pdtView; // Pointer to _bbd._psv's IDropTarget interface
    

    IOleObject * _poleHistory;
    IStream    * _pstmHistory;
    IBindCtx   * _pbcHistory;
    
    IHTMLDocument2  * _pHTMLDocument;
    IPersistHistory * _pphHistory;

    IOleInPlaceActiveObject *_pact;     // for UIWindow

    IClassFactory* _pcfHTML;            // cached/locked class factory

    
    DWORD       _dwReadyStatePending;
    LPWSTR      _pszTitlePending;
    DWORD       _grfHLNFPending;
    HDPA        _hdpaDLM;           // downloading object (for DLM)
    BOOL        _cp;                // current codepage

    //
    // NOTES: Currently, we support only one pending navigation.
    //  If we want to support queued navigation, we need to turn
    //  following two variables into a queue. (SatoNa)
    //
    DWORD       _uActionQueued;       // queued action
    LPITEMIDLIST _pidlQueued;         // pidl to go asynchronously
    DWORD       _dwSBSPQueued;        // grfHLNF to go asynchronously

    UINT        _cRefCannotNavigate;  // Increment when we can navigate

    RECT _rcBorderDoc;                  // for UIWindow
    DWORD _dwStartingAppTick;

    BITBOOL     _fDontResizeView : 1; // Don't resize _hwndView
    BITBOOL     _fNavigate:1;       // are we navigating?
    BITBOOL     _fDescendentNavigate:1; // are our descendents navigating?
    BITBOOL     _fDownloadSet:1;        // did we invoke download animation ?
    BITBOOL     _fNoDragDrop:1;          // TRUE iff we want to register for drops
    BITBOOL     _fRegisteredDragDrop:1;  // TRUE iff we have registered for drops
    BITBOOL     _fNavigatedToBlank: 1;  // Has called _ShowBlankPage once.
    BITBOOL     _fAsyncNavigate:1; // Ignore sync-hack-bug-fix
    BITBOOL     _fPausedByParent :1;    // Interaction paused by parent
    BITBOOL     _fDontAddTravelEntry:1;
    BITBOOL     _fIsLocalAnchor:1;
    BITBOOL     _fGeneratedPage:1;      //  trident told us that the page is generated.
    BITBOOL     _fOwnsPalette:1;        // does the browser own the palette ? (did we get QueryNewPalette ..)
    BITBOOL     _fUsesPaletteCommands : 1; // if we are using a separate communication with trident for palette commands
    BITBOOL     _fCreateViewWindowPending:1;
    BITBOOL     _fReleasingShellView:1; 
    BITBOOL     _fDeferredUIDeactivate:1;
    BITBOOL     _fDeferredSelfDestruction:1;
    BITBOOL     _fActive:1;  // remember if the frame is active or not (WM_ACTIVATE)
    BITBOOL     _fUIActivateOnActive:1; // TRUE iff we have a bending uiactivate
    BITBOOL     _fInQueryStatus:1;
    BITBOOL     _fCheckedDesktopComponentName:1;
    BITBOOL     _fInDestroy:1;            // being destroyed
    BITBOOL     _fDontUpdateTravelLog:1;
    BITBOOL     _fHtmlNavCanceled:1;
    BITBOOL     _fDontShowNavCancelPage:1;

    BITBOOL     _fHadBeforeNavigate   :1;
    BITBOOL     _fHadNavigateComplete :1;
    BITBOOL     _fInvokeDefBrowserOnNewWindow:1;

    enum DOCFLAGS
    {
        DOCFLAG_DOCCANNAVIGATE         = 0x00000001,  // The document knows how to navigate
        DOCFLAG_NAVIGATEFROMDOC        = 0x00000002,  // Document called Navigate
        DOCFLAG_SETNAVIGATABLECODEPAGE = 0x00000004,  // GetBindInfo should call NavigatableCodepage
    };

    DWORD _dwDocFlags;
    
    // for IDropTarget
    
    DWORD _dwDropEffect;

#ifdef DEBUG
    BOOL        _fProcessed_WM_CLOSE; // TRUE iff WM_CLOSE processed
    BOOL        _fMightBeShuttingDown; // TRUE if we might be shutting down (recieved a WM_QUERYENDSESSION || (WM_ENDSESSION w/ wParam == TRUE))
#endif

    // friend   CIEFrameAuto;
    interface IShellHTMLWindowSupport   *_phtmlWS;  
    
    IUrlHistoryStg *_pIUrlHistoryStg;   // pointer to url history storage object
    
    ITravelLogStg *_pITravelLogStg;     // exposed travel log object

    ITargetFrame2 *_ptfrm;
    
    //  Cached History IShellFolder
    IUnknown *_punkSFHistory;

    //  what SSL icon to show
    int     _eSecureLockIconPending;
    
    // Support for OLECMDID_HTTPEQUIV (Client Pull, PICS, etc)

#ifdef NEVER
    HRESULT _HandleHttpEquiv (VARIANT *pvarargIn, VARIANT *pvarargOut, BOOL fDone);
    HRESULT _KillRefreshTimer( void );
    VOID    _OnRefreshTimer(void);
    void    _StartRefreshTimer(void);

    // equiv handlers we know about
    friend HRESULT _HandleRefresh (HWND hwnd, WCHAR *pwz, WCHAR *pwzColon, CBaseBrowser2 *pbb, BOOL fDone, LPARAM lParam);
#endif

#ifdef NEVER
    friend VOID CALLBACK _RefreshTimerProc (HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    // Client Pull values
    WCHAR *_pwzRefreshURL;
    int    _iRefreshTimeout;
    BOOL   _iRefreshTimeoutSet:1;
    INT_PTR _iRefreshTimerID;
#endif

#ifdef MESSAGEFILTER
    // COM Message filter used to help dispatch TIMER messages during OLE operations.
    LPMESSAGEFILTER _lpMF;
#endif

    CUrlTrackingStg * _ptracking;

    CAutoImageResize *_pAIResize;

    // _fTopBrowser vs. _fNoTopLevelBrowser:
    // _fTopBrowser: True means we are the top most browser, or a top most browser does not exist and we are acting like the top most browser.
    //               In the latter case, the immediate childern of our host will also act like top most browsers.
    // _fNoTopLevelBrowser: This means that the top most item isn't one of our shell browsers, so it's immediate browser child
    //               will act like a top most browser.
    //
    //     In normal cases, a shell browser (CShellBrowser, CDesktopBrowser, ...) is a top most browser
    //   with TRUE==_fTopBrowser and FALSE==_fNoTopLevelBrowser.  It can have subframes that will have
    //   FALSE==_fTopBrowser and FALSE==_fNoTopLevelBrowser.
    //
    //   The only time _fNoTopLevelBrowser is TRUE is if some other object (like Athena) hosts MSHTML directly
    //   which will prevent some shell browser from being top most.  Since the HTML can have several frames,
    //   each will have TRUE==_fTopBrowser, so _fNoTopLevelBrowser will be set to TRUE to distinguish this case.
    BOOL        _fTopBrowser :1;    // Should only be set via the _SetTopBrowser method
    BOOL        _fNoTopLevelBrowser :1;         // TRUE iff the toplevel is a non-shell browser (Athena).  Shell browsers include CDesktopBrowser, CShellBrowser, ...
    BOOL        _fHaveOldStatusText :1;
    
    WCHAR       _szwOldStatusText[MAX_PATH];

    FOLDERSETDATABASE _fldBase; // cache viewset results in here (used when navigating)

    // Manages extended toolbar buttons and tools menu extensions for IE
    IToolbarExt* _pToolbarExt;

    LPITEMIDLIST _pidlBeforeNavigateEvent;         // pidl refered to in BeforeNavigate2 event

    // ViewLinkedWebOC variables

    BOOL           _fIsViewLinkedWebOC;                // TRUE if an instance of the WebOC is a ViewLinked
    IWebBrowser2*  _pDispViewLinkedWebOCFrame;         // The pDisp of the Frame of a ViewLinkedWebOC.
    BOOL           _fHadFirstBeforeNavigate;           // TRUE if we have already skipped over the first ViewLinkedWebOC's 
                                                       // BeforeNavigateEvent.

    TCHAR _szViewLinkedWebOCFrameName[INTERNET_MAX_URL_LENGTH+1];

public:

    // handling for plugUI shutdown
    // need the hwnd for the lang change modal property sheet
    static HDPA         s_hdpaOptionsHwnd;

    static void         _SyncDPA();
    static int CALLBACK _OptionsPropSheetCallback(HWND hwndDlg, UINT uMsg, LPARAM lParam);

private:
    HRESULT _AddFolderOptionsSheets(DWORD dwReserved, LPFNADDPROPSHEETPAGE pfnAddPropSheetPage, LPPROPSHEETHEADER ppsh);
    HRESULT _AddInternetOptionsSheets(DWORD dwReserved, LPFNADDPROPSHEETPAGE pfnAddPropSheetPage, LPPROPSHEETHEADER ppsh);
    HRESULT _ReplaceWithGoHome(LPCITEMIDLIST * ppidl, LPITEMIDLIST * ppidlFree);

    // this is private!  it should only be called by _NavigateToPidl

    HRESULT     _CreateNewShellViewPidl(LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD fSBSP);
    HRESULT     _CreateNewShellView(IShellFolder* psf, LPCITEMIDLIST pidl, DWORD grfHLNF);
    HRESULT     _DismissFindDialog();

    // Privacy state
    HRESULT     _UpdatePrivacyIcon(BOOL fSetNewState, BOOL fNewState);
};

HRESULT _DisplayParseError(HWND hwnd, HRESULT hres, LPCWSTR pwszPath);

#endif // _BASESB2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\basesb.cpp ===
#include "priv.h"

#include <mluisupp.h>

// stuff that should be turned off while in here, but on when 
// it goes to commonsb or shbrows2.cpp
#define IN_BASESB2

#ifdef IN_BASESB2
#define _fFullScreen FALSE
#endif

#include "sccls.h"

#include <idhidden.h>
#include "basesb.h"
#include "iedde.h"
#include "bindcb.h"
#include "resource.h"
#include "security.h"
#include <urlmon.h>
#include "favorite.h"
#include "uemapp.h"
#include <varutil.h>
#include "interned.h" // IHTMLPrivateWindow
#ifdef FEATURE_PICS
#include <ratings.h>
#include <ratingsp.h>
#endif
#include "msiehost.h"

#include "dhuihand.h"
#include "mypics.h"
#include "airesize.h"

#define DM_ACCELERATOR      0
#define DM_WEBCHECKDRT      0
#define DM_COCREATEHTML     0
#define DM_CACHEOLESERVER   0
#define DM_DOCCP            0
#define DM_PICS             0
#define DM_SSL              0
#define DM_MISC             DM_TRACE    // misc/tmp

// get at defs to run a privacy dialog box
#include "privacyui.hpp"

//
//  Remove this #include by defining _bbd._pauto as IWebBrowserApp, just like
//  Explorer.exe.
//
#include "hlframe.h"

extern IUnknown* ClassHolder_Create(const CLSID* pclsid);
extern HRESULT VariantClearLazy(VARIANTARG *pvarg);


#define WMC_ASYNCOPERATION      (WMC_RESERVED_FIRST + 0x0000)

#define ISSPACE(ch) (((ch) == 32) || ((unsigned)((ch) - 9)) <= 13 - 9)

#define IDT_STARTING_APP_TIMER  9001        // trying to pick a unique number... (THIS IS BOGUS! FIX THIS!)
#define STARTING_APP_DURATION   2500

UINT g_uMsgFileOpened = (UINT)-1;         // Registered window message for file opens

// _uActionQueued of WMC_ACYNCOPERATION specifies the operation.
#define ASYNCOP_NIL                 0
#define ASYNCOP_GOTO                1
#define ASYNCOP_ACTIVATEPENDING     2
#define ASYNCOP_CANCELNAVIGATION    3

void IEInitializeClassFactoryObject(IUnknown* punkAuto);
BOOL ParseRefreshContent(LPWSTR pwzContent,
    UINT * puiDelay, LPWSTR pwzUrlBuf, UINT cchUrlBuf);

#define VALIDATEPENDINGSTATE() ASSERT((_bbd._psvPending && _bbd._psfPending) || (!_bbd._psvPending && !_bbd._psfPending))

#define DM_HTTPEQUIV        TF_SHDNAVIGATE
#define DM_NAV              TF_SHDNAVIGATE
#define DM_ZONE             TF_SHDNAVIGATE
#define DM_IEDDE            DM_TRACE
#define DM_CANCELMODE       0
#define DM_UIWINDOW         0
#define DM_ENABLEMODELESS   TF_SHDNAVIGATE
#define DM_EXPLORERMENU     0
#define DM_BACKFORWARD      0
#define DM_PROTOCOL         0
#define DM_ITBAR            0
#define DM_STARTUP          0
#define DM_AUTOLIFE         0
#define DM_PALETTE          0
#define DM_PERSIST          0       // trace IPS::Load, ::Save, etc.
#define DM_VIEWSTREAM       DM_TRACE
#define DM_FOCUS            0
#define DM_FOCUS2           0           // like DM_FOCUS, but verbose

// these two MUST be in order because we peek them together

STDAPI SafeGetItemObject(IShellView *psv, UINT uItem, REFIID riid, void **ppv);
extern HRESULT TargetQueryService(IUnknown *punk, REFIID riid, void **ppvObj);
HRESULT CreateTravelLog(ITravelLog **pptl);
HRESULT CreatePublicTravelLog(IBrowserService *pbs, ITravelLogEx *ptlx, ITravelLogStg **pptlstg);

#ifdef MESSAGEFILTER
/*
 * CMsgFilter - implementation of IMessageFilter
 *
 * Used to help distribute WM_TIMER messages during OLE operations when 
 * we are busy.  If we don't install the CoRegisterMessageFilter
 * then OLE can PeekMessage(PM_NOREMOVE) the timers such that they pile up
 * and fill the message queue.
 *
 */
class CMsgFilter : public IMessageFilter {
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj)
    {
        // This interface doesn't get QI'ed.
        ASSERT(FALSE);
        return E_NOINTERFACE;
    };
    STDMETHODIMP_(ULONG) AddRef(void)    {   return ++_cRef; };
    STDMETHODIMP_(ULONG) Release(void)   {   ASSERT(_cRef > 0);
                                                _cRef--;
                                                if (_cRef > 0)
                                                    return _cRef;

                                                delete this;
                                                return 0;
                                            };

    // *** IMessageFilter specific methods ***
    STDMETHODIMP_(DWORD) HandleInComingCall(
        IN DWORD dwCallType,
        IN HTASK htaskCaller,
        IN DWORD dwTickCount,
        IN LPINTERFACEINFO lpInterfaceInfo)
    {
        if (_lpMFOld)
           return (_lpMFOld->HandleInComingCall(dwCallType, htaskCaller, dwTickCount, lpInterfaceInfo));
        else
           return SERVERCALL_ISHANDLED;
    };

    STDMETHODIMP_(DWORD) RetryRejectedCall(
        IN HTASK htaskCallee,
        IN DWORD dwTickCount,
        IN DWORD dwRejectType)
    {
        if (_lpMFOld)
            return (_lpMFOld->RetryRejectedCall(htaskCallee, dwTickCount, dwRejectType));
        else
            return 0xffffffff;
    };

    STDMETHODIMP_(DWORD) MessagePending(
        IN HTASK htaskCallee,
        IN DWORD dwTickCount,
        IN DWORD dwPendingType)
    {
        DWORD dw;
        MSG msg;

        // We can get released during the DispatchMessage call...
        // If it's our last release, we'll free ourselves and
        // fault when we dereference _lpMFOld... Make sure this
        // doesn't happen by increasing our refcount.
        //
        AddRef();

        while (PeekMessage(&msg, NULL, WM_TIMER, WM_TIMER, PM_REMOVE))
        {
#ifndef DISPATCH_IETIMERS
            TCHAR szClassName[40];
                
            GetClassName(msg.hwnd, szClassName, ARRAYSIZE(szClassName));


            if (StrCmpI(szClassName, TEXT("Internet Explorer_Hidden")) != 0)
            {
#endif
                DispatchMessage(&msg);
#ifndef DISPATCH_IETIMERS
            }
#endif
        }

        if (_lpMFOld)
            dw = (_lpMFOld->MessagePending(htaskCallee, dwTickCount, dwPendingType));
        else
            dw = PENDINGMSG_WAITDEFPROCESS;

        Release();

        return(dw);
    };

    CMsgFilter() : _cRef(1)
    {
        ASSERT(_lpMFOld == NULL);
    };

    BOOL Initialize()
    {
        return (CoRegisterMessageFilter((LPMESSAGEFILTER)this, &_lpMFOld) != S_FALSE);
    };

    void UnInitialize()
    {
        CoRegisterMessageFilter(_lpMFOld, NULL);

        // we shouldn't ever get called again, but after 30 minutes
        // of automation driving we once hit a function call above
        // and we dereferenced this old pointer and page faulted.

        ATOMICRELEASE(_lpMFOld);
    };

protected:
    int _cRef;
    LPMESSAGEFILTER _lpMFOld;
};
#endif


void IEHard_NavWarning(HWND hwnd, BOOL fIE);
BOOL IEHard_ShowOnNavigateComplete(void);
BOOL IEHard_HostedInIE(IUnknown* punk);


//--------------------------------------------------------------------------
// Detecting a memory leak
//--------------------------------------------------------------------------

HRESULT GetTopFrameOptions(IServiceProvider * psp, DWORD * pdwOptions)
{
    IServiceProvider * pspTop;
    HRESULT hres = psp->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IServiceProvider, &pspTop));
    if (SUCCEEDED(hres))
    {
        ITargetFrame2 *ptgf;
        hres = pspTop->QueryService(SID_SContainerDispatch, IID_PPV_ARG(ITargetFrame2, &ptgf));
        if (SUCCEEDED(hres))
        {
            hres = ptgf->GetFrameOptions(pdwOptions);
            ptgf->Release();
        }
        pspTop->Release();
    }

    return hres;
}

void UpdateDesktopComponentName(LPCWSTR lpcwszURL, LPCWSTR lpcwszName)
{
    IActiveDesktop * piad;

    if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_ActiveDesktop, NULL, IID_PPV_ARG(IActiveDesktop, &piad))))
    {
        COMPONENT comp;
        comp.dwSize = SIZEOF(comp);

        if (SUCCEEDED(piad->GetDesktopItemBySource(lpcwszURL, &comp, 0)) && !comp.wszFriendlyName[0])
        {
            StrCpyNW(comp.wszFriendlyName, lpcwszName, ARRAYSIZE(comp.wszFriendlyName));
            piad->ModifyDesktopItem(&comp, COMP_ELEM_FRIENDLYNAME);
            piad->ApplyChanges(AD_APPLY_SAVE);
        }
        piad->Release();
    }
}

HRESULT CBaseBrowser2::_Initialize(HWND hwnd, IUnknown* pauto)
{
    if (pauto)
    {
        pauto->AddRef();
    }
    else
    {
        CIEFrameAuto_CreateInstance(NULL, &pauto);
    }

    // Grab _pauto interfaces we use throughout this code.
    //
    if (pauto)
    {
        pauto->QueryInterface(IID_PPV_ARG(IWebBrowser2, &_bbd._pautoWB2));
        ASSERT(_bbd._pautoWB2);

        pauto->QueryInterface(IID_PPV_ARG(IExpDispSupport, &_bbd._pautoEDS));
        ASSERT(_bbd._pautoEDS);

        pauto->QueryInterface(IID_PPV_ARG(IShellService, &_bbd._pautoSS));
        ASSERT(_bbd._pautoSS);

        pauto->QueryInterface(IID_PPV_ARG(ITargetFrame2, &_ptfrm));
        ASSERT(_ptfrm);

        pauto->QueryInterface(IID_PPV_ARG(IHlinkFrame, &_bbd._phlf));
        ASSERT(_bbd._phlf);

        IHTMLWindow2 *pWindow;
        if( SUCCEEDED(GetWindowFromUnknown( pauto, &pWindow )) )
        {
            pWindow->QueryInterface(IID_PPV_ARG(IShellHTMLWindowSupport, &_phtmlWS));
            pWindow->Release( );
        }
        ASSERT( _phtmlWS );

        _pauto = pauto;
    }

    //  _psbOuter?
    if (NULL == _bbd._phlf)
    {
        Release();
        return E_FAIL;
    }
    else
    {
        _SetWindow(hwnd);
        return S_OK;
    }
}


HRESULT CBaseBrowser2::InitializeTransitionSite()
{
    return S_OK;
}


HRESULT CBaseBrowser2_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CBaseBrowser2 *pbb = new CBaseBrowser2(pUnkOuter);
    if (pbb)
    {
        *ppunk = pbb->_GetInner();
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

CBaseBrowser2::CBaseBrowser2(IUnknown* punkAgg) :
       CAggregatedUnknown(punkAgg),
        _bptBrowser(BPT_DeferPaletteSupport)
{
    TraceMsg(TF_SHDLIFE, "ctor CBaseBrowser2 %x", this);

    _bbd._uActivateState = SVUIA_ACTIVATE_FOCUS;
    _InitComCtl32();

    ASSERT(S_FALSE == _DisableModeless());
    ASSERT(_cp == CP_ACP);
    ASSERT(!_fNoTopLevelBrowser);
    ASSERT(!_dwDocFlags);

    _QueryOuterInterface(IID_PPV_ARG(IBrowserService2, &_pbsOuter));
    _QueryOuterInterface(IID_PPV_ARG(IBrowserService3, &_pbsOuter3));
    _QueryOuterInterface(IID_PPV_ARG(IShellBrowser, &_psbOuter));
    _QueryOuterInterface(IID_PPV_ARG(IServiceProvider, &_pspOuter));

    // The following are intercepted by CCommonBrowser, but we don't call 'em
    //_QueryOuterInterface(IID_PPV_ARG(IOleCommandTarget, &_pctOuter));
    //_QueryOuterInterface(IID_PPV_ARG(IInputObjectSite, &_piosOuter));

    _dwStartingAppTick = 0;
}


CBaseBrowser2::~CBaseBrowser2()
{
    TraceMsg(TF_SHDLIFE, "dtor CBaseBrowser2 %x", this);

    // Are we releasing these too early (i.e. does anything in the
    // rest of this func rely on having the 'vtables' still be valid?)
    RELEASEOUTERINTERFACE(_pbsOuter);
    RELEASEOUTERINTERFACE(_pbsOuter3);
    RELEASEOUTERINTERFACE(_psbOuter);
    RELEASEOUTERINTERFACE(_pspOuter);

    // The following are intercepted by CCommonBrowser, but we don't call 'em
    //RELEASEOUTERINTERFACE(_pctOuter);
    //RELEASEOUTERINTERFACE(_piosOuter);
    
    ASSERT(_hdpaDLM == NULL);    // subclass must free it.

    // finish tracking here
    if (_ptracking) 
    {
        delete _ptracking;
        _ptracking = NULL;
    }

    //
    // Notes: Unlike IE3.0, we release CIEFrameAuto pointers here.
    //
    ATOMICRELEASE(_bbd._pautoWB2);
    ATOMICRELEASE(_bbd._pautoEDS);
    ATOMICRELEASE(_bbd._pautoSS);
    ATOMICRELEASE(_phtmlWS);
    ATOMICRELEASE(_bbd._phlf);
    ATOMICRELEASE(_ptfrm);
    ATOMICRELEASE(_pauto);
    
    ATOMICRELEASE(_punkSFHistory);

    // clean up our palette by simulating a switch out of palettized mode
    _bptBrowser = BPT_NotPalettized;
    _QueryNewPalette();

    ASSERT(!_bbd._phlf);
    ASSERT(!_ptfrm);
    ASSERT(S_FALSE == _DisableModeless());
    ASSERT(_bbd._hwnd==NULL);

    ATOMICRELEASE(_pact);

    ATOMICRELEASE(_pIUrlHistoryStg);
    ATOMICRELEASE(_pITravelLogStg);
    ATOMICRELEASE(_poleHistory);
    ATOMICRELEASE(_pstmHistory);
    ATOMICRELEASE(_bbd._ptl);

    ATOMICRELEASE(_pHTMLDocument);
    ATOMICRELEASE(_pphHistory);
    ATOMICRELEASE(_pDispViewLinkedWebOCFrame);

#ifdef MESSAGEFILTER
    if (_lpMF) 
    {
        IMessageFilter* lpMF = _lpMF;
        _lpMF = NULL;
        ((CMsgFilter *)lpMF)->UnInitialize();
        EVAL(lpMF->Release() == 0);
    }
#endif

    // This is created during FileCabinet_CreateViewWindow2
    CShellViews_Delete(&_fldBase._cViews);

    // If the class factory object has been cached, unlock it and release.
    if (_pcfHTML) 
    {
        _pcfHTML->LockServer(FALSE);
        _pcfHTML->Release();
    }

    ATOMICRELEASE(_pToolbarExt);
}

HRESULT CBaseBrowser2::v_InternalQueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CBaseBrowser2, IShellBrowser),         // IID_IShellBrowser
        QITABENTMULTI(CBaseBrowser2, IOleWindow, IShellBrowser), // IID_IOleWindow
        QITABENT(CBaseBrowser2, IOleInPlaceUIWindow),   // IID_IOleInPlaceUIWindow
        QITABENT(CBaseBrowser2, IOleCommandTarget),     // IID_IOleCommandTarget
        QITABENT(CBaseBrowser2, IDropTarget),           // IID_IDropTarget
        QITABENTMULTI(CBaseBrowser2, IBrowserService, IBrowserService3), // IID_IBrowserService
        QITABENTMULTI(CBaseBrowser2, IBrowserService2, IBrowserService3), // IID_IBrowserService2
        QITABENT(CBaseBrowser2, IBrowserService3),      // IID_IBrowserService3
        QITABENT(CBaseBrowser2, IServiceProvider),      // IID_IServiceProvider
        QITABENT(CBaseBrowser2, IOleContainer),         // IID_IOleContainer
        QITABENT(CBaseBrowser2, IAdviseSink),           // IID_IAdviseSink
        QITABENT(CBaseBrowser2, IInputObjectSite),      // IID_IInputObjectSite
        QITABENT(CBaseBrowser2, IDocNavigate),          // IID_IDocNavigate
        QITABENT(CBaseBrowser2, IPersistHistory),       // IID_IPersistHistory
        QITABENT(CBaseBrowser2, IInternetSecurityMgrSite), // IID_IInternetSecurityMgrSite
        QITABENT(CBaseBrowser2, IVersionHost),          // IID_IVersionHost
        QITABENT(CBaseBrowser2, IProfferService),       // IID_IProfferService
        QITABENT(CBaseBrowser2, ITravelLogClient),      // IID_ITravelLogClient
        QITABENT(CBaseBrowser2, ITravelLogClient2),     // IID_ITravelLogClient2
        QITABENTMULTI(CBaseBrowser2, ITridentService, ITridentService2), // IID_ITridentService
        QITABENT(CBaseBrowser2, ITridentService2),      // IID_ITridentService2
        QITABENT(CBaseBrowser2, IInitViewLinkedWebOC),  // IID_IInitViewLinkedWebOC
        QITABENT(CBaseBrowser2, INotifyAppStart),       // IID_INotifyAppStart
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

BOOL CBaseBrowser2::_IsViewMSHTML(IShellView * psv)
{
    BOOL fIsMSHTML = FALSE;
    
    if (psv)
    {
        IPersist *pPersist = NULL;
        HRESULT hres = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_PPV_ARG(IPersist, &pPersist));
        if (SUCCEEDED(hres) && (pPersist != NULL))
        {
            CLSID clsid;
            hres = pPersist->GetClassID(&clsid);
            if (SUCCEEDED(hres) && IsEqualGUID(clsid, CLSID_HTMLDocument))
                fIsMSHTML = TRUE;
            pPersist->Release();
        }
    }
    return fIsMSHTML;
}

HRESULT CBaseBrowser2::ReleaseShellView()
{
    //  We're seeing some reentrancy here.  If _cRefUIActivateSV is non-zero, it means we're
    //  in the middle of UIActivating the shell view.
    //
    if (_cRefUIActivateSV)
    {
        TraceMsg(TF_WARNING, 
            "CBB(%x)::ReleaseShellView _cRefUIActivateSV(%d)!=0  _bbd._psv=%x ABORTING", 
            this, _cRefUIActivateSV, _bbd._psv);
        return S_OK;
    }
    
    BOOL fViewObjectChanged = FALSE;

    VALIDATEPENDINGSTATE();

    TraceMsg(DM_NAV, "CBaseBrowser2(%x)::ReleaseShellView(%x)", this, _bbd._psv);

    ATOMICRELEASE(_pdtView);

    if (_bbd._psv) 
    {
        //  Disable navigation while we are UIDeactivating/DestroyWindowing
        // the IShellView. Some OC/DocObject in it (such as ActiveMovie)
        // might have a message loop long enough to cause some reentrancy.

        _psbOuter->EnableModelessSB(FALSE);

        // Tell the shell's HTML window we are releasing the document.
        if (_phtmlWS)
        {
            _phtmlWS->ViewReleased();
        }

        //
        //  We need to cancel the menu mode so that unmerging menu won't
        // destroy the menu we are dealing with (which caused GPF in USER).
        // DocObject needs to do appropriate thing for context menus.
        // (02-03-96 SatoNa)
        //
        HWND hwndCapture = GetCapture();
        TraceMsg(DM_CANCELMODE, "ReleaseShellView hwndCapture=%x _bbd._hwnd=%x", hwndCapture, _bbd._hwnd);
        if (hwndCapture && hwndCapture==_bbd._hwnd) 
        {
            TraceMsg(DM_CANCELMODE, "ReleaseShellView Sending WM_CANCELMODE");
            SendMessage(_bbd._hwnd, WM_CANCELMODE, 0, 0);
        }

        //
        //  We don't want to resize the previous view window while we are
        // navigating away from it.
        //
        TraceMsg(TF_SHDUIACTIVATE, "CSB::ReleaseShellView setting _fDontResizeView");
        _fDontResizeView = TRUE;

        // If the current view is still waiting for ReadyStateComplete,
        // and the view we're swapping in here does not support this property,
        // then we'll never go to ReadyStateComplete! Simulate it here:
        //
        // NOTE: ZekeL put this in _CancelNavigation which happened way too often.
        // I think this is the case he was trying to fix, but I don't remember
        // the bug number so I don't have a specific repro...
        //
        
        if (!_bbd._fIsViewMSHTML)
        {
            _fReleasingShellView = TRUE;
            OnReadyStateChange(_bbd._psv, READYSTATE_COMPLETE);
            _fReleasingShellView = FALSE;
        }

        // At one point during a LOR stress test, we got re-entered during
        // this UIActivate call (some rogue 3rd-party IShellView perhaps?)
        // which caused _psv to get freed, and we faulted during the unwind.
        // Gaurd against this by swapping the _psv out early.
        //
        IShellView* psv = _bbd._psv;
        _bbd._psv = NULL;
        if (psv)
        {
            psv->UIActivate(SVUIA_DEACTIVATE);
            if (_cRefUIActivateSV)
            {
                TraceMsg(TF_WARNING, "CBB(%x)::ReleaseShellView setting _bbd._psv = NULL (was %x) while _cRefUIActivateSV=%d",
                    this, psv, _cRefUIActivateSV);
            }

            ATOMICRELEASE(_bbd._pctView);

            if (_pvo)
            {
                IAdviseSink *pSink;

                // paranoia: only blow away the advise sink if it is still us
                if (SUCCEEDED(_pvo->GetAdvise(NULL, NULL, &pSink)) && pSink)
                {
                    if (pSink == SAFECAST(this, IAdviseSink *))
                        _pvo->SetAdvise(0, 0, NULL);

                    pSink->Release();
                }

                fViewObjectChanged = TRUE;
                ATOMICRELEASE(_pvo);
            }
            
            psv->SaveViewState();
            TraceMsg(DM_NAV, "ief NAV::%s %x",TEXT("ReleaseShellView Calling DestroyViewWindow"), psv);
            psv->DestroyViewWindow();
    
            UINT cRef = psv->Release();
            TraceMsg(DM_NAV, "ief NAV::%s %x %x",TEXT("ReleaseShellView called psv->Release"), psv, cRef);

            _bbd._hwndView = NULL;
            TraceMsg(TF_SHDUIACTIVATE, "CSB::ReleaseShellView resetting _fDontResizeView");
            _fDontResizeView = FALSE;

            if (_bbd._pidlCur) 
            {
                ILFree(_bbd._pidlCur);
                _bbd._pidlCur = NULL;
            }
        }
        
        _psbOuter->EnableModelessSB(TRUE);

        //
        //  If there is any blocked async operation AND we can navigate now,
        // unblock it now. 
        //
        _MayUnblockAsyncOperation();
    }

    ATOMICRELEASE(_bbd._psf);

    if (fViewObjectChanged)
        _ViewChange(DVASPECT_CONTENT, -1);

    if (_bbd._pszTitleCur)
    {
        LocalFree(_bbd._pszTitleCur);
        _bbd._pszTitleCur = NULL;
    }

    // NOTES: (SatoNa)
    //
    //  This is the best time to clean up the left-over from UI-negotiation
    // from the previous DocObject. Excel 97, for some reason, takes 16
    // pixels from the top (for the formula bar) when we UI-deactivate it
    // by callin gIOleDocumentView::UIActivate(FALSE), which we call above.
    //
    SetRect(&_rcBorderDoc, 0, 0, 0, 0);
    return S_OK;
}

void CBaseBrowser2::_StopCurrentView()
{
    // send OLECMDID_STOP
    if (_bbd._pctView) // we must check!
    {
        _bbd._pctView->Exec(NULL, OLECMDID_STOP, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
    }
}

//
// This function synchronously cancels the pending navigation if any.
//
HRESULT CBaseBrowser2::_CancelPendingNavigation(BOOL fDontReleaseState)
{
    TraceMsg(TF_SHDNAVIGATE, "CBB::_CancelPendingNavigation called");
    
    _StopAsyncOperation();
    
    HRESULT hres = S_FALSE;

#ifndef NON_NATIVE_FRAMES

    if (_bbd._psvPending) 
    {
        if (_IsViewMSHTML(_bbd._psvPending))
        {
            VARIANT varStop;

            V_VT(&varStop)   = VT_BOOL;
            V_BOOL(&varStop) = VARIANT_TRUE;

            IUnknown_Exec(_bbd._psvPending, NULL, OLECMDID_STOP, 0, &varStop, NULL);
        }
        else
        {
            if (_bbd._phlf && !fDontReleaseState) 
            {
                 // release our state
                 _bbd._phlf->Navigate(0, NULL, NULL, NULL);
            }

            _CancelPendingView();
        }

        hres = S_OK;
    }

#else

    if (_bbd._psvPending) 
    {
        if (_bbd._phlf && !fDontReleaseState) 
        {
             // release our state
             _bbd._phlf->Navigate(0, NULL, NULL, NULL);
        }

        _CancelPendingView();
        hres = S_OK;
    }

#endif

    return hres;
}

void CBaseBrowser2::_SendAsyncNavigationMsg(VARIANTARG *pvarargIn)
{
    LPCWSTR psz = VariantToStrCast(pvarargIn);
    if (psz)
    {
        LPITEMIDLIST pidl;
        if (EVAL(SUCCEEDED(IECreateFromPathW(psz, &pidl))))
        {
            _NavigateToPidlAsync(pidl, 0); // takes ownership of pidl
        }
    }
}


//
// NOTES: It does not cancel the pending view.
//
void CBaseBrowser2::_StopAsyncOperation(void)
{
    // Don't remove posted WMC_ASYNCOPERATION message. PeekMesssage removes
    // messages for children! (SatoNa)
    _uActionQueued = ASYNCOP_NIL;

    // Remove the pidl in the queue (single depth)
    _FreeQueuedPidl(&_pidlQueued);
}

//
//  This function checks if we have any asynchronous operation AND
// we no longer need to postpone. In that case, we unblock it by
// posting a WMC_ASYNCOPERATION.
//
void CBaseBrowser2::_MayUnblockAsyncOperation(void)
{
    if (_uActionQueued!=ASYNCOP_NIL && _CanNavigate()) 
    {
        TraceMsg(TF_SHDNAVIGATE, "CBB::_MayUnblockAsyncOp posting WMC_ASYNCOPERATION");
        PostMessage(_bbd._hwnd, WMC_ASYNCOPERATION, 0, 0);
    }
}

BOOL CBaseBrowser2::_PostAsyncOperation(UINT uAction)
{
    _uActionQueued = uAction;
    return PostMessage(_bbd._hwnd, WMC_ASYNCOPERATION, 0, 0);
}

LRESULT CBaseBrowser2::_SendAsyncOperation(UINT uAction)
{
    _uActionQueued = uAction;
    return SendMessage(_bbd._hwnd, WMC_ASYNCOPERATION, 0, 0);
}

HRESULT CBaseBrowser2::_CancelPendingNavigationAsync(void)
{
    TraceMsg(TF_SHDNAVIGATE, "CBB::_CancelPendingNavigationAsync called");

    _StopAsyncOperation();
    _PostAsyncOperation(ASYNCOP_CANCELNAVIGATION);
    return S_OK;
}

HRESULT CBaseBrowser2::_CancelPendingView(void)
{
    if (_bbd._psvPending) 
    {
        TraceMsg(DM_NAV, "ief NAV::%s %x",TEXT("_CancelPendingView Calling DestroyViewWindow"), _bbd._psvPending);
        _bbd._psvPending->DestroyViewWindow();

        ASSERT(_bbd._psfPending);

        // When cancelling a pending navigation, make sure we
        // think the pending operation is _COMPLETE otherwise
        // we may get stuck in a _LOADING state...
        //
        TraceMsg(TF_SHDNAVIGATE, "basesb(%x) Fake pending ReadyState_Complete", this);
        OnReadyStateChange(_bbd._psvPending, READYSTATE_COMPLETE);

        ATOMICRELEASE(_bbd._psvPending);

        // Paranoia
        ATOMICRELEASE(_bbd._psfPending);
        
        _bbd._hwndViewPending = NULL;

        _setDescendentNavigate(NULL);

        SetNavigateState(BNS_NORMAL);

        if (_bbd._pidlPending) 
        {
            ILFree(_bbd._pidlPending);
            _bbd._pidlPending = NULL;
        }

        if (_bbd._pszTitlePending)
        {
            LocalFree(_bbd._pszTitlePending);
            _bbd._pszTitlePending = NULL;
        }

        // Pending navigation is canceled.
        // since the back button works as a stop on pending navigations, we
        // should check that here as well.
        _pbsOuter->UpdateBackForwardState();
        _NotifyCommandStateChange();

        _PauseOrResumeView(_fPausedByParent);
    }
    return S_OK;
}

void CBaseBrowser2::_UpdateTravelLog(BOOL fForceUpdate /* = FALSE */)
{
    //
    //  we update the travellog in two parts.  first we update
    //  the current entry with the current state info, 
    //  then we create a new empty entry.  UpdateEntry()
    //  and AddEntry() need to always be in pairs, with 
    //  identical parameters.
    //
    //  if this navigation came from a LoadHistory, the 
    //  _fDontAddTravelEntry will be set, and the update and 
    //  cursor movement will have been adjusted already.
    //  we also want to prevent new frames from updating 
    //  and adding stuff, so unless this is the top we
    //  wont add to the travellog if this is a new frame.
    //
    ASSERT(!(_grfHLNFPending & HLNF_CREATENOHISTORY));

    ITravelLog *ptl;
    GetTravelLog(&ptl);
    BOOL fTopFrameBrowser = IsTopFrameBrowser(SAFECAST(this, IServiceProvider *), SAFECAST(this, IShellBrowser *));
 
    if (ptl)
    {
        //  
        //  some times we are started by another app (MSWORD usually) that has HLink
        //  capability.  we detect this by noting that we are a new browser with an empty
        //  TravelLog, and then see if we can get a IHlinkBrowseContext.  if this is successful,
        //  we should add an entry and update it immediately with the external info.
        //
        IHlinkBrowseContext *phlbc = NULL;  // init to suppress bogus C4701 warning
        BOOL fExternalNavigate = (FAILED(ptl->GetTravelEntry(SAFECAST(this, IBrowserService *), 0, NULL)) &&
            fTopFrameBrowser && _bbd._phlf && SUCCEEDED(_bbd._phlf->GetBrowseContext(&phlbc)));

        if (fExternalNavigate)
        {
            ptl->AddEntry(SAFECAST(this, IBrowserService *), FALSE);
            ptl->UpdateExternal(SAFECAST(this, IBrowserService *), phlbc);
            phlbc->Release();
        }
        else if (_bbd._psv && (fForceUpdate || !_fIsLocalAnchor || (_dwDocFlags & DOCFLAG_DOCCANNAVIGATE)))
        {
            ptl->UpdateEntry(SAFECAST(this, IBrowserService *), _fIsLocalAnchor);  // CAST for IUnknown
        }

        if (!_fDontAddTravelEntry && (_bbd._psv || fTopFrameBrowser))
        {
            ptl->AddEntry(SAFECAST(this, IBrowserService *), _fIsLocalAnchor);  // CAST for IUnknown
        }

        ptl->Release();
    }

    _fDontAddTravelEntry  = FALSE;
    _fIsLocalAnchor       = FALSE;
}


void CBaseBrowser2::_OnNavigateComplete(LPCITEMIDLIST pidl, DWORD grfHLNF)
{
    _pbsOuter->UpdateBackForwardState();
}


//// Does only the top shbrowse need this?  or the top oc frame too?
HRESULT CBaseBrowser2::UpdateSecureLockIcon(int eSecureLock)
{
    // only the top boy should get to set his stuff
    if (!IsTopFrameBrowser(SAFECAST(this, IServiceProvider *), SAFECAST(this, IShellBrowser *)))
        return S_OK;

    if (eSecureLock != SECURELOCK_NOCHANGE)
        _bbd._eSecureLockIcon = eSecureLock;
    
    // 
    //  There is no mixed Security Icon - zekel 6-AUG-97
    //  right now we have no icon or TT for SECURELOCK_SET_MIXED, which 
    //  is set when the root page is secure but some of the other content
    //  or frames are not.  some PM needs to implement, probably 
    //  with consultation from TonyCi and DBau.  by default we currently
    //  only show for pages that are completely secure.
    //

    TraceMsg(DM_SSL, "CBB:UpdateSecureLockIcon() _bbd._eSecureLockIcon = %d", _bbd._eSecureLockIcon);

    //
    // It looks like it doesnt matter what icon we select here,
    // the status bar always shows some lock icon that was cached there earlier
    // and it treats this HICON as a bool to indicat on or off  - zekel - 5-DEC-97
    //

    HICON hicon = NULL;
    TCHAR szText[MAX_TOOLTIP_STRING];

    szText[0] = 0;

    switch (_bbd._eSecureLockIcon)
    {
    case SECURELOCK_SET_UNSECURE:
    case SECURELOCK_SET_MIXED:
        hicon = NULL;
        break;

    case SECURELOCK_SET_SECUREUNKNOWNBIT:
        hicon = g_hiconSSL;
        break;

    case SECURELOCK_SET_SECURE40BIT:
        hicon = g_hiconSSL;
        MLLoadString(IDS_SSL40, szText, ARRAYSIZE(szText));
        break;

    case SECURELOCK_SET_SECURE56BIT:
        hicon = g_hiconSSL;
        MLLoadString(IDS_SSL56, szText, ARRAYSIZE(szText));
        break;

    case SECURELOCK_SET_SECURE128BIT:
        hicon = g_hiconSSL;
        MLLoadString(IDS_SSL128, szText, ARRAYSIZE(szText));
        break;

    case SECURELOCK_SET_FORTEZZA:
        hicon = g_hiconFortezza;
        MLLoadString(IDS_SSL_FORTEZZA, szText, ARRAYSIZE(szText));
        break;

    default:
        ASSERT(0);
        return E_FAIL;
    }

    VARIANTARG var = {0};
    if (_bbd._pctView && SUCCEEDED(_bbd._pctView->Exec(&CGID_Explorer, SBCMDID_GETPANE, PANE_SSL, NULL, &var))
        && V_UI4(&var) != PANE_NONE)
    {
        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETICON, V_UI4(&var), (LPARAM)(hicon), NULL);
        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTIPTEXT, V_UI4(&var), (LPARAM)(szText[0] ? szText : NULL), NULL);

        // Also add the tip text as the pane's normal text.  Because of the pane's size it will be clipped,
        // but it will show up as a useful string in MSAA.
        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTEXTW, V_UI4(&var), (LPARAM)(szText[0] ? szText : NULL), NULL);
    }    
    return S_OK;
}

//
// Update Privacy Icon
//
HRESULT CBaseBrowser2::_UpdatePrivacyIcon(BOOL fSetState, BOOL fNewImpacted)
{
    static BOOL fHelpShown = FALSE;

    //
    // only the top boy should get to set his stuff
    //
    if (!IsTopFrameBrowser(SAFECAST(this, IServiceProvider *), SAFECAST(this, IShellBrowser *)))
        return S_OK;

    //
    // save off the privacy state
    //
    if(fSetState)
    {
        _bbd._fPrivacyImpacted = fNewImpacted;
    }

    HICON hicon = NULL;
    TCHAR szText[MAX_TOOLTIP_STRING];

    szText[0] = 0;

    if(_bbd._fPrivacyImpacted)
    {
        hicon = g_hiconPrivacyImpact;
        MLLoadString(IDS_PRIVACY_TOOLTIP, szText, ARRAYSIZE(szText));
    }

    if (_bbd._pctView)
    {
        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETICON, STATUS_PANE_PRIVACY, (LPARAM)(hicon), NULL);
        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTIPTEXT, STATUS_PANE_PRIVACY, (LPARAM)(szText[0] ? szText : NULL), NULL);

        // Also add the tip text as the panes normal text.  Because of the pane's size it will be clipped,
        // but it will show up as a useful string in MSAA.
        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTEXTW, STATUS_PANE_PRIVACY, (LPARAM)(szText[0] ? szText : NULL), NULL);
    }    

    // if impacted and never shown before, show bubble toolhelp
    if(FALSE == fHelpShown && _bbd._fPrivacyImpacted)
    {
        DWORD   dwValue, dwSize;

        // only do this work once
        fHelpShown = TRUE;

        // Check to see if we should show discovery UI
        dwSize = sizeof(DWORD);
        if(ERROR_SUCCESS != SHGetValueW(HKEY_CURRENT_USER,
                REGSTR_PATH_INTERNET_SETTINGS,
                REGSTR_VAL_PRIVDISCOVER,
                NULL, &dwValue, &dwSize)
            || 0 == dwValue)
        {
            BOOL    bStatusBarVisible = FALSE;
            INT_PTR i = 1;
            HRESULT hr;

            // suppression setting not set, show ui if status bar is visible
            IBrowserService *pbs;
            hr = _pspOuter->QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IBrowserService, &pbs));
            if(SUCCEEDED(hr))
            {
                hr = pbs->IsControlWindowShown(FCW_STATUS, &bStatusBarVisible);
                pbs->Release();
            }

            BOOL fDontShowPrivacyFirstTimeDialogAgain = FALSE;
            if(SUCCEEDED(hr) && bStatusBarVisible)
            {
                fDontShowPrivacyFirstTimeDialogAgain = DoPrivacyFirstTimeDialog( _bbd._hwnd);
            }

            if( fDontShowPrivacyFirstTimeDialogAgain == TRUE)
            {
                dwValue = 1;
                SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_INTERNET_SETTINGS, REGSTR_VAL_PRIVDISCOVER,
                    REG_DWORD, &dwValue, sizeof(DWORD));
            }
        }
    }

    return S_OK;
}

//
//  This block of code simply prevents calling UIActivate of old
// extensions with a new SVUIA_ value.
//
HRESULT CBaseBrowser2::_UIActivateView(UINT uState)
{
    if (_bbd._psv) 
    {
        BOOL fShellView2;
        IShellView2* psv2;
        if (SUCCEEDED(_bbd._psv->QueryInterface(IID_PPV_ARG(IShellView2, &psv2))))
        {
            fShellView2 = TRUE;
            psv2->Release();
        }
        else
        {
            fShellView2 = FALSE;
        }

        if (uState == SVUIA_INPLACEACTIVATE && !fShellView2)
        {
            uState = SVUIA_ACTIVATE_NOFOCUS;        // map it to old one.
        }

        if (_cRefUIActivateSV)
        {
            TraceMsg(TF_WARNING, "CBB(%x)::_UIActivateView(%d) entered reentrantly!!!!!! _cRefUIActivate=%d",
                this, uState, _cRefUIActivateSV);
            if (uState == SVUIA_DEACTIVATE)
            {
                _fDeferredUIDeactivate = TRUE;
                return S_OK;
            }
            if (!_HeyMoe_IsWiseGuy())
            {
                if (_bbd._psv)
                    _bbd._psv->UIActivate(SVUIA_INPLACEACTIVATE);
                return S_OK;
            }
        }

        _cRefUIActivateSV++;

        TraceMsg(TF_SHDUIACTIVATE, "CBaseBrowser2(%x)::_UIActivateView(%d) about to call _bbd._psv(%x)->UIActivate",
            this, uState, _bbd._psv);

        _bbd._psv->UIActivate(uState);

        if (uState == SVUIA_ACTIVATE_FOCUS && !fShellView2)
        {
            // win95 defview expects a SetFocus on activation (nt5 bug#172210)
            if (_bbd._hwndView)
                SetFocus(_bbd._hwndView);
        }

        TraceMsg(TF_SHDUIACTIVATE, "CBaseBrowser2(%x)::_UIActivateView(%d) back from _bbd._psv(%x)->UIActivate",
            this, uState, _bbd._psv);

        _cRefUIActivateSV--;

        _UpdatePrivacyIcon(FALSE, FALSE);
        UpdateSecureLockIcon(SECURELOCK_NOCHANGE);
        
    }
    _bbd._uActivateState = uState;

    // If this is a pending view, set the focus to its window even though it's hidden.
    // In ActivatePendingView(), we check if this window still has focus and, if it does,
    // we will ui-activate the view. Fix for IE5 bug #70632 -- MohanB

    if (    SVUIA_ACTIVATE_FOCUS == uState
        &&  !_bbd._psv
        &&  !_bbd._hwndView
        &&  _bbd._psvPending
        &&  _bbd._hwndViewPending
       )
    {
        ::SetFocus(_bbd._hwndViewPending);
    }

    if (_fDeferredUIDeactivate)
    {
        TraceMsg(TF_SHDUIACTIVATE, "CBaseBrowser2(%x)::_UIActivateView processing deferred UIDeactivate, _bbd._psv=%x",
            this, _bbd._psv);
        _fDeferredUIDeactivate = FALSE;
        if (_bbd._psv)
            _bbd._psv->UIActivate(SVUIA_DEACTIVATE);
        _UpdatePrivacyIcon(FALSE, FALSE);
        UpdateSecureLockIcon(SECURELOCK_NOCHANGE);
        _bbd._uActivateState = SVUIA_DEACTIVATE;
    }

    if (_fDeferredSelfDestruction)
    {
        TraceMsg(TF_SHDUIACTIVATE, "CBaseBrowser2(%x)::_UIActivateView processing deferred OnDestroy",
            this);
        _fDeferredSelfDestruction = FALSE;
        _pbsOuter->OnDestroy();
    }

    return S_OK;
}


//Called from CShellBrowser::OnCommand
HRESULT CBaseBrowser2::Offline(int iCmd)
{
    HRESULT hresIsOffline = IsGlobalOffline() ? S_OK : S_FALSE;

    switch(iCmd){
    case SBSC_TOGGLE:
        hresIsOffline = (hresIsOffline == S_OK) ? S_FALSE : S_OK; // Toggle Property
        // Tell wininet that the user wants to go offline
        SetGlobalOffline(hresIsOffline == S_OK); 
        SendShellIEBroadcastMessage(WM_WININICHANGE,0,0, 1000); // Tell all browser windows to update their title   
        break;
        
    case SBSC_QUERY:
        break;
    default: // Treat like a query
        break;                   
    }
    return hresIsOffline;
}



BOOL _TrackPidl(LPITEMIDLIST pidl, IUrlHistoryPriv *php, BOOL fIsOffline, LPTSTR pszUrl, DWORD cchUrl)
{
    BOOL fRet = FALSE;

    // Should use IsBrowserFrameOptionsPidlSet(pidl, BFO_ENABLE_HYPERLINK_TRACKING)
    //     instead of IsURLChild() because it doesn't work in Folder Shortcuts and doesn't
    //     work in NSEs outside of the "IE" name space (like Web Folders).
    if (pidl && IsURLChild(pidl, FALSE))
    {
        if (SUCCEEDED(IEGetNameAndFlags(pidl, SHGDN_FORPARSING, pszUrl, cchUrl, NULL)))
        {
            PROPVARIANT vProp;
            if (SUCCEEDED(php->GetProperty(pszUrl, PID_INTSITE_TRACKING, &vProp)))
            {
                if (vProp.vt == VT_UI4)
                {
                    if (fIsOffline)
                        fRet = (vProp.ulVal & TRACK_OFFLINE_CACHE_ENTRY) ? TRUE : FALSE;
                    else
                        fRet = (vProp.ulVal & TRACK_ONLINE_CACHE_ENTRY) ? TRUE : FALSE;
                }

                PropVariantClear(&vProp);
            }
        }
    }

    return fRet;
}

// End tracking of previous page
// May start tracking of new page
// use SatoN's db to quick check tracking/tracking scope bits, so
// to eliminate call to CUrlTrackingStg::IsOnTracking
void CBaseBrowser2::_MayTrackClickStream(LPITEMIDLIST pidlNew)
{
    BOOL    fIsOffline = (Offline(SBSC_QUERY) != S_FALSE);
    IUrlHistoryStg*    phist;
    IUrlHistoryPriv*   phistp;
    PROPVARIANT vProp = {0};
    TCHAR szUrl[MAX_URL_STRING];

    ASSERT(_bbd._pautoWB2);

    HRESULT hr = _pspOuter->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IUrlHistoryStg, &phist));
    if (SUCCEEDED(hr))
    {
        hr = phist->QueryInterface(IID_PPV_ARG(IUrlHistoryPriv, &phistp));
        phist->Release();
    }

    if (SUCCEEDED(hr))
    {
        if (_TrackPidl(_bbd._pidlCur, phistp, fIsOffline, szUrl, SIZECHARS(szUrl)))
        {
            if (_ptracking)
                _ptracking->OnUnload(szUrl);
            else
                hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (_TrackPidl(pidlNew, phistp, fIsOffline, szUrl, SIZECHARS(szUrl)))
        {    
            // instance of object already exists
            BRMODE brMode = BM_NORMAL;
            DWORD dwOptions;

            if (!_ptracking) 
            {
                _ptracking = new CUrlTrackingStg();
                if (!_ptracking)
                    hr = E_OUTOFMEMORY;
            }

            if (SUCCEEDED(hr))
            {
                hr = GetTopFrameOptions(_pspOuter, &dwOptions);
                if (SUCCEEDED(hr))
                {
                    //Is this a desktop component?                    
                    if (dwOptions & FRAMEOPTIONS_DESKTOP)
                        brMode = BM_DESKTOP;
                    //Is it fullscreen?                    
                    else if (dwOptions & (FRAMEOPTIONS_SCROLL_AUTO | FRAMEOPTIONS_NO3DBORDER))
                        brMode = BM_THEATER;
                }

                _ptracking->OnLoad(szUrl, brMode, FALSE);
            }
        }
    }

    phistp->Release();
}


HRESULT CBaseBrowser2::_SwitchActivationNow()
{
    ASSERT(_bbd._psvPending);

    WORD wNavTypeFlags = 0;  // init to suppress bogus C4701 warning

    IShellView* psvNew = _bbd._psvPending;
    IShellFolder* psfNew = _bbd._psfPending;
    HWND hwndViewNew = _bbd._hwndViewPending;
    LPITEMIDLIST pidlNew = _bbd._pidlPending;

    _bbd._fIsViewMSHTML = _IsViewMSHTML(psvNew);
    
    _bbd._psvPending = NULL;
    _bbd._psfPending = NULL;
    _bbd._hwndViewPending = NULL;
    _bbd._pidlPending = NULL;

    // Quickly check tracking prefix string on this page,
    // if turned on, log enter/exit events
    // Should use IsBrowserFrameOptionsSet(_bbd._psf, BFO_ENABLE_HYPERLINK_TRACKING)
    //     instead of IsURLChild() because it doesn't work in Folder Shortcuts and doesn't
    //     work in NSEs outside of the "IE" name space (like Web Folders).
    if ((_bbd._pidlCur && IsURLChild(_bbd._pidlCur, FALSE)) ||
        (pidlNew && IsURLChild(pidlNew, FALSE)))
        _MayTrackClickStream(pidlNew);

    // nuke the old stuff
    _pbsOuter->ReleaseShellView();
    
    ASSERT(!_bbd._psv && !_bbd._psf && !_bbd._hwndView);

    // activate the new stuff
    if (_grfHLNFPending != (DWORD)-1) 
    {
        _OnNavigateComplete(pidlNew, _grfHLNFPending);
    }

    VALIDATEPENDINGSTATE();

    // now do the actual switch

    // no need to addref because we're keeping the pointer and just chaning
    // it from the pending to the current member variables
    _bbd._psf = psfNew;
    _bbd._psv = psvNew; 

    ILFree(_bbd._pidlCur);
    _bbd._pidlCur = pidlNew;

    DEBUG_CODE(TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];)
    DEBUG_CODE(IEGetDisplayName(_bbd._pidlCur, szPath, SHGDN_FORPARSING);)
    DEBUG_CODE(TraceMsg(DM_TRACE, "CBB::ActivatePendingView (TRAVELLOG): _UpdateTravelLog called from shdocvw for %ws", szPath);)

    _bbd._hwndView = hwndViewNew;
    _dwReadyStateCur = _dwReadyStatePending;

    if (_bbd._pszTitleCur)
        LocalFree(_bbd._pszTitleCur);
    _bbd._pszTitleCur = _bbd._pszTitlePending;
    _bbd._pszTitlePending = NULL;

    if (_eSecureLockIconPending != SECURELOCK_NOCHANGE)
    {
        _bbd._eSecureLockIcon = _eSecureLockIconPending;
        _eSecureLockIconPending = SECURELOCK_NOCHANGE;
    }

    //
    //  This is the best time to resize the newone.
    //
    _pbsOuter->_UpdateViewRectSize();
    SetWindowPos(_bbd._hwndView, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

    // WARNING: Not all shellview supports IOleCommandTarget!!!
    _fUsesPaletteCommands = FALSE;
    
    if ( _bbd._psv )
    {
        _bbd._psv->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_bbd._pctView));

        // PALETTE: Exec down to see if they support the colors changes Command so that we don't have to 
        // PALETTE: wire ourselves into the OnViewChange mechanism just to get palette changes...
        if ( _bbd._pctView && 
             SUCCEEDED(_bbd._pctView->Exec( &CGID_ShellDocView, SHDVID_CANDOCOLORSCHANGE, 0, NULL, NULL)))
        {
            _fUsesPaletteCommands = TRUE;

            // force a colors dirty to make sure that we check for a new palette for each page...
            _ColorsDirty( BPT_UnknownPalette );
        }
    }

    // PALETTE: only register for the OnViewChange stuff if the above exec failed...
    if (SUCCEEDED(_bbd._psv->QueryInterface(IID_PPV_ARG(IViewObject, &_pvo))) && !_fUsesPaletteCommands )
        _pvo->SetAdvise(DVASPECT_CONTENT, ADVF_PRIMEFIRST, this);

    _Exec_psbMixedZone();

    if (_bbd._pctView != NULL)
    {
        _bbd._pctView->Exec(&CGID_ShellDocView, SHDVID_RESETSTATUSBAR, 0, NULL, NULL);
    }

    return S_OK;
}

// This member is called when we about to destroy the current shell view.
// Returning S_FALSE indicate that the user hit CANCEL when it is prompted
// to save the changes (if any).

HRESULT CBaseBrowser2::_MaySaveChanges(void)
{
    HRESULT hres = S_OK;
    if (_bbd._pctView) // we must check!
    {
        hres = _bbd._pctView->Exec(&CGID_Explorer, SBCMDID_MAYSAVECHANGES,
                            OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
    }
    return hres;
}

HRESULT CBaseBrowser2::_DisableModeless(void)
{
    if (_cRefCannotNavigate == 0)
    {
        OLECMD rgCmd;
        BOOL fPendingInScript = FALSE;

        //  if pending shell view supports it, give it a chance to tell us it's not ready
        //  to deactivate [eg executing a script].  normally scripts should not be run
        //  before inplace activation, but TRIDENT sometimes has to do this when parsing.
        //
        rgCmd.cmdID = SHDVID_CANDEACTIVATENOW;
        rgCmd.cmdf = 0;

        if (SUCCEEDED(IUnknown_QueryStatus(_bbd._psvPending, &CGID_ShellDocView, 1, &rgCmd, NULL)) &&
            (rgCmd.cmdf & MSOCMDF_SUPPORTED) &&
            !(rgCmd.cmdf & MSOCMDF_ENABLED))
        {
            fPendingInScript = TRUE;
        }

        if (!fPendingInScript) 
        {
            return S_FALSE;
        }
    }
    return S_OK;
}

BOOL CBaseBrowser2::_CanNavigate(void)
{
    return !((_DisableModeless() == S_OK) || (! IsWindowEnabled(_bbd._hwnd)));
}

HRESULT CBaseBrowser2::CanNavigateNow(void)
{
    return _CanNavigate() ? S_OK : S_FALSE;
}

HRESULT CBaseBrowser2::_PauseOrResumeView(BOOL fPaused)
{
    // If fPaused (it's minimized or the parent is minimized) or
    // _bbd._psvPending is non-NULL, we need to pause.
    if (_bbd._pctView) 
    {
        VARIANT var = { 0 };
        var.vt = VT_I4;
        var.lVal = (_bbd._psvPending || fPaused) ? FALSE : TRUE;
        _bbd._pctView->Exec(NULL, OLECMDID_ENABLE_INTERACTION, OLECMDEXECOPT_DONTPROMPTUSER, &var, NULL);
    }

    return S_OK;
}

HRESULT CBaseBrowser2::CreateViewWindow(IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd)
{
    _fCreateViewWindowPending = TRUE;
    _pbsOuter->GetFolderSetData(&(_fldBase._fld)); // it's okay to stomp on this every time

    HRESULT hres = FileCabinet_CreateViewWindow2(_psbOuter, &_fldBase, psvNew, psvOld, prcView, phwnd);

    _fCreateViewWindowPending = FALSE;
    return hres;
}


//
// grfHLNF == (DWORD)-1 means don't touch the history at all.
//
// NOTE:
// if _fCreateViewWindowPending == TRUE, it means we came through here once
// already, but we are activating a synchronous view and the previous view would
// not deactivate immediately...
// It is used to delay calling IShellView::CreateViewWindow() for shell views until we know that
// we can substitute psvNew for _bbd._psv.
//
HRESULT CBaseBrowser2::_CreateNewShellView(IShellFolder* psf, LPCITEMIDLIST pidl, DWORD grfHLNF)
{
    BOOL fActivatePendingView = FALSE;
    IShellView *psvNew = NULL;

    // Bail Out of Navigation if modal windows are up from our view
    // Should we restart navigation on next EnableModeless(TRUE)?
    if (!_CanNavigate())
    {
        TraceMsg(DM_ENABLEMODELESS, "CSB::_CreateNewShellView returning ERROR_BUSY");
        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }
        
    HRESULT hres = _MaySaveChanges();
    if (hres == S_FALSE)
    {
        TraceMsg(DM_WARNING, "CBB::_CreateNewShellView _MaySaveChanges returned S_FALSE. Navigation canceled");
        return HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }

    TraceMsg(DM_WARNING, "CBB::_CNSV - Cur View MSHTML? %d  Pending View MSHTML? %d",
             _IsViewMSHTML(_bbd._psv), _IsViewMSHTML(_bbd._psvPending));

    VALIDATEPENDINGSTATE();

#ifndef NON_NATIVE_FRAMES

    // The navigation has been interrupted.
    //
    if (   _bbd._psv
        && _bbd._psvPending
        && _IsViewMSHTML(_bbd._psvPending))
    {
        _fHtmlNavCanceled = TRUE;
    }

#endif

    _CancelPendingView();

    ASSERT (_fCreateViewWindowPending == FALSE);

    VALIDATEPENDINGSTATE();

    if (_bbd._psv && _IsViewMSHTML(_bbd._psv))
    {
        ATOMICRELEASE(_pphHistory);
        SafeGetItemObject(_bbd._psv, SVGIO_BACKGROUND, IID_PPV_ARG(IPersistHistory, &_pphHistory));
    }

    hres = psf->CreateViewObject(_bbd._hwnd, IID_PPV_ARG(IShellView, &psvNew));

    if (SUCCEEDED(hres))
    {
        _bbd._fCreatingViewWindow = TRUE;

        IUnknown_SetSite(psvNew, _psbOuter);    // SetSite for the view

        _psbOuter->EnableModelessSB(FALSE);
    
        HWND hwndViewNew = NULL;
        RECT rcView;

        //
        // NOTES: SatoNa
        //
        //  Notice that we explicitly call _GetViewBorderRect (non-virtual)
        // instead of virtual _GetShellView, which CShellBrowser override.
        // We now call thru (virtual) _pbsOuter, is this o.k.?
        //
        _pbsOuter->_GetViewBorderRect(&rcView);

        // It is ncecessary for _bbd._pidlPending and _bbd._psvPending to both be set together.
        // they're  a pair
        // previously _bbd._pidlPending was being set after the call to
        // FileCabinet_CreateViewWindow and when messages were pumped there  [NOTE: messages should not have been pumped there...]
        // a redirect would be nofied in the bind status callback.
        // this meant that a valid _bbd._pidlPending was actually available BUT
        // then we would return and blow away that _bbd._pidlPending
        //
        ASSERT(_bbd._psvPending == NULL );
        _bbd._psvPending = psvNew;
        psvNew->AddRef();

        ASSERT(_bbd._psfPending == NULL);
        ASSERT(_bbd._pidlPending == NULL);

        _bbd._psfPending = psf;
        psf->AddRef();

        _bbd._pidlPending = ILClone(pidl);

        // Initialize _bbd._pidlNewShellView which will be used by GetViewStateStream
        _bbd._pidlNewShellView = pidl;
        _grfHLNFPending = grfHLNF;

        // Start at _COMPLETE just in case the object we connect
        // to doesn't notify us of ReadyState changes
        //
        _dwReadyStatePending = READYSTATE_COMPLETE;

        // We need to cache this information here because the _dwDocFlags
        // can change during the call to CreateViewWindow. This information
        // is needed to determine whether or not we should stop the current
        // view. If the document does not know how to navigate, then we
        // stop the current view. The is needed in order to stop the 
        // navigation in the current view when a new navigation has started.
        //
        BOOL fDocCanNavigate = _dwDocFlags & DOCFLAG_DOCCANNAVIGATE;

        hres = _pbsOuter->CreateViewWindow(psvNew, _bbd._psv, &rcView, &hwndViewNew);

        IUnknown_SetSite(psvNew, NULL); // The view by now must have psb

        _bbd._pidlNewShellView = NULL;

        TraceMsg(DM_NAV, "ief NAV::%s %x %x",TEXT("_CreateNewShellView(3) Called CreateViewWindow"), psvNew, hres);

        if (SUCCEEDED(hres))
        {
            // we defer the _PauseOrResumeView until here when we have enough
            // info to know if it's a new page or not.  o.w. we end up (e.g.)
            // stopping bgsounds etc. on local links (nash:32270).
#ifdef NON_NATIVE_FRAMES
            // 
            // Note (scotrobe): This was a no-op in IE5.
            //
            _PauseOrResumeView(_fPausedByParent);
            
            // We stop the current view because we need to flush away any image stuff that
            // is in queue so that the actual html file can get downloaded
            //
            _StopCurrentView();
#endif

            // We can't stop the current view if the doc knows how
            // to navigate. This is because in that case, the document
            // in current view is the same document as the pending view.
            //
            if (!fDocCanNavigate)
            {
                _StopCurrentView();
            }

            _bbd._hwndViewPending = hwndViewNew;

            // chrisfra - if hres == S_FALSE this (calling ActivatePendingViewAsync
            // when _bbd._psv==NULL) will break async URL download
            // as it will cause _bbd._psvPending to be set to NULL prematurely.  this should
            // be deferred until CDocObjectView::CBindStatusCallback::OnObjectAvailable
            //if (hres==S_OK || _bbd._psv==NULL)
            
            ASSERT(( hres == S_OK ) || ( hres == S_FALSE ));
            
            if (hres == S_OK)
            {
                // We should activate synchronously.
                //
                // NOTE: This used to be ActivatePendingViewAsyc(), but that causes a
                // fault if you navigated to C:\ and click A:\ as soon as it appears. This
                // puts the WM_LBUTTONDOWN in FRONT of the WMC_ASYNCOPERATION message. If
                // there's no disk in drive A: then a message box appears while in the
                // middle of the above FileCabinet_CreateViewWindow call and we pull off
                // the async activate and activate the view we're in the middle of
                // creating! Don't do that.
                //
                fActivatePendingView = TRUE;
            }
            else
            {
                // Activation is pending.
                // since the back button works as a stop on pending navigations, we
                // should check that here as well.
                _pbsOuter->UpdateBackForwardState();
            }
        }
        else
        {
            if (   _bbd._psvPending
                && !(_dwDocFlags & DOCFLAG_NAVIGATEFROMDOC)
                && _IsViewMSHTML(_bbd._psvPending))
            {
                _fHtmlNavCanceled = TRUE;
            }
            else
            {
                _fHtmlNavCanceled = FALSE;
            }

            TraceMsg(DM_WARNING, "ief _CreateNewShellView psvNew->CreateViewWindow failed %x", hres);
            _CancelPendingView();
        }

        psvNew->Release();

        if (_psbOuter)
            _psbOuter->EnableModelessSB(TRUE);
    }
    else
    {
        TraceMsg(TF_WARNING, "ief _BrowseTo psf->CreateViewObject failed %x", hres);
    }

    _fHtmlNavCanceled = FALSE;

    //
    //  If there is any blocked async operation AND we can navigate now,
    // unblock it now. 
    //
    _MayUnblockAsyncOperation();

    _bbd._fCreatingViewWindow = FALSE;

    VALIDATEPENDINGSTATE();

    TraceMsg(DM_WARNING, "CBB::_CNSV - Cur View MSHTML? %d  Pending View MSHTML? %d",
             _IsViewMSHTML(_bbd._psv), _IsViewMSHTML(_bbd._psvPending));

    if (fActivatePendingView && !_IsViewMSHTML(_bbd._psvPending))
    {
        //
        // Since _IsViewMSHTML can delegate to a marshalled interface,
        // we can get re-entrancy.  On re-entrancy, we can do a 
        // _CancelPendingView in which case _bbd._psvPending is 
        // no longer valid.
        //
        // So, we need to see if we still have _hbd._psvPending here.  
        //

        if (_bbd._psvPending)
        {
            _PreActivatePendingViewAsync(); // so we match old code

            hres = _pbsOuter->ActivatePendingView();
            if (FAILED(hres))
                TraceMsg(DM_WARNING, "CBB::_CNSV ActivatePendingView failed");
        }
    }

    TraceMsg(DM_STARTUP, "ief _CreateNewShellView returning %x", hres);
    return hres;
}

//  private bind that is very loose in its bind semantics.
HRESULT IEBindToObjectForNavigate(LPCITEMIDLIST pidl, IBindCtx * pbc, IShellFolder **ppsfOut);

// this binds to the pidl folder then hands off to CreateNewShellView
// if you have anything you need to do like checking before we allow the navigate, it
// should go into _NavigateToPidl
HRESULT CBaseBrowser2::_CreateNewShellViewPidl(LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD fSBSP)
{
    SetNavigateState(BNS_BEGIN_NAVIGATE);

    TraceMsg(DM_NAV, "ief NAV::%s %x %x",TEXT("_CreateNewShellViewPidl not same pidl"), pidl, _bbd._pidlCur);

    // Check for URL-pidl?

    // We will allow UI to be displayed by passing this IBindCtx to IShellFolder::BindToObject().
    IBindCtx * pbc = NULL;
    IShellFolder* psf;
    HRESULT hres;

    pbc = CreateBindCtxForUI(SAFECAST(this, IShellBrowser*));    // I'm safecasting to IUnknown.  IShellBrowser is only for disambiguation.
    hres = IEBindToObjectForNavigate(pidl, pbc, &psf);   // If pbc is NULL, we will survive.

    if (SUCCEEDED(hres))
    {
        hres = _CreateNewShellView(psf, pidl, grfHLNF);
        TraceMsg(DM_STARTUP, "CSB::_CreateNewShellViewPidl _CreateNewShellView(3) returned %x", hres);
        psf->Release();
    }
    else
    {
        // This will happen when a user tries to navigate to a directory past
        // MAX_PATH by double clicking on a subdirectory in the shell.
        TraceMsg(DM_TRACE, "CSB::_CreateNSVP BindToOject failed %x", hres);
    }

    
    // If _CreateNewShellView (or IEBindToObject) fails or the user cancels
    // the MayOpen dialog (hres==S_FALSE), we should restore the navigation
    // state to NORMAL (to stop animation). 
    if (FAILED(hres))
    {
        TraceMsg(TF_SHDNAVIGATE, "CSB::_CreateNSVP _CreateNewShellView FAILED (%x). SetNavigateState to NORMAL", hres);
        SetNavigateState(BNS_NORMAL);
    }

    ATOMICRELEASE(pbc);
    TraceMsg(DM_STARTUP, "CSB::_CreateNewShellViewPidl returning %x", hres);
    return hres;
}

//
// Returns the border rectangle for the shell view.
//
HRESULT CBaseBrowser2::_GetViewBorderRect(RECT* prc)
{
    _pbsOuter->_GetEffectiveClientArea(prc, NULL);  // hmon?
    // (derived class subtracts off border taken by all "frame" toolbars)
    return S_OK;
}

//
// Returns the window rectangle for the shell view window.
//
HRESULT CBaseBrowser2::GetViewRect(RECT* prc)
{
    //
    // By default (when _rcBorderDoc is empty), ShellView's window
    // rectangle is the same as its border rectangle.
    //
    _pbsOuter->_GetViewBorderRect(prc);

    // Subtract document toolbar margin
    prc->left += _rcBorderDoc.left;
    prc->top += _rcBorderDoc.top;
    prc->right -= _rcBorderDoc.right;
    prc->bottom -= _rcBorderDoc.bottom;

    TraceMsg(DM_UIWINDOW, "ief GetViewRect _rcBorderDoc=%x,%x,%x,%x",
             _rcBorderDoc.left, _rcBorderDoc.top, _rcBorderDoc.right, _rcBorderDoc.bottom);
    TraceMsg(DM_UIWINDOW, "ief GetViewRect prc=%x,%x,%x,%x",
             prc->left, prc->top, prc->right, prc->bottom);

    return S_OK;
}

HRESULT CBaseBrowser2::_PositionViewWindow(HWND hwnd, LPRECT prc)
{
    SetWindowPos(hwnd, NULL,
                 prc->left, prc->top, 
                 prc->right - prc->left, 
                 prc->bottom - prc->top,
                 SWP_NOZORDER | SWP_NOACTIVATE);

    return S_OK;
}

void CBaseBrowser2::_PositionViewWindowHelper(HWND hwnd, LPRECT prc)
{
    if (_pbsOuter3)
        _pbsOuter3->_PositionViewWindow(hwnd, prc);
    else
        _PositionViewWindow(hwnd, prc);
}

HRESULT CBaseBrowser2::_UpdateViewRectSize(void)
{
    RECT rc;

    TraceMsg(TF_SHDUIACTIVATE, "CSB::_UpdateViewRectSize called when _fDontReszeView=%d, _bbd._hwndV=%x, _bbd._hwndVP=%x",
             _fDontResizeView, _bbd._hwndView, _bbd._hwndViewPending);

    _pbsOuter->GetViewRect(&rc);

    if (_bbd._hwndView && !_fDontResizeView) 
    {
        TraceMsg(TF_SHDUIACTIVATE, "CSB::_UpdateViewRectSize resizing _bbd._hwndView(%x)", _bbd._hwndView);
        _PositionViewWindowHelper(_bbd._hwndView, &rc);
    }

    if (_bbd._hwndViewPending) 
    {
        TraceMsg(TF_SHDUIACTIVATE, "CSB::_UpdateViewRectSize resizing _bbd._hwndViewPending(%x)", _bbd._hwndViewPending);
        _PositionViewWindowHelper(_bbd._hwndViewPending, &rc);
    }
    return S_OK;
}

UINT g_idMsgGetAuto = 0;

// this stays in shdocvw because the OC requires drop target registration
void CBaseBrowser2::_RegisterAsDropTarget()
{
    // if it's okay to register and we haven't registered already
    // and we've processed WM_CREATE
    if (!_fNoDragDrop && !_fRegisteredDragDrop && _bbd._hwnd)
    {
        BOOL fAttemptRegister = _fTopBrowser ? TRUE : FALSE;

        // if we're not toplevel, we still try to register
        // if we have a proxy browser
        if (!fAttemptRegister)
        {
            IShellBrowser* psb;
            HRESULT hres = _pspOuter->QueryService(SID_SProxyBrowser, IID_PPV_ARG(IShellBrowser, &psb));
            if (SUCCEEDED(hres)) 
            {
                fAttemptRegister = TRUE;
                psb->Release();
            }
        }

        if (fAttemptRegister)
        {
            HRESULT hr;
            IDropTarget *pdt;

            // SAFECAST(this, IDropTarget*), the hard way
            hr = THR(QueryInterface(IID_PPV_ARG(IDropTarget, &pdt)));
            if (SUCCEEDED(hr)) 
            {
                hr = THR(RegisterDragDrop(_bbd._hwnd, pdt));
                if (SUCCEEDED(hr)) 
                {
                    _fRegisteredDragDrop = TRUE;
                }
                pdt->Release();
            }
        }
    }
}

void CBaseBrowser2::_UnregisterAsDropTarget()
{
    if (_fRegisteredDragDrop)
    {
        _fRegisteredDragDrop = FALSE;
        
        THR(RevokeDragDrop(_bbd._hwnd));
    }
}


HRESULT CBaseBrowser2::OnCreate(LPCREATESTRUCT pcs)
{
    HRESULT hres;
    TraceMsg(DM_STARTUP, "_OnCreate called");

    if (g_idMsgGetAuto == 0)
        g_idMsgGetAuto = RegisterWindowMessage(TEXT("GetAutomationObject"));

    hres = InitPSFInternet();

    // do stuff that depends on window creation
    if (SUCCEEDED(hres))
    {
        // this must be done AFTER the ctor so that we get virtuals right
        // NOTE: only do this if we're actually creating the window, because
        //       the only time we SetOwner(NULL) is OnDestroy.
        //
        _bbd._pautoSS->SetOwner(SAFECAST(this, IShellBrowser*));
    
        _RegisterAsDropTarget();
    }

    TraceMsg(DM_STARTUP, "ief OnCreate returning %d (SUCCEEDED(%x))", SUCCEEDED(hres), hres);

    return SUCCEEDED(hres) ? S_OK : E_FAIL;
}

HRESULT CBaseBrowser2::OnDestroy()
{
    //  We're seeing some reentrancy here.  If _cRefCannotNavigate is non-zero, it means we're
    //  in the middle of something and shouldn't destroy ourselves.
    //

    //  Also check reentrant calls to OnDestroy().
    if (_fInDestroy)
    {
        // Already being destroyed -- bail out.
        return S_OK;
    }

    _fInDestroy = TRUE;

    if (_cRefUIActivateSV)
    {
        TraceMsg(TF_WARNING, 
            "CBB(%x)::OnDestroy _cRefUIActivateSV(%d)!=0", 
            this, _cRefUIActivateSV);

        // I need to defer my self-destruction.
        //
        _fDeferredSelfDestruction = TRUE;
        return S_OK;
    }

    _CancelPendingView();
    _pbsOuter->ReleaseShellView();
    
#ifdef DEBUG
    // It is valid for _cRefCannotNavigate > 0 if we the system is shutting down. The reason
    // for this is that we can still be processing a call to ::CreateNewShellView() when we
    // the desktop recieves the WM_ENDSESSION and destroys us. In this case its ok to proceed
    // with the destroy in this case, since we are logging off or rebooting anyway.
    AssertMsg(_fMightBeShuttingDown || (S_FALSE == _DisableModeless()),
              TEXT("CBB::OnDestroy _cRefCannotNavigate!=0 (%d)"),
              _cRefCannotNavigate);
#endif

    ATOMICRELEASE(_bbd._ptl);

    // This should always be successful because the IDropTarget is registered 
    // in _OnCreate() and is the default one.
    // _pdtView should have already been released in ReleaseShellView
    ASSERT(_pdtView == NULL);

    _UnregisterAsDropTarget();
    //
    //  It is very important to call _bbd._pauto->SetOwner(NULL) here, which will
    // remove any reference from the automation object to us. Before doing
    // it, we always has cycled references and we never be released.
    //
    _bbd._pautoSS->SetOwner(NULL);

    _bbd._hwnd = NULL;

#ifdef DEBUG
    _fProcessed_WM_CLOSE = TRUE;
#endif
    _DLMDestroy();
    IUnknown_SetSite(_pToolbarExt, NULL); // destroy the toolbar extensions

    if (_pauto)
    {
        IWebBrowserPriv * pWBPriv;

        HRESULT hr = _pauto->QueryInterface(IID_PPV_ARG(IWebBrowserPriv, &pWBPriv));
        if (SUCCEEDED(hr))
        {
            pWBPriv->OnClose();
            pWBPriv->Release();
        }
    }

    ATOMICRELEASE(_pHTMLDocument);
    ATOMICRELEASE(_pphHistory);

    return S_OK;
}

HRESULT CBaseBrowser2::NavigateToPidl(LPCITEMIDLIST pidl, DWORD grfHLNF)
{
    HRESULT hr = S_OK;

    LPITEMIDLIST pidlNew = (LPITEMIDLIST)pidl;

    //
    //  Need to handle going back to an outside app - zekel 7MAY97
    //  i have dumped the code that did this, so now i need to put it
    //  into the CTravelLog implementation, so that it will be done properly
    //  without us.  but it shouldnt be done here regardless.
    //

    //  Remove? - with the old Travellog code
    // special case hack for telling us to use the local history, not
    // the global history
    if (pidl && pidl != PIDL_LOCALHISTORY)
        pidlNew = ILClone(pidl);

    //
    // Fortunately the only callers of NavigateToPidl use HLNF_NAVIGATINGBACK/FORWARD
    // so that's the only mapping we need to do here.
    //
    DWORD dwSBSP = 0;
    if (grfHLNF != (DWORD)-1)
    {
        if (grfHLNF & SHHLNF_WRITENOHISTORY)
            dwSBSP |= SBSP_WRITENOHISTORY;
        if (grfHLNF & SHHLNF_NOAUTOSELECT)
            dwSBSP |= SBSP_NOAUTOSELECT;
    }
    if (grfHLNF & HLNF_NAVIGATINGBACK)
        dwSBSP = SBSP_NAVIGATEBACK;
    else if (grfHLNF & HLNF_NAVIGATINGFORWARD)
        dwSBSP = SBSP_NAVIGATEFORWARD;

    if (dwSBSP)
    {
        if (_psbOuter)
        {
            hr = _psbOuter->BrowseObject(pidlNew, dwSBSP);  // browse will do the nav here.
        }

        ILFree(pidlNew);
    }
    else
        _NavigateToPidlAsync(pidlNew, dwSBSP, FALSE);  // takes ownership of the pidl
    
    return hr;
}

// S_OK means we found at least one valid connection point
//
HRESULT GetWBConnectionPoints(IUnknown* punk, IConnectionPoint **ppcp1, IConnectionPoint **ppcp2)
{
    HRESULT           hres = E_FAIL;
    IExpDispSupport*  peds;
    CConnectionPoint* pccp1 = NULL;
    CConnectionPoint* pccp2 = NULL;
    
    if (ppcp1)
        *ppcp1 = NULL;
    if (ppcp2)
        *ppcp2 = NULL;

    if (punk && SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IExpDispSupport, &peds))))
    {
        if (ppcp1 && SUCCEEDED(peds->FindCIE4ConnectionPoint(DIID_DWebBrowserEvents,
                                                reinterpret_cast<CIE4ConnectionPoint**>(&pccp1))))
        {
            *ppcp1 = pccp1->CastToIConnectionPoint();
            hres = S_OK;
        }

        if (ppcp2 && SUCCEEDED(peds->FindCIE4ConnectionPoint(DIID_DWebBrowserEvents2,
                                                reinterpret_cast<CIE4ConnectionPoint**>(&pccp2))))
        {
            *ppcp2 = pccp2->CastToIConnectionPoint();
            hres = S_OK;
        }
            
        peds->Release();
    }

    return hres;
}

void CBaseBrowser2::_UpdateBackForwardState()
{
    if (_fTopBrowser && !_fNoTopLevelBrowser) 
    {
        IConnectionPoint *pccp1;
        IConnectionPoint *pccp2;

        if (S_OK == GetWBConnectionPoints(_bbd._pautoEDS, &pccp1, &pccp2))
        {
            HRESULT hresT;
            VARIANTARG va[2];
            DISPPARAMS dp;
            ITravelLog *ptl;

            GetTravelLog(&ptl);

            // if we've got a site or if we're trying to get to a site,
            // enable the back button
            BOOL fEnable = (ptl ? S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_BACK, NULL) : FALSE);
                
            VARIANT_BOOL bEnable = fEnable ? VARIANT_TRUE : VARIANT_FALSE;
            TraceMsg(TF_TRAVELLOG, "CBB::UpdateBackForward BACK = %d", fEnable);

            // We use SHPackDispParams once instead of calling DoInvokeParams multiple times...
            //
            hresT = SHPackDispParams(&dp, va, 2, VT_I4, CSC_NAVIGATEBACK, VT_BOOL, bEnable);
            ASSERT(S_OK==hresT);

            // Removed the following EnableModelessSB(FALSE) because VB5 won't run the event handler if
            // we're modal.
            // _psbOuter->EnableModelessSB(FALSE);

            IConnectionPoint_SimpleInvoke(pccp1, DISPID_COMMANDSTATECHANGE, &dp);
            IConnectionPoint_SimpleInvoke(pccp2, DISPID_COMMANDSTATECHANGE, &dp);

            fEnable = (ptl ? S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_FORE, NULL) : FALSE);
            bEnable = fEnable ? VARIANT_TRUE : VARIANT_FALSE;
            TraceMsg(TF_TRAVELLOG, "CBB::UpdateBackForward FORE = %d", fEnable);

            ATOMICRELEASE(ptl);
            // We know how SHPackDispParams fills in va[]
            ASSERT(VT_BOOL == va[0].vt);
            va[0].boolVal = bEnable;
            ASSERT(VT_I4 == va[1].vt);
            va[1].lVal = CSC_NAVIGATEFORWARD;

            IConnectionPoint_SimpleInvoke(pccp1, DISPID_COMMANDSTATECHANGE, &dp);
            IConnectionPoint_SimpleInvoke(pccp2, DISPID_COMMANDSTATECHANGE, &dp);
            ATOMICRELEASE(pccp1);
            ATOMICRELEASE(pccp2);

            // Removed the following _psbOuter->EnableModelessSB(TRUE) because VB5 won't run the event handler if
            // we're modal.
            // _psbOuter->EnableModelessSB(TRUE);
        }
    }
}

void CBaseBrowser2::_NotifyCommandStateChange()
{
    HRESULT hr;

    // I'm only firing these in the toplevel case
    // Why? Who cares about the frameset case
    // since nobody listens to these events on
    // the frameset.
    //
    if (_fTopBrowser && !_fNoTopLevelBrowser) 
    {
        IConnectionPoint * pccp1;
        IConnectionPoint * pccp2;

        if (S_OK == GetWBConnectionPoints(_bbd._pautoEDS, &pccp1, &pccp2))
        {
            ASSERT(pccp1 || pccp2); // Should've gotten at least one

            VARIANTARG args[2];
            DISPPARAMS dp;

            hr = SHPackDispParams(&dp, args, 2,
                                  VT_I4,   CSC_UPDATECOMMANDS,
                                  VT_BOOL, FALSE);

            IConnectionPoint_SimpleInvoke(pccp1, DISPID_COMMANDSTATECHANGE, &dp);
            IConnectionPoint_SimpleInvoke(pccp2, DISPID_COMMANDSTATECHANGE, &dp);

            ATOMICRELEASE(pccp1);
            ATOMICRELEASE(pccp2);
        }
    }
}


LRESULT CBaseBrowser2::OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    HWND hwndControl = GET_WM_COMMAND_HWND(wParam, lParam);
    if (IsInRange(idCmd, FCIDM_SHVIEWFIRST, FCIDM_SHVIEWLAST))
    {
        if (_bbd._hwndView)
            SendMessage(_bbd._hwndView, WM_COMMAND, wParam, lParam);
        else
            TraceMsg(0, "view cmd id with NULL view");

        /// REVIEW - how can we get FCIDM_FAVORITECMD... range if we're NOT toplevelapp?
        /// REVIEW - should RecentOnCommand be done this way too?
    }
    
    return S_OK;
}


LRESULT CBaseBrowser2::OnNotify(LPNMHDR pnm)
{
    // the id is from the view, probably one of the toolbar items

    if (IsInRange(pnm->idFrom, FCIDM_SHVIEWFIRST, FCIDM_SHVIEWLAST))
    {
        if (_bbd._hwndView)
            SendMessage(_bbd._hwndView, WM_NOTIFY, pnm->idFrom, (LPARAM)pnm);
    }
    return 0;
}

HRESULT CBaseBrowser2::OnSetFocus()
{
    if (_bbd._hwndView) 
    {
        SetFocus(_bbd._hwndView);
    } 
    return 0;
}


#define ABOUT_HOME L"about:home"
// This function is VERY focused on achieving what the
// caller wants.  That's why it has a very specific
// meaning to the return value.
BOOL IsAboutHomeOrNonAboutURL(LPITEMIDLIST pidl)
{
    BOOL fIsAboutHomeOrNonAboutURL = TRUE;
    WCHAR wzCur[MAX_URL_STRING];

    if (pidl && SUCCEEDED(IEGetDisplayName(pidl, wzCur, SHGDN_FORPARSING)))
    {        
        // Is it "about:home"?
        if (0 != StrCmpNICW(ABOUT_HOME, wzCur, ARRAYSIZE(ABOUT_HOME) - 1))
        {
            // No.  We also want to return TRUE if the scheme was NOT an ABOUT URL.
            fIsAboutHomeOrNonAboutURL = (URL_SCHEME_ABOUT != GetUrlSchemeW(wzCur));
        }
    }

    return fIsAboutHomeOrNonAboutURL;            
}

//
// This function activate the pending view synchronously.
//
HRESULT CBaseBrowser2::ActivatePendingView(void)
{
    HRESULT hres = E_FAIL;
    BOOL bHadFocus;

    TraceMsg(TF_SHDNAVIGATE, "CBB::ActivatePendingView called");

    if (!_bbd._psvPending || !_bbd._psfPending)
    {
#ifdef DEBUG
        // it is valid for these to be null if we are shutting down b/c the desktop
        // could have destroyed us, which would have called ::OnDestroy which calls _CancelPendingView
        // which releases and nulls out _bbd._psvPending and _bbd._psfPending
        ASSERT(_fMightBeShuttingDown);
#endif
        goto Done;
    }

#ifndef NON_NATIVE_FRAMES

    IUnknown_Exec(_bbd._psvPending, &CGID_ShellDocView, SHDVID_COMPLETEDOCHOSTPASSING, 0, NULL, NULL);

#endif

#ifdef FEATURE_PICS
    if (S_FALSE == IUnknown_Exec(_bbd._psvPending, &CGID_ShellDocView, SHDVID_CANACTIVATENOW, NULL, NULL, NULL))
    {
        hres = S_OK;    // still waiting . . . but no failure.
        goto DoneWait;
    }
#endif
    
    //  if we are in modal loop, don't activate now
    if (_cRefCannotNavigate > 0)
    {
        goto Done;
    }

    // if _cRefCannotNavigate > 0 it is possible that _hwndViewPending has not been created so this assert 
    // should go after the check above
    ASSERT(_bbd._hwndViewPending);
    
    //  if shell view supports it, give it a chance to tell us it's not ready
    //  to deactivate [eg executing a script]
    //
    OLECMD rgCmd;
    rgCmd.cmdID = SHDVID_CANDEACTIVATENOW;
    rgCmd.cmdf = 0;
    if (_bbd._pctView &&
        SUCCEEDED(_bbd._pctView->QueryStatus(&CGID_ShellDocView, 1, &rgCmd, NULL)) &&
        (rgCmd.cmdf & MSOCMDF_SUPPORTED) &&
        !(rgCmd.cmdf & MSOCMDF_ENABLED)) 
    {
        //
        //  The DocObject that reported MSOCMDF_SUPPORTED must send
        //  SHDVID_DEACTIVATEMENOW when we're out of scripts or whatever so that
        //  we retry the activate
        //
        TraceMsg(DM_WARNING, "CBB::ActivatePendingView DocObject says I can't deactivate it now");
        goto Done;
    }

    ASSERT(_bbd._psvPending);

    // Prevent any navigation while we have the pointers swapped and we're in
    // delicate state
    _psbOuter->EnableModelessSB(FALSE);

    //
    // Don't play sound for the first navigation (to avoid multiple
    // sounds to be played for a frame-set creation).
    //
    if (_bbd._psv && IsWindowVisible(_bbd._hwnd) && !(_dwSBSPQueued & SBSP_WRITENOHISTORY)) 
    {
        IEPlaySound(TEXT("ActivatingDocument"), FALSE);
    }

    ASSERT(_bbd._psvPending);

    //  NOTE: if there are any other protocols that need to not be in 
    //  the travel log, it should probably implemented through UrlIs(URLIS_NOTRAVELLOG)
    //  right now, About: is the only one we care about
    //
    // Note that with the native frames changes, if we don't have
    // a psv, we will want to call _UpdateTravelLog because that is
    // where the first travel entry is added.
    //
    if (!(_grfHLNFPending & HLNF_CREATENOHISTORY) && 
        (!_bbd._psv || IsAboutHomeOrNonAboutURL(_bbd._pidlCur))
        && !_fDontUpdateTravelLog)
    {
        DEBUG_CODE(TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];)
        DEBUG_CODE(IEGetDisplayName(_bbd._pidlCur, szPath, SHGDN_FORPARSING);)
        DEBUG_CODE(TraceMsg(DM_TRACE, "CBB::ActivatePendingView (TRAVELLOG): _UpdateTravelLog called from shdocvw for %ws", szPath);)

        _UpdateTravelLog();
    }

    //  WARNING - these will only fail if the UpdateTravelLog() - zekel - 7-AUG-97
    //  was skipped and these bits are set.

    //  alanau 5-may-98 -- I still hit this assert on a script-based navigate to the same page.
    //      iedisp.cpp sees StrCmpW("about:blank","about:blank?http://www.microsoft.com/ie/ie40/gallery/_main.htm") 
    //      (for example), but basesb.cpp sees two equal pidls (both "about:blank?http://...").
    //      Killing this assert.
    // ASSERT(!_fDontAddTravelEntry);
    //
    //  scotrobe 11-Aug-99 If the hosted document is able to
    //  navigate itself, _UpdateTravelLog() will never be called.
    //
    ASSERT((_dwDocFlags & DOCFLAG_DOCCANNAVIGATE) || !_fIsLocalAnchor);

    // before we destroy the window check if it or any of its childern has focus
    bHadFocus =     _bbd._hwndView && (IsChildOrSelf(_bbd._hwndView, GetFocus()) == S_OK)
                ||  _bbd._hwndViewPending && (IsChildOrSelf(_bbd._hwndViewPending, GetFocus()) == S_OK);

    _pbsOuter->_SwitchActivationNow();

    _psbOuter->EnableModelessSB(TRUE);

    TraceMsg(DM_NAV, "CBaseBrowser2(%x)::ActivatePendingView(%x)", this, _bbd._psv);

    // if some other app has focus, then don't uiactivate this navigate
    // or we'll steal focus away. we'll uiactivate when we next get activated
    //
    // ie4.01, bug#64630 and 64329
    // _fActive only gets set by WM_ACTIVATE on the TopBrowser.  so for subframes
    // we always defer setting the focus if they didnt have focus before navigation.
    // the parent frame should set the subframe as necessary when it gets 
    //  its UIActivate.   - ReljaI 4-NOV-97
    if (SVUIA_ACTIVATE_FOCUS == _bbd._uActivateState && !(_fActive || bHadFocus))
    {
        _bbd._uActivateState = SVUIA_INPLACEACTIVATE;
        _fUIActivateOnActive = TRUE;
    }
    
    _UIActivateView(_bbd._uActivateState);

    // Tell the shell's HTML window we have a new document.
    if (_phtmlWS)
    {
        _phtmlWS->ViewActivated();
    }

    // this matches the _bbd._psvPending = NULL above.
    // we don't put this right beside there because the
    // _SwitchActivationNow could take some time, as well as the DoInvokePidl

    SetNavigateState(BNS_NORMAL);

    _pbsOuter->UpdateBackForwardState();
    _NotifyCommandStateChange();

    if (!_fNoDragDrop && _fTopBrowser)
    {
        ASSERT(_bbd._psv);
        // _SwitchActivationNow should have already released the old _pdtView and set it to NULL
        ASSERT(_pdtView == NULL);
        _bbd._psv->QueryInterface(IID_PPV_ARG(IDropTarget, &_pdtView));
    }

    // The pending view may have a title change stored up, so fire the TitleChange.
    // Also the pending view may not tell us about title changes, so simulate one.
    //
    if (_bbd._pszTitleCur)
    {
        if (_dwDocFlags & DOCFLAG_DOCCANNAVIGATE)
        {
            VARIANTARG  varTitle;
            HRESULT     hrExec;

            V_VT(&varTitle) = VT_BSTR;
            V_BSTR(&varTitle) = SysAllocString(_bbd._pszTitleCur);

            ASSERT(V_BSTR(&varTitle));

            hrExec = IUnknown_Exec( _psbOuter, NULL, OLECMDID_SETTITLE, NULL, &varTitle, NULL);

            VariantClear(&varTitle);
        }
        else
        {
            FireEvent_DoInvokeStringW(_bbd._pautoEDS, DISPID_TITLECHANGE, _bbd._pszTitleCur);
        }
    }
    else if (_bbd._pidlCur)
    {
        WCHAR wzFullName[MAX_URL_STRING];

        hres = ::IEGetNameAndFlags(_bbd._pidlCur, SHGDN_NORMAL, wzFullName, SIZECHARS(wzFullName), NULL);
        if (SUCCEEDED(hres))
            FireEvent_DoInvokeStringW(_bbd._pautoEDS, DISPID_TITLECHANGE, wzFullName);
    }

    // We must fire this event LAST because the app can shut us down
    // in response to this event.
    //

    //
    // MSWorks printing bug 104242 - Do NOT fire the NC2 event when the state is 
    // interactive. doing this will cause WorksCalender to print a partial document.
    // Instead, we have the SetReadyState explicitly directly call FireEvent_NaviagateComplete
    // and so the event will fire once the whole document has been parsed in.  This
    // code is matched by a bunch of event blockers in formkrnl.cxx
    //
    if ( GetModuleHandle(TEXT("WKSCAL.EXE")))
    {
        LBSTR::CString strPath;

        LPTSTR pstrPath = strPath.GetBuffer( MAX_URL_STRING );

        if ( strPath.GetAllocLength() < MAX_URL_STRING )
        {
            TraceMsg( TF_WARNING, "CBaseBrowser2::ActivatePendingView() - strPath Allocation Failed!" );

            hres = E_OUTOFMEMORY;
        }
        else
        {
            hres = IEGetDisplayName( _bbd._pidlCur, pstrPath, SHGDN_FORPARSING );

            // Let CString class own the buffer again.
            strPath.ReleaseBuffer();
        }

        if ( FAILED(hres) )
        {
            strPath.Empty();
        }

        if (   GetUrlSchemeW( strPath ) == URL_SCHEME_ABOUT
            || GetUrlSchemeW( strPath ) == URL_SCHEME_FILE
            || GetUrlSchemeW( strPath ) == URL_SCHEME_INVALID
           )
        {
            goto Done;
        }
    }

    // fire the event!
    FireEvent_NavigateComplete(_bbd._pautoEDS, _bbd._pautoWB2, _bbd._pidlCur, _bbd._hwnd);

    // Sync up the lock icon state with CDocObjectHost
    
    if (S_OK != IUnknown_Exec(_bbd._psv, &CGID_ShellDocView, SHDVID_FORWARDSECURELOCK, NULL, NULL, NULL))
    {      
        // No CDocObjectHost, so we're not secure
        CComVariant varLock((long) SECURELOCK_SET_UNSECURE);
        
        if (!IsTopFrameBrowser(SAFECAST(this, IServiceProvider *), SAFECAST(this, IShellBrowser *)))
        {
            // we should suggest if we are not the top frame
            IOleCommandTarget *pct;

            if (SUCCEEDED(QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IOleCommandTarget, &pct))))
            {
                varLock.lVal += SECURELOCK_FIRSTSUGGEST;       
                pct->Exec(&CGID_Explorer, SBCMDID_SETSECURELOCKICON, 0, &varLock, NULL);
                pct->Release();
            }
        }       
        else
        {
            Exec(&CGID_Explorer, SBCMDID_SETSECURELOCKICON, 0, &varLock, NULL);
        }
    }

    hres = S_OK;

Done:
    OnReadyStateChange(NULL, READYSTATE_COMPLETE);
DoneWait:
    return hres;
}

LRESULT CBaseBrowser2::_DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // call the UNICODE/ANSI aware DefWindowProc
    //
    return ::SHDefWindowProc(hwnd, uMsg, wParam, lParam);
}


void CBaseBrowser2::_ViewChange(DWORD dwAspect, LONG lindex)
{
    //
    // we are interested in content changes only
    //

    // NOTE: if we are registed for separate palette commands, then do not invalidate the colours here...
    if (dwAspect & DVASPECT_CONTENT && !_fUsesPaletteCommands )
    {
        //
        // recompute our palette
        //
        _ColorsDirty(BPT_UnknownPalette);
    }
    else
    {
        TraceMsg(DM_PALETTE, "cbb::_vc not interested in aspect(s) %08X", dwAspect);
    }
}

void CBaseBrowser2::_ColorsDirty(BrowserPaletteType bptNew)
{
    //
    // if we are not currently handling palette messages then get out
    //
    if (_bptBrowser == BPT_DeferPaletteSupport)
    {
        TraceMsg(DM_PALETTE, "cbb::_cd deferring palette support");
        return;
    }

    //
    // we only handle palette changes and display changes
    //
    if ((bptNew != BPT_UnknownPalette) && (bptNew != BPT_UnknownDisplay))
    {
        AssertMsg(FALSE, TEXT("CBaseBrowser2::_ColorsDirty: invalid BPT_ constant"));
        bptNew = BPT_UnknownPalette;
    }

    //
    // if we aren't on a palettized display we don't care about palette changes
    //
    if ((bptNew != BPT_UnknownDisplay) && (_bptBrowser == BPT_NotPalettized))
    {
        TraceMsg(DM_PALETTE, "cbb::_cd not on palettized display");
        return;
    }

    //
    // if we are already handling one of these then we're done
    //
    if ((_bptBrowser == BPT_PaletteViewChanged) ||
        (_bptBrowser == BPT_DisplayViewChanged))
    {
        TraceMsg(DM_PALETTE, "cbb::_cd coalesced");
        return;
    }

    //
    // unknown display implies unknown palette when the display is palettized
    //
    if (_bptBrowser == BPT_UnknownDisplay)
        bptNew = BPT_UnknownDisplay;

    //
    // post ourselves a WM_QUERYNEWPALETTE so we can pile up multiple advises
    // and handle them at once (we can see a lot of them sometimes...)
    // NOTE: the lParam is -1 so we can tell that WE posted it and that
    // NOTE: it doesn't necessarily mean we onw the foreground palette...
    //
    if (PostMessage(_bbd._hwnd, WM_QUERYNEWPALETTE, 0, (LPARAM) -1))
    {
        TraceMsg(DM_PALETTE, "cbb::_cd queued update");

        //
        // remember that we have already posted a WM_QUERYNEWPALETTE
        //
        _bptBrowser = (bptNew == BPT_UnknownPalette)?
            BPT_PaletteViewChanged : BPT_DisplayViewChanged;
    }
    else
    {
        TraceMsg(DM_PALETTE, "cbb::_cd FAILED!");

        //
        // at least remember that the palette is stale
        //
        _bptBrowser = bptNew;
    }
}

void CBaseBrowser2::v_PropagateMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fSend)
{
    if (_bbd._hwnd)
        PropagateMessage(_bbd._hwnd, uMsg, wParam, lParam, fSend);
}

void CBaseBrowser2::_DisplayChanged(WPARAM wParam, LPARAM lParam)
{
    //
    // forward this on to our children
    //
    v_PropagateMessage(WM_DISPLAYCHANGE, wParam, lParam, TRUE);

    //
    // and mark our colors as dirty
    //
    _ColorsDirty(BPT_UnknownDisplay);
}

// 
// return results for _UpdateBrowserPaletteInPlace()
//    S_OK : BrowserPalette was successfully updated in place
//    S_FALSE : BrowserPalette is exactly the same, no need to update
//    E_FAIL : Unable to update palette in place at all, caller needs to create new palette 
// 
HRESULT CBaseBrowser2::_UpdateBrowserPaletteInPlace(LOGPALETTE *plp)
{
    if (!_hpalBrowser)
        return E_FAIL;

    WORD w;
    if (GetObject(_hpalBrowser, sizeof(w), &w) != sizeof(w))
        return E_FAIL;

    if (w != plp->palNumEntries)
        return E_FAIL;

    if (w > 256)
        return E_FAIL;

    //
    // GDI marks a palette as dirty if you update its colors
    // only replace the entries if the colors are actually different
    // this prevents excessive flashing
    //
    PALETTEENTRY ape[256];

    if (GetPaletteEntries(_hpalBrowser, 0, w, ape) != w)
        return E_FAIL;

    if (memcmp(ape, plp->palPalEntry, w * sizeof(PALETTEENTRY)) == 0)
    {
        TraceMsg(DM_PALETTE, "cbb::_ubpip %08x already had view object's colors", _hpalBrowser);
        return S_FALSE;
    }

    // make sure we don't reuse the global halftone palette that we are reusing across shdocvw....
    // do this after we've done the colour match 
    if ( _hpalBrowser == g_hpalHalftone )
    {
        return E_FAIL;
    }
    
    //
    // actually set up the colors
    //
    if (SetPaletteEntries(_hpalBrowser, 0, plp->palNumEntries,
        plp->palPalEntry) != plp->palNumEntries)
    {
        return E_FAIL;
    }

    TraceMsg(DM_PALETTE, "cbb::_ubpip updated %08x with view object's colors", _hpalBrowser);
    return S_OK;
}

void CBaseBrowser2::_RealizeBrowserPalette(BOOL fBackground)
{
    HPALETTE hpalRealize;

    //
    // get a palette to realize
    //
    if (_hpalBrowser)
    {
        TraceMsg(DM_PALETTE, "cbb::_rbp realizing %08x", _hpalBrowser);
        hpalRealize = _hpalBrowser;
    }
    else
    {
        TraceMsg(DM_PALETTE, "cbb::_rbp realizing DEFAULT_PALETTE");
        hpalRealize = (HPALETTE) GetStockObject(DEFAULT_PALETTE);
    }

    if ( !_fOwnsPalette && !fBackground )
    {
        // NOTE: if we don't think we own the foreground palette, and we
        // NOTE: are being told to realize in the foreground, then ignore
        // NOTE: it because they are wrong...
        fBackground = TRUE;
    }
    
    //
    // get a DC to realize on and select our palette
    //
    HDC hdc = GetDC(_bbd._hwnd);

    if (hdc)
    {
        HPALETTE hpalOld = SelectPalette(hdc, hpalRealize, fBackground);

        if (hpalOld)
        {
            //
            // we don't paint any palettized stuff ourselves we're just a frame
            // eg. we don't need to repaint here if the realize returns nonzero
            //
            RealizePalette(hdc);

            //
            // since we create and delete our palette alot, don't leave it selected
            //
            SelectPalette(hdc, hpalOld, TRUE);
        }
        ReleaseDC(_bbd._hwnd, hdc);
    }
}

void CBaseBrowser2::_PaletteChanged(WPARAM wParam, LPARAM lParam)
{
    TraceMsg(DM_PALETTE, "cbb::_pc (%08X, %08X, %08X) begins -----------------------", this, wParam, lParam);

    //
    // cdturner: 08/03/97
    // we think that we currently own the foregorund palette, we need to make sure that 
    // the window that just realized in the foreground (and thus caused the system
    // to generate the WM_PALETTECHANGED) was us, otherwise, we no longer own the 
    // palette 
    // 
    if ( _fOwnsPalette )
    {
        // by default we do not own it.
        _fOwnsPalette = FALSE;
        
        // the wParam hwnd we get is the top-level window that cause it, so we need to walk the window
        // chain to find out if it is one of our parents...
        // start at _bbd._hwnd (incase we are the top-level :-))
        HWND hwndParent = _bbd._hwnd;
        while ( hwndParent != NULL )
        {
            if ( hwndParent == (HWND) wParam )
            {
                // we caused it, so therefore we must still own it...
                _fOwnsPalette = TRUE;
                break;
            }
            hwndParent = GetParent( hwndParent );
        }
    }
    
    //
    // should we realize now? (see _QueryNewPalette to understand _bptBrowser)
    //
    // NOTE: we realize in the background here on purpose!  This helps us be
    // compatible with Netscape plugins etc that think they can own the
    // palette from inside the browser.
    //
    if (((HWND)wParam != _bbd._hwnd) && (_bptBrowser == BPT_Normal))
        _RealizeBrowserPalette(TRUE);

    //
    // always forward the changes to the current view
    // let the toolbars know too
    //
    if (_bbd._hwndView)
        TraceMsg(DM_PALETTE, "cbb::_pc forwarding to view window %08x", _bbd._hwndView);
    _pbsOuter->_SendChildren(_bbd._hwndView, TRUE, WM_PALETTECHANGED, wParam, lParam);  // SendMessage

    TraceMsg(DM_PALETTE, "cbb::_pc (%08X) ends -------------------------", this);
}

BOOL CBaseBrowser2::_QueryNewPalette()
{
    BrowserPaletteType bptNew;
    HPALETTE hpalNew = NULL;
    BOOL fResult = TRUE;
    BOOL fSkipRealize = FALSE;
    HDC hdc;

    TraceMsg(DM_PALETTE, "cbb::_qnp (%08X) begins ==================================", this);

TryAgain:
    switch (_bptBrowser)
    {
    case BPT_Normal:
        TraceMsg(DM_PALETTE, "cbb::_qnp - normal realization");
        //
        // Normal Realization: realize _hpalBrowser in the foreground
        //

        // avoid realzing the palette into the display if we've been asked not to...
        if ( !fSkipRealize )
            _RealizeBrowserPalette(FALSE);
        break;

    case BPT_ShellView:
        TraceMsg(DM_PALETTE, "cbb::_qnp - forwarding to shell view");
        //
        // Win95 Explorer-compatible: forward the query to the shell view
        //
        if (_bbd._hwndView && SendMessage(_bbd._hwndView, WM_QUERYNEWPALETTE, 0, 0))
            break;

        TraceMsg(DM_PALETTE, "cbb::_qnp - no shell view or view didn't answer");

        //
        // we only manage our palette as a toplevel app
        //

        //
        // the view didn't handle it; fall through to use a generic palette
        //
    UseGenericPalette:
        TraceMsg(DM_PALETTE, "cbb::_qnp - using generic palette");
        //
        // Use a Halftone Palette for the device
        //
        hpalNew = g_hpalHalftone;
        bptNew = BPT_Normal;
        goto UseThisPalette;

    case BPT_UnknownPalette:
    case BPT_PaletteViewChanged:
        TraceMsg(DM_PALETTE, "cbb::_qnp - computing palette");
        //
        // Undecided: try to use IViewObject::GetColorSet to compose a palette
        //
        LOGPALETTE *plp;
        HRESULT hres;

        // default to forwarding to the view if something fails along the way
        hpalNew = NULL;
        bptNew = BPT_ShellView;

        //
        // if we have a view object then try to get its color set
        //
        if (!_pvo)
        {
            TraceMsg(DM_PALETTE, "cbb::_qnp - no view object");
            goto UseGenericPalette;
        }

        plp = NULL;
        hres = _pvo->GetColorSet(DVASPECT_CONTENT, -1, NULL, NULL, NULL, &plp);

        if (FAILED(hres))
        {
            TraceMsg(DM_PALETTE, "cbb::_qnp - view object's GetColorSet failed");
            goto UseThisPalette;
        }

        //
        // either a null color set or S_FALSE mean the view object doesn't care
        //
        if (!plp)
            hres = S_FALSE;

        if (hres != S_FALSE)
        {
            //
            // can we reuse the current palette object?
            //
            HRESULT hrLocal = _UpdateBrowserPaletteInPlace(plp);
            if (FAILED( hrLocal ))
            {
                TraceMsg(DM_PALETTE, "cbb::_qnp - creating new palette for view object's colors");
                hpalNew = CreatePalette(plp);
            }
            else
            {
                hpalNew = _hpalBrowser;

                // NOTE: if we got back the same palette, don't bother realizing it into the foreground.
                // NOTE: this has the (desirable) side effect of stops us flashing the display when a
                // NOTE: control on a page has (wrongly) realized its own palette...
                if ( hrLocal == S_FALSE )
                {
                    // ASSERT( GetActiveWindow() == _bbd._hwnd );
                    fSkipRealize = TRUE;
                }
            }

            //
            // did we succeed at setting up a palette?
            //
            if (hpalNew)
            {
                TraceMsg(DM_PALETTE, "cbb::_qnp - palette is ready to use");
                bptNew = BPT_Normal;
            }
            else
            {
                TraceMsg(DM_PALETTE, "cbb::_qnp - failed to create palette");
            }
        }

        //
        // free the logical palette from the GetColorSet above
        //
        if (plp)
            CoTaskMemFree(plp);

        //
        // if the view object responded that it didn't care then pick a palette
        //
        if (hres == S_FALSE)
        {
            TraceMsg(DM_PALETTE, "cbb::_qnp - view object doesn't care");
            goto UseGenericPalette;
        }

        //
        // fall through to use the palette we decided on
        //
    UseThisPalette:
        //
        // we get here when we've decided on a new palette strategy
        //
        TraceMsg(DM_PALETTE, "cbb::_qnp - chose palette %08x", hpalNew);
        //
        // do we have a new palette object to use?
        //
        if (hpalNew != _hpalBrowser)
        {
            if (_hpalBrowser && _hpalBrowser != g_hpalHalftone)
            {
                TraceMsg(DM_PALETTE, "cbb::_qnp - deleting old palette %08x", _hpalBrowser);
                DeletePalette(_hpalBrowser);
            }
            _hpalBrowser = hpalNew;
        }
        
        //
        // notify the hosted object that we just changed the palette......
        //
        if ( _bbd._pctView )
        {
            VARIANTARG varIn = {0};
            varIn.vt = VT_I4;
            varIn.intVal = DISPID_AMBIENT_PALETTE;
            
            _bbd._pctView->Exec( &CGID_ShellDocView, SHDVID_AMBIENTPROPCHANGE, 0, &varIn, NULL );
        }

        //
        // now loop back and use this new palette strategy
        //
        _bptBrowser = bptNew;
        goto TryAgain;

    case BPT_UnknownDisplay:
    case BPT_DisplayViewChanged:
    case BPT_DeferPaletteSupport:
        TraceMsg(DM_PALETTE, "cbb::_qnp - unknown display");
        //
        // Unknown Display: decide whether we need palette support or not
        //
        hdc = GetDC(NULL);

        if (hdc)
        {
            bptNew = (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)?
                BPT_UnknownPalette : BPT_NotPalettized;
            ReleaseDC(NULL, hdc);
        }

        //
        // Set the new mode and branch accordingly
        // NOTE: we don't do a UseThisPalette here because it is still unknown
        //
        if (hdc && (_bptBrowser = bptNew) == BPT_UnknownPalette)
            goto TryAgain;

        TraceMsg(DM_PALETTE, "cbb::_qnp - not in palettized display mode");

        //
        // fall through to non-palette case
        //
    case BPT_NotPalettized:
        //
        // Not in Palettized Mode: do nothing
        //
        // if we just switched from a palettized mode then free our palette
        //
        if (_hpalBrowser)
        {
            TraceMsg(DM_PALETTE, "cbb::_qnp - old palette still lying around");
            hpalNew = NULL;
            bptNew = BPT_NotPalettized;
            goto UseThisPalette;
        }

        //
        // and don't do anything else
        //
        fResult = FALSE;
        break;

    default:
        TraceMsg(DM_PALETTE, "cbb::_qnp - invalid BPT_ state!");
        //
        // we should never get here
        //
        ASSERT(FALSE);
        _bptBrowser = BPT_UnknownDisplay;
        goto TryAgain;
    }

    TraceMsg(DM_PALETTE, "cbb::_qnp (%08X) ends ====================================", this);

    return fResult;
}


HRESULT CBaseBrowser2::_TryShell2Rename(IShellView* psv, LPCITEMIDLIST pidlNew)
{
    HRESULT hres = E_FAIL;

    if (EVAL(psv))  // Winstone once found it to be NULL.
    {
        // ? -  overloading the semantics of IShellExtInit
        IPersistFolder* ppf;
        hres = psv->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf));
        if (SUCCEEDED(hres)) 
        {
            hres = ppf->Initialize(pidlNew);
            if (SUCCEEDED(hres)) 
            {
                // we need to update what we're pointing to
                LPITEMIDLIST pidl = ILClone(pidlNew);
                if (pidl) 
                {
                    if (IsSameObject(psv, _bbd._psv)) 
                    {
                        ASSERT(_bbd._pidlCur);
                        ILFree(_bbd._pidlCur);
                        _bbd._pidlCur = pidl;

                        // If the current pidl is renamed, we need to fire a
                        // TITLECHANGE event. We don't need to do this in the
                        // pending case because the NavigateComplete provides
                        // a way to get the title.
                        //
                        WCHAR wzFullName[MAX_URL_STRING];

                        ::IEGetNameAndFlags(_bbd._pidlCur, SHGDN_NORMAL, wzFullName, SIZECHARS(wzFullName), NULL);
            
                        FireEvent_DoInvokeStringW(_bbd._pautoEDS, DISPID_TITLECHANGE, wzFullName);
                    } 
                    else if (IsSameObject(psv, _bbd._psvPending)) 
                    {
                        ASSERT(_bbd._pidlPending);
                        ILFree(_bbd._pidlPending);
                        _bbd._pidlPending = pidl;
                    } 
                    else 
                    {
                        // It may be possible to get here during _MayPlayTransition!
                        //
                        ASSERT(!_bbd._psvPending); // this should be the case if we get here
                        ASSERT(FALSE); // we should never get here or we have a problem
                    }
                }
            }
            ppf->Release();
        }
    }

    return hres;
}

HRESULT CBaseBrowser2::OnSize(WPARAM wParam)
{
    if (wParam != SIZE_MINIMIZED) 
    {
        _pbsOuter->v_ShowHideChildWindows(FALSE);
    }
    
    return S_OK;
}

BOOL CBaseBrowser2::v_OnSetCursor(LPARAM lParam)
{
    if (_fNavigate || _fDescendentNavigate) 
    {
        switch (LOWORD(lParam)) 
        {
        case HTBOTTOM:
        case HTTOP:
        case HTLEFT:
        case HTRIGHT:
        case HTBOTTOMLEFT:
        case HTBOTTOMRIGHT:
        case HTTOPLEFT:
        case HTTOPRIGHT:
            break;

        default:
            SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
            return TRUE;
        }
    }
    else
    {
        if (GetTickCount() < _dwStartingAppTick + STARTING_APP_DURATION)
        {
            SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
            return TRUE;
        }
    }

    return FALSE;
}

const SA_BSTRGUID s_sstrSearchFlags = {
    38 * SIZEOF(WCHAR),
    L"{265b75c1-4158-11d0-90f6-00c04fd497ea}"
};

#define PROPERTY_VALUE_SEARCHFLAGS ((BSTR)s_sstrSearchFlags.wsz)

LRESULT CBaseBrowser2::_OnGoto(void)
{
    TraceMsg(TF_SHDNAVIGATE, "CBB::_OnGoto called");

    //
    //  If we can't navigate right now, postpone it by restoring _uAction
    // and don't free pidlQueued. Subsequent _MayUnblockAsyncOperation call
    // will post WMC_ASYNCOPERATION (if we can navigate) and we come here
    // again.
    //
    if (!_CanNavigate()) 
    {
        TraceMsg(TF_SHDNAVIGATE, "CBB::_OnGoto can't do it now. Postpone!");
        _uActionQueued = ASYNCOP_GOTO;
        return S_FALSE;
    }

    LPITEMIDLIST pidl = _pidlQueued;
    DWORD dwSBSP = _dwSBSPQueued;
    _dwSBSPQueued = 0;

    _pidlQueued = NULL;

    if (pidl && PIDL_NOTHING != pidl) 
    {
        DWORD grfHLNF = 0;
        
        if (dwSBSP & SBSP_WRITENOHISTORY)
        {
            grfHLNF |= SHHLNF_WRITENOHISTORY;
        }
        if (dwSBSP & SBSP_NOAUTOSELECT)
        {
            grfHLNF |= SHHLNF_NOAUTOSELECT;
        }

        if (PIDL_LOCALHISTORY == pidl)
        {
            pidl = NULL;

            // For beta2 we need to do a better job mapping SBSP to HLNF values.
            // For beta1, this is the only case that's busted.
            //
            // This problem stems from converting _NavigateToPidl in ::NavigateToPidl
            // into a call to the Async version
            //
            if (dwSBSP & SBSP_NAVIGATEBACK)
                grfHLNF = HLNF_NAVIGATINGBACK;
            else if (dwSBSP & SBSP_NAVIGATEFORWARD)
                grfHLNF = HLNF_NAVIGATINGFORWARD;
        }
        else if (dwSBSP == (DWORD)-1)
        {
            // Same problem as above
            //
            // This problem stems from converting _NavigateToPidl in ::NavigateToTLItem
            // into a call to the Async version
            //
            grfHLNF = (DWORD)-1;
        }
        else
        {
            if (dwSBSP & SBSP_REDIRECT)
                grfHLNF |= HLNF_CREATENOHISTORY;
            {
                IWebBrowser2 *pWB2; 
                BOOL bAllow = ((dwSBSP & SBSP_ALLOW_AUTONAVIGATE) ? TRUE : FALSE);
    
                if (bAllow)
                    grfHLNF |= HLNF_ALLOW_AUTONAVIGATE;
    
                if (SUCCEEDED(_pspOuter->QueryService(SID_SHlinkFrame, IID_PPV_ARG(IWebBrowser2, &pWB2)))) 
                {
                    if (pWB2) 
                    {
                        VARIANT v = {0}; // for failure of below call
                        pWB2->GetProperty(PROPERTY_VALUE_SEARCHFLAGS, &v);
                        if (v.vt == VT_I4) 
                        {
                            v.lVal &= (~ 0x00000001);   // Clear the allow flag before we try to set it.
                            v.lVal |= (bAllow ? 0x01 : 0x00);
                        } 
                        else 
                        {
                            VariantClear(&v);
                            v.vt = VT_I4;
                            v.lVal = (bAllow ? 0x01 : 0x00);
                        }
                        pWB2->PutProperty(PROPERTY_VALUE_SEARCHFLAGS, v);
                        pWB2->Release();
                    }
                }
            }
        }

        TraceMsg(DM_NAV, "ief NAV::%s %x %x",TEXT("_OnGoto called calling _NavigateToPidl"), pidl, _bbd._pidlCur);
        _pbsOuter->_NavigateToPidl(pidl, (DWORD)grfHLNF, dwSBSP);
    }
    else 
    {
        // wParam=NULL means canceling the navigation.
        TraceMsg(DM_NAV, "NAV::_OnGoto calling _CancelPendingView");
        _CancelPendingView();

        if (PIDL_NOTHING == pidl)
        {
            // If we're being told to navigate to nothing, go there
            //
            // What should we do with the history??
            //
            _pbsOuter->ReleaseShellView();
        }
        else if (!_bbd._pidlCur)
        {
            //
            //  If the very first navigation failed, navigate to
            // a local html file so that the user will be able
            // to View->Options dialog.
            //
            TCHAR szPath[MAX_PATH]; // This is always local
            HRESULT hresT = _GetStdLocation(szPath, ARRAYSIZE(szPath), DVIDM_GOLOCALPAGE);
            if (FAILED(hresT) || !PathFileExists(szPath)) 
            {
                StrCpyN(szPath, TEXT("shell:Desktop"), ARRAYSIZE(szPath));
            }
            BSTR bstr = SysAllocStringT(szPath);
            if (bstr) 
            {
                TraceMsg(TF_SHDNAVIGATE, "CBB::_OnGoto Calling _bbd._pauto->Navigate(%s)", szPath);
                _bbd._pautoWB2->Navigate(bstr,NULL,NULL,NULL,NULL);
                SysFreeString(bstr);
            }
        }
    }

    _FreeQueuedPidl(&pidl);

    return 0;
}

void CBaseBrowser2::_FreeQueuedPidl(LPITEMIDLIST* ppidl)
{
    if (*ppidl && PIDL_NOTHING != *ppidl) 
    {
        ILFree(*ppidl);
    }
    *ppidl = NULL;
}

HRESULT CBaseBrowser2::OnFrameWindowActivateBS(BOOL fActive)
{
    BOOL fOldActive = _fActive;
    
    if (_pact)
    {
        TraceMsg(TF_SHDUIACTIVATE, "OnFrameWindowActivateBS(%d)", fActive);
        _pact->OnFrameWindowActivate(fActive);
    }

    _fActive = fActive;
    
    if (fActive && !fOldActive && _fUIActivateOnActive)
    {
        _fUIActivateOnActive = FALSE;

        _UIActivateView(SVUIA_ACTIVATE_FOCUS);
    }

    return S_OK;
}

LRESULT CBaseBrowser2::WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == g_uMsgFileOpened)
    {
        AppStarted();
        return 0;
    }

    switch(uMsg)
    {
#ifdef DEBUG
    // compile time assert to make sure we don't use these msgs
    // here since we must allow these to go to the subclasses 
    case CWM_GLOBALSTATECHANGE:
    case CWM_FSNOTIFY:
    case WMC_ACTIVATE:
        break;

    case WM_QUERYENDSESSION:
        // assume we are going to be shutting down (if we aren't, we unset this during the
        // WM_ENDSESSION message)
        _fMightBeShuttingDown = TRUE;
        goto DoDefault; // act like we didn't handle this msg
        break;

    case WM_ENDSESSION:
        // the wParam tells us if the session is being ended or not
        _fMightBeShuttingDown = (BOOL)wParam;
        return 0;
        break;
#endif
        
    // UGLY: Win95/NT4 shell DefView code sends this msg and does not deal
    // with the failure case. other ISVs do the same so this needs to stay forever
    case CWM_GETISHELLBROWSER:
        return (LRESULT)_psbOuter;  // not ref counted!

    //  WM_COPYDATA is used to implement inter-window target'ed navigation
    //  Copy data contains target, URL, postdata and referring URL
    case WM_COPYDATA:
        return (LRESULT)FALSE;

    case WMC_ASYNCOPERATION:
        {
            UINT uAction = _uActionQueued;
            _uActionQueued = ASYNCOP_NIL;

            switch(uAction) 
            {
            case ASYNCOP_GOTO:
                _OnGoto();
                break;
    
            case ASYNCOP_ACTIVATEPENDING:
                VALIDATEPENDINGSTATE();
                if (_bbd._psvPending) // paranoia
                {  
                    if (FAILED(_pbsOuter->ActivatePendingView()) && _cRefCannotNavigate > 0)
                    {
                        _uActionQueued = ASYNCOP_ACTIVATEPENDING; // retry activation
                    }
                }
                break;
    
            case ASYNCOP_CANCELNAVIGATION:
                _CancelPendingNavigation();
                break;

            case ASYNCOP_NIL:
                break;

            default:
                ASSERT(0);
                break;
            }
        }
        break;

    case WMC_DELAYEDDDEEXEC:
        return IEDDE_RunDelayedExecute();
        break;
        
    case WM_SIZE:
        _pbsOuter->OnSize(wParam);
        break;

#ifdef PAINTINGOPTS
    case WM_WINDOWPOSCHANGING:
        // Let's not waste any time blitting bits around, the viewer window
        // is really the guy that has the content so when it resizes itself
        // it can decide if it needs to blt or not.  This also makes resizing
        // look nicer.
        ((LPWINDOWPOS)lParam)->flags |= SWP_NOCOPYBITS;
        goto DoDefault;
#endif

    case WM_ERASEBKGND:
        if (!_bbd._hwndView)
            goto DoDefault;

        goto DoDefault;

    case WM_SETFOCUS:
        return _pbsOuter->OnSetFocus();

    case WM_DISPLAYCHANGE:
        _DisplayChanged(wParam, lParam);
        break;

    case WM_PALETTECHANGED:
        _PaletteChanged(wParam, lParam);
        break;

    case WM_QUERYNEWPALETTE:
        // we always pass -1 as the LParam to show that we posted it to ourselves...
        if ( lParam != 0xffffffff )
        {
            // otherwise, it looks like the system or our parent has just sent a real honest to God,
            // system WM_QUERYNEWPALETTE, so we now own the Foreground palette and we have a license to
            // to SelectPalette( hpal, FALSE );
            _fOwnsPalette = TRUE;
        }
        return _QueryNewPalette();

    case WM_SYSCOLORCHANGE:
    case WM_ENTERSIZEMOVE:
    case WM_EXITSIZEMOVE:
    case WM_WININICHANGE:
    case WM_FONTCHANGE:
        v_PropagateMessage(uMsg, wParam, lParam, TRUE);
        break;

    case WM_PRINT:
        // Win95 explorer did this
        if (_bbd._hwndView)
            SendMessage(_bbd._hwndView, uMsg, wParam, lParam);
        break;

#ifdef DEBUG
    case WM_ACTIVATE:
        // do *not* do any toolbar stuff here.  it will mess up the desktop.
        // override does that in shbrows2.cpp
        TraceMsg(DM_FOCUS, "cbb.wpbs(WM_ACT): => default");
        goto DoDefault;
#endif

    case WM_SETCURSOR:
        if (v_OnSetCursor(lParam))
            return TRUE;
        goto DoDefault;

    case WM_TIMER:
        if (wParam == IDT_STARTING_APP_TIMER)
        {
            AppStarted();
            return 0;
        }
        goto DoDefault;

    case WM_CREATE:
        if (S_OK != _pbsOuter->OnCreate((LPCREATESTRUCT)lParam))
        {
            _pbsOuter->OnDestroy();
            return -1;
        }
        g_uMsgFileOpened = RegisterWindowMessage(SH_FILEOPENED);
        return 0;

    case WM_NOTIFY:
        return _pbsOuter->OnNotify((LPNMHDR)lParam);

    case WM_COMMAND:
        _pbsOuter->OnCommand(wParam, lParam);
        break;

    case WM_DESTROY:
        _pbsOuter->OnDestroy();
        break;

    case WMC_IEHARD_NAVWARNING:
        _ShowIEHardNavWarning();
        break;

    default:
        if (uMsg == g_idMsgGetAuto)
        {
            //
            //  According to LauraBu, using WM_GETOBJECT for our private
            // purpose will work, but will dramatically slow down
            // accessibility apps unless we actually implement one of
            // accessibility interfaces. Therefore, we use a registered
            // message to get the automation/frame interface out of
            // IE/Nashvile frame. (SatoNa)
            //
            IUnknown* punk;
            if (SUCCEEDED(_bbd._pautoSS->QueryInterface(*(IID*)wParam, (void **)&punk)))
                return (LRESULT)punk; // Note that it's AddRef'ed by QI.
            return 0;
        }
        else if (uMsg == GetWheelMsg()) 
        {
             // Forward the mouse wheel message on to the view window
            if (_bbd._hwndView) 
            {
                PostMessage(_bbd._hwndView, uMsg, wParam, lParam);
                return 1;
            }
            // Fall through...
        }

DoDefault:
        return _DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

// *** IOleWindow methods ***
HRESULT CBaseBrowser2::GetWindow(HWND * lphwnd)
{
    *lphwnd = _bbd._hwnd;
    return S_OK;
}

HRESULT CBaseBrowser2::GetViewWindow(HWND * lphwnd)
{
    *lphwnd = _bbd._hwndView;
    return S_OK;
}

HRESULT CBaseBrowser2::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

// *** IShellBrowser methods *** (same as IOleInPlaceFrame)
HRESULT CBaseBrowser2::InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    return S_OK;
}

HRESULT CBaseBrowser2::SetMenuSB(HMENU hmenuShared, HOLEMENU holemenuReserved, HWND hwndActiveObject)
{
    return S_OK;
}

/*----------------------------------------------------------
Purpose: Remove menus that are shared with other menus from 
         the given browser menu.


Returns: 
Cond:    --
*/
HRESULT CBaseBrowser2::RemoveMenusSB(HMENU hmenuShared)
{
    return S_OK;
}

HRESULT CBaseBrowser2::SetStatusTextSB(LPCOLESTR lpszStatusText)
{
    // Even if we're not toplevel, send this to SendControlMsg
    // so events get notified. (Also simplifies CVOCBrowser.)
    //
    HRESULT hres;
    
    // If we are asked to put some text into the status bar, first save off what is already in pane 0
    if (lpszStatusText)
    {
        LRESULT lIsSimple = FALSE;
        
        // If we have a menu down, then we are already in simple mode. So send the 
        // text to pane 255 (simple)
        _psbOuter->SendControlMsg(FCW_STATUS, SB_ISSIMPLE, 0, 0L, &lIsSimple);
        
        if (!_fHaveOldStatusText && !lIsSimple)
        {
            WCHAR wzStatusText[MAX_URL_STRING];
            LRESULT ret;

            // TODO: Put this into a wrapper function because iedisp.cpp does something similar.
            //       Great when we convert to UNICODE
            if (SUCCEEDED(_psbOuter->SendControlMsg(FCW_STATUS, SB_GETTEXTLENGTHW, 0, 0, &ret)) &&
                LOWORD(ret) < ARRAYSIZE(wzStatusText))
            {
                // SB_GETTEXTW is not supported by the status bar control in Win95. Hence, the thunk here.
                _psbOuter->SendControlMsg(FCW_STATUS, SB_GETTEXTW, STATUS_PANE_NAVIGATION, (LPARAM)wzStatusText, NULL);
                StrCpyNW(_szwOldStatusText, wzStatusText, ARRAYSIZE(_szwOldStatusText));
                _fHaveOldStatusText = TRUE;
            }
        }   

        hres = _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTEXTW, lIsSimple ? 255 | SBT_NOBORDERS : STATUS_PANE_NAVIGATION | SBT_NOTABPARSING, (LPARAM)lpszStatusText, NULL);
    }
    else if (_fHaveOldStatusText) 
    {
        VARIANTARG var = {0};
        if (_bbd._pctView && SUCCEEDED(_bbd._pctView->Exec(&CGID_Explorer, SBCMDID_GETPANE, PANE_NAVIGATION, NULL, &var))
             && V_UI4(&var) != PANE_NONE)
        {
            hres = _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTEXTW, V_UI4(&var),(LPARAM)_szwOldStatusText, NULL);
        }
        else
        {
            hres = E_FAIL;
        }
        _fHaveOldStatusText = FALSE;
    }
    else
    {
        // No message, and no old status text, so clear what's there.
        hres = _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTEXTW, STATUS_PANE_NAVIGATION | SBT_NOTABPARSING , (LPARAM)lpszStatusText, NULL);
    }
    return hres;
}

HRESULT CBaseBrowser2::EnableModelessSB(BOOL fEnable)
{
    //  We no longer call _CancelNavigation here, which causes some problems
    // when the object calls EnableModeless when we are navigating away
    // (see IE bug 4581). Instead, we either cancel or postpone asynchronous
    // event while _DisableModeless(). (SatoNa)

    //
    // If we're NOT top level, assume virtual EnableModelessSB
    // handled this request and forwarded it to us. (See CVOCBrowser.)
    //
    if (fEnable)
    {
        // Robust against random calls
        //
        // If this EVAL rips, somebody is calling EMSB(TRUE) without a
        // (preceeding) matching EMSB(FALSE).  Find and fix!
        //
        if (EVAL(_cRefCannotNavigate > 0))
        {
            _cRefCannotNavigate--;
        }

        // Tell the shell's HTML window to retry pending navigation.
        if (_cRefCannotNavigate == 0 && _phtmlWS)
        {
            _phtmlWS->CanNavigate();
        }
    }
    else
    {
        _cRefCannotNavigate++;
    }

    //
    //  If there is any blocked async operation AND we can navigate now,
    // unblock it now. 
    //
    _MayUnblockAsyncOperation();

    return S_OK;
}

HRESULT CBaseBrowser2::TranslateAcceleratorSB(LPMSG lpmsg, WORD wID)
{
    return S_FALSE;
}


//
//  This function starts the navigation to the navigation to the specified
// pidl asynchronously. It cancels the pending navigation synchronously
// if any.
//
// NOTE: This function takes ownership of the pidl -- caller does NOT free pidl!!!
//
void CBaseBrowser2::_NavigateToPidlAsync(LPITEMIDLIST pidl, DWORD dwSBSP, BOOL fDontCallCancel)
{
    BOOL fCanSend = FALSE;

    TraceMsg(TF_SHDNAVIGATE, "CBB::_NavigateToPidlAsync called");

    // _StopAsyncOperation(); 
    if (!fDontCallCancel)
        _CancelPendingNavigation(); // which calls _StopAsyncOperation too
    else 
    {
        //
        //  I'm removing this assert because _ShowBlankPage calls this funcion
        // with fDontCallCancel==TRUE -- callin _CancelPendingNavigation here
        // causes GPF in CDocHostObject::_CancelPendingNavigation. (SatoNa)
        //
        // ASSERT(_bbd._pidlPending == NULL);
    }

    ASSERT(!_pidlQueued);

    _pidlQueued   = pidl;
    _dwSBSPQueued = dwSBSP;

    // Technically a navigate must be async or we have problems such as:
    //   1> object initiating the navigate (mshtml or an object on the page
    //      or script) gets destroyed when _bbd._psv is removed and then we return
    //      from this call into the just freed object.
    //   2> object initiating the navigate gets called back by an event
    //
    // In order for Netscape OM compatibility, we must ALWAY have a _bbd._psv or
    // _bbd._psvPending, so we go SYNC when we have neither. This avoids problem
    // <1> but not problem <2>. As we find faults, we'll work around them.
    //
    // Check _fAsyncNavigate to avoid navigate when persisting the WebBrowserOC
    // This avoids faults in Word97 and MSDN's new InfoViewer -- neither like
    // being reentered by an object they are in the middle of initializing.
    //
    if (_bbd._psv || _bbd._psvPending || _fAsyncNavigate)
    {
        _PostAsyncOperation(ASYNCOP_GOTO);
    }
    else
    {
        //  if we are just starting out, we can do this synchronously and
        //  reduce the window where the IHTMLWindow2 for the frame is undefined
        fCanSend = TRUE;
    }

    // Starting a navigate means we are loading someing...
    //
    OnReadyStateChange(NULL, READYSTATE_LOADING);

    //
    // Don't play sound for the first navigation (to avoid multiple
    // sounds to be played for a frame-set creation).
    //
    if (   _bbd._psv
        && IsWindowVisible(_bbd._hwnd)
        && !(_dwSBSPQueued & SBSP_WRITENOHISTORY)
        && !(_dwDocFlags & DOCFLAG_NAVIGATEFROMDOC))
    {
        IEPlaySound(TEXT("Navigating"), FALSE);
    }

    if (fCanSend)
    {
        _SendAsyncOperation(ASYNCOP_GOTO);
    }
}

// Now that all navigation paths go through
// _NavigateToPidlAsync we probably don't need to activate async.
// Remove this code...
//
BOOL CBaseBrowser2::_ActivatePendingViewAsync(void)
{
    TraceMsg(TF_SHDNAVIGATE, "CBB::_ActivatePendingViewAsync called");

    _PreActivatePendingViewAsync();

    //
    // _bbd._psvPending is for debugging purpose.
    //
    return _PostAsyncOperation(ASYNCOP_ACTIVATEPENDING);
}


HRESULT _TryActivateOpenWindow(LPCITEMIDLIST pidl)
{
    HWND hwnd;
    IWebBrowserApp *pwb;
    HRESULT hr = WinList_FindFolderWindow(pidl, NULL, &hwnd, &pwb);
    if (S_OK == hr)
    {
        CoAllowSetForegroundWindow(pwb, NULL);
        SetForegroundWindow(hwnd);
        ShowWindow(hwnd, SW_SHOWNORMAL);
        pwb->Release();
    }

    return hr;
}


HRESULT CBaseBrowser2::BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    HRESULT hr;
    BOOL fNewWindow = FALSE;

    if (PIDL_NOTHING == pidl)
    {
        if (!_CanNavigate()) 
            return HRESULT_FROM_WIN32(ERROR_BUSY);

        _NavigateToPidlAsync((LPITEMIDLIST)PIDL_NOTHING, wFlags);
        return S_OK;
    }

    if (!_CanNavigate()) 
        return HRESULT_FROM_WIN32(ERROR_BUSY);

    LPITEMIDLIST pidlNew = NULL;
    int iTravel = 0;

    switch (wFlags & (SBSP_RELATIVE | SBSP_ABSOLUTE | SBSP_PARENT | SBSP_NAVIGATEBACK | SBSP_NAVIGATEFORWARD))
    {
    case SBSP_NAVIGATEBACK:
        ASSERT(pidl==NULL || pidl==PIDL_LOCALHISTORY);
        iTravel = TLOG_BACK;
        break;

    case SBSP_NAVIGATEFORWARD:
        ASSERT(pidl==NULL || pidl==PIDL_LOCALHISTORY);
        iTravel = TLOG_FORE;
        break;

    case SBSP_RELATIVE:
        if (ILIsEmpty(pidl) && (wFlags & SBSP_NEWBROWSER))
            fNewWindow = TRUE;
        else if (_bbd._pidlCur)
            pidlNew = ILCombine(_bbd._pidlCur, pidl);
        break;

    case SBSP_PARENT:
        pidlNew = ILCloneParent(_bbd._pidlCur);
        break;

    default:
        ASSERT(FALSE);
        // fall through
    case SBSP_ABSOLUTE:
        pidlNew = ILClone(pidl);
        break;
    }

    if (iTravel)
    {
        ITravelLog *ptl;
        hr = GetTravelLog(&ptl);
        if (SUCCEEDED(hr))
        {
            hr = ptl->Travel(SAFECAST(this, IShellBrowser*), iTravel);
            ptl->Release();
        }
        _pbsOuter->UpdateBackForwardState();
        return hr;
    }

    // if block is needed for multi-window open.  if we're called to open  a new
    // window, but we're in the middle of navigating, we say we're busy.
    if (wFlags & SBSP_SAMEBROWSER)
    {
        if (wFlags & (SBSP_EXPLOREMODE | SBSP_OPENMODE))
        {
            // fail this if we're already navigating
            if (!_CanNavigate() || (_uActionQueued == ASYNCOP_GOTO))
            {
                return HRESULT_FROM_WIN32(ERROR_BUSY);
            }
        }
    }
    
    if (pidlNew || fNewWindow)
    {
        if ((wFlags & (SBSP_NEWBROWSER | SBSP_SAMEBROWSER)) == SBSP_NEWBROWSER)
        {
            // SBSP_NEWBROWSER + SBSP_EXPLOREMODE
            // means never reuse windows, always create a new explorer

            if (wFlags & SBSP_EXPLOREMODE)
            {
                _OpenNewFrame(pidlNew, wFlags); // takes ownership of pidl
            }
            else
            {
                hr = _TryActivateOpenWindow(pidlNew);
                if ((S_OK == hr) || 
                    (E_PENDING == hr))    // it will come up eventually
                {
                    hr = S_OK;
                    ILFree(pidlNew);
                }
                else
                    _OpenNewFrame(pidlNew, wFlags); // takes ownership of pidl
            }
        }
        else
        {
            // NOTE: we assume SBSP_SAMEBROWSER if SBSP_NEWBROWSER is not set
            _NavigateToPidlAsync(pidlNew, wFlags /* grfSBSP */); // takes ownership of pidl
        }
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT CBaseBrowser2::GetControlWindow(UINT id, HWND * lphwnd)
{
    return E_FAIL;
}

HRESULT CBaseBrowser2::SendControlMsg(UINT id, UINT uMsg, WPARAM wParam,
            LPARAM lParam, LRESULT *pret)
{
    HWND hwndControl = NULL;

    if (pret)
    {
        *pret = 0;
    }

    // If this is statusbar and set text then signal event change.
    if ((id == FCW_STATUS) && (uMsg == SB_SETTEXT || uMsg == SB_SETTEXTW) && // trying to set status text
        (!(wParam & SBT_OWNERDRAW))) // we don't own the window -- this can't work
    {
        // When browser or java perf timing mode is enabled, use "Done" or "Applet Started" 
        // in the status bar to get load time.
        if(g_dwStopWatchMode && (g_dwStopWatchMode & (SPMODE_BROWSER | SPMODE_JAVA)))
        {
            StopWatch_MarkJavaStop((LPSTR)lParam, _bbd._hwnd, (uMsg == SB_SETTEXTW));
        }
        
        if (uMsg == SB_SETTEXTW)
        {
            FireEvent_DoInvokeStringW(_bbd._pautoEDS, DISPID_STATUSTEXTCHANGE, (LPWSTR)lParam);
        }
        else
        {
            FireEvent_DoInvokeString(_bbd._pautoEDS, DISPID_STATUSTEXTCHANGE, (LPSTR)lParam);
        }
    }

    HRESULT hres = _psbOuter->GetControlWindow(id, &hwndControl);
    if (SUCCEEDED(hres))
    {
        LRESULT ret = SendMessage(hwndControl, uMsg, wParam, lParam);
        if (pret)
        {
            *pret = ret;
        }
    }

    return hres;
}
 
HRESULT CBaseBrowser2::QueryActiveShellView(struct IShellView ** ppshv)
{
    IShellView * psvRet = _bbd._psv;

    if ( _fCreateViewWindowPending )
    {
        ASSERT( _bbd._psvPending );
        psvRet = _bbd._psvPending;
    }
    //
    // We have both psv and hwndView after the completion of view creation.
    //
    *ppshv = psvRet;
    if (psvRet)
    {
        psvRet->AddRef();
        return NOERROR;
    }

    return E_FAIL;
}

HRESULT CBaseBrowser2::OnViewWindowActive(struct IShellView * psv)
{
    AssertMsg((!_bbd._psv || IsSameObject(_bbd._psv, psv)),
              TEXT("CBB::OnViewWindowActive _bbd._psv(%x)!=psv(%x)"),
              psv, _bbd._psv);
    _pbsOuter->_OnFocusChange(ITB_VIEW);
    return S_OK;
}

HRESULT CBaseBrowser2::SetToolbarItems(LPTBBUTTON pViewButtons, UINT nButtons, UINT uFlags)
{
    return NOERROR;
}

//
// Notes: pidlNew will be freed
//
HRESULT CBaseBrowser2::_OpenNewFrame(LPITEMIDLIST pidlNew, UINT wFlags)
{
    UINT uFlags = COF_CREATENEWWINDOW;
    
    if (wFlags & SBSP_EXPLOREMODE) 
        uFlags |= COF_EXPLORE;
    else 
    {
        // maintain the same class if possible
        if (IsNamedWindow(_bbd._hwnd, TEXT("IEFrame")))
            uFlags |= COF_IEXPLORE;
    }

    IBrowserService *pbs;
    ITravelLog *ptlClone = NULL;
    DWORD bid = BID_TOPFRAMEBROWSER;

    if (!(wFlags & SBSP_NOTRANSFERHIST))
    {
        if (SUCCEEDED(_pspOuter->QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IBrowserService, &pbs))))
        {
            ITravelLog *ptl;

            if (SUCCEEDED(pbs->GetTravelLog(&ptl)))
            {
                if (SUCCEEDED(ptl->Clone(&ptlClone)))
                {
                    ptlClone->UpdateEntry(pbs, FALSE);
                    bid = pbs->GetBrowserIndex();
                }
                ptl->Release();
            }
            pbs->Release();
        }
    }

    INotifyAppStart * pnasTop;
    HRESULT hr = _pspOuter->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(INotifyAppStart, &pnasTop));
    if (SUCCEEDED(hr))
    {
        pnasTop->AppStarting();
        pnasTop->Release();
    }

    hr = SHOpenNewFrame(pidlNew, ptlClone, bid, uFlags);
    
    if (ptlClone)
        ptlClone->Release();

    return hr;
}

//
//  This is a helper member of CBaseBroaser class (non-virtual), which
// returns the effective client area. We get this rectangle by subtracting
// the status bar area from the real client area.
//
HRESULT CBaseBrowser2::_GetEffectiveClientArea(LPRECT lprectBorder, HMONITOR hmon)
{
    // (derived class overrides w/ GetEffectiveClientRect for FCIDM_STATUS etc.)
    //
    // This code should only be hit in the WebBrowserOC case, but I don't
    // have a convenient assert for that... [mikesh]
    //
    ASSERT(hmon == NULL);
    GetClientRect(_bbd._hwnd, lprectBorder);
    return NOERROR;
}

HRESULT CBaseBrowser2::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    TraceMsg(TF_SHDUIACTIVATE, "UIW::ReqestBorderSpace pborderwidths=%x,%x,%x,%x",
             pborderwidths->left, pborderwidths->top, pborderwidths->right, pborderwidths->bottom);
    return S_OK;
}

//
// This is an implementation of IOleInPlaceUIWindow::GetBorder.
//
//  This function returns the bounding rectangle for the active object.
// It gets the effective client area, then subtract border area taken by
// all "frame" toolbars.
//
HRESULT CBaseBrowser2::GetBorder(LPRECT lprectBorder)
{
    _pbsOuter->_GetViewBorderRect(lprectBorder);
    return S_OK;
}

//
// NOTES: We used to handle the border space negotiation in CShellBrowser
//  and block it for OC (in Beta-1 of IE4), but I've changed it so that
//  CBaseBrowser2 always handles it. It simplifies our implementation and
//  also allows a DocObject to put toolbars within the frameset, which is
//  requested by the Excel team. (SatoNa)
//
HRESULT CBaseBrowser2::SetBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    if (pborderwidths) 
    {
        TraceMsg(TF_SHDUIACTIVATE, "UIW::SetBorderSpace pborderwidths=%x,%x,%x,%x",
                 pborderwidths->left, pborderwidths->top, pborderwidths->right, pborderwidths->bottom);
        _rcBorderDoc = *pborderwidths;
    }
    else
    {
        TraceMsg(TF_SHDUIACTIVATE, "UIW::SetBorderSpace pborderwidths=NULL");
        SetRect(&_rcBorderDoc, 0, 0, 0, 0);
    }
    
    _pbsOuter->_UpdateViewRectSize();
    return S_OK;
}

HRESULT CBaseBrowser2::SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName)
{
    TraceMsg(TF_SHDUIACTIVATE, "UIW::SetActiveObject called %x", pActiveObject);

    ATOMICRELEASE(_pact);

    if (pActiveObject)
    {
        _pact = pActiveObject;
        _pact->AddRef();
    }

    return S_OK;
}


/***********************************************************************\
    FUNCTION: _AddFolderOptionsSheets

    DESCRIPTION:
        Add the sheets for the "Folder Options" dialog.  These sheets
    come from the IShelLView object.
\***********************************************************************/
HRESULT CBaseBrowser2::_AddFolderOptionsSheets(DWORD dwReserved, LPFNADDPROPSHEETPAGE pfnAddPropSheetPage, LPPROPSHEETHEADER ppsh)
{
    // Add the normal Folder Option sheets.
    IShellPropSheetExt * ppsx;
    HRESULT hr = _pbsOuter->CreateBrowserPropSheetExt(IID_PPV_ARG(IShellPropSheetExt, &ppsx));
    if (SUCCEEDED(hr))
    {
        hr = ppsx->AddPages(AddPropSheetPage, (LPARAM)ppsh);
        ppsx->Release();
    }

    // Let the view add additional pages.  The exception will be FTP Folders because it exists to add
    // internet pages and we don't want them here.  However, if the above failed, then
    // we also want to fall back to this.  One of the cases this fixes if if the
    // browser fell back to legacy FTP support (web browser), then the above call will
    // fail on browser only, and we want to fall thru here to add the internet options.  Which
    // is appropriate for the fallback legacy FTP case because the menu will only have "Internet Options"
    // on it.
    if (FAILED(hr) || !IsBrowserFrameOptionsSet(_bbd._psf, BFO_BOTH_OPTIONS))
    {
        EVAL(SUCCEEDED(hr = _bbd._psv->AddPropertySheetPages(dwReserved, pfnAddPropSheetPage, (LPARAM)ppsh)));
    }

    return hr;
}


/***********************************************************************\
    FUNCTION: _AddInternetOptionsSheets

    DESCRIPTION:
        Add the sheets for the "Internet Options" dialog.  These sheets
    come from the browser.
\***********************************************************************/
HRESULT CBaseBrowser2::_AddInternetOptionsSheets(DWORD dwReserved, LPFNADDPROPSHEETPAGE pfnAddPropSheetPage, LPPROPSHEETHEADER ppsh)
{
    HRESULT hr;

    // Add the normal Internet Control Panel sheets. (This won't work when viewing FTP)
    if (_bbd._psvPending)
        hr = _bbd._psvPending->AddPropertySheetPages(dwReserved, pfnAddPropSheetPage, (LPARAM)ppsh);
    else
        hr = _bbd._psv->AddPropertySheetPages(dwReserved, pfnAddPropSheetPage, (LPARAM)ppsh);

    return hr;
}

/***********************************************************************\
    FUNCTION: _DoOptions

    DESCRIPTION:
        The user selected either "Folder Options" or "Internet Options" from
    the View or Tools menu (or where ever it lives this week).  The logic
    in this function is a little strange because sometimes the caller doesn't
    tell us which we need to display in the pvar.  If not, we need to calculate
    what to use.
    1. If it's a URL pidl (HTTP, GOPHER, etc) then we assume it's the
       "Internet Options" dialog.  We then use psv->AddPropertySheetPages()
       to create the "Internet Options" property sheets.
    2. If it's in the shell (or FTP because it needs folder options), then
       we assume it's "Folder Options" the user selected.  In that case,
       we get the property sheets using _pbsOuter->CreateBrowserPropSheetExt().
     
    Now it gets weird.  The PMs want FTP to have both "Internet Options" and
    "Folder Options".  If the pvar param is NULL, assume it's "Folder Options".
    If it was "Internet Options" in the internet case, then I will pass an
    pvar forcing Internet Options.

    NOTE: SBO_NOBROWSERPAGES means "Folder Options".  I'm guessing browser refers
          to the original explorer browser.
\***********************************************************************/

HDPA CBaseBrowser2::s_hdpaOptionsHwnd = NULL;

void CBaseBrowser2::_DoOptions(VARIANT* pvar)
{
    // Step 1. Determine what sheets to use.
    DWORD dwFlags = SBO_DEFAULT;
    TCHAR szCaption[MAX_PATH];
    
    if (!_bbd._psv)
        return;

    // Did the caller explicitly tell us which to use?
    if (pvar && pvar->vt == VT_I4)
        dwFlags = pvar->lVal;
    else if (_bbd._pidlCur)
    {
        // don't show the Folder Option pages if
        // 1. we're browsing the internet (excluding FTP), or
        // 2. if we're browsing a local file (not a folder), like a local .htm file.
        if (IsBrowserFrameOptionsSet(_bbd._psf, BFO_RENAME_FOLDER_OPTIONS_TOINTERNET))
        {
            // SBO_NOBROWSERPAGES means don't add the "Folder Options" pages.
            dwFlags = SBO_NOBROWSERPAGES;
        }
    }
    
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE rPages[MAX_PAGES];

    psh.dwSize = SIZEOF(psh);
    psh.dwFlags = PSH_DEFAULT | PSH_USECALLBACK;
    psh.hInstance = MLGetHinst();
    psh.hwndParent = _bbd._hwnd;
    psh.pszCaption = szCaption;
    psh.nPages = 0;
    psh.nStartPage = 0;
    psh.phpage = rPages;
    psh.pfnCallback = _OptionsPropSheetCallback;

    // Step 2. Now add "Internet Options" or "Folder Options" sheets.
    if (dwFlags == SBO_NOBROWSERPAGES)
    {
        // They don't want folder pages. (The used to refer to it as browser)
        EVAL(SUCCEEDED(_AddInternetOptionsSheets(0, AddPropSheetPage, &psh)));
        MLLoadString(IDS_INTERNETOPTIONS, szCaption, ARRAYSIZE(szCaption));
    }
    else
    {
        EVAL(SUCCEEDED(_AddFolderOptionsSheets(0, AddPropSheetPage, &psh)));
        MLLoadString(IDS_FOLDEROPTIONS, szCaption, ARRAYSIZE(szCaption));
    }

    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
    if (psh.nPages == 0)
    {
        SHRestrictedMessageBox(_bbd._hwnd);
    }
    else
    {
        // Step 3. Display the dialog
        _bbd._psv->EnableModelessSV(FALSE);
        INT_PTR iPsResult = PropertySheet(&psh);
        _SyncDPA();
        _bbd._psv->EnableModelessSV(TRUE);

        if (ID_PSREBOOTSYSTEM == iPsResult)
        {
            // The "offline folders" prop page will request a reboot if the user
            // has enabled or disabled client-side-caching.
            RestartDialog(_bbd._hwnd, NULL, EWX_REBOOT);
        }
    }
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
}

// we're here because our prop sheet just closed
// we need to purge it from the hwnd list
// check all the hwnds because 1) there's probably
// only one anyway, 2) paranoia.
void CBaseBrowser2::_SyncDPA()
{
    ENTERCRITICAL;

    if (s_hdpaOptionsHwnd != NULL)
    {
        int i, cPtr = DPA_GetPtrCount(s_hdpaOptionsHwnd);
        ASSERT(cPtr >= 0);

        // remove handles for windows which aren't there anymore
        for (i = cPtr - 1; i >= 0; i--)
        {
            HWND hwnd = (HWND)DPA_GetPtr(s_hdpaOptionsHwnd, i);
            if (!IsWindow(hwnd))
            {
                DPA_DeletePtr(s_hdpaOptionsHwnd, i);
                cPtr--;
            }
        }

        // if there aren't any windows left then clean up the hdpa
        if (cPtr == 0)
        {
            DPA_Destroy(s_hdpaOptionsHwnd);
            s_hdpaOptionsHwnd = NULL;
        }
    }

    LEAVECRITICAL;
}

int CALLBACK
CBaseBrowser2::_OptionsPropSheetCallback(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    switch (uMsg)
    {
    case PSCB_INITIALIZED:
        {
            ENTERCRITICAL;

            if (s_hdpaOptionsHwnd == NULL)
            {
                // low mem -> Create failure -> don't track hwnd
                s_hdpaOptionsHwnd = DPA_Create(1);
            }

            if (s_hdpaOptionsHwnd != NULL)
            {
                // low mem -> AppendPtr array expansion failure -> don't track hwnd
                DPA_AppendPtr(s_hdpaOptionsHwnd, hwndDlg);
            }

            LEAVECRITICAL;
        }
        break;
    }

    return 0;
}

HRESULT CBaseBrowser2::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, 
                                  OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    if (rgCmds == NULL)
        return E_INVALIDARG;

    if (pguidCmdGroup == NULL)
    {
        for (ULONG i = 0 ; i < cCmds; i++)
        {
            rgCmds[i].cmdf = 0;

            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_SETDOWNLOADSTATE:
            case OLECMDID_UPDATECOMMANDS:
                rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case OLECMDID_STOP:
            case OLECMDID_STOPDOWNLOAD:
                if (_bbd._psvPending) // pending views are stoppable
                {
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                }
                else if (_bbd._pctView) // current views may support stop also
                {
                    _bbd._pctView->QueryStatus(NULL, 1, &rgCmds[i], pcmdtext);
                }
                break;

            default:
                // set to zero above
                if (_bbd._pctView)
                {
                    // Recursion check.  Avoid looping for those command IDs where Trident bounces
                    // back up to us.
                    //
                    if (_fInQueryStatus)
                        break;
                    _fInQueryStatus = TRUE;
                    _bbd._pctView->QueryStatus(NULL, 1, &rgCmds[i], pcmdtext);
                    _fInQueryStatus = FALSE;
                }
                break;
            }
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        for (ULONG i=0 ; i < cCmds ; i++)
        {
            switch (rgCmds[i].cmdID)
            {            
            case SBCMDID_ADDTOFAVORITES:
            case SBCMDID_CREATESHORTCUT:
                rgCmds[i].cmdf = OLECMDF_ENABLED;   // support these unconditionally
                break;

            case SBCMDID_CANCELNAVIGATION:
                rgCmds[i].cmdf = _bbd._psvPending ? OLECMDF_ENABLED : 0;
                break;

            case SBCMDID_OPTIONS:
                rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            default:
                rgCmds[i].cmdf = 0;
                break;
            }
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        for (ULONG i=0 ; i < cCmds ; i++)
        {
            ITravelLog *ptl;

            switch (rgCmds[i].cmdID)
            {
            case SHDVID_CANGOBACK:
                rgCmds[i].cmdf = FALSE; // Assume False 
                if (SUCCEEDED(GetTravelLog(&ptl)))
                {
                    ASSERT(ptl);
                    if (S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_BACK, NULL))
                        rgCmds[i].cmdf = TRUE;
                    ptl->Release();
                }
                break;

            case SHDVID_CANGOFORWARD:
                rgCmds[i].cmdf = FALSE; // Assume False 
                if (SUCCEEDED(GetTravelLog(&ptl)))
                {
                    ASSERT(ptl);
                    if (S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_FORE, NULL))
                        rgCmds[i].cmdf = TRUE;
                    ptl->Release();
                }
                break;

            case SHDVID_PRINTFRAME:
            case SHDVID_MIMECSETMENUOPEN:
            case SHDVID_FONTMENUOPEN:
                if (_bbd._pctView)
                    _bbd._pctView->QueryStatus(pguidCmdGroup, 1, &rgCmds[i], pcmdtext);
                break;

            default:
                rgCmds[i].cmdf = 0;
                break;
            }
        }
    }
    else
    {
        return OLECMDERR_E_UNKNOWNGROUP;
    }

    return S_OK;
}

HRESULT CBaseBrowser2::_ShowBlankPage(LPCTSTR pszAboutUrl, LPCITEMIDLIST pidlIntended)
{
    // Never execute this twice.
    if (_fNavigatedToBlank) 
    {
        TraceMsg(TF_WARNING, "Re-entered CBaseBrowser2::_ShowBlankPage");
        return E_FAIL;
    }

    _fNavigatedToBlank = TRUE;

    BSTR bstrURL;
    TCHAR szPendingURL[MAX_URL_STRING + 1];
    TCHAR *pszOldUrl = NULL;
    
    szPendingURL[0] = TEXT('#');
    HRESULT hres;
    

    if (pidlIntended)
    {
        hres = ::IEGetNameAndFlags(pidlIntended, SHGDN_FORPARSING, szPendingURL + 1, SIZECHARS(szPendingURL)-1, NULL);
        if (S_OK == hres)
            pszOldUrl = szPendingURL;
    }   

    hres = CreateBlankURL(&bstrURL, pszAboutUrl, pszOldUrl);
   
    if (SUCCEEDED(hres))
    {
        LPITEMIDLIST pidlTemp;

        hres = IECreateFromPathW(bstrURL, &pidlTemp);
        if (SUCCEEDED(hres)) 
        {
            //
            // Note that we pass TRUE as fDontCallCancel to asynchronously
            // cancel the current view. Otherwise, we hit GPF in CDocHostObject::
            // _CancelPendingNavigation.
            //
            _NavigateToPidlAsync(pidlTemp, 0, TRUE); // takes ownership of pidl
        }

        SysFreeString(bstrURL);
    }
    return hres;
}

int CALLBACK _PunkRelease(void * p, void * pData)
{
    IUnknown* punk = (IUnknown*)p;
    punk->Release();
    return 1;
}

void CBaseBrowser2::_DLMDestroy(void)
{
    if (_hdpaDLM) 
    {
        DPA_DestroyCallback(_hdpaDLM, _PunkRelease, NULL);
        _hdpaDLM = NULL;
    }
}

HRESULT CBaseBrowser2::InitializeDownloadManager()
{
    _hdpaDLM = DPA_Create(4);
    return S_OK;
}


//
// DLM = DownLoad Manager
//
void CBaseBrowser2::_DLMUpdate(MSOCMD* prgCmd)
{
    ASSERT(prgCmd->cmdID == OLECMDID_STOPDOWNLOAD);
    for (int i = DPA_GetPtrCount(_hdpaDLM) - 1; i >= 0; i--) 
    {
        IOleCommandTarget* pcmdt = (IOleCommandTarget*)DPA_GetPtr(_hdpaDLM, i);
        prgCmd->cmdf = 0;
        pcmdt->QueryStatus(NULL, 1, prgCmd, NULL);
        if (prgCmd->cmdf & MSOCMDF_ENABLED) 
        {
            // We found one downloading guy, skip others. 
            break;
        }
        else 
        {
            // This guy is no longer busy, remove it from the list,
            // and continue. 
            DPA_DeletePtr(_hdpaDLM, i);
            pcmdt->Release();
        }
    }
}

void CBaseBrowser2::_DLMRegister(IUnknown* punk)
{
    // Check if it's already registered. 
    for (int i = 0; i < DPA_GetPtrCount(_hdpaDLM); i++) 
    {
        IOleCommandTarget* pcmdt = (IOleCommandTarget*)DPA_GetPtr(_hdpaDLM, i);
        if (IsSameObject(pcmdt, punk)) 
        {
            // Already registered, don't register.
            return;
        }
    }

    IOleCommandTarget* pcmdt;
    HRESULT hres = punk->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pcmdt));
    if (SUCCEEDED(hres)) 
    {
        if (DPA_AppendPtr(_hdpaDLM, pcmdt) == -1) 
        {
            pcmdt->Release();
        }
    }
}

//
// This function updates the _fDescendentNavigate flag.
//
// ALGORITHM:
//  If pvaragIn->lVal has some non-zero value, we set _fDescendentNavigate.
//  Otherwise, we ask the current view to see if it has something to stop.
// 
HRESULT CBaseBrowser2::_setDescendentNavigate(VARIANTARG *pvarargIn)
{
    ASSERT(!pvarargIn || pvarargIn->vt == VT_I4 || pvarargIn->vt == VT_BOOL || pvarargIn->vt == VT_UNKNOWN);
    if (!pvarargIn || !pvarargIn->lVal)
    {
        MSOCMD rgCmd;

        rgCmd.cmdID = OLECMDID_STOPDOWNLOAD;
        rgCmd.cmdf = 0;
        if (_bbd._pctView)
            _bbd._pctView->QueryStatus(NULL, 1, &rgCmd, NULL);

        //
        // If and only if the view says "I'm not navigating any more",
        // we'll ask the same question to each registered objects.
        //
        if (_hdpaDLM && !(rgCmd.cmdf & MSOCMDF_ENABLED)) 
        {
            _DLMUpdate(&rgCmd);
        }

        _fDescendentNavigate = (rgCmd.cmdf & MSOCMDF_ENABLED) ? TRUE:FALSE;
    }
    else
    {
        if (_hdpaDLM && pvarargIn->vt == VT_UNKNOWN) 
        {
            ASSERT(pvarargIn->punkVal);
            _DLMRegister(pvarargIn->punkVal);
        }
        _fDescendentNavigate = TRUE;
    }
    return S_OK;
}

void CBaseBrowser2::_CreateShortcutOnDesktop(IUnknown *pUnk, BOOL fUI)
{
    ISHCUT_PARAMS ShCutParams = {0};
    IWebBrowser *pwb = NULL;
    IDispatch *pdisp = NULL;
    IHTMLDocument2 *pDoc = NULL;
    LPITEMIDLIST pidlCur = NULL;
    BSTR bstrTitle = NULL;
    BSTR bstrURL = NULL;
    
    if (!fUI || (MLShellMessageBox(_bbd._hwnd,
                                 MAKEINTRESOURCE(IDS_CREATE_SHORTCUT_MSG),
                                 MAKEINTRESOURCE(IDS_TITLE),
                                 MB_OKCANCEL) == IDOK))
    {
         TCHAR szPath[MAX_PATH];
         
         if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_DESKTOPDIRECTORY, TRUE))
         {
            TCHAR szName[MAX_URL_STRING];
            HRESULT hr;

            if (pUnk)
            {
                hr = IUnknown_QueryService(pUnk, SID_SHlinkFrame, IID_PPV_ARG(IWebBrowser, &pwb));
                if (hr)
                    goto Cleanup;
                
                hr = pUnk->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc));
                if (hr)
                    goto Cleanup;
                
                hr = pDoc->get_URL(&bstrURL);
                if (hr)
                    goto Cleanup;
                
                hr = pDoc->get_title(&bstrTitle);
                if (hr)
                    goto Cleanup;
                
                if (SysStringLen(bstrTitle) == 0)
                {
                    StrCpyNW(szName, bstrURL, ARRAYSIZE(szName));
                    ShCutParams.pszTitle = PathFindFileName(szName); 
                }
                else
                {
                    StrCpyNW(szName, bstrTitle, ARRAYSIZE(szName));
                    ShCutParams.pszTitle = szName;
                }
                
                pidlCur = PidlFromUrl(bstrURL);
                if (!pidlCur)
                    goto Cleanup;
                
                ShCutParams.pidlTarget = pidlCur;
            }
            else
            {
                hr = QueryService(SID_SHlinkFrame, IID_PPV_ARG(IWebBrowser, &pwb));
                if (hr)
                    goto Cleanup;
                
                hr = pwb->get_Document(&pdisp);
                if (hr)
                    goto Cleanup;
                
                hr = pdisp->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc));
                if (hr)
                    goto Cleanup;
                
                ShCutParams.pidlTarget = _bbd._pidlCur;
                if(_bbd._pszTitleCur)
                {
                    StrCpyNW(szName, _bbd._pszTitleCur, ARRAYSIZE(szName));
                    ShCutParams.pszTitle = szName;
                }
                else
                {
                    ::IEGetNameAndFlags(_bbd._pidlCur, SHGDN_INFOLDER, szName, SIZECHARS(szName), NULL);
                    ShCutParams.pszTitle = PathFindFileName(szName); 
                }
            }
            ShCutParams.pszDir = szPath; 
            ShCutParams.pszOut = NULL;
            ShCutParams.bUpdateProperties = FALSE;
            ShCutParams.bUniqueName = TRUE;
            ShCutParams.bUpdateIcon = TRUE;
            
            hr = pwb->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &ShCutParams.pCommand));
            ASSERT((S_OK == hr) && (BOOLIFY(ShCutParams.pCommand)));
            if (hr)
                goto Cleanup;
            
            ShCutParams.pDoc = pDoc;
            ShCutParams.pDoc->AddRef();
            
            hr = CreateShortcutInDirEx(&ShCutParams);
            AssertMsg(SUCCEEDED(hr), TEXT("CDOH::_CSOD CreateShortcutInDir failed %x"), hr);
            if (hr)
                goto Cleanup;
         } 
         else 
         {
             TraceMsg(DM_ERROR, "CSB::_CSOD SHGetSFP(DESKTOP) failed");
         }
    }
Cleanup:
    SysFreeString(bstrTitle);
    SysFreeString(bstrURL);
    ILFree(pidlCur);
    SAFERELEASE(ShCutParams.pDoc);
    SAFERELEASE(ShCutParams.pCommand);
    SAFERELEASE(pwb);
    SAFERELEASE(pdisp);
    SAFERELEASE(pDoc);
}


void CBaseBrowser2::_AddToFavorites(LPCITEMIDLIST pidl, LPCTSTR pszTitle, BOOL fDisplayUI)
{
    HRESULT hr;
    IWebBrowser *pwb = NULL;
    IOleCommandTarget *pcmdt = NULL;

    if (SHIsRestricted2W(_bbd._hwnd, REST_NoFavorites, NULL, 0))
        return;

    hr = QueryService(SID_SHlinkFrame, IID_PPV_ARG(IWebBrowser, &pwb));
    if (S_OK == hr)
    {
        hr = pwb->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pcmdt));
        ASSERT((S_OK == hr) && (BOOLIFY(pcmdt)));
        
        pwb->Release();
    }

    //there's a small window where _pidlCur can be freed while AddToFavorites is coming up,
    // so use a local copy instead
    LPITEMIDLIST pidlCur = NULL;
    if (!pidl)
        pidlCur = ILClone(_bbd._pidlCur);

    if (pidl || pidlCur)
        AddToFavorites(_bbd._hwnd, pidl ? pidl : pidlCur, pszTitle, fDisplayUI, pcmdt, NULL);

    ILFree(pidlCur);

    SAFERELEASE(pcmdt);
}

HRESULT CBaseBrowser2::_OnCoCreateDocument(VARIANTARG *pvarargOut)
{
    HRESULT hres;

    //
    // Cache the class factory object and lock it (leave it loaded)
    //
    if (_pcfHTML == NULL) 
    {
        TraceMsg(DM_COCREATEHTML, "CBB::_OnCoCreateDoc called first time (this=%x)", this);
        hres = CoGetClassObject(CLSID_HTMLDocument, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                    0, IID_PPV_ARG(IClassFactory, &_pcfHTML));
        if (SUCCEEDED(hres)) 
        {
            hres = _pcfHTML->LockServer(TRUE);
            if (FAILED(hres)) 
            {
                _pcfHTML->Release();
                _pcfHTML = NULL;
                return hres;
            }
        } 
        else 
        {
            return hres;
        }
    }

    TraceMsg(DM_COCREATEHTML, "CBB::_OnCoCreateDoc creating an instance (this=%x)", this);

    hres = _pcfHTML->CreateInstance(NULL, IID_PPV_ARG(IUnknown, &pvarargOut->punkVal));
    if (SUCCEEDED(hres)) 
    {
        pvarargOut->vt = VT_UNKNOWN;
    } 
    else 
    {
        pvarargOut->vt = VT_EMPTY;
    }
    return hres;
}


// fill a buffer with a variant, return a pointer to that buffer on success of the conversion

LPCTSTR VariantToString(const VARIANT *pv, LPTSTR pszBuf, UINT cch)
{
    *pszBuf = 0;

    if (pv && pv->vt == VT_BSTR && pv->bstrVal)
    {
        StrCpyN(pszBuf, pv->bstrVal, cch);
        if (*pszBuf)
            return pszBuf;
    }
    return NULL;
}

HRESULT CBaseBrowser2::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, 
                           VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_NOTSUPPORTED;

    if (pguidCmdGroup == NULL) 
    {
        switch(nCmdID) 
        {

        case OLECMDID_CLOSE:
            HWND hwnd;
            GetWindow(&hwnd);
            PostMessage(hwnd, WM_CLOSE, 0, 0);
            hres = S_OK;
            break;

        // CBaseBrowser2 doesn't actually do the toolbar -- itbar does, forward this
        case OLECMDID_UPDATECOMMANDS:
            _NotifyCommandStateChange();
            hres = S_OK;
            break;

        case OLECMDID_SETDOWNLOADSTATE:

            ASSERT(pvarargIn);

            if (pvarargIn) 
            {
                _setDescendentNavigate(pvarargIn);
                hres = _updateNavigationUI();              
            }
            else 
            {
                hres = E_INVALIDARG;
            }
            break;
            
        case OLECMDID_REFRESH:
            if (_bbd._pctView) // we must check!
                hres = _bbd._pctView->Exec(NULL, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            else if (_bbd._psv)
            {
                _bbd._psv->Refresh();
                hres = S_OK;
            }

            break;

        //
        //  When Exec(OLECMDID_STOP) is called either by the containee (the
        // current document) or the automation service object, we cancel
        // the pending navigation (if any), then tell the current document
        // to stop the go-going download in that page.
        //
        case OLECMDID_STOP:
            // cant stop if we are modeless
            if (S_FALSE == _DisableModeless())
            {
                LPITEMIDLIST pidlIntended = (_bbd._pidlPending) ? ILClone(_bbd._pidlPending) : NULL;
                _CancelPendingNavigation();

                // the _bbd._pctView gives us a _StopCurrentView()
                _pbsOuter->_ExecChildren(_bbd._pctView, TRUE, NULL, OLECMDID_STOP, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);   // Exec

                if (!_bbd._pidlCur)
                {
                    TCHAR szResURL[MAX_URL_STRING];

                    hres = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                             HINST_THISDLL,
                                             ML_CROSSCODEPAGE,
                                             TEXT("navcancl.htm"),
                                             szResURL,
                                             ARRAYSIZE(szResURL),
                                             TEXT("shdocvw.dll"));
                    if (SUCCEEDED(hres))
                    {
                        _ShowBlankPage(szResURL, pidlIntended);
                    }
                }

                if (pidlIntended)
                {
                    ILFree(pidlIntended);
                }
                    
            }

            hres = S_OK;
            break;

        // handled in basesb so IWebBrowser::ExecWB gets this
        // since this used to be in shbrowse, make sure we do
        // it only if _fTopBrowser
        case OLECMDID_FIND:
#define TBIDM_SEARCH            0x123 // defined in browseui\itbdrop.h

            // Check restriction here cuz Win95 didn't check in SHFindFiles like it now does.
            if (!SHRestricted(REST_NOFIND) && _fTopBrowser)
            {
                if (!_bbd._pctView || FAILED(_bbd._pctView->Exec(NULL, nCmdID, nCmdexecopt, pvarargIn, pvarargOut))) 
                {
                    if (pvarargIn && pvarargIn->vt == VT_UNKNOWN)
                    {
                        ASSERT(pvarargIn->punkVal);

                        VARIANT  var = {0};
                        var.vt = VT_I4;
                        var.lVal = -1;
                        if (SUCCEEDED(IUnknown_Exec(pvarargIn->punkVal, &CLSID_CommonButtons, TBIDM_SEARCH, 0, NULL, &var)))
                            break;
                    }
                    SHFindFiles(_bbd._pidlCur, NULL);
                }
            }
            break;

        case OLECMDID_HTTPEQUIV_DONE:
        case OLECMDID_HTTPEQUIV:
            hres = OnHttpEquiv(_bbd._psv, (OLECMDID_HTTPEQUIV_DONE == nCmdID), pvarargIn, pvarargOut);
            break;

        case OLECMDID_PREREFRESH:
            // Tell the shell's HTML window we have a new document
            // Fall through default
            if (_phtmlWS)
            {
                _phtmlWS->ViewActivated();
            }

        // Binder prints by reflecting the print back down. do the same here
        // Note: we may want to do the same for _PRINTPREVIEW, _PROPERTIES, _STOP, etc.
        // The null command group should all go down, no need to stop these at the pass.
        default:
            if (_bbd._pctView) // we must check!
                hres = _bbd._pctView->Exec(NULL, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            else
                hres = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else if (IsEqualGUID(CGID_MSHTML, *pguidCmdGroup))
    {
        if (_bbd._pctView) // we must check!
            hres = _bbd._pctView->Exec(&CGID_MSHTML, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        else
            hres = OLECMDERR_E_NOTSUPPORTED;
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        case SBCMDID_CREATESHORTCUT:
            if (   pvarargIn
                && (V_VT(pvarargIn) == VT_UNKNOWN)
               )
            {
                _CreateShortcutOnDesktop(V_UNKNOWN(pvarargIn), nCmdexecopt & OLECMDEXECOPT_PROMPTUSER);
            }
            else
            {
                _CreateShortcutOnDesktop(NULL, nCmdexecopt & OLECMDEXECOPT_PROMPTUSER);
            }
            hres = S_OK;
            break;

        case SBCMDID_ADDTOFAVORITES:
            {
                LPITEMIDLIST pidl = NULL;

                //if someone doesn't pass a path in, _AddToFavorites will use the current page
                if ((pvarargIn != NULL) && (pvarargIn->vt == VT_BSTR))
                    IECreateFromPath(pvarargIn->bstrVal, &pidl);
                
                TCHAR szTitle[128];
                LPTSTR pszTitle = NULL;
                if (pvarargOut)
                    pszTitle = (LPTSTR)VariantToString(pvarargOut, szTitle, ARRAYSIZE(szTitle)); // may be NULL
                else
                {
                    if (_bbd._pszTitleCur)
                        pszTitle = StrCpyNW(szTitle, _bbd._pszTitleCur, ARRAYSIZE(szTitle));
                }

                _AddToFavorites(pidl, pszTitle, nCmdexecopt & OLECMDEXECOPT_PROMPTUSER);

                if (pidl)
                    ILFree(pidl);
                hres = S_OK;
            }
            break;

        case SBCMDID_OPTIONS:
            _DoOptions(pvarargIn);
            break;

        case SBCMDID_CANCELNAVIGATION:

            TraceMsg(DM_NAV, "ief NAV::%s called when _bbd._pidlCur==%x, _bbd._psvPending==%x",
                             TEXT("Exec(SBCMDID_CANCELNAV) called"),
                             _bbd._pidlCur, _bbd._psvPending);

            // Check if this is sync or async
            if (pvarargIn && pvarargIn->vt == VT_I4 && pvarargIn->lVal) 
            {
                TraceMsg(DM_WEBCHECKDRT, "CBB::Exec calling _CancelPendingNavigation");
                _CancelPendingNavigation();
            }
            else
            {
                //
                //  We must call ASYNC version in this case because this call
                // is from the pending view itself.
                //
                LPITEMIDLIST pidlIntended = (_bbd._pidlPending) ? ILClone(_bbd._pidlPending) : NULL;
                _CancelPendingNavigationAsync();

                if (!_bbd._pidlCur)
                {
                    if (!_fDontShowNavCancelPage)
                    {
                        TCHAR szResURL[MAX_URL_STRING];

                        if (IsGlobalOffline())
                        {
                            hres = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                                     HINST_THISDLL,
                                                     ML_CROSSCODEPAGE,
                                                     TEXT("offcancl.htm"),
                                                     szResURL,
                                                     ARRAYSIZE(szResURL),
                                                     TEXT("shdocvw.dll"));
                            if (SUCCEEDED(hres))
                            {
                                _ShowBlankPage(szResURL, pidlIntended);
                            }
                        }
                        else
                        {
                            hres = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                                     HINST_THISDLL,
                                                     ML_CROSSCODEPAGE,
                                                     TEXT("navcancl.htm"),
                                                     szResURL,
                                                     ARRAYSIZE(szResURL),
                                                     TEXT("shdocvw.dll"));
                            if (SUCCEEDED(hres))
                            {
                                _ShowBlankPage(szResURL, pidlIntended);
                            }
                        }
                    }
                    else
                    {
                        _fDontShowNavCancelPage = FALSE;
                    }
                }

                if (pidlIntended)
                    ILFree(pidlIntended);
            }
            hres = S_OK;
            break;

        case SBCMDID_ASYNCNAVIGATION:

            TraceMsg(DM_NAV, "ief NAV::%s called when _bbd._pidlCur==%x, _bbd._psvPending==%x",
                             TEXT("Exec(SBCMDID_ASYNCNAV) called"),
                             _bbd._pidlCur, _bbd._psvPending);

            //
            //  We must call ASYNC version in this case because this call
            // is from the pending view itself.
            //
            _SendAsyncNavigationMsg(pvarargIn);
            hres = S_OK;
            break;


        case SBCMDID_COCREATEDOCUMENT:
            hres = _OnCoCreateDocument(pvarargOut);
            break;

        case SBCMDID_HISTSFOLDER:
            if (pvarargOut) 
            {
                VariantClearLazy(pvarargOut);
                if (NULL == _punkSFHistory)
                {
                    IHistSFPrivate *phsfHistory;

                    hres = LoadHistoryShellFolder(NULL, &phsfHistory);
                    if (SUCCEEDED(hres))
                    {
                        hres = phsfHistory->QueryInterface(IID_PPV_ARG(IUnknown, &_punkSFHistory));
                        phsfHistory->Release();
                    }
                }
                if (NULL != _punkSFHistory)
                {
                    pvarargOut->vt = VT_UNKNOWN;
                    pvarargOut->punkVal = _punkSFHistory;
                    _punkSFHistory->AddRef();
                }
            }
            break;

        case SBCMDID_UPDATETRAVELLOG:
            {
                BOOL fForceUpdate = FALSE;

                if (pvarargIn && (VT_I4 == V_VT(pvarargIn)))
                {
                    _fIsLocalAnchor = !!(V_I4(pvarargIn) & TRAVELLOG_LOCALANCHOR);
                    fForceUpdate = !!(V_I4(pvarargIn) & TRAVELLOG_FORCEUPDATE);
                }

                _UpdateTravelLog(fForceUpdate);
            }
            // fall through

        case SBCMDID_REPLACELOCATION:
            if (pvarargIn && pvarargIn->vt == VT_BSTR)
            {
                WCHAR wzParsedUrl[MAX_URL_STRING];
                LPWSTR  pszUrl = pvarargIn->bstrVal;
                LPITEMIDLIST pidl;

                // BSTRs can be NULL.
                if (!pszUrl)
                    pszUrl = L"";

                // NOTE: This URL came from the user, so we need to clean it up.
                //       If the user entered "yahoo.com" or "Search Get Rich Quick",
                //       it will be turned into a search URL by ParseURLFromOutsideSourceW().
                DWORD cchParsedUrl = ARRAYSIZE(wzParsedUrl);
                if (!ParseURLFromOutsideSourceW(pszUrl, wzParsedUrl, &cchParsedUrl, NULL))
                {
                    StrCpyN(wzParsedUrl, pszUrl, ARRAYSIZE(wzParsedUrl));
                } 

                IEParseDisplayName(CP_ACP, wzParsedUrl, &pidl);
                if (pidl)
                {
                    NotifyRedirect(_bbd._psv, pidl, NULL);
                    ILFree(pidl);
                }
            }

            // even if there was no url, still force no refresh.
            _fGeneratedPage = TRUE;
            
            //  force updating the back and forward buttons
            _pbsOuter->UpdateBackForwardState();
            hres = S_OK;
            break;

        case SBCMDID_ONCLOSE:
            hres = S_OK;

            if (_bbd._pctView)
            {
                hres = _bbd._pctView->Exec(pguidCmdGroup, nCmdID, 0, NULL, NULL);
            }

            break;

        case SBCMDID_SETSECURELOCKICON:
            {
                //  if this is a SET, then just obey.
                LONG lock = pvarargIn->lVal;
                TraceMsg(DM_SSL, "SB::Exec() SETSECURELOCKICON lock = %d", lock);

                if (lock >= SECURELOCK_FIRSTSUGGEST)
                {
                    //
                    //  if this was ever secure, then the lowest we can be
                    //  suggested to is MIXED.  otherwise we just choose the 
                    //  lowest level of security suggested.
                    //
                    if ((lock == SECURELOCK_SUGGEST_UNSECURE) && 
                        (_bbd._eSecureLockIcon != SECURELOCK_SET_UNSECURE))
                    {
                        lock = SECURELOCK_SET_MIXED;
                    }
                    else
                    {
                        lock = min(lock - SECURELOCK_FIRSTSUGGEST, _bbd._eSecureLockIcon);
                    }
                }

                UpdateSecureLockIcon(lock);
                hres = S_OK;
            }
            break;

        default:
            hres = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        case SHDVID_GOBACK:
            hres = _psbOuter->BrowseObject(NULL, SBSP_NAVIGATEBACK);
            break;

        case SHDVID_GOFORWARD:
            hres = _psbOuter->BrowseObject(NULL, SBSP_NAVIGATEFORWARD);
            break;

        // we reflect AMBIENTPROPCHANGE down because this is how iedisp notifies dochost
        // that an ambient property has changed. we don't need to reflect this down in
        // cwebbrowsersb because only the top-level iwebbrowser2 is allowed to change props
        case SHDVID_AMBIENTPROPCHANGE:
        case SHDVID_PRINTFRAME:
        case SHDVID_MIMECSETMENUOPEN:
        case SHDVID_FONTMENUOPEN:
        case SHDVID_DOCFAMILYCHARSET:
            if (_bbd._pctView) // we must check!
            {
                hres = _bbd._pctView->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            }
            else
                hres = E_FAIL;
            break;

        case SHDVID_DEACTIVATEMENOW:
            if (!_bbd._psvPending)
            {
                hres = S_OK;
                break;
            }
            //  fall through to activate new view
#ifdef FEATURE_PICS
        case SHDVID_ACTIVATEMENOW:
#endif
            if (   pvarargIn
                && (VT_BOOL == V_VT(pvarargIn))
                && (VARIANT_TRUE == V_BOOL(pvarargIn)))  // Synchronous
            {
                if (_bbd._psvPending)
                {
                    ASSERT(_pbsOuter);
                    _pbsOuter->ActivatePendingView();
                }
            }
            else  // Asynchronous
            {
                _ActivatePendingViewAsync();
            }

            hres = S_OK;
            break;


        case SHDVID_GETPENDINGOBJECT:
            ASSERT( pvarargOut);
            if (_bbd._psvPending && ((pvarargIn && pvarargIn->vt == VT_BOOL && pvarargIn->boolVal) || !_bbd._psv))
            {
                VariantClearLazy(pvarargOut);
                _bbd._psvPending->QueryInterface(IID_PPV_ARG(IUnknown, &pvarargOut->punkVal));
                if (pvarargOut->punkVal) pvarargOut->vt = VT_UNKNOWN;
            }
            hres = (pvarargOut->punkVal == NULL) ? E_FAIL : S_OK;
            break;

 
        case SHDVID_SETPRINTSTATUS:
            if (pvarargIn && pvarargIn->vt == VT_BOOL)
            {
                VARIANTARG var = {0};
                if (_bbd._pctView && SUCCEEDED(_bbd._pctView->Exec(&CGID_Explorer, SBCMDID_GETPANE, PANE_PRINTER, NULL, &var))
                     && V_UI4(&var) != PANE_NONE)
                {
                    _psbOuter->SendControlMsg(FCW_STATUS, SB_SETICON, V_UI4(&var), 
                                  (LPARAM)(pvarargIn->boolVal ? g_hiconPrinter : NULL), NULL);
                    // we're putting the printer icon and the offline icon in the same
                    // slot on the status bar, so when we turn off the printer icon
                    // we have to check to see if we're offline so we can put the offline
                    // icon back
                    if (!pvarargIn->boolVal && IsGlobalOffline())
                    {
#ifdef DEBUG
                        VARIANTARG var2 = {0};
                        _bbd._pctView->Exec(&CGID_Explorer, SBCMDID_GETPANE, PANE_OFFLINE, NULL, &var2);
                        ASSERT(V_UI4(&var2) == V_UI4(&var));
#endif DEBUG
                        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETICON, V_UI4(&var),
                                                  (LPARAM)(g_hiconOffline), NULL);
                    } // if (!pvarargIn->boolVal && IsGlobalOffline())
                }
                hres = S_OK;
            }
            else
                hres = E_INVALIDARG;
            break;

#ifdef FEATURE_PICS
        /* Dochost sends up this command to have us put up the PICS access
         * denied dialog.  This is done so that all calls to this ratings
         * API are modal to the top-level browser window;  that in turn
         * lets the ratings code coalesce denials for all subframes into
         * a single dialog.
         */
        case SHDVID_PICSBLOCKINGUI:
            {
                void * pDetails;
                if (pvarargIn && pvarargIn->vt == VT_INT_PTR)
                    pDetails = pvarargIn->byref;
                else
                    pDetails = NULL;
                TraceMsg(DM_PICS, "CBaseBrowser2::Exec calling RatingAccessDeniedDialog2");
                /**
                 * We QueryService for an SID_IRatingNotification which is
                 * implemented by our host, if we find it, instead of 
                 * displaying the modal ratings dialog, we notify our host through
                 * the interface and allow it to make the decision
                 */
                IRatingNotification* pRatingNotify;
                hres = QueryService(SID_SRatingNotification, IID_PPV_ARG(IRatingNotification, &pRatingNotify));
                if (SUCCEEDED(hres))
                {
                    RATINGBLOCKINGINFO* pRBInfo = NULL;
                    TraceMsg(DM_PICS, "CBaseBrowser2::Exec calling RatingMarsCrackData");
                    hres = RatingCustomCrackData(NULL, pDetails, &pRBInfo);
                    if (SUCCEEDED(hres))
                    {
                        hres = pRatingNotify->AccessDeniedNotify(pRBInfo);
                        RatingCustomDeleteCrackedData(pRBInfo);
                    }
                    pRatingNotify->Release();
                } // if (SUCCEEDED(hres))
                else {
                    hres = RatingAccessDeniedDialog2(_bbd._hwnd, NULL, pDetails);
                }
            }
            break;
#endif

       case SHDVID_ONCOLORSCHANGE:
            // PALETTE:
            // PALETTE: recompute our palette
            // PALETTE:
            _ColorsDirty(BPT_UnknownPalette);
            break;

        case SHDVID_GETOPTIONSHWND:
        {
            ASSERT(pvarargOut != NULL);
            ASSERT(V_VT(pvarargOut) == VT_BYREF);


            // return the hwnd for the inet options
            // modal prop sheet. we're tracking
            // this hwnd because if it's open
            // and plugUI shutdown needs to happen,
            // that dialog needs to receive a WM_CLOSE
            // before we can nuke it

            hres = E_FAIL;

            // is there a list of window handles?

            ENTERCRITICAL;

            if (s_hdpaOptionsHwnd != NULL)
            {
                int cPtr = DPA_GetPtrCount(s_hdpaOptionsHwnd);
                // is that list nonempty?
                if (cPtr > 0)
                {
                    HWND hwndOptions = (HWND)DPA_GetPtr(s_hdpaOptionsHwnd, 0);
                    ASSERT(hwndOptions != NULL);

                    pvarargOut->byref = hwndOptions;

                    // remove it from the list
                    // that hwnd is not our responsibility anymore
                    DPA_DeletePtr(s_hdpaOptionsHwnd, 0);

                    // successful hwnd retrieval
                    hres = S_OK;
                }
            }

            LEAVECRITICAL;
        }
        break;

        case SHDVID_DISPLAYSCRIPTERRORS:
        {
            HRESULT hr;

            hr = _bbd._pctView->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

            return hr;
        }
        break;

        case SHDVID_NAVIGATEFROMDOC:  // The document called Navigate
            _dwDocFlags |= DOCFLAG_NAVIGATEFROMDOC;
            return S_OK;

        case SHDVID_SETNAVIGATABLECODEPAGE:
            _dwDocFlags |= DOCFLAG_SETNAVIGATABLECODEPAGE;
            return S_OK;

        case SHDVID_CHECKINCACHEIFOFFLINE:
            {
                if (pvarargIn && (VT_BSTR == V_VT(pvarargIn)) && V_BSTR(pvarargIn)
                    && pvarargOut && (VT_BOOL == V_VT(pvarargOut)))
                {
                    LPITEMIDLIST pidl = PidlFromUrl(V_BSTR(pvarargIn));
                    if (pidl)
                    {
                        // (scotrobe): We should be passing fIsPost
                        // into _CheckInCacheIfOffline. 
                        //
                        V_BOOL(pvarargOut) = (S_OK == _CheckInCacheIfOffline(pidl, FALSE));
                        ILFree(pidl);

                        return S_OK;
                    }
                }
                return E_FAIL;
            }
            break;

        case SHDVID_CHECKDONTUPDATETLOG:
            {
                if (pvarargOut)
                {
                    V_VT(pvarargOut) = VT_BOOL;
                    V_BOOL(pvarargOut) = (_fDontAddTravelEntry ? VARIANT_TRUE : VARIANT_FALSE);
                    hres = S_OK;
                }
                break;
            }

        case SHDVID_FIREFILEDOWNLOAD:
            if (pvarargOut)
            {
                BOOL fCancel = FALSE;

                V_VT(pvarargOut) = VT_BOOL;

                FireEvent_FileDownload(_bbd._pautoEDS, &fCancel, pvarargIn ? V_BOOL(pvarargIn):VARIANT_FALSE);
                pvarargOut->boolVal = (fCancel ? VARIANT_TRUE : VARIANT_FALSE);
                hres = S_OK;
            }
            break;

        default:
            hres = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else if (IsEqualGUID(CGID_ShortCut, *pguidCmdGroup))
    {
        if (_bbd._pctView) // we must check!
            hres = _bbd._pctView->Exec(&CGID_ShortCut, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        else
            hres = OLECMDERR_E_NOTSUPPORTED;
    } 
    else if (IsEqualGUID(CGID_DocHostCmdPriv, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        case DOCHOST_DOCCANNAVIGATE:
            if (pvarargIn && VT_UNKNOWN == V_VT(pvarargIn) && V_UNKNOWN(pvarargIn))
            {
                _dwDocFlags |= DOCFLAG_DOCCANNAVIGATE;
            }
            else
            {
                _dwDocFlags &= ~DOCFLAG_DOCCANNAVIGATE;                
            }

            hres = S_OK;
            break;

        case DOCHOST_SETBROWSERINDEX:
            if (pvarargIn && VT_I4 == V_VT(pvarargIn))
            {
                _dwBrowserIndex = V_I4(pvarargIn);
                return S_OK;
            }

            return E_INVALIDARG;

        default:
            hres = OLECMDERR_E_UNKNOWNGROUP;  // Backwards compatability
            break;
        }
    }
    else if (IsEqualGUID(CGID_InternetExplorer, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        case IECMDID_SET_INVOKE_DEFAULT_BROWSER_ON_NEW_WINDOW:
            if ((NULL != pvarargIn) && (pvarargIn->vt == VT_BOOL))
            {
                _fInvokeDefBrowserOnNewWindow = pvarargIn->boolVal ? TRUE : FALSE;
                hres = S_OK;
            }
            else
            {
                hres = E_INVALIDARG;
            }
            break;

        case IECMDID_GET_INVOKE_DEFAULT_BROWSER_ON_NEW_WINDOW:
            if ((NULL != pvarargOut) && (pvarargOut->vt == VT_EMPTY))
            {
                pvarargOut->vt = VT_BOOL;
                pvarargOut->boolVal = _fInvokeDefBrowserOnNewWindow ? TRUE : FALSE;
                hres = S_OK;
            }
            else
            {
                hres = E_INVALIDARG;
            }
            break;
            
        case IECMDID_BEFORENAVIGATE_GETSHELLBROWSE:
            {
                // true if pending navigate is NOT a web navigation.
                if (pvarargOut && _pidlBeforeNavigateEvent)
                {
                    DWORD dwAttributes = SFGAO_FOLDER;
                    hres = IEGetAttributesOf(_pidlBeforeNavigateEvent, &dwAttributes);

                    V_VT(pvarargOut) = VT_BOOL;
                    V_BOOL(pvarargOut) = SUCCEEDED(hres) && (dwAttributes & SFGAO_FOLDER) ?
                         VARIANT_TRUE : VARIANT_FALSE;
                    hres = S_OK;
                }
            }
            break;


        case IECMDID_BEFORENAVIGATE_DOEXTERNALBROWSE:
            {
                if (_pidlBeforeNavigateEvent)
                {                  
                    hres = _psbOuter->BrowseObject(_pidlBeforeNavigateEvent, SBSP_ABSOLUTE | SBSP_NEWBROWSER);
                }
            }
            break;

        case IECMDID_BEFORENAVIGATE_GETIDLIST:
            {
                if (pvarargOut && _pidlBeforeNavigateEvent)
                {                  
                    hres = InitVariantFromIDList(pvarargOut, _pidlBeforeNavigateEvent);
                }
            }
            break;

        default:
            hres = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else
    {
        hres = OLECMDERR_E_UNKNOWNGROUP;
    }
    return hres;
}

LPITEMIDLIST
CBaseBrowser2::PidlFromUrl(BSTR bstrUrl)
{
    LPITEMIDLIST pidl = NULL;

    ASSERT(bstrUrl);

    IEParseDisplayNameWithBCW(CP_ACP, bstrUrl, NULL, &pidl);

    // IEParseDisplayNameWithBCW will return a null pidl if 
    // the URL has any kind of fragment identifier at the
    // end - #, ? =, etc.
    //    
    if (!pidl) 
    {
        TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];
        DWORD cchBuf = ARRAYSIZE(szPath);

        // If it's a FILE URL, convert it to a path.
        //
        if (IsFileUrlW(bstrUrl) && SUCCEEDED(PathCreateFromUrl(bstrUrl, szPath, &cchBuf, 0)))
        {
            // That worked, we are done because our buffer is now full.
        }
        else        
        {
            // We now need to copy to the buffer and we assume it's a path.
            //
            StrCpyN(szPath, bstrUrl, ARRAYSIZE(szPath));
        }

        pidl = SHSimpleIDListFromPath(szPath);
    }

    return pidl;
}

BSTR
CBaseBrowser2::GetHTMLWindowUrl(IHTMLWindow2 * pHTMLWindow)
{
    BSTR bstrUrl = NULL;

    IHTMLPrivateWindow * pPrivateWindow;
    HRESULT hr = pHTMLWindow->QueryInterface(IID_PPV_ARG(IHTMLPrivateWindow, &pPrivateWindow));
    if (SUCCEEDED(hr))
    {
        pPrivateWindow->GetAddressBarUrl(&bstrUrl);
        pPrivateWindow->Release();
    }

    return bstrUrl;
}

LPITEMIDLIST
CBaseBrowser2::_GetPidlForDisplay(BSTR bstrUrl, BOOL * pfIsErrorUrl /* = NULL */)
{
    BOOL fIsErrorUrl  = FALSE;
    LPITEMIDLIST pidl = NULL;

    if (bstrUrl)
    {
        fIsErrorUrl = ::IsErrorUrl(bstrUrl);
        if (!fIsErrorUrl)
        {
            pidl = PidlFromUrl(bstrUrl);
        }
        else
        {
            // Only strip the anchor fragment if it's not JAVASCRIPT: or VBSCRIPT:, because a # could not an
            // anchor but a string to be evaluated by a script engine like #00ff00 for an RGB color.
            //
            int nScheme = GetUrlSchemeW(bstrUrl);      
            if (nScheme != URL_SCHEME_JAVASCRIPT && nScheme != URL_SCHEME_VBSCRIPT)
            {
                //  Locate local anchor fragment if possible
                //
                LPWSTR pszFragment = StrChr(bstrUrl, L'#');

                // It is possible to have a fragment identifier 
                // with no corresponding fragment.
                //
                if (pszFragment && lstrlen(pszFragment) > 1)
                {
                    BSTR bstrTemp = SysAllocString(pszFragment+1);
                    if (bstrTemp)
                    {
                        pidl = PidlFromUrl(bstrTemp);
                        SysFreeString(bstrTemp);
                    }
                }
            }
        }
    }

    if (pfIsErrorUrl)
        *pfIsErrorUrl = fIsErrorUrl;

    return pidl;
}

HRESULT CBaseBrowser2::ParseDisplayName(IBindCtx *pbc, LPOLESTR pszDisplayName,
        ULONG *pchEaten, IMoniker **ppmkOut)
{

    TraceMsg(0, "sdv TR ::ParseDisplayName called");
    *ppmkOut = NULL;
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::EnumObjects( DWORD grfFlags, IEnumUnknown **ppenum)
{
    TraceMsg(0, "sdv TR ::EnumObjects called");
    *ppenum = NULL;
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::LockContainer( BOOL fLock)
{
    TraceMsg(0, "sdv TR ::LockContainer called");
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::SetTitle(IShellView* psv, LPCWSTR lpszName)
{
    LPWSTR *ppszName = NULL;
    BOOL fFireEvent = FALSE;
    LPITEMIDLIST pidl;

    // We need to forward title changes on to the automation interface.
    // But since title changes can technically occur at any time we need
    // to distinguish between current and pending title changes and only
    // pass on the current title change now. We'll pass on the pending
    // title change at NavigateComplete time. (This also lets us identify
    // when we navigate to non-SetTitle object (such as the shell) and
    // simulate a TitleChange event.)
    //
    // Since the DocObjectHost needs to retrieve the title later, we
    // hold onto the current view's title change so they don't have to.
    //

    // Figure out which object is changing.
    //
    if (IsSameObject(_bbd._psv, psv))
    {
        ppszName = &_bbd._pszTitleCur;
        pidl = _bbd._pidlCur;
        fFireEvent = TRUE;
    }
    else if (EVAL(IsSameObject(_bbd._psvPending, psv) || !_bbd._psvPending)) // no pending probably means we're in _MayPlayTransition
    {
        ppszName = &_bbd._pszTitlePending;
        pidl = _bbd._pidlPending;
        // If we have no current guy, might as well set the title early
        fFireEvent = !_bbd._psv;
    }
    else
    {
        ppszName = NULL;
        pidl = NULL;        // init pidl to suppress bogus C4701 warning
    }

    if (ppszName)
    {
        UINT cchLen = lstrlenW(lpszName) + 1; // +1 for NULL
        UINT cbAlloc;

        // For some reason we cap the length of this string. We can't cap
        // less than MAX_PATH because we need to handle filesys names.
        //
        if (cchLen > MAX_PATH)
            cchLen = MAX_PATH;

        // We want to allocate at least a medium size string because
        // many web pages script the title one character at a time.
        //
#define MIN_TITLE_ALLOC  64
        if (cchLen < MIN_TITLE_ALLOC)
            cbAlloc = MIN_TITLE_ALLOC * SIZEOF(*lpszName);
        else
            cbAlloc = cchLen * SIZEOF(*lpszName);
#undef  MIN_TITLE_ALLOC

        // Do we need to allocate?
        if (!(*ppszName) || LocalSize((HLOCAL)(*ppszName)) < cbAlloc)
        {
            // Free up Old Title
            if(*ppszName)
                LocalFree((void *)(*ppszName));
                
            *ppszName = (LPWSTR)LocalAlloc(LPTR, cbAlloc);
        }

        if (*ppszName)
        {
            StrCpyNW(*ppszName, lpszName, cchLen);

            if (fFireEvent)
            {
                DWORD dwOptions;

                FireEvent_DoInvokeStringW(_bbd._pautoEDS, DISPID_TITLECHANGE, *ppszName);

                // If this is a desktop component, try to update the friendly name if necessary.
                if (!_fCheckedDesktopComponentName)
                {
                    _fCheckedDesktopComponentName = TRUE;
                    if (SUCCEEDED(GetTopFrameOptions(_pspOuter, &dwOptions)) && (dwOptions & FRAMEOPTIONS_DESKTOP))
                    {
                        WCHAR wszPath[MAX_URL_STRING];
                        if (SUCCEEDED(::IEGetDisplayName(pidl, wszPath, SHGDN_FORPARSING)))
                        {
                            UpdateDesktopComponentName(wszPath, lpszName);
                        }
                    }
                }
            }
        }
    }

    return NOERROR;
}
HRESULT CBaseBrowser2::GetTitle(IShellView* psv, LPWSTR pszName, DWORD cchName)
{
    LPWSTR psz;

    if (!psv || IsSameObject(_bbd._psv, psv))
    {
        psz = _bbd._pszTitleCur;
    }
    else if (EVAL(IsSameObject(_bbd._psvPending, psv) || !_bbd._psvPending))
    {
        psz = _bbd._pszTitlePending;
    }
    else
    {
        psz = NULL;
    }

    if (psz)
    {
        StrCpyNW(pszName, psz, cchName);
        return(S_OK);
    }
    else
    {
        *pszName = 0;
        return(E_FAIL);
    }
}

HRESULT CBaseBrowser2::GetParentSite(struct IOleInPlaceSite** ppipsite)
{
    *ppipsite = NULL;
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::GetOleObject(struct IOleObject** ppobjv)
{
    *ppobjv = NULL;
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::NotifyRedirect(IShellView * psv, LPCITEMIDLIST pidlNew, BOOL *pfDidBrowse)
{
    HRESULT hres = E_FAIL;
    
    if (pfDidBrowse)
        *pfDidBrowse = FALSE;

    if (IsSameObject(psv, _bbd._psv) ||
        IsSameObject(psv, _bbd._psvPending))
    {
        hres = _pbsOuter->_TryShell2Rename(psv, pidlNew);
        if (FAILED(hres)) 
        {
            // if we weren't able to just swap it, we've got to browse to it
            // but pass redirect so that we don't add a navigation stack item
            //
            // NOTE: the above comment is a bit old since we don't pass
            // redirect here. If we ever start passing redirect here,
            // we'll confuse ISVs relying on the NavigateComplete event
            // exactly mirroring when navigations enter the navigation stack.
            //
            hres = _psbOuter->BrowseObject(pidlNew, SBSP_WRITENOHISTORY | SBSP_SAMEBROWSER);

            if(pfDidBrowse)
                *pfDidBrowse = TRUE;
        }
    }

    return hres;
}

HRESULT CBaseBrowser2::SetFlags(DWORD dwFlags, DWORD dwFlagMask)
{
    if (dwFlagMask & BSF_REGISTERASDROPTARGET)
    {
        _fNoDragDrop = (!(dwFlags & BSF_REGISTERASDROPTARGET)) ? TRUE : FALSE;

        if (!_fNoDragDrop)
            _RegisterAsDropTarget();
        else
            _UnregisterAsDropTarget();
    }
    
    if (dwFlagMask & BSF_DONTSHOWNAVCANCELPAGE)
    {
        _fDontShowNavCancelPage = !!(dwFlags & BSF_DONTSHOWNAVCANCELPAGE);
    }

    if (dwFlagMask & BSF_HTMLNAVCANCELED)
    {
        _fHtmlNavCanceled = !!(dwFlags & BSF_HTMLNAVCANCELED);
    }

    return S_OK;
}

HRESULT CBaseBrowser2::GetFlags(DWORD *pdwFlags)
{
    DWORD dwFlags = 0;

    if (!_fNoDragDrop)
        dwFlags |= BSF_REGISTERASDROPTARGET;
        
    if (_fTopBrowser)
        dwFlags |= BSF_TOPBROWSER;

    if (_grfHLNFPending & HLNF_CREATENOHISTORY)
        dwFlags |= BSF_NAVNOHISTORY;

    if (_fHtmlNavCanceled)
        dwFlags |= BSF_HTMLNAVCANCELED;
    
    if (_dwDocFlags & DOCFLAG_SETNAVIGATABLECODEPAGE)
        dwFlags |= BSF_SETNAVIGATABLECODEPAGE;

    if (_dwDocFlags & DOCFLAG_NAVIGATEFROMDOC)
        dwFlags |= BSF_DELEGATEDNAVIGATION;

    *pdwFlags = dwFlags;

    return S_OK;
}


HRESULT CBaseBrowser2::UpdateWindowList(void)
{
    // code used to assert, but in WebBrowserOC cases we can get here.
    return E_UNEXPECTED;
}

STDMETHODIMP CBaseBrowser2::IsControlWindowShown(UINT id, BOOL *pfShown)
{
    if (pfShown)
        *pfShown = FALSE;
    return E_NOTIMPL;
}

STDMETHODIMP CBaseBrowser2::ShowControlWindow(UINT id, BOOL fShow)
{
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::IEGetDisplayName(LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags)
{
    return ::IEGetDisplayName(pidl, pwszName, uFlags);
}

HRESULT CBaseBrowser2::IEParseDisplayName(UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut)
{
    HRESULT hr;
    IBindCtx * pbc = NULL;    
    WCHAR wzParsedUrl[MAX_URL_STRING];

    //
    // if we can find a search context living in a host somewhere,
    // then we need to pass that into ParseUrlFromOutsideSource
    // because it'll use it to customize the behavior of
    // the search hooks if a search ends up happening
    //

    ISearchContext *  pSC = NULL;
    QueryService(SID_STopWindow, IID_PPV_ARG(ISearchContext, &pSC));

    //
    // NOTE: This URL came from the user, so we need to clean it up.
    //       If the user entered "yahoo.com" or "Search Get Rich Quick",
    //       it will be turned into a search URL by ParseURLFromOutsideSourceW().
    //

    DWORD cchParsedUrl = ARRAYSIZE(wzParsedUrl);
    if (!ParseURLFromOutsideSourceWithContextW(pwszPath, wzParsedUrl, &cchParsedUrl, NULL, pSC))
    {
        StrCpyN(wzParsedUrl, pwszPath, ARRAYSIZE(wzParsedUrl));
    } 

    if (pSC != NULL)
    {
        pSC->Release();
    }

    // This is currently used for FTP, so we only do it for FTP for perf reasons.
    if (URL_SCHEME_FTP == GetUrlSchemeW(wzParsedUrl))
        pbc = CreateBindCtxForUI(SAFECAST(this, IOleContainer *));  // We really want to cast to (IUnknown *) but that's ambiguous.
    
    hr = IEParseDisplayNameWithBCW(uiCP, wzParsedUrl, pbc, ppidlOut);
    ATOMICRELEASE(pbc);

    return hr;
}

HRESULT _DisplayParseError(HWND hwnd, HRESULT hres, LPCWSTR pwszPath)
{
    if (FAILED(hres)
        && hres != E_OUTOFMEMORY
        && hres != HRESULT_FROM_WIN32(ERROR_CANCELLED))
    {
        TCHAR szPath[MAX_URL_STRING];
        SHUnicodeToTChar(pwszPath, szPath, ARRAYSIZE(szPath));
        MLShellMessageBox(hwnd,
                        MAKEINTRESOURCE(IDS_ERROR_GOTO),
                        MAKEINTRESOURCE(IDS_TITLE),
                        MB_OK | MB_SETFOREGROUND | MB_ICONSTOP,
                        szPath);

        hres = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }

    return hres;
}

HRESULT CBaseBrowser2::DisplayParseError(HRESULT hres, LPCWSTR pwszPath)
{
    return _DisplayParseError(_bbd._hwnd, hres, pwszPath);
}

HRESULT CBaseBrowser2::_CheckZoneCrossing(LPCITEMIDLIST pidl)
{
    if (!(_dwDocFlags & DOCFLAG_NAVIGATEFROMDOC))
    {
        return _pbsOuter->v_CheckZoneCrossing(pidl);
    }

    return S_OK;
}


// if in global offline mode and this item requires net access and it is
// not in the cache put up UI to go online.
//
// returns:
//      S_OK        URL is ready to be accessed
//      E_ABORT     user canceled the UI

HRESULT CBaseBrowser2::_CheckInCacheIfOffline(LPCITEMIDLIST pidl, BOOL fIsAPost)
{
    HRESULT hr = S_OK;      // assume it is
    VARIANT_BOOL fFrameIsSilent;
    VARIANT_BOOL fFrameHasAmbientOfflineMode;

    EVAL(SUCCEEDED(_bbd._pautoWB2->get_Silent(&fFrameHasAmbientOfflineMode)));    // should always work

    EVAL(SUCCEEDED(_bbd._pautoWB2->get_Offline(&fFrameIsSilent)));   
    if ((fFrameIsSilent == VARIANT_FALSE) &&
        (fFrameHasAmbientOfflineMode == VARIANT_FALSE)&&
        pidl && (pidl != PIDL_NOTHING) && (pidl != PIDL_LOCALHISTORY) && 
        IsBrowserFrameOptionsPidlSet(pidl, BFO_USE_IE_OFFLINE_SUPPORT) && 
        IsGlobalOffline()) 
    {
        TCHAR szURL[MAX_URL_STRING];
        EVAL(SUCCEEDED(::IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szURL, SIZECHARS(szURL), NULL)));

        if (UrlHitsNet(szURL) && ((!UrlIsMappedOrInCache(szURL)) || fIsAPost))
        {
            // UI to allow user to go on-line
            HWND hParentWnd = NULL; // init to suppress bogus C4701 warning

            hr = E_FAIL;
            if(!_fTopBrowser)
            {
               IOleWindow *pOleWindow;
               hr = _pspOuter->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IOleWindow, &pOleWindow));
               if(SUCCEEDED(hr))
               { 
                    ASSERT(pOleWindow);
                    hr = pOleWindow->GetWindow(&hParentWnd);
                    pOleWindow->Release();
               }
            }
            
            if (S_OK != hr)
            {
                hr = S_OK;
                hParentWnd = _bbd._hwnd;
            }


            _psbOuter->EnableModelessSB(FALSE);
            if (InternetGoOnline(szURL, hParentWnd, FALSE))
            {
                // Tell all browser windows to update their title and status pane
                SendShellIEBroadcastMessage(WM_WININICHANGE,0,0, 1000); 
            }    
            else
                hr = E_ABORT;   // user abort case...

            _psbOuter->EnableModelessSB(TRUE);
        }
    }

    return hr;
}


// This function exists to prevent us from using the stack space too long.
// We will use it here and then free it when we return.
HRESULT CBaseBrowser2::_ReplaceWithGoHome(LPCITEMIDLIST * ppidl, LPITEMIDLIST * ppidlFree)
{
    TCHAR szHome[MAX_URL_STRING];
    HRESULT hres = _GetStdLocation(szHome, ARRAYSIZE(szHome), DVIDM_GOHOME);

    if (SUCCEEDED(hres))
    {
        hres = IECreateFromPath(szHome, ppidlFree);
        if (SUCCEEDED(hres))
        {
            *ppidl = *ppidlFree;
        }
    }

    return hres;
}

// this does all the preliminary checking of whether we can navigate to pidl or not.
// then if all is ok, we do the navigate with CreateNewShellViewPidl
HRESULT CBaseBrowser2::_NavigateToPidl(LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD fSBSP)
{
    HRESULT hres;
    BOOL fCanceledDueToOffline = FALSE;
    BOOL fIsAPost = FALSE;  
    LPITEMIDLIST pidlFree = NULL;

    //
    // If we are processing a modal dialog, don't process it.
    //
    // NOTES: Checking _cRefCannotNavigate is supposed to be enough, but
    //  since we are dealing with random ActiveX objects, we'd better be
    //  robust. That's why we check IsWindowEnabled as well.
    //
    if ((S_OK ==_DisableModeless()) || !IsWindowEnabled(_bbd._hwnd)) 
    {
        TraceMsg(DM_ENABLEMODELESS, "CSB::_NavigateToPidl returning ERROR_BUSY");
        hres = HRESULT_FROM_WIN32(ERROR_BUSY);
        goto Done;
    }

    TraceMsg(DM_NAV, "ief NAV::%s %x %x",TEXT("_NavigateToPidl called"), pidl, grfHLNF);
    // used to be we would pull a NULL out of the 
    // the TravelLog, but i dont think that happens anymore
    ASSERT(pidl);  // Get ZEKEL

    // Sometimes we are navigated to the INTERNET shell folder
    // if this is the case, we really want to goto the Start Page.
    // This case only happens if you select "Internet Explorer" from the 
    // Folder Explorer Band.
    if (IsBrowserFrameOptionsPidlSet(pidl, BFO_SUBSTITUE_INTERNET_START_PAGE))
    {
        hres = _ReplaceWithGoHome(&pidl, &pidlFree);
        if (FAILED(hres))
            goto Done;
    }

    // We should only fire the BeforeNavigate event
    // if the document is not going to fire it.
    // We know that the document will fire it if
    // the document didn't call Navigate, the document
    // knows how to navigate and the document isn't hyperlinking.
    //
    if (!(_dwDocFlags & DOCFLAG_NAVIGATEFROMDOC))
    {
        hres = _FireBeforeNavigateEvent(pidl, &fIsAPost);
        if (hres == E_ABORT)
            goto Done;   // event handler told us to cancel
    }

    // if we can't go here (?), cancel the navigation
    hres = _CheckZoneCrossing(pidl);
    if (hres != S_OK)
        goto Done;
        
    TraceMsg(DM_NAV, "ief NAV::%s %x %x",TEXT("_CreateNewShellViewPidl called"), pidl, grfHLNF);

    //
    // Now that we are actually navigating...
    //

    // tell the frame to cancel the current navigation
    // and tell it about history navigate options as it will not be getting it
    // from subsequent call to Navigate
    //
    if (_bbd._phlf) 
    {
        _bbd._phlf->Navigate(grfHLNF&(SHHLNF_WRITENOHISTORY|SHHLNF_NOAUTOSELECT), NULL, NULL, NULL);
    }

    hres = _CheckInCacheIfOffline(pidl, fIsAPost);
    if (hres != S_OK) 
    {
        fCanceledDueToOffline = TRUE;
        goto Done;
    }


    //
    //  if we goto the current page, we still do a full navigate
    //  but we dont want to create a new entry.
    //
    //  **EXCEPTIONS**
    //  if this was a generated page, ie Trident did doc.writes(),
    //  we need to always create a travel entry, because trident 
    //  can rename the pidl, but it wont actually be that page.
    //
    //  if this was a post then we need to create a travelentry.
    //  however if it was a travel back/fore, it will already have
    //  set the the bit, so we still wont create a new entry.
    //
    //
    //  NOTE: this is similar to a refresh, in that it reparses
    //  the entire page, but creates no travel entry.
    //
    if (   !_fDontAddTravelEntry                 // If the flag is already set, short circuit the rest
        && !fIsAPost                             // ...and not a Post
        && !_fGeneratedPage                      // ...and not a Generated Page
        && !(grfHLNF & HLNF_CREATENOHISTORY)     // ...and the CREATENOHISTORY flag is NOT set
        && pidl                                  // ...and we have a pidl to navigate to
        && _bbd._pidlCur                         // ...as well as a current pidl
        && ILIsEqual(pidl, _bbd._pidlCur)        // ...and the pidls are equal
        )
        _fDontAddTravelEntry = TRUE;             // Then set the DontAddTravelEntry flag.

    TraceMsg(TF_TRAVELLOG, "CBB:_NavToPidl() _fDontAddTravelEntry = %d", _fDontAddTravelEntry);

    _fGeneratedPage = FALSE;

    hres = _CreateNewShellViewPidl(pidl, grfHLNF, fSBSP);

    _dwDocFlags &= ~(DOCFLAG_NAVIGATEFROMDOC | DOCFLAG_SETNAVIGATABLECODEPAGE);

    if (SUCCEEDED(hres))
    {
        ATOMICRELEASE(_pHTMLDocument);
    }

Done:
    if (FAILED(hres))
    {
        TraceMsg(DM_WARNING, "CSB::_NavigateToPidl _CreateNewShellViewPidl failed %x", hres);

        // On failure we won't hit _ActivatePendingView
        OnReadyStateChange(NULL, READYSTATE_COMPLETE);

        //  if this was navigation via ITravelLog, 
        //  this will revert us to the original position
        if (_fDontAddTravelEntry)
        {
            ITravelLog *ptl;
        
            if(SUCCEEDED(GetTravelLog(&ptl)))
            {
                ptl->Revert();
                ptl->Release();
            }
            _fDontAddTravelEntry = FALSE;
            ASSERT(!_fIsLocalAnchor);

            ATOMICRELEASE(_poleHistory);
            ATOMICRELEASE(_pbcHistory);
            ATOMICRELEASE(_pstmHistory);
        }
        if (_pbsOuter)
            _pbsOuter->UpdateBackForwardState();

        //  we failed and have nothing to show for it...
        if (!_bbd._pidlCur && !_fNavigatedToBlank)
        {
            TCHAR szResURL[MAX_URL_STRING];

            if (fCanceledDueToOffline)
            {
                hres = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                         HINST_THISDLL,
                                         ML_CROSSCODEPAGE,
                                         TEXT("offcancl.htm"),
                                         szResURL,
                                         ARRAYSIZE(szResURL),
                                         TEXT("shdocvw.dll"));
                if (SUCCEEDED(hres))
                {
                    _ShowBlankPage(szResURL, pidl);
                }
            }
            else
            {
                // NT #274562: We only want to navigate to the
                //    about:NavigationCancelled page if it wasn't
                //    a navigation to file path. (UNC or Drive).
                //    The main reason for this is that if the user
                //    enters "\\unc\share" into Start->Run and
                //    the window can't successfully navigate to the
                //    share because permissions don't allow it, we
                //    want to close the window after the user hits
                //    [Cancel] in the [Retry][Cancel] dialog.  This
                //    is to prevent the shell from appearing to have
                //    shell integrated bugs and to be compatible with
                //    the old shell.
                if ( IsBrowserFrameOptionsPidlSet(_bbd._pidlCur, BFO_SHOW_NAVIGATION_CANCELLED ) )
                {
                    hres = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                             HINST_THISDLL,
                                             ML_CROSSCODEPAGE,
                                             TEXT("navcancl.htm"),
                                             szResURL,
                                             ARRAYSIZE(szResURL),
                                             TEXT("shdocvw.dll"));
                    if (SUCCEEDED(hres))
                    {
                        _ShowBlankPage(szResURL, pidl);
                    }
                }
            }
        }
    }

    ILFree(pidlFree);
    
    return hres;
}

HRESULT CBaseBrowser2::OnReadyStateChange(IShellView* psvSource, DWORD dwReadyState)
{
    BOOL fChange = FALSE;

    if (psvSource)
    {
        if (IsSameObject(psvSource, _bbd._psv))
        {
            TraceMsg(TF_SHDNAVIGATE, "basesb(%x)::OnReadyStateChange(Current, %d)", this, dwReadyState);
            fChange = (_dwReadyStateCur != dwReadyState);
            _dwReadyStateCur = dwReadyState;
            if ((READYSTATE_COMPLETE == dwReadyState) && !_fReleasingShellView)
                _Exec_psbMixedZone();
        }
        else if (IsSameObject(psvSource, _bbd._psvPending))
        {
            TraceMsg(TF_SHDNAVIGATE, "basesb(%x)::OnReadyStateChange(Pending, %d)", this, dwReadyState);
            fChange = (_dwReadyStatePending != dwReadyState);
            _dwReadyStatePending = dwReadyState;
        }
        else if (!_bbd._psvPending)
        {
            // Assume psvSource != _bbd._psv && NULL==_bbd._psvPending
            // means that _SwitchActivationNow is in the middle
            // of _MayPlayTransition's message loop and the
            // _bbd._psvPending dude is updating us.
            //
            // NOTE: We don't fire the event because get_ReadyState
            // can't figure this out. We know we will eventually
            // fire the event because CBaseBrowser2 will go to _COMPLETE
            // after _SwitchActivationNow.
            //
            TraceMsg(TF_SHDNAVIGATE, "basesb(%x)::OnReadyStateChange(ASSUMED Pending, %d)", this, dwReadyState);
            _dwReadyStatePending = dwReadyState;
       }
    }
    else
    {
        // We use this function when our own simulated
        // ReadyState changes
        //
        TraceMsg(TF_SHDNAVIGATE, "basesb(%x)::OnReadyStateChange(Self, %d)", this, dwReadyState);
        fChange = (_dwReadyState != dwReadyState);
        _dwReadyState = dwReadyState;
    }

    // No sense in firing events if nothing actually changed...
    //
    if (fChange && _bbd._pautoEDS)
    {
        DWORD dw;

        IUnknown_CPContainerOnChanged(_pauto, DISPID_READYSTATE);

        // if we at Complete, fire the event
        get_ReadyState(&dw);
        if (READYSTATE_COMPLETE == dw)
        {
            if (  !(_dwDocFlags & DOCFLAG_DOCCANNAVIGATE)
               || !_bbd._fIsViewMSHTML)
            {
                FireEvent_DocumentComplete(_bbd._pautoEDS, _bbd._pautoWB2, _bbd._pidlCur);
            }

            // If we hit this, we have not picked up the history object we created.
            //
            AssertMsg(_fDontAddTravelEntry || !_poleHistory, TEXT("CBB::OnDocComplete: nobody picked up _poleHistory"));

            if (g_dwProfileCAP & 0x00080000) 
            {
                StopCAP();
            }
            
            ATOMICRELEASE(_pphHistory);
        }
    }

    return S_OK;
}

HRESULT CBaseBrowser2::get_ReadyState(DWORD * pdwReadyState)
{
    DWORD dw = _dwReadyState;

    if (_bbd._psvPending && _dwReadyStatePending < dw)
    {
        dw = _dwReadyStatePending;
    }

    if (_bbd._psv && _dwReadyStateCur < dw)
    {
        dw = _dwReadyStateCur;
    }

    *pdwReadyState = dw;

    return S_OK;
}

HRESULT CBaseBrowser2::_updateNavigationUI()
{
    if (_fNavigate || _fDescendentNavigate)
    {
        SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
        if (!_fDownloadSet)
        {
            FireEvent_DoInvokeDispid(_bbd._pautoEDS, DISPID_DOWNLOADBEGIN);
            _fDownloadSet = TRUE;
        }   
    }
    else
    {
        if (_fDownloadSet)
        {
            FireEvent_DoInvokeDispid(_bbd._pautoEDS, DISPID_DOWNLOADCOMPLETE);
            _fDownloadSet = FALSE;
        }
        SetCursor(LoadCursor(NULL, IDC_ARROW));            
    }

    return S_OK;
}

HRESULT CBaseBrowser2::SetNavigateState(BNSTATE bnstate)
{
    switch (bnstate) 
    {
    case BNS_BEGIN_NAVIGATE:
    case BNS_NAVIGATE:
        _fNavigate = TRUE;
        _updateNavigationUI();
        break;

    case BNS_NORMAL:
        _fNavigate = FALSE;
        _updateNavigationUI();
        break;
    }
    return S_OK;
}


HRESULT CBaseBrowser2::GetNavigateState(BNSTATE *pbnstate)
{
    // Return Navigate if we are processing a navigation or if
    // we are processing a modal dialog.
    //
    // NOTES: Checking _cRefCannotNavigate is supposed to be enough, but
    //  since we are dealing with random ActiveX objects, we'd better be
    //  robust. That's why we check IsWindowEnabled as well.
    //
    *pbnstate = (_fNavigate || (S_OK ==_DisableModeless()) || _fDescendentNavigate ||
            !IsWindowEnabled(_bbd._hwnd)) ? BNS_NAVIGATE : BNS_NORMAL;
    return S_OK;
}

HRESULT CBaseBrowser2::UpdateBackForwardState(void)
{
    if (_fTopBrowser) 
    {
        _UpdateBackForwardState();
    } 
    else 
    {
        // sigh, BrowserBand now makes this fire
        //ASSERT(_fTopBrowser);
        IBrowserService *pbs = NULL;
        TraceMsg(TF_SHDNAVIGATE, "cbb.ohlfn: !_fTopBrowser (BrowserBand?)");
        if (SUCCEEDED(_pspOuter->QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IBrowserService, &pbs)))) 
        {
            BOOL fTopFrameBrowser = IsSameObject(pbs, SAFECAST(this, IShellBrowser *));
            if (!fTopFrameBrowser)
                pbs->UpdateBackForwardState();
            else 
                _UpdateBackForwardState();
            pbs->Release();        
        }
    }
    return S_OK;
}


HRESULT CBaseBrowser2::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;

    //
    // NOTES: Notice that CBaseBrowser2 directly expose the automation
    //  service object via QueryService. CWebBrowserSB will appropriately
    //  dispatch those. See comments on CWebBrowserSB::QueryService for
    //  detail. (SatoNa)
    //
    if (IsEqualGUID(guidService, SID_SWebBrowserApp) || 
        IsEqualGUID(guidService, SID_SContainerDispatch) || 
        IsEqualGUID(guidService, IID_IExpDispSupport))
    {
        hr = _bbd._pautoSS->QueryInterface(riid, ppv);
    }
    else  if (IsEqualGUID(guidService, SID_SHlinkFrame) || 
              IsEqualGUID(guidService, IID_ITargetFrame2) || 
              IsEqualGUID(guidService, IID_ITargetFrame)) 
    {
        hr = _ptfrm->QueryInterface(riid, ppv);
    }
    else if (IsEqualGUID(guidService, SID_STopLevelBrowser) || 
             IsEqualGUID(guidService, SID_STopFrameBrowser) ||
             IsEqualGUID(guidService, SID_STopWindow) ||
             IsEqualGUID(guidService, SID_SProfferService))
    {
        if (IsEqualGUID(riid, IID_IUrlHistoryStg))
        {
            ASSERT(_fTopBrowser);

            if (!_pIUrlHistoryStg)
            {
                // create this object the first time it's asked for
                CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER,
                        IID_PPV_ARG(IUrlHistoryStg, &_pIUrlHistoryStg));
            }

            if (_pIUrlHistoryStg)
                hr = _pIUrlHistoryStg->QueryInterface(riid, ppv);
            else
                hr = E_NOINTERFACE;
        }
        else if (IsEqualGUID(riid, IID_IToolbarExt))
        {
            // This code should all migrate to a helper object after IE5B2. So this
            // should be temporary (stevepro).
            if (!_pToolbarExt)
            {
                IUnknown* punk;
                if (SUCCEEDED(CBrowserExtension_CreateInstance(NULL, &punk, NULL)))
                {
                    IUnknown_SetSite(punk, _psbOuter);
                    punk->QueryInterface(IID_PPV_ARG(IToolbarExt, &_pToolbarExt));
                    punk->Release();
                }
            }

            if (_pToolbarExt)
                hr = _pToolbarExt->QueryInterface(riid, ppv);
            else
                hr = E_NOINTERFACE;
        }
        else
            hr = QueryInterface(riid, ppv);
    }
    else if (IsEqualGUID(guidService, SID_SUrlHistory)) 
    {
        if (!_pIUrlHistoryStg)
        {
            // Asking for it creates a copy in _pIUrlHistoryStg
            IUrlHistoryStg *puhs;
            if (SUCCEEDED(_pspOuter->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IUrlHistoryStg, &puhs))))
            {
                if (!_pIUrlHistoryStg)
                    _pIUrlHistoryStg = puhs;
                else
                    puhs->Release();
            }
        }
        
        if (_pIUrlHistoryStg)
            hr = _pIUrlHistoryStg->QueryInterface(riid, ppv);
        else
            hr = E_NOINTERFACE;
    }
    else if (IsEqualGUID(guidService, SID_SShellBrowser) || 
             IsEqualGUID(guidService, SID_SVersionHost)) 
    {
        if (IsEqualIID(riid, IID_IHlinkFrame)) 
        {
            // HACK: MSHTML uses IID_IShellBrowser instead of SID_SHlinkFrame
            hr = _pspOuter->QueryService(SID_SHlinkFrame, riid, ppv);
        } 
        else if (IsEqualIID(riid, IID_IBindCtx) && _bbd._phlf) 
        {
            // HACK ALERT: Notice that we are using QueryService to the
            //  other direction here. We must make it absolutely sure
            //  that we'll never infinitly QueryService each other.
            hr = IUnknown_QueryService(_bbd._phlf, IID_IHlinkFrame, riid, ppv);
        } 
        else 
        {
            hr = QueryInterface(riid, ppv);
        }
    }
    else if (IsEqualGUID(guidService, SID_SOmWindow))
    {
        // HACK ALERT: Notice that we are using QueryService to the
        //  other direction here. We must make it absolutely sure
        //  that we'll never infinitly QueryService each other.
        hr = IUnknown_QueryService(_ptfrm, SID_SOmWindow, riid, ppv);
    }
    else if (IsEqualGUID(guidService, IID_IElementNamespaceTable) && _bbd._psv)
    {
        hr = IUnknown_QueryService(_bbd._psv, IID_IElementNamespaceTable, riid, ppv);
    }
    else if (IsEqualGUID(guidService, SID_STravelLogCursor))
    {
        // exposed travel log object
        if (!_pITravelLogStg)
        {    
            // create this object the first time it's asked for
            ITravelLog * ptl;
            GetTravelLog(&ptl);

            ITravelLogEx *ptlx;
            if (ptl && SUCCEEDED(ptl->QueryInterface(IID_PPV_ARG(ITravelLogEx, &ptlx))))
            {
                hr = CreatePublicTravelLog(SAFECAST(this, IBrowserService *), ptlx, &_pITravelLogStg);
                ptlx->Release();
            }
            SAFERELEASE(ptl);
        }
        
        if (_pITravelLogStg)
        {         
            hr = _pITravelLogStg->QueryInterface(riid, ppv);
        }
    }
    else if (IsEqualGUID(riid,IID_IEnumPrivacyRecords))
    {
        IHTMLWindow2     * pIW  = NULL;
        IServiceProvider * pISP = NULL;

        hr = QueryService(IID_IHTMLWindow2, IID_PPV_ARG(IHTMLWindow2, &pIW));
        if (SUCCEEDED(hr))
        {
            hr = pIW->QueryInterface(IID_PPV_ARG(IServiceProvider, &pISP));
            if (SUCCEEDED(hr))
            {
                hr = pISP->QueryService(IID_IEnumPrivacyRecords, IID_IEnumPrivacyRecords, ppv);
                pISP->Release();
            }
            pIW->Release();
        }        
    }
    else
    {
        hr = IProfferServiceImpl::QueryService(guidService, riid, ppv);
    }

    ASSERT(SUCCEEDED(hr) ? *ppv != NULL : *ppv == NULL);  // COM rules

    return hr;
}


void CBaseBrowser2::OnDataChange(FORMATETC *, STGMEDIUM *)
{
}

void CBaseBrowser2::OnViewChange(DWORD dwAspect, LONG lindex)
{
    _ViewChange(dwAspect, lindex);
}

void CBaseBrowser2::OnRename(IMoniker *)
{
}

void CBaseBrowser2::OnSave()
{
}

void CBaseBrowser2::OnClose()
{
    _ViewChange(DVASPECT_CONTENT, -1);
}


// *** IDropTarget ***

// These methods are defined in shdocvw.cpp
extern DWORD CommonDragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt);


// Use the ShellView IDropTarget functions whenever they are implemented

// IDropTarget::DragEnter

HRESULT CBaseBrowser2::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    if (_pdtView)
        return _pdtView->DragEnter(pdtobj, grfKeyState, ptl, pdwEffect);
    else 
    {
        if (_fNoDragDrop)
        {
            _dwDropEffect = DROPEFFECT_NONE;
        }
        else
        {
            _dwDropEffect = CommonDragEnter(pdtobj, grfKeyState, ptl);
        }
        *pdwEffect &= _dwDropEffect;
    }
    return S_OK;
}

// IDropTarget::DragOver

HRESULT CBaseBrowser2::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    if (S_OK == _DisableModeless()) 
    {
        *pdwEffect = 0;
        return S_OK;
    }

    if (_pdtView)
        return _pdtView->DragOver(grfKeyState, ptl, pdwEffect);

    *pdwEffect &= _dwDropEffect;
    return S_OK;    
}


// IDropTarget::DragLeave

HRESULT CBaseBrowser2::DragLeave(void)
{
    if (_pdtView)
        return _pdtView->DragLeave();
    return S_OK;
}


// IDropTarget::DragDrop

HRESULT CBaseBrowser2::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    if (S_OK == _DisableModeless()) 
    {
        *pdwEffect = 0;
        return S_OK;
    }
    BOOL fNavigateDone = FALSE;
    HRESULT hr = E_FAIL;
    // If this is a shortcut - we want it to go via _NavIEShortcut
    // First check if it indeed a shortcut

    STGMEDIUM medium;

    if (_ptfrm && (DataObj_GetDataOfType(pdtobj, CF_HDROP, &medium)))
    {         
        WCHAR wszPath[MAX_PATH];

        if (DragQueryFileW((HDROP)medium.hGlobal, 0, wszPath, ARRAYSIZE(wszPath)))
        {
            LPWSTR pwszExtension = PathFindExtensionW(wszPath);
            // Check the extension to see if it is a .URL file

            if (0 == StrCmpIW(pwszExtension, L".url"))
            {
                // It is an internet shortcut 
                VARIANT varShortCutPath = {0};
                VARIANT varFlag = {0};

                varFlag.vt = VT_BOOL;
                varFlag.boolVal = VARIANT_TRUE;

                LBSTR::CString strPath( wszPath );

                varShortCutPath.vt = VT_BSTR;
                varShortCutPath.bstrVal = strPath;

                hr = IUnknown_Exec(_ptfrm, &CGID_Explorer, SBCMDID_IESHORTCUT, 0, &varShortCutPath, &varFlag);
                fNavigateDone = SUCCEEDED(hr);   
                if(fNavigateDone)
                {
                    DragLeave();
                }
            }
        }

        // must call ReleaseStgMediumHGLOBAL since DataObj_GetDataOfType added an extra GlobalLock
        ReleaseStgMediumHGLOBAL(NULL, &medium);
    }

    if (FALSE == fNavigateDone)
    {
        if (_pdtView)
        {
            hr = _pdtView->Drop(pdtobj, grfKeyState, pt, pdwEffect);
        }
        else 
        {
            LPITEMIDLIST pidlTarget;
            hr = SHPidlFromDataObject(pdtobj, &pidlTarget, NULL, 0);
            if (SUCCEEDED(hr))
            {
                ASSERT(pidlTarget);
                hr = _psbOuter->BrowseObject(pidlTarget, SBSP_SAMEBROWSER | SBSP_ABSOLUTE);
                ILFree(pidlTarget);
            }
        }
    }

    return hr;
}

HRESULT CBaseBrowser2::_FireBeforeNavigateEvent(LPCITEMIDLIST pidl, BOOL* pfIsPost)
{
    HRESULT hres = S_OK;

    IBindStatusCallback * pBindStatusCallback;
    LPTSTR pszHeaders = NULL;
    LPBYTE pPostData = NULL;
    DWORD cbPostData = 0;
    BOOL fCancelled=FALSE;
    STGMEDIUM stgPostData;
    BOOL fHavePostStg = FALSE;

    *pfIsPost = FALSE;
    
    // If this is the first BeforeNavigateEvent of a ViewLinkedWebOC we do not need to fire.
    // It is fired by the hosting Trident. Note that _fIsViewLinkedWebOC is only set by the 
    // host, so we need not worry about BeforeNavigateEvent not being fired for other in other
    // instances of the WebOC.

    if (_fIsViewLinkedWebOC && (!_fHadFirstBeforeNavigate))
    {
        _fHadFirstBeforeNavigate = TRUE;
        return hres;
    }

    // get the bind status callback for this browser and ask it for
    // headers and post data
    if (SUCCEEDED(GetTopLevelPendingBindStatusCallback(this,&pBindStatusCallback))) 
    {
        GetHeadersAndPostData(pBindStatusCallback,&pszHeaders,&stgPostData,&cbPostData, pfIsPost);
        pBindStatusCallback->Release();
        fHavePostStg = TRUE;

        if (stgPostData.tymed == TYMED_HGLOBAL) 
        {
            pPostData = (LPBYTE) stgPostData.hGlobal;
        }
    }

    // Fire a BeforeNavigate event to inform container that we are about
    // to navigate and to give it a chance to cancel.  We have to ask
    // for post data and headers to pass to event, so only do this if someone
    // is actually hooked up to the event (HasSinks() is TRUE).
    //if (_bbd._pautoEDS->HasSinks()) 
    {
        TCHAR szFrameName[MAX_URL_STRING];
        SHSTR strHeaders;

        szFrameName[0] = 0;

        // get our frame name
        ITargetFrame2 *pOurTargetFrame;
        hres = TargetQueryService(SAFECAST(this, IShellBrowser *), IID_PPV_ARG(ITargetFrame2, &pOurTargetFrame));
        if (SUCCEEDED(hres))
        {
            LPOLESTR pwzFrameName = NULL;
            pOurTargetFrame->GetFrameName(&pwzFrameName);
            pOurTargetFrame->Release();

            if (pwzFrameName) 
            {
                SHUnicodeToTChar(pwzFrameName, szFrameName, ARRAYSIZE(szFrameName));
                CoTaskMemFree(pwzFrameName);            
            }               
        }

        strHeaders.SetStr(pszHeaders);

        _pidlBeforeNavigateEvent = (LPITEMIDLIST) pidl; // no need to copy

        // This is a work around for view linked weboc. Setting the frame name has side effects.
        
        TCHAR * pEffectiveName;

        if (_fIsViewLinkedWebOC && !szFrameName[0])
        {
            pEffectiveName = _szViewLinkedWebOCFrameName;
        }
        else
        {
            pEffectiveName = szFrameName[0] ? szFrameName : NULL;
        }

        // fire the event!
        FireEvent_BeforeNavigate(_bbd._pautoEDS, _bbd._hwnd, _bbd._pautoWB2,
            pidl, NULL, 0, pEffectiveName,
            pPostData, cbPostData, strHeaders.GetStr(), &fCancelled);

        ASSERT(_pidlBeforeNavigateEvent == pidl);
        _pidlBeforeNavigateEvent = NULL;

        // free anything we alloc'd above
        if (pszHeaders)
        {
            LocalFree(pszHeaders);
            pszHeaders = NULL;
        }

        if (fCancelled) 
        {
            // container told us to cancel
            hres = E_ABORT;
        }
    }
    if (fHavePostStg) 
    {
        ReleaseStgMedium(&stgPostData);
    }
    return hres;
}

HRESULT CBaseBrowser2::SetTopBrowser()
{
    _fTopBrowser = TRUE;

#ifdef MESSAGEFILTER
    if (!_lpMF) 
    {
        /*
         * Create a message filter here to pull out WM_TIMER's while we are
         * busy.  The animation timer, along with other timers, can get
         * piled up otherwise which can fill the message queue and thus USER's
         * heap.
         */
        _lpMF = new CMsgFilter();

        if (_lpMF && !(((CMsgFilter *)_lpMF)->Initialize()))
        {
            ATOMICRELEASE(_lpMF);
        }
    }
#endif
    return S_OK;
}

HRESULT CBaseBrowser2::_ResizeView()
{
    _pbsOuter->_UpdateViewRectSize();
    if (_pact) 
    {
        RECT rc;
        GetBorder(&rc);
        TraceMsg(TF_SHDUIACTIVATE, "UIW::SetBorderSpaceDW calling _pact->ResizeBorder");
        _pact->ResizeBorder(&rc, this, TRUE);
    }
    return S_OK;
} 

HRESULT CBaseBrowser2::_ResizeNextBorder(UINT itb)
{
    // (derived class resizes inner toolbar if any)
    return _ResizeView();
}

HRESULT CBaseBrowser2::_OnFocusChange(UINT itb)
{
#if 0
    // the OC *does* get here (it's not aggregated so _pbsOuter->_OnFocusChange
    // ends up here not in commonsb).  not sure if E_NOTIMPL is o.k., but
    // for now it's what we'll do...
    ASSERT(0);
#endif
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus)
{
    ASSERT(0);          // split: untested!
    // do we need to do _UIActivateView?
    ASSERT(fSetFocus);  // i think?

    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::v_ShowHideChildWindows(BOOL fChildOnly)
{
    // (derived class does ShowDW on all toolbars)
    if (!fChildOnly) 
    {
        _pbsOuter->_ResizeNextBorder(0);
        // This is called in ResizeNextBorder 
        // _UpdateViewRectSize();
    }

    return S_OK;
}

//***   _ExecChildren -- broadcast Exec to view and toolbars
// NOTES
//  we might do *both* punkBar and fBroadcast if we want to send stuff
//  to both the view and to all toolbars, e.g. 'stop' or 'refresh'.
//
//  Note: n.b. the tray isn't a real toolbar, so it won't get called (sigh...).
HRESULT CBaseBrowser2::_ExecChildren(IUnknown *punkBar, BOOL fBroadcast, const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt,
    VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    //ASSERT(!fBroadcast);    // only derived class supports this
    // alanau: but CWebBrowserSB doesn't override this method, so we hit this assert.

    // 1st, send to specified guy (if requested)
    if (punkBar != NULL) 
    {
        // send to specified guy
        IUnknown_Exec(punkBar, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }

    // (derived class broadcasts to toolbars)

    return S_OK;
}

HRESULT CBaseBrowser2::_SendChildren(HWND hwndBar, BOOL fBroadcast, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
#if 0
    // the OC *does* get here (it's not aggregated so _pbsOuter->_SendChildren
    // ends up here not in commonsb).  since there are no kids i guess it's
    // ok to just drop the fBroadcast on the floor.
    ASSERT(!fBroadcast);    // only derived class supports this
#endif

    // 1st, send to specified guy (if requested)
    if (hwndBar != NULL)
    {
        // send to specified guy
        SendMessage(hwndBar, uMsg, wParam, lParam);
    }

    // (derived class broadcasts to toolbars)

    return S_OK;
}

//
//  Handle <META HTTP-EQUIV ...> headers for lower components
//
HRESULT CBaseBrowser2::OnHttpEquiv(IShellView* psv, BOOL fDone, VARIANT *pvarargIn, VARIANT *pvarargOut)
{
    return OLECMDERR_E_NOTSUPPORTED;
} // _HandleHttpEquiv

STDMETHODIMP CBaseBrowser2::GetPalette( HPALETTE * phpal )
{
    BOOL fRes = FALSE;
    if ( _hpalBrowser )
    {
       *phpal = _hpalBrowser;
       fRes = TRUE;
    }
    return fRes ? NOERROR : E_FAIL;
}


//
//  IPersist
//
HRESULT 
CBaseBrowser2::GetClassID(CLSID *pclsid)
{
    return E_NOTIMPL;
}

//
// IPersistHistory
//  
#ifdef DEBUG
#define c_szFrameMagic TEXT("IE4ViewStream")
#define c_cchFrameMagic SIZECHARS(c_szFrameMagic)
#endif

// NOTE this is almost the same kind of data that is 
//  stored in a TravelEntry.

typedef struct _PersistedFrame {
    DWORD cbSize;
    DWORD type;
    DWORD lock;
    DWORD bid;
    CLSID clsid;
    DWORD cbPidl;
} PERSISTEDFRAME, *PPERSISTEDFRAME;

#define PFTYPE_USEPIDL      1
#define PFTYPE_USECLSID     2

#define PFFLAG_SECURELOCK   0x00000001


HRESULT GetPersistedFrame(IStream *pstm, PPERSISTEDFRAME ppf, LPITEMIDLIST *ppidl)
{
    HRESULT hr;
    ASSERT(pstm);
    ASSERT(ppf);
    ASSERT(ppidl);

#ifdef DEBUG
    TCHAR szMagic[SIZECHARS(c_szFrameMagic)];
    DWORD cbMagic = CbFromCch(c_cchFrameMagic);

    ASSERT(SUCCEEDED(IStream_Read(pstm, (void *) szMagic, cbMagic)));
    ASSERT(!StrCmp(szMagic, c_szFrameMagic));
#endif //DEBUG

    // This is pointing to the stack, make sure it starts NULL
    *ppidl = NULL;

    if(SUCCEEDED(hr = IStream_Read(pstm, (void *) ppf, SIZEOF(PERSISTEDFRAME))))
    {
        if(ppf->cbSize == SIZEOF(PERSISTEDFRAME) && (ppf->type == PFTYPE_USECLSID || ppf->type == PFTYPE_USEPIDL))
        {
            //  i used SHAlloc() cuz its what all the IL functions use
            if(ppf->cbPidl)
                *ppidl = (LPITEMIDLIST) SHAlloc(ppf->cbPidl);
        
            if(*ppidl)
            {
                hr = IStream_Read(pstm, (void *) *ppidl, ppf->cbPidl);
                if(FAILED(hr))
                {
                    ILFree(*ppidl);
                    *ppidl = NULL;
                }
            }
            else 
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT
CBaseBrowser2::LoadHistory(IStream *pstm, IBindCtx *pbc)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(pstm);

    TraceMsg(TF_TRAVELLOG, "CBB::LoadHistory entered pstm = %X, pbc = %d", pstm, pbc);

    ATOMICRELEASE(_poleHistory);
    ATOMICRELEASE(_pstmHistory);
    ATOMICRELEASE(_pbcHistory);

    if (pstm)
    {
        PERSISTEDFRAME pf;
        LPITEMIDLIST pidl;

        hr = GetPersistedFrame(pstm, &pf, &pidl);
        if (SUCCEEDED(hr))
        {
            //  need to restore the previous bid
            //  if this is a new window
            ASSERT(pf.bid == _dwBrowserIndex || !_bbd._pidlCur);
            _dwBrowserIndex = pf.bid;
            _eSecureLockIconPending = pf.lock;

            if (pf.type == PFTYPE_USECLSID)
            {
                hr = E_FAIL;

                if (_pHTMLDocument)
                {
                    if (   (_dwDocFlags & DOCFLAG_DOCCANNAVIGATE)
                        && IsEqualCLSID(pf.clsid, CLSID_HTMLDocument))
                    {
                        IPersistHistory * pph;
                        hr = _pHTMLDocument->QueryInterface(IID_PPV_ARG(IPersistHistory, &pph));

                        if (SUCCEEDED(hr))
                        {
                            _fDontAddTravelEntry = TRUE;

                            hr = pph->LoadHistory(pstm, pbc);
                            TraceMsg(TF_TRAVELLOG, "CBB::LoadHistory called pole->LoadHistory, hr =%X", hr);

                            pph->Release();

                            return hr;
                        }
                    }
                    else
                    {
                        ATOMICRELEASE(_pHTMLDocument);  // We are going to cocreate a new document.
                    }
                }

                if (S_OK != hr)
                {
                    // Get the class and instantiate
                    hr = CoCreateInstance(pf.clsid, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IOleObject, &_poleHistory));
                }

                if (SUCCEEDED(hr))
                {
                    DWORD dwFlags;

                    hr = _poleHistory->GetMiscStatus(DVASPECT_CONTENT, &dwFlags);
                    if (SUCCEEDED(hr))
                    {
                        if (dwFlags & OLEMISC_SETCLIENTSITEFIRST)
                        {
                            pstm->AddRef();  
                            if (pbc)
                                pbc->AddRef();
 
                            // we need to addref because we will use it async
                            // whoever uses it needs to release.
                            _pstmHistory = pstm;
                            _pbcHistory = pbc;
                        }
                        else
                        {
                            IPersistHistory * pph;
                            hr = _poleHistory->QueryInterface(IID_PPV_ARG(IPersistHistory, &pph));

                            if (SUCCEEDED(hr))
                            {
                                hr = pph->LoadHistory(pstm, pbc);
                                TraceMsg(TF_TRAVELLOG, "CBB::LoadHistory called pole->LoadHistory, hr =%X", hr);

                                pph->Release();
                            }
                        }

                        //  if we made then set the prepared history object in 
                        //  _poleHistory
                        if (FAILED(hr))
                        {
                            ATOMICRELEASE(_poleHistory);
                            ATOMICRELEASE(_pstmHistory);
                            ATOMICRELEASE(_pbcHistory);
                        }
                    }
                }
            }
            
            //
            // just browse the object
            // if poleHistory is set, then when the dochost is created
            // it will pick up the object and use it.
            // other wise we will do a normal navigate.
            //
            if (pidl)
            {
                DEBUG_CODE(TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];)
                DEBUG_CODE(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL);)
                DEBUG_CODE(TraceMsg(DM_TRACE, "CBB::LoadHistory: URL - %ws", szPath);)

                _fDontAddTravelEntry = TRUE;
                hr = _psbOuter->BrowseObject(pidl, SBSP_SAMEBROWSER | SBSP_ABSOLUTE);
                ILFree(pidl);
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }

    TraceMsg(TF_TRAVELLOG, "CBB::LoadHistory exiting, hr =%X", hr);
    _pbsOuter->UpdateBackForwardState();
    return hr;
}

// Save a stream represeting the history at this point.
// Be sure to keep this and GetDummyWindowData in sync.

HRESULT
CBaseBrowser2::SaveHistory(IStream *pstm)
{
    HRESULT hr = E_UNEXPECTED;
    TraceMsg(TF_TRAVELLOG, "CBB::SaveHistory entering, pstm =%X", pstm);
    ASSERT(pstm);

    if(_bbd._pidlCur)
    {
        PERSISTEDFRAME pf = {0};
        pf.cbSize = SIZEOF(pf);
        pf.bid = GetBrowserIndex();
        pf.cbPidl = ILGetSize(_bbd._pidlCur);
        pf.type = PFTYPE_USEPIDL;
        pf.lock = _bbd._eSecureLockIcon;

        DEBUG_CODE(TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];)
        DEBUG_CODE(IEGetDisplayName(_bbd._pidlCur, szPath, SHGDN_FORPARSING);)
        
        ASSERT(SUCCEEDED(IStream_Write(pstm, (void *) c_szFrameMagic, CbFromCch(c_cchFrameMagic))));
    
        //
        //  in order to use IPersistHistory we need to get the CLSID of the Ole Object
        //  then we need to get IPersistHistory off that object
        //  then we can save the PERSISTEDFRAME and the pidl and then pass 
        //  the stream down into the objects IPersistHistory
        //

        //  Right now we circumvent the view object for history - zekel - 18-JUL-97
        //  right now we just grab the DocObj from the view object, and then query
        //  the Doc for IPersistHistory.  really what we should be doing is QI the view
        //  for pph, and then use it.  however this requires risky work with the
        //  navigation stack, and thus should be postponed to IE5.  looking to the future
        //  the view could persist all kinds of great state info
        //
        //  but now we just get the background object.  but check to make sure that it
        //  will be using the DocObjHost code by QI for IDocViewSite
        //

        //  _bbd._psv can be null in subframes that have not completed navigating
        //  before a refresh is called
        //
        if (!_pphHistory && _bbd._psv)
        {
            hr = SafeGetItemObject(_bbd._psv, SVGIO_BACKGROUND, IID_PPV_ARG(IPersistHistory, &_pphHistory));
        }

        if (_pphHistory)
        {
            IDocViewSite *pdvs;

            if (SUCCEEDED(_bbd._psv->QueryInterface(IID_PPV_ARG(IDocViewSite, &pdvs))) && 
                SUCCEEDED(hr = _pphHistory->GetClassID(&(pf.clsid))))
            {
                pf.type = PFTYPE_USECLSID;
                TraceMsg(TF_TRAVELLOG, "CBB::SaveHistory is PFTYPE_USECLSID");
            }

            ATOMICRELEASE(pdvs);
        }


        if (SUCCEEDED(hr = IStream_Write(pstm,(void *)&pf, pf.cbSize)))
            hr = IStream_Write(pstm,(void *)_bbd._pidlCur, pf.cbPidl);

        if (SUCCEEDED(hr) && pf.type == PFTYPE_USECLSID)
            hr = _pphHistory->SaveHistory(pstm);

        ATOMICRELEASE(_pphHistory);
    }
    
    TraceMsg(TF_TRAVELLOG, "CBB::SaveHistory exiting, hr =%X", hr);
    return hr;
}

HRESULT CBaseBrowser2::SetPositionCookie(DWORD dwPositionCookie)
{
    HRESULT hr = E_FAIL;
    //
    //  we force the browser to update its internal location and the address bar
    //  this depends on the fact that setposition cookie was always 
    //  started by a ptl->Travel(). so that the current position in the ptl
    //  is actually the correct URL for us to have.  zekel - 22-JUL-97
    //

    ITravelLog *ptl;
    GetTravelLog(&ptl);
    if(ptl)
    {
        ITravelEntry *pte;
        if(EVAL(SUCCEEDED(ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), 0, &pte))))
        {
            LPITEMIDLIST pidl;
            if(SUCCEEDED(pte->GetPidl(&pidl)))
            {
                BOOL fUnused;
                ASSERT(pidl);

                if (SUCCEEDED(hr = _FireBeforeNavigateEvent(pidl, &fUnused)))
                {
                    IPersistHistory *pph;
                    if(_bbd._psv && SUCCEEDED(hr = SafeGetItemObject(_bbd._psv, SVGIO_BACKGROUND, IID_PPV_ARG(IPersistHistory, &pph))))
                    {
                        ASSERT(pph);

                        //  now that we are certain that we are going to call into 
                        //   the document, we need to update the entry right before.
                        //  NOTE: after an update, we cannot revert if there was an
                        //  error in the Set...
                        ptl->UpdateEntry(SAFECAST(this, IShellBrowser *), TRUE);

                        hr = pph->SetPositionCookie(dwPositionCookie);
                        pph->Release();

                        //  this updates the browser to the new pidl, 
                        //  and navigates there directly if necessary.
                        BOOL fDidBrowse;
                        NotifyRedirect(_bbd._psv, pidl, &fDidBrowse);

                        if (!fDidBrowse)
                        {
                            // fire the event!
                            FireEvent_NavigateComplete(_bbd._pautoEDS, _bbd._pautoWB2, _bbd._pidlCur, _bbd._hwnd);          
                            FireEvent_DocumentComplete(_bbd._pautoEDS, _bbd._pautoWB2, _bbd._pidlCur);
                        }
                    }

                }
                ILFree(pidl);
            }
            pte->Release();
        }
        ptl->Release();
    }

    TraceMsg(TF_TRAVELLOG, "CBB::SetPositionCookie exiting, cookie = %X, hr =%X", dwPositionCookie, hr);
    
    return hr;
}

HRESULT CBaseBrowser2::GetPositionCookie(DWORD *pdwPositionCookie)
{
    HRESULT hr = E_FAIL;
    IPersistHistory *pph;
    ASSERT(pdwPositionCookie);

    if(pdwPositionCookie && _bbd._psv && SUCCEEDED(hr = SafeGetItemObject(_bbd._psv, SVGIO_BACKGROUND, IID_PPV_ARG(IPersistHistory, &pph))))
    {
        ASSERT(pph);

        hr = pph->GetPositionCookie(pdwPositionCookie);
        pph->Release();
    }

    TraceMsg(TF_TRAVELLOG, "CBB::GetPositionCookie exiting, cookie = %X, hr =%X", *pdwPositionCookie, hr);

    return hr;
}

DWORD CBaseBrowser2::GetBrowserIndex()
{
    //  the first time we request the index, we init it.
    if (!_dwBrowserIndex)
    {
        //
        //  the topframe browser all have the same browser index so 
        //  that they can trade TravelEntries if necessary.  because we now
        //  trade around TravelEntries, then we need to make the bids relatively
        //  unique.  and avoid ever having a random frame be BID_TOPFRAMEBROWSER
        //
        if (IsTopFrameBrowser(SAFECAST(this, IServiceProvider *), SAFECAST(this, IShellBrowser *)))
            _dwBrowserIndex = BID_TOPFRAMEBROWSER;
        else do
        {
            _dwBrowserIndex = SHRandom();

        } while (!_dwBrowserIndex || _dwBrowserIndex == BID_TOPFRAMEBROWSER);
        // psp->Release();

        TraceMsg(TF_TRAVELLOG, "CBB::GetBrowserIndex() NewFrame BID = %X", _dwBrowserIndex);
    }

    return _dwBrowserIndex;
}

HRESULT CBaseBrowser2::GetHistoryObject(IOleObject **ppole, IStream **ppstm, IBindCtx **ppbc) 
{
    ASSERT(ppole);
    ASSERT(ppstm);
    ASSERT(ppbc);

    *ppole = _poleHistory;
    *ppstm = _pstmHistory;
    *ppbc = _pbcHistory;

    //  we dont need to release, because we are just giving away our
    //  reference.
    _poleHistory = NULL;
    _pstmHistory = NULL;
    _pbcHistory = NULL;

    if(*ppole)
        return NOERROR;

    ASSERT(!*ppstm);
    return E_FAIL;
}

HRESULT CBaseBrowser2::SetHistoryObject(IOleObject *pole, BOOL fIsLocalAnchor)
{
    if (!_poleHistory && !_fGeneratedPage)
    {
        ASSERT(pole);

        // Note: _fIsLocalAnchor is ignored if (_dwDocFlags & DOCFLAG_DOCCANNAVIGATE)
        // is TRUE. In that case, the document (Trident) can navigate
        // itself and will take care of updating the travel log.
        //
        _fIsLocalAnchor = fIsLocalAnchor;

        if (pole)
        {
            _poleHistory = pole;
            _poleHistory->AddRef();
            return NOERROR;
        }
    }
    return E_FAIL;
}

HRESULT CBaseBrowser2::CacheOLEServer(IOleObject *pole)
{
    TraceMsg(DM_CACHEOLESERVER, "CBB::CacheOLEServer called");
    HRESULT hres;
    IPersist* pps;

    // ISVs want to turn off this caching because it's "incovenient"
    // to have the browser hold onto their object. We can do that
    // with a quick registry check here, but first let's make sure
    // we don't have a real bug to fix...

    hres = pole->QueryInterface(IID_PPV_ARG(IPersist, &pps));
    if (FAILED(hres)) 
    {
        return hres;
    }

    CLSID clsid = CLSID_NULL;
    hres = pps->GetClassID(&clsid);
    pps->Release();

    if (SUCCEEDED(hres)) 
    {
        SA_BSTRGUID str;
        InitFakeBSTR(&str, clsid);

        VARIANT v;
        hres = _bbd._pautoWB2->GetProperty(str.wsz, &v);
        if (SUCCEEDED(hres) && v.vt != VT_EMPTY) 
        {
            // We already have it. We are fine.
            TraceMsg(DM_CACHEOLESERVER, "CBB::CacheOLEServer not first time");
            VariantClear(&v);
        }
        else
        {
            // We don't have it yet. Add it. 
            v.vt = VT_UNKNOWN;
            v.punkVal = ClassHolder_Create(&clsid);
            if (v.punkVal)
            {
                hres = _bbd._pautoWB2->PutProperty(str.wsz, v);
                TraceMsg(DM_CACHEOLESERVER, "CBB::CacheOLEServer first time %x", hres);
                v.punkVal->Release();
            }
        }
    }
    return hres;
}

HRESULT CBaseBrowser2::GetSetCodePage(VARIANT* pvarIn, VARIANT* pvarOut)
{
    // Process the out parameter first so that the client can set and
    // get the previous value in a single call.

    if (pvarOut) 
    {
        pvarOut->vt = VT_I4;
        pvarOut->lVal = _cp;
    }

    if (pvarIn && pvarIn->vt==VT_I4) 
    {
        TraceMsg(DM_DOCCP, "CBB::GetSetCodePage changing _cp from %d to %d", _cp, pvarIn->lVal);
        _cp = pvarIn->lVal;
    }

    return S_OK;
}

HRESULT CBaseBrowser2::GetPidl(LPITEMIDLIST *ppidl)
{
    ASSERT(ppidl);

    *ppidl = ILClone(_bbd._pidlCur);

    return *ppidl ? S_OK : E_FAIL;
}

HRESULT CBaseBrowser2::SetReferrer(LPITEMIDLIST pidl)
{
    return E_NOTIMPL;
}

HRESULT CBaseBrowser2::GetBrowserByIndex(DWORD dwID, IUnknown **ppunk)
{
    HRESULT hr = E_FAIL;
    ASSERT(ppunk);
    *ppunk = NULL;

    //gotta get the target frame ...
    ITargetFramePriv * ptf;
    if(SUCCEEDED(_ptfrm->QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptf))))
    {
        ASSERT(ptf);
        hr = ptf->FindBrowserByIndex(dwID, ppunk);

        ptf->Release();
    }

    return hr;
}

HRESULT CBaseBrowser2::GetTravelLog(ITravelLog **pptl)
{
    *pptl = NULL;

    if (!_bbd._ptl)
    {
        IBrowserService *pbs;
        if (SUCCEEDED(_pspOuter->QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IBrowserService, &pbs)))) 
        {
            if (IsSameObject(SAFECAST(this, IBrowserService *), pbs))
            {
                // we are it, so we need to make us a TravelLog
                CreateTravelLog(&_bbd._ptl);
            }
            else
            {
                pbs->GetTravelLog(&_bbd._ptl);
            }
            pbs->Release();
        }
    }

    return _bbd._ptl ? _bbd._ptl->QueryInterface(IID_PPV_ARG(ITravelLog, pptl)) : E_FAIL;
}

HRESULT CBaseBrowser2::InitializeTravelLog(ITravelLog* ptl, DWORD dwBrowserIndex)
{
    ptl->QueryInterface(IID_PPV_ARG(ITravelLog, &_bbd._ptl));   // hold a copy
    _dwBrowserIndex = dwBrowserIndex;
    return S_OK;
}

// Let the top level browser know that it might need to update it's zones information
void CBaseBrowser2::_Exec_psbMixedZone()
{
    IShellBrowser *psbTop;
    if (SUCCEEDED(_pspOuter->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psbTop)))) 
    {
        IUnknown_Exec(psbTop, &CGID_Explorer, SBCMDID_MIXEDZONE, 0, NULL, NULL);
        psbTop->Release();
    }
}

STDMETHODIMP CBaseBrowser2::QueryUseLocalVersionVector(BOOL *pfUseLocal)
{
    *pfUseLocal = FALSE;
    return S_OK;
}

STDMETHODIMP CBaseBrowser2::QueryVersionVector(IVersionVector *pVersion)
{
    HRESULT    hr;
    ULONG      cchVer = 0;

    // Was IE's version set by a registry entry?
    // This simplified call checks for presence of the IE string
    //
    hr = pVersion->GetVersion(L"IE", NULL, &cchVer);
    ASSERT(hr == S_OK);

    if (cchVer == 0)
    {
        // Not already set.  Set it to default value.
        // Note that the four digits of precision is required due to a peculiarity in the parser.
        //
        hr = pVersion->SetVersion(L"IE", L"6.0000");
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FindWindowByIndex
//
//  Interface : ITravelLogClient
//
//  Synopsis  : Returns the window with the given index.
//
//--------------------------------------------------------------------------
HRESULT
CBaseBrowser2::FindWindowByIndex(DWORD dwID, IUnknown ** ppunk)
{
    return GetBrowserByIndex(dwID, ppunk);
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::GetWindowData
//
//  Interface : ITravelLogClient
//
//  Synopsis  : Returns a WINDOWDATA structure containing pertinent
//              window information needed for the travel log.. 
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::GetWindowData(LPWINDOWDATA pWinData)
{
    HRESULT hr = S_OK;

    ASSERT(pWinData);
    ASSERT(_bbd._pidlCur);

    DEBUG_CODE(TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];)
    DEBUG_CODE(IEGetDisplayName(_bbd._pidlCur, szPath, SHGDN_FORPARSING);)
    DEBUG_CODE(TraceMsg(DM_TRACE, "CBB::ActivatePendingView (TRAVELLOG): _UpdateTravelLog called from shdocvw for %ws", szPath);)

    ZeroMemory(pWinData, sizeof(WINDOWDATA));

    // Window ID and codepage
    //
    pWinData->dwWindowID = GetBrowserIndex();
    pWinData->uiCP       = _cp;

    // Current Pidl
    //
    pWinData->pidl = ILClone(_bbd._pidlCur);

    // Title - when we are in a shell view, 
    // _bbd._pszTitleCur is NULL, which is correct.
    // However, we still have to create memory for
    // pWinData->lpszTitle and you can't pass NULL
    // to SHStrDupW.
    //
    if (_bbd._pszTitleCur)
        hr = SHStrDupW(_bbd._pszTitleCur, &pWinData->lpszTitle);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::LoadHistoryPosition
//
//  Interface : ITravelLogClient
//
//  Synopsis  : Loads the Url location and position cookie. This is used 
//              during a history navigation in a frame that involves a
//              local anchor. 
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::LoadHistoryPosition(LPOLESTR pszUrlLocation, DWORD dwCookie)
{
    IEPlaySound(TEXT("Navigating"), FALSE);

    return SetPositionCookie(dwCookie);
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::GetDummyWindowData
//
//  Interface : ITravelLogClient2
//
//  Synopsis  : Fills in a windowdata and a stream very similar to 
//              that created by SaveHistory.
//              Be sure to keep this and SaveHistory in sync.
//
//--------------------------------------------------------------------------

STDMETHODIMP CBaseBrowser2::GetDummyWindowData(
        LPWSTR pszUrl, 
        LPWSTR pszTitle,
        LPWINDOWDATA pWinData)
{
    HRESULT hres = S_OK;
    PERSISTEDFRAME pf = {0};
    LPITEMIDLIST pidl;

      // grab current window ID
    pWinData->dwWindowID = GetBrowserIndex();

      // everything else is dummy
    pWinData->uiCP = 0;
    hres = SHStrDup(pszUrl, &pWinData->lpszUrl);
    hres = SHStrDup(pszTitle, &pWinData->lpszTitle);

    if (!pWinData->pStream)
    {
      hres = CreateStreamOnHGlobal(NULL, FALSE, &pWinData->pStream);
      if (hres)
          goto done;
    }

    pidl = PidlFromUrl(pszUrl);

    pf.cbSize = SIZEOF(pf);
    pf.bid = GetBrowserIndex();
    pf.cbPidl = ILGetSize(pidl);
    pf.type = PFTYPE_USEPIDL;
    pf.lock = 0; // _bbd._eSecureLockIcon;

    ASSERT(SUCCEEDED(IStream_Write(pWinData->pStream, (void *) c_szFrameMagic, CbFromCch(c_cchFrameMagic))));

    if (SUCCEEDED(hres = IStream_Write(pWinData->pStream,(void *)&pf, pf.cbSize)))
        hres = IStream_Write(pWinData->pStream,(void *)pidl, pf.cbPidl);

    ILFree(pidl); 

done:
    return SUCCEEDED(hres) ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::UpdateDesktopComponent
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::UpdateDesktopComponent(IHTMLWindow2 * pHTMLWindow)
{
    BSTR bstrTitle = NULL;
    BSTR bstrUrlUnencoded = NULL;
    HRESULT hr = S_OK;
    IHTMLDocument2 * pHTMLDocument2;
    IHTMLDocument4 * pHTMLDocument4;
    DWORD   dwOptions = 0;

    hr = pHTMLWindow->get_document(&pHTMLDocument2);
    if (SUCCEEDED(hr))
    {
        hr = pHTMLDocument2->QueryInterface(IID_PPV_ARG(IHTMLDocument4, &pHTMLDocument4));

        if (SUCCEEDED(hr))
        {
            pHTMLDocument2->get_title(&bstrTitle);
            pHTMLDocument4->get_URLUnencoded(&bstrUrlUnencoded);

            TraceMsg(DM_TRACE, "CBaseBrowser2::UpdateDesktopComponent: URLUnencoded - %ws; Title - %ws",
                     bstrUrlUnencoded, bstrTitle);

            // Update the desktop component's friendly name.
            //
            UpdateDesktopComponentName(bstrUrlUnencoded, bstrTitle);
            
            SysFreeString(bstrTitle);
            SysFreeString(bstrUrlUnencoded);

            pHTMLDocument4->Release();
        }

        pHTMLDocument2->Release();
    }

    return hr;
}

HRESULT
CBaseBrowser2::_InitDocHost(IWebBrowser2 * pWebBrowser)
{
    HRESULT     hr = E_FAIL;
    IDispatch*  pDocDispatch = NULL;

    ASSERT(pWebBrowser);

    // get the IHTMLWindow2 for the WebOC windowop
    hr = pWebBrowser->get_Document(&pDocDispatch);
    if (S_OK == hr && pDocDispatch)
    {
        IHTMLDocument2* pDoc;    
        
        hr = pDocDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc));
        pDocDispatch->Release();

        if (S_OK == hr)
        {
            IHTMLWindow2* pHtmlWindow;
            
            hr = pDoc->get_parentWindow(&pHtmlWindow);
            pDoc->Release();

            if (S_OK == hr)
            {
                BOOL fIsFrameWindow = IsFrameWindow(pHtmlWindow);
                pHtmlWindow->Release();

                if (!fIsFrameWindow && _bbd._pctView)
                {
                    hr = _bbd._pctView->Exec(&CGID_ShellDocView, 
                                             SHDVID_NAVSTART, 
                                             0, 
                                             NULL, 
                                             NULL);
                }
            }
        }
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireBeforeNavigate2
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireBeforeNavigate2(IDispatch * pDispatch,
                                   LPCTSTR     lpszUrl,
                                   DWORD       dwFlags,
                                   LPCTSTR     lpszFrameName,
                                   LPBYTE      pPostData,
                                   DWORD       cbPostData,
                                   LPCTSTR     lpszHeaders,
                                   BOOL        fPlayNavSound,
                                   BOOL      * pfCancel)
{
    HRESULT      hr = S_OK;
    BSTR         bstrUrl = NULL;
    LPITEMIDLIST pidl = NULL;
    IWebBrowser2 * pWebBrowser = NULL;

    ASSERT(pfCancel);

    *pfCancel = FALSE;
        
    // Stress fix
    //
    if (NULL == lpszUrl)
    {
        bstrUrl = SysAllocString(_T(""));
    }
    else
    {
        bstrUrl = SysAllocString(lpszUrl);
    }

    pidl = PidlFromUrl(bstrUrl);

    if (pidl)
    {

        hr = _GetWebBrowserForEvt(pDispatch, &pWebBrowser);

        if (S_OK == hr)
        {
            ASSERT(pWebBrowser);

            _pidlBeforeNavigateEvent = pidl; // no need to copy.

            // This is a work around for view linked weboc. Setting the frame name has side effects.
        
            LPCTSTR pEffectiveName;

            if (_fIsViewLinkedWebOC && (lpszFrameName == NULL || !lpszFrameName[0]))
            {
                pEffectiveName = _szViewLinkedWebOCFrameName;
            }
            else
            {
                pEffectiveName = lpszFrameName;
            }

            FireEvent_BeforeNavigate(pWebBrowser, _bbd._hwnd, pWebBrowser,
                                     pidl, NULL, dwFlags, pEffectiveName,
                                     pPostData, cbPostData, lpszHeaders, pfCancel);

            // Make sure that we remove earlier URLs that are cached during redirections.
            _InitDocHost(pWebBrowser);

            ATOMICRELEASE(pWebBrowser);

            ASSERT(_pidlBeforeNavigateEvent == pidl);
            _pidlBeforeNavigateEvent = NULL;

            ILFree(pidl);

            if (!*pfCancel && fPlayNavSound)
            {
                IEPlaySound(TEXT("Navigating"), FALSE);
            }
        }        
    }

    if (_phtmlWS && !pDispatch)
    {
        if (!_bbd._psvPending)
        {
            _phtmlWS->ViewReleased();
        }
        else
        {
            _phtmlWS->ViewReleaseIntelliForms();
        }
    }
    else if (_phtmlWS && !_bbd._psvPending)
    {
        _DismissFindDialog();
    }

    SysFreeString(bstrUrl);
    
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireNavigateError
//
//  Interface : ITridentService2
//
//  Called when there is a binding error
//
//  Input     : pHTMLWindow         - used to determine if we are a frame or 
//                                    the top-level.
//              bstrURL             - the URL which caused the error.                                   
//              bstrTargetFrameName - the frame being targeted.
//              dwStatusCode        - the binding error
//              pfCancel            - set by the host if it wants to 
//                                    cancel autosearch or friendly error
//                                    pages
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireNavigateError(IHTMLWindow2 * pHTMLWindow2, 
                                 BSTR           bstrURL,
                                 BSTR           bstrTargetFrameName,
                                 DWORD          dwStatusCode,
                                 BOOL         * pfCancel)
{
    ASSERT(dwStatusCode != 0);

    HRESULT hr = S_OK;
    IWebBrowser2 * pWebBrowser = NULL;

    *pfCancel = FALSE;

    //
    //  Use top-level if window is not specified or the window is the top-level 
    //
    if ((pHTMLWindow2 != NULL) && IsFrameWindow(pHTMLWindow2))
    {
        hr = _GetWebBrowserForEvt(pHTMLWindow2, &pWebBrowser);
    }
    else
    {
        hr = _GetWebBrowserForEvt(NULL, &pWebBrowser);
    }

    if (S_OK == hr)
    {
        ASSERT(pWebBrowser);

        TCHAR  szUrl[INTERNET_MAX_URL_LENGTH];

        LPITEMIDLIST pidl = NULL;

        if (bstrURL)
        {
            StrCpyN(szUrl, bstrURL, ARRAYSIZE(szUrl));
        }
        else
        {
            StrCpyN(szUrl, _T(""), ARRAYSIZE(szUrl));
        }

        pidl = PidlFromUrl(szUrl);

        if (pidl)
        {
            FireEvent_NavigateError(pWebBrowser, 
                                    pWebBrowser,
                                    pidl,
                                    bstrTargetFrameName,
                                    dwStatusCode,
                                    pfCancel);
            ILFree(pidl);
        }
    }

    ATOMICRELEASE(pWebBrowser);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FirePrintTemplateEvent
//
//  Interface : ITridentService
//
//  Called when a template is instantiate or torndown
//
//  pHTMLWindow is used to determine if we are a frame or the top-level
//  dispidPrintEvent either DISPID_PRINTTEMPLATEINSTANTIATION 
//                   or     DISPID_PRINTTEMPLATETEARDOWN 
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FirePrintTemplateEvent(IHTMLWindow2 * pHTMLWindow2, DISPID dispidPrintEvent)
{
    HRESULT hr = S_OK;

    IWebBrowser2 * pWebBrowser = NULL;

    //
    //  Use top-level if window is not specified or the window is the top-level 
    //
    if ((pHTMLWindow2 != NULL) && IsFrameWindow(pHTMLWindow2))
    {
        hr = _GetWebBrowserForEvt(pHTMLWindow2, &pWebBrowser);
    }
    else
    {
        hr = _GetWebBrowserForEvt(NULL, &pWebBrowser);
    }

    if (S_OK == hr)
    {
        ASSERT(pWebBrowser);

        FireEvent_PrintTemplateEvent(pWebBrowser, 
                                     pWebBrowser,
                                     dispidPrintEvent);
    }

    ATOMICRELEASE(pWebBrowser);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireUpdatePageStatus
//
//  Interface : ITridentService
//
//  Called when a template is instantiate or torndown
//
//  pHTMLWindow is used to determine if we are a frame or the top-level
//  nPage defined to be the number of pages spooled
//  fDone a flag to indicate that the last page has been sppoled
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireUpdatePageStatus(IHTMLWindow2 * pHTMLWindow2, DWORD nPage, BOOL fDone)
{
    HRESULT hr = S_OK;

    IWebBrowser2 * pWebBrowser = NULL;

    //
    //  Use top-level if window is not specified or the window is the top-level 
    //
    if  ((pHTMLWindow2 != NULL) && IsFrameWindow(pHTMLWindow2))
    {
        hr = _GetWebBrowserForEvt(pHTMLWindow2, &pWebBrowser);
    }
    else
    {
        hr = _GetWebBrowserForEvt(NULL, &pWebBrowser);
    }

    if (S_OK == hr)
    {
        ASSERT(pWebBrowser);

        FireEvent_UpdatePageStatus(pWebBrowser, 
                                   pWebBrowser,
                                   nPage,
                                   fDone);
    }

    ATOMICRELEASE(pWebBrowser);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FirePrivacyImpactedStateChange
//
//  Interface : ITridentService2
//
//  Called whenever the global privacy impacted state changes
//
//  Input     : The new privacy impacted state
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FirePrivacyImpactedStateChange(BOOL bPrivacyImpacted)
{
    HRESULT         hr          = S_OK;
    IWebBrowser2  * pWebBrowser = NULL;

    //
    // Update browser frame / save state
    //
    _UpdatePrivacyIcon(TRUE, bPrivacyImpacted);

    //
    // We always fire this at the top level 
    //
    hr = _GetWebBrowserForEvt(NULL, &pWebBrowser);

    if (S_OK == hr)
    {
        ASSERT(pWebBrowser);
        FireEvent_PrivacyImpactedStateChange(pWebBrowser, 
                                     bPrivacyImpacted);
    }

    ATOMICRELEASE(pWebBrowser);
    return hr;
}
    
HRESULT
CBaseBrowser2::_DismissFindDialog()
{
    BSTR bstrName = SysAllocString(STR_FIND_DIALOG_NAME);
    if (bstrName)
    {
        VARIANT varProp = {0};
        _bbd._pautoWB2->GetProperty(bstrName, &varProp);

        if ( (varProp.vt == VT_DISPATCH) && (varProp.pdispVal != NULL) )
        {
            IUnknown* pWindow = varProp.pdispVal;

            //now that we've pulled the pdispVal out of the propbag, clear the property on the automation object
            VARIANT varTmp = {0};
            _bbd._pautoWB2->PutProperty(bstrName, varTmp);

            //(davemi) see IE5 bug 57060 for why the below line doesn't work and IDispatch must be used instead
            //pWindow->close();
            IDispatch * pdisp;
            if (SUCCEEDED(pWindow->QueryInterface(IID_PPV_ARG(IDispatch, &pdisp))))
            {
                DISPID dispid;
                DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

                BSTR bstrClose = SysAllocString(L"close");
                if (bstrClose)
                {
                    HRESULT hr;

                    hr = pdisp->GetIDsOfNames(IID_NULL, &bstrClose, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
                    if (hr == S_OK)
                        pdisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD, &dispparamsNoArgs, &varTmp, NULL, NULL);

                    SysFreeString(bstrClose);
                }

                pdisp->Release();
            }
        }
        
        VariantClear(&varProp);
        SysFreeString(bstrName);
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::_GetWebBrowserForEvt
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::_GetWebBrowserForEvt(IDispatch     * pDispatch,
                                    IWebBrowser2 ** ppWebBrowser)
{
    if (_fIsViewLinkedWebOC && _pDispViewLinkedWebOCFrame && _fHadFirstBeforeNavigate)
    {
        *ppWebBrowser = _pDispViewLinkedWebOCFrame;
        _pDispViewLinkedWebOCFrame->AddRef();

        return S_OK;
    }
    else if (pDispatch)  // Top-level
    {
        return IUnknown_QueryService(pDispatch,
                                     SID_SWebBrowserApp,
                                     IID_PPV_ARG(IWebBrowser2, ppWebBrowser));
    }        
    else
    {
        *ppWebBrowser = _bbd._pautoWB2;

        if (*ppWebBrowser)
        {
            (*ppWebBrowser)->AddRef();
            return S_OK;
        }

        return E_FAIL;
    }
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::GetUrlSearchComponent
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::GetUrlSearchComponent(BSTR * pbstrSearch)
{
    TCHAR sz[MAX_URL_STRING];

    ASSERT(pbstrSearch);
    ASSERT(!*pbstrSearch);
    if (ILGetHiddenString(_bbd._pidlPending ? _bbd._pidlPending : _bbd._pidlCur,
                          IDLHID_URLQUERY,
                          sz,
                          SIZECHARS(sz)))
    {
        *pbstrSearch = SysAllocString(sz);
    }
    return (*pbstrSearch) ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::IsErrorUrl
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::IsErrorUrl(LPCTSTR lpszUrl, BOOL *pfIsError)
{
    HRESULT hr = S_OK;
    
    if (!lpszUrl || !pfIsError)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfIsError = ::IsErrorUrl(lpszUrl);
    
Cleanup:
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireNavigateComplete2
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireNavigateComplete2(IHTMLWindow2 * pHTMLWindow2,
                                     DWORD          dwFlags)
{
    if (!pHTMLWindow2)
        return E_POINTER;

    HRESULT hr = E_FAIL;
    BOOL    fIsErrorUrl = FALSE;

    BSTR bstrUrl = GetHTMLWindowUrl(pHTMLWindow2);
    if (bstrUrl)
    {
        // If the URL is a res: URL, _GetPidlForDisplay will return
        // the URL after the # in the res: URL.
        //
        LPITEMIDLIST pidl = _GetPidlForDisplay(bstrUrl, &fIsErrorUrl);

        if (pidl)
        {
            BOOL fViewActivated = FALSE;
            IWebBrowser2 * pWebBrowser = NULL;

            // If this is not a frame, we update the browser
            // state and pass the browser's IWebBrowser2 to 
            // FireEvent_NavigateComplete. If this is a frame,
            // we pass the IWebBrowser2 of the window.
            //
            if (!(dwFlags & NAVDATA_FRAMEWINDOW))
            {
                fViewActivated = _ActivateView(bstrUrl, pidl, dwFlags, fIsErrorUrl);

                if (_dwDocFlags & DOCFLAG_DOCCANNAVIGATE)
                {
                    ATOMICRELEASE(_pHTMLDocument);
                    pHTMLWindow2->get_document(&_pHTMLDocument);
                }

                if (IEHard_ShowOnNavigateComplete())
                {
                    EnableModelessSB(FALSE);
                    IEHard_NavWarning(_bbd._hwnd, IEHard_HostedInIE((IShellBrowser*)this));
                    EnableModelessSB(TRUE);
                }
            }
            else
            {
                if (IsWindowVisible(_bbd._hwnd) 
                    && !(_dwSBSPQueued & SBSP_WRITENOHISTORY)
                    && !(dwFlags & NAVDATA_FRAMECREATION)
                    && !(dwFlags & NAVDATA_RESTARTLOAD)) 
                {
                    IEPlaySound(TEXT("ActivatingDocument"), FALSE);
                }   

                if (_pbsOuter)
                {
                    _pbsOuter->UpdateBackForwardState();
                }
            }

            hr = _GetWebBrowserForEvt((dwFlags & NAVDATA_FRAMEWINDOW) ? pHTMLWindow2 : NULL,
                                      &pWebBrowser);

            if (S_OK == hr && !fViewActivated)
            {
                ASSERT(pWebBrowser);

                // fire the event!
                FireEvent_NavigateComplete(pWebBrowser, pWebBrowser, pidl, _bbd._hwnd);           
            }

            ATOMICRELEASE(pWebBrowser);

            ILFree(pidl);
        }

        SysFreeString(bstrUrl);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
// Method   : CBaseBrowser2::_ActivateView
//
// Synopsis : If there is a pending view, it will be activated. If there
//            if not a pending view, which is the case when we are 
//            navigating due to a hyperlink, OM navigation, or frame
//            navigation, we update the browser state. (The view is already
//            active in this case.)  In either case, we update the
//            state of the dochost.
//
//--------------------------------------------------------------------------

BOOL
CBaseBrowser2::_ActivateView(BSTR         bstrUrl,
                             LPITEMIDLIST pidl,
                             DWORD        dwFlags,
                             BOOL         fIsErrorUrl)
{
    BOOL fViewActivated = FALSE;

    // Activate the pending view if there is one.
    //
    if (_bbd._psvPending)
    {
        ILFree(_bbd._pidlPending);

        _bbd._pidlPending = ILClone(pidl);

        _fDontUpdateTravelLog = !!(dwFlags & NAVDATA_DONTUPDATETRAVELLOG);

        ASSERT(_pbsOuter);
        _pbsOuter->ActivatePendingView();

        _fDontUpdateTravelLog = FALSE;
        fViewActivated = TRUE;
    }
    else
    {
        UINT uProt = GetUrlSchemeW(bstrUrl);

        if (   uProt != URL_SCHEME_JAVASCRIPT 
            && uProt != URL_SCHEME_VBSCRIPT)
        {
            _UpdateBrowserState(pidl);
        }

        // In the case where there is a pending view
        // ActivatePendingView() will call ViewActivated().
        // Also, the call to ViewActivated() must happen
        // after the current pidl has changed. The current
        // pidl changes in _UpdateBrowserState().
        // 
        if (_phtmlWS)
        {
            _phtmlWS->ViewActivated();
        }

        // Don't play sound for the first navigation (to avoid multiple
        // sounds to be played for a frame-set creation).
        //

        ASSERT(_bbd._psv);

        if (IsWindowVisible(_bbd._hwnd) && !(_dwSBSPQueued & SBSP_WRITENOHISTORY)) 
        {
            IEPlaySound(TEXT("ActivatingDocument"), FALSE);
        }                    
    }

    // In the case of an error URL, we must send the original URL
    // to the dochost. It needs the res: URL in the case of an 
    // error page so it knows not to update the history.
    //
    if (!fIsErrorUrl)
    {
        _UpdateDocHostState(pidl, fIsErrorUrl);
    }
    else
    {
        LPITEMIDLIST pidlOriginal = PidlFromUrl(bstrUrl);

        if (pidlOriginal)
        {
            _UpdateDocHostState(pidlOriginal, fIsErrorUrl);
            ILFree(pidlOriginal);
        }
    }

    if (_pbsOuter)
    {
        _pbsOuter->_OnFocusChange(ITB_VIEW);
    }

    return fViewActivated;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::_UpdateBrowserState
//
//--------------------------------------------------------------------------

void
CBaseBrowser2::_UpdateBrowserState(LPCITEMIDLIST pidl)
{
    ASSERT(pidl);

    ILFree(_bbd._pidlCur);

    _bbd._pidlCur = ILClone(pidl);

    // With the _bbd._pidlCur now updated, we can now call UpdateWindowList to 
    // update the window list with the new pidl.
    //
    _pbsOuter->UpdateWindowList();
    _fGeneratedPage = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::_UpdateDocHostState
//
//--------------------------------------------------------------------------

void
CBaseBrowser2::_UpdateDocHostState(LPITEMIDLIST pidl, BOOL fIsErrorUrl) const
{
    DOCHOSTUPDATEDATA dhud;
    VARIANT varVal;

    ASSERT(  (_bbd._psvPending  &&  _bbd._pidlPending)
          || (!_bbd._psvPending && !_bbd._pidlPending));

    ASSERT(!_bbd._pidlPending || ILIsEqual(_bbd._pidlPending, pidl) || fIsErrorUrl);

    IShellView * psv = _bbd._psvPending ? _bbd._psvPending : _bbd._psv;
    ASSERT(psv);

    dhud._pidl = pidl;       
    dhud._fIsErrorUrl = fIsErrorUrl;

    varVal.vt = VT_PTR;
    varVal.byref = &dhud;

    IUnknown_Exec(psv, &CGID_ShellDocView, 
                  SHDVID_UPDATEDOCHOSTSTATE, 0, &varVal, NULL);
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireDocumentComplete
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireDocumentComplete(IHTMLWindow2 * pHTMLWindow2,
                                    DWORD          dwFlags)
{
    if (!pHTMLWindow2)
        return E_POINTER;

    HRESULT hr = E_FAIL;

    BSTR bstrUrl = GetHTMLWindowUrl(pHTMLWindow2);
    if (bstrUrl)
    {                      
        LPITEMIDLIST pidl = _GetPidlForDisplay(bstrUrl);

        if (pidl)
        {
            IWebBrowser2 * pWebBrowser;

            hr = _GetWebBrowserForEvt((dwFlags & NAVDATA_FRAMEWINDOW) ? pHTMLWindow2 : NULL,
                                      &pWebBrowser);
            ASSERT(pWebBrowser);

            if (S_OK == hr)
            {
                FireEvent_DocumentComplete(pWebBrowser, pWebBrowser, pidl);
                pWebBrowser->Release();
            }

            ILFree(pidl);
        }

        SysFreeString(bstrUrl);
    }

    if (!(dwFlags & NAVDATA_FRAMEWINDOW) && !IEHard_ShowOnNavigateComplete())
    {               
        if (_CanShowModalDialogNow())
        {
            // Even if we think we can, don't do it from inside DocumentComplete or any other Trident event.
            // Pumping messages during any of these events is bad for Trident, so we'll do it slightly later.
            
            PostMessage(_bbd._hwnd, WMC_IEHARD_NAVWARNING, 0, 0);                
        }
    }

    return hr;
}


// Determines if we are in a reasonable state to show a random dialog box out of nowhere.
// The browser can get into states where the window is basically useless and no view
// is hosted.  One such case is when a new window navigates to unhostable content 
// (like an exe file).  If we put up a dialog at a bad time, we'll disrupt some sensitive
// Trident timing and the content won't be sent to the download dialog.

BOOL CBaseBrowser2::_CanShowModalDialogNow()
{
    return (_bbd._hwnd && IsWindow(_bbd._hwnd) && IsWindowVisible(_bbd._hwnd) &&
            _bbd._hwndView && IsWindow(_bbd._hwndView) && IsWindowVisible(_bbd._hwndView));
}

 
void CBaseBrowser2::_ShowIEHardNavWarning()
{
    if (_CanShowModalDialogNow())
    {
        // If GetLastActivePopup returns something other than the supplied window, it means
        // there is a modal or modeless dialog that is active, and we don't bother showing any message.       
        
        HWND hwndPopup = GetLastActivePopup(_bbd._hwnd);

        if (hwndPopup == _bbd._hwnd)
        {
            // Most of the time, this means that there are no dialogs attached to us.
            // But there could still be a modeless dialog showing; it just isn't active right now.  
            // We'll show our messagebox anyway, because the same thing would happen if you opened 
            // the About dialog yourself -- it would be parented to the top window, and the modeless
            // dialog would still be dangling around and enabled.
        
            EnableModelessSB(FALSE);
            IEHard_NavWarning(_bbd._hwnd, IEHard_HostedInIE((IShellBrowser*)this));
            EnableModelessSB(TRUE);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireDownloadBegin
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireDownloadBegin()
{
    return _updateNavigationUI();
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::FireDownloadComplete
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::FireDownloadComplete()
{
    return _updateNavigationUI();
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::GetPendingUrl
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::GetPendingUrl(BSTR * pbstrPendingUrl)
{
    if (!pbstrPendingUrl)
        return E_POINTER;

    *pbstrPendingUrl = NULL;

    LPITEMIDLIST pidl = _bbd._pidlPending ? _bbd._pidlPending : _bbd._pidlCur;

    TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];

    HRESULT hr = IEGetDisplayName(pidl, szPath, SHGDN_FORPARSING);
    if (S_OK == hr)
    {
        TraceMsg(DM_TRACE, "CBaseBrowser2::GetPendingUrl - URL: %ws", szPath);

        *pbstrPendingUrl = SysAllocString(szPath);
    }

    return (*pbstrPendingUrl) ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::ActiveElementChanged
//
//  Interface : ITridentService
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::ActiveElementChanged(IHTMLElement * pHTMLElement)
{
    // Forward the call to the OmWindow
    //
    if (_phtmlWS)
    {
        return _phtmlWS->ActiveElementChanged(pHTMLElement);
    }

    return E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::InitAutoImageResize()
//
//  Interface : ITridentService2
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::InitAutoImageResize()
{
    HRESULT hr = S_OK;
   
    if (_pAIResize)
        UnInitAutoImageResize();

    CAutoImageResize *pAIResize = new CAutoImageResize();
    if (pAIResize)
    {
        // need to get a pDoc2 for the init call...
        IDispatch *pDocDispatch;
        hr = _bbd._pautoWB2->get_Document(&pDocDispatch);
        if (SUCCEEDED(hr))
        {
            IHTMLDocument2 *pDoc2;
            hr = pDocDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument2,&pDoc2));
            if (SUCCEEDED(hr))
            {
                // init the object
                pAIResize->Init(pDoc2); 

                // cache the pointer for destruction later
                _pAIResize=pAIResize;

                pDoc2->Release();
            }
            pDocDispatch->Release();
        }

        if (FAILED(hr))
        {
            delete pAIResize;
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::UnInitAutoImageResize()
//
//  Interface : ITridentService2
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::UnInitAutoImageResize()
{
    if (_pAIResize)
    {
        _pAIResize->UnInit();
        ATOMICRELEASE(_pAIResize);
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::IsGalleryMeta
//
//  Interface : ITridentService2
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::IsGalleryMeta(BOOL bFlag, void *pMyPics)
{
    // Forward the call to the CMyPics object
    //

    if (pMyPics)
    {
        ((CMyPics*)pMyPics)->IsGalleryMeta(bFlag);
        return S_OK;
    }

    return E_FAIL;
}

//+-------------------------------------------------------------------------
//
// Functions that live in mypics.cpp that are called below
//
//--------------------------------------------------------------------------

HRESULT SendDocToMailRecipient(LPCITEMIDLIST pidl, UINT uiCodePage, DWORD grfKeyState, IUnknown *pUnkSite);
BOOL    MP_IsEnabledInIEAK();
BOOL    MP_IsEnabledInRegistry();


//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::EmailPicture
//
//  Interface : ITridentService2
//
//--------------------------------------------------------------------------

HRESULT
CBaseBrowser2::EmailPicture(BSTR bstrURL)
{
    IDispatch *pDocDispatch;
    HRESULT hr = _bbd._pautoWB2->get_Document(&pDocDispatch);
    if (SUCCEEDED(hr))
    {
        IHTMLDocument2 *pDoc2;
        hr = pDocDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc2));
        if (SUCCEEDED(hr))
        {
            // Get that cmd target thingie...
            IOleCommandTarget *pcmdt;
            hr = IUnknown_QueryService(pDoc2, SID_SWebBrowserApp, IID_PPV_ARG(IOleCommandTarget, &pcmdt));
            if (SUCCEEDED(hr))
            {
                // ... and thus the pidl...
                LPITEMIDLIST pidlForImg;
                hr = IEParseDisplayName(CP_ACP, bstrURL, &pidlForImg);
                if (SUCCEEDED(hr))
                {                    
                    // ... and pray this works...
                    SendDocToMailRecipient(pidlForImg, 0, FORCE_COPY, pcmdt);
                    
                    ILFree(pidlForImg);
                }
                pcmdt->Release();
            }
            pDoc2->Release();
        }
        pDocDispatch->Release();
    }
    
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::AttachMyPics
//
//  Interface : ITridentService2
//
//--------------------------------------------------------------------------


HRESULT
CBaseBrowser2::AttachMyPics(void *pDoc2, void **ppMyPics)
{
    IHTMLDocument2 *pdoc2     = (IHTMLDocument2 *)pDoc2;
    DWORD           dwOptions = 0;

    ASSERT(ppMyPics && *ppMyPics==NULL);

    if (!MP_IsEnabledInIEAK()     || 
        !MP_IsEnabledInRegistry() ||
        !IsInternetExplorerApp()) 
    {
        return S_OK;
    }

    if (!pdoc2 || !ppMyPics || (*ppMyPics != NULL)) 
    {
        return S_OK;
    }

    //Is this a desktop component?                    
    if (SUCCEEDED(GetTopFrameOptions(_pspOuter, &dwOptions)))
    {    
        if (dwOptions & FRAMEOPTIONS_DESKTOP) 
        {
            return S_OK;
        }
    }

    CMyPics *pPics = new CMyPics();

    if (pPics)
    {
        if (SUCCEEDED(pPics->Init(pdoc2))) 
        {
            *ppMyPics = pPics;
        } 
        else 
        {
            pPics->Release();
        }
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::ReleaseMyPics
//
//  Interface : ITridentService2
//
//--------------------------------------------------------------------------

BOOL
CBaseBrowser2::ReleaseMyPics(void *pMyPics)
{
    CMyPics *pPics = (CMyPics *) pMyPics;

    BOOL bRet = pPics->IsOff();

    if (pPics) 
    {
        pPics->UnInit();
        pPics->Release();
    }

    return (bRet);
}

STDMETHODIMP CBaseBrowser2::SetFrameName(BSTR bstrFrameName)
{
    return StringCchCopy(_szViewLinkedWebOCFrameName, ARRAYSIZE(_szViewLinkedWebOCFrameName), bstrFrameName);
}

//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::AppStarting
//
//  Interface : INotifyAppStart
//
//--------------------------------------------------------------------------
HRESULT
CBaseBrowser2::AppStarting(void)
{
    _dwStartingAppTick = GetTickCount();
    SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
    SetTimer( _bbd._hwnd, IDT_STARTING_APP_TIMER, STARTING_APP_DURATION, NULL);

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method    : CBaseBrowser2::AppStarted
//
//  Interface : INotifyAppStart
//
//--------------------------------------------------------------------------
HRESULT
CBaseBrowser2::AppStarted(void)
{
    _dwStartingAppTick = 0;
    KillTimer( _bbd._hwnd, IDT_STARTING_APP_TIMER );
    SetCursor(LoadCursor(NULL, IDC_ARROW));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\browsext.cpp ===
#include "priv.h"
#include "browsext.h"
#include "tbext.h"
#include <winreg.h>     // For the registry walking
#include "dochost.h"
#include "resource.h"
#include <mluisupp.h>
#include <tb_ids.h>


// {DFEED31E-78ED-11d2-86BA-00C04F8EEA99}
EXTERN_C const IID IID_IToolbarExt = 
{ 0xdfeed31e, 0x78ed, 0x11d2, { 0x86, 0xba, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99 } };

// {D82B85D0-78F4-11d2-86BA-00C04F8EEA99}
EXTERN_C const CLSID CLSID_PrivBrowsExtCommands =
{ 0xd82b85d0, 0x78f4, 0x11d2, { 0x86, 0xba, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99 } };

const TCHAR c_szHelpMenu[]  = TEXT("help");

//+-------------------------------------------------------------------------
// Creates and instance of CBrowserExtension
//--------------------------------------------------------------------------
HRESULT CBrowserExtension_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;
    CBrowserExtension* p = new CBrowserExtension();
    if (p)
    {
        *ppunk = SAFECAST(p, IToolbarExt*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

CBrowserExtension::CBrowserExtension()
:   _cRef(1),
    _uStringIndex((UINT)-1),
    _uiImageIndex((UINT)-1)
{
    ASSERT(_pISB == NULL);
    ASSERT(_hdpa == NULL);
    ASSERT(_nExtButtons == 0);
    ASSERT(_fStringInit == FALSE);
    ASSERT(_fImageInit == FALSE);
}

CBrowserExtension::~CBrowserExtension(void)
{
    if (_pISB)
        _pISB->Release();

    if (_hdpa)
    {
        _FreeItems();
        DPA_Destroy(_hdpa);
        _hdpa = NULL;
    }

    _ReleaseImageLists(_uiImageIndex);
}

// *** IUnknown methods ***

HRESULT CBrowserExtension::QueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CBrowserExtension, IToolbarExt),
        QITABENT(CBrowserExtension, IObjectWithSite),
        QITABENT(CBrowserExtension, IOleCommandTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CBrowserExtension::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CBrowserExtension::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IToolbarExt interface functions
HRESULT CBrowserExtension::SetSite(IUnknown* pUnkSite)
{
    HRESULT hr = S_OK;

    ATOMICRELEASE(_pISB);

    if (pUnkSite)
    {
        hr = pUnkSite->QueryInterface(IID_IShellBrowser, (LPVOID*)&_pISB);
    }

    // See if we need to init ourselves
    if (NULL == _hdpa)
    {
        // Real construction happens here
        HRESULT hr2 = Update();

        ASSERT(SUCCEEDED(hr2));
    }
    else
    {
        // Update the site for each button/menu extension
        for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);
            IUnknown_SetSite(pItem->pIBE, _pISB);
        }
    }
    return hr;
}

STDMETHODIMP CBrowserExtension::GetSite(REFIID riid, void ** ppvSite)
{
    HRESULT hr = S_OK;
    *ppvSite = NULL;

    if (_pISB)
    {
        hr = _pISB->QueryInterface(riid, ppvSite);
    }
    return hr;
}

HRESULT CBrowserExtension::GetNumButtons(UINT* pButtons)
{
    ASSERT(pButtons);
    *pButtons = _nExtButtons;
    return S_OK;
}

HRESULT CBrowserExtension::InitButtons(IExplorerToolbar* pxtb, UINT* puStringIndex, const GUID* pguidCommandGroup)
{
    ASSERT(pxtb);

    UINT uiSize;
    pxtb->GetBitmapSize(&uiSize);
    int cx = LOWORD(uiSize);

    // Get the image lists for the current button size and screen resolution
    CImageList* pimlDef;
    CImageList* pimlHot;
    UINT uiImageIndexOld = _uiImageIndex;
    _uiImageIndex = _GetImageLists(&pimlDef, &pimlHot, cx < 20);
    pxtb->SetImageList(pguidCommandGroup, *pimlDef, *pimlHot, NULL);

    // Free the previously used image list
    _ReleaseImageLists(uiImageIndexOld);

    // Add the button text to the toolbar
    if (_uStringIndex == (UINT)-1)
    {
        LRESULT iAddResult = 0; // result of adding the string buffer to the toolbar string list
        HRESULT hr = pxtb->AddString(pguidCommandGroup, MLGetHinst(), IDS_BROWSER_TB_LABELS, &iAddResult);
        _uStringIndex = (UINT)iAddResult;
        _AddCustomStringsToBuffer(pxtb, pguidCommandGroup);
    }

    *puStringIndex = _uStringIndex;
    return S_OK;
}

CBrowserExtension::ExtensionItem* CBrowserExtension::_FindItem(REFGUID rguid)
{
    ExtensionItem* pFound = NULL;
    if (NULL != _hdpa)
    {
        for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);

            if (pItem && IsEqualGUID(pItem->guid, rguid))
            {
                pFound = pItem;
                break;
            }
        }
    }
    return pFound;
}

void CBrowserExtension::_AddItem(HKEY hkeyExtensions, LPCWSTR pszGuidItem, REFGUID rguidItem)
{
    // Create the dpa used to store our items
    if (NULL == _hdpa)
    {
        _hdpa = DPA_Create(5);
        if (NULL == _hdpa)
        {
            return;
        }
    }

    HKEY hkeyThisExtension;

    if (RegOpenKeyEx(hkeyExtensions, pszGuidItem, 0, KEY_READ, &hkeyThisExtension) == ERROR_SUCCESS)
    {
        // Get the clsid of the object
        WCHAR szCLSID[64];
        ULONG cbCLSID = SIZEOF(szCLSID);
        CLSID clsidCustomButton;

        if (SUCCEEDED(RegQueryValueEx(hkeyThisExtension, TEXT("clsid"), NULL, NULL, (unsigned char *)&szCLSID, &cbCLSID)) &&
            SUCCEEDED(CLSIDFromString(szCLSID, &clsidCustomButton)))
        {
            IBrowserExtension * pibeTemp;

            // Check for our internal object.  Note that our CoCreateInctance wrapper
            // compares to the address of the global clsid, so we want to use the global
            // guid.
            const CLSID* pclsid = &clsidCustomButton;
            if (IsEqualGUID(clsidCustomButton, CLSID_ToolbarExtExec))
            {
                pclsid = &CLSID_ToolbarExtExec;
            }
            else if (IsEqualGUID(clsidCustomButton, CLSID_ToolbarExtBand))
            {
                pclsid = &CLSID_ToolbarExtBand;
            }

            // Create the extension object
            if (SUCCEEDED(CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_SERVER,
                                 IID_IBrowserExtension, (void **)&pibeTemp)))
            {
                if (SUCCEEDED(pibeTemp->Init(rguidItem)))
                {
                    // Add this item to our array
                    ExtensionItem* pItem = new ExtensionItem;
                    if (pItem)
                    {
                        if (DPA_AppendPtr(_hdpa, pItem) != -1)
                        {
                            VARIANTARG varArg;

                            pItem->idCmd = _GetCmdIdFromClsid(pszGuidItem);
                            pItem->pIBE = pibeTemp;
                            pItem->guid = rguidItem;
                            pibeTemp->AddRef();

                            // See if it's a button
                            if (SUCCEEDED(pibeTemp->GetProperty(TBEX_BUTTONTEXT, NULL)))
                            {
                                _nExtButtons++;
                                pItem->fButton = TRUE;

                                // See if the button default to visible on the toolbar
                                if (SUCCEEDED(pibeTemp->GetProperty(TBEX_DEFAULTVISIBLE, &varArg)))
                                {
                                    ASSERT(varArg.vt == VT_BOOL);
                                    pItem->fVisible = (varArg.boolVal == VARIANT_TRUE);
                                }
                            }

                            // set the target menu
                            
                            pItem->idmMenu = 0;
                            
                            if (SUCCEEDED(pibeTemp->GetProperty(TMEX_MENUTEXT, NULL)))
                            {
                                
                                if (SUCCEEDED(pibeTemp->GetProperty(TMEX_CUSTOM_MENU, &varArg)))
                                {
                                    ASSERT(varArg.vt == VT_BSTR);
                                    ASSERT(IS_VALID_STRING_PTR(varArg.bstrVal, -1));
    
                                    if (!StrCmpNI(varArg.bstrVal, c_szHelpMenu, ARRAYSIZE(c_szHelpMenu)))
                                    {
                                        pItem->idmMenu = FCIDM_MENU_HELP;
                                    }
    
                                    VariantClear(&varArg);
                                }

                                if (pItem->idmMenu == 0)
                                {
                                    pItem->idmMenu = FCIDM_MENU_TOOLS;
                                }
                            }

                            // Pass the site to the object
                            IUnknown_SetSite(pibeTemp, _pISB);
                        }
                        else
                        {
                            delete pItem;
                        }
                    }
                }

                // This will free pibeTemp if we didn't store it away
                pibeTemp->Release();
            }
        }
        RegCloseKey(hkeyThisExtension);
    }
}


//
// All real construction happens here.  In theory this function can be called upon a SysINIChange to update our
// custom toolbar cached information.  This has not been tested.  This opens the Extensions section of the registry
// enumerates all of the subkeys.  Attempts to CoCreate each one.  Upon successful CoCreation it calls
// IObjectWithSite::SetSite(IShellBrowser), if it is implemented.  Next IBrowserExtension::Init is called.  Finally,
// IBrowserExtension::GetProperty(TBEX_BUTTONTEXT, NULL) is called looking for a S_OK to insure that the control in
// question is a Toolbar Button (as opposed to a tools menu item, or...)
//
HRESULT CBrowserExtension::Update()
{
    WCHAR szItemGuid[64];    // sufficient for {clsid}
    DWORD cbItemGuid;
    GUID guidItem;
    HRESULT hr = S_OK;

    // Free previous items
    _nExtButtons = 0;
    _nExtToolsMenuItems = 0;
    _FreeItems();

    // First add extensions from HKCU
    HKEY hkeyExtensions;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Extensions"), 0,
                     KEY_READ, &hkeyExtensions) == ERROR_SUCCESS)
    {
        cbItemGuid = sizeof(szItemGuid);
        for (int iKey = 0;
             RegEnumKeyEx(hkeyExtensions, iKey, szItemGuid, &cbItemGuid, NULL, NULL, NULL, NULL) != ERROR_NO_MORE_ITEMS;
             iKey++)
        {
            if (SUCCEEDED(CLSIDFromString(szItemGuid, &guidItem)))
            {
                _AddItem(hkeyExtensions, szItemGuid, guidItem);
            }
            cbItemGuid = sizeof(szItemGuid);
        }

        RegCloseKey(hkeyExtensions);
    }

    // Next add any unique items from HKLM
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Internet Explorer\\Extensions"), 0,
                     KEY_READ, &hkeyExtensions) == ERROR_SUCCESS)
    {
        cbItemGuid = sizeof(szItemGuid);
        for (int iKey = 0;
             RegEnumKeyEx(hkeyExtensions, iKey, szItemGuid, &cbItemGuid, NULL, NULL, NULL, NULL) != ERROR_NO_MORE_ITEMS;
             iKey++)
        {
            if (SUCCEEDED(CLSIDFromString(szItemGuid, &guidItem)))
            {
                if (_FindItem(guidItem) == NULL)
                {
                    _AddItem(hkeyExtensions, szItemGuid, guidItem);
                }
            }
            cbItemGuid = sizeof(szItemGuid);
        }

        RegCloseKey(hkeyExtensions);
    }

    return hr;
}

//
// This takes a TBBUTTON[] and fills in the Custom Buttons.  A couple of usage points:
// (1) The caller should allocate a TBBUTTON[] big enough for NUM_STD_BUTTONS + GetNumExtButtons()
//     Then they should copy the standard buttons into the array, and pass the pointer to the remainder
//     of the array here.
// (2) This function should *by design* never be called before AddCustomImagesToImageList and
//     AddCustomStringsToBuffer have both been called.  An attempt to do so in DEBUG mode will hit
//     a break point.
//
HRESULT CBrowserExtension::GetButtons(TBBUTTON * tbArr, int nNumButtons, BOOL fInit)
{
    ASSERT(_fStringInit && _fImageInit);

    if (_hdpa)
    {
        ASSERT(nNumButtons == _nExtButtons);
        ASSERT(tbArr != NULL)
        int iBtn = 0;

        for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);
            if (!pItem->fButton)
                continue;

            // We use the MAKELONG(n, 1) to insure that we are using the alternate image list.
            tbArr[iBtn].iBitmap    = MAKELONG(pItem->iImageID, 1);
            tbArr[iBtn].idCommand  = pItem->idCmd;
            tbArr[iBtn].fsState    = TBSTATE_ENABLED;
            tbArr[iBtn].fsStyle    = BTNS_BUTTON;
            tbArr[iBtn].dwData     = 0;
            tbArr[iBtn].iString    = pItem->iStringID;

            //
            // Default to hidden during initialization so that it defaults to the left well
            // of the the customize dialog (defaults off the toolbar)
            //
            if (fInit && !pItem->fVisible)
            {
                tbArr[iBtn].fsState = TBSTATE_HIDDEN;
            }

            ++iBtn;
        }
    }
    return S_OK;
}

//
// This function takes the ImageLists for hot and normal icons and adds the appropriate icon to each
// list for each custom toolbar button.  The resultant ImageID is then stored in our _rgExtensionItem struct
// so that the IDs can be placed in a TBBUTTON[] when AddExtButtonsTBArray is called.
//
HRESULT CBrowserExtension::_AddCustomImagesToImageList(CImageList& rimlNormal, CImageList& rimlHot, BOOL fSmallIcons)
{
#ifdef DEBUG
    _fImageInit = TRUE;
#endif DEBUG

    if (rimlNormal.HasImages() && rimlHot.HasImages() && NULL != _hdpa)
    {
        for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);
            if (!pItem->fButton)
                continue;

            VARIANTARG varArg;

            pItem->iImageID = rimlNormal.GetImageIndex(pItem->guid);
            if (-1 == pItem->iImageID &&
                SUCCEEDED(pItem->pIBE->GetProperty((fSmallIcons ? TBEX_GRAYICONSM : TBEX_GRAYICON), &varArg)))
            {
                if (varArg.vt == VT_BYREF)
                {
                    pItem->iImageID = rimlNormal.AddIcon((HICON)varArg.byref, pItem->guid);
                }
                else if (varArg.vt == VT_I4)
                {
                    // It's one of our built-in images
                    pItem->iImageID = varArg.lVal;
                }
                else
                {
                    TraceMsg(TF_ALWAYS, "Button doesn't have an image associated");
                }
            }

            int iHot = rimlHot.GetImageIndex(pItem->guid);
            if (-1 == iHot &&
                SUCCEEDED(pItem->pIBE->GetProperty((fSmallIcons ? TBEX_HOTICONSM : TBEX_HOTICON), &varArg)))
            {
                if (varArg.vt == VT_BYREF)
                {
                    iHot = rimlHot.AddIcon((HICON)varArg.byref, pItem->guid);
                }
                else if (varArg.vt == VT_I4)
                {
                    // It's one of our built-in images
                    iHot = varArg.lVal;
                }
                else
                {
                    TraceMsg(TF_ALWAYS, "Button doesn't have an image associated");
                }
            }

            if (iHot!=pItem->iImageID)
            {
                TraceMsg(TF_ALWAYS, "ButtonExtension: iHot doesn't match iImageID");
            }
        }
    }

    return S_OK;
}

//
// This function takes the StringList and adds the caption (ToolbarText) for each of the custom toolbar buttons
// to it.  The resultant StringID is then stored in our _rgExtensionItem struct so that the ID can be placed in
// a TBBUTTON[] when AddExtButtonsTBArray is called.
//
HRESULT CBrowserExtension::_AddCustomStringsToBuffer(IExplorerToolbar * pxtb, const GUID* pguidCommandGroup)
{
#ifdef DEBUG
    _fStringInit = TRUE;
#endif DEBUG

    if (NULL != _hdpa)
    {
        for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);
            if (!pItem->fButton)
                continue;

            VARIANTARG varArg;

            if (SUCCEEDED(pItem->pIBE->GetProperty(TBEX_BUTTONTEXT, &varArg)))
            {
                // We need to double-null terminate the string!
                WCHAR szBuf[70];    // should be ample for button text!
                ZeroMemory(szBuf, sizeof(szBuf));
                StringCchCopy(szBuf, ARRAYSIZE(szBuf) - 2, varArg.bstrVal);
                LRESULT iResult;

                if (SUCCEEDED(pxtb->AddString(pguidCommandGroup, 0, (LPARAM)szBuf, &iResult)))
                {
                    pItem->iStringID = (SHORT)iResult;
                }

                VariantClear(&varArg);
            }
        }
    }

    return S_OK;
}

int CBrowserExtension::_GetCmdIdFromClsid(LPCWSTR pszGuid)
{
    DWORD dwDisposition;
    HRESULT hr = S_OK;
    int nReturn = DVIDM_MENUEXT_FIRST; 

    HKEY hkeyExtensionMapping;
    if (RegCreateKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Extensions\\CmdMapping"), 0, NULL, 0,
                       KEY_READ | KEY_WRITE, NULL, &hkeyExtensionMapping, &dwDisposition) == ERROR_SUCCESS)
    {
        DWORD dwType = REG_DWORD, dwData, cbData = sizeof(dwData);
        
        if ( (SHQueryValueEx(hkeyExtensionMapping, pszGuid, NULL, &dwType, &dwData, &cbData) == ERROR_SUCCESS) &&
             (dwType == REG_DWORD) )
        {
            //the item has a mapping
            nReturn = dwData;
        }
        else
        {
            //it's a new item, get and store the next available id in the default value of the Mapping key
            if ( (SHQueryValueEx(hkeyExtensionMapping, L"NextId", NULL, &dwType, &dwData, &cbData) != ERROR_SUCCESS) ||
                 (dwType != REG_DWORD) )
            {
                dwData = DVIDM_MENUEXT_FIRST;
            }
            nReturn = dwData;

            dwType = REG_DWORD;
            cbData = sizeof(dwData);
            EVAL(SHSetValueW(hkeyExtensionMapping, NULL, pszGuid, dwType, &dwData, cbData) == ERROR_SUCCESS);

            dwData++;
            ASSERT(dwData < DVIDM_MENUEXT_LAST); //ugh, we've used up our whole range. we need to look for holes.
            EVAL(SHSetValueW(hkeyExtensionMapping, NULL, L"NextId", dwType, &dwData, cbData) == ERROR_SUCCESS);
        }
        RegCloseKey(hkeyExtensionMapping);
    }

    return nReturn;
}

int CBrowserExtension::_GetIdpaFromCmdId(int nCmdId)
{
    if (NULL != _hdpa)
    {
        for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);
            if (pItem->idCmd == nCmdId)
                return i;
        }
    }
    return -1;
}

// *** IOleCommandTarget methods ***

HRESULT CBrowserExtension::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (!pguidCmdGroup)
        return E_INVALIDARG;

    if (IsEqualGUID(*pguidCmdGroup, CLSID_ToolbarExtButtons))
    {
        int iCmd = _GetIdpaFromCmdId(nCmdID);

        if (iCmd >= 0 && iCmd < DPA_GetPtrCount(_hdpa))
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, iCmd);
            if (pItem)
                return IUnknown_Exec(pItem->pIBE, NULL, 0, 0, NULL, NULL);
        }
    }
    else if (IsEqualGUID(*pguidCmdGroup, CLSID_PrivBrowsExtCommands))
    {
        switch (nCmdID)
        {
        case PBEC_GETSTRINGINDEX:
            if (pvarargIn && pvarargIn->vt == VT_I4)
            {
                pvarargIn->lVal = _uStringIndex;
                return S_OK;
            }
            break;
        }
    }

    return E_FAIL;
}

HRESULT CBrowserExtension::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    if (!pguidCmdGroup)
        return E_INVALIDARG;

    if (IsEqualGUID(*pguidCmdGroup, CLSID_ToolbarExtButtons))
    {
        for (ULONG i = 0; i < cCmds; i++)
        {
            int iCmd = _GetIdpaFromCmdId(rgCmds[i].cmdID);

            if (iCmd >= 0 && iCmd < DPA_GetPtrCount(_hdpa))
            {
                ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, iCmd);
                if (pItem)
                {
                    // I don't think this has ever worked.  The command id
                    // isn't the same as the one we use in Exec.
                    IUnknown_QueryStatus(pItem->pIBE, pguidCmdGroup, 1, &rgCmds[i], pcmdtext);
                }
            }
        }

        return S_OK;
    }

    return E_FAIL;
}

//
// This function is a helper for the destructor.  It is also called by Update() so that if we are ever asked
// to Update() we first kill all of our cached information and then we go to the registry...
//

void CBrowserExtension::_FreeItems(void)
{
    if (_hdpa)
    {
        for (int i = DPA_GetPtrCount(_hdpa) - 1; i >= 0; --i)
        {
            ExtensionItem* pItem = (ExtensionItem*)DPA_DeletePtr(_hdpa, i);

            IUnknown_SetSite(pItem->pIBE, NULL);
            pItem->pIBE->Release();
            delete pItem;
        }
    }
}

// this help function is used to isolate the menu-specific
// processing. after using this helper to fill out the BROWSEXT_MENU_INFO
// struct, the OnCustomizableMenuPopup is able to do menu-inspecific
// processing.

HRESULT
CBrowserExtension::_GetCustomMenuInfo(HMENU hMenuParent, HMENU hMenu, BROWSEXT_MENU_INFO * pMI)
{
    HRESULT hr;

    RIP(IS_VALID_HANDLE(hMenuParent, MENU));
    RIP(IS_VALID_HANDLE(hMenu, MENU));
    RIP(IS_VALID_WRITE_PTR(pMI, BROWSEXT_MENU_INFO *));

    hr = E_FAIL;
    pMI->idmMenu = 0;

    // set idmMenu, idmPlaceholder, and idmModMarker to values
    // reflecting whichever menu's popup we're currently handling

    if (GetMenuFromID(hMenuParent, FCIDM_MENU_HELP) == hMenu)
    {
        pMI->idmMenu = FCIDM_MENU_HELP;
        pMI->idmPlaceholder = FCIDM_HELP_EXT_PLACEHOLDER;
        pMI->idmModMarker = FCIDM_HELP_EXT_MOD_MARKER;
    }
    else if (GetMenuFromID(hMenuParent, FCIDM_MENU_TOOLS) == hMenu)
    {
        pMI->idmMenu = FCIDM_MENU_TOOLS;
        pMI->idmPlaceholder = FCIDM_TOOLS_EXT_PLACEHOLDER;
        pMI->idmModMarker = FCIDM_TOOLS_EXT_MOD_MARKER;
    }

    // set iInsert. using a constant insertion index
    // instead of always inserting by command at
    // the placeholder makes it easier later when
    // we have to stick in the final separator to
    // isolate the custom item group.

    if (pMI->idmMenu != 0)
    {
        int i;
        int cItems;

        cItems = GetMenuItemCount(hMenu);

        for (i = 0; i < cItems; i++)
        {
            MENUITEMINFO    mii;
            BOOL            f;

            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_ID;

            f = GetMenuItemInfo(hMenu, i, TRUE, &mii);

            if (f && mii.wID == pMI->idmPlaceholder)
            {
                pMI->iInsert = i;
                hr = S_OK;
                break;
            }
        }
    }

    return hr;
}

// note, this popup handler can't easily tell whether an item
// has been removed from the DPA. if you remove any items from the
// DPA it is your responsibility to delete them from the menu
// also, if they live on a menu

HRESULT CBrowserExtension::OnCustomizableMenuPopup(HMENU hMenuParent, HMENU hMenu)
{
    HRESULT             hr;
    BROWSEXT_MENU_INFO  menuInfo;

    RIP(IS_VALID_HANDLE(hMenu, MENU));

    hr = _GetCustomMenuInfo(hMenuParent, hMenu, &menuInfo);
    if (SUCCEEDED(hr) && _hdpa != NULL)
    {
        BOOL    fItemInserted;
        UINT    cItems;
        UINT    i;

        ASSERT(IS_VALID_HANDLE(_hdpa, DPA));

        fItemInserted = FALSE;

        // check each extension object we currently have
        // to see whether any of them should go into this
        // menu

        cItems = (UINT)DPA_GetPtrCount(_hdpa);

        for (i = 0; i < cItems; i++)
        {
            ExtensionItem * pItem;

            pItem = (ExtensionItem *)DPA_GetPtr(_hdpa, i);
            ASSERT(IS_VALID_READ_PTR(pItem, ExtensionItem));

            // does this item go into the menu we're currently
            // customizing?

            if (pItem->idmMenu == menuInfo.idmMenu)
            {
                MENUITEMINFO        mii;
                IOleCommandTarget * pOCT;

                mii.fMask   = MIIM_ID;
                mii.wID     = pItem->idCmd;
                mii.cbSize  = sizeof(mii);

                // set the MENUITEMINFO's state information, if applicable

                ASSERT(IS_VALID_CODE_PTR(pItem->pIBE, IBrowserExtension));

                hr = pItem->pIBE->QueryInterface(IID_IOleCommandTarget, (void **)&pOCT);
                if (SUCCEEDED(hr))
                {
                    OLECMD oleCmd = {OLECMDID_OPEN,};

                    ASSERT(IS_VALID_CODE_PTR(pOCT, IOleCommandTarget));

                    hr = pOCT->QueryStatus(NULL, 1, &oleCmd, NULL);
                    if (SUCCEEDED(hr))
                    {
                        mii.fMask |= MIIM_STATE;
                        mii.fState = 0;

                        // enabled state

                        if (oleCmd.cmdf & OLECMDF_ENABLED)
                        {
                            mii.fState |= MFS_ENABLED;
                        }
                        else
                        {
                            mii.fState |= MFS_DISABLED;
                        }

                        // checked state

                        if (oleCmd.cmdf & OLECMDF_LATCHED)
                        {
                            mii.fState |= MFS_CHECKED;
                        }
                        else
                        {
                            mii.fState |= MFS_UNCHECKED;
                        }
                    }

                    pOCT->Release();
                }

                // get the menu text.
                // this changing is an unlikely scenario, but if we're truly
                // supporting dynamic customization, then we need to allow for
                // this possibility.

                VARIANTARG  varArg;

                hr = pItem->pIBE->GetProperty(TMEX_MENUTEXT, &varArg);
                if (SUCCEEDED(hr))
                {
                    BOOL    fItemExists;

                    ASSERT(varArg.vt == VT_BSTR);
                    ASSERT(IS_VALID_STRING_PTR(varArg.bstrVal, -1));

                    fItemExists = GetMenuItemInfo(hMenu, mii.wID, FALSE, &mii);

                    mii.fMask |= MIIM_TYPE;
                    mii.fType = MFT_STRING;
                    mii.cch = SysStringLen(varArg.bstrVal);
                    mii.dwTypeData = varArg.bstrVal;

                    if (fItemExists)
                    {
                        // update the old item using current info

                        SetMenuItemInfo(hMenu, mii.wID, FALSE, &mii);
                    }
                    else
                    {
                        // create a new item using current info

                        if (InsertMenuItem(hMenu, menuInfo.iInsert, TRUE, &mii))
                        {
                            fItemInserted = TRUE;
                        }
                    }

                    VariantClear(&varArg);
                }

            }
        }

        if (fItemInserted)
        {
            MENUITEMINFO    mii;
            BOOL            fModMarkerExists;

            // since we made an insertion, we need to insert
            // a separator, but only if we didn't do it already

            mii.cbSize = sizeof(mii);
            mii.fMask = 0;

            fModMarkerExists = GetMenuItemInfo(hMenu, menuInfo.idmModMarker, FALSE, &mii);

            if (!fModMarkerExists)
            {
                mii.fMask = MIIM_ID | MIIM_TYPE;
                mii.wID = menuInfo.idmModMarker;
                mii.fType = MFT_SEPARATOR;

                InsertMenuItem(hMenu, menuInfo.iInsert, TRUE, &mii);
            }
        }

        // the only thing that is guaranteed to be a complete failure
        // if if we failed to get the info for the menu doing the popup.
        // otherwise, despite the possibility that any particular insertion
        // attempt might have failed, there are potentially many custom
        // items. though some might fail, some might succeed. in either
        // we'll return overall success, because we successfully did the
        // best we could with the items that were present.
        // at least we didn't crash :)

        hr = S_OK;
    }

    return hr;
}

HRESULT CBrowserExtension::OnMenuSelect(UINT nCmdID)
{
    VARIANT varArg;
    HRESULT hr = E_FAIL;

    // We better have stored our menu extensions if we are at this point
    ASSERT(_hdpa != NULL);
    int i = _GetIdpaFromCmdId(nCmdID);
    if (i >= 0 && i < DPA_GetPtrCount(_hdpa))
    {
        ExtensionItem* pItem = (ExtensionItem*)DPA_GetPtr(_hdpa, i);
        ASSERT(pItem->idmMenu != 0);

        hr = pItem->pIBE->GetProperty(TMEX_STATUSBARTEXT, &varArg);
        if (SUCCEEDED(hr))
        {
            if (varArg.vt == VT_BSTR)
            {
                // Set the Status Bar Text
                if (_pISB)
                {
                    _pISB->SetStatusTextSB(varArg.bstrVal);
                }
            }

            VariantClear(&varArg);
            hr = S_OK;
        }
    }
    return hr;
}

// Create an image list for the Cut/Copy/Paste buttons
CBrowserExtension::CImageCache CBrowserExtension::_rgImages[3];

//
// Get the image list for the toolbar. These image lists are shared between instances so
// the caller must call _ReturnImageLists when finished with them.  The index returned from this
// functions is passed to _ReturnImageLists.
//
UINT CBrowserExtension::_GetImageLists(CImageList** ppimlDef, CImageList** ppimlHot, BOOL fSmall)
{
    COLORREF crMask = RGB( 255, 0, 255 );
    BOOL bUseNewIcons = !SHUseClassicToolbarGlyphs();

    //
    // Get the index into our image cache
    //   16 color 16x16 (small)
    //   16 color 20x20
    //   256 color 20x20
    //
    int i = fSmall ? 0 : 1;
    if (!fSmall && SHGetCurColorRes() > 8)
        ++i;

    int cx = fSmall ? 16 : 20;

    if (!fSmall && bUseNewIcons)
    {
        cx = 24;
    }

    //
    // Create the images if necessary
    //
    ENTERCRITICAL;

    if (_rgImages[0].uiResDef == 0)
    {

        _rgImages[1].uiResDef = IDB_CLASSIC_IETOOLBAR;
        _rgImages[1].uiResHot = IDB_CLASSIC_IETOOLBARHOT;
        _rgImages[1].bShell32 = FALSE;


        if (bUseNewIcons)
        {
            _rgImages[0].uiResDef = IDB_TB_EXT_DEF_16;
            _rgImages[0].uiResHot = IDB_TB_EXT_HOT_16;
            _rgImages[0].bShell32 = TRUE;
            _rgImages[2].uiResDef = IDB_TB_EXT_DEF_24;
            _rgImages[2].uiResHot = IDB_TB_EXT_HOT_24;
            _rgImages[2].bShell32 = TRUE;
        }
        else
        {
            _rgImages[0].uiResDef = IDB_CLASSIC_IETOOLBAR16;
            _rgImages[0].uiResHot = IDB_CLASSIC_IETOOLBARHOT16;
            _rgImages[0].bShell32 = FALSE;
            _rgImages[2].uiResDef = IDB_CLASSIC_IETOOLBARHICOLOR;
            _rgImages[2].uiResHot = IDB_CLASSIC_IETOOLBARHOTHICOLOR;
            _rgImages[2].bShell32 = FALSE;
        }
    }

    if (!_rgImages[i].imlDef.HasImages())
    {
        _rgImages[i].imlDef = ImageList_LoadImage(_rgImages[i].bShell32 ? GetModuleHandle(TEXT("shell32.dll")) : HINST_THISDLL,
                                           MAKEINTRESOURCE(_rgImages[i].uiResDef),
                                           cx, 0, crMask,
                                           IMAGE_BITMAP, LR_CREATEDIBSECTION);
    }

    if (!_rgImages[i].imlHot.HasImages())
    {
        _rgImages[i].imlHot = ImageList_LoadImage(_rgImages[i].bShell32 ? GetModuleHandle(TEXT("shell32.dll")) : HINST_THISDLL,
                                           MAKEINTRESOURCE(_rgImages[i].uiResHot),
                                           cx, 0, crMask,
                                           IMAGE_BITMAP, LR_CREATEDIBSECTION);
    }

    //
    // Add the custom buttons to our image lists
    //
    _AddCustomImagesToImageList(_rgImages[i].imlDef, _rgImages[i].imlHot, fSmall);

    ++_rgImages[i].cUsage;

    *ppimlDef = &_rgImages[i].imlDef;
    *ppimlHot = &_rgImages[i].imlHot;
    LEAVECRITICAL;

    return i;
}

//
// Called when the imagelist indicated by uiIndex is not longer used by this instance
//
void CBrowserExtension::_ReleaseImageLists(UINT uiIndex)
{
    if (uiIndex >= ARRAYSIZE(_rgImages))
    {
        return;
    }

    ENTERCRITICAL;

    ASSERT(_rgImages[uiIndex].cUsage >= 1);

    // If the image lists are no longer used, we can free them
    if (--_rgImages[uiIndex].cUsage == 0)
    {
        _rgImages[uiIndex].imlDef.FreeImages();
        _rgImages[uiIndex].imlHot.FreeImages();
    }
    LEAVECRITICAL;
}

//+-------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
CImageList::CImageList(HIMAGELIST himl)
:   _himl(himl)
{
    ASSERT(_hdpa == NULL);
}

//+-------------------------------------------------------------------------
// Destructor
//--------------------------------------------------------------------------
CImageList::~CImageList()
{
    FreeImages();
}

//+-------------------------------------------------------------------------
// Frees an association item from our dpa
//--------------------------------------------------------------------------
int CImageList::_DPADestroyCallback(LPVOID p, LPVOID d)
{
    delete (ImageAssoc*)p;
    return 1;
}

//+-------------------------------------------------------------------------
// Frees our image list and inex associations
//--------------------------------------------------------------------------
void CImageList::FreeImages()
{
    if (_hdpa)
    {
        DPA_DestroyCallback(_hdpa, _DPADestroyCallback, 0);
        _hdpa = NULL;
    }
    if (_himl)
    {
        ImageList_Destroy(_himl);
        _himl = NULL;
    }
}

//+-------------------------------------------------------------------------
// Updates the image list
//--------------------------------------------------------------------------
CImageList& CImageList::operator=(HIMAGELIST himl)
{
    if (himl != _himl)
    {
        FreeImages();
        _himl = himl;
    }
    return *this;
}

//+-------------------------------------------------------------------------
// Returns the index of the images associated with rguid.  Returns -1 if not
// found.
//--------------------------------------------------------------------------
int CImageList::GetImageIndex(REFGUID rguid)
{
    int iIndex = -1;

    if (_hdpa)
    {
        ASSERT(_himl);

        for (int i=0; i < DPA_GetPtrCount(_hdpa); ++i)
        {
            ImageAssoc* pAssoc = (ImageAssoc*)DPA_GetPtr(_hdpa, i);
            if (IsEqualGUID(pAssoc->guid, rguid))
            {
                return pAssoc->iImage;
            }
        }
    }
    return iIndex;
}

//+-------------------------------------------------------------------------
// Adds the icon to the image list and returns the index.  If the image is
// already present, the existing index is returned.  Returns -1 on failure.
//--------------------------------------------------------------------------
int CImageList::AddIcon(HICON hicon, REFGUID rguid)
{
    ASSERT(hicon != NULL);

    // First see is we have already added this image
    int iIndex = GetImageIndex(rguid);
    if (iIndex == -1)
    {
        // Make sure we have a dpa to store our items
        if (NULL == _hdpa)
        {
            _hdpa = DPA_Create(5);
        }

        if (_hdpa && _himl)
        {
            // Add the icon to our image list
            iIndex = ImageList_AddIcon(_himl, hicon);
            if (iIndex != -1)
            {
                ImageAssoc* pAssoc = new ImageAssoc;
                if (pAssoc)
                {
                    pAssoc->guid = rguid;
                    pAssoc->iImage = iIndex;
                    DPA_AppendPtr(_hdpa, pAssoc);
                }
            }
        }
    }
    return iIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\cacheoff.cpp ===
// Author:  Karim Farouki
// Date:    24 June 1998

#include "priv.h"
#include "util.h"
#include <emptyvc.h>
#include <mluisupp.h>   // for MLLoadString
#include "resource.h"   // for the string ID's

typedef HRESULT (* LPFCALLBACK )(LPINTERNET_CACHE_ENTRY_INFO, void *);

typedef struct tagRTSCBSTRUCT   
{
    IEmptyVolumeCacheCallBack   * picb;
    DWORDLONG                   * pdwlSpaceUsed;
} RTSCBSTRUCT;  // RunningTotalSizeCallBack Struct

typedef struct tagDECBSTRUCT
{
    IEmptyVolumeCacheCallBack   * picb;
    DWORDLONG                   dwlSpaceFreed;
    DWORDLONG                   dwlTotalSpace;
} DECBSTRUCT;   // DeleteEntryCallBack Struct

class COfflinePagesCacheCleaner : public IEmptyVolumeCache2
{
    private:
        // Data
        ULONG       m_cRef;
        DWORDLONG   m_dwlSpaceUsed;
        TCHAR       m_szCacheDir[MAX_PATH + 1];

        // Functions
        HRESULT     WalkOfflineCache(
                        LPFCALLBACK     lpfCallBack,
                        void            * pv
                        );

        static HRESULT CALLBACK RunningTotalSizeCallback(
                        LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo, 
                        void                        * pv
                        );
        
        static HRESULT CALLBACK DeleteEntryCallback(
                        LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo, 
                        void                        * pv
                        );
        static VOID IncrementFileSize(
                        LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo, 
                        DWORDLONG                   * pdwlSize
                        );

        ~COfflinePagesCacheCleaner(void);

    public:
        // Constructor/Destructor
        COfflinePagesCacheCleaner(void);

        // IUnknown Interface members
        STDMETHODIMP            QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG)    AddRef(void);
        STDMETHODIMP_(ULONG)    Release(void);

        // IEmptyVolumeCache interface methods
        STDMETHODIMP    Initialize(
                            HKEY    hkRegKey,
                            LPCWSTR pcwszVolume,
                            LPWSTR  * ppwszDisplayName,
                            LPWSTR  * ppwszDescription,
                            DWORD   * pdwFlags
                            );

        STDMETHODIMP    GetSpaceUsed(
                            DWORDLONG                   * pdwlSpaceUsed,
                            IEmptyVolumeCacheCallBack   * picb
                            );

        STDMETHODIMP    Purge(
                            DWORDLONG                   dwlSpaceToFree,
                            IEmptyVolumeCacheCallBack   * picb
                            );

        STDMETHODIMP    ShowProperties(
                            HWND    hwnd
                            );

        STDMETHODIMP    Deactivate(
                            DWORD   * pdwFlags
                            );

        // IEmptyVolumeCache2 interface methods
        STDMETHODIMP    InitializeEx(
                            HKEY hkRegKey,
                            LPCWSTR pcwszVolume,
                            LPCWSTR pcwszKeyName,
                            LPWSTR *ppwszDisplayName,
                            LPWSTR *ppwszDescription,
                            LPWSTR *ppwszBtnText,
                            DWORD *pdwFlags
                            );
};

STDAPI COfflinePagesCacheCleaner_CreateInstance(
    IUnknown        * punkOuter,
    IUnknown        ** ppunk,
    LPCOBJECTINFO   poi
    )
{
    HRESULT hr = S_OK;
    
    *ppunk = NULL;

    COfflinePagesCacheCleaner * lpOPCC = new COfflinePagesCacheCleaner();

    if (lpOPCC == NULL)
        hr = E_OUTOFMEMORY;
    else
        *ppunk = SAFECAST(lpOPCC, IEmptyVolumeCache *);

    return hr;
}

COfflinePagesCacheCleaner::COfflinePagesCacheCleaner() : m_cRef(1)
{
    DllAddRef();
}

COfflinePagesCacheCleaner::~COfflinePagesCacheCleaner()
{
    DllRelease();
}

STDMETHODIMP COfflinePagesCacheCleaner::QueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = S_OK;
    
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEmptyVolumeCache) || IsEqualIID(riid, IID_IEmptyVolumeCache2))
    {
        *ppv = SAFECAST(this, IEmptyVolumeCache2 *);
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP_(ULONG) COfflinePagesCacheCleaner::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) COfflinePagesCacheCleaner::Release()
{
    ULONG uRefCount = --m_cRef;
    
    if (!uRefCount)
        delete this;

    return uRefCount;
}

STDMETHODIMP COfflinePagesCacheCleaner::InitializeEx(
    HKEY hkRegKey,
    LPCWSTR pcwszVolume,
    LPCWSTR pcwszKeyName,
    LPWSTR *ppwszDisplayName,
    LPWSTR *ppwszDescription,
    LPWSTR *ppwszBtnText,
    DWORD *pdwFlags
    )
{
    *ppwszBtnText = (LPWSTR)CoTaskMemAlloc( 128*sizeof(WCHAR) );
    if ( !*ppwszBtnText )
        return E_OUTOFMEMORY;

    MLLoadString( IDS_CACHEOFF_BTNTEXT, *ppwszBtnText, 128 );

    return Initialize(hkRegKey, pcwszVolume, ppwszDisplayName, ppwszDescription, pdwFlags );
}

STDMETHODIMP COfflinePagesCacheCleaner::Initialize(
    HKEY    hkRegkey,
    LPCWSTR pcwszVolume,
    LPWSTR  * ppwszDisplayName,
    LPWSTR  * ppwszDescription,
    DWORD   * pdwFlags
    )
{
    HRESULT         hr;
    uCLSSPEC        ucs;          // Used to see if Webcheck is installed
    QUERYCONTEXT    qc = { 0 };   // Used to see if Webcheck is installed
    DWORDLONG       dwlSize;      // Amount of offline cachespace


#ifdef UNICODE
    // We can't use the registry values on NT because they can't be multi-local localized.
    // Instead we must use strings loaded from resources.
    *ppwszDisplayName = (LPWSTR)CoTaskMemAlloc( 512*sizeof(WCHAR) );
    if ( !*ppwszDisplayName )
        return E_OUTOFMEMORY;

    *ppwszDescription = (LPWSTR)CoTaskMemAlloc( 512*sizeof(WCHAR) );
    if ( !*ppwszDescription )
    {
        CoTaskMemFree(*ppwszDisplayName);
        return E_OUTOFMEMORY;
    }

    MLLoadString( IDS_CACHEOFF_DISPLAY, *ppwszDisplayName, 512 );
    MLLoadString( IDS_CACHEOFF_DESCRIPTION, *ppwszDescription, 512 );

#else
    // We can use the default registry DisplayName and Description
    *ppwszDisplayName = NULL;
    *ppwszDescription = NULL;
#endif

    // Intentionally am not turning on cleanup by default; turning on *view pages* button
    *pdwFlags = EVCF_HASSETTINGS;

    // Let's check if the Internet Cache Folder is in pcwzVolume
    GetCacheLocation(m_szCacheDir, ARRAYSIZE(m_szCacheDir));
    if (StrCmpNI(pcwszVolume, m_szCacheDir, 3))
    {
        // If the cache is on a different drive return S_FALSE so that we don't show up in UI
        return S_FALSE;
    }

    // Determine if offline browsing pack is intalled.
    ucs.tyspec = TYSPEC_CLSID;
    ucs.tagged_union.clsid = CLSID_SubscriptionMgr;

    hr = FaultInIEFeature(NULL, &ucs, &qc, FIEF_FLAG_PEEK | FIEF_FLAG_FORCE_JITUI);
    
    if (SUCCEEDED(hr))  // (if offline pack installed)
    {
        GetSpaceUsed(&dwlSize, NULL);  
        
        if (dwlSize)        // If there is something in offline cache to delete
            return S_OK;    // load cleaner/
    }

    return S_FALSE;
}

STDMETHODIMP COfflinePagesCacheCleaner::GetSpaceUsed(
    DWORDLONG                   * pdwlSpaceUsed,
    IEmptyVolumeCacheCallBack   * picb
    )
{
    HRESULT hr;

    ASSERT(NULL != pdwlSpaceUsed);

    if (NULL != pdwlSpaceUsed)
    {
        RTSCBSTRUCT * prtscbStruct = new RTSCBSTRUCT;
    
        if (NULL != prtscbStruct)
        {
            // Initialize GetSpazeUsed Structure
            prtscbStruct->pdwlSpaceUsed = pdwlSpaceUsed;
            *(prtscbStruct->pdwlSpaceUsed) = 0;
            prtscbStruct->picb = picb;

            // Get Offline Cache Space Usage    
            hr = WalkOfflineCache(RunningTotalSizeCallback, (void *)(prtscbStruct));
            m_dwlSpaceUsed = *(prtscbStruct->pdwlSpaceUsed);

            // Send the last notification to the cleanup manager
            if (picb != NULL)
                picb->ScanProgress(*(prtscbStruct->pdwlSpaceUsed), EVCCBF_LASTNOTIFICATION, NULL);

            delete prtscbStruct;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP COfflinePagesCacheCleaner::Purge(
    DWORDLONG                   dwlSpaceToFree,   // Spec makes this irrelevent!
    IEmptyVolumeCacheCallBack   * picb
    )
{
    HRESULT hr;

    DECBSTRUCT  * pdecbStruct = new DECBSTRUCT;

    if (NULL != pdecbStruct)
    {
        // Initialize DeleteEntry Structure
        pdecbStruct->picb = picb;
        pdecbStruct->dwlSpaceFreed = 0;
        pdecbStruct->dwlTotalSpace = m_dwlSpaceUsed;

        //  Delete Offline Cache Entries
        hr = WalkOfflineCache(DeleteEntryCallback, (void *)(pdecbStruct));

        // Send the last notification to the cleanup manager
        if (picb != NULL)
        {
            picb->PurgeProgress(m_dwlSpaceUsed, 0, EVCCBF_LASTNOTIFICATION, NULL);
        }

        delete pdecbStruct;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

STDMETHODIMP COfflinePagesCacheCleaner::ShowProperties(HWND hwnd)
{
    TCHAR szOfflinePath[MAX_PATH];
    DWORD dwSize = SIZEOF(szOfflinePath);

    szOfflinePath[0] = L'\0';

    if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SUBSCRIPTION,
                       REGSTR_VAL_DIRECTORY, NULL, (LPBYTE)szOfflinePath, &dwSize) != ERROR_SUCCESS)
    {
        TCHAR szWindows[MAX_PATH];

        szWindows[0] = L'\0';
        GetWindowsDirectory(szWindows, ARRAYSIZE(szWindows));
        if (*szWindows)
            PathCombine(szOfflinePath, szWindows, TEXT("Offline Web Pages"));
    }

    if (*szOfflinePath)
    {
        PathQuoteSpaces(szOfflinePath);
        SHELLEXECUTEINFO shei;
        ZeroMemory(&shei, sizeof(shei));
        shei.cbSize     = sizeof(shei);
        shei.lpFile     = szOfflinePath;
        shei.nShow      = SW_SHOWNORMAL;
        ShellExecuteEx(&shei);
    }
    
    // Returning S_OK insures that GetSpaceUsed is recalled (to recalc) the size being
    // used (in case someone deletes some MAO stuff).
    return S_OK;
}

STDMETHODIMP COfflinePagesCacheCleaner::Deactivate(DWORD * pdwFlags)
{
    // We don't implement this.
    *pdwFlags = 0;

    return S_OK;
}

HRESULT COfflinePagesCacheCleaner::WalkOfflineCache(
    LPFCALLBACK     lpfCallBack,
    void *          pv
    )
{
    ASSERT(pv);

    HRESULT hr = S_OK;
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo;
    HANDLE hCacheEntryInfo;
    DWORD dwCacheEntryInfoSize;
    
    if ((lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO) LocalAlloc(LPTR, 
                                        MAX_CACHE_ENTRY_INFO_SIZE)) == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        dwCacheEntryInfoSize = MAX_CACHE_ENTRY_INFO_SIZE;
        if ((hCacheEntryInfo = FindFirstUrlCacheEntry(NULL, lpCacheEntryInfo,
                                        &dwCacheEntryInfoSize)) == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    
        if (SUCCEEDED(hr))
        {
            do
            {   
                if (lpCacheEntryInfo->CacheEntryType & STICKY_CACHE_ENTRY)
                {
                    hr = lpfCallBack(lpCacheEntryInfo, pv);
                }

                dwCacheEntryInfoSize = MAX_CACHE_ENTRY_INFO_SIZE;
            } while ((E_ABORT != hr) &&
                     FindNextUrlCacheEntry(hCacheEntryInfo, lpCacheEntryInfo,
                                           &dwCacheEntryInfoSize));
            
            if (hr != E_ABORT) 
            {
                DWORD dwLastErr = GetLastError();

                if (dwLastErr != ERROR_NO_MORE_ITEMS)
                {
                    hr = HRESULT_FROM_WIN32(dwLastErr);
                }
            }
        }
    
        LocalFree(lpCacheEntryInfo);
        lpCacheEntryInfo = NULL;
    }

    return hr;
}

HRESULT CALLBACK COfflinePagesCacheCleaner::RunningTotalSizeCallback(
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,  // Name of the CacheEntry to sum
    void                        * pv               // A RTSCBSTRUCT
    )
{
    HRESULT hr = S_OK;
    RTSCBSTRUCT * prtscbStruct = (RTSCBSTRUCT *)pv;

    // Add current file size to total    
    IncrementFileSize(lpCacheEntryInfo, prtscbStruct->pdwlSpaceUsed);

    // Update the progressbar!
    if (prtscbStruct->picb != NULL)
        hr = prtscbStruct->picb->ScanProgress(*(prtscbStruct->pdwlSpaceUsed), 0, NULL);

    return hr;
}

HRESULT CALLBACK COfflinePagesCacheCleaner::DeleteEntryCallback(
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo, // Name of the CacheEntry to delete
    void                        * pv              // Pointer to DECBSTRUCT
    )
{
    HRESULT     hr = S_OK;
    DECBSTRUCT  * pdecbStruct = (DECBSTRUCT *)pv;
    
    // Add current file size to total deleted
    IncrementFileSize(lpCacheEntryInfo, &(pdecbStruct->dwlSpaceFreed));

    DeleteUrlCacheEntry(lpCacheEntryInfo->lpszSourceUrlName);   

    // Update the progress bar!
    if (pdecbStruct->picb != NULL)
    {
        hr =  pdecbStruct->picb->PurgeProgress(pdecbStruct->dwlSpaceFreed, 
            pdecbStruct->dwlTotalSpace - pdecbStruct->dwlSpaceFreed, NULL, NULL);
    }

    return hr;
}

VOID COfflinePagesCacheCleaner::IncrementFileSize(
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo, 
    DWORDLONG                   * pdwlSize
    )
{
    ULARGE_INTEGER uliFileSize;
    
    uliFileSize.HighPart = lpCacheEntryInfo->dwSizeHigh;
    uliFileSize.LowPart = lpCacheEntryInfo->dwSizeLow;

    *pdwlSize += QUAD_PART(uliFileSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\bindcb.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

#ifndef _BINDCB_H_

// the CStubBindStatusCallback implements IBindStatusCallback and
// IHttpNegotiate.  We use it to make a "fake" bind status callback
// object when we have headers and post data we would like to apply
// to a navigation.  We supply this IBindStatusCallback object, and
// the URL moniker asks us for headers and post data and use those in
// the transaction.

class CStubBindStatusCallback : public IBindStatusCallback,
                                       IHttpNegotiate,
                                       IMarshal
{
private:
    UINT      _cRef;         // ref count on this COM object
    LPCTSTR    _pszHeaders;  // headers to use
    HGLOBAL   _hszPostData;  // post data to use
    DWORD     _cbPostData;   // size of post data
    BOOL      _bFrameIsOffline : 1; // Indicates if Offline property is set
    BOOL      _bFrameIsSilent : 1;  // Indicates if Silent property is set
    BOOL      _bHyperlink : 1;  // This is a hyperlink or top level request
    DWORD     _grBindFlags; //  optional additional bindinfo flags

public:
    CStubBindStatusCallback(LPCWSTR pwzHeaders,LPCBYTE pPostData,DWORD cbPostData,
                            VARIANT_BOOL bFrameIsOffline, VARIANT_BOOL bFrameIsSilent, BOOL bHyperlink, DWORD grBindFlags);
    ~CStubBindStatusCallback();

    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IBindStatusCallback ***
    virtual STDMETHODIMP OnStartBinding(
        /* [in] */ DWORD grfBSCOption,
        /* [in] */ IBinding *pib);

    virtual STDMETHODIMP GetPriority(
        /* [out] */ LONG *pnPriority);

    virtual STDMETHODIMP OnLowResource(
        /* [in] */ DWORD reserved);

    virtual STDMETHODIMP OnProgress(
        /* [in] */ ULONG ulProgress,
        /* [in] */ ULONG ulProgressMax,
        /* [in] */ ULONG ulStatusCode,
        /* [in] */ LPCWSTR szStatusText);

    virtual STDMETHODIMP OnStopBinding(
        /* [in] */ HRESULT hresult,
        /* [in] */ LPCWSTR szError);

    virtual STDMETHODIMP GetBindInfo(
        /* [out] */ DWORD *grfBINDINFOF,
        /* [unique][out][in] */ BINDINFO *pbindinfo);

    virtual STDMETHODIMP OnDataAvailable(
        /* [in] */ DWORD grfBSCF,
        /* [in] */ DWORD dwSize,
        /* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pstgmed);

    virtual STDMETHODIMP OnObjectAvailable(
        /* [in] */ REFIID riid,
        /* [iid_is][in] */ IUnknown *punk);

    /* *** IHttpNegotiate ***  */
    virtual STDMETHODIMP BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
            DWORD dwReserved, LPWSTR __RPC_FAR *pszAdditionalHeaders);

    virtual STDMETHODIMP OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders,
            LPCWSTR szRequestHeaders, LPWSTR *pszAdditionalRequestHeaders);

    // IMarshal methods
                    
    STDMETHODIMP GetUnmarshalClass(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,CLSID *pCid);
    STDMETHODIMP GetMarshalSizeMax(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,DWORD *pSize);
    STDMETHODIMP MarshalInterface(IStream *pistm,REFIID riid,
                                void *pvInterface,DWORD dwDestContext,
                                void *pvDestContext,DWORD mshlflags);
    STDMETHODIMP UnmarshalInterface(IStream *pistm,REFIID riid,void ** ppvObj);
    STDMETHODIMP ReleaseMarshalData(IStream *pStm);
    STDMETHODIMP DisconnectObject(DWORD dwReserved);

    // helper methods
    STDMETHODIMP _FreeHeadersAndPostData();
    BOOL _CanMarshalIID(REFIID riid);
    HRESULT _ValidateMarshalParams(REFIID riid,void *pvInterface,
                    DWORD dwDestContext,void *pvDestContext,DWORD mshlflags);

};

// :
// private flags between shdocvw and mshtml
// -> should be done via bind context
//
#define BINDF_INLINESGETNEWESTVERSION   0x10000000
#define BINDF_INLINESRESYNCHRONIZE      0x20000000
#define BINDF_CONTAINER_NOWRITECACHE    0x40000000


// global helper functions
BOOL fOnProxy();
HRESULT BuildBindInfo(DWORD *grfBINDF,BINDINFO *pbindinfo,HGLOBAL hszPostData,
    DWORD cbPostData, BOOL bFrameIsOffline, BOOL bFrameIsSilent, BOOL bHyperlink, LPUNKNOWN pUnkForRelease);
HRESULT BuildAdditionalHeaders(LPCTSTR pszOurExtraHeaders,LPCWSTR * ppwzCombinedHeadersOut);
HRESULT CStubBindStatusCallback_Create(LPCWSTR pwzHeaders, LPCBYTE pPostData,
    DWORD cbPostData, VARIANT_BOOL bFrameIsOffline, VARIANT_BOOL bFrameIsSilent,BOOL bHyperlink,
    DWORD grBindFlags,
    CStubBindStatusCallback ** ppBindStatusCallback);
HRESULT GetHeadersAndPostData(IBindStatusCallback * pBindStatusCallback,
    LPTSTR * ppszHeaders, STGMEDIUM * pstgPostData, DWORD * pdwPostData, BOOL * pfUseCache);
HRESULT GetTopLevelBindStatusCallback(IServiceProvider * psp,
    IBindStatusCallback ** ppBindStatusCallback);
HRESULT GetTopLevelPendingBindStatusCallback(IServiceProvider * psp,
    IBindStatusCallback ** ppBindStatusCallback);

#endif // _BINDCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\browsext.h ===
#ifndef _BROWSEXT_H
#define _BROWSEXT_H

#include "tbext.h"

#define FCIDM_TOOLS_EXT_PLACEHOLDER         0x9000
#define FCIDM_TOOLS_EXT_MOD_MARKER          0x9001
#define FCIDM_HELP_EXT_PLACEHOLDER          0x9002
#define FCIDM_HELP_EXT_MOD_MARKER           0x9003

//
// This class is used to store/retrieve images by name (guid) from shared image lists
//
class CImageList
{
public:
    CImageList(HIMAGELIST himl = NULL);
    ~CImageList();

    CImageList& operator=(HIMAGELIST himl);
    operator HIMAGELIST() { return _himl; }
    int GetImageIndex(REFGUID rguid);
    int AddIcon(HICON hicon, REFGUID rguid);
    BOOL HasImages() { return (_himl != NULL); }
    void FreeImages();

protected:
    static int _DPADestroyCallback(LPVOID p, LPVOID d);

    // Associate guids with indices into the image list
    struct ImageAssoc
    {
        GUID    guid;
        int     iImage;
    };
    HIMAGELIST  _himl;
    HDPA        _hdpa;      // Array of ImageAssoc
};


//
// Internal interface fo managing buttons added to the internet toolbar and menu items added to the
// tools menu.  This interface will likely go away afer IE5B2 when we move this functionality to
// a browser helper object.
//
EXTERN_C const IID IID_IToolbarExt;

DECLARE_INTERFACE_(IToolbarExt, IUnknown)
{
    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;
    virtual STDMETHODIMP_(ULONG) AddRef(void) PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;

    // *** IToolbarExt methods ***
    virtual STDMETHODIMP GetButtons(TBBUTTON* ptbArr, int nNumButtons, BOOL fInit) PURE;
    virtual STDMETHODIMP GetNumButtons(UINT* pButtons) PURE;
    virtual STDMETHODIMP InitButtons(IExplorerToolbar* pxtb, UINT* puStringIndex, const GUID* pguidCommandGroup) PURE;
    virtual STDMETHODIMP OnCustomizableMenuPopup(HMENU hMenuParent, HMENU hMenu) PURE;
    virtual STDMETHODIMP OnMenuSelect(UINT nCmdID) PURE;
};

class CBrowserExtension : public IToolbarExt
                        , public IObjectWithSite
                        , public IOleCommandTarget
{
public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* pUnkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, void ** ppvSite);

    // *** IToolbarExt methods ***
    virtual STDMETHODIMP GetButtons(TBBUTTON* ptbArr, int nNumButtons, BOOL fInit);
    virtual STDMETHODIMP GetNumButtons(UINT* pButtons);
    virtual STDMETHODIMP InitButtons(IExplorerToolbar* pxtb, UINT* puStringIndex, const GUID* pguidCommandGroup);
    virtual STDMETHODIMP OnCustomizableMenuPopup(HMENU hMenuParent, HMENU hMenu);
    virtual STDMETHODIMP OnMenuSelect(UINT nCmdID);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);

protected:
    // Instance creator
    friend HRESULT CBrowserExtension_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

    CBrowserExtension();
    ~CBrowserExtension();

    HRESULT Update();

    struct ExtensionItem
    {
        CLSID               guid;       // id of the extension
        IBrowserExtension*  pIBE;
        BITBOOL             fButton:1;  // if has a button
        BITBOOL             fVisible:1; // if defaults to visible on the toolbar
        int                 iStringID;  // Keeps track of the location in the string resource for the button
        int                 iImageID;   // The ID of the icon in the image lists
        int                 idCmd;      // toolbar CmdId
        UINT                idmMenu;    // idm of the menu this extension belongs to
    };

    void            _AddItem(HKEY hkeyExtensions,  LPCWSTR pszButtonGuid, REFGUID rguid);
    ExtensionItem*  _FindItem(REFGUID rguid);
    void            _FreeItems();
    HRESULT         _Exec(int nItem, int nCmdID);
    UINT            _GetImageLists(CImageList** ppimlDef, CImageList** ppimlHot, BOOL fSmall);
    void            _ReleaseImageLists(UINT uiIndex);
    HRESULT         _AddCustomImagesToImageList(CImageList& rimlNormal, CImageList& rimlHot, BOOL fSmallIcons);
    HRESULT         _AddCustomStringsToBuffer(IExplorerToolbar * pxtb, const GUID* pguidCommandGroup);

    int             _GetCmdIdFromClsid(LPCWSTR pszGuid);
    int             _GetIdpaFromCmdId(int nCmdId);

    typedef struct tagBROWSEXT_MENU_INFO
    {
        UINT    idmMenu;        // idm for this menu
        UINT    idmPlaceholder;
        UINT    idmModMarker;   // separator with this idm is present if customizations have been made
        int     iInsert;        // insertion point for custom items
    } BROWSEXT_MENU_INFO;

    HRESULT         _GetCustomMenuInfo(HMENU hMenuParent, HMENU hMenu, BROWSEXT_MENU_INFO * pMI);

    LONG                _cRef;                  // reference count
    HDPA                _hdpa;                  // array of ExtensionItem*
    int                 _nExtButtons;           // Number of Buttons
    int                 _nExtToolsMenuItems;    // Number of Tools Menu Items
    IShellBrowser*      _pISB;                  // Passed into the IObjectWithSite::GetSite
    UINT                _uStringIndex;          // index of first string added to toolbar

    // Used for CUT/COPY/PASTE imagelist
    struct CImageCache
    {
        UINT        uiResDef;               // resource id for grey-scale bitmap
        UINT        uiResHot;               // resource id for color bitmap
        CImageList  imlDef;                 // grey scale imagelist
        CImageList  imlHot;                 // color imagelist
        int         cUsage;                 // number of instances using this item
        BOOL        bShell32;               // resource stored in shell32
    };
    static CImageCache      _rgImages[3];   // cached image lists:
                                            //   16 color 16x16
                                            //   16 color 20x20
                                            //   256 color 20x20
    UINT                    _uiImageIndex;  // Currently used index into _rgImages (-1 is none)


#ifdef DEBUG
    BOOL _fStringInit;      // These are used to insure that AddExtButtonsTBArray is only called after
    BOOL _fImageInit;       // AddCustomImag... and AddCustomStrin... have been called.
#endif
};

EXTERN_C const CLSID CLSID_PrivBrowsExtCommands;
typedef enum {
    PBEC_GETSTRINGINDEX     =   1,
} PBEC_COMMANDS;

#endif // _BROWSEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\bindcb.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

// the CStubBindStatusCallback implements IBindStatusCallback,
// IHttpNegotiate.  We use it to make a "fake" bind status callback
// object when we have headers and post data we would like to apply
// to a navigation.  We supply this IBindStatusCallback object, and
// the URL moniker asks us for headers and post data and use those in
// the transaction.

#include "priv.h"
#include "sccls.h"
#include "bindcb.h"  

CStubBindStatusCallback::CStubBindStatusCallback(LPCWSTR pwzHeaders,LPCBYTE pPostData,
    DWORD cbPostData, VARIANT_BOOL bOfflineProperty, VARIANT_BOOL bSilentProperty, BOOL bHyperlink,
    DWORD grBindFlags) : _cRef(1)
    // _pszHeaders(NULL), _hszPostData(NULL), _cbPostData(0)  (don't need to zero-init)
{
    // this is a standalone COM object; need to maintain ref count on our
    // DLL to ensure it doesn't unload
    DllAddRef();

    if (pwzHeaders) {
        _pszHeaders = StrDup(pwzHeaders);    // allocate for a permanent copy
    }

    if (pPostData && cbPostData) {
        // make a copy of post data and store it
        _hszPostData = GlobalAlloc(GPTR,cbPostData);
        if (_hszPostData) {
            memcpy((LPVOID) _hszPostData,pPostData,cbPostData);
            _cbPostData = cbPostData;
        }
    }

    _bFrameIsOffline = bOfflineProperty ? TRUE : FALSE;
    _bFrameIsSilent = bSilentProperty ? TRUE : FALSE;
    _bHyperlink = bHyperlink ? TRUE : FALSE;
    _grBindFlags = grBindFlags;
    TraceMsg(TF_SHDLIFE, "ctor CStubBindStatusCallback %x", this);
}

HRESULT CStubBSC_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CStubBindStatusCallback * pbsc = new CStubBindStatusCallback(NULL, NULL, 0, FALSE, FALSE, TRUE, 0);
    if (pbsc) {
    *ppunk = (IBindStatusCallback *)pbsc;
    return S_OK;
    }

    return E_OUTOFMEMORY;
}


CStubBindStatusCallback::~CStubBindStatusCallback()
{
    TraceMsg(TF_SHDLIFE, "dtor CBindStatusCallback %x", this);

    _FreeHeadersAndPostData();  // free any data we still have in this object

    // release ref count on DLL
    DllRelease();
}

STDMETHODIMP CStubBindStatusCallback::QueryInterface(REFIID riid,
    LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IBindStatusCallback)) {
        *ppvObj = SAFECAST(this, IBindStatusCallback*);
    } else if (IsEqualIID(riid, IID_IHttpNegotiate)) {
        *ppvObj = SAFECAST(this, IHttpNegotiate*);
    } else if (IsEqualIID(riid, IID_IMarshal)) {
        *ppvObj = SAFECAST(this, IMarshal*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();  // handing out an interface on ourselves; bump up ref count

    return S_OK;
}

STDMETHODIMP_(ULONG) CStubBindStatusCallback::AddRef(void)
{
    _cRef++;
    TraceMsg(TF_SHDREF, "CStubBindStatusCallback(%x)::AddRef called, new _cRef=%d", this, _cRef);

    return _cRef;
}

STDMETHODIMP_(ULONG) CStubBindStatusCallback::Release(void)
{
    _cRef--;
    TraceMsg(TF_SHDREF, "CStubBindStatusCallback(%x)::Release called, new _cRef=%d", this, _cRef);

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

//
//  Implementation of IBindStatusCallback begins here
//

// implements IBindStatusCallback::OnStartBinding
STDMETHODIMP CStubBindStatusCallback::OnStartBinding(DWORD grfBSCOption,IBinding *pib)
{
    return S_OK;  // we don't care
}

// implements IBindStatusCallback::GetPriority
STDMETHODIMP CStubBindStatusCallback::GetPriority(LONG *pnPriority)
{
    *pnPriority = NORMAL_PRIORITY_CLASS;

    return S_OK;
}

// implements IBindStatusCallback::OnLowResource
STDMETHODIMP CStubBindStatusCallback::OnLowResource(DWORD reserved)
{
    return S_OK;  // we don't care
}

// implements IBindStatusCallback::OnProgress
STDMETHODIMP CStubBindStatusCallback::OnProgress(ULONG ulProgress,ULONG ulProgressMax,
        ULONG ulStatusCode,LPCWSTR szStatusText)
{
    return S_OK;  // we don't care
}

// implements IBindStatusCallback::OnStopBinding
STDMETHODIMP CStubBindStatusCallback::OnStopBinding(HRESULT hresult,LPCWSTR szError)
{
    return S_OK;  // we don't care
}

// implements IBindStatusCallback::GetBindInfo
STDMETHODIMP CStubBindStatusCallback::GetBindInfo(DWORD *grfBINDF,BINDINFO *pbindinfo)
{
    HRESULT hr;

    if (!grfBINDF || !pbindinfo || !pbindinfo->cbSize)
        return E_INVALIDARG;

    // call helper function to do fill in BINDINFO struct with appropriate
    // binding data
    *grfBINDF = _grBindFlags;
    hr = BuildBindInfo(grfBINDF,pbindinfo,_hszPostData,_cbPostData, _bFrameIsOffline, _bFrameIsSilent, _bHyperlink,
        (IBindStatusCallback *) this);

    return hr;
}

// implements IBindStatusCallback::OnDataAvailable
STDMETHODIMP CStubBindStatusCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
    FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
    ASSERT(FALSE);  // should never get called here!

    return S_OK;
}

STDMETHODIMP CStubBindStatusCallback::OnObjectAvailable(REFIID riid,IUnknown *punk)
{
    return S_OK;
}

//
//  Implementation of IHttpNegotiate begins here
//

// implements IHttpNegotiate::BeginningTransaction
STDMETHODIMP CStubBindStatusCallback::BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
    DWORD dwReserved, LPWSTR *ppwzAdditionalHeaders)
{
    // call helper function
    return BuildAdditionalHeaders(_pszHeaders,(LPCWSTR *) ppwzAdditionalHeaders);
}

// implements IHttpNegotiate::OnResponse
STDMETHODIMP CStubBindStatusCallback::OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders,
    LPCWSTR szRequestHeaders, LPWSTR *pszAdditionalRequestHeaders)
{

    return S_OK;
}

//
//  Additional methods on our class begin here
//

STDMETHODIMP CStubBindStatusCallback::_FreeHeadersAndPostData()
{
    if (_pszHeaders) {
        LocalFree((HGLOBAL) _pszHeaders);
        _pszHeaders = NULL;
    }

    if (_hszPostData) {
        GlobalFree(_hszPostData);
        _hszPostData = NULL;
        _cbPostData = 0;
    }
    
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Method:     CStubBindStatusCallback::_CanMarshalIID
//
//  Synopsis:   Checks whether this object supports marshalling this IID.
//
//  Arguments:  [riid] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BOOL CStubBindStatusCallback::_CanMarshalIID(REFIID riid)
{
    // keep this in sync with the QueryInterface
    return (BOOL) (IsEqualIID(riid,IID_IBindStatusCallback) || 
                   IsEqualIID(riid,IID_IUnknown) ||
                   IsEqualIID(riid, IID_IHttpNegotiate));
}

//+---------------------------------------------------------------------------
//
//  Method:     CStubBindStatusCallback::_ValidateMarshalParams
//
//  Synopsis:   Validates the standard set parameters that are passed into most
//              of the IMarshal methods
//
//  Arguments:  [riid] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CStubBindStatusCallback::_ValidateMarshalParams(REFIID riid,void *pvInterface,
                    DWORD dwDestContext,void *pvDestContext,DWORD mshlflags)
{

    HRESULT hr = NOERROR;
 
    if (_CanMarshalIID(riid))
    {
        // 10/02/96 chrisfra: ask johannp, should we be supporting future contexts
        // via CoGetStandardMarshal?

        ASSERT((dwDestContext == MSHCTX_INPROC || dwDestContext == MSHCTX_LOCAL || dwDestContext == MSHCTX_NOSHAREDMEM));
        ASSERT((mshlflags == MSHLFLAGS_NORMAL || mshlflags == MSHLFLAGS_TABLESTRONG));

        if (  (dwDestContext != MSHCTX_INPROC && dwDestContext != MSHCTX_LOCAL && dwDestContext != MSHCTX_NOSHAREDMEM)
            || (mshlflags != MSHLFLAGS_NORMAL && mshlflags != MSHLFLAGS_TABLESTRONG))
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// IMarshal methods
//
//+---------------------------------------------------------------------------
//
//  Method:     CStubBindStatusCallback::GetUnmarshalClass
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//              [pCid] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CStubBindStatusCallback::GetUnmarshalClass(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,CLSID *pCid)
{
    HRESULT hr;

    hr = _ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
    if (hr == NOERROR)
    {
        *pCid = (CLSID) CLSID_CStubBindStatusCallback;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CStubBindStatusCallback::GetMarshalSizeMax
//
//  Synopsis:
//
//  Arguments:  [void] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//              [pSize] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CStubBindStatusCallback::GetMarshalSizeMax(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,DWORD *pSize)
{
    HRESULT hr;

    if (pSize == NULL)
    {
        hr = E_INVALIDARG;

    }
    else
    {

        hr = _ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
        if (hr == NOERROR)
        {

            // size of fBSCBFlags, grBindFlags, postdata, headers.
            *pSize = (sizeof(DWORD) + 3 * sizeof(DWORD)) + _cbPostData ;
            if (_pszHeaders)
                *pSize += ((lstrlen(_pszHeaders) + 1) * sizeof(*_pszHeaders));
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CStubBindStatusCallback::MarshalInterface
//
//  Synopsis:
//
//  Arguments:  [REFIID] --
//              [riid] --
//              [DWORD] --
//              [void] --
//              [DWORD] --
//              [mshlflags] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CStubBindStatusCallback::MarshalInterface(IStream *pistm,REFIID riid,
                                void *pvInterface,DWORD dwDestContext,
                                void *pvDestContext,DWORD mshlflags)
{
    HRESULT hr;
    DWORD cbLen;
    DWORD fBSCBFlags;

    hr = _ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
    if (hr != NOERROR) goto exitPoint;

    //  Write _grBindFlags
    hr = pistm->Write(&_grBindFlags, sizeof(DWORD), NULL);
    if (hr != NOERROR) goto exitPoint;

    //  Write fBSCBFlags

    fBSCBFlags = (_bFrameIsOffline ? 1 : 0) + (_bFrameIsSilent ? 2 : 0) ;

    hr = pistm->Write(&fBSCBFlags, sizeof(DWORD), NULL);
    if (hr != NOERROR) goto exitPoint;

    //  Write headers

    cbLen = (_pszHeaders ? (lstrlen(_pszHeaders) + 1) * sizeof(TCHAR) : 0);
    hr = pistm->Write(&cbLen, sizeof(DWORD), NULL);
    if (hr != NOERROR) goto exitPoint;
    if (cbLen != 0)
    {
        hr = pistm->Write(_pszHeaders, cbLen, NULL);
        if (hr != NOERROR) goto exitPoint;
    }

    //  Write PostData

    hr = pistm->Write(&_cbPostData, sizeof(DWORD), NULL);
    if (hr != NOERROR) goto exitPoint;
    if (_cbPostData != 0)
    {
        hr = pistm->Write(_hszPostData, _cbPostData, NULL);
        if (hr != NOERROR) goto exitPoint;
    }

exitPoint:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CStubBindStatusCallback::UnmarshalInterface
//
//  Synopsis:   Unmarshals an Urlmon interface out of a stream
//
//  Arguments:  [REFIID] --
//              [void] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CStubBindStatusCallback::UnmarshalInterface(IStream *pistm, REFIID riid, void ** ppvObj)
{
    HRESULT hr = NOERROR;
    DWORD fBSCBFlags;

    if (ppvObj == NULL)
    {
        hr = E_INVALIDARG;
    }
    else if (! _CanMarshalIID(riid))
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    else
    {
        *ppvObj = NULL;
        DWORD cbLen;

        //  Free old values, if any

        _FreeHeadersAndPostData();

        //  Read _grBindFlags

        hr = pistm->Read(&fBSCBFlags, sizeof(DWORD), NULL);
        if (hr != NOERROR) goto exitPoint;
        _grBindFlags = fBSCBFlags;

        //  Read m_fBSCBFlags

        hr = pistm->Read(&fBSCBFlags, sizeof(DWORD), NULL);
        if (hr != NOERROR) goto exitPoint;
        _bFrameIsOffline = fBSCBFlags & 1 ? 1:0;
        _bFrameIsSilent = fBSCBFlags & 2 ? 1:0;

        //  Read headers

        hr = pistm->Read(&cbLen, sizeof(DWORD), NULL);
        if (hr != NOERROR) goto exitPoint;
        if (cbLen != 0)
        {
            LPTSTR pszData;

            pszData = (LPTSTR) LocalAlloc(LPTR, cbLen);
            if (pszData == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exitPoint;
            }
            hr = pistm->Read(pszData, cbLen, 0);
            if (hr != NOERROR)
            {
                LocalFree(pszData);
                pszData = NULL;
                goto exitPoint;
            }
            _pszHeaders = pszData;
        }

        //  Read PostData

        hr = pistm->Read(&cbLen, sizeof(DWORD), NULL);
        if (hr != NOERROR) goto exitPoint;
        if (cbLen != 0)
        {
            HGLOBAL hszData;

            // POST data must be HGLOBAL because the StgMedium requires it
            // see bindcb.cpp ::GetBindInfo()
            // This will be freed by the Moniker when it's done with it.


            hszData = GlobalAlloc(GPTR,cbLen);
            if (hszData == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exitPoint;
            }
            hr = pistm->Read(hszData, cbLen, 0);
            if (hr != NOERROR)
            {
                GlobalFree(hszData);
                hszData = NULL;
                goto exitPoint;
            }
            _hszPostData = hszData;
            _cbPostData = cbLen;
        }


        // call QI to get the requested interface
        hr = QueryInterface(riid, ppvObj);
    }
exitPoint:
    return hr;
}

STDMETHODIMP CStubBindStatusCallback::ReleaseMarshalData(IStream *pStm)
{
    //  10/02/96 chrisfra: ask Johannp if this should be seeking past EOD
    return NOERROR;
}

STDMETHODIMP CStubBindStatusCallback::DisconnectObject(DWORD dwReserved)
{
    return NOERROR;
}


//
//  Global helper functions
//

/*******************************************************************

    NAME:       fOnProxy

    SYNOPSIS:   returns TRUE if we are have proxy enabled


********************************************************************/
BOOL fOnProxy()
{
    // are we on a proxy?
    BOOL fRetOnProxy = FALSE;
    DWORD dwValue;
    DWORD dwSize = SIZEOF(dwValue);
    BOOL  fDefault = FALSE;

    SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
        TEXT("ProxyEnable"), NULL, (LPBYTE)&dwValue, &dwSize, FALSE, (LPVOID) &fDefault, SIZEOF(fDefault));
    fRetOnProxy = dwValue;

    return fRetOnProxy;
}

/*******************************************************************

    NAME:       SetBindfFlagsBasedOnAmbient

    SYNOPSIS:   sets BINDF_OFFLINE if ambient offline and
                not-connected and sets BINDF_GETFROMCACHE_IF_NET_FAIL
                if ambient offline and connected


********************************************************************/
void SetBindfFlagsBasedOnAmbient(BOOL fAmbientOffline, DWORD *grfBINDF)
{
    if (fAmbientOffline)
    {
        DWORD dwConnectedStateFlags;
        
        // We want to set the offline bindf flag if the ambient flag is set
        // and we're currently not connected.
        //
        // If either of these conditions is not true, clear the offline flag
        // as mshtml may have previously set it.
        if (FALSE == InternetGetConnectedState(&dwConnectedStateFlags, 0))
        {
            *grfBINDF |= BINDF_OFFLINEOPERATION;
            *grfBINDF &= ~BINDF_GETFROMCACHE_IF_NET_FAIL;
        }
        else
        {
            *grfBINDF |= BINDF_GETFROMCACHE_IF_NET_FAIL;
            *grfBINDF &= ~BINDF_OFFLINEOPERATION;   
        }
    }
    else
    {
        *grfBINDF &= ~BINDF_OFFLINEOPERATION;
    }
}


/*******************************************************************

    NAME:       BuildBindInfo

    SYNOPSIS:   Fills out a BINDINFO structure for a URL moniker

    NOTES:      The point of having this in a global helper function is
                so we don't have to duplicate this code in multiple
                implementations of IBindStatusCallback.

                The caller must pass in an IUnknown to be used as the
                pUnkForRelease in the STGMEDIUM for post data.  If there
                is post data, this function will AddRef the passed-in
                IUnknown and return it in the STGMEDIUM structure.  The
                caller (or someone else, if the caller hands it off) must
                ultimately call Release on pbindinfo->stgmediumData.pUnkForRelease.

********************************************************************/
HRESULT BuildBindInfo(DWORD *grfBINDF,BINDINFO *pbindinfo,HGLOBAL hszPostData,
    DWORD cbPostData, BOOL bFrameIsOffline, BOOL bFrameIsSilent, BOOL bHyperlink, LPUNKNOWN pUnkForRelease)
{
    DWORD dwConnectedStateFlags = 0;
    ASSERT(grfBINDF);
    ASSERT(pbindinfo);
    ASSERT(pUnkForRelease);

    HRESULT hres=S_OK;

    if (!grfBINDF || !pbindinfo || !pbindinfo->cbSize)
        return E_INVALIDARG;

    // clear BINDINFO except cbSize
    ASSERT(sizeof(*pbindinfo) == pbindinfo->cbSize);
    DWORD cbSize = pbindinfo->cbSize;
    ZeroMemory(pbindinfo, cbSize);
    pbindinfo->cbSize = cbSize;

    *grfBINDF |= BINDF_ASYNCHRONOUS;

    if (bHyperlink)
        *grfBINDF |= BINDF_HYPERLINK;

   
    SetBindfFlagsBasedOnAmbient(bFrameIsOffline, grfBINDF);
    
    if (bFrameIsSilent)
        *grfBINDF |= BINDF_NO_UI;   

    // default method is GET.  Valid ones are _GET, _PUT, _POST, _CUSTOM
    pbindinfo->dwBindVerb = BINDVERB_GET;

    // get IE-wide UTF-8 policy by calling urlmon
    DWORD dwIE = URL_ENCODING_NONE;
    DWORD dwOutLen = sizeof(DWORD);
    if (S_OK == UrlMkGetSessionOption(
        URLMON_OPTION_URL_ENCODING,
        &dwIE, 
        sizeof(DWORD),
        &dwOutLen,
        NULL))
    {
        if (dwIE == URL_ENCODING_ENABLE_UTF8)
        {
            pbindinfo->dwOptions |= BINDINFO_OPTIONS_ENABLE_UTF8;
        }
        else if (dwIE == URL_ENCODING_DISABLE_UTF8)
        {
            pbindinfo->dwOptions |= BINDINFO_OPTIONS_DISABLE_UTF8;
        }
    }

    // if we have postdata set, then we assume this is a POST verb

    if (hszPostData)
    {
        pbindinfo->dwBindVerb = BINDVERB_POST;
        pbindinfo->stgmedData.tymed = TYMED_HGLOBAL;
        pbindinfo->stgmedData.hGlobal = hszPostData;
        //  this count should *NOT* include the terminating NULL
        pbindinfo->cbstgmedData = cbPostData;
        pbindinfo->stgmedData.pUnkForRelease = pUnkForRelease;
        // addref on the IUnknown that's holding onto this data so
        // it knows to stick around; caller must call Release
        // on the pUnkForRelease when done.
        pUnkForRelease->AddRef(); 

        // We will still cache the response, but we do not want to
        // read from cache for a POST transaction.  This will keep us
        // from reading from the cache.
        *grfBINDF |= BINDF_GETNEWESTVERSION | BINDF_CONTAINER_NOWRITECACHE;
    } else {
        ASSERT(pbindinfo->stgmedData.tymed == TYMED_NULL);
        ASSERT(pbindinfo->stgmedData.hGlobal == NULL);
        ASSERT(pbindinfo->stgmedData.pUnkForRelease == NULL);
    }

    return hres;
}

#define HDR_LANGUAGE     TEXT("Accept-Language:")
#define CRLF             TEXT("\x0D\x0A")
#define HDR_LANGUAGE_CRLF     TEXT("Accept-Language: %s\x0D\x0A")

/*******************************************************************

    NAME:       BuildAdditionalHeaders

    SYNOPSIS:   Builds HTTP headers to be given to URL moniker

    ENTRY:      pszOurExtraHeaders - headers that we explicitly want to add
                *ppwzCombinedHeadersOut - on exit, filled in with
                   buffer of default headers plus pszOurExtraHeaders.

    NOTES:      The point of having this in a global helper function is
                so we don't have to duplicate this code in multiple
                implementations of IBindStatusCallback.

                The caller must free *ppwzCombinedHeaders by passing
                to URLMON, or calling OleFree

********************************************************************/
HRESULT BuildAdditionalHeaders(LPCTSTR pszOurExtraHeaders,LPCWSTR * ppwzCombinedHeadersOut)
{

    TCHAR   szLanguage[80];   // what limit on language?
    DWORD   dwLanguage = ARRAYSIZE(szLanguage);
    static const TCHAR hdr_language[] = HDR_LANGUAGE_CRLF;
    TCHAR szHeader[ARRAYSIZE(hdr_language) + ARRAYSIZE(szLanguage)]; // NOTE format string length > wnsprintf length
    int cchHeaders = 0;
    int cchAddedHeaders = 1;  // implied '\0'
    HRESULT hres = NOERROR;

    if (!ppwzCombinedHeadersOut)
        return E_FAIL;

    *ppwzCombinedHeadersOut = NULL;

    // If there is no language in the registry, *WE DO NOT SEND THIS HEADER*

    // S_OK means szLanguage filled in and returned
    // S_FALSE means call succeeded, but there was no language set
    // E_* is an error
    // We treat S_FALSE and E_* the same, no language header sent.
    if (GetAcceptLanguages(szLanguage, &dwLanguage) == S_OK)
    {
        StringCchPrintf(szHeader, ARRAYSIZE(szHeader), hdr_language, szLanguage);
        cchHeaders = lstrlen(szHeader) + 1;
    }

    if (pszOurExtraHeaders)
    {
        cchAddedHeaders = lstrlen(pszOurExtraHeaders) + 1;
    }

    // If we have headers we added or were sent in, we need to Wide 'em and
    // give 'em back
    if (cchAddedHeaders > 1 || cchHeaders > 0)
    {
        WCHAR *pwzHeadersForUrlmon = (WCHAR *)CoTaskMemAlloc(sizeof(WCHAR) * (cchHeaders  + cchAddedHeaders - 1));
        if (pwzHeadersForUrlmon)
        {
            if (cchHeaders)
            {
                StrCpyN(pwzHeadersForUrlmon, szHeader, cchHeaders);
            }
            if (pszOurExtraHeaders)
            {
                if (cchHeaders)
                {
                    StrCpyN(pwzHeadersForUrlmon + cchHeaders - 1,
                            pszOurExtraHeaders, cchAddedHeaders);
                }
                else
                {
                    StrCpyN(pwzHeadersForUrlmon, pszOurExtraHeaders, cchAddedHeaders - 1);
                }
            }
            if (cchHeaders || pszOurExtraHeaders)
                *ppwzCombinedHeadersOut = pwzHeadersForUrlmon;
        }
        else
            hres = E_OUTOFMEMORY;
    }
    else
        hres = pszOurExtraHeaders == NULL ? S_OK : E_FAIL;

    return hres;
}

/*******************************************************************

    NAME:       GetHeadersAndPostData

    SYNOPSIS:   Gets HTTP headers and post data from an IBindStatusCallback

    ENTRY:      IBindStatusCallback - object to ask for headers and post data
                ppszHeaders - on exit, filled in with pointer to headers,
                    or NULL if none
                pstgPostData - pointer to a STGMEDIUM to be filled in with post
                    data, if any.


    NOTES:      The caller is responsible for:
                    - calling LocalFree on *ppszHeaders when done with them
                    - calling ReleaseStgMedium on pstgPostData when done
                      with it

********************************************************************/
HRESULT GetHeadersAndPostData(IBindStatusCallback * pBindStatusCallback,
    LPTSTR * ppszHeaders, STGMEDIUM * pstgPostData, DWORD * pdwPostData, BOOL* pfIsPost)
{
    HRESULT hr = S_OK;

    ASSERT(pBindStatusCallback);
    ASSERT(ppszHeaders);
    ASSERT(pstgPostData);
    ASSERT(pdwPostData);

    // clear the out parameters
    *ppszHeaders = NULL;

    DWORD grfBINDF;
    IHttpNegotiate *pinegotiate;
    BINDINFO binfo;
    binfo.cbSize = sizeof(binfo);
    ZeroMemory(pstgPostData, sizeof(*pstgPostData));
    *pdwPostData = 0;

    hr=pBindStatusCallback->GetBindInfo(&grfBINDF, &binfo);

    if (SUCCEEDED(hr)) {
        // copy STGMEDIUM with post data to caller
        *pstgPostData = binfo.stgmedData;
        *pdwPostData = binfo.cbstgmedData;

        // clear these so ReleaseBindInfo won't wack it since we are giving it to the caller
        ZeroMemory(&binfo.stgmedData, sizeof(STGMEDIUM));
        binfo.cbstgmedData = 0;

        if (pfIsPost)
        {
            if (*pdwPostData)
                *pfIsPost = TRUE;
            else
                *pfIsPost = FALSE;
        }
 
        hr = pBindStatusCallback->QueryInterface(IID_IHttpNegotiate, (LPVOID *)&pinegotiate);
        if (SUCCEEDED(hr))
        {
            WCHAR *pwzAdditionalHeaders = NULL;
            WCHAR wzNull[1];

            wzNull[0] = 0;
            hr=pinegotiate->BeginningTransaction(wzNull, wzNull, 0, &pwzAdditionalHeaders);
            if (SUCCEEDED(hr) && pwzAdditionalHeaders)
            {
                DWORD cchHeaders;

                cchHeaders = lstrlen(pwzAdditionalHeaders) + 1;

                //  they should *NEVER* be specifying more than a few hundred
                //  bytes or they're going to fail with a number of HTTP servers!

                LPTSTR pszHeaders = (TCHAR *)LocalAlloc(LPTR, cchHeaders*sizeof(TCHAR));
                if (pszHeaders)
                {
                    LPTSTR pszNext;
                    LPTSTR pszLine;
                    LPTSTR pszLast;

                    StrCpyN(pszHeaders, pwzAdditionalHeaders, cchHeaders);
                    pszLine = pszHeaders;
                    pszLast = pszHeaders + lstrlen(pszHeaders);
                    while (pszLine < pszLast)
                    {
                        pszNext = StrStrI(pszLine, CRLF);
                        if (pszNext == NULL)
                        {
                            // All Headers must be terminated in CRLF!
                            pszLine[0] = '\0';
                            break;
                        }
                        pszNext += 2;
                        if (!StrCmpNI(pszLine,HDR_LANGUAGE,16))
                        {
                            MoveMemory(pszLine, pszNext, ((pszLast - pszNext) + 1)*sizeof(TCHAR));
                            break;
                        }
                        pszLine = pszNext;
                    }
                    // Don't include empty headers
                    if (pszHeaders[0] == '\0')
                    {
                        LocalFree(pszHeaders);
                        pszHeaders = NULL;
                    }
                }
                OleFree(pwzAdditionalHeaders);
                *ppszHeaders = pszHeaders;
            }
            pinegotiate->Release();
        }

        ReleaseBindInfo(&binfo);
    }

    return hr;
}

/*******************************************************************

    NAME:       GetTopLevelBindStatusCallback

    ENTRY:      psp - IServiceProvider of ShellBrowser container to query
                ppBindStatusCallback - if successful, filled in with
                   an IBindStatusCallback on exit

    SYNOPSIS:   Gets the IBindStatusCallback associated with this top
                level browser.  This works from within nested frames.

********************************************************************/
HRESULT GetTopLevelBindStatusCallback(IServiceProvider *psp, IBindStatusCallback **ppBindStatusCallback)
{
    IHlinkFrame *phf;
    HRESULT hr = psp->QueryService(SID_SHlinkFrame, IID_PPV_ARG(IHlinkFrame, &phf));
    if (SUCCEEDED(hr)) 
    {
        hr = IUnknown_QueryService(phf, IID_IHlinkFrame, IID_PPV_ARG(IBindStatusCallback, ppBindStatusCallback));
        phf->Release();
    }

    return hr;
}

/*******************************************************************

    NAME:       GetTopLevelPendingBindStatusCallback

    ENTRY:      psp - IServiceProvider of ShellBrowser container to query
                ppBindStatusCallback - if successful, filled in with
                   an IBindStatusCallback on exit

    SYNOPSIS:   Gets the IBindStatusCallback associated with this top
                level browser.  This works from within nested frames.

********************************************************************/
HRESULT GetTopLevelPendingBindStatusCallback(IServiceProvider *psp, IBindStatusCallback **ppBindStatusCallback)
{
    IHlinkFrame *phf;
    HRESULT hr = psp->QueryService(SID_SHlinkFrame, IID_PPV_ARG(IHlinkFrame, &phf));
    if (SUCCEEDED(hr)) 
    {
        hr = IUnknown_QueryService(phf, SID_PendingBindStatusCallback, IID_PPV_ARG(IBindStatusCallback, ppBindStatusCallback));
        phf->Release();
    }

    return hr;
}

// Global helper function to create a CStubBindStatusCallback
HRESULT CStubBindStatusCallback_Create(LPCWSTR pwzHeaders, LPCBYTE pPostData,
    DWORD cbPostData, VARIANT_BOOL bFrameIsOffline, VARIANT_BOOL bFrameIsSilent, BOOL bHyperlink, 
    DWORD grBindFlags,
    CStubBindStatusCallback ** ppBindStatusCallback)
{
    ASSERT(ppBindStatusCallback);

    *ppBindStatusCallback = new CStubBindStatusCallback(pwzHeaders,pPostData,
        cbPostData, bFrameIsOffline, bFrameIsSilent, bHyperlink, grBindFlags);

    return (*ppBindStatusCallback ? S_OK : E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\cachecln.cpp ===
// Author:  Pritvinath Obla
// Date:    10 July 1997

#include "priv.h"
#include "util.h"
#include <emptyvc.h>
#include <mluisupp.h>   // for MLLoadString
#include "resource.h"   // for the string ID's

class CInternetCacheCleaner : public IEmptyVolumeCache2
{
private:
    //
    // Data
    //
    ULONG                   m_cRef;             // reference count
    DWORDLONG               m_dwlSpaceUsed;
    TCHAR                   m_szCacheDir[MAX_PATH + 1];

    //
    // Functions
    //
    HRESULT                 GetInternetCacheSize(
                                DWORDLONG                   *pdwlSpaceUsed,
                                IEmptyVolumeCacheCallBack   *picb
                                );

    HRESULT                 DelInternetCacheFiles(
                                DWORD                       dwPercentToFree,
                                IEmptyVolumeCacheCallBack   *picb
                                );

public:
    //
    // Constructor and Destructor
    //
    CInternetCacheCleaner(void);
    ~CInternetCacheCleaner(void);

    //
    // IUnknown interface members
    //
    STDMETHODIMP            QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);

    //
    // IEmptyVolumeCache interface methods
    //
    STDMETHODIMP            Initialize(
                                HKEY    hkRegKey,
                                LPCWSTR pcwszVolume,
                                LPWSTR  *ppwszDisplayName,
                                LPWSTR  *ppwszDescription,
                                DWORD   *pdwFlags
                                );

    STDMETHODIMP            GetSpaceUsed(
                                DWORDLONG                   *pdwlSpaceUsed,
                                IEmptyVolumeCacheCallBack   *picb
                                );

    STDMETHODIMP            Purge(
                                DWORDLONG                   dwlSpaceToFree,
                                IEmptyVolumeCacheCallBack   *picb
                                );

    STDMETHODIMP            ShowProperties(
                                HWND    hwnd
                                );

    STDMETHODIMP            Deactivate(
                                DWORD   *pdwFlags
                                );

    //
    // IEmptyVolumeCache2 interface methods
    //
    STDMETHODIMP            InitializeEx(
                                HKEY hkRegKey,
                                LPCWSTR pcwszVolume,
                                LPCWSTR pcwszKeyName,
                                LPWSTR *ppwszDisplayName,
                                LPWSTR *ppwszDescription,
                                LPWSTR *ppwszBtnText,
                                DWORD *pdwFlags
                                );
};

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner_CreateInstance
//
// Purpose:     CreateInstance function for IClassFactory
//------------------------------------------------------------------------------
//
STDAPI CInternetCacheCleaner_CreateInstance(
    IUnknown        *punkOuter,
    IUnknown        **ppunk,
    LPCOBJECTINFO   poi
    )
{
    *ppunk = NULL;

    CInternetCacheCleaner *lpICC = new CInternetCacheCleaner();

    if (lpICC == NULL)
        return E_OUTOFMEMORY;

    *ppunk = SAFECAST(lpICC, IEmptyVolumeCache *);

    return S_OK;
}

CInternetCacheCleaner::CInternetCacheCleaner() : m_cRef(1)
{
    DllAddRef();

    m_dwlSpaceUsed = 0;
    *m_szCacheDir = '\0';
}

CInternetCacheCleaner::~CInternetCacheCleaner()
{
    DllRelease();
}

STDMETHODIMP CInternetCacheCleaner::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (IsEqualIID(riid, IID_IUnknown)  ||
        IsEqualIID(riid, IID_IEmptyVolumeCache2) ||
        IsEqualIID(riid, IID_IEmptyVolumeCache))
    {
        *ppv = SAFECAST(this, IEmptyVolumeCache2 *);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CInternetCacheCleaner::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CInternetCacheCleaner::Release()
{
    //  
    // Decrement and check
    //
    if (--m_cRef)
        return m_cRef;

    //
    // No references left to this object
    //
    delete this;

    return 0;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::InitializeEx
//
// Purpose:     Initializes the Internet Cache Cleaner and returns the 
//                  specified IEmptyVolumeCache flags to the cache manager
//------------------------------------------------------------------------------
//

STDMETHODIMP CInternetCacheCleaner::InitializeEx(
    HKEY hkRegKey,
    LPCWSTR pcwszVolume,
    LPCWSTR pcwszKeyName,
    LPWSTR *ppwszDisplayName,
    LPWSTR *ppwszDescription,
    LPWSTR *ppwszBtnText,
    DWORD *pdwFlags
    )
{
    *ppwszBtnText = (LPWSTR)CoTaskMemAlloc( 128*sizeof(WCHAR) );
    if ( !*ppwszBtnText )
        return E_OUTOFMEMORY;

    MLLoadString( IDS_CACHECLN_BTNTEXT, *ppwszBtnText, 128 );

    return Initialize(hkRegKey, pcwszVolume, ppwszDisplayName, ppwszDescription, pdwFlags );
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::Initialize
//
// Purpose:     Initializes the Internet Cache Cleaner and returns the 
//                  specified IEmptyVolumeCache flags to the cache manager
//------------------------------------------------------------------------------
//
STDMETHODIMP CInternetCacheCleaner::Initialize(
    HKEY    hkRegKey,
    LPCWSTR pcwszVolume,
    LPWSTR  *ppwszDisplayName,
    LPWSTR  *ppwszDescription,
    DWORD   *pdwFlags
    )
{
#ifdef UNICODE
    // We can't use the registry values on NT because they can't be multi-local localized.  As
    // a result we must set the out pointers with values read from resources.
    *ppwszDisplayName = (LPWSTR)CoTaskMemAlloc( 512*sizeof(WCHAR) );
    if ( !*ppwszDisplayName )
        return E_OUTOFMEMORY;

    *ppwszDescription = (LPWSTR)CoTaskMemAlloc( 512*sizeof(WCHAR) );
    if ( !*ppwszDescription )
    {
        CoTaskMemFree(*ppwszDisplayName);
        return E_OUTOFMEMORY;
    }

    MLLoadString( IDS_CACHECLN_DISPLAY, *ppwszDisplayName, 512 );
    MLLoadString( IDS_CACHECLN_DESCRIPTION, *ppwszDescription, 512 );
#else
    //
    // Let cleanmgr read the default DisplayName and Description
    //      from hkRegKey and use them
    //
    *ppwszDisplayName = NULL;
    *ppwszDescription = NULL;
#endif

    *pdwFlags = 0;              // initialize the [out] parameter

    //
    // Check if the Internet Cache Folder is in pcwzVolume
    //
    GetCacheLocation(m_szCacheDir, ARRAYSIZE(m_szCacheDir));
    if (StrCmpNI(pcwszVolume, m_szCacheDir, 3))
    {
        //
        // Different drives; return S_FALSE so that this cleaner
        //      doesn't show up in cleanmgr's UI
        //
        return S_FALSE;
    }

    //
    // Enable this cleaner by default both in cleanup and tuneup modes
    //
    *pdwFlags = EVCF_ENABLEBYDEFAULT |
                EVCF_ENABLEBYDEFAULT_AUTO |
                EVCF_HASSETTINGS;

#if 0
    /***
    // Since GetInternetCacheSize returns only an approx. size,
    //      we would never get a value of 0 even if the cache is empty
    // Should enable this check once wininet.dll exports a GetCacheSize API

    //
    // Check if there is any disk space to free at all
    // If not, return S_FALSE so that this cleaner doesn't show up in
    //      cleanmgr's UI
    //
    DWORDLONG dwlSpaceUsed;
    if (SUCCEEDED(GetInternetCacheSize(&dwlSpaceUsed, NULL))  &&
        dwlSpaceUsed == 0)
    {
        return S_FALSE;
    }
    ***/
#endif

    return S_OK;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::GetSpaceUsed
//
// Purpose:     Return the total amount of space this internet cache cleaner
//                  can free up
//------------------------------------------------------------------------------
//
STDMETHODIMP CInternetCacheCleaner::GetSpaceUsed(
    DWORDLONG                   *pdwlSpaceUsed,
    IEmptyVolumeCacheCallBack   *picb
    )
{
    HRESULT hr;

    hr = GetInternetCacheSize(pdwlSpaceUsed, picb);
    m_dwlSpaceUsed = *pdwlSpaceUsed;

    //
    // Send the last notification to the cleanup manager
    //
    if (picb != NULL)
    {
        picb->ScanProgress(*pdwlSpaceUsed, EVCCBF_LASTNOTIFICATION, NULL);
    }

    if (hr != E_ABORT)
    {
        if (FAILED(hr))
        {
            //
            // *pdwlSpaceUsed is only a guesstimate; so return S_FALSE
            //
            hr = S_FALSE;
        }
        else
        {
            //
            // Return S_OK once wininet exports a GetCacheSize API;
            //      till then use FindFirstUrlCacheEntry/FindNextUrlCacheEntry
            //      to get approx. size of the cache
            //
            hr = S_FALSE;
        }
    }

    return hr;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::Purge
//
// Purpose:     Delete the internet cache files
//------------------------------------------------------------------------------
//
STDMETHODIMP CInternetCacheCleaner::Purge(
    DWORDLONG                   dwlSpaceToFree,
    IEmptyVolumeCacheCallBack   *picb
    )
{
    HRESULT hr;
    DWORD dwPercentToFree = 100;    // Optimize the most common scenario:
                                    // In most cases, dwlSpaceToFree will be
                                    //      equal to m_dwlSpaceUsed

    if (dwlSpaceToFree != m_dwlSpaceUsed)
    {
        dwPercentToFree = m_dwlSpaceUsed ?
                                DWORD((dwlSpaceToFree * 100) / m_dwlSpaceUsed) :
                                100;
    }

    hr = DelInternetCacheFiles(dwPercentToFree, picb);

    //
    // Send the last notification to the cleanup manager
    //
    if (picb != NULL)
    {
        picb->PurgeProgress(dwlSpaceToFree, 0,
                                EVCCBF_LASTNOTIFICATION, NULL);
    }

    if (hr != E_ABORT)
    {
        hr = S_OK;          // cannot return anything else
    }

    return hr;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::ShowProperties
//
// Purpose:     Launch the cache viewer to list the internet cache files
//------------------------------------------------------------------------------
//
STDMETHODIMP CInternetCacheCleaner::ShowProperties(
    HWND    hwnd
    )
{
    DWORD dwAttrib;

    if (*m_szCacheDir == '\0')      // Internet cache dir is not yet initialized
    {
        GetCacheLocation(m_szCacheDir, ARRAYSIZE(m_szCacheDir));
    }

    dwAttrib = GetFileAttributes(m_szCacheDir);
    if (dwAttrib != 0xffffffff  &&  (dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
    {
        WCHAR szCache[MAX_PATH];
        StringCchCopy(szCache, ARRAYSIZE(szCache), m_szCacheDir);
        PathQuoteSpaces(szCache);

        SHELLEXECUTEINFO sei;

        //
        // Launch the cache viewer
        //
        sei.cbSize          = sizeof(SHELLEXECUTEINFO);
        sei.hwnd            = hwnd;
        sei.lpVerb          = NULL;
        sei.lpFile          = szCache;
        sei.lpParameters    = NULL;
        sei.lpDirectory     = NULL;
        sei.nShow           = SW_SHOWNORMAL;
        sei.fMask           = 0;

        ShellExecuteEx(&sei);
    }

    //
    // The user may or may not delete files directly from the cachevu folder
    // Since there is no way of knowing this, don't return S_OK which would
    //      trigger cleanmgr to call GetSpaceUsed again
    //
    return S_OK;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::Deactivate
//
// Purpose:     Deactivates the Internet Cache Cleaner...Not implemented
//------------------------------------------------------------------------------
//
STDMETHODIMP CInternetCacheCleaner::Deactivate(
    DWORD   *pdwFlags
    )
{
    *pdwFlags = 0;

    return S_OK;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::GetInternetCacheSize
//
// Purpose:     Find the size of the internet cache by calling into wininet APIs
//
// Notes:       The current implementation is temporary; once wininet exports
//                  a real API for getting the cache size, use that
//------------------------------------------------------------------------------
//
HRESULT CInternetCacheCleaner::GetInternetCacheSize(
    DWORDLONG                   *pdwlSpaceUsed,
    IEmptyVolumeCacheCallBack   *picb           // not used
    )
{
    HRESULT hr = S_OK;
    DWORD dwLastErr;
    LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo;
    HANDLE hCacheEntryInfo;
    DWORD dwCacheEntryInfoSize;

    *pdwlSpaceUsed = 0;

    if ((lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFOA) LocalAlloc(LPTR,
                                        MAX_CACHE_ENTRY_INFO_SIZE)) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    dwCacheEntryInfoSize = MAX_CACHE_ENTRY_INFO_SIZE;
    if ((hCacheEntryInfo = FindFirstUrlCacheEntryA(NULL, lpCacheEntryInfo,
                                            &dwCacheEntryInfoSize)) == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (SUCCEEDED(hr))
    {
        do
        {
            if (!(lpCacheEntryInfo->CacheEntryType & (STICKY_CACHE_ENTRY | COOKIE_CACHE_ENTRY)))
            {
                ULARGE_INTEGER uliFileSize;

                uliFileSize.HighPart = lpCacheEntryInfo->dwSizeHigh;
                uliFileSize.LowPart = lpCacheEntryInfo->dwSizeLow;

                *pdwlSpaceUsed += QUAD_PART(uliFileSize);
            }
            
            dwCacheEntryInfoSize = MAX_CACHE_ENTRY_INFO_SIZE;

        } while (FindNextUrlCacheEntryA(hCacheEntryInfo, lpCacheEntryInfo,
                                                    &dwCacheEntryInfoSize));

        if ((dwLastErr = GetLastError()) != ERROR_NO_MORE_ITEMS)
        {
            hr = HRESULT_FROM_WIN32(dwLastErr);
        }
    }

    if (lpCacheEntryInfo != NULL)
    {
        LocalFree(lpCacheEntryInfo);
        lpCacheEntryInfo = NULL;
    }

    return hr;
}

//
//------------------------------------------------------------------------------
// CInternetCacheCleaner::DelInternetCacheFiles
//
// Purpose:     Delete the internet cache files
//------------------------------------------------------------------------------
//
HRESULT CInternetCacheCleaner::DelInternetCacheFiles(
    DWORD                       dwPercentToFree,
    IEmptyVolumeCacheCallBack   *picb           // not used
    )
{
    HRESULT hr = S_OK;

    if (*m_szCacheDir == '\0')      // Internet cache dir is not yet initialized
    {
        hr = GetCacheLocation(m_szCacheDir, ARRAYSIZE(m_szCacheDir));
    }

    if (SUCCEEDED(hr))
    {
        FreeUrlCacheSpace(m_szCacheDir, dwPercentToFree, STICKY_CACHE_ENTRY);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\cabsh.h ===
#ifndef _CABSH_H
#define _CABSH_H

// Define structure to be used at head of state stream that is
// not dependent on 16 or 32 bits...
typedef struct _CABSHOLD       // Cabinet Stream header
{
    DWORD   dwSize;       // Offset to where the View streamed additional info

    // First stuff from the window placement
    DWORD  flags;
    DWORD  showCmd;
    POINTL ptMinPosition;
    POINTL ptMaxPosition;
    RECTL  rcNormalPosition;

    // Stuff from Folder Settings;
    DWORD   ViewMode;       // View mode (FOLDERVIEWMODE values)
    DWORD   fFlags;         // View options (FOLDERFLAGS bits)
    DWORD   TreeSplit;      // Position of split in pixels

    // Hot Key
    DWORD   dwHotkey;        // Hotkey

    WINVIEW wv;
} CABSHOLD;

typedef struct _CABSH       // Cabinet Stream header
{
    DWORD   dwSize;       // Offset to where the View streamed additional info

    // First stuff from the window placement
    DWORD  flags;
    DWORD  showCmd;
    POINTL ptMinPosition;
    POINTL ptMaxPosition;
    RECTL  rcNormalPosition;

    // Stuff from Folder Settings;
    DWORD   ViewMode;       // View mode (FOLDERVIEWMODE values)
    DWORD   fFlags;         // View options (FOLDERFLAGS bits)
    DWORD   TreeSplit;      // Position of split in pixels

    // Hot Key
    DWORD   dwHotkey;        // Hotkey

    WINVIEW wv;

    DWORD   fMask;          // Flags specifying which fields are valid
    SHELLVIEWID vid;        // extended view id
    DWORD   dwVersionId;    // CABSH_VER below
    DWORD   dwRevCount;     // rev count of default settings when the folder was saved to the stream
} CABSH;

#define CABSHM_VIEWID  0x00000001
#define CABSHM_VERSION 0x00000002
#define CABSHM_REVCOUNT 0x00000004

#define CABSH_VER 1 // change this version whenever we want to change defaults
#define CABSH_WIN95_VER 0 // this was the pre-ie4 version number

#endif  // _CABSH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\channel.h ===
#ifndef _CHANNEL_H
#define _CHANNEL_H


void Channel_UpdateQlinks();

HRESULT Channel_GetFolder(LPTSTR pszPath, int cchPath);
LPITEMIDLIST Channel_GetFolderPidl();
HRESULT ChannelBand_CreateInstance(IUnknown** ppunk);
HRESULT Channels_OpenBrowser(IWebBrowser2 **ppwb, BOOL fInPlace);

BOOL GetFirstUrl(TCHAR szURL[], DWORD cb);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\cwndproc.cpp ===
#include "priv.h"
#include "..\inc\cwndproc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\debug.c ===
//
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shdocvw"
#define SZ_MODULE           "SHDOCVW"
#define DECLARE_DEBUG
#include <debug.h>

// Include the standard helper functions to dump common ADTs

#undef lstrcpy
#undef wsprintf

#undef  StrCpyW
#define lstrcpy    StrCpyW
#undef  wsprintfW
#define wsprintf   wsprintfW

#include "..\inc\dump.c"

#undef  lstrcpy
#define lstrcpy     Do_not_use_lstrcpy_use_StrCpyN
#undef  wsprintf
#define wsprintf    Do_not_use_wsprintf_use_wnsprintf

#define StrCpyW     Do_not_use_StrCpyW_use_StrCpyNW
#define wsprintfW   Do_not_use_wsprintfW_use_wnsprintfW



#ifdef DEBUG

void DumpMsg(LPCTSTR pszLabel, MSG * pmsg)
{
    ASSERT(IS_VALID_STRING_PTR(pszLabel, -1));
    ASSERT(pmsg);

    switch (pmsg->message)
    {
    case WM_LBUTTONDOWN:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_LBUTTONDOWN hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        break;

    case WM_LBUTTONUP:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_LBUTTONUP   hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        break;

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYUP:
        BLOCK
        {
            LPTSTR pcsz = TEXT("(unknown)");
            switch (pmsg->message)
            {
                STRING_CASE(WM_KEYDOWN);
                STRING_CASE(WM_SYSKEYDOWN);
                STRING_CASE(WM_KEYUP);
                STRING_CASE(WM_SYSKEYUP);
            }

            TraceMsg(TF_ALWAYS, "%s: msg = %s     hwnd = %#08lx",
                     pszLabel, pcsz, pmsg->hwnd);
            TraceMsg(TF_ALWAYS, "            vk = %#04lx  count = %u  flags = %#04lx",
                     pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        }
        break;

    case WM_CHAR:
    case WM_SYSCHAR:
        BLOCK
        {
            LPTSTR pcsz = TEXT("(unknown)");
            switch (pmsg->message)
            {
                STRING_CASE(WM_CHAR);
                STRING_CASE(WM_SYSCHAR);
            }

            TraceMsg(TF_ALWAYS, "%s: msg = %s     hwnd = %#08lx",
                     pszLabel, pcsz, pmsg->hwnd);
            TraceMsg(TF_ALWAYS, "            char = '%c'  count = %u  flags = %#04lx",
                     pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        }
        break;

    case WM_MOUSEMOVE:
#if 0
        TraceMsg(TF_ALWAYS, "%s: msg = WM_MOUSEMOVE hwnd = %#08lx  x=%d  y=%d",
                 pszLabel, pmsg->hwnd, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
#endif
        break;

    case WM_TIMER:
#if 0
        TraceMsg(TF_ALWAYS, "%s: msg = WM_TIMER       hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              id = %#08lx",
                 pmsg->wParam);
#endif
        break;

    case WM_MENUSELECT:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_MENUSELECT  hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              uItem = %#04lx  flags = %#04lx  hmenu = %#08lx",
                 GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_FLAGS(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam));
        break;

    default:
        if (WM_USER > pmsg->message)
        {
            TraceMsg(TF_ALWAYS, "%s: msg = %#04lx    hwnd=%#04lx wP=%#08lx lP=%#08lx",
                     pszLabel, pmsg->message, pmsg->hwnd, pmsg->wParam, pmsg->lParam);
        }
        break;
    }
}    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\convert.h ===
/************************************************************\
	FILE: convert.h

	DATE: Apr 1, 1996

	AUTHOR: Bryan Starbuck (bryanst)

	DESCRIPTION:
		This file will handle the logic to convert Netscape
	bookmarks to Microsoft Internet Explorer favorites.  This 
	will happen by finding the location of the Netscape bookmarks
	file and the Microsoft Internet Explorer favorites directory
	from the registry.  Then it will parse the bookmarks file to
	extract the URLs, which will finally be added to the favorites
	directory.

  NOTES:
	This was developed with Netscape 2.0 and IE 2.0.  Future notes
	will be made about compatibility with different versions of
	these browsers.
	
\************************************************************/

#ifndef _CONVERT_H
#define _CONVERT_H



// ItemType is going to be the type of entry found in the bookmarks
// file.
typedef enum MYENTRYTYPE
{
    ET_OPEN_DIR     = 531,  // New level in heirarchy
    ET_CLOSE_DIR,           // Close level in heirarchy
    ET_BOOKMARK,            // Bookmark entry.
    ET_NONE,                // End of File
    ET_ERROR                // Bail, we encountered an error
} MyEntryType;


//////////////////////////////////////////////////////////////////
//	Exprted Functions
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//  Internal Functions
//////////////////////////////////////////////////////////////////
BOOL    ImportNetscapeProxy(void);		// Import Netscape Proxy Setting
BOOL    UpdateHomePage(void);			// Upgrade IE v1.0 Home URL to v3.0
BOOL    ImportBookmarks(HINSTANCE hInstWithStr);			//  Import Netscape Bookmarks to IE Favorites

BOOL    RegStrValueEmpty(HKEY hTheKey, char * szPath, char * szKey);
BOOL    GetNSProxyValue(char * szProxyValue, DWORD * pdwSize);

BOOL        VerifyBookmarksFile(HANDLE hFile);
BOOL        ConvertBookmarks(char * szFavoritesDir, HANDLE hFile, HINSTANCE hInstWithStr);
MyEntryType   NextFileEntry(char ** ppStr, char ** ppToken);
BOOL        GetData(char ** ppData, HANDLE hFile);
void        RemoveInvalidFileNameChars(char * pBuf);
BOOL        CreateDir(char *pDirName);
BOOL        CloseDir(void);
BOOL        CreateBookmark(char *pBookmarkName);
BOOL        GetNavBkMkDir( LPSTR lpszDir, int isize );


#endif // _CONVERT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\chanoc.cpp ===
//
// This Channel OC code was copied from browseui.  Once it is reenabled in
// browseui it can be removed from shdocvw.
//

#include "priv.h"
#include "cobjsafe.h"


STDAPI ChannelOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
HRESULT IUnknown_SetBandInfoSFB(IUnknown *punkBand, BANDINFOSFB *pbi);
IDeskBand * ChannelBand_Create(LPCITEMIDLIST pidlDefault);
//LPITEMIDLIST Channel_GetFolderPidl();
void Channels_SetBandInfoSFB(IUnknown* punkBand);

//////////////////////////////////////////////////
//
// ChannelOC
//
// This is an OC that wraps the above band for
// inclusion in the Active Desktop.
//
// TODO:
//  - listen to ISFBand for resizes and request them
//    from our container
//
// Do we need to register as a drop target?

#undef  SUPERCLASS
#define SUPERCLASS CShellEmbedding
#undef  THISCLASS
#define THISCLASS ChannelOC

class ChannelOC : public SUPERCLASS
    , public IServiceProvider
    , public IPersistPropertyBag
    , public CObjectSafety
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj) { return SUPERCLASS::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return SUPERCLASS::AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void) { return SUPERCLASS::Release(); }

    // *** CAggregatedUnknown ***
    virtual HRESULT v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IServiceProvider ***
    virtual STDMETHODIMP QueryService(REFGUID guidService,
        REFIID riid, void **ppvObj);

    // *** IPersistPropertyBag ***
    virtual STDMETHODIMP Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog);
    virtual STDMETHODIMP Save(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    virtual STDMETHODIMP InitNew();
    virtual STDMETHODIMP GetClassID(CLSID *pClassID) { return SUPERCLASS::GetClassID(pClassID); };

    // *** IOleInPlaceObject ***
    virtual STDMETHODIMP SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect);

protected:
    ChannelOC(IUnknown* punkOuter, LPCOBJECTINFO poi);
    ~ChannelOC();
    friend HRESULT ChannelOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

    virtual LRESULT v_WndProc(HWND, UINT, WPARAM, LPARAM);

    LPITEMIDLIST _GetInitialPidl(void);
    virtual void _OnInPlaceActivate(void);      // called when we actually go in-place-active
    virtual void _OnInPlaceDeactivate(void);    // called when we actually deactivate

    IDeskBand*          _pBand;
    IWinEventHandler*   _pweh;
    COLORREF            _crBkgndOC;
    COLORREF            _crBorder;

    // for GetBandInfo, not currently used
    DESKBANDINFO _dbi;
};

ChannelOC::ChannelOC(IUnknown* punkOuter, LPCOBJECTINFO poi) : 
    CShellEmbedding(punkOuter, poi, NULL)
{
    TraceMsg(TF_SHDLIFE, "ctor ChannelOC %x", this);
    _crBkgndOC = CLR_DEFAULT;
    _crBorder = CLR_DEFAULT;
}


ChannelOC::~ChannelOC() 
{
    TraceMsg(TF_SHDLIFE, "dtor ChannelOC %x", this);
}

HRESULT ChannelOC::v_InternalQueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(THISCLASS, IServiceProvider),
        QITABENT(THISCLASS, IPersistPropertyBag),
        QITABENT(THISCLASS, IObjectSafety),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
        hres = SUPERCLASS::v_InternalQueryInterface(riid, ppvObj);

    return hres;
}

HRESULT ChannelOC::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    return IUnknown_QueryService(_pcli, guidService, riid, ppvObj);
}

//***   ChannelOC::IPersistPropertyBag::* {
//
HRESULT THISCLASS::Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog)
{
    ASSERT(_crBkgndOC == CLR_DEFAULT);  // paranoia
    _crBkgndOC = PropBag_ReadInt4(pPropBag, L"BGColor", CLR_DEFAULT);
    TraceMsg(TF_WARNING, "coc.l: BGColor=%x", _crBkgndOC);
    
    _crBorder = PropBag_ReadInt4(pPropBag, L"BorderColor", CLR_DEFAULT);
    
    return S_OK;
}

HRESULT THISCLASS::Save(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    ASSERT(0);
    return E_NOTIMPL;
}

HRESULT THISCLASS::InitNew()
{
    ASSERT(_crBkgndOC == CLR_DEFAULT);
    ASSERT(_crBorder == CLR_DEFAULT);
    return E_NOTIMPL;
}

// }

LRESULT ChannelOC::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    switch(uMsg)
    {
    case WM_CONTEXTMENU:
        return 1;

    case WM_WINDOWPOSCHANGED:
        if (_hwndChild)
        {
            LPWINDOWPOS lpwp = (LPWINDOWPOS)lParam;
    
            if (!(lpwp->flags & SWP_NOSIZE))
            {
                SetWindowPos(_hwndChild, NULL,
                    0,0,
                    lpwp->cx, lpwp->cy,
                    SWP_NOZORDER|SWP_NOMOVE|SWP_NOACTIVATE|
                    (lpwp->flags&(SWP_NOREDRAW|SWP_NOCOPYBITS)));
            }
    
        }
        return 0;

    case WM_ERASEBKGND:
        if ( _crBorder == CLR_DEFAULT )
        {
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
        else
        {
            HDC hdc = (HDC) wParam;
            RECT rcClient;
            GetClientRect( hwnd, &rcClient );
            COLORREF crSave = SetBkColor(hdc, _crBorder);
            
            ExtTextOut(hdc,0,0,ETO_OPAQUE,&rcClient,NULL,0,NULL);
            SetBkColor(hdc, crSave);
        }

    case WM_COMMAND:
    case WM_NOTIFY:
        if (_pweh)
        {
            LRESULT lres;
            if (SUCCEEDED(_pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, &lres)))
                return lres;
        }
        // fall through

    default:
        return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
    }
}


LPITEMIDLIST ChannelOC::_GetInitialPidl()
{
    LPITEMIDLIST pidl = NULL;

    // Figure out what directory this ChannelOC is looking at.
    // If we're looking at a specific channel category, use it,
    // otherwise use the top-level Channels folder.
    //
    if (EVAL(_pcli))
    {
        IOleContainer *pContainer;

        if (SUCCEEDED(_pcli->GetContainer(&pContainer)))
        {
            IHTMLDocument2 *pDoc;

            if (SUCCEEDED(pContainer->QueryInterface(IID_IHTMLDocument2, (LPVOID*)&pDoc)))
            {
                IHTMLLocation *pLocation;

                if (SUCCEEDED(pDoc->get_location(&pLocation)))
                {
                    BSTR bstrURL;

                    if (SUCCEEDED(pLocation->get_href(&bstrURL)) && bstrURL)
                    {
                        TCHAR szPath[MAX_PATH];
                        DWORD cchT = ARRAYSIZE(szPath);
                        if (SUCCEEDED(PathCreateFromUrl(bstrURL, szPath, &cchT, 0)))
                        {
                            PathRemoveFileSpec(szPath);

                            // if we're not under the channels folder, then
                            // ignore this location
                            //
                            if (SUCCEEDED(IECreateFromPath(szPath, &pidl)))
                            {
                                LPITEMIDLIST pidlChannels = Channel_GetFolderPidl();

                                if (!pidlChannels || !ILIsParent(pidlChannels, pidl, FALSE))
                                {
                                    ILFree(pidl);
                                    pidl = NULL;
                                }

                                ILFree(pidlChannels);
                            }
                            TraceMsg(TF_BAND, "ChannelOC::_OnInPlaceActivate [%s] (%x)", szPath, pidl);
                        }

                        SysFreeString(bstrURL);
                    }

                    pLocation->Release();
                }

                pDoc->Release();
            }

            pContainer->Release();
        }
    }

    return pidl;
}

void ChannelOC::_OnInPlaceActivate()
{
    SUPERCLASS::_OnInPlaceActivate();

    // we should never get called twice, but might as well be safe
    //
    if (EVAL(!_pBand))
    {
        LPITEMIDLIST pidl = _GetInitialPidl();

        // Now create the band and initialize it properly
        //
        _pBand = ChannelBand_Create(pidl);
        if (_pBand)
        {
            IDropTarget* pdt;

            Channels_SetBandInfoSFB(_pBand);
            _pBand->QueryInterface(IID_IWinEventHandler, (LPVOID*)&_pweh);
        
            IUnknown_SetSite(_pBand, SAFECAST(this, IOleObject*));

            // now that band is sited and init'ed, we can override defaults
            if (_crBkgndOC != CLR_DEFAULT) {
                BANDINFOSFB bi;

                TraceMsg(TF_WARNING, "coc.oipa: BGColor=%x _pBand=%x", _crBkgndOC, _pBand);
                bi.dwMask = ISFB_MASK_BKCOLOR;
                bi.crBkgnd = _crBkgndOC;
                IUnknown_SetBandInfoSFB(_pBand, &bi);
            }

            _dbi.dwMask = DBIM_MINSIZE|DBIM_MAXSIZE|DBIM_INTEGRAL|DBIM_ACTUAL|DBIM_TITLE|DBIM_MODEFLAGS|DBIM_BKCOLOR;
            _pBand->GetBandInfo(0, DBIF_VIEWMODE_VERTICAL, &_dbi);

            _pBand->GetWindow(&_hwndChild);

            SetWindowPos(_hwndChild, NULL, 0, 0,
                         _rcPos.right - _rcPos.left,
                         _rcPos.bottom - _rcPos.top,
                         SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER|SWP_SHOWWINDOW);

            _pBand->ShowDW(TRUE);

            // Register the band as a drop target
            if (SUCCEEDED(_pBand->QueryInterface(IID_IDropTarget, (LPVOID*)&pdt)))
            {
                THR(RegisterDragDrop(_hwnd, pdt));
                pdt->Release();
            }

            TraceMsg(TF_BAND, "ISFBandOC::_OnInPlaceActivate()d to cx=%d cy=%d", _size.cx, _size.cy);
        }

        ILFree(pidl);
    }
}

void ChannelOC::_OnInPlaceDeactivate()
{
    IDeskBand * pBand = _pBand;

    // set to NULL to avoid re-entrancy...
    _pBand = NULL;
    
    if (pBand)
    {
        _hwndChild = NULL;

        RevokeDragDrop(_hwnd);

        pBand->ShowDW(FALSE);
        IUnknown_SetSite(pBand, NULL);
        pBand->CloseDW(0);

        TraceMsg(TF_BAND, "ISFBandOC::_OnInPlaceDeactivate()d");
    }

    // we need to keep _pweh because we need the notifies during destruction to 
    // free everything properly
    // the _pBand = NULL above is sufficient to keep from reentrancy
    ATOMICRELEASE(_pweh);
    ATOMICRELEASE(pBand);

    SUPERCLASS::_OnInPlaceDeactivate();
}

HRESULT ChannelOC::SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    HRESULT hres = SUPERCLASS::SetObjectRects(lprcPosRect, lprcClipRect);

    if (_hwndChild)
    {
        SetWindowPos(_hwndChild, NULL, 0,0,
            _rcPos.right - _rcPos.left,
            _rcPos.bottom - _rcPos.top, SWP_NOZORDER);
    }

    return hres;
}

STDAPI ChannelOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hres = E_OUTOFMEMORY;

    ChannelOC* pBand = new ChannelOC(punkOuter, poi);
    if (pBand)
    {
        *ppunk = pBand->_GetInner();
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\clslock.cpp ===
#include "priv.h"
#include "dochost.h"

#define DM_CACHEOLESERVER   DM_TRACE

#define HACK_CACHE_OBJECT_TOO

class CClassHolder : IUnknown
{
public:
    CClassHolder();

    HRESULT Initialize(const CLSID* pclsid);
    
    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    friend IUnknown* ClassHolder_Create(const CLSID* pclsid);

protected:
    ~CClassHolder();

    UINT _cRef;
    IClassFactory* _pcf;
    DWORD _dwAppHack;

#ifdef HACK_CACHE_OBJECT_TOO
    IUnknown* _punk;
#endif // HACK_CACHE_OBJECT_TOO
};

HRESULT CClassHolder::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CClassHolder, IDiscardableBrowserProperty, IUnknown),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CClassHolder::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CClassHolder::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

CClassHolder::CClassHolder() : _cRef(1)
{
}

HRESULT CClassHolder::Initialize(const CLSID *pclsid)
{
    // we need local server here for word, excel, ...
    HRESULT hr = CoGetClassObject(*pclsid, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, 0, IID_PPV_ARG(IClassFactory, &_pcf));

    TraceMsg(DM_CACHEOLESERVER, "CCH::CCH Just called CoGetClassObject %x", hr);

    if (SUCCEEDED(hr)) 
    {
        ::GetAppHackFlags(NULL, pclsid, &_dwAppHack);

        _pcf->LockServer(TRUE);

#ifdef HACK_CACHE_OBJECT_TOO
        hr = _pcf->CreateInstance(NULL, IID_PPV_ARG(IUnknown, &_punk));
        if ((_dwAppHack & BROWSERFLAG_INITNEWTOKEEP) && SUCCEEDED(hr)) 
        {
            TraceMsg(TF_SHDAPPHACK, "CCH::CCH hack for Excel. Call InitNew to keep it running");

            //
            // This InitNew keeps Excel running
            //
            IPersistStorage* pps;
            HRESULT hrT = _punk->QueryInterface(IID_PPV_ARG(IPersistStorage, &pps));
            if (SUCCEEDED(hrT)) 
            {
                IStorage* pstg;
                hrT = StgCreateDocfile(NULL,
                    STGM_DIRECT | STGM_CREATE | STGM_READWRITE
                    | STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE,
                    0, &pstg);
                if (SUCCEEDED(hrT)) 
                {
                    TraceMsg(DM_TRACE, "CCLH::ctor calling InitNew()");
                    pps->InitNew(pstg);
                    pstg->Release();
                }
                else 
                {
                    TraceMsg(DM_TRACE, "CCLH::ctor StgCreateDocfile failed %x", hrT);
                }
                pps->Release();
            } 
            else 
            {
                TraceMsg(DM_TRACE, "CCLH::ctor QI to IPersistStorage failed %x", hrT);
            }
        }
#endif
    }
    return hr;
}

CClassHolder::~CClassHolder()
{
    if (_pcf) 
    {
#ifdef HACK_CACHE_OBJECT_TOO
        if (_punk) 
        {
            _punk->Release();
        }
#endif
        _pcf->LockServer(FALSE);
        ATOMICRELEASE(_pcf);
    }
}

IUnknown* ClassHolder_Create(const CLSID* pclsid)
{
    IUnknown *punk = NULL;
    CClassHolder *pch = new CClassHolder();
    if (pch)
    {
        if (SUCCEEDED(pch->Initialize(pclsid)))
        {
            pch->QueryInterface(IID_PPV_ARG(IUnknown, &punk));
        }
        pch->Release();
    }
    return punk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\dhuihand.h ===
#ifndef _DHUIHAND_H
#define _DHUIHAND_H

class CDocHostUIHandler : 
               public IDocHostUIHandler2
             , public IObjectWithSite
             , public IOleCommandTarget
             , public IDispatch
{
   public:

       // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv);
    STDMETHOD_(ULONG,AddRef)(THIS);
    STDMETHOD_(ULONG,Release)(THIS);
    
    // IDocHostUIHandler
    virtual HRESULT STDMETHODCALLTYPE ShowContextMenu( 
        DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
    virtual HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO *pInfo);
    virtual HRESULT STDMETHODCALLTYPE ShowUI( 
        DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
        IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
        IOleInPlaceUIWindow *pDoc);
    virtual HRESULT STDMETHODCALLTYPE HideUI(void);
    virtual HRESULT STDMETHODCALLTYPE UpdateUI(void);
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL fEnable);
    virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE ResizeBorder( 
        LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
        LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
    virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath(BSTR *pbstrKey, DWORD dw);
    virtual HRESULT STDMETHODCALLTYPE GetDropTarget( 
        IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
    virtual HRESULT STDMETHODCALLTYPE GetExternal(IDispatch **ppDisp);
    virtual HRESULT STDMETHODCALLTYPE TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    virtual HRESULT STDMETHODCALLTYPE FilterDataObject(IDataObject *pDO, IDataObject **ppDORet);

    // IDocHostUIHandler2
    virtual HRESULT STDMETHODCALLTYPE GetOverrideKeyPath(LPOLESTR *pchKey, DWORD dw);

    // IObjectWithSite
    virtual HRESULT STDMETHODCALLTYPE SetSite(IUnknown *punkSite);
    virtual HRESULT STDMETHODCALLTYPE GetSite(REFIID riid, void **ppvSite);

    // IOleCommandTarget
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);           

    //IDispatch
    virtual STDMETHODIMP GetTypeInfoCount(UINT* pctinfo) { return E_NOTIMPL; };
    virtual STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo) { return E_NOTIMPL; };
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
        LCID lcid, DISPID *rgDispId) { return E_NOTIMPL; };
    virtual STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pVarResult,
        EXCEPINFO *pExcepInfo, UINT *puArgErr);

    CDocHostUIHandler::CDocHostUIHandler(void);
    CDocHostUIHandler::~CDocHostUIHandler(void);

protected:
    HRESULT GetAltExternal(IDispatch **ppDisp);    
    void ShowErrorDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags);   
    HRESULT ShowMessage(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags);
    void ShowFindDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags);
    HRESULT ShowPageSetupDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags);
    HRESULT ShowPrintDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags);
    HRESULT DoTemplatePrinting(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, BOOL fPREVIEW);
    HRESULT DoTemplatePageSetup(VARIANTARG *pvarargIn);
    HRESULT ShowPropertysheetDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags);
    HRESULT ShowPropertysheetDialogHelper(int cUnk, IUnknown ** apUnk, HWND hwndOwner, 
        IServiceProvider * pServiceProvider, IUnknown * punkBrowseDefault);
    HRESULT GetCommonPages(int cUnk, IUnknown **apUnk, CAUUID *pca);
    HRESULT ClsidToMoniker(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    IUnknown         * _punkSite;
    IOleInPlaceFrame * _pOleInPlaceFrame;
    HMENU              _hBrowseMenu;
    HMENU              _hEditMenu;    
    IDispatch        * _pExternal;

    IHTMLOptionsHolder * _pOptionsHolder;
    
    BOOL IsFindDialogUp(IWebBrowser2* pwb, IHTMLWindow2** ppWindow);

public:
    //to block more then one preview
    LONG    IncrementPreviewCnt() { return InterlockedIncrement(&m_cPreviewIsUp); };
    LONG    DecrementPreviewCnt() { ASSERT( 0 != m_cPreviewIsUp ); return InterlockedDecrement(&m_cPreviewIsUp); };

private:
    LONG    m_cRef;
    LONG    m_cPreviewIsUp;
};

BSTR GetFindText(IWebBrowser2* pwb);
void PutFindText(IWebBrowser2* pwb, LPCWSTR pwszFindText);

#define STR_FIND_DIALOG_NAME   TEXT("__IE_FindDialog")
#define STR_FIND_DIALOG_TEXT   TEXT("__IE_FindDialogText")
#define STR_PRINT_PREVIEW_NAME TEXT("__IE_PRINTPREVIEW_TEMPLATE")

#endif //_DHUIHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\dllreg.cpp ===
// dllreg.c -- autmatic registration and unregistration
//
#include "priv.h"
#include "util.h"
#include "htregmng.h"
#include <advpub.h>
#include <comcat.h>
#include <winineti.h>
#include "resource.h"
#include "DllRegHelper.h"

#include <mluisupp.h>

#ifdef UNIX
#include "unixstuff.h"
#endif

//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//
#define GUID_STR_LEN    40


//
// helper macros
//
//#define RegCreate(hk, psz, phk) if (ERROR_SUCCESS != RegCreateKeyEx((hk), psz, 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, (phk), &dwDummy)) goto CleanUp
//#define RegSetStr(hk, psz) if (ERROR_SUCCESS != RegSetValueEx((hk), NULL, 0, REG_SZ, (BYTE*)(psz), lstrlen(psz)+1)) goto CleanUp
//#define RegSetStrValue(hk, pszStr, psz)    if(ERROR_SUCCESS != RegSetValueEx((hk), (const char *)(pszStr), 0, REG_SZ, (BYTE*)(psz), lstrlen(psz)+1)) goto CleanUp
//#define RegCloseK(hk) RegCloseKey(hk); hk = NULL
#define RegOpenK(hk, psz, phk) if (ERROR_SUCCESS != RegOpenKeyEx(hk, psz, 0, KEY_READ|KEY_WRITE, phk)) return FALSE


//=--------------------------------------------------------------------------=
// UnregisterTypeLibrary
//=--------------------------------------------------------------------------=
// blows away the type library keys for a given libid.
//
// Parameters:
//    REFCLSID        - [in] libid to blow away.
//
// Output:
//    BOOL            - TRUE OK, FALSE bad.
//
// Notes:
//    - WARNING: this function just blows away the entire type library section,
//      including all localized versions of the type library.  mildly anti-
//      social, but not killer.
//
BOOL UnregisterTypeLibrary
(
    const CLSID* piidLibrary
)
{
    TCHAR szScratch[GUID_STR_LEN];
    HKEY hk;
    BOOL f;

    // convert the libid into a string.
    //
    SHStringFromGUID(*piidLibrary, szScratch, ARRAYSIZE(szScratch));
    RegOpenK(HKEY_CLASSES_ROOT, TEXT("TypeLib"), &hk);

    f = SHDeleteKey(hk, szScratch);

    RegCloseKey(hk);
    return f;
}

HRESULT SHRegisterTypeLib(void)
{
    HRESULT hr = S_OK;
    ITypeLib *pTypeLib;
    DWORD   dwPathLen;
    TCHAR   szTmp[MAX_PATH];

    // Load and register our type library.
    //

    dwPathLen = GetModuleFileName(HINST_THISDLL, szTmp, ARRAYSIZE(szTmp));

#ifdef UNIX
    dwPathLen = ConvertModuleNameToUnix( szTmp );
#endif

    hr = LoadTypeLib(szTmp, &pTypeLib);

    if (SUCCEEDED(hr))
    {
        // call the unregister type library as we had some old junk that
        // was registered by a previous version of OleAut32, which is now causing
        // the current version to not work on NT...
        UnregisterTypeLibrary(&LIBID_SHDocVw);
        hr = RegisterTypeLib(pTypeLib, szTmp, NULL);

        if (FAILED(hr))
        {
            TraceMsg(DM_WARNING, "sccls: RegisterTypeLib failed (%x)", hr);
        }
        pTypeLib->Release();
    }
    else
    {
        TraceMsg(DM_WARNING, "sccls: LoadTypeLib failed (%x)", hr);
    }

    return hr;
}


//
// The actual functions called
//


/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.
*/
HRESULT 
CallRegInstall(
    LPSTR pszSection,
    BOOL bUninstall)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szIEPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "MSIEXPLORE", szIEPath },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            // Get the location of iexplore from the registry
            if ( !EVAL(GetIEPath(szIEPath, SIZECHARS(szIEPath))) )
            {
                // Failed, just say "iexplore"
#ifndef UNIX
                StrCpyNA(szIEPath, "iexplore.exe", ARRAYSIZE(szIEPath));
#else
                StrCpyNA(szIEPath, "iexplorer", ARRAYSIZE(szIEPath));
#endif
            }

            if (g_fRunningOnNT)
            {
                // If on NT, we want custom action for %25% %11%
                // so that it uses %SystemRoot% in writing the
                // path to the registry.
                stReg.cEntries += 2;
            }

            hr = pfnri(g_hinst, pszSection, &stReg);
            if (bUninstall)
            {
                // ADVPACK will return E_UNEXPECTED if you try to uninstall 
                // (which does a registry restore) on an INF section that was 
                // never installed.  We uninstall sections that may never have
                // been installed, so ignore this error
                hr = ((E_UNEXPECTED == hr) ? S_OK : hr);
            }
        }
        else
            TraceMsg(TF_ERROR, "DLLREG CallRegInstall() calling GetProcAddress(hinstAdvPack, \"RegInstall\") failed");

        FreeLibrary(hinstAdvPack);
    }
    else
        TraceMsg(TF_ERROR, "DLLREG CallRegInstall() Failed to load ADVPACK.DLL");

    return hr;
}

const CATID * const c_DeskBandClasses[] = 
{
    &CLSID_QuickLinks,
    &CLSID_AddressBand,
    NULL
};

const CATID * const c_OldDeskBandClasses[] = 
{
    &CLSID_QuickLinksOld,
    NULL
};

const CATID * const c_InfoBandClasses[] =
{
    &CLSID_FavBand,
    &CLSID_HistBand,
    &CLSID_ExplorerBand,
    NULL
};

void RegisterCategories(BOOL fRegister)
{
    enum DRH_REG_MODE eRegister = fRegister ? CCR_REG : CCR_UNREG;

    DRH_RegisterOneCategory(&CATID_DeskBand, IDS_CATDESKBAND, c_DeskBandClasses, eRegister);
    DRH_RegisterOneCategory(&CATID_InfoBand, IDS_CATINFOBAND, c_InfoBandClasses, eRegister);
    if (fRegister) 
    {
        // only nuke the implementor(s), not the category
        DRH_RegisterOneCategory(&CATID_DeskBand, IDS_CATDESKBAND, c_OldDeskBandClasses, CCR_UNREGIMP);
    }
}

STDAPI 
DllRegisterServer(void)
{
    HRESULT hr = S_OK;
    HRESULT hrExternal = S_OK;
    TraceMsg(DM_TRACE, "DLLREG DllRegisterServer() Beginning");

#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllRegisterServer");
        DEBUG_BREAK;
    }
#endif

    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    // (The inf engine doesn't guarantee DelReg/AddReg order, that's
    // why we explicitly unreg and reg here.)
    //
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    hr = THR(CallRegInstall("InstallControls", FALSE));
    if (SUCCEEDED(hrExternal))
        hrExternal = hr;

    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    hr = THR(SHRegisterTypeLib());
    if (SUCCEEDED(hrExternal))
        hrExternal = hr;

#ifdef UNIX
    hrExternal = UnixRegisterBrowserInActiveSetup();
#endif /* UNIX */

    return hrExternal;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    TraceMsg(DM_TRACE, "DLLREG DllUnregisterServer() Beginning");

    // UnInstall the registry values
    hr = THR(CallRegInstall("UnInstallControls", TRUE));

    return hr;
}


extern HRESULT UpgradeSettings(void);

/*----------------------------------------------------------
Purpose: Install/uninstall user settings

Description: Note that this function has special error handling.
             The function will keep hrExternal with the worse error
             but will only stop executing util the internal error (hr)
             gets really bad.  This is because we need the external
             error to catch incorrectly authored INFs but the internal
             error to be robust in attempting to install other INF sections
             even if one doesn't make it.
*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;
    HRESULT hrExternal = S_OK;
    HINSTANCE hinstAdvPack;

    if (0 == StrCmpIW(pszCmdLine, TEXTW("ForceAssoc")))
    {
        InstallIEAssociations(IEA_FORCEIE);
        return hr;
    }

    hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.

#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllInstall");
        DEBUG_BREAK;
    }
#endif

    // Assume we're installing for integrated shell unless otherwise
    // noted.
    BOOL bIntegrated = ((WhichPlatform() == PLATFORM_INTEGRATED) ? TRUE : FALSE);

    TraceMsg(DM_TRACE, "DLLREG DllInstall(bInstall=%lx, pszCmdLine=\"%ls\") bIntegrated=%lx", (DWORD) bInstall, pszCmdLine, (DWORD) bIntegrated);

    CoInitialize(0);
    if (bInstall)
    {
        // Backup current associations because InstallPlatformRegItems() may overwrite.
        hr = THR(CallRegInstall("InstallAssociations", FALSE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

        hr = THR(CallRegInstall("InstallBrowser", FALSE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

        if (bIntegrated)
        {
            // UnInstall settings that cannot be installed with Shell Integration.
            // This will be a NO-OP if it wasn't installed.
            hr = THR(CallRegInstall("UnInstallOnlyBrowser", TRUE));
            if (SUCCEEDED(hrExternal))
                hrExternal = hr;

            // Install IE4 shell components too.
            hr = THR(CallRegInstall("InstallOnlyShell", FALSE));
            if (SUCCEEDED(hrExternal))
                hrExternal = hr;

            if (GetUIVersion() >= 5)
            {
                hr = THR(CallRegInstall("InstallWin2KShell", FALSE));
                if (SUCCEEDED(hrExternal))
                    hrExternal = hr;
            }
            else
            {
                hr = THR(CallRegInstall("InstallPreWin2KShell", FALSE));
                if (SUCCEEDED(hrExternal))
                    hrExternal = hr;
            }

            if (IsOS(OS_WHISTLERORGREATER))
            {
                hr = THR(CallRegInstall("InstallXP", FALSE));
                if (SUCCEEDED(hrExternal))
                    hrExternal = hr;
            }
        }
        else
        {
            // UnInstall Shell Integration settings.
            // This will be a NO-OP if it wasn't installed.
            hr = THR(CallRegInstall("UnInstallOnlyShell", TRUE));
            if (SUCCEEDED(hrExternal))
                hrExternal = hr;

            // Install IE4 shell components too.
            hr = THR(CallRegInstall("InstallOnlyBrowser", FALSE));
            if (SUCCEEDED(hrExternal))
                hrExternal = hr;
        }

        UpgradeSettings();
        UninstallCurrentPlatformRegItems();
        InstallIEAssociations(IEA_NORMAL);
        RegisterCategories(TRUE);
        SHRegisterTypeLib();
    }
    else
    {
        // Uninstall browser-only or integrated-browser?
        UninstallPlatformRegItems(bIntegrated);

        // Restore previous association settings that UninstallPlatformRegItems() could
        // have Uninstalled.
        hr = THR(CallRegInstall("UnInstallAssociations", TRUE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

        // UnInstall settings that cannot be installed with Shell Integration.
        // This will be a NO-OP if it wasn't installed.
        hr = THR(CallRegInstall("UnInstallOnlyBrowser", TRUE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

        // UnInstall Shell Integration settings.
        // This will be a NO-OP if it wasn't installed.
        hr = THR(CallRegInstall("UnInstallShell", TRUE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

        hr = THR(CallRegInstall("UnInstallBrowser", TRUE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

        UnregisterTypeLibrary(&LIBID_SHDocVw);
        RegisterCategories(FALSE);
    }


    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    CoUninitialize();
    return hrExternal;    
}    


/*----------------------------------------------------------
Purpose: Gets a registry value that is User Specifc.  
         This will open HKEY_CURRENT_USER if it exists,
         otherwise it will open HKEY_LOCAL_MACHINE.  

Returns: DWORD containing success or error code.
Cond:    --
*/
LONG OpenRegUSKey(LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)           
{
    DWORD dwRet = RegOpenKeyEx(HKEY_CURRENT_USER, lpSubKey, ulOptions, samDesired, phkResult);

    if (ERROR_SUCCESS != dwRet)
        dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpSubKey, ulOptions, samDesired, phkResult);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\dhuihand.cpp ===
#include "priv.h"
#include "resource.h"
#include "mshtmcid.h"

#include <mluisupp.h>

#ifndef X_IEHELPID_H_
#define X_IEHELPID_H_
#include "iehelpid.h"
#endif

#include "dhuihand.h"

#define DM_DOCHOSTUIHANDLER 0
#define CX_CONTEXTMENUOFFSET    2
#define CY_CONTEXTMENUOFFSET    2

//+------------------------------------------------------------------------
//
// WARNING! (greglett)
//
// The following defines were stolen from commdlg.h.  Since SHDOCVW is
// compiled with WINVER=0x0400 and these defines are WINVER=0x0500 they
// needed to be copied and included here.  These must be kept in sync
// with the commdlg.h definitions.
//
// If shdocvw ever gets compiled with WINVER=0x0500 or above, then these
// can be removed.
//
//-------------------------------------------------------------------------

#define NEED_BECAUSE_COMPILED_AT_WINVER_4
#ifdef  NEED_BECAUSE_COMPILED_AT_WINVER_4
//
//  Define the start page for the print dialog when using PrintDlgEx.
//
#define START_PAGE_GENERAL             0xffffffff

//
//  Page Range structure for PrintDlgEx.
//
typedef struct tagPRINTPAGERANGE {
   DWORD  nFromPage;
   DWORD  nToPage;
} PRINTPAGERANGE, *LPPRINTPAGERANGE;


//
//  PrintDlgEx structure.
//
typedef struct tagPDEXA {
   DWORD                 lStructSize;          // size of structure in bytes
   HWND                  hwndOwner;            // caller's window handle
   HGLOBAL               hDevMode;             // handle to DevMode
   HGLOBAL               hDevNames;            // handle to DevNames
   HDC                   hDC;                  // printer DC/IC or NULL
   DWORD                 Flags;                // PD_ flags
   DWORD                 Flags2;               // reserved
   DWORD                 ExclusionFlags;       // items to exclude from driver pages
   DWORD                 nPageRanges;          // number of page ranges
   DWORD                 nMaxPageRanges;       // max number of page ranges
   LPPRINTPAGERANGE      lpPageRanges;         // array of page ranges
   DWORD                 nMinPage;             // min page number
   DWORD                 nMaxPage;             // max page number
   DWORD                 nCopies;              // number of copies
   HINSTANCE             hInstance;            // instance handle
   LPCSTR                lpPrintTemplateName;  // template name for app specific area
   LPUNKNOWN             lpCallback;           // app callback interface
   DWORD                 nPropertyPages;       // number of app property pages in lphPropertyPages
   HPROPSHEETPAGE       *lphPropertyPages;     // array of app property page handles
   DWORD                 nStartPage;           // start page id
   DWORD                 dwResultAction;       // result action if S_OK is returned
} PRINTDLGEXA, *LPPRINTDLGEXA;
//
//  PrintDlgEx structure.
//
typedef struct tagPDEXW {
   DWORD                 lStructSize;          // size of structure in bytes
   HWND                  hwndOwner;            // caller's window handle
   HGLOBAL               hDevMode;             // handle to DevMode
   HGLOBAL               hDevNames;            // handle to DevNames
   HDC                   hDC;                  // printer DC/IC or NULL
   DWORD                 Flags;                // PD_ flags
   DWORD                 Flags2;               // reserved
   DWORD                 ExclusionFlags;       // items to exclude from driver pages
   DWORD                 nPageRanges;          // number of page ranges
   DWORD                 nMaxPageRanges;       // max number of page ranges
   LPPRINTPAGERANGE      lpPageRanges;         // array of page ranges
   DWORD                 nMinPage;             // min page number
   DWORD                 nMaxPage;             // max page number
   DWORD                 nCopies;              // number of copies
   HINSTANCE             hInstance;            // instance handle
   LPCWSTR               lpPrintTemplateName;  // template name for app specific area
   LPUNKNOWN             lpCallback;           // app callback interface
   DWORD                 nPropertyPages;       // number of app property pages in lphPropertyPages
   HPROPSHEETPAGE       *lphPropertyPages;     // array of app property page handles
   DWORD                 nStartPage;           // start page id
   DWORD                 dwResultAction;       // result action if S_OK is returned
} PRINTDLGEXW, *LPPRINTDLGEXW;
#ifdef UNICODE
typedef PRINTDLGEXW PRINTDLGEX;
typedef LPPRINTDLGEXW LPPRINTDLGEX;
#else
typedef PRINTDLGEXA PRINTDLGEX;
typedef LPPRINTDLGEXA LPPRINTDLGEX;
#endif // UNICODE

HRESULT  APIENTRY  PrintDlgExA(LPPRINTDLGEXA);
HRESULT  APIENTRY  PrintDlgExW(LPPRINTDLGEXW);
#ifdef UNICODE
#define PrintDlgEx  PrintDlgExW
#else
#define PrintDlgEx  PrintDlgExA
#endif // !UNICODE

//
//  Result action ids for PrintDlgEx.
//
#define PD_RESULT_CANCEL               0
#define PD_RESULT_PRINT                1
#define PD_RESULT_APPLY                2

#define PD_CURRENTPAGE                 0x00400000
#define PD_NOCURRENTPAGE               0x00800000

#endif // NEED_BECAUSE_COMPILED_AT_WINVER_4


//+------------------------------------------------------------------------
//
// Useful combinations of flags for IOleCommandTarget
//
//-------------------------------------------------------------------------

#define OLECMDSTATE_DISABLED    OLECMDF_SUPPORTED
#define OLECMDSTATE_UP          (OLECMDF_SUPPORTED | OLECMDF_ENABLED)
#define OLECMDSTATE_DOWN        (OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_LATCHED)
#define OLECMDSTATE_NINCHED     (OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED)

struct SExpandoInfo
{
    TCHAR * name;
    VARTYPE type;
};

// Enumerations for custom expandos
enum MessageEnum
{
   MessageText,
   MessageCaption,
   MessageStyle,
   MessageHelpFile,
   MessageHelpContext
};

enum PagesetupEnum
{
    PagesetupHeader,
    PagesetupFooter,
    PagesetupStruct
};

enum PrintEnum
{
    PrintfRootDocumentHasFrameset,
    PrintfAreRatingsEnabled,
    PrintfPrintActiveFrame,
    PrintfPrintLinked,
    PrintfPrintSelection,
    PrintfPrintAsShown,
    PrintfShortcutTable,
    PrintiFontScaling,
    PrintpBodyActiveTarget,
    PrintStruct,
    PrintToFileOk,
    PrintToFileName,
    PrintfPrintActiveFrameEnabled,
};

enum PropertysheetEnum
{
    PropertysheetPunks
};

//----------------------------------------------------------------------------
//
//  Arrays describing helpcontextids for PageSetup/Print
//
//----------------------------------------------------------------------------

static const DWORD aPrintDialogHelpIDs[] =
{
    stc6,                       IDH_PRINT_CHOOSE_PRINTER,
    cmb4,                       IDH_PRINT_CHOOSE_PRINTER,
    psh2,                       IDH_PRINT_PROPERTIES,
    stc7,                       IDH_PRINT_SETUP_DETAILS,
    stc8,                       IDH_PRINT_SETUP_DETAILS,
    stc9,                       IDH_PRINT_SETUP_DETAILS,
    stc10,                      IDH_PRINT_SETUP_DETAILS,
    stc12,                      IDH_PRINT_SETUP_DETAILS,
    stc11,                      IDH_PRINT_SETUP_DETAILS,
    stc14,                      IDH_PRINT_SETUP_DETAILS,
    stc13,                      IDH_PRINT_SETUP_DETAILS,
    stc5,                       IDH_PRINT_TO_FILE,
    chx1,                       IDH_PRINT_TO_FILE,
    ico3,                       IDH_PRINT_COLLATE,
    chx2,                       IDH_PRINT_COLLATE,
    grp1,                       IDH_PRINT_RANGE,
    rad1,                       IDH_PRINT_RANGE,        // all
    rad2,                       IDH_PRINT_RANGE,        // selection
    rad3,                       IDH_PRINT_RANGE,        // pages
    stc2,                       IDH_PRINT_RANGE,
    stc3,                       IDH_PRINT_RANGE,
    edt1,                       IDH_PRINT_RANGE,
    edt2,                       IDH_PRINT_RANGE,
    edt3,                       IDH_PRINT_COPIES,
    rad4,                       IDH_PRINT_SCREEN,
    rad5,                       IDH_PRINT_SEL_FRAME,
    rad6,                       IDH_PRINT_ALL_FRAME,
    IDC_LINKED,                 IDH_PRINT_LINKS,
    IDC_SHORTCUTS,              IDH_PRINT_SHORTCUTS,
    0,    0
};

static const DWORD aPageSetupDialogHelpIDs[] =
{
    psh3,                       IDH_PRINT_PRINTER_SETUP,
    stc2,                       IDH_PAGE_PAPER_SIZE,
    cmb2,                       IDH_PAGE_PAPER_SIZE,
    stc3,                       IDH_PAGE_PAPER_SOURCE,
    cmb3,                       IDH_PAGE_PAPER_SOURCE,
    rad1,                       IDH_PAGE_ORIENTATION,
    rad2,                       IDH_PAGE_ORIENTATION,
    stc15,                      IDH_PAGE_MARGINS,
    edt4,                       IDH_PAGE_MARGINS,
    stc16,                      IDH_PAGE_MARGINS,
    edt5,                       IDH_PAGE_MARGINS,
    stc17,                      IDH_PAGE_MARGINS,
    edt6,                       IDH_PAGE_MARGINS,
    stc18,                      IDH_PAGE_MARGINS,
    edt7,                       IDH_PAGE_MARGINS,
    IDC_EDITHEADER,             IDH_PAGESETUP_HEADER_LEFT,
    IDC_STATICHEADER,           IDH_PAGESETUP_HEADER_LEFT,
    IDC_EDITFOOTER,             IDH_PAGESETUP_HEADER_LEFT,
    IDC_STATICFOOTER,           IDH_PAGESETUP_HEADER_LEFT,
    IDC_HEADERFOOTER,           IDH_PAGESETUP_HEADER_LEFT,
    0,    0
};

//+---------------------------------------------------------------------------
//
//  Function:   GetControlID
//
//  Synopsis:
//
//  Arguments:  HWND - passed window handle of WM_CONTEXTMENU
//              lParam  - passed coordinates (lParam) of WM_CONTEXTMENU
//
//  Returns:    int - ctrlid
//
//
//----------------------------------------------------------------------------
int GetControlID(HWND hwnd, LPARAM lParam)
{
    int CtrlID;

    CtrlID = GetDlgCtrlID(hwnd);
    if (CtrlID==0)
    {
        POINT pt;
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        if (ScreenToClient(hwnd, &pt))
        {
            HWND  hwndChild = ChildWindowFromPointEx(hwnd, pt, CWP_ALL);
            if (hwndChild)
            {
                CtrlID = GetDlgCtrlID(hwndChild);
            }
        }
    }
    return CtrlID;

}

//+---------------------------------------------------------------------------
//
//  Function:   GetHelpFile
//
//  Synopsis:
//
//  Arguments:  iCtrlID - id of the control
//              adw     - array of DWORDS, consisting of controlid,helpid pairs
//
//  Returns:    A string with the name of the helpfile
//
//  Notes:      Help topics for the print dialogs can be either in iexplore.hlp
//              or in windows.hlp.  We key off the helpid to determine which
//              file to go to.
//
//----------------------------------------------------------------------------


LPTSTR
GetHelpFile(int iCtrlID, DWORD * adw)
{
    ASSERT (adw);
    while (TRUE)
    {
        int ctrlid = int(*adw);
        int helpid = int(*(adw + 1));

        if (ctrlid == 0 && helpid == 0)
        {
            break;
        }

        if (ctrlid == iCtrlID)
        {
            //TraceTag((tagContextHelp, "for ctrl=%d, topic=%d", ctrlid, helpid));
            return (helpid < 50000) ? TEXT("windows.hlp") : TEXT("iexplore.hlp");
        }

        adw += 2;
    }
    return TEXT("windows.hlp");
}

GetInterfaceFromClientSite(IUnknown *pUnk, REFIID riid, void ** ppv)
{
    HRESULT               hr;
    IOleObject          * pOleObject = NULL;
    IOleClientSite      * pOleClientSite = NULL;

    if (!pUnk || !ppv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppv = NULL;

    hr = pUnk->QueryInterface(IID_PPV_ARG(IOleObject, &pOleObject));
    if (hr)
        goto Cleanup;

    hr = pOleObject->GetClientSite(&pOleClientSite);
    if (pOleClientSite == NULL)
    {
        hr = E_FAIL;
    }
    if (hr)
        goto Cleanup;

    hr = pOleClientSite->QueryInterface(riid, ppv);

Cleanup:
    ATOMICRELEASE(pOleClientSite);
    ATOMICRELEASE(pOleObject);

    return hr;
    
    
}

//
// Get the IOleInPlaceFrame if available.  If this proves useful, move this somewhere interesting.
//
HRESULT GetInPlaceFrameFromUnknown(IUnknown * punk, IOleInPlaceFrame ** ppOleInPlaceFrame)
{
    IOleInPlaceSite     * pOleInPlaceSite = NULL;
    IOleInPlaceUIWindow * pOleInPlaceUIWindow = NULL;
    RECT                  rcPos, rcClip;
    OLEINPLACEFRAMEINFO   frameInfo = {0};
    HRESULT hr = GetInterfaceFromClientSite(punk, IID_PPV_ARG(IOleInPlaceSite, &pOleInPlaceSite));
    if (S_OK != hr)
        goto Cleanup;

    *ppOleInPlaceFrame = NULL;

    frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
    hr = pOleInPlaceSite->GetWindowContext(ppOleInPlaceFrame,
                                           &pOleInPlaceUIWindow,
                                           &rcPos,
                                           &rcClip,
                                           &frameInfo);

Cleanup:
    ATOMICRELEASE(pOleInPlaceUIWindow);
    ATOMICRELEASE(pOleInPlaceSite);

    return hr;
}

HRESULT
GetHwndFromUnknown(
    IUnknown          * punk,
    HWND              * phwnd)
{
    HRESULT             hr;
    IOleInPlaceFrame  * pOleInPlaceFrame = NULL;

    ASSERT(punk);
    ASSERT(phwnd);

    if (phwnd)
    {
        *phwnd = NULL;
    }

    if (!punk || !phwnd)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = GetInPlaceFrameFromUnknown(punk, &pOleInPlaceFrame);
    if (S_OK != hr)
        goto Cleanup;

    hr = pOleInPlaceFrame->GetWindow(phwnd);
    if (S_OK != hr)
        goto Cleanup;

Cleanup:
    ATOMICRELEASE(pOleInPlaceFrame);

    return hr;
}

HRESULT
GetEventFromUnknown(
    IUnknown       * punk,
    IHTMLEventObj ** ppEventObj)
{
    HRESULT             hr;
    IHTMLDocument2    * pOmDoc = NULL;
    IHTMLWindow2      * pOmWindow = NULL;

    ASSERT(punk);
    ASSERT(ppEventObj);

    if (ppEventObj)
        *ppEventObj = NULL;

    if (!punk || !ppEventObj)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = punk->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pOmDoc));
    if (S_OK != hr)
        goto Cleanup;

    hr = pOmDoc->get_parentWindow(&pOmWindow);
    if (S_OK != hr)
        goto Cleanup;

    hr = pOmWindow->get_event(ppEventObj);
    if (S_OK != hr)
        goto Cleanup;

Cleanup:
    ATOMICRELEASE(pOmDoc);
    ATOMICRELEASE(pOmWindow);

    return hr;
}

//
// Gets the dispids/variants from the event.
//
HRESULT
GetParamsFromEvent(
    IHTMLEventObj         * pEventObj,
    unsigned int            cExpandos,
    DISPID                  aDispid[],
    VARIANT                 aVariant[],
    const SExpandoInfo      aExpandos[])
{
    HRESULT             hr;
    IDispatchEx       * pDispatchEx = NULL;
    unsigned int        i;

    ASSERT(pEventObj);
    ASSERT(aVariant);
    ASSERT(aExpandos);
    // ASSERT(cExpandos >= 0); // cExpandos is an unsigned int, so this is always true

    // deleted "|| cExpandos < 0" from below test
    // since unsigned ints are never negative
    if (!pEventObj || !aVariant || !aExpandos)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    for (i=0; i<cExpandos; i++)
    {
        VariantInit(aVariant+i);
        aDispid[i] = DISPID_UNKNOWN;
    }

    hr = pEventObj->QueryInterface(IID_PPV_ARG(IDispatchEx, &pDispatchEx));
    if (S_OK != hr)
        goto Cleanup;

    for (i=0; i<cExpandos; i++)
    {
        hr = pDispatchEx->GetDispID(
            aExpandos[i].name,
            fdexNameCaseSensitive,
            aDispid+i);
        if (S_OK != hr)
            goto Cleanup;

        hr = pDispatchEx->InvokeEx(
            aDispid[i],
            LOCALE_USER_DEFAULT,
            DISPATCH_PROPERTYGET,
            (DISPPARAMS *)&g_dispparamsNoArgs,
            aVariant+i,
            NULL,
            NULL);

        // Check the variant types match
        ASSERT(  V_VT(aVariant+i) == aExpandos[i].type
               || V_VT(aVariant+i) == VT_EMPTY);

        if (S_OK != hr)
            goto Cleanup;
    }

Cleanup:
    ATOMICRELEASE(pDispatchEx);

    return hr;
}


HRESULT
PutParamToEvent(DISPID dispid, VARIANT * var, IHTMLEventObj * pEventObj)
{
    HRESULT         hr;
    IDispatchEx   * pDispatchEx = NULL;
    DISPPARAMS      dispparams = {var, &dispid, 1, 1};

    ASSERT(var);
    ASSERT(pEventObj);

    if (!var || !pEventObj)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = pEventObj->QueryInterface(IID_PPV_ARG(IDispatchEx, &pDispatchEx));
    if (S_OK != hr)
        goto Cleanup;

    hr = pDispatchEx->InvokeEx(
            dispid,
            LOCALE_USER_DEFAULT,
            DISPATCH_PROPERTYPUT,
            &dispparams,
            NULL,
            NULL,
            NULL);
    if (S_OK != hr)
        goto Cleanup;

Cleanup:
    ATOMICRELEASE(pDispatchEx);

    return hr;
}

void PutFindText(IWebBrowser2* pwb, LPCWSTR pwszFindText)
{
    BSTR bstrName = SysAllocString(STR_FIND_DIALOG_TEXT);

    if (NULL != bstrName)
    {
        VARIANT var = {VT_EMPTY};

        if (NULL != pwszFindText)
        {
            var.vt = VT_BSTR;
            var.bstrVal = SysAllocString(pwszFindText);
        }

        if ((VT_EMPTY == var.vt) || (NULL != var.bstrVal))
        {
            pwb->PutProperty(bstrName, var);
        }

        SysFreeString(var.bstrVal);
        SysFreeString(bstrName);
    }
}

BSTR GetFindText(IWebBrowser2* pwb)
{   
    BSTR bstrName = SysAllocString(STR_FIND_DIALOG_TEXT);

    VARIANT var = {0};

    if (bstrName)
    {
        ASSERT(pwb);

        pwb->GetProperty(bstrName, &var);

        SysFreeString(bstrName);
    }

    BSTR bstrResult; 
    
    if (VT_BSTR == var.vt)
    {
        bstrResult = var.bstrVal;
    }
    else
    {   
        bstrResult = NULL;
        VariantClear(&var);
    }

    return bstrResult;
}

CDocHostUIHandler::CDocHostUIHandler(void) : m_cRef(1)
{
    DllAddRef();
    m_cPreviewIsUp = 0;
}

CDocHostUIHandler::~CDocHostUIHandler(void)
{
    ATOMICRELEASE(_punkSite);
    //
    // We don't addref _pExternal to avoid an addref/release cycle.  So, we can't release it.
    //
    // ATOMICRELEASE(_pExternal);
    ATOMICRELEASE(_pOptionsHolder);
    if (_hBrowseMenu)
        DestroyMenu(_hBrowseMenu);
    if (_hEditMenu)
        DestroyMenu(_hEditMenu);

    DllRelease();
}

STDMETHODIMP CDocHostUIHandler::QueryInterface(REFIID riid, PVOID *ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDocHostUIHandler, IDocHostUIHandler),
        QITABENT(CDocHostUIHandler, IObjectWithSite),
        QITABENT(CDocHostUIHandler, IOleCommandTarget),
        QITABENT(CDocHostUIHandler, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CDocHostUIHandler::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDocHostUIHandler::Release()
{
    ASSERT(0 != m_cRef);
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
    }
    return cRef;
}


HRESULT CDocHostUIHandler::SetSite(IUnknown *punkSite)
{
    ATOMICRELEASE(_punkSite);

    ASSERT(_punkSite == NULL);  // don't lose a reference to this

    _punkSite = punkSite;
    if (_punkSite)
    {
        _punkSite->AddRef();
    }

    // Always return S_OK
    //
    return S_OK;
}

HRESULT CDocHostUIHandler::GetSite(REFIID riid, void **ppvSite)
{
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_FAIL;
}


//==========================================================================
// IDocHostUIHandler implementation
//==========================================================================

HRESULT CDocHostUIHandler::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
    HRESULT                 hr = S_FALSE;
    HCURSOR                 hcursor;
    HMENU                   hMenu = NULL;
    VARIANT                 var, var1, var2;
    VARIANT               * pvar = NULL;
    int                     iSelection = 0;
    HWND                    hwnd = NULL;
    IOleCommandTarget     * pOleCommandTarget = NULL;
    IOleWindow            * pOleWindow = NULL;
    IOleInPlaceFrame      * pOleInPlaceFrame = NULL;
    IDocHostUIHandler     * pUIHandler = NULL;
    MENUITEMINFO            mii = {0};
    int                     i;
    OLECMD                  olecmd;
    UINT                    mf;
    BOOL                    fDeletePrint            = FALSE;
    BOOL                    fDeleteSetDesktopItem   = FALSE;
    BOOL                    fDeleteViewSource       = FALSE;

    IHTMLImgElement       * pImgEle = NULL;


    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::ShowContextMenu called");

    //If restriction is set, we lie to Mshtml that context menu has been set. 
    if (SHRestricted2W(REST_NoBrowserContextMenu, NULL, 0))
        return S_OK;

    // Do a proper QI for IOleCommandTarget
    //
    hr = pcmdtReserved->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pOleCommandTarget));
    if (S_OK != hr)
        goto Cleanup;


    // Check if we are in browse mode
    //
    olecmd.cmdID = IDM_BROWSEMODE;
    hr = pOleCommandTarget->QueryStatus(&CGID_MSHTML, 1, &olecmd, NULL);
    if (S_OK != hr)
        goto Cleanup;
        
    if (olecmd.cmdf == OLECMDSTATE_DOWN)
    {
        if (!_hBrowseMenu)
            _hBrowseMenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(IDR_BROWSE_CONTEXT_MENU));
            
        hMenu = _hBrowseMenu;
    }
    // Check if we are in edit mode
    else
    {
        olecmd.cmdID = IDM_EDITMODE;
        hr = pOleCommandTarget->QueryStatus(&CGID_MSHTML, 1, &olecmd, NULL);
        if (S_OK != hr)
            goto Cleanup;
            
        if (olecmd.cmdf == OLECMDSTATE_DOWN)
        {
            if (!_hEditMenu)
                _hEditMenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(IDR_FORM_CONTEXT_MENU));
                
            hMenu = _hEditMenu;
        }

        // Neither Browse nor Edit flags were set
        else
        {
            ASSERT(false);
            goto Cleanup;
        }
    }

    if (!hMenu)
        goto Cleanup;


    //
    // check through all the submenus and remove any sets of items which
    // need to be removed
    //

    fDeletePrint = SHRestricted2(REST_NoPrinting, NULL, 0);
    fDeleteSetDesktopItem = (WhichPlatform() != PLATFORM_INTEGRATED);
    fDeleteViewSource = SHRestricted2(REST_NoViewSource, NULL, 0);

    if (fDeletePrint || fDeleteSetDesktopItem || fDeleteViewSource)
    {
        int  iSubMenuIndex;

        for (iSubMenuIndex = 0;  iSubMenuIndex < GetMenuItemCount(hMenu); iSubMenuIndex++)
        {
            HMENU hSubMenu = GetSubMenu(hMenu, iSubMenuIndex);
            if (hSubMenu)
            {
                if (fDeletePrint)
                {
                    DeleteMenu(hSubMenu, IDM_PRINT, MF_BYCOMMAND);
                }

                if (fDeleteSetDesktopItem)
                {
                    DeleteMenu(hSubMenu, IDM_SETDESKTOPITEM, MF_BYCOMMAND);
                }

                if (fDeleteViewSource)
                {
                    DeleteMenu(hSubMenu, IDM_VIEWSOURCE, MF_BYCOMMAND);
                }
            }
        }
    }


    // Make sure we are running mshtml debug build if we are loading debug window
    if (dwID == CONTEXT_MENU_DEBUG)
    {
        olecmd.cmdID = IDM_DEBUG_TRACETAGS;
        hr = pOleCommandTarget->QueryStatus(&CGID_MSHTML, 1, &olecmd, NULL);
        if (olecmd.cmdf != OLECMDSTATE_UP)
            goto Cleanup;
    }


    // Select the appropriate submenu based on the passed in ID
    hMenu = GetSubMenu(hMenu, dwID);

    if (!hMenu)
        goto Cleanup;

    // Loop through and QueryStatus the menu items.
    //
    for (i = 0; i < GetMenuItemCount(hMenu); i++)
    {
        olecmd.cmdID = GetMenuItemID(hMenu, i);
        if (olecmd.cmdID > 0)
        {
            pOleCommandTarget->QueryStatus(
                    &CGID_MSHTML,
                    1,
                    &olecmd,
                    NULL);
            switch (olecmd.cmdf)
            {
            case OLECMDSTATE_UP:
            case OLECMDSTATE_NINCHED:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_UNCHECKED;
                break;

            case OLECMDSTATE_DOWN:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_CHECKED;
                break;

            case OLECMDSTATE_DISABLED:
            default:
                mf = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
                break;
            }
            CheckMenuItem(hMenu, olecmd.cmdID, mf);
            EnableMenuItem(hMenu, olecmd.cmdID, mf);
        }
    }

    // Get the language submenu
    hr = pOleCommandTarget->Exec(&CGID_ShellDocView, SHDVID_GETMIMECSETMENU, 0, NULL, &var);
    if (S_OK != hr)
        goto Cleanup;

    mii.cbSize = sizeof(mii);
    mii.fMask  = MIIM_SUBMENU;
    mii.hSubMenu = (HMENU) var.byref;

    SetMenuItemInfo(hMenu, IDM_LANGUAGE, FALSE, &mii);
    // Insert Context Menu
    V_VT(&var1) = VT_INT_PTR;
    V_BYREF(&var1) = hMenu;

    V_VT(&var2) = VT_I4;
    V_I4(&var2) = dwID;

    hr = pOleCommandTarget->Exec(&CGID_ShellDocView, SHDVID_ADDMENUEXTENSIONS, 0, &var1, &var2);
    if (S_OK != hr)
        goto Cleanup;

    // Get the window also.
    //
    if (SUCCEEDED(pcmdtReserved->QueryInterface(IID_PPV_ARG(IOleWindow, &pOleWindow))))
    {
        pOleWindow->GetWindow(&hwnd);
    }

    if (hwnd)
    {

        GetInterfaceFromClientSite(pcmdtReserved, IID_PPV_ARG(IDocHostUIHandler, &pUIHandler));
        if (pUIHandler)
            pUIHandler->EnableModeless(FALSE);

        GetInPlaceFrameFromUnknown(pcmdtReserved, &pOleInPlaceFrame);
        if (pOleInPlaceFrame)
                pOleInPlaceFrame->EnableModeless(FALSE);

        hcursor = SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));

        // Display the menu.  Pass in the HWND of our site object.
        //
        iSelection = ::TrackPopupMenu(
                        hMenu,
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                        ppt->x + CX_CONTEXTMENUOFFSET,
                        ppt->y + CY_CONTEXTMENUOFFSET,
                        0,
                        hwnd,
                        (RECT*)NULL);        

        if (pUIHandler)
            pUIHandler->EnableModeless(TRUE);

        if (pOleInPlaceFrame)
            pOleInPlaceFrame->EnableModeless(TRUE);

        SetCursor(hcursor);
    }

    if (iSelection)
    {
        switch (iSelection)
        {
            case IDM_FOLLOWLINKN:
                // tell the top level browser to save its window size to the registry so 
                // that our new window can pick it up and cascade properly

                IUnknown_Exec(_punkSite, &CGID_Explorer, SBCMDID_SUGGESTSAVEWINPOS, 0, NULL, NULL);

                // fall through

            case IDM_PROPERTIES:
            case IDM_FOLLOWLINKC:
            
                pvar = &var;
                V_VT(pvar) = VT_I4;
                V_I4(pvar) = MAKELONG(ppt->x, ppt->y);
                break;
        }

        pOleCommandTarget->Exec(&CGID_MSHTML, iSelection, 0, pvar, NULL);
    }

    {
        MENUITEMINFO mii2 = {0};
        mii2.cbSize = sizeof(mii);
        mii2.fMask  = MIIM_SUBMENU;
        mii2.hSubMenu = NULL;

        SetMenuItemInfo(hMenu, IDM_LANGUAGE, FALSE, &mii2);
    }

Cleanup:
    DestroyMenu(mii.hSubMenu);

    ATOMICRELEASE(pOleCommandTarget);
    ATOMICRELEASE(pOleWindow);
    ATOMICRELEASE(pOleInPlaceFrame);
    ATOMICRELEASE(pUIHandler);
    return hr;
}

HRESULT CDocHostUIHandler::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    DWORD dwUrlEncodingDisableUTF8;
    DWORD dwSize = SIZEOF(dwUrlEncodingDisableUTF8);
    BOOL  fDefault = FALSE;
    DWORD dwLoadf = 0;

    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetHostInfo called");

    pInfo->cbSize = sizeof(DOCHOSTUIINFO);

    pInfo->dwFlags = DOCHOSTUIFLAG_BROWSER | DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION | DOCHOSTUIFLAG_IME_ENABLE_RECONVERSION;

    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;     // default

    SHRegGetUSValue(REGSTR_PATH_INTERNET_SETTINGS,
        TEXT("UrlEncoding"), NULL, (LPBYTE) &dwUrlEncodingDisableUTF8, &dwSize, FALSE, (LPVOID) &fDefault, SIZEOF(fDefault));

    if (dwUrlEncodingDisableUTF8)
        pInfo->dwFlags |= DOCHOSTUIFLAG_URL_ENCODING_DISABLE_UTF8;
    else
        pInfo->dwFlags |= DOCHOSTUIFLAG_URL_ENCODING_ENABLE_UTF8;

    return S_OK;
}

HRESULT CDocHostUIHandler::ShowUI(
    DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
    IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
    IOleInPlaceUIWindow *pDoc)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::ShowUI called");

    // Host did not display its own UI. Trident will proceed to display its own.
    return S_FALSE;
}

HRESULT CDocHostUIHandler::HideUI(void)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::HideUI called");
    // This one is paired with ShowUI
    return S_FALSE;
}

HRESULT CDocHostUIHandler::UpdateUI(void)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::UpdateUI called");
    // LATER: Isn't this equivalent to OLECMDID_UPDATECOMMANDS?
    return S_FALSE;
}

HRESULT CDocHostUIHandler::EnableModeless(BOOL fEnable)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::EnableModeless called");
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::OnDocWindowActivate(BOOL fActivate)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::OnFrameWindowActivate(BOOL fActivate)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::ResizeBorder(
LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::TranslateAccelerator(
LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_FALSE; // The message was not translated
}

HRESULT CDocHostUIHandler::GetOptionKeyPath(BSTR *pbstrKey, DWORD dw)
{
    // Trident will default to its own user options.
    if (!pbstrKey)
        return E_POINTER;
        
    *pbstrKey = NULL;
    return S_FALSE;
}

HRESULT CDocHostUIHandler::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetDropTarget called");
    return E_NOTIMPL;
}

HRESULT CDocHostUIHandler::GetAltExternal(IDispatch **ppDisp)
{
    HRESULT hr = E_FAIL;

    IDocHostUIHandler *pDocHostUIHandler;
    IOleObject        *pOleObject;
    IOleClientSite    *pOleClientSite;

    *ppDisp = NULL;

    //  * QI ourselves for a service provider
    //  * QS for the top level browser's service provider
    //  * Ask for an IOleObject
    //  * Ask the IOleObject for an IOleClientSite
    //  * QI the IOleClientSite for an IDocHostUIHandler
    //  * Call GetExternal on the IDocHostUIHandler to get the IDispatch

    if (SUCCEEDED(IUnknown_QueryServiceForWebBrowserApp(_punkSite, IID_PPV_ARG(IOleObject, &pOleObject))))
    {
        if (SUCCEEDED(pOleObject->GetClientSite(&pOleClientSite)))
        {
            if (SUCCEEDED(pOleClientSite->QueryInterface(IID_PPV_ARG(IDocHostUIHandler, &pDocHostUIHandler))))
            {
                hr = pDocHostUIHandler->GetExternal(ppDisp);
                pDocHostUIHandler->Release();
            }
            pOleClientSite->Release();
        }
        pOleObject->Release();
    }

    return hr;
}

HRESULT CDocHostUIHandler::GetExternal(IDispatch **ppDisp)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetExternal called");

    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (_pExternal)
    {
        *ppDisp = _pExternal;
        (*ppDisp)->AddRef();
        goto Cleanup;
    }

    IDispatch *psuihDisp;
    IDispatch *pAltExternalDisp;

    *ppDisp = NULL;

    GetAltExternal(&pAltExternalDisp);

    hr = CShellUIHelper_CreateInstance2((IUnknown **)&psuihDisp, IID_IDispatch, _punkSite, pAltExternalDisp);
    if (SUCCEEDED(hr))
    {
        *ppDisp = psuihDisp;
        _pExternal = *ppDisp;

        if (pAltExternalDisp)
        {
            //  Don't hold a ref - the ShellUIHelper will do it
            pAltExternalDisp->Release();
        }
    }
    else if (pAltExternalDisp)
    {
        //  Couldn't create a ShellUIHelper but we got our host's
        //  external.
        *ppDisp = pAltExternalDisp;
        _pExternal = *ppDisp;
    }

Cleanup:
    ASSERT((SUCCEEDED(hr) && (*ppDisp)) || (FAILED(hr)));
    return hr;
}


HRESULT CDocHostUIHandler::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::TranslateUrl called");

    return S_FALSE;
}


HRESULT CDocHostUIHandler::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::FilterDataObject called");

    return S_FALSE;
}

HRESULT CDocHostUIHandler::GetOverrideKeyPath(LPOLESTR *pchKey, DWORD dw)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetOverrideKeyPath called");

    return S_FALSE;
}


STDAPI CDocHostUIHandler_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hres = E_OUTOFMEMORY;
    CDocHostUIHandler *pis = new CDocHostUIHandler;
    if (pis)
    {
        *ppunk = SAFECAST(pis, IDocHostUIHandler *);
        hres = S_OK;
    }
    return hres;
}

//==========================================================================
// IOleCommandTarget implementation
//==========================================================================

HRESULT CDocHostUIHandler::QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    if (IsEqualGUID(CGID_DocHostCommandHandler, *pguidCmdGroup))
    {
        ULONG i;

        if (rgCmds == NULL)
            return E_INVALIDARG;

        for (i = 0 ; i < cCmds ; i++)
        {
            // ONLY say that we support the stuff we support in ::Exec
            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_SHOWSCRIPTERROR:
            case OLECMDID_SHOWMESSAGE:
            case OLECMDID_SHOWFIND:
            case OLECMDID_SHOWPAGESETUP:
            case OLECMDID_SHOWPRINT:
            case OLECMDID_PRINTPREVIEW:
            case OLECMDID_PRINT:
            case OLECMDID_PROPERTIES:
            case SHDVID_CLSIDTOMONIKER:
                rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            default:
                rgCmds[i].cmdf = 0;
                break;
            }
        }

        hres = S_OK;
    }

    return hres;
}

HRESULT CDocHostUIHandler::Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (IsEqualGUID(CGID_DocHostCommandHandler, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case OLECMDID_SHOWSCRIPTERROR:
            if (!pvarargIn || !pvarargOut)
                return E_INVALIDARG;

            ShowErrorDialog(pvarargIn, pvarargOut, nCmdexecopt);
            return S_OK;

        case OLECMDID_SHOWMESSAGE:
            if (!pvarargIn || !pvarargOut)
                return E_INVALIDARG;
            else
                return ShowMessage(pvarargIn, pvarargOut, nCmdexecopt);

        case OLECMDID_SHOWFIND:
            if (!pvarargIn)
                return E_INVALIDARG;

            ShowFindDialog(pvarargIn, pvarargOut, nCmdexecopt);
            return S_OK;

        case OLECMDID_SHOWPAGESETUP:
            if (!pvarargIn)
                return E_INVALIDARG;
            else
                return ShowPageSetupDialog(pvarargIn, pvarargOut, nCmdexecopt);

        case IDM_TEMPLATE_PAGESETUP:
            return DoTemplatePageSetup(pvarargIn);

        case OLECMDID_SHOWPRINT:
            if (!pvarargIn)
                return E_INVALIDARG;
            else
                return ShowPrintDialog(pvarargIn, pvarargOut, nCmdexecopt);

        case OLECMDID_PRINTPREVIEW:
            if (!pvarargIn)
                return E_INVALIDARG;
            else
                return DoTemplatePrinting(pvarargIn, pvarargOut, TRUE);

        case OLECMDID_PRINT:
            if (!pvarargIn)
                return E_INVALIDARG;
            else
                return DoTemplatePrinting(pvarargIn, pvarargOut, FALSE);

        case OLECMDID_REFRESH:
            //if print preview is up, tell them we handled refresh 
            //to prevent Trident from refreshing.
            if (m_cPreviewIsUp > 0)
                return S_OK;
            // else do default handling
            break;

        case OLECMDID_PROPERTIES:
            if (!pvarargIn)
                return E_INVALIDARG;
            else
                return ShowPropertysheetDialog(pvarargIn, pvarargOut, nCmdexecopt);

        case SHDVID_CLSIDTOMONIKER:
            if (!pvarargIn || !pvarargOut)
                return E_INVALIDARG;
            else
                return ClsidToMoniker(pvarargIn, pvarargOut);

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }

    return OLECMDERR_E_UNKNOWNGROUP;
}

//+---------------------------------------------------------------------------
//
//  Helper for OLECMDID_SHOWSCRIPTERROR
//
//+---------------------------------------------------------------------------

void CDocHostUIHandler::ShowErrorDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD)
{
    HRESULT hr;
    HWND hwnd;
    IHTMLEventObj * pEventObj = NULL;
    IMoniker * pmk = NULL;
    VARIANT varEventObj;
    TCHAR   szResURL[MAX_URL_STRING];

    ASSERT(V_VT(pvarargIn) == VT_UNKNOWN);
    hr = GetHwndFromUnknown(V_UNKNOWN(pvarargIn), &hwnd);
    if (S_OK != hr)
        goto Cleanup;

    hr = GetEventFromUnknown(V_UNKNOWN(pvarargIn), &pEventObj);
    if (S_OK != hr)
        goto Cleanup;

    hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                           HINST_THISDLL,
                           ML_CROSSCODEPAGE,
                           TEXT("error.dlg"),
                           szResURL,
                           ARRAYSIZE(szResURL),
                           TEXT("shdocvw.dll"));
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = CreateURLMoniker(NULL, szResURL, &pmk);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&varEventObj) = VT_DISPATCH;
    V_DISPATCH(&varEventObj) = pEventObj;

    ShowHTMLDialog(hwnd, pmk, &varEventObj, NULL, pvarargOut);

Cleanup:
    ATOMICRELEASE(pEventObj);
    ATOMICRELEASE(pmk);
}

//+---------------------------------------------------------------------------
//
//  Callback procedure for OLECMDID_SHOWMESSAGE dialog
//
//+---------------------------------------------------------------------------
struct MSGBOXCALLBACKINFO
{
    DWORD   dwHelpContext;
    TCHAR * pstrHelpFile;
    HWND    hwnd;
};

static void CALLBACK
MessageBoxCallBack(HELPINFO *phi)
{
    MSGBOXCALLBACKINFO  *p = (MSGBOXCALLBACKINFO *)phi->dwContextId;
    BOOL                fRet;

    fRet = WinHelp(
            p->hwnd,
            p->pstrHelpFile,
            HELP_CONTEXT,
            p->dwHelpContext);

    THR(fRet ? S_OK : E_FAIL);
}

//+---------------------------------------------------------------------------
//
//  Helper for OLECMDID_SHOWMESSAGE
//
//+---------------------------------------------------------------------------

HRESULT
CDocHostUIHandler::ShowMessage(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD)
{

// must match order of MessageEnum
static const SExpandoInfo s_aMessageExpandos[] =
{
    {TEXT("messageText"),         VT_BSTR},
    {TEXT("messageCaption"),      VT_BSTR},
    {TEXT("messageStyle"),        VT_UI4},
    {TEXT("messageHelpFile"),     VT_BSTR},
    {TEXT("messageHelpContext"),  VT_UI4}
};

    HRESULT             hr;
    HWND                hwnd = NULL;
    MSGBOXCALLBACKINFO  mcbi;
    MSGBOXPARAMS        mbp = {0};
    LRESULT             plResult = 0;
    LPOLESTR            lpstrText = NULL;
    LPOLESTR            lpstrCaption = NULL;
    DWORD               dwType = 0;
    LPOLESTR            lpstrHelpFile = NULL;
    DWORD               dwHelpContext = 0;

    IHTMLEventObj     * pEventObj = NULL;
    const int           cExpandos = ARRAYSIZE(s_aMessageExpandos);
    DISPID              aDispid[cExpandos];
    VARIANT             aVariant[cExpandos];
    int                 i;
    ULONG_PTR uCookie = 0;

    ASSERT(pvarargIn && pvarargOut);

    for (i=0; i<cExpandos; i++)
        VariantInit(aVariant + i);

    ASSERT(V_VT(pvarargIn) == VT_UNKNOWN);
    if ((V_VT(pvarargIn) != VT_UNKNOWN) || !V_UNKNOWN(pvarargIn))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    GetHwndFromUnknown(V_UNKNOWN(pvarargIn), &hwnd);  // hwnd can be NULL
    hr = GetEventFromUnknown(V_UNKNOWN(pvarargIn), &pEventObj);
    if (S_OK != hr)
        goto Cleanup;

    // Get parameters from event object
    hr = GetParamsFromEvent(
            pEventObj,
            cExpandos,
            aDispid,
            aVariant,
            s_aMessageExpandos);
    if (S_OK != hr)
        goto Cleanup;

    // Copy values from variants
    lpstrText = V_BSTR(&aVariant[MessageText]);
    lpstrCaption = V_BSTR(&aVariant[MessageCaption]);
    dwType = V_UI4(&aVariant[MessageStyle]);
    lpstrHelpFile = V_BSTR(&aVariant[MessageHelpFile]);
    dwHelpContext = V_UI4(&aVariant[MessageHelpContext]);

    // Set message box callback info
    mcbi.dwHelpContext = dwHelpContext;
    mcbi.pstrHelpFile = lpstrHelpFile;
    mcbi.hwnd = hwnd;

    // Set message box params
    mbp.cbSize = sizeof(mbp);
    mbp.hwndOwner = hwnd;           // It is okay if this is NULL
    mbp.hInstance = MLGetHinst();
    mbp.lpszText = lpstrText;
    mbp.lpszCaption = lpstrCaption;
    mbp.dwContextHelpId = (DWORD_PTR) &mcbi;
    mbp.lpfnMsgBoxCallback = MessageBoxCallBack;
    // mbp.dwLanguageID = ?
    mbp.dwStyle = dwType;

    if (dwHelpContext && lpstrHelpFile)
        mbp.dwStyle |= MB_HELP;

    if (mbp.hwndOwner == NULL)
        mbp.dwStyle |= MB_TASKMODAL;

    SHActivateContext(&uCookie);
    plResult = MessageBoxIndirect(&mbp);
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

Cleanup:
    V_VT(pvarargOut) = VT_I4;
    V_I4(pvarargOut) = (LONG)plResult;

    for (i=0; i<cExpandos; i++)
        VariantClear(&aVariant[i]);

    ATOMICRELEASE(pEventObj);

    return hr;
}


BOOL CDocHostUIHandler::IsFindDialogUp(IWebBrowser2* pwb, IHTMLWindow2** ppWindow)
{
    BOOL fRet = FALSE;
    BSTR bstrName = SysAllocString(STR_FIND_DIALOG_NAME);
    if (bstrName)
    {
        VARIANT var = {0};
        pwb->GetProperty(bstrName, &var);

        if ( (var.vt == VT_DISPATCH) && (var.pdispVal != NULL) )
        {
            if (ppWindow)
            {
                *ppWindow = (IHTMLWindow2*)var.pdispVal;
                (*ppWindow)->AddRef();
            }
            fRet = TRUE;
        }

        VariantClear(&var);
        SysFreeString(bstrName);
    }

    if (!fRet && ppWindow)
        *ppWindow = NULL;

    return fRet;
}

HRESULT SetFindDialogProperty(IWebBrowser2* pwb, VARIANT* pvar)
{
    HRESULT hr;
    BSTR bstrName = SysAllocString(STR_FIND_DIALOG_NAME);
    if (bstrName)
    {
        hr = pwb->PutProperty(bstrName, *pvar);

        SysFreeString(bstrName);
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

//if this fails, then we have no choice but to orphan the dialog
HRESULT SetFindDialogUp(IWebBrowser2* pwb, IHTMLWindow2* pWindow)
{
    VARIANT var;
    var.vt = VT_DISPATCH;
    var.pdispVal = pWindow;
    return SetFindDialogProperty(pwb, &var);
}

void ReleaseFindDialog(IWebBrowser2* pwb)
{
    VARIANT var = {0};
    SetFindDialogProperty(pwb, &var);
}


//+---------------------------------------------------------------------------
//
//  Helper for OLECMDID_SHOWFIND
//
//  pvarargIn - IDispatch Interface
//  dwflags   - bidi flag
//+---------------------------------------------------------------------------

void
CDocHostUIHandler::ShowFindDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD dwflags)
{
    IDispatch             * pDispatch = NULL;
    IHTMLOptionsHolder    * pHTMLOptionsHolder = NULL;
    IHTMLDocument2        * pHTMLDocument2 = NULL;
    IHTMLWindow2          * pHTMLWindow2 = NULL;
    IOleInPlaceFrame      * pOleInPlaceFrame = NULL;
    HWND                    hwnd = NULL;
    IMoniker              * pmk = NULL;

    if (EVAL(V_VT(pvarargIn) == VT_DISPATCH))
    {
        pDispatch = V_DISPATCH(pvarargIn);
        
        if (SUCCEEDED(pDispatch->QueryInterface(IID_PPV_ARG(IHTMLOptionsHolder, &pHTMLOptionsHolder))))
        {
            if (SUCCEEDED(pHTMLOptionsHolder->get_document(&pHTMLDocument2)) && pHTMLDocument2)
            {
                if (SUCCEEDED(pHTMLDocument2->get_parentWindow(&pHTMLWindow2)))
                {
                    if (SUCCEEDED(GetInPlaceFrameFromUnknown(pHTMLDocument2, &pOleInPlaceFrame)))
                    {
                        if (SUCCEEDED(pOleInPlaceFrame->GetWindow(&hwnd)))
                        {
                            BOOL fInBrowser = FALSE;
                            IWebBrowser2 * pwb2 = NULL;

                            if (SUCCEEDED(IUnknown_QueryServiceForWebBrowserApp(_punkSite, IID_PPV_ARG(IWebBrowser2, &pwb2))))
                            {
                                fInBrowser = TRUE;
                            }

                            TCHAR   szResURL[MAX_URL_STRING];

                            if (SUCCEEDED(MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                                            HINST_THISDLL,
                                                            ML_CROSSCODEPAGE,
                                                            (dwflags ? TEXT("bidifind.dlg") : TEXT("find.dlg")),
                                                            szResURL,
                                                            ARRAYSIZE(szResURL),
                                                            TEXT("shdocvw.dll"))))
                            {
                                CreateURLMoniker(NULL, szResURL, &pmk);

                                if (fInBrowser)
                                {
                                    IHTMLWindow2 *pWinOut;

                                    if (!IsFindDialogUp(pwb2, &pWinOut))
                                    {
                                        ASSERT(NULL==pWinOut);

                                        if ((NULL != pvarargIn) && 
                                            (VT_DISPATCH == pvarargIn->vt) &&
                                            (NULL != pvarargIn->pdispVal))
                                        {
                                            BSTR bstrFindText = GetFindText(pwb2);
                                            if (bstrFindText)
                                            {
                                                //  paranoia since we hang on to this object
                                                //  a while and there is always potential 
                                                //  for mess ups below where we mean to
                                                //  release it.
                                                ATOMICRELEASE(_pOptionsHolder);

                                                pvarargIn->pdispVal->QueryInterface(
                                                                     IID_PPV_ARG(IHTMLOptionsHolder,
                                                                     &_pOptionsHolder));
                                                if (_pOptionsHolder)
                                                    _pOptionsHolder->put_findText(bstrFindText);
                                                
                                                SysFreeString(bstrFindText);
                                            }
                                        }

                                        ShowModelessHTMLDialog(hwnd, pmk, pvarargIn, NULL, &pWinOut);

                                        if (pWinOut)
                                        {
                                            //can't really handle failure here, because the dialog is already up.
                                            BSTR bstrOnunload = SysAllocString(L"onunload");
                                            if (bstrOnunload)
                                            {
                                                IHTMLWindow3 * pWin3;
                                                if (SUCCEEDED(pWinOut->QueryInterface(IID_PPV_ARG(IHTMLWindow3, &pWin3))))
                                                {
                                                    VARIANT_BOOL varBool;
                                                    if (SUCCEEDED(pWin3->attachEvent(bstrOnunload, (IDispatch*)this, &varBool)))
                                                    {
                                                        // on SetFindDialogUp success, the property holds the ref on pWinOut
                                                        if (FAILED(SetFindDialogUp(pwb2, pWinOut)))
                                                        {
                                                            // No way to handle the event, so detach
                                                            pWin3->detachEvent(bstrOnunload, (IDispatch*)this);
                                                        }
                                                    }

                                                    pWin3->Release();
                                                }
                                                SysFreeString(bstrOnunload);
                                            }

                                            // REVIEW: the old code leaked this ref if the property
                                            // wasn't attached in SetFindDialogUp...
                                            pWinOut->Release();
                                        }        
                                    }
                                    else
                                    {
                                        //since the find dialog is already up, send focus to it
                                        pWinOut->focus();
                                        pWinOut->Release();
                                    }
                                }
                                else
                                {
                                    //we're not in the browser, so just show it modal
                                    ShowHTMLDialog(hwnd, pmk, pvarargIn, NULL, NULL);
                                }
                                if (pmk)
                                    pmk->Release();
                            }
                            ATOMICRELEASE(pwb2);

                        }
                        pOleInPlaceFrame->Release();
                    }
                    pHTMLWindow2->Release();
                }
                pHTMLDocument2->Release();
            }
            pHTMLOptionsHolder->Release();
        }
    }

    //pWinOut gets released in CDocHostUIHandler::Invoke() or CIEFrameAuto::COmWindow::ViewReleased(),
    // in response to the onunload event.
    
    if (pvarargOut)
        VariantInit(pvarargOut);
}

//+---------------------------------------------------------------------------
//
//  Callback procedure for OLECMDID_SHOWPAGESETUP dialog
//
//+---------------------------------------------------------------------------
struct PAGESETUPBOXCALLBACKINFO
{
    TCHAR   strHeader[1024];
    TCHAR   strFooter[1024];
};

UINT_PTR APIENTRY
PageSetupHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    HKEY    keyPageSetup = NULL;

    switch (uiMsg)
    {
    case WM_INITDIALOG:
        PAGESETUPBOXCALLBACKINFO * ppscbi;
        ppscbi = (PAGESETUPBOXCALLBACKINFO *) ((PAGESETUPDLG*)lParam)->lCustData;
        SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)ppscbi);

        SendDlgItemMessage(hdlg,IDC_EDITHEADER, EM_LIMITTEXT, ARRAYSIZE(ppscbi->strHeader)-1, 0L);
        SendDlgItemMessage(hdlg,IDC_EDITFOOTER, EM_LIMITTEXT, ARRAYSIZE(ppscbi->strFooter)-1, 0L);

        SetDlgItemText(hdlg,IDC_EDITHEADER, ppscbi->strHeader);
        SetDlgItemText(hdlg,IDC_EDITFOOTER, ppscbi->strFooter);
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
            {
                PAGESETUPBOXCALLBACKINFO * ppscbi;
                ppscbi = (PAGESETUPBOXCALLBACKINFO *) GetWindowLongPtr(hdlg, DWLP_USER);
                if (ppscbi)
                {
                    GetDlgItemText(hdlg,IDC_EDITHEADER, ppscbi->strHeader, ARRAYSIZE(ppscbi->strHeader));
                    GetDlgItemText(hdlg,IDC_EDITFOOTER, ppscbi->strFooter, ARRAYSIZE(ppscbi->strFooter));
                }
            }
        }
        break;

   case WM_HELP:
   {
        LPHELPINFO pHI = (LPHELPINFO)lParam;
        if (pHI->iContextType == HELPINFO_WINDOW)   // must be for a control
        {
            WinHelp(
                    (HWND)pHI->hItemHandle,
                    GetHelpFile(pHI->iCtrlId, (DWORD *)aPageSetupDialogHelpIDs),
                    HELP_WM_HELP,
                    (DWORD_PTR)(LPVOID) aPageSetupDialogHelpIDs);
        }
        break;
        //return TRUE;
    }

    case WM_CONTEXTMENU:
    {
        int CtrlID = GetControlID((HWND)wParam, lParam);

        WinHelp(
                (HWND)wParam,
                GetHelpFile(CtrlID, (DWORD *)aPageSetupDialogHelpIDs),
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) aPageSetupDialogHelpIDs);
        break;
    }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Helper for OLECMDID_SHOWPAGESETUP
//
//  pvarargIn - holds IHTMLEventObj * for the event
//
// Returns S_FALSE if the user clicked Cancel and S_TRUE if the user
// clicked OK.
//+---------------------------------------------------------------------------

HRESULT
CDocHostUIHandler::ShowPageSetupDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD)
{

// must match order of PagesetupEnum
static const SExpandoInfo s_aPagesetupExpandos[] =
{
    {OLESTR("pagesetupHeader"),  VT_BSTR},
    {OLESTR("pagesetupFooter"),  VT_BSTR},
    {OLESTR("pagesetupStruct"),  VT_PTR}
};

    HRESULT                         hr = E_FAIL;
    PAGESETUPDLG                  * ppagesetupdlg = NULL;
    PAGESETUPBOXCALLBACKINFO        pagesetupcbi;

    IHTMLEventObj                 * pEventObj = NULL;
    const int                       cExpandos = ARRAYSIZE(s_aPagesetupExpandos);
    DISPID                          aDispid[cExpandos];
    VARIANT                         aVariant[cExpandos];
    int                             i;
    ULONG_PTR uCookie = 0;

    for (i=0; i<cExpandos; i++)
        VariantInit(aVariant+i);

    ASSERT(pvarargIn && (V_VT(pvarargIn) == VT_UNKNOWN));
    if ((V_VT(pvarargIn) != VT_UNKNOWN) || !V_UNKNOWN(pvarargIn))
        goto Cleanup;

    if (V_UNKNOWN(pvarargIn)->QueryInterface(IID_PPV_ARG(IHTMLEventObj, &pEventObj)))
        goto Cleanup;

    // Get parameters from event object
    if (GetParamsFromEvent(
            pEventObj,
            cExpandos,
            aDispid,
            aVariant,
            s_aPagesetupExpandos))
        goto Cleanup;

    // Copy values from variants
    StrCpyN(pagesetupcbi.strHeader,
        V_BSTR(&aVariant[PagesetupHeader]) ? V_BSTR(&aVariant[PagesetupHeader]) : TEXT(""),
        ARRAYSIZE(pagesetupcbi.strHeader));
    StrCpyN(pagesetupcbi.strFooter,
        V_BSTR(&aVariant[PagesetupFooter]) ? V_BSTR(&aVariant[PagesetupFooter]) : TEXT(""),
        ARRAYSIZE(pagesetupcbi.strHeader));

    ppagesetupdlg = (PAGESETUPDLG *)V_BYREF(&aVariant[PagesetupStruct]);
    if (!ppagesetupdlg)
        goto Cleanup;

    // Set up custom dialog resource fields in pagesetupdlg
    ppagesetupdlg->Flags |= PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGESETUPTEMPLATE;
    ppagesetupdlg->lCustData = (LPARAM) &pagesetupcbi;
    ppagesetupdlg->lpfnPageSetupHook = PageSetupHookProc;
    ppagesetupdlg->hInstance = MLLoadShellLangResources();

    ppagesetupdlg->lpPageSetupTemplateName = MAKEINTRESOURCE(PAGESETUPDLGORD);

    // Show dialog
    SHActivateContext(&uCookie);
    if (!PageSetupDlg(ppagesetupdlg))
    {
        // treat failure as canceling
        hr = S_FALSE;
        goto Cleanup;
    }
    hr = S_OK;

    // Save header/footer in event object
    VARIANT var;

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = SysAllocString(pagesetupcbi.strHeader ? pagesetupcbi.strHeader : TEXT(""));
    if (NULL != V_BSTR(&var))
    {
        PutParamToEvent(aDispid[PagesetupHeader], &var, pEventObj);
        VariantClear(&var);
    }

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = SysAllocString(pagesetupcbi.strFooter ? pagesetupcbi.strFooter : TEXT(""));
    if (NULL != V_BSTR(&var))
    {
        PutParamToEvent(aDispid[PagesetupFooter], &var, pEventObj);
        VariantClear(&var);
    }

Cleanup:
    if (ppagesetupdlg)
        MLFreeLibrary(ppagesetupdlg->hInstance);

    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    for (i=0; i<cExpandos; i++)
        VariantClear(&aVariant[i]);

    if (pvarargOut)
        VariantInit(pvarargOut);

    ATOMICRELEASE(pEventObj);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Callback procedure for OLECMDID_SHOWPRINT dialog
//
//+---------------------------------------------------------------------------

static void SetPreviewBitmap(long bitmapID, HWND hdlg);
HRESULT GetPrintFileName(HWND hwnd, TCHAR achFilePath[], int cchFilePath);

struct PRINTBOXCALLBACKINFO
{
    BOOL    fRootDocumentHasFrameset;
    BOOL    fAreRatingsEnabled;
    BOOL    fPrintActiveFrameEnabled;
    BOOL    fPrintActiveFrame;
    BOOL    fPrintLinked;
    BOOL    fPrintSelection;
    BOOL    fPrintAsShown;
    BOOL    fShortcutTable;
    int     iFontScaling;
    IOleCommandTarget * pBodyActive;
};

// Common handling functions for both NT 5 and legacy print dialogs
void OnInitDialog( HWND hdlg, PRINTBOXCALLBACKINFO * ppcbi )
{
    if (ppcbi)
    {
        // Three scenarioes:
        // 1.  Base case: Not FRAMESET, no IFRAMES.  No frameoptions should be available.
        // 2.  FRAMESET:  Obey all frameoptions.  Any may be available.
        // 3.  IFRAME:    May have selected frame available.  If so, make selecetd frame & as laid out avail.
        
        // Should the active frame be disabled?
        if (!ppcbi->fPrintActiveFrameEnabled)
        {
            // Disable "print selected frame" radiobutton.
            HWND hwndPrintActiveFrame =  GetDlgItem(hdlg, rad5);
            EnableWindow(hwndPrintActiveFrame, FALSE);
        }

        // If there is no frameset, disable "print all frames" radiobutton.
        if (!ppcbi->fRootDocumentHasFrameset)
        {
            HWND hwndPrintAllFrames = GetDlgItem(hdlg, rad6);
            EnableWindow(hwndPrintAllFrames, FALSE);

            if (!ppcbi->fPrintActiveFrameEnabled)
            {
                // We're not a FRAMESET and don't have IFRAMEs
                // Disable "print as laid out on screen" radiobutton.
                HWND hwndPrintAsLaidOutOnScreen = GetDlgItem(hdlg, rad4);
                EnableWindow(hwndPrintAsLaidOutOnScreen, FALSE);
                SetPreviewBitmap(IDR_PRINT_PREVIEWDISABLED, hdlg);                
            }
        }

        // Setup default radio button to be checked.
        // NOTE: We currently allow the template to check options that are disabled.
        if (ppcbi->fPrintActiveFrame)
        {
            // Check "print selected frame" radiobutton.
            CheckRadioButton(hdlg, rad4, rad6, rad5);
            SetPreviewBitmap(IDR_PRINT_PREVIEWONEDOC, hdlg);
        }
        else if (ppcbi->fPrintAsShown)
        {
            // Check "print frames as laid out" radiobutton.
            CheckRadioButton(hdlg, rad4, rad6, rad4);
            SetPreviewBitmap(IDR_PRINT_PREVIEW, hdlg);
        }
        else
        {
            // Check "print all frames" radiobutton.
            CheckRadioButton(hdlg, rad4, rad6, rad6);
            SetPreviewBitmap(IDR_PRINT_PREVIEWALLDOCS, hdlg);
        }


        HWND hwndSelection = GetDlgItem(hdlg, rad2);
        if (hwndSelection) EnableWindow(hwndSelection, (ppcbi->fPrintSelection));

#ifdef FONTSIZE_BOX
        int i=0, cbLen=0;

        //bugwin16: need to fix this.
        for (i = 0; i < IDS_PRINT_FONTMAX; i++)
        {
            TCHAR   achBuffer[128];

            cbLen = MLLoadShellLangString(IDS_PRINT_FONTSCALE+i,achBuffer,127);
            if (cbLen)
            {
                SendDlgItemMessage(hdlg, IDC_SCALING, CB_ADDSTRING, 0, (long) achBuffer);
            }
        }

        if (i>0)
        {
            SendDlgItemMessage(hdlg, IDC_SCALING, CB_SETCURSEL, IDS_PRINT_FONTMAX - 1 - ppcbi->iFontScaling, 0);
        }
#endif // FONTSIZE_BOX

        // If ratings are enabled, don't allow recursive printing.
        if (ppcbi->fAreRatingsEnabled)
        {
            HWND hwndPrintLinkedDocuments = GetDlgItem(hdlg, IDC_LINKED);
            CheckDlgButton(hdlg, IDC_LINKED, BST_UNCHECKED);
            EnableWindow(hwndPrintLinkedDocuments, FALSE);
        }
    }
}

void OnCommand( HWND hdlg, WPARAM wParam, LPARAM lParam )
{
    PRINTBOXCALLBACKINFO * ppcbi;
    ppcbi = (PRINTBOXCALLBACKINFO *)GetWindowLongPtr(hdlg, DWLP_USER);

    if (!ppcbi)
    {
        return;
    }

    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
    case rad1:         // "Print all"
    case rad3:         // "Print range"
    case rad2:         // "Print selection" (text selection)
      {
        // If we are printing a text selection, and we have a selected frame,
        // force a print selected frame.
        if (ppcbi && ppcbi->fPrintActiveFrame && ppcbi->fPrintSelection)
        {
            HWND hwndPrintWhatGroup = GetDlgItem(hdlg, grp3);
            HWND hwndPrintActiveFrame = GetDlgItem(hdlg, rad5);
            HWND hwndPrintAllFrames = GetDlgItem(hdlg, rad6);
            HWND hwndPrintSelectedFrame = GetDlgItem(hdlg, rad4);

            if (hwndPrintWhatGroup)     EnableWindow(hwndPrintWhatGroup, LOWORD(wParam) != rad2);
            if (hwndPrintActiveFrame)   EnableWindow(hwndPrintActiveFrame, LOWORD(wParam) != rad2);
            if (hwndPrintAllFrames)     EnableWindow(hwndPrintAllFrames, ppcbi->fRootDocumentHasFrameset && LOWORD(wParam) != rad2);
            if (hwndPrintSelectedFrame) EnableWindow(hwndPrintSelectedFrame, LOWORD(wParam) != rad2);

        }

        break;
      }

    case rad4:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            // now change the icon...

            SetPreviewBitmap(IDR_PRINT_PREVIEW, hdlg);
            HWND hwnd = GetDlgItem(hdlg, rad2);
            if (hwnd) EnableWindow(hwnd, FALSE);
            hwnd = GetDlgItem(hdlg, IDC_SHORTCUTS);
            if (hwnd) EnableWindow(hwnd, FALSE);
            hwnd = GetDlgItem(hdlg, IDC_LINKED);
            if (hwnd) EnableWindow(hwnd, FALSE);
   //         if (ppcbi->pBodyActive);
   //             ppcbi->pBodyActive->Layout()->LockFocusRect(FALSE);
        }
        break;

    case rad5:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            // now change the icon

            SetPreviewBitmap(IDR_PRINT_PREVIEWONEDOC, hdlg);
            HWND hwnd = GetDlgItem(hdlg, rad2);
            if (hwnd) EnableWindow(hwnd, (ppcbi->fPrintSelection));
            hwnd = GetDlgItem(hdlg, IDC_SHORTCUTS);
            if (hwnd) EnableWindow(hwnd, TRUE);
            hwnd = GetDlgItem(hdlg, IDC_LINKED);
            if (hwnd) EnableWindow(hwnd, TRUE);
   //         if (ppcbi->pBodyActive);
   //             ppcbi->pBodyActive->Layout()->LockFocusRect(TRUE);
        }
        break;

    case rad6:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            // now change the icon

            SetPreviewBitmap(IDR_PRINT_PREVIEWALLDOCS, hdlg);
            HWND hwnd = GetDlgItem(hdlg, rad2);
            if (hwnd) EnableWindow(hwnd, FALSE);
            hwnd = GetDlgItem(hdlg, IDC_SHORTCUTS);
            if (hwnd) EnableWindow(hwnd, TRUE);
            hwnd = GetDlgItem(hdlg, IDC_LINKED);
            if (hwnd) EnableWindow(hwnd, TRUE);
   //         if (ppcbi->pBodyActive);
   //             ppcbi->pBodyActive->Layout()->LockFocusRect(FALSE);
        }
        break;
    }
}

void OnHelp( HWND hdlg, WPARAM wParam, LPARAM lParam )
{
    LPHELPINFO pHI = (LPHELPINFO)lParam;
    if (pHI->iContextType == HELPINFO_WINDOW)   // must be for a control
    {
        WinHelp(
                (HWND)pHI->hItemHandle,
                GetHelpFile(pHI->iCtrlId, (DWORD *) aPrintDialogHelpIDs),
                HELP_WM_HELP,
                (DWORD_PTR)(LPVOID) aPrintDialogHelpIDs);
    }
}

void OnContextMenu( HWND hdlg, WPARAM wParam, LPARAM lParam )
{
    int CtrlID = GetControlID((HWND)wParam, lParam);

    WinHelp(
            (HWND)wParam,
            GetHelpFile(CtrlID, (DWORD *) aPrintDialogHelpIDs),
            HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID) aPrintDialogHelpIDs);
}

void OnApplyOrOK( HWND hdlg, WPARAM wParam, LPARAM lParam )
{
    PRINTBOXCALLBACKINFO * ppcbi = (PRINTBOXCALLBACKINFO *)GetWindowLongPtr(hdlg, DWLP_USER);
    if (ppcbi)
    {
        ppcbi->fPrintLinked      = IsDlgButtonChecked(hdlg, IDC_LINKED);
        ppcbi->fPrintSelection   = IsDlgButtonChecked(hdlg, rad2);
        ppcbi->fPrintActiveFrame = IsDlgButtonChecked(hdlg, rad5) ||
                                       ( ppcbi->fPrintSelection &&
                                         ppcbi->fRootDocumentHasFrameset
                                        );
        ppcbi->fPrintAsShown     = IsDlgButtonChecked(hdlg, rad4) ||
                                       ( ppcbi->fPrintSelection &&
                                         ppcbi->fRootDocumentHasFrameset
                                        );
        ppcbi->fShortcutTable    = IsDlgButtonChecked(hdlg, IDC_SHORTCUTS);
#ifdef FONTSIZE_BOX
        ppcbi->iFontScaling      = IDS_PRINT_FONTMAX - 1 - SendDlgItemMessage( hdlg, IDC_SCALING, CB_GETCURSEL, 0,0 );
#endif
    }

}
// This is the callback routine (and dlgproc) for the options
// page in the NT 5 print dialog.
INT_PTR APIENTRY
OptionsPageProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg)
    {
    case WM_INITDIALOG:
    {
        PRINTBOXCALLBACKINFO * ppcbi;
        ppcbi = (PRINTBOXCALLBACKINFO *) ((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)ppcbi);

        OnInitDialog( hdlg, ppcbi );
        break;
    }

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_APPLY:
            OnApplyOrOK( hdlg, wParam, lParam );
            SetWindowLongPtr (hdlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr (hdlg, DWLP_MSGRESULT, FALSE);
            return 1;
            break;

        case PSN_RESET:
            SetWindowLongPtr (hdlg, DWLP_MSGRESULT, FALSE);
            break;
        }
        break;

    case WM_COMMAND:
        OnCommand( hdlg, wParam, lParam );
        break;

    case WM_HELP:
        OnHelp( hdlg, wParam, lParam );
        break;

    case WM_CONTEXTMENU:
        OnContextMenu( hdlg, wParam, lParam );
        break;
    }

    return FALSE;

}


UINT_PTR CALLBACK
PrintHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg)
    {
    case WM_INITDIALOG:
        if (lParam)
        {
            PRINTBOXCALLBACKINFO * ppcbi;
            ppcbi = (PRINTBOXCALLBACKINFO *) ((PRINTDLG*)lParam)->lCustData;
            SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)ppcbi);

            OnInitDialog( hdlg, ppcbi );
        }
        return TRUE;

    case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDOK:
                OnApplyOrOK( hdlg, wParam, lParam );
                break;

            default:
                OnCommand( hdlg, wParam, lParam );
                break;
            }
        }
        break;

    case WM_HELP:
        OnHelp( hdlg, wParam, lParam );
        break;
        //return TRUE;

    case WM_CONTEXTMENU:
        OnContextMenu( hdlg, wParam, lParam );
        break;

    case WM_DESTROY:
    {
        PRINTBOXCALLBACKINFO * ppcbi = (PRINTBOXCALLBACKINFO *)GetWindowLongPtr(hdlg, DWLP_USER);
        ASSERT(ppcbi);
        break;
    }
    }

    return FALSE;
}

void SetPreviewBitmap(long bitmapID, HWND hdlg)
{
    // now change the icon...(note these bitmaps are not localized)
    HBITMAP hNewBitmap = (HBITMAP) LoadImage(HINST_THISDLL, MAKEINTRESOURCE(bitmapID),
                           IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_LOADMAP3DCOLORS );
    if (hNewBitmap)
    {
        HBITMAP hOldBitmap = (HBITMAP) SendDlgItemMessage(hdlg, IDC_PREVIEW, STM_SETIMAGE,
                                                  (WPARAM) IMAGE_BITMAP, (LPARAM) hNewBitmap);

        if (hOldBitmap)
        {
            //VERIFY(DeleteObject(hOldBitmap)!=0);
            int i;
            i = DeleteObject(hOldBitmap);
            ASSERT(i!=0);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Helper for OLECMDID_SHOWPRINT
//
//+---------------------------------------------------------------------------

HRESULT
CDocHostUIHandler::ShowPrintDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD)
{

// the following must match the order of PrintEnum
static const SExpandoInfo s_aPrintExpandos[] =
{
    {OLESTR("printfRootDocumentHasFrameset"),   VT_BOOL},
    {OLESTR("printfAreRatingsEnabled"),         VT_BOOL},
    {OLESTR("printfActiveFrame"),               VT_BOOL},
    {OLESTR("printfLinked"),                    VT_BOOL},
    {OLESTR("printfSelection"),                 VT_BOOL},
    {OLESTR("printfAsShown"),                   VT_BOOL},
    {OLESTR("printfShortcutTable"),             VT_BOOL},
    {OLESTR("printiFontScaling"),               VT_INT},
    {OLESTR("printpBodyActiveTarget"),          VT_UNKNOWN},
    {OLESTR("printStruct"),                     VT_PTR},
    {OLESTR("printToFileOk"),                   VT_BOOL},
    {OLESTR("printToFileName"),                 VT_BSTR},
    {OLESTR("printfActiveFrameEnabled"),        VT_BOOL},
};

    HRESULT                         hr = E_FAIL;
    PRINTDLG                      * pprintdlg = NULL;
    PRINTBOXCALLBACKINFO            printcbi;

    IHTMLEventObj                 * pEventObj = NULL;
    const int                       cExpandos = ARRAYSIZE(s_aPrintExpandos);
    DISPID                          aDispid[cExpandos];
    VARIANT                         aVariant[cExpandos];
    int                             i;
    DWORD                           dwErr = 0;

    printcbi.pBodyActive = NULL;

    if (!V_UNKNOWN(pvarargIn))
        goto Cleanup;

    if (V_UNKNOWN(pvarargIn)->QueryInterface(IID_PPV_ARG(IHTMLEventObj, &pEventObj)))
        goto Cleanup;

    // Get parameters from event object
    if (GetParamsFromEvent(
            pEventObj,
            cExpandos,
            aDispid,
            aVariant,
            s_aPrintExpandos))
        goto Cleanup;

    // Copy values from variants
    printcbi.fRootDocumentHasFrameset   = V_BOOL(&aVariant[PrintfRootDocumentHasFrameset]);
    printcbi.fAreRatingsEnabled         = V_BOOL(&aVariant[PrintfAreRatingsEnabled]);
    printcbi.fPrintActiveFrame          = V_BOOL(&aVariant[PrintfPrintActiveFrame]);
    printcbi.fPrintActiveFrameEnabled   = V_BOOL(&aVariant[PrintfPrintActiveFrameEnabled]);
    printcbi.fPrintLinked               = V_BOOL(&aVariant[PrintfPrintLinked]);
    printcbi.fPrintSelection            = V_BOOL(&aVariant[PrintfPrintSelection]);
    printcbi.fPrintAsShown              = V_BOOL(&aVariant[PrintfPrintAsShown]);
    printcbi.fShortcutTable             = V_BOOL(&aVariant[PrintfShortcutTable]);
    printcbi.iFontScaling               = V_INT(&aVariant[PrintiFontScaling]);

    // If we ever get LockFocusRect, use this field to access it
    // peterlee 8/7/98
    /*
    if (V_UNKNOWN(&aVariant[PrintpBodyActiveTarget]))
    {
        if (V_UNKNOWN(&aVariant[PrintpBodyActiveTarget])->QueryInterface(IID_IOleCommandTarget,
                (void**)&printcbi.pBodyActive))
            goto Cleanup;
    }
    */

    pprintdlg = (PRINTDLG *)V_BYREF(&aVariant[PrintStruct]);
    if (!pprintdlg)
        goto Cleanup;

    // Fix up requested page range so it's within bounds.  The dialog will
    // fail to initialize under W95 if this isn't done.
    if ( pprintdlg->nFromPage < pprintdlg->nMinPage )
        pprintdlg->nFromPage = pprintdlg->nMinPage;
    else if ( pprintdlg->nFromPage > pprintdlg->nMaxPage )
        pprintdlg->nFromPage = pprintdlg->nMaxPage;

    if ( pprintdlg->nToPage < pprintdlg->nMinPage )
        pprintdlg->nToPage = pprintdlg->nMinPage;
    else if ( pprintdlg->nToPage > pprintdlg->nMaxPage )
        pprintdlg->nToPage = pprintdlg->nMaxPage;

    // Set up custom dialog resource fields in pagesetupdlg
    pprintdlg->hInstance            = MLLoadShellLangResources();
    pprintdlg->lCustData            = (LPARAM) &printcbi;
    pprintdlg->lpfnPrintHook        = PrintHookProc;
    pprintdlg->lpPrintTemplateName  = MAKEINTRESOURCE(PRINTDLGORD);

    if (g_bRunOnNT5)
    {
        // We want to use the new PrintDlgEx in NT 5, so map all the PrintDlg
        // settings to the new PrintDlgEx, get a pointer to the new function
        // and then call it.

        // Load the function from comdlg32 directly...
        typedef HRESULT (*PFNPRINTDLGEX)(LPPRINTDLGEX pdex);
        PFNPRINTDLGEX pfnPrintDlgEx = NULL;
        HMODULE hComDlg32 = LoadLibrary(TEXT("comdlg32.dll"));
        if (hComDlg32)
        {
            pfnPrintDlgEx = (PFNPRINTDLGEX)GetProcAddress(hComDlg32, "PrintDlgExW");
        }


        // Make sure we can call the function...
        if (!pfnPrintDlgEx)
        {
            if (hComDlg32)
            {
                FreeLibrary(hComDlg32);
            }
            hr = E_FAIL;
            goto Cleanup;
        }

        HPROPSHEETPAGE          pages[1];
        PRINTPAGERANGE          ppr;

        PRINTDLGEX  pdex = {0};
        // Copy over existing settings
        pdex.lStructSize = sizeof(pdex);
        pdex.hwndOwner   = pprintdlg->hwndOwner;
        pdex.hDevMode    = pprintdlg->hDevMode;
        pdex.hDevNames   = pprintdlg->hDevNames;
        pdex.hDC         = pprintdlg->hDC;
        pdex.Flags       = pprintdlg->Flags;
        pdex.nMinPage    = pprintdlg->nMinPage;
        pdex.nMaxPage    = pprintdlg->nMaxPage;
        pdex.nCopies     = pprintdlg->nCopies;

        // New settings
        pdex.nStartPage     = START_PAGE_GENERAL;
        ppr.nFromPage       = pprintdlg->nFromPage;
        ppr.nToPage         = pprintdlg->nToPage;
        pdex.nPageRanges    = 1;
        pdex.nMaxPageRanges = 1;
        pdex.lpPageRanges   = &ppr;

        // Create options page
        PROPSHEETPAGE psp = {0};
        psp.dwSize       = sizeof(psp);
        psp.dwFlags      = PSP_DEFAULT;
        psp.hInstance    = pprintdlg->hInstance;
        psp.pszTemplate  = MAKEINTRESOURCE(IDD_PRINTOPTIONS);
        psp.pfnDlgProc   = OptionsPageProc;
        psp.lParam       = (LPARAM)&printcbi;
       
        pages[0] = SHNoFusionCreatePropertySheetPageW(&psp);

        if (pages[0])
        {

            pdex.nPropertyPages = 1;
            pdex.lphPropertyPages = pages;

            // Show the dialog
            ULONG_PTR uCookie = 0;
            SHActivateContext(&uCookie);
            hr = pfnPrintDlgEx(&pdex);
            if (uCookie)
            {
                SHDeactivateContext(uCookie);
            }
            if (SUCCEEDED(hr))
            {
                hr = S_FALSE;

                if ((pdex.dwResultAction == PD_RESULT_PRINT) || (pdex.Flags & PD_RETURNDEFAULT))
                {
                    // copy back values which might have changed
                    // during the call to PrintDlgEx
                    pprintdlg->Flags     = pdex.Flags;
                    pprintdlg->hDevMode  = pdex.hDevMode;
                    pprintdlg->hDevNames = pdex.hDevNames;
                    pprintdlg->nCopies   = (WORD)pdex.nCopies;
                    pprintdlg->nFromPage = (WORD)ppr.nFromPage;
                    pprintdlg->nToPage   = (WORD)ppr.nToPage;
                    if (pprintdlg->Flags & PD_RETURNDC)
                    {
                        pprintdlg->hDC = pdex.hDC;
                    }

                    hr = S_OK;
                }
                else if ((pdex.Flags & (PD_RETURNDC | PD_RETURNIC)) && pdex.hDC)
                {
                    DeleteDC(pdex.hDC);
                    pdex.hDC = NULL;
                }
            }
            else
            {
                hr = S_FALSE;
            }

            FreeLibrary(hComDlg32);
        }
        else
        {
            FreeLibrary(hComDlg32);
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }



    }
    else
    {
        pprintdlg->Flags |= PD_ENABLEPRINTTEMPLATE | PD_ENABLEPRINTHOOK;
        pprintdlg->Flags &= (~(PD_CURRENTPAGE | PD_NOCURRENTPAGE));         // Just in case, mask out the W2K only.

        // Show dialog
        if (!PrintDlg(pprintdlg))
        {
           // treat failure as canceling
            dwErr = CommDlgExtendedError();
            hr = S_FALSE;
            goto Cleanup;
        }
        hr = S_OK;
    }

    // Write changed values to event object
    VARIANT var;
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = printcbi.fPrintLinked ? VARIANT_TRUE : VARIANT_FALSE;
    PutParamToEvent(aDispid[PrintfPrintLinked], &var, pEventObj);

    V_BOOL(&var) = printcbi.fPrintActiveFrame ? VARIANT_TRUE : VARIANT_FALSE;
    PutParamToEvent(aDispid[PrintfPrintActiveFrame], &var, pEventObj);

    V_BOOL(&var) = printcbi.fPrintAsShown ? VARIANT_TRUE : VARIANT_FALSE;
    PutParamToEvent(aDispid[PrintfPrintAsShown], &var, pEventObj);

    V_BOOL(&var) = printcbi.fShortcutTable ? VARIANT_TRUE : VARIANT_FALSE;
    PutParamToEvent(aDispid[PrintfShortcutTable], &var, pEventObj);

    // now pop up the fileselection dialog and save the filename...
    // this is the only place where we can make this modal
    BOOL fPrintToFileOk;
    fPrintToFileOk = FALSE;
    if ((pprintdlg->Flags & PD_PRINTTOFILE) != 0)
    {
        // Get the save file path from the event object
        TCHAR achPrintToFileName[MAX_PATH];
    
        StrCpyN(achPrintToFileName,
            V_BSTR(&aVariant[PrintToFileName]) ? V_BSTR(&aVariant[PrintToFileName]) : TEXT(""),
            ARRAYSIZE(achPrintToFileName));

        if (SUCCEEDED(GetPrintFileName(pprintdlg->hwndOwner, achPrintToFileName, ARRAYSIZE(achPrintToFileName))) && 
            achPrintToFileName[0])
        {
            fPrintToFileOk = TRUE;
            V_VT(&var) = VT_BSTR;
            V_BSTR(&var) = SysAllocString(achPrintToFileName);
            if (NULL != V_BSTR(&var))
            {
                PutParamToEvent(aDispid[PrintToFileName], &var, pEventObj);
                VariantClear(&var);
            }
        }
    }

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = fPrintToFileOk ? VARIANT_TRUE : VARIANT_FALSE;
    PutParamToEvent(aDispid[PrintToFileOk], &var, pEventObj);

Cleanup:
    if (pprintdlg)
        MLFreeLibrary(pprintdlg->hInstance);

    for (i=0; i<cExpandos; i++)
        VariantClear(&aVariant[i]);

    if (pvarargOut)
        VariantInit(pvarargOut);

    ATOMICRELEASE(pEventObj);
    ATOMICRELEASE(printcbi.pBodyActive);

    return hr;
}


//+---------------------------------------------------------------------------
//
//   Callback procedure for PrintToFile Dialog
//
//+---------------------------------------------------------------------------
UINT_PTR APIENTRY PrintToFileHookProc(HWND hdlg,
                              UINT uiMsg,
                              WPARAM wParam,
                              LPARAM lParam)
{
    switch (uiMsg)
    {
        case WM_INITDIALOG:
        {
            int      cbLen;
            TCHAR    achOK[MAX_PATH];

            // change "save" to "ok"
            cbLen = MLLoadShellLangString(IDS_PRINTTOFILE_OK,achOK,ARRAYSIZE(achOK));
            if (cbLen < 1)
                StrCpyN(achOK, TEXT("OK"), ARRAYSIZE(achOK));

    //        SetDlgItemText(hdlg, IDOK, _T("OK"));
            SetDlgItemText(hdlg, IDOK, achOK);

            // ...and, finally force us into foreground (needed for Win95, Bug : 13368)
            ::SetForegroundWindow(hdlg);
            break;
        }
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetPrintFileName
//
//  Synopsis:   Opens up the customized save file dialog and gets
//              a filename for the printoutput
//  Returns:
//
//----------------------------------------------------------------------------
HRESULT GetPrintFileName(HWND hwnd, TCHAR achFilePath[], int cchFilePath)
{
    int             cbLen;
    TCHAR           achTitlePrintInto[MAX_PATH];
    TCHAR           achFilePrintInto[MAX_PATH];
    TCHAR           achPath[MAX_PATH];

    HRESULT         hr = E_FAIL;

    OPENFILENAME    openfilename = {0};
    openfilename.lStructSize = sizeof(openfilename);
    openfilename.hwndOwner = hwnd;

    cbLen = MLLoadShellLangString(IDS_PRINTTOFILE_TITLE,achTitlePrintInto,ARRAYSIZE(achTitlePrintInto));
    ASSERT (cbLen && "could not load the resource");

    if (cbLen > 0)
        openfilename.lpstrTitle = achTitlePrintInto;

    // guarantee trailing 0 to terminate the filter string
    TCHAR           achFilter[MAX_PATH] = {0};
    cbLen = MLLoadShellLangString(IDS_PRINTTOFILE_SPEC,achFilter,ARRAYSIZE(achFilter)-2);
    ASSERT (cbLen && "could not load the resource");

    if (cbLen>0)
    {
        for (; cbLen >= 0; cbLen--)
        {
            if (achFilter[cbLen]== L',')
            {
                achFilter[cbLen] = 0;
            }
        }
    }

    openfilename.nMaxFileTitle = openfilename.lpstrTitle ? lstrlen(openfilename.lpstrTitle) : 0;
    StrCpyN(achFilePrintInto, TEXT(""), ARRAYSIZE(achFilePrintInto));
    openfilename.lpstrFile = achFilePrintInto;
    openfilename.nMaxFile = ARRAYSIZE(achFilePrintInto);
    openfilename.Flags = OFN_NOREADONLYRETURN | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT |
                        OFN_ENABLEHOOK | OFN_NOCHANGEDIR;
    openfilename.lpfnHook = PrintToFileHookProc;
    openfilename.lpstrFilter = achFilter;
    openfilename.nFilterIndex = 1;

    StrCpyN(achPath, achFilePath, ARRAYSIZE(achPath));
    openfilename.lpstrInitialDir = *achPath ? achPath : NULL;

    if (GetSaveFileName(&openfilename))
    {
        StrCpyN(achFilePath, openfilename.lpstrFile, cchFilePath);
        hr = S_OK;
    }

    if (FAILED(hr))
        *achFilePath = NULL;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Helpers for OLECMDID_PROPERTIES
//
//+---------------------------------------------------------------------------

HRESULT
CDocHostUIHandler::ShowPropertysheetDialog(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, DWORD)
{

// must match order of PropertysheetEnum
static const SExpandoInfo s_aPropertysheetExpandos[] =
{
    {OLESTR("propertysheetPunks"),  VT_SAFEARRAY}
};

    HRESULT             hr;
    HWND                hwnd = NULL;
    HWND                hwndParent;
    IUnknown          * punk = NULL;
    OLECMD              olecmd = {0, 0};
    int                 cUnk = 0;
    IUnknown * HUGEP  * apUnk = NULL;
    OCPFIPARAMS         ocpfiparams = {0};
    CAUUID              ca = { 0, 0 };
    RECT                rc = {0, 0, 0, 0};
    RECT                rcDesktop = {0, 0, 0, 0};
    SIZE                pixelOffset;
    SIZE                metricOffset = {0, 0};

    IHTMLEventObj     * pEventObj = NULL;
    const int           cExpandos = ARRAYSIZE(s_aPropertysheetExpandos);
    VARIANT             aVariant[cExpandos];
    DISPID              aDispid[cExpandos];
    SAFEARRAY         * psafearray = NULL;

    for (int i=0; i<cExpandos; i++)
        VariantInit(&aVariant[i]);

    ASSERT(pvarargIn && V_VT(pvarargIn) == VT_UNKNOWN && V_UNKNOWN(pvarargIn));
    if (!pvarargIn || (V_VT(pvarargIn) != VT_UNKNOWN) || !V_UNKNOWN(pvarargIn))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get the hwnd
    punk = V_UNKNOWN(pvarargIn);
    hr = GetHwndFromUnknown(punk, &hwnd);
    if (S_OK != hr)
        goto Cleanup;

    // get the SafeArray expando from the event obj
    hr = GetEventFromUnknown(punk, &pEventObj);
    if (S_OK != hr)
        goto Cleanup;

    hr = GetParamsFromEvent(
            pEventObj,
            cExpandos,
            aDispid,
            aVariant,
            s_aPropertysheetExpandos);
    if (S_OK != hr)
        goto Cleanup;
    psafearray = V_ARRAY(&aVariant[PropertysheetPunks]);

    // verify array dimensions
    if (SafeArrayGetDim(psafearray) != 1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get array size, adding one to 0-based size
    hr = SafeArrayGetUBound(psafearray, 1, (long*)&cUnk);
    if (S_OK != hr)
        goto Cleanup;
    cUnk++;

    if (cUnk)
    {
        // get pointer to vector
        hr = SafeArrayAccessData(psafearray, (void HUGEP* FAR*)&apUnk);
        if (S_OK != hr)
            goto Cleanup;
    }
    else
    {
        cUnk = 1;
        apUnk = &punk;
    }

    // Compute pages to load
    hr = THR(GetCommonPages(cUnk, apUnk, &ca));
    if (S_OK != hr)
        goto Cleanup;

    //  compute top-level parent
    while (hwndParent = GetParent(hwnd))
        hwnd = hwndParent;

    // The dialog box is not centered on screen
    // the ocpfi seems to be ignoring the x, y values in ocpfiparams
    // Compute offset to center of screen
    GetWindowRect(GetDesktopWindow(), &rcDesktop);
    GetWindowRect(hwnd, &rc);
    pixelOffset.cx = (rcDesktop.right - rcDesktop.left)/2 - rc.left;
    pixelOffset.cy = (rcDesktop.bottom - rcDesktop.top)/2 - rc.top;
    AtlPixelToHiMetric(&pixelOffset, &metricOffset);

    ocpfiparams.cbStructSize = sizeof(ocpfiparams);
    ocpfiparams.hWndOwner = hwnd;
    ocpfiparams.x = metricOffset.cx;
    ocpfiparams.y = metricOffset.cy;
    ocpfiparams.lpszCaption = NULL;
    ocpfiparams.cObjects = cUnk;
    ocpfiparams.lplpUnk = apUnk;
    ocpfiparams.cPages = ca.cElems;
    ocpfiparams.lpPages = ca.pElems;
    ocpfiparams.lcid = GetUserDefaultLCID();
    ocpfiparams.dispidInitialProperty = DISPID_UNKNOWN;

    // OleCreatePropertyFrameIndirect throws its own dialog on error,
    // so we don't want to display that twice
    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
    THR(OleCreatePropertyFrameIndirect(&ocpfiparams));
    hr = S_OK;

Cleanup:
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    if (ca.cElems)
        CoTaskMemFree(ca.pElems);

    if (psafearray && apUnk)
        SafeArrayUnaccessData(psafearray);

    if (pvarargOut)
        VariantInit(pvarargOut);

    for (i=0; i<cExpandos; i++)
        VariantClear(&aVariant[i]);

    ATOMICRELEASE(pEventObj);

    return hr;
}

HRESULT
CDocHostUIHandler::GetCommonPages(int cUnk, IUnknown **apUnk, CAUUID *pca)
{
    HRESULT                hr = E_INVALIDARG;
    int                    i;
    UINT                   iScan, iFill, iCompare;
    BOOL                   fFirst = TRUE;
    CAUUID                 caCurrent;
    IUnknown *             pUnk;
    ISpecifyPropertyPages *pSPP;

    pca->cElems = 0;
    pca->pElems = NULL;

    for (i = 0; i < cUnk; i++)
    {
        pUnk = apUnk[i];
        ASSERT(pUnk);

        hr = THR(pUnk->QueryInterface(IID_PPV_ARG(ISpecifyPropertyPages, &pSPP)));
        if (S_OK != hr)
            goto Cleanup;

        hr = THR(pSPP->GetPages(fFirst ? pca : &caCurrent));
        ATOMICRELEASE(pSPP);
        if (S_OK != hr)
            goto Cleanup;

        if (fFirst)
        {
            continue;
        }
         // keep only the common pages
        else
        {
            for (iScan = 0, iFill = 0; iScan < pca->cElems; iScan++)
            {
                for (iCompare = 0; iCompare < caCurrent.cElems; iCompare++)
                {
                    if (caCurrent.pElems[iCompare] == pca->pElems[iScan])
                        break;
                }
                if (iCompare != caCurrent.cElems)
                {
                    pca->pElems[iFill++] = pca->pElems[iScan];
                 }
            }
            pca->cElems = iFill;
            CoTaskMemFree(caCurrent.pElems);
        }
    }


Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Helper for SHDVID_CLSIDTOMONIKER
//
//+---------------------------------------------------------------------------

struct HTMLPAGECACHE
{
    const CLSID *   pclsid;
    TCHAR *         ach;
};

HRESULT CDocHostUIHandler::ClsidToMoniker(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    static const HTMLPAGECACHE s_ahtmlpagecache[] =
    {
        &CLSID_CAnchorBrowsePropertyPage,           _T("anchrppg.ppg"),
        &CLSID_CImageBrowsePropertyPage,            _T("imageppg.ppg"),
        &CLSID_CDocBrowsePropertyPage,              _T("docppg.ppg"),
    };

    HRESULT                 hr = E_FAIL;
    IMoniker              * pmk = NULL;
    IUnknown              * pUnk = NULL;
    int                     i;
    const HTMLPAGECACHE   * phtmlentry;
    const CLSID           * pclsid;

    ASSERT(pvarargIn);
    ASSERT(pvarargOut);
    ASSERT(V_VT(pvarargIn) == VT_UINT_PTR && V_BYREF(pvarargIn));

    if (!pvarargIn || V_VT(pvarargIn) != VT_UINT_PTR || !V_BYREF(pvarargIn))
        goto Cleanup;
    pclsid = (CLSID *)V_BYREF(pvarargIn);

    if (!pvarargOut)
        goto Cleanup;
    VariantInit(pvarargOut);

    // lookup the resource from the CLSID
    for (i = ARRAYSIZE(s_ahtmlpagecache) - 1, phtmlentry = s_ahtmlpagecache;
        i >= 0;
        i--, phtmlentry++)
    {
        ASSERT(phtmlentry->pclsid && phtmlentry->ach);
        if (IsEqualCLSID(*pclsid, *phtmlentry->pclsid))
        {
            // create a moniker for the dialog resource
            TCHAR szResURL[MAX_URL_STRING];
            hr = MLBuildResURL(TEXT("shdoclc.dll"),
                       HINST_THISDLL,
                       ML_CROSSCODEPAGE,
                       phtmlentry->ach,
                       szResURL,
                       ARRAYSIZE(szResURL));
            if (S_OK != hr)
                goto Cleanup;

            hr = CreateURLMoniker(NULL, szResURL, &pmk);
            if (S_OK != hr)
                goto Cleanup;

            break;
        }
    }

    if (!pmk)
        goto Cleanup;

    // return the moniker
    hr = pmk->QueryInterface(IID_PPV_ARG(IUnknown, &pUnk));
    if (S_OK != hr)
        goto Cleanup;
    else
    {
        V_VT(pvarargOut) = VT_UNKNOWN;
        V_UNKNOWN(pvarargOut) = pUnk;
        V_UNKNOWN(pvarargOut)->AddRef();
    }

Cleanup:
    ATOMICRELEASE(pUnk);
    ATOMICRELEASE(pmk);

    return hr;
}

STDMETHODIMP CDocHostUIHandler::Invoke(
    DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, 
    VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    HRESULT hr = S_OK; // this function almost always succeeds! should return failure in some cases

    if (pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH && pDispParams->rgvarg[0].pdispVal)
        {
            IHTMLEventObj *pObj=NULL;
            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_PPV_ARG(IHTMLEventObj, &pObj)) && pObj))
            {
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                if (bstrEvent)
                {
                    ASSERT(!StrCmpCW(bstrEvent, L"unload"));

                    IWebBrowser2* pwb2;
                    hr = IUnknown_QueryServiceForWebBrowserApp(_punkSite, IID_PPV_ARG(IWebBrowser2, &pwb2));
                    if (SUCCEEDED(hr))
                    {
                        IHTMLWindow2* pWindow;

                        // we shouldn't be catching this event if the dialog is not up
                        if (IsFindDialogUp(pwb2, &pWindow))
                        {
                            ASSERT(pWindow);

                            if (_pOptionsHolder)
                            {
                                BSTR bstrFindText = NULL;
                                _pOptionsHolder->get_findText(&bstrFindText);

                                ATOMICRELEASE(_pOptionsHolder);
                                PutFindText(pwb2, bstrFindText);

                                SysFreeString(bstrFindText);
                            }

                            BSTR bstrOnunload = SysAllocString(L"onunload");
                            if (bstrOnunload)
                            {
                                IHTMLWindow3 * pWin3;

                                if (SUCCEEDED(pWindow->QueryInterface(IID_PPV_ARG(IHTMLWindow3, &pWin3))))
                                {
                                    pWin3->detachEvent(bstrOnunload, (IDispatch*)this);
                                    pWin3->Release();
                                }
                                SysFreeString(bstrOnunload);
                            }
                            pWindow->Release();

                             //this is the one that should release the dialog (the pWinOut from ShowFindDialog())
                            ReleaseFindDialog(pwb2);
                        }
                        pwb2->Release();
                    }
                    SysFreeString(bstrEvent);
                }
                pObj->Release();
            }
        }
    }

    return hr;
}


//------------------------------------------------------------------
//------------------------------------------------------------------
IMoniker * GetTemplateMoniker(VARIANT varUrl)
{
    IMoniker * pMon = NULL;
    HRESULT    hr = S_OK;

    if (V_VT(&varUrl) == VT_BSTR && SysStringLen(V_BSTR(&varUrl)) !=0)
    {
        // we have a template URL
        hr = CreateURLMoniker(NULL, V_BSTR(&varUrl), &pMon);
    }
    else 
    {
        TCHAR   szResURL[MAX_URL_STRING];

        hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                               HINST_THISDLL,
                               ML_CROSSCODEPAGE,
                               TEXT("preview.dlg"),
                               szResURL,
                               ARRAYSIZE(szResURL),
                               TEXT("shdocvw.dll"));
        if (S_OK != hr)
            goto Cleanup;

        hr = CreateURLMoniker(NULL, szResURL, &pMon);
    }

Cleanup:
    return pMon;
}

//============================================================================
//
//  Printing support
//
//============================================================================

static enum {
    eTemplate    = 0,
    eParentHWND  = 1,
    eHeader      = 2, // keep this in ssync with the list below!
    eFooter      = 3,
    eOutlookDoc  = 4,
    eFontScale   = 5,
    eFlags       = 6,
    eContent     = 7,
    ePrinter     = 8,
    eDevice      = 9,
    ePort        = 10,
    eSelectUrl   = 11,
    eBrowseDoc   = 12,
    eTempFiles   = 13,
};

static const SExpandoInfo s_aPrintTemplateExpandos[] =
{
    {TEXT("__IE_TemplateUrl"),         VT_BSTR},
    {TEXT("__IE_ParentHWND"),          VT_UINT},
    {TEXT("__IE_HeaderString"),        VT_BSTR},    // from here down matches the
    {TEXT("__IE_FooterString"),        VT_BSTR},    //    safeArray structure  so
    {TEXT("__IE_OutlookHeader"),       VT_UNKNOWN}, //    that we can just VariantCopy
    {TEXT("__IE_BaseLineScale"),       VT_INT},     //    in a loop to transfer the
    {TEXT("__IE_uPrintFlags"),         VT_UINT},    //    data.
    {TEXT("__IE_ContentDocumentUrl"),  VT_BSTR},    // See MSHTML: SetPrintCommandParameters()
    {TEXT("__IE_PrinterCMD_Printer"),  VT_BSTR},
    {TEXT("__IE_PrinterCMD_Device"),   VT_BSTR},
    {TEXT("__IE_PrinterCMD_Port"),     VT_BSTR},
    {TEXT("__IE_ContentSelectionUrl"), VT_BSTR},
    {TEXT("__IE_BrowseDocument"),      VT_UNKNOWN},
    {TEXT("__IE_TemporaryFiles"),      VT_ARRAY|VT_BSTR},
};

//+--------------------------------------------------------------------------------------
//
//  Helper class CPrintUnloadHandler. Used to delete tempfiles created for print[preview].
//  Note that we don't delete files when we get onUnload event - at this moment
//  files are still in use and can't be deleted. We use destructor - when template
//  is being destructed and all files are already released, template releases 
//  all sinks and here we do our cleanup.
//---------------------------------------------------------------------------------------

class CPrintUnloadHandler: public IDispatch
{
    CDocHostUIHandler *m_pUIHandler;
    VARIANT            m_vFileNameArray;    //SAFEARRAY with filenames
    LONG               m_cRef;
    IUnknown          *m_punkFreeThreadedMarshaler; 
    bool               m_fPreview;

   public:

    //IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv)
    {
        HRESULT hr = E_NOINTERFACE;

        if (ppv == NULL) 
        {
            return E_POINTER;
        }
        else if (IsEqualIID(IID_IUnknown, riid) || IsEqualIID(IID_IDispatch, riid))
        {
            *ppv = this;
            AddRef();
            hr = S_OK;
        }
        else if (IsEqualIID(IID_IMarshal, riid))
        {
            hr = m_punkFreeThreadedMarshaler->QueryInterface(riid,ppv);
        }

        return hr;
    }
    
    STDMETHOD_(ULONG,AddRef)(THIS)
    {
        return InterlockedIncrement(&m_cRef);
    }
    
    STDMETHOD_(ULONG,Release)(THIS)
    {
        ASSERT(0 != m_cRef);
        ULONG cRef = InterlockedDecrement(&m_cRef);
        if (0 == cRef)
        {
            delete this;
        }
        return cRef;
    }

    //IDispatch
    virtual STDMETHODIMP GetTypeInfoCount(UINT* pctinfo) 
    { return E_NOTIMPL; };

    virtual STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo) 
    { return E_NOTIMPL; };

    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
        LCID lcid, DISPID *rgDispId) 
    { return E_NOTIMPL; };

    virtual STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pVarResult,
        EXCEPINFO *pExcepInfo, UINT *puArgErr)
    { return S_OK; }

    CPrintUnloadHandler(CDocHostUIHandler *pUIHandler, bool fPreview)
    {
        ASSERT(pUIHandler);
        //make sure our handler doesn't go anywere..
        m_pUIHandler = pUIHandler;
        pUIHandler->AddRef();
        m_cRef = 1;
        VariantInit(&m_vFileNameArray);
        //create threaded marshaler because we will be called from another thread
        //which will be created for print(preview) window
        CoCreateFreeThreadedMarshaler((IUnknown*)this, &m_punkFreeThreadedMarshaler);
        //if preview, lock the preview gate so no more then one is possible
        m_fPreview = fPreview;
        if (m_fPreview) 
            pUIHandler->IncrementPreviewCnt();
    }

    ~CPrintUnloadHandler()
    {
        //here we delete those temp files, finally.
        DeleteFiles();
        if (m_fPreview) 
            m_pUIHandler->DecrementPreviewCnt();
        if (m_pUIHandler) 
            m_pUIHandler->Release();
        if (m_punkFreeThreadedMarshaler) 
            m_punkFreeThreadedMarshaler->Release();
        VariantClear(&m_vFileNameArray);
    }

    HRESULT SetFileList(VARIANT *pvFileList)
    {
        if (pvFileList && (V_VT(pvFileList) == (VT_ARRAY | VT_BSTR)))
            return VariantCopy(&m_vFileNameArray, pvFileList);
        else 
            return VariantClear(&m_vFileNameArray);
    }

    void DeleteFiles()
    {
        int arrayMin, arrayMax;

        if (V_VT(&m_vFileNameArray) != (VT_ARRAY | VT_BSTR)) 
            return;

        SAFEARRAY  *psa = V_ARRAY(&m_vFileNameArray);

        if (FAILED(SafeArrayGetLBound(psa, 1, (LONG*)&arrayMin))) 
            return;

        if (FAILED(SafeArrayGetUBound(psa, 1, (LONG*)&arrayMax))) 
            return;

        for (int i = arrayMin; i <= arrayMax; i++)
        {
            BSTR bstrName = NULL;
            if (SUCCEEDED(SafeArrayGetElement(psa, (LONG*)&i, &bstrName)) && bstrName)
            {
                TCHAR szFileName[MAX_PATH];
                SHUnicodeToTChar(bstrName, szFileName, ARRAYSIZE(szFileName));
                DeleteFile(szFileName);
                SysFreeString(bstrName);
            }
       }
    }
};


#define MAX_BUF_INT         (1 + 10 + 1)        // -2147483647

//+--------------------------------------------------------------------------------------
//  
//  Member DoTemplatePrinting
//
//  Synopsis : this member function deals with instantiating a print template and enabling 
//      the printing of a document. It deals with the logic of whether to show or hide the
//      template;  determining whether/and-how to bring up the print/page-setup dialogs;
//      kicking off the print process rather or waiting for the template
//      UI (and thus the user) to do so.
//
//  Arguments : 
//      pvarargIn  : points to an event object with a number of expandoes that define
//                      how this print operation should progress.
//      pvarargOut : not used
//      fPreview   : flag indicating whether or not to actually show the template. This is true
//                      for preview mode, and false for normal printing
//
//---------------------------------------------------------------------------------------
HRESULT 
CDocHostUIHandler::DoTemplatePrinting(VARIANTARG *pvarargIn, VARIANTARG *pvarargOut, BOOL fPreview)
{
    int                     i;
    HRESULT                 hr = S_OK;
    VARIANT                 varDLGOut = {0};
    const int               cExpandos = ARRAYSIZE(s_aPrintTemplateExpandos);
    VARIANT                 aVariant[cExpandos] = {0};
    DISPID                  aDispid[cExpandos];
    BSTR                    bstrDlgOptions = NULL;
    DWORD                   dwDlgFlags;
    IHTMLEventObj         * pEventObj  = NULL;
    IHTMLEventObj2        * pEventObj2 = NULL;
    IMoniker              * pmk        = NULL;
    IHTMLWindow2          * pWinOut    = NULL;
    TCHAR                   achInit[512];
    RECT                    rcClient;
    HWND                    hwndOverlay = NULL;
    HWND                    hwndParent  = NULL;
    CPrintUnloadHandler   * pFinalizer = NULL;
    BOOL                    fBlock;

    // in preview mode we do not want to bring up another instance of the template
    if (fPreview && (IncrementPreviewCnt() > 1))
        goto Cleanup;

    if (SHRestricted2(REST_NoPrinting, NULL, 0))
    {
        // printing functionality disabled via IEAK restriction

        MLShellMessageBox(NULL, MAKEINTRESOURCE(IDS_RESTRICTED), MAKEINTRESOURCE(IDS_TITLE), MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);

        hr = S_FALSE;
        goto Cleanup;
    }

    ASSERT(V_VT(pvarargIn) == VT_UNKNOWN);
    if ((V_VT(pvarargIn) != VT_UNKNOWN) || !V_UNKNOWN(pvarargIn))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // now get the expando properties that were passed in...
    //
    hr = V_UNKNOWN(pvarargIn)->QueryInterface(IID_PPV_ARG(IHTMLEventObj, &pEventObj));
    if (S_OK != hr)
        goto Cleanup;
    hr = V_UNKNOWN(pvarargIn)->QueryInterface(IID_PPV_ARG(IHTMLEventObj2, &pEventObj2));
    if (S_OK != hr)
        goto Cleanup;

    //
    // Get expando parameters from event object
    //
    hr = GetParamsFromEvent(pEventObj,
                            cExpandos,
                            aDispid,
                            aVariant,
                            s_aPrintTemplateExpandos);

    if (S_OK != hr)
        goto Cleanup;

    //
    // Now that we have all the data, lets do the work of raising the template.
    //  First, Create the Moniker of the template document
    //
    pmk = GetTemplateMoniker(aVariant[eTemplate]);

    //
    // Set up the bstrDlgOptions to properly pass in the size and location 
    //
    StrCpyN(achInit, TEXT("resizable:yes;status:no;help:no;"), ARRAYSIZE(achInit));

    //
    // get the top most hwnd to use as the parenting hwnd and
    // to use to set the size of the preview window
    //

    hwndOverlay = (HWND)(void*)V_UNKNOWN(&aVariant[eParentHWND]);
    while (hwndParent = GetParent(hwndOverlay))
    {
        hwndOverlay = hwndParent;
    }

    if (GetWindowRect(hwndOverlay, &rcClient))
    {
        TCHAR achBuf[32];
        
        StrCatBuff(achInit, TEXT("dialogLeft:"), ARRAYSIZE(achInit));
        _ltot(rcClient.left, achBuf, 10); // plenty of space in achBuf for the long value
        StrCatBuff(achInit, achBuf, ARRAYSIZE(achInit));
        StrCatBuff(achInit, TEXT("px;dialogTop:"), ARRAYSIZE(achInit));
        _ltot(rcClient.top, achBuf, 10);
        StrCatBuff(achInit, achBuf, ARRAYSIZE(achInit));
        StrCatBuff(achInit, TEXT("px;dialogWidth:"), ARRAYSIZE(achInit));
        _ltot(rcClient.right - rcClient.left, achBuf, 10);
        StrCatBuff(achInit, achBuf, ARRAYSIZE(achInit));
        StrCatBuff(achInit, TEXT("px;dialogHeight:"), ARRAYSIZE(achInit));
        _ltot(rcClient.bottom - rcClient.top, achBuf, 10);
        StrCatBuff(achInit, achBuf, ARRAYSIZE(achInit));
        StrCatBuff(achInit, TEXT("px;"), ARRAYSIZE(achInit));
    }
    bstrDlgOptions = SysAllocString(achInit);
    if (!bstrDlgOptions)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //Create a finalizer    
    pFinalizer = new CPrintUnloadHandler(this, fPreview);
    if (pFinalizer)
    {
       pFinalizer->SetFileList(&aVariant[eTempFiles]);
    }


    //
    // Bring up a modeless dialog and get the window pointer so that 
    // we can properly initialize the template document.
    //
    V_VT(&varDLGOut) = VT_UNKNOWN;
    V_UNKNOWN(&varDLGOut) = NULL;

    // HTMLDLG_MODELESS really means "open dialog on its own thread", which
    // we want to do for both actual printing and previewing.
    // Note that if we're previewing, we also flip on HTMLDLG_MODAL; this
    // is by design! (see comment below).
    fBlock = ((V_UINT(&aVariant[eFlags]) & PRINT_WAITFORCOMPLETION) != 0);

    dwDlgFlags = HTMLDLG_PRINT_TEMPLATE;

    // VERIFY if we are going to display
    if (fPreview)
        dwDlgFlags |= HTMLDLG_VERIFY;
    // otherwise, don't display with NOUI
    else
        dwDlgFlags |= HTMLDLG_NOUI;

    // If we are not printing synchronously, create a thread for printing.
    if (!fBlock)
        dwDlgFlags |= HTMLDLG_MODELESS;

    // Dlg should block UI on parent
    if (fPreview || fBlock)
        dwDlgFlags |= HTMLDLG_MODAL;

    ShowHTMLDialogEx((HWND)(void*)V_UNKNOWN(&aVariant[eParentHWND]), 
                     pmk, 
                     dwDlgFlags, 
                     pvarargIn,
                     bstrDlgOptions, 
                     &varDLGOut);

    if (V_UNKNOWN(&varDLGOut))
    {
        V_UNKNOWN(&varDLGOut)->QueryInterface(IID_PPV_ARG(IHTMLWindow2, &pWinOut));
    }

    if (pWinOut)
    {
        BSTR bstrOnunload = SysAllocString(L"onunload");

        //
        // can't really handle failure here, because the dialog is already up.
        // .. but we need to set up an onunload handler to properly ref release
        //
        if (bstrOnunload)
        {
            IHTMLWindow3 * pWin3;

            if (SUCCEEDED(pWinOut->QueryInterface(IID_PPV_ARG(IHTMLWindow3, &pWin3))))
            {
                VARIANT_BOOL varBool;
                hr = pWin3->attachEvent(bstrOnunload, (IDispatch*)pFinalizer, &varBool);

                // (greglett) If this fails, we're in trouble. 
                // We can either delete the temp files at the end of the function (where the ATOMICRELEASE
                //    calls the Finalizer's destructor), or we can leak the temp files.
                // We choose to delete the temp files if we were not modeless (same thread means we're now done with the files).
                // Otherwise, we'd rather leak the files than not work.
                // Known case: 109200.
                if (S_OK != hr && !fBlock)
                {
                    //ASSERT(FALSE && "Temp files leaked while printing!");
                    pFinalizer->SetFileList(NULL);
                }
                pWin3->Release();
            }
            SysFreeString(bstrOnunload);
        }

        pWinOut->Release();
    }

Cleanup:

    DecrementPreviewCnt();

    VariantClear(&varDLGOut);

    if (bstrDlgOptions) 
        SysFreeString(bstrDlgOptions);

    if (pvarargOut) 
        VariantClear(pvarargOut);

   for (i=0; i<cExpandos; i++)
        VariantClear(aVariant + i);

    //  This will also delete temp files stored in finalizer if we did non-modeless preview (!fBlock)
    ATOMICRELEASE(pFinalizer);  

    ATOMICRELEASE(pEventObj);
    ATOMICRELEASE(pEventObj2);
    ATOMICRELEASE(pmk);

    return hr;
}

//+--------------------------------------------------------------------------------------
//
//  Member DoTemplatePageSetup
//
//  Synopsis : In template printing architecture, the page setup dialog is still raised 
//      by the DHUIHandler, but it may be overriden. In order to pull ALL print knowledge
//      out of trident it is necessary to have trident delegate the request for pagesetup
//      up to here, then we instantiate a minimal template which brings up a CTemplatePrinter
//      which delegates back to the DHUIHandler to bring up the dialog itself.
//
//      Although this is slightly convoluted, it is necessary in order to give the host
//      complete control over the pagesetup dialog (when not raised from print preview)
//      while at the same time maintaining backcompat for the registry setting that is done
//      independant of the UI handling itself
//
//---------------------------------------------------------------------------------------
HRESULT
CDocHostUIHandler::DoTemplatePageSetup(VARIANTARG *pvarargIn)
{
    HRESULT         hr            = S_OK;
    TCHAR           szResURL[MAX_URL_STRING];
    IHTMLEventObj * pEventObj     = NULL;
    IMoniker      * pMon          = NULL;
    const int       cExpandos = ARRAYSIZE(s_aPrintTemplateExpandos);
    VARIANT         aVariant[cExpandos] = {0};
    DISPID          aDispid[cExpandos];
    int i;

    if (SHRestricted2(REST_NoPrinting, NULL, 0))
    {
        // printing functionality disabled via IEAK restriction

        MLShellMessageBox(NULL, MAKEINTRESOURCE(IDS_RESTRICTED), MAKEINTRESOURCE(IDS_TITLE), MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);

        hr = S_FALSE;
        goto Cleanup;
    }

    ASSERT(V_VT(pvarargIn) == VT_UNKNOWN);
    if ((V_VT(pvarargIn) != VT_UNKNOWN) || !V_UNKNOWN(pvarargIn))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // now get the expando properties that were passed in...
    //
    hr = V_UNKNOWN(pvarargIn)->QueryInterface(IID_PPV_ARG(IHTMLEventObj, &pEventObj));
    if (S_OK != hr)
        goto Cleanup;
    
    //
    // Get expando parameters from event object
    // do we care if this fails?
    hr = GetParamsFromEvent(pEventObj,
                            cExpandos,
                            aDispid,
                            aVariant,
                            s_aPrintTemplateExpandos);

    // get the resource URL
    hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                           HINST_THISDLL,
                           ML_CROSSCODEPAGE,
                           TEXT("pstemplate.dlg"),
                           szResURL,
                           ARRAYSIZE(szResURL),
                           TEXT("shdocvw.dll"));
    if (S_OK != hr)
        goto Cleanup;

    // create the moniker
    hr = CreateURLMoniker(NULL, szResURL, &pMon);
    if (S_OK != hr)
        goto Cleanup;

    // raise the template
    hr = ShowHTMLDialogEx((HWND)(void*)V_UNKNOWN(&aVariant[eParentHWND]), 
                          pMon, 
                          HTMLDLG_MODAL | HTMLDLG_NOUI | HTMLDLG_PRINT_TEMPLATE, 
                          pvarargIn,
                          NULL, 
                          NULL);

Cleanup:
   for (i=0; i<cExpandos; i++)
        VariantClear(aVariant + i);

    ATOMICRELEASE(pMon);
    ATOMICRELEASE(pEventObj);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\dpastuff.cpp ===
#include "priv.h"
#include "runonnt.h"

#include "..\inc\dpastuff.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\dochost.h ===
#include "dhuihand.h"
#include "iface.h"
#include "dspsprt.h"
#include "privacyui.hpp"

#ifdef UNIX
#define MAIL_ACTION_SEND    1
#define MAIL_ACTION_READ    2
#endif

#define MAX_SCRIPT_ERR_CACHE_SIZE   20

class CDocObjectHost;
interface IToolbarExt;
interface IHTMLPrivateWindow;
interface IPrivacyServices;

//
// script error handling
// support for caching errors and displaying them when the script error icon
// on the status bar is clicked by the user
//

class CScriptErrorList : public CImpIDispatch,
                         public IScriptErrorList
{
public:
    CScriptErrorList();
    ~CScriptErrorList();

    BOOL    IsEmpty()
        { return _hdpa != NULL && DPA_GetPtrCount(_hdpa) == 0; }
    BOOL    IsFull()
        { return _hdpa != NULL && DPA_GetPtrCount(_hdpa) >= MAX_SCRIPT_ERR_CACHE_SIZE; }

    HRESULT AddNewErrorInfo(LONG    lLine,
                            LONG    lChar,
                            LONG    lCode,
                            BSTR    strMsg,
                            BSTR    strUrl);
    void    ClearErrorList();

    // IUnknown
    STDMETHODIMP            QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo * * pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // IScriptErrorList
    STDMETHODIMP    advanceError();
    STDMETHODIMP    retreatError();
    STDMETHODIMP    canAdvanceError(BOOL * pfCanAdvance);
    STDMETHODIMP    canRetreatError(BOOL * pfCanRetreat);
    STDMETHODIMP    getErrorLine(LONG * plLine);
    STDMETHODIMP    getErrorChar(LONG * plChar);
    STDMETHODIMP    getErrorCode(LONG * plCode);
    STDMETHODIMP    getErrorMsg(BSTR * pstrMsg);
    STDMETHODIMP    getErrorUrl(BSTR * pstrUrl);
    STDMETHODIMP    getAlwaysShowLockState(BOOL * pfAlwaysShowLock);
    STDMETHODIMP    getDetailsPaneOpen(BOOL * pfDetailsPaneOpen);
    STDMETHODIMP    setDetailsPaneOpen(BOOL fDetailsPaneOpen);
    STDMETHODIMP    getPerErrorDisplay(BOOL * pfPerErrorDisplay);
    STDMETHODIMP    setPerErrorDisplay(BOOL fPerErrorDisplay);

private:
    class _CScriptErrInfo
    {
    public:
        ~_CScriptErrInfo();

        HRESULT Init(LONG lLine, LONG lChar, LONG lCode, BSTR strMsg, BSTR strUrl);

        LONG    _lLine;
        LONG    _lChar;
        LONG    _lCode;
        BSTR    _strMsg;
        BSTR    _strUrl;
    };

    HDPA    _hdpa;
    LONG    _lDispIndex;
    ULONG   _ulRefCount;
};

// The dochost and docview need to talk to eachother. We can't use the IOleCommandTarget
// because there's no direction associated with that. Create two different interfaces
// for now becuz that'll probably be useful if we ever make dochost a CoCreateable thing
// so we can share hosting code with shell32.
// (We can coalesce them into one interface later if they don't diverge.)

//
// IDocHostObject
//
EXTERN_C const GUID IID_IDocHostObject;   //67431840-C511-11CF-89A9-00A0C9054129

#undef  INTERFACE
#define INTERFACE  IDocHostObject
DECLARE_INTERFACE_(IDocHostObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDocHostObject methods ***
    virtual STDMETHODIMP OnQueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext, HRESULT hres) PURE;
    virtual STDMETHODIMP OnExec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut) PURE;
    virtual STDMETHODIMP QueryStatusDown(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext) PURE;
    virtual STDMETHODIMP ExecDown(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut) PURE;
} ;


//
//  This is a proxy IOleInPlaceActiveObject class. The interface to this
// object will be passed to the IOleInPlaceUIWindow interface of the browser
// if it support it.
//
class CProxyActiveObject : public IOleInPlaceActiveObject
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleWindow methods ***
    STDMETHODIMP GetWindow(HWND * lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // *** IOleInPlaceActiveObject ***
    STDMETHODIMP TranslateAccelerator(LPMSG lpmsg);
    STDMETHODIMP OnFrameWindowActivate(
        BOOL fActivate);
    STDMETHODIMP OnDocWindowActivate(
        BOOL fActivate);
    STDMETHODIMP ResizeBorder(
        LPCRECT prcBorder,
        IOleInPlaceUIWindow *pUIWindow,
        BOOL fFrameWindow);
    STDMETHODIMP EnableModeless(
        BOOL fEnable);

    void Initialize(CDocObjectHost* pdoh) { _pdoh = pdoh; }

    IOleInPlaceActiveObject *GetObject() { return _piact;}
    HWND GetHwnd() {return _hwnd;}
    void SetActiveObject(IOleInPlaceActiveObject * );
protected:


    CDocObjectHost* _pdoh;
    IOleInPlaceActiveObject*    _piact; // non-NULL while UI-active
    HWND _hwnd;
};


//  This is a proxy IOleInPlaceFrame class. The interfaces to this object
// will be passed to in-place active object.
//
class CDocObjectFrame : public IOleInPlaceFrame
                      , public IOleCommandTarget
                      , public IServiceProvider
                      , public IInternetSecurityMgrSite
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleWindow methods ***
    STDMETHODIMP GetWindow(HWND * lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // IOleInPlaceUIWindow (also IOleWindow)
    STDMETHODIMP GetBorder(LPRECT lprectBorder);
    STDMETHODIMP RequestBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetActiveObject(
        IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName);

    // IOleInPlaceFrame (also IOleInPlaceUIWindow)
    STDMETHODIMP InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHODIMP SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHODIMP RemoveMenus(HMENU hmenuShared);
    STDMETHODIMP SetStatusText(LPCOLESTR pszStatusText);
    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP TranslateAccelerator(LPMSG lpmsg, WORD wID);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IServiceProvider (must be QI'able from IOleClientSite)
    STDMETHODIMP QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj);

    // *** IInternetSecurityMgrSite methods ***
    // STDMETHODIMP GetWindow(HWND * lphwnd) { return IOleWindow::GetWindow(lphwnd); }
    // STDMETHODIMP EnableModeless(BOOL fEnable) { return IOleInPlaceFrame::EnableModeless(fEnable); }

public:
    void Initialize(CDocObjectHost* pdoh) { _pdoh = pdoh; }
protected:
    CDocObjectHost* _pdoh;
};

//
// LATER: Move it to a private, but shared header later.
//
//   BROWSERFLAG_OPENCOPY               - make a copy of object (Excel)
//   BROWSERFLAG_OPENVERB               - use OLEIVERB_OPEN instead of PRIMARY
//   BROWSERFLAG_SETHOSTNAME            - set HostName
//   BROWSERFLAG_DONTINPLACE            - Never in-place activate
//   BROWSERFLAG_CANOPENFILEMULTIPETIMES- 
//   BROWSERFLAG_DONTUIDEACTIVATE       - Never UI-deactivate 
//   BROWSERFLAG_NEVERERASEBKGND        - Never erase background (Trident)
//   BROWSERFLAG_PRINTPROMPTUI          - Don't pass DONPROMPTUI for PRINT (PPT)
//   BROWSERFLAG_SUPPORTTOP             - Handles Navigate("#top")
//   BROWSERFLAG_INITNEWTOKEEP          - IPS::InitNew to keep it running
//   BROWSERFLAG_DONTAUTOCLOSE          - Don't auto close on first navigate w/ no OLE object
//   BROWSERFLAG_REPLACE                - Don't use hard-coded flags
//   BROWSERFLAG_DONTCACHESERVER        - Don't cache the server.
//   BROWSERFLAG_ENABLETOOLSBUTTON      - Ignore when QueryStatus doesn't set enabled flag (Visio)
//   BROWSERFLAG_SAVEASWHENCLOSING      - Show the Save As dialog instead of attempting to save (Visio)  
//
#define BROWSERFLAG_OPENCOPY                0x00000001
#define BROWSERFLAG_OPENVERB                0x00000002
#define BROWSERFLAG_SETHOSTNAME             0x00000004
#define BROWSERFLAG_DONTINPLACE             0x00000008
#define BROWSERFLAG_CANOPENFILEMULTIPETIMES 0x00000010
#define BROWSERFLAG_DONTUIDEACTIVATE        0x00000020
#define BROWSERFLAG_NEVERERASEBKGND         0x00000040
#define BROWSERFLAG_PRINTPROMPTUI           0x00000080
#define BROWSERFLAG_SUPPORTTOP              0x00000100
#define BROWSERFLAG_INITNEWTOKEEP           0x00000200
#define BROWSERFLAG_DONTAUTOCLOSE           0x00000400
#define BROWSERFLAG_DONTDEACTIVATEMSOVIEW   0x00000800
#define BROWSERFLAG_MSHTML                  0x40000000
#define BROWSERFLAG_REPLACE                 0x80000000 
#define BROWSERFLAG_DONTCACHESERVER         0x00001000
#define BROWSERFLAG_ENABLETOOLSBTN          0x00002000
#define BROWSERFLAG_SAVEASWHENCLOSING       0x00004000

#ifdef FEATURE_PICS
class CPicsRootDownload;
#endif

// CMenuList:  a small class that tracks whether a given hmenu belongs
//             to the frame or the object, so the messages can be
//             dispatched correctly.
class CMenuList
{
public:
    CMenuList(void);
    ~CMenuList(void);

    void Set(HMENU hmenuShared, HMENU hmenuFrame);
    void AddMenu(HMENU hmenu);
    void RemoveMenu(HMENU hmenu);
    BOOL IsObjectMenu(HMENU hmenu);

#ifdef DEBUG
    void Dump(LPCTSTR pszMsg);
#endif

private:
    HDSA    _hdsa;
};

#define ERRORPAGE_DNS               1
#define ERRORPAGE_SYNTAX            2
#define ERRORPAGE_NAVCANCEL         3
#define ERRORPAGE_OFFCANCEL         4
#define ERRORPAGE_CHANNELNOTINCACHE	5

// Array of http error codes and file names.
//
struct ErrorUrls
{
    DWORD   dwError;
    LPCTSTR pszUrl;
};

class CDocObjectHost :
                  /* public CDocHostUIHandler */
                     public IDocHostUIHandler2
                   , public IDocHostShowUI
    /* Group 2 */  , public IOleClientSite, public IOleDocumentSite
                   , public IOleCommandTarget
    /* Group 3 */  , public IOleInPlaceSiteEx
    /* VBE */      , public IServiceProvider
                   , public IDocHostObject

    /* palette */  , public IViewObject, public IAdviseSink
                   , public IDispatch // ambient properties (from container/iedisp)
                   , public IPropertyNotifySink // for READYSTATE
                   , public IOleControlSite // forward to container/iedisp
                   , protected CImpWndProc
{
  /*typedef CDocHostUIHandler super;*/
    friend class CDocObjectView;
    friend CDocObjectFrame;
    friend CProxyActiveObject;

public:
    CDocObjectHost(BOOL fWindowOpen = FALSE);

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);


    // IOleClientSite
    STDMETHODIMP SaveObject(void);
    STDMETHODIMP GetMoniker(DWORD, DWORD, IMoniker **);
    STDMETHODIMP GetContainer(IOleContainer **);
    STDMETHODIMP ShowObject(void);
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout(void);

    // IServiceProvider (must be QI'able from IOleClientSite)
    STDMETHODIMP QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj);

    // IViewObject
    STDMETHODIMP Draw(DWORD, LONG, void *, DVTARGETDEVICE *, HDC, HDC,
        const RECTL *, const RECTL *, BOOL (*)(ULONG_PTR), ULONG_PTR);
    STDMETHODIMP GetColorSet(DWORD, LONG, void *, DVTARGETDEVICE *,
        HDC, LOGPALETTE **);
    STDMETHODIMP Freeze(DWORD, LONG, void *, DWORD *);
    STDMETHODIMP Unfreeze(DWORD);
    STDMETHODIMP SetAdvise(DWORD, DWORD, IAdviseSink *);
    STDMETHODIMP GetAdvise(DWORD *, DWORD *, IAdviseSink **);

    // IAdviseSink
    virtual STDMETHODIMP_(void) OnDataChange(FORMATETC *, STGMEDIUM *);
    virtual STDMETHODIMP_(void) OnViewChange(DWORD dwAspect, LONG lindex);
    virtual STDMETHODIMP_(void) OnRename(IMoniker *);
    virtual STDMETHODIMP_(void) OnSave();
    virtual STDMETHODIMP_(void) OnClose();

    // *** IOleWindow methods ***
    STDMETHODIMP GetWindow(HWND * lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // IOleInPlaceSite (also IOleWindow)
    STDMETHODIMP CanInPlaceActivate( void);
    STDMETHODIMP OnInPlaceActivate( void);
    STDMETHODIMP OnUIActivate( void);
    STDMETHODIMP GetWindowContext(
        IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppDoc,
        LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHODIMP Scroll(SIZE scrollExtant);
    STDMETHODIMP OnUIDeactivate(BOOL fUndoable);
    STDMETHODIMP OnInPlaceDeactivate( void);
    STDMETHODIMP DiscardUndoState( void);
    STDMETHODIMP DeactivateAndUndo( void);
    STDMETHODIMP OnPosRectChange(LPCRECT lprcPosRect);

    // IOleInPlaceSiteEx
    STDMETHODIMP OnInPlaceActivateEx(BOOL *pfNoRedraw, DWORD dwFlags);
    STDMETHODIMP OnInPlaceDeactivateEx(BOOL fNoRedraw);
    STDMETHODIMP RequestUIActivate( void);

    // IOleDocumentSite
    STDMETHODIMP ActivateMe(IOleDocumentView *pviewToActivate);

    // IDocHostUIHandler
    STDMETHODIMP ShowContextMenu( 
        DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
    STDMETHODIMP GetHostInfo(DOCHOSTUIINFO *pInfo);
    STDMETHODIMP ShowUI( 
        DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
        IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
        IOleInPlaceUIWindow *pDoc);
    STDMETHODIMP HideUI(void);
    STDMETHODIMP UpdateUI(void);
    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP OnDocWindowActivate(BOOL fActivate);
    STDMETHODIMP OnFrameWindowActivate(BOOL fActivate);
    STDMETHODIMP ResizeBorder( 
        LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
    STDMETHODIMP TranslateAccelerator( 
        LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
    STDMETHODIMP GetOptionKeyPath(BSTR *pbstrKey, DWORD dw);
    STDMETHODIMP GetDropTarget( 
        IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
    STDMETHODIMP GetExternal(IDispatch **ppDisp);
    STDMETHODIMP TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    STDMETHODIMP FilterDataObject(IDataObject *pDO, IDataObject **ppDORet);

    // IDocHostUIHandler2
    STDMETHODIMP GetOverrideKeyPath(LPOLESTR *pchKey, DWORD dw);

    // IDocHostShowUI
    STDMETHODIMP ShowMessage(HWND hwnd, LPOLESTR lpstrText, LPOLESTR lpstrCaption,
            DWORD dwType, LPOLESTR lpstrHelpFile, DWORD dwHelpContext, LRESULT *plResult);
    STDMETHODIMP ShowHelp(HWND hwnd, LPOLESTR pszHelpFile, UINT uCommand, DWORD dwData,
            POINT ptMouse, IDispatch *pDispatchObjectHit);

    // IOleInPlaceFrame equivalent (non-virtual)
    HRESULT _InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    HRESULT _SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    HRESULT _RemoveMenus(HMENU hmenuShared);
    HRESULT _SetStatusText(LPCOLESTR pszStatusText);
    HRESULT _EnableModeless(BOOL fEnable);
    HRESULT _TranslateAccelerator(LPMSG lpmsg, WORD wID);

    // IOleCommandTarget equivalent (virtual / both direction)
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDocHostObject methods ***
    STDMETHODIMP OnQueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext, HRESULT hres);
    STDMETHODIMP OnExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    STDMETHODIMP QueryStatusDown(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP ExecDown(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDispatch methods ***
    STDMETHOD(GetTypeInfoCount) (unsigned int *pctinfo)
        { return E_NOTIMPL; };
    STDMETHOD(GetTypeInfo) (unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return E_NOTIMPL; };
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, unsigned int cNames, LCID lcid, DISPID * rgdispid)
        { return E_NOTIMPL; };
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams,
                        VARIANT * pvarResult,EXCEPINFO * pexcepinfo,UINT * puArgErr);

    // *** IPropertyNotifySink methods ***
    STDMETHODIMP OnChanged(DISPID dispid);
    STDMETHODIMP OnRequestEdit(DISPID dispid);

    // *** IOleControlSite ***
    STDMETHODIMP OnControlInfoChanged();
    STDMETHODIMP LockInPlaceActive(BOOL fLock)
        { return E_NOTIMPL; };
    STDMETHODIMP GetExtendedControl(IDispatch **ppDisp)
        { *ppDisp = NULL; return E_NOTIMPL; };
    STDMETHODIMP TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags)
        { return E_NOTIMPL; };
    STDMETHODIMP TranslateAccelerator(MSG *pMsg,DWORD grfModifiers);

    STDMETHODIMP OnFocus(BOOL fGotFocus)
        { return E_NOTIMPL; };
    STDMETHODIMP ShowPropertyFrame(void)
        { return E_NOTIMPL; };



    HRESULT SetTarget(IMoniker* pmk, UINT uiCP, LPCTSTR pszLocation, LPITEMIDLIST pidlKey, IShellView* psvPrev, BOOL fFileProtocol);
    HRESULT UIActivate(UINT uState, BOOL fPrevViewIsDocView);
    
    //Helper function for initing History related privates
    IUnknown *get_punkSFHistory();
    BOOL InitHostWindow(IShellView* psv, IShellBrowser* psb, LPRECT prcView);
    void DestroyHostWindow();
    void _ChainBSC();
    HRESULT TranslateHostAccelerators(LPMSG lpmsg);
    HRESULT AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    BOOL _IsMenuShared(HMENU hmenu);
    void _SetPriorityStatusText(LPCOLESTR pszPriorityStatusText);

    BOOL DocCanHandleNavigation() const
        { return (_fPrevDocHost && _fDocCanNavigate); }

    void OnInitialUpdate();
    void ResetRefreshUrl();
    void HideBrowser() const;

protected:
    virtual ~CDocObjectHost();

    // Private method
    void _InitOleObject();
    void _ResetOwners();
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnMenuSelect(UINT id, UINT mf, HMENU hmenu);
    void _OnInitMenuPopup(HMENU hmInit, int nIndex, BOOL fSystemMenu);
    void _OnCommand(UINT wNotify, UINT id, HWND hwndControl);
    void _OnNotify(LPNMHDR lpnm);
    void _OnSave(void);
    void _OnBound(HRESULT hres);
    static BOOL_PTR CALLBACK s_RunDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnOpen(void);
    void _OnClose() const;
    BOOL _HideBrowserBar() const;
    void _OnImportExport(HWND hwnd);
    void _OnAddToSitesList(HWND hwnd, DWORD dwZone);
    HRESULT _PrepFileOpenAddrBand(IAddressEditBox ** ppaeb, IWinEventHandler ** ppweh, IBandSite ** ppbs);
    void _OnPaint(HDC hdc);
    void _OnSetFocus(void);
    void _GetClipRect(RECT* prc);
    void _RegisterWindowClass(void);
    void _PlaceProgressBar(BOOL fForcedLayout=FALSE);
    void _OnSetProgressPos(DWORD dwPos, DWORD state);
    void _OnSetProgressMax(DWORD dwRange);
    HRESULT _OnContentDisposition();
    void _OnSetStatusText(VARIANTARG *pvarIn);
    void _Navigate();
#ifndef UNIX
    void _NavigateFolder(BSTR bstrUrl);
#endif // UNIX

    // IE Media Bar functions
    BOOL _DelegateToMediaBar(IBindCtx * pbc, LPCWSTR pwzMimeType);
    void _ForceCreateMediaBar();
    static INT_PTR CALLBACK s_MimeDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


    void _CancelPendingNavigation(BOOL fDownloadAsync,
                                  BOOL fSyncReally = FALSE,
                                  BOOL fDontShowNavCancelPage = FALSE,
                                  BOOL fForceClose = FALSE);

    void _DoAsyncNavigation(LPCTSTR pwzURL);
    IOleInPlaceSite* _GetParentSite(void);
    HRESULT _GetCurrentPage(LPTSTR szBuf, UINT cchMax, BOOL fURL=FALSE);
    HRESULT _GetCurrentPageW(LPOLESTR * ppszDisplayName, BOOL fURL=FALSE);
    BOOL _IsDirty(IPersistFile** pppf);
    HRESULT _OnSaveAs(void);
    void _MergeToolbarSB();
    void _OnHelpGoto(UINT idRes);
    void _Navigate(LPCWSTR pwszURL);
    HRESULT _OnMaySaveChanges(void);
    void _OnCodePageChange(const VARIANTARG* pvarargIn);
    void _MappedBrowserExec(DWORD nCmdID, DWORD nCmdexecopt);
#ifdef DEBUG
    void _DumpMenus(LPCTSTR pszMsg, BOOL bBreak);
#endif

    HRESULT _BindSync(IMoniker* pmk, IBindCtx* pbc, IShellView* psvPrev);
    void    _PostBindAppHack(void);
    void    _AppHackForExcel95(void);
    HRESULT _GetOfflineSilent(BOOL *pbIsOffline, BOOL *pbIsSilent);
    HRESULT _StartAsyncBinding(IMoniker* pmk, IBindCtx* pbc, IShellView* psvPrev);
    HRESULT _BindWithRetry(IMoniker* pmk, IBindCtx* pbc, IShellView* psvPrev);
    void    _UnBind(void);
    void    _ReleaseOleObject(BOOL fIfInited = TRUE);
    void    _ReleasePendingObject(BOOL fIfInited = TRUE);
    HRESULT _GetUrlVariant(VARIANT *pvarOut);
    HRESULT _CreatePendingDocObject(BOOL fMustInit, BOOL fWindowOpen = FALSE);
    void    _ActivateOleObject(void);
    HRESULT _CreateMsoView(void);
    void    _CloseMsoView(void);
    HRESULT _EnsureActivateMsoView(void);
    void    _ShowMsoView(void);
    void    _HideOfficeToolbars(void);
    HRESULT _ActivateMsoView(void);
    HRESULT _DoVerbHelper(BOOL fOC);
    void    _InitToolbarButtons(void);
    void    _UIDeactivateMsoView(void);
    BOOL    _BuildClassMapping(void);
    HRESULT _RegisterMediaTypeClass(IBindCtx* pbc);
    void    _IPDeactivateMsoView(IOleDocumentView* pmsov);
    void    _CompleteHelpMenuMerge(HMENU hmenu);
    BOOL    _ShouldForwardMenu(UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _ForwardObjectMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT _MayHaveVirus(REFCLSID rclsid);
    HRESULT _ForwardSetSecureLock(int lock);
    void    _ResetStatusBar();

    BOOL _ToolsButtonAvailable();
    BYTE _DefToolsButtonState(DWORD dwRest);

    BYTE _DefFontsButtonState(DWORD dwRest);

    DWORD _DiscussionsButtonCmdf();
    BOOL _DiscussionsButtonAvailable();
    BYTE _DefDiscussionsButtonState(DWORD dwRest);

    BOOL _MailButtonAvailable();
    BYTE _DefMailButtonState(DWORD dwRest);

    BOOL _EditButtonAvailable();
    BYTE _DefEditButtonState(DWORD dwRest);

    void _MarkDefaultButtons(PTBBUTTON tbStd);
    const GUID* _GetButtonCommandGroup();
    void _AddButtons(BOOL fForceReload);

    HRESULT _OnChangedReadyState();
    void    _OnReadyState(long lVal, BOOL fUpdateHistory = TRUE);
    BOOL    _SetUpTransitionCapability(BOOL fWindowOpen = FALSE);
    BOOL    _RemoveTransitionCapability();
    void    _UpdateHistoryAndIntSiteDB(LPCWSTR pszTitle);
    HRESULT _CoCreateHTMLDocument(REFIID riid, LPVOID* ppvOut);

    void    _RemoveFrameSubMenus(void);
    HRESULT _DestroyBrowserMenu(void);
    HRESULT _CreateBrowserMenu(LPOLEMENUGROUPWIDTHS pmw);
    void    _OnSetTitle(VARIANTARG *pvTitle);
    DWORD   _GetAppHack(void);
    void    _CleanupProgress(void);

    // Trident Native Frames Support
    //

    VOID    ClearScriptError();
    
    HRESULT _HandleFailedNavigation(VARIANTARG * varargIn, VARIANTARG * varargOut = NULL );

    HRESULT _DisplayHttpErrorPage(IHTMLWindow2 * pCurrentWindow,
                                  BSTR           bstrUrl,
                                  DWORD          dwError,
                                  BOOL           fAddrBarNav,
                                  BOOL           fRefresh = FALSE );

    HRESULT _DoAutoSearch(VARIANTARG   * pvarargIn,
                          long           lStartIdx,
                          DWORD          dwStatusCode,
                          BOOL           fAddMRU,
                          BOOL         * pfShouldDisplayError);

    HRESULT _HandleDocHostCmds(DWORD nCmdID,
                               DWORD nCmdexecopt,
                               VARIANTARG * pvarargIn,
                               VARIANTARG * pvarargOut,
                               BOOL       * pfHandled);

    HRESULT _HandleDocHostCmdPriv(DWORD nCmdID,
                                  DWORD nCmdexecopt,
                                  VARIANTARG * pvarargIn,
                                  VARIANTARG * pvarargOut,
                                  BOOL       * pfHandled);

    HRESULT _NavigateDocument(BSTR bstrUrl, BSTR bstrLocation);
    void    _GetShortCutPath(BSTR * bstrShortCutPath);
    void    _GetDocNavFlags(DWORD * pdwDocNavFlags);

    BOOL    _HandleShdocvwCmds(DWORD        nCmdID,
                               DWORD        nCmdexecopt,
                               VARIANTARG * pvarargIn,
                               VARIANTARG * pvarargOut);

    void _StartPicsForWindow(VARIANTARG * pvarargIn, VARIANTARG * pvarargOut);
    void _CancelPicsForWindow(VARIANTARG * pvarargIn);
    void _IsPicsEnabled(VARIANTARG * pvarIsPicsEnabled);

    HRESULT _UpdateState(LPITEMIDLIST pidl, BOOL fIsErrorUrl);
    void    _Init();

    BOOL _IsInBrowserBand() const;

    DEBUG_CODE(void _TraceMonikerDbg(IMoniker * pmk, TCHAR * pszCaller) const;)

    HRESULT _LoadDocument();

    void _FireNavigateErrorHelper(IHTMLWindow2 * pHTMLWindow2,
                                  DWORD          dwStatusCode,
                                  BOOL         * pfCancelAutoSearch,
                                  BSTR           bstrPendingURL = NULL);

    static LRESULT s_IconsWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    static UINT _MapCommandID(UINT id, BOOL fToMsoCmd);
    inline static UINT _MapToMso(UINT id) { return _MapCommandID(id, TRUE); }
    inline static UINT _MapFromMso(UINT idMso) { return _MapCommandID(idMso, FALSE); }

    inline IOleInPlaceActiveObject *_ActiveObject() { return _xao.GetObject(); }
    inline HWND _ActiveHwnd() { return _xao.GetHwnd(); }

    inline IOleObject * GetOleObject() { return _pole; }


    // internal class objects
    CDocObjectFrame         _dof;
    CProxyActiveObject      _xao;
    CDocHostUIHandler       _dhUIHandler;

    IToolbarExt *           _pBrowsExt;
    int                     _iString;       // start index for toolbar button strings

    UINT                    _cRef;

    // parent references
    IShellView * _psv;
    IOleCommandTarget*      _pmsoctView;
    IDocViewSite*           _pdvs;

    //
    IShellBrowser*          _psb;
    IOleCommandTarget*      _pmsoctBrowser;
    IBrowserService*        _pwb;
    
    IServiceProvider*       _psp;
    IOleInPlaceUIWindow*    _pipu; // Optional interface from IShellBrowser
    IExpDispSupport *       _peds;
    IExpDispSupportOC *     _pedsHelper;

    // for pre-merged menu
    IOleCommandTarget*      _pcmdMergedMenu;

    // Pointer to the WebBrowserOC's DocHostUIHandler, if any.
    IDocHostUIHandler         * _pWebOCUIHandler;
    IDocHostUIHandler2        * _pWebOCUIHandler2;

    // Pointer to the WebBrowserOC's ShowUI handler, if any.
    IDocHostShowUI            * _pWebOCShowUI;

    // Pointer to the WebBrowserOC's InPlaceSiteEx, if any.
    IOleInPlaceSiteEx         * _pWebOCInPlaceSiteEx;

    // we created...
    UINT        _uState;
    HWND        _hwndProgress;
    HWND        _hwndIcons;
    HWND        _hwndTooltip;
    WNDPROC     _pfnStaticWndProc;

    HACCEL      _hacc;

    // Menus: the final menu bar the user sees (_hmenuCur, _hmenuSet) is the product 
    //        of merging the object's menu with the browser's menu.  The browser's menu
    //        (_hmenuBrowser) is the result of combining the browser's
    //        menu (owned by mshtml, obtained via IShellBrowser) with the 
    //        frame's menu (_hmenuFrame).

    HMENU       _hmenuFrame;    // menu to be merged when we have focus
    HMENU       _hmenuBrowser;  // Menu from IShellBrowser
    HMENU       _hmenuSet;      // set by ::SetMenu
    HMENU       _hmenuCur;      // currently set menu
    HMENU       _hmenuMergedHelp;   // Merged help menu
    HMENU       _hmenuObjHelp;  // Hosted object's help menu

    CMenuList   _menulist;      // Menu list for dispatching

    LPCTSTR      _pszLocation;
    UINT        _uiCP;

    LPOLESTR    _pwszRefreshUrl;  // Url to refresh when intrenal error page is dispalyed.

    BOOL        _fNeedToActivate:1;     //  this is set when we do a LoadHistory on the _pole
    BOOL        _fClientSiteSet:1;
    BOOL        _fDontInplaceActivate:1;
    BOOL        _fDrawBackground:1;
    BOOL        _fCanceledByBrowser:1;
    BOOL        _fForwardMenu:1;            // TRUE: forward the menu message
    BOOL        _fHaveParentSite:1;     // pretty much "we're in a frame"
    BOOL        _fhasLastModified;    // object has Last-Modified header
    BOOL        _fIPDeactivatingView:1;
    BOOL        _fCantSaveBack:1;       // We can't call IPSFile::Save(NULL)
    BOOL        _fHaveAppHack:1;
    BOOL        _fReadystateInteractiveProcessed:1;
    BOOL        _fFileProtocol:1;
    BOOL        _fConfirmed:1;            // _MayHaveVirus already confirmed
    BOOL        _fCycleFocus:1;           // 1=got callback to do CycleFocus
    BOOL        _fCreatingPending:1;      // we are creating _punkPending
    BOOL        _fAbortCreatePending:1;   // abort create due to reentrant free
    BOOL        _fCalledMayOpenSafeDlg:1; // Already called MayOpenSafeOpenDialog. 
    BOOL        _fPendingNeedsInit:1;     // does _punkPending need to be inited?
    BOOL        _fPendingWasInited:1;     // _punkPending was inited
    BOOL        _fSetSecureLock:1;        // indicates we should update the browser with fSecureLock
    BOOL        _fProgressTimer:1;        //  progress timer is active
    BOOL        _fProgressTimerFull:1;    //  wait a quarter sec with a full progress bar
    BOOL        _fIsHistoricalObject:1;   //  this item was retrieved from GetHistoryObject() and successfully took LoadHistory()
    BOOL        _fSyncBindToObject:1;     //  to detect when the call backs are on the sync thread
    BOOL        _fUIActivatingView:1;     // Indicates if we're UIActivating or Showing our DocObj view.
    BOOL        _fShowProgressCtl:1;      // Show the progress control on the status bar.
    BOOL        _fWebOC:1;                // are we a web oc?
#ifdef DEBUG
    BOOL        _fFriendlyError:1;        // So we know we're going to an error page.
#endif

    BOOL        _fDocCanNavigate:1;       // TRUE indicates that the hosted document can navigate itself.
    BOOL        _fPrevDocHost:1;          // TRUE if there was a previous doc object host.
    BOOL        _fClosing:1;              // The browser is being closed.
    BOOL        _fRefresh:1;              // the browser is being refreshed (ie we are handling refresh).
    BOOL        _fDelegatedNavigation:1;  // TRUE if the navigation was delegated from the document.
    BOOL        _fErrorPage : 1;        // True if we're navigating to some sort of error page.
    BOOL        _fWindowOpen:1;
    
    IHTMLWindow2 * _pHTMLWindow;        // Navigation interface of the hosted document.    
    LPITEMIDLIST   _pidl;               // Current pidl.
    
    HRESULT     _hrOnStopBinding;       // set in onstopbinding when _fSyncBindToObject
    DWORD       _dwPropNotifyCookie;

    DWORD       _dwAppHack;
    DWORD       _dwSecurityStatus;      // Return from QueryOptions(INTERNET_OPTION_SECURITY_FLAGS)
    int         _eSecureLock;           // one of the SECURELOCK_* values

    HINSTANCE   _hinstInetCpl;          // Inetcpl

    TBBUTTON*   _ptbStd;                // buffer for button array (used for ETCMDID_GETBUTTONS)
    int         _nNumButtons;

    VARIANT     _varUserEnteredUrl;     // The URL entered by the user in the address bar.
                                        // Needed for AutoSearch when initiated by Trident.
    BOOL        _fDontInPlaceNavigate() { ASSERT(_fHaveAppHack); return (_dwAppHack & BROWSERFLAG_DONTINPLACE); }
    BOOL        _fCallSetHostName()     { ASSERT(_fHaveAppHack); return (_dwAppHack & BROWSERFLAG_SETHOSTNAME); }
    BOOL        _fUseOpenVerb()         { ASSERT(_fHaveAppHack); return (_dwAppHack & BROWSERFLAG_OPENVERB); }
    BOOL        _fAppHackForExcel()     { ASSERT(_fHaveAppHack); return (_dwAppHack & BROWSERFLAG_OPENCOPY); }

    UINT        posOfflineIcon;

    enum {
        PROGRESS_RESET,
        PROGRESS_FINDING,
        PROGRESS_TICK,
        PROGRESS_SENDING,
        PROGRESS_RECEIVING,
        PROGRESS_FULL
    };

#define PROGRESS_REBASE     100
#define PROGRESS_FINDMAX    30 * PROGRESS_REBASE    //  maximum amount of status on find
#define PROGRESS_SENDMAX    40 * PROGRESS_REBASE    //  maximum amount of status on send
#define PROGRESS_TOTALMAX   100 * PROGRESS_REBASE   //  the total size of the progress bar in find/send
#define PROGRESS_INCREMENT  50          //  default progress increment

#define ADJUSTPROGRESSMAX(dw)   (PROGRESS_REBASE * (dw) )
#define ADJUSTPROGRESSPOS(dw)   ((dw) * PROGRESS_REBASE + ((_dwProgressBase * _dwProgressMax) / PROGRESS_REBASE))

    DWORD       _dwProgressMax; // max progress range for progress bar
    DWORD       _dwProgressPos;
    DWORD       _dwProgressInc;
    DWORD       _dwProgressTicks;
    DWORD       _dwProgressMod;
    DWORD       _dwProgressBase;

#define IDTIMER_PROGRESS        88
#define IDTIMER_PROGRESSFULL    89


#ifdef HLINK_EXTRA
    // Navigation
    IHlinkBrowseContext* _pihlbc;
#endif // HLINK_EXTRA

    // Data associated
    IMoniker*   _pmkCur;
    IBindCtx*   _pbcCur;
    IOleObject* _pole;
    IViewObject* _pvo;
    IStorage*   _pstg;
    IUnknown*   _punkPending;

    IHlinkFrame *_phf;
    IOleCommandTarget*_pocthf;
    IUnknown *_punkSFHistory;

    // Advisory connection
    IAdviseSink *_padvise;
    DWORD _advise_aspect;
    DWORD _advise_advf;

    // View associated (only used when the object is active)
    IOleDocumentView*           _pmsov;
    IOleCommandTarget*          _pmsot;
    IOleControl*                _pmsoc;
    IHlinkSource*               _phls;
    BORDERWIDTHS _bwTools;
    RECT        _rcView;

    int _iZoom;
    int _iZoomMin;
    int _iZoomMax;
    class CDOHBindStatusCallback : public IBindStatusCallback
            , public IAuthenticate
            , public IServiceProvider
            , public IHttpNegotiate
            , public IHttpSecurity

    {
        friend CDocObjectHost;
    protected:
        // *** IUnknown methods ***
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
        virtual STDMETHODIMP_(ULONG) AddRef(void) ;
        virtual STDMETHODIMP_(ULONG) Release(void);

        // *** IAuthenticate ***
        STDMETHODIMP Authenticate(
            HWND *phwnd,
            LPWSTR *pszUsername,
            LPWSTR *pszPassword);

        // *** IServiceProvider ***
        STDMETHODIMP QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj);

        // *** IBindStatusCallback ***
        STDMETHODIMP OnStartBinding(
            /* [in] */ DWORD grfBSCOption,
            /* [in] */ IBinding *pib);

        STDMETHODIMP GetPriority(
            /* [out] */ LONG *pnPriority);

        STDMETHODIMP OnLowResource(
            /* [in] */ DWORD reserved);

        STDMETHODIMP OnProgress(
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);

        STDMETHODIMP OnStopBinding(
            /* [in] */ HRESULT hresult,
            /* [in] */ LPCWSTR szError);

        STDMETHODIMP GetBindInfo(
            /* [out] */ DWORD *grfBINDINFOF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);

        STDMETHODIMP OnDataAvailable(
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);

        STDMETHODIMP OnObjectAvailable(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);

        /* *** IHttpNegotiate ***  */
        STDMETHODIMP BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
                DWORD dwReserved, LPWSTR *pszAdditionalHeaders);

        STDMETHODIMP OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders,
                            LPCWSTR szRequestHeaders,
                            LPWSTR *pszAdditionalRequestHeaders);

        /* *** IHttpSecurity ***  */
        STDMETHODIMP  GetWindow(REFGUID rguidReason, HWND* phwnd);

        STDMETHODIMP OnSecurityProblem(DWORD dwProblem);

    protected:
        ~CDOHBindStatusCallback();
        IBinding*       _pib;
        IBindCtx*       _pbc;
        IBindStatusCallback* _pbscChained;
        IHttpNegotiate* _pnegotiateChained;
        IShellView*     _psvPrev;
        ULONG           _bindst;
        HGLOBAL _hszPostData;
        int _cbPostData;
        LPSTR _pszHeaders;
        LPTSTR _pszRedirectedURL;
        LPTSTR _pszCacheFileName;
        DWORD           _dwBindVerb;            // the verb requested
        DWORD           _dwBindf;               // last set of bind flags returned as a response to the GetBindInfo call...
        DWORD           _cbContentLength;
        BOOL            _fSelfAssociated:1;     //
        BOOL            _fBinding:1;        // downloading
        BOOL            _bFrameIsOffline:1;
        BOOL            _bFrameIsSilent:1;
        BOOL            _fDocWriteAbort:1;      // abort to use _punkPending
        BOOL            _fBoundToMSHTML:1;      // if bound to TRIDENT
        BOOL            _fBoundToNoOleObject:1; // the object does not support IOleObject
        BOOL            _fAborted:1;            // TRUE when AbortBinding called when IDCANCEL for BINDSTATUS_CONTENTDISPOSITIONATTACH

        //Privacy data
        LPTSTR          _pszPolicyRefURL;
        LPTSTR          _pszP3PHeader;
        DWORD           _dwPrivacyFlags;

        CPrivacyQueue   _privacyQueue;
        
        void _Redirect(LPCWSTR pwzNew);
        void _UpdateSSLIcon(void);
        BOOL _DisplayFriendlyHttpErrors(void);
        void _HandleHttpErrors(DWORD dwError, DWORD cbContentLength, CDocObjectHost* pdoh);
        
        HRESULT _HandleFailedNavigationSearch (LPBOOL           pfShouldDisplayError,
                                               DWORD            dwStatusCode,
                                               CDocObjectHost * pdoh,
                                               HRESULT          hrDisplay,
                                               TCHAR          * szURL,
                                               LPCWSTR          szError,
                                               IBinding       * pib,
                                               BOOL             fAddMRU = TRUE,
                                               BOOL             fFromTrident = FALSE);
                                               
        void _CheckForCodePageAndShortcut(void);
        void _DontAddToMRU(CDocObjectHost* pdoh);
        void _UpdateMRU(CDocObjectHost* pdoh, LPCWSTR pszUrl);
        HRESULT _SetSearchInfo(CDocObjectHost *pdoh, DWORD dwIndex, BOOL fAllowSearch, BOOL fContinueSearch, BOOL fSentToEngine);
        void ResetPrivacyInfo();
        HRESULT BuildRecord();
        HRESULT AddToPrivacyQueue(LPTSTR * ppszUrl, LPTSTR * ppszPolicyRef, LPTSTR * ppszP3PHeader, DWORD dwFlags);

    public:
        void AbortBinding(void);
        CDOHBindStatusCallback() : _pib(NULL) {}
        void _RegisterObjectParam(IBindCtx* pbc);
        void _RevokeObjectParam(IBindCtx* pbc);
        void _NavigateToErrorPage(DWORD dwError, CDocObjectHost* pdoh, BOOL fInPlace);
    };

    friend class CDOHBindStatusCallback;
    CDOHBindStatusCallback _bsc;

#ifdef FEATURE_PICS
#define PICS_WAIT_FOR_ASYNC 0x01        /* waiting for async rating query */
#define PICS_WAIT_FOR_INDOC 0x02        /* waiting for in-document rating */
#define PICS_WAIT_FOR_ROOT  0x04        /* waiting for root document */
#define PICS_WAIT_FOR_END   0x08        /* waiting for end of document */

#define PICS_MULTIPLE_FLAGS PICS_WAIT_FOR_INDOC     /* sources which can produce multiple results */

#define PICS_LABEL_FROM_HEADER 0        /* label was obtained from the http header */
#define PICS_LABEL_FROM_PAGE   1        /* label was obtained from the page itself */

    /*
     * _fPicsBlockLate - TRUE if we're using a DocObject which we have
     *                   to allow to download completely because we may
     *                   need to get ratings out of it.  FALSE if we
     *                   just want to block it as early as possible
     *                   (usually at OnProgress(CLASSIDAVAILABLE)).
     * _fSetTarget - bug 29364: this indicates we are calling _StartAsyncBinding
     *               and we shouldn't do any activation, even if we're told to.
     *               Has URLMON changed how it binds to objects? (GregJ claims
     *               that URLMON never called OnObjectAvailable synchronously
     *               with the _StartAsyncBinding call...) It also seems that
     *               both Trident and this PICS stuff use the
     *               message SHDVID_ACTIVATEMENOW which might confuse
     *               the delayed activation stuff CDTurner put in... [mikesh]
     */

    BOOL        _fSetTarget:1;
    BOOL        _fPicsBlockLate:1;

    class CPicsProcessor : public IOleCommandTarget
    {
    // Everything public because the _bsc needs to get at base proc
    public:
        friend class CDocObjectHost;

        CPicsProcessor();
        ~CPicsProcessor() { _ReInit(); }
        void _ReInit();

        // *** IUnknown methods ***
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
        virtual STDMETHODIMP_(ULONG) AddRef(void) ;
        virtual STDMETHODIMP_(ULONG) Release(void);

        // IOleCommandTarget equivalent (virtual / both direction)
        STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
            ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
        STDMETHODIMP Exec(const GUID *pguidCmdGroup,
            DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

        /* PICS state flags:
         *
         * _fPicsAccessAllowed - Whether the most significant rating we've
         *                       found so far (that actually applies to the
         *                       thing we're browsing to) would allow access.
         *                       Once all rating sources report in, this flag
         *                       indicates whether the user can see the content.
         */
        BYTE            _fPicsAccessAllowed:1;
        BYTE            _fInDialog:1;
        BYTE            _fTerminated:1;

        /* The following flags are a separate bitfield so I can easily test
         * "if (!_fbPicsWaitFlags)" to see if I'm done waiting.
         *
         * IMPORTANT: The flags are in order of precedence.  That is, ASYNC
         * is more important than INDOC, which is more important than ROOT.
         * This way, given any flag which specifies the source of a rating,
         * if that rating applies to the content, then
         *
         *  _fbPicsWaitFlags &= (flag - 1);
         *
         * will turn off that flag and all flags above it, causing the code
         * to not consider any further ratings from that source or less
         * important sources.
         */
        BYTE        _fbPicsWaitFlags;

        DWORD       _dwPicsLabelSource;
        LPVOID      _pRatingDetails;
        DWORD       _dwPicsSerialNumber;    /* serial number for async query */
        DWORD       _dwKey;                 /* Key for identifying CPicsProcs */
        HANDLE      _hPicsQuery;            /* handle to async query event */
        LPTSTR      _pszPicsURL;            /* result of CoInternetGetSecurityUrl */

        IHTMLPrivateWindow *    _pPrivWindow;       /* Private Window on behalf of which this proccessing is being done */
        CPicsRootDownload *     _pRootDownload;     /* object managing root document download */
        CDocObjectHost *        _pdoh;          

        CPicsProcessor *        _pPicsProcNext;     /* the next pics proc in the chain */

        LONG_PTR _GetKey() { return (LONG_PTR)_dwKey; }
        UINT    _PicsBlockingDialog();
        HRESULT _StartPicsQuery(LPCOLESTR pwszRawURL);
        void    _HandlePicsChecksComplete();
        void    _GotLabel(HRESULT hres, LPVOID pDetails, BYTE bfSource);
        void    _HandleInDocumentLabel(LPCTSTR pszLabel);
        void    _HandleDocumentEnd(void);
        void    _StartPicsRootQuery(LPCTSTR pszURL);
        void    _Terminate();
    };

    friend class CPicsProcessor;
    CPicsProcessor _PicsProcBase;
    DWORD          _dwPicsKeyBase;

    CPicsProcessor* _GetPicsProcessorFromKey(LONG_PTR lKey);
    CPicsProcessor* _GetPicsProcessorFromSerialNumber( DWORD dwPicsSerialNumber );
    void            _StartBasePicsProcessor();
    HRESULT         _StartSecondaryPicsProcessor(IHTMLPrivateWindow * pPrivWindow);
    HRESULT         _RemovePicsProcessorByKey(LONG_PTR lKey);
    HRESULT         _RemovePicsProcessorByPrivWindowUnk(IUnknown* pUnkFind);
    HRESULT         _RemoveAllPicsProcessors();

#endif

    BSTR                _strPriorityStatusText;

    // support for caching of script errors
    CScriptErrorList *  _pScriptErrList;
    BOOL                _fScriptErrDlgOpen;
    BOOL                _fShowScriptErrDlgAgain;
    HRESULT             _ScriptErr_CacheInfo(VARIANTARG *pvarIn);
    void                _ScriptErr_Dlg(BOOL fOverrridePerErrorMode);
};


#ifdef FEATURE_PICS

//#include <brwsectl.h>   /* for IBrowseControl */

class CPicsRootDownload : public IBindStatusCallback,
                                 IOleClientSite, IServiceProvider,
                                 IDispatch
{
protected:
    UINT m_cRef;
    long m_lFlags;
    IOleCommandTarget *m_pctParent;
    IOleObject *m_pole;
    IOleCommandTarget *m_pctObject;
    IBinding *m_pBinding;
    IBindCtx *m_pBindCtx;

    void _NotifyEndOfDocument(void);
    HRESULT _Abort(void);
    BOOL m_fFrameIsSilent:1;
    BOOL m_fFrameIsOffline:1;

public:
    CPicsRootDownload(IOleCommandTarget *pctParent, BOOL fFrameIsOffline, BOOL fFrameIsSilent);
    ~CPicsRootDownload();

    HRESULT StartDownload(IMoniker *pmk);
    void CleanUp(void);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IBindStatusCallback methods
    STDMETHODIMP    OnStartBinding(DWORD dwReserved, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                        STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // IOleClientSite
    STDMETHODIMP SaveObject(void);
    STDMETHODIMP GetMoniker(DWORD, DWORD, IMoniker **);
    STDMETHODIMP GetContainer(IOleContainer **);
    STDMETHODIMP ShowObject(void);
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout(void);

    // IServiceProvider (must be QI'able from IOleClientSite)
    STDMETHODIMP QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj);

    // *** IDispatch methods ***
    STDMETHOD(GetTypeInfoCount) (unsigned int *pctinfo)
        { return E_NOTIMPL; };
    STDMETHOD(GetTypeInfo) (unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return E_NOTIMPL; };
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, unsigned int cNames, LCID lcid, DISPID * rgdispid)
        { return E_NOTIMPL; };
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams,
                        VARIANT * pvarResult,EXCEPINFO * pexcepinfo,UINT * puArgErr);
};

// IID_IsPicsBrowser is a way we can use pClientSite->QueryService to find out
// if the top-level browser is a PICS root document download or not, so we can
// avoid navigating sub-frames.  No real interface corresponds to this IID, we
// just return an IUnknown pointer.
EXTERN_C const GUID IID_IsPicsBrowser;   // F114C2C0-90BE-11D0-83B1-00C04FD705B2

#endif


void DeleteFileSent(LPTSTR *ppszTempFile);
BOOL ShouldShellExecURL( LPTSTR pszURL );
DWORD GetSyncMode (DWORD dwDefault);

// in Dochost.cpp
BOOL _ValidateURL(LPTSTR pszName, DWORD dwFlags);
void GetAppHackFlags(IOleObject* pole, const CLSID* pclsid, DWORD* pdwAppHack);

BOOL _IsDesktopItem(CDocObjectHost * pdoh);
BOOL IsAssociatedWithIE(LPCWSTR pwszFileName);
UINT OpenSafeOpenDialog(HWND hwnd, UINT idRes, LPCTSTR pszFileClass, LPCTSTR pszURL, LPCTSTR pszRedirURL, LPCTSTR pszCacheName, LPCTSTR pszDisplay, UINT uiCP, IUnknown *punk = NULL, BOOL fDisableOpen = FALSE);

void CDownLoad_OpenUI(IMoniker* pmk, 
                      IBindCtx *pbc, 
                      BOOL fSync, 
                      BOOL fSaveAs=FALSE, 
                      BOOL fSafe=FALSE, 
                      LPWSTR pwzHeaders = NULL, 
                      DWORD dwVerb=BINDVERB_GET, 
                      DWORD grfBINDF = (BINDF_ASYNCHRONOUS | BINDF_PULLDATA), 
                      BINDINFO* pbinfo = NULL,
                      LPCTSTR pszRedir=NULL,
                      UINT uiCP = CP_ACP,
                      IUnknown *punk = NULL,
                      BOOL fConfirmed=FALSE
                      );

HRESULT CDownLoad_OpenUIURL(LPCWSTR pwszURL, IBindCtx *pbc, LPWSTR pwzHeaders, BOOL fSync, BOOL fSaveAs=FALSE, BOOL fSafe=FALSE, DWORD dwVerb=BINDVERB_GET, DWORD grfBINDF=(BINDF_ASYNCHRONOUS | BINDF_PULLDATA), BINDINFO* pbinfo=NULL,
                    LPCTSTR pszRedir=NULL, UINT uiCP=CP_ACP, IUnknown *punk = NULL, BOOL fConfirmed=FALSE);

HRESULT _GetRequestFlagFromPIB(IBinding *pib, DWORD *pdwOptions);
HRESULT _SetSearchInfo (IServiceProvider *psp, DWORD dwIndex, BOOL fAllowSearch, BOOL fContinueSearch, BOOL fSentToEngine);
HRESULT _GetSearchInfo (IServiceProvider *psp, LPDWORD pdwIndex, LPBOOL pfAllowSearch, LPBOOL pfContinueSearch, LPBOOL pfSentToEngine);


// Values for automatically scanning common net suffixes

#define NO_SUFFIXES     0
#define SCAN_SUFFIXES   1
#define DONE_SUFFIXES   2

// Registry values for automatically sending request to search engine

#define NEVERSEARCH     0
#define PROMPTSEARCH    1
#define ALWAYSSEARCH    2

#define SHOULD_DO_SEARCH(x,y) (y || (x && x != DONE_SUFFIXES))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\droptgt.cpp ===
#include "priv.h"
#include "..\inc\droptgt.h"

#include "..\inc\droptgt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\download.cpp ===
#include "priv.h"
#include "bindcb.h"
#include "resource.h"
#include <vrsscan.h>
#include "iface.h"
#include "security.h"
#include <wintrust.h>
#include "iehelpid.h"
#include <shlwapi.h>
#include "inetreg.h"
#include <varutil.h>
#include "dochost.h"
#include <mluisupp.h>
#include <downloadmgr.h>
#include "apithk.h"
#include "richedit.h"
#include <brutil.h>
#include <winsaferp.h>


#define MIME
#include "filetype.h"


#define ALLFILE_WILDCARD TEXT("*.*")

#define MAX_BYTES_STRLEN 64
#define CALC_NOW 5  // Recalcs Estimated time left every this many'th call to OnProgress

//
//  Enable WinVerifyTrust
//
#define CALL_WVT

#ifdef CALL_WVT
#include "wvtp.h"

//
//  Note that this is a global variable. It means we don't call LoadLibrary
// everytime we download an EXE (good), but the user need to reboot if
// WINTRUST.DLL is added later (bad). Since WINTRUST.DLL is part of IE 3.0,
// this is sufficient at this point.
//
Cwvt g_wvt;

HWND g_hDlgActive = NULL;   // get rid of this, not needed

//
// A named mutex is being used to determine if a critical operation exist, such as a file download.
// When we detect this we can prevent things like going offline while a download is in progress.
// To start the operation Create the named mutex. When the op is complete, close the handle.
// To see if any pending operations are in progress, Open the named mutex.  Success/fail will indicate
// if any pending operations exist.  This mechanism is being used to determine if a file download is
// in progress when the user attempts to go offline.  If so, we prompt them to let them know that going 
// offline will cancel the download(s).
HANDLE g_hCritOpMutex = NULL;


// SafeOpen dialog

UINT _VerifyTrust(HWND hwnd, LPCTSTR pszFileName, LPCWSTR pszStatusText);
#endif // CALL_WVT

// Do strong typechecking on the parameters
#ifdef SAFECAST
#undef SAFECAST
#endif
#define SAFECAST(_src, _type) (((_type)(_src)==(_src)?0:0), (_type)(_src))

extern HRESULT _GetRequestFlagFromPIB(IBinding *pib, DWORD *pdwOptions);
extern HRESULT _PrepareURLForDisplayUTF8W(LPCWSTR pwz, LPWSTR pwzOut, LPDWORD pcchOut, BOOL fUTF8Enabled, UINT uiCP);


UINT IE_ErrorMsgBox(IShellBrowser* psb,
                    HWND hwnd, HRESULT hrError, LPCWSTR szError, LPCTSTR szURL,
                    UINT idResource, UINT wFlags);
BOOL IsAssociatedWithIE(LPCWSTR pszFileName);

extern "C" EXECUTION_STATE WINAPI pSetThreadExecutionState(EXECUTION_STATE esFlags);  // Win2k+, Win98+ kernel32 API

#define DM_DOWNLOAD             TF_SHDPROGRESS
#define DM_PROGRESS             TF_SHDPROGRESS
#define DM_WVT                  TF_SHDPROGRESS

#define DWNLDMSG(psz, psz2)     TraceMsg(DM_DOWNLOAD, "shd TR-DWNLD::%s %s", psz, psz2)
#define DWNLDMSG2(psz, x)       TraceMsg(DM_DOWNLOAD, "shd TR-DWNLD::%s %x", psz, x)
#define DWNLDMSG3(psz, x, y)    TraceMsg(DM_DOWNLOAD, "shd TR-DWNLD::%s %x %x", psz, x, y)
#define DWNLDMSG4(psz, x, y, z) TraceMsg(DM_DOWNLOAD, "shd TR-DWNLD::%s %x %x %x", psz, x, y, z)

#define SAFEMSG(psz, psz2)      TraceMsg(0, "shd TR-SAFE::%s %s", psz, psz2)
#define SAFEMSG2(psz, x)        TraceMsg(0, "shd TR-SAFE::%s %x", psz, x)
#define EXPMSG(psz, psz2)       TraceMsg(0, "shd TR-EXP::%s %s", psz, psz2)
#define MDLGMSG(psz, x)         TraceMsg(0, "shd TR-MODELESS::%s %x", psz, x)
#define MSGMSG(psz, x)          TraceMsg(TF_SHDTHREAD, "ief MMSG::%s %x", psz, x)
#define PARKMSG(psz, x)         TraceMsg(TF_SHDTHREAD, "ief MPARK::%s %x", psz, x)

// File name and 32 for the rest of the title string
#define TITLE_LEN    (256 + 32)
#define MAX_DISPLAY_LEN 96
#define MAX_SCHEME_STRING 16
class CDownload : public IBindStatusCallback
            , public IAuthenticate
            , public IServiceProvider
            , public IHttpNegotiate
            , public IWindowForBindingUI
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // *** IAuthenticate ***
    STDMETHODIMP Authenticate(
        HWND *phwnd,
        LPWSTR *pszUsername,
        LPWSTR *pszPassword);

    // *** IServiceProvider ***
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

    // *** IBindStatusCallback ***
    STDMETHODIMP OnStartBinding(
        /* [in] */ DWORD grfBSCOption,
        /* [in] */ IBinding *pib);

    STDMETHODIMP GetPriority(
        /* [out] */ LONG *pnPriority);

    STDMETHODIMP OnLowResource(
        /* [in] */ DWORD reserved);

    STDMETHODIMP OnProgress(
        /* [in] */ ULONG ulProgress,
        /* [in] */ ULONG ulProgressMax,
        /* [in] */ ULONG ulStatusCode,
        /* [in] */ LPCWSTR szStatusText);

    STDMETHODIMP OnStopBinding(
        /* [in] */ HRESULT hresult,
        /* [in] */ LPCWSTR szError);

    STDMETHODIMP GetBindInfo(
        /* [out] */ DWORD *grfBINDINFOF,
        /* [unique][out][in] */ BINDINFO *pbindinfo);

    STDMETHODIMP OnDataAvailable(
        /* [in] */ DWORD grfBSCF,
        /* [in] */ DWORD dwSize,
        /* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pstgmed);

    STDMETHODIMP OnObjectAvailable(
        /* [in] */ REFIID riid,
        /* [iid_is][in] */ IUnknown *punk);

    /* *** IHttpNegotiate ***  */
    STDMETHODIMP BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
            DWORD dwReserved, LPWSTR *pszAdditionalHeaders);

    STDMETHODIMP OnResponse(DWORD dwResponseCode,
                        LPCWSTR szResponseHeaders,
                        LPCWSTR szRequestHeaders,
                        LPWSTR *pszAdditionalRequestHeaders);

    STDMETHODIMP GetWindow(REFGUID RefGUI, HWND* phWnd);

protected:
    LONG        _cRef;
    LONG        _cRefDLD;
    IBinding*   _pib;
    IBindCtx*   _pbc;
    CDocObjectHost *_pdoh;
    HWND        _hDlg;
    HWND        _hwndToolTips;
    BOOL        _fSaveAs : 1;
    BOOL        _fGotFile : 1;
    BOOL        _fFirstTickValid : 1;
    BOOL        _fEndDialogCalled : 1;
    BOOL        _fDontPostQuitMsg : 1;  // Posts WM_QUIT message in destructor
    BOOL        _fCallVerifyTrust : 1;
    BOOL        _fStrsLoaded : 1;
    BOOL        _fSafe : 1;             // no need to call IsSafe dialog
    BOOL        _fDownloadStarted : 1; // Have we started receiving data
    BOOL        _fDownloadCompleted : 1;  // We have received BSCF_LASTDATANOTIFICATION
    BOOL        _fDeleteFromCache : 1; // Delete the file from cache when done
    BOOL        _fWriteHistory : 1;  // Should it be written to history? (SECURITY)
    BOOL        _fDismissDialog : 1;
    BOOL        _fUTF8Enabled : 1;
    DWORD       _dwFirstTick;
    DWORD       _dwFirstSize;
    DWORD       _dwTotalSize;           // Size of file downloaded so far
    DWORD       _dwFileSize;            // Size of file to download
    HICON       _hicon;
    TCHAR       _szPath[MAX_PATH];      // ok with MAX_PATH
    TCHAR       _szSaveToFile[MAX_PATH];    // File to Save to
    TCHAR       _szEstimateTime[MAX_PATH];  // ok with MAX_PATH
    TCHAR       _szBytesCopied[MAX_PATH];  // ok with MAX_PATH
    TCHAR       _szTitlePercent[TITLE_LEN];
    TCHAR       _szTitleBytes[TITLE_LEN];
    TCHAR       _szTransferRate[TITLE_LEN];
    TCHAR       _szURL[MAX_URL_STRING];
    TCHAR       _szDisplay[MAX_DISPLAY_LEN];   // URL to be displayed
    TCHAR       _szDefDlgTitle[256];
    TCHAR       _szExt[10];
    DWORD       _grfBINDF;
    BINDINFO*   _pbinfo;
    LPWSTR      _pwzHeaders;
    IMoniker*   _pmk;                   // WARNING: No ref-count (only for modal)
    LPWSTR      _pwszDisplayName;
    DWORD       _dwVerb;
    UINT        _uiCP;                  // Code page
    DWORD       _dwOldEst;
    ULONG       _ulOldProgress;
    DWORD       _dwOldRate;
    DWORD       _dwOldPcent;
    DWORD       _dwOldCur;
    BOOL        _fConfirmed;


    void SetMoniker(IMoniker* pmk) { _pmk=pmk; }
    BOOL _IsModal(void) { return (bool)_pmk; }

    virtual ~CDownload();
    friend INT_PTR CALLBACK DownloadDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK SafeOpenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    UINT _MayAskUserIsFileSafeToOpen(LPCTSTR pszMime);
    BOOL _GetSaveLocation(void);
    BOOL _SaveFile(void);
    void _DeleteFromCache(void);
    ULONG AddRefDLD(void);
    ULONG ReleaseDLD(void);
    HRESULT PerformVirusScan(LPCTSTR szFileName);

public:
    CDownload(BOOL fSaveAs = FALSE, LPWSTR pwzHeaders = NULL,
              DWORD grfBINDF = BINDF_ASYNCHRONOUS, BINDINFO* pbinfo = NULL,
              BOOL fSafe = FALSE, DWORD dwVerb = BINDVERB_GET, LPCTSTR pszRedir=NULL, UINT uiCP=CP_ACP, BOOL fConfirmed = FALSE);

    static void OpenUI(IMoniker* pmk, IBindCtx *pbc, BOOL fSaveAs = FALSE, BOOL fSafe = FALSE, LPWSTR pwzHeaders = NULL, DWORD dwVerb = BINDVERB_GET, DWORD grfBINDF = 0, BINDINFO* pbinfo = NULL, LPCTSTR pszRedir=NULL, UINT uiCP=CP_ACP, BOOL fConfirmed = FALSE);

    HRESULT StartBinding(IMoniker* pmk, IBindCtx *pbc = NULL);
    void EndDialogDLD(UINT id);
    void ShowStats(void);
    BOOL SetDismissDialogFlag(BOOL fDismiss) { return(_fDismissDialog = fDismiss); }
    BOOL GetDismissDialogFlag(void) { return(_fDismissDialog); }
#ifdef USE_LOCKREQUEST
    HRESULT LockRequestHandle(void);
#endif
};

CDownload::CDownload(BOOL fSaveAs, LPWSTR pwzHeaders, DWORD grfBINDF, BINDINFO* pbinfo, BOOL fSafe, DWORD dwVerb, LPCTSTR pszRedir, UINT uiCP, BOOL fConfirmed)
    : _cRef(1), _fSaveAs(fSaveAs), _fWriteHistory(1),
      _grfBINDF(grfBINDF), _pbinfo(pbinfo), _fSafe(fSafe), _pwzHeaders(pwzHeaders), _dwVerb(dwVerb), _uiCP(uiCP), _fConfirmed(fConfirmed)
{
    ASSERT(_fStrsLoaded == FALSE);
    ASSERT(_fDownloadStarted == FALSE);
    ASSERT(_fDownloadCompleted == FALSE);
    ASSERT(_fGotFile == FALSE);
    ASSERT(_fUTF8Enabled == FALSE);
    ASSERT(_hDlg == NULL);
    ASSERT(_pwszDisplayName == NULL);
    ASSERT(_dwTotalSize == 0);
    ASSERT(_dwFileSize == 0);
    ASSERT(_dwFirstTick == 0);
    ASSERT(_ulOldProgress == 0);
    ASSERT(_dwOldRate == 0);
    ASSERT(_dwOldPcent == 0);
    ASSERT(_dwOldCur == 0);

    _dwOldEst = 0xffffffff;
    
    if (pszRedir && lstrlen(pszRedir))
        StrCpyN(_szURL, pszRedir, ARRAYSIZE(_szURL) - 1); // -1 ???

    TraceMsg(TF_SHDLIFE, "CDownload::CDownload being constructed");
}

void ProcessStartbindingError(HWND hWnd, LPTSTR pszTitle, LPTSTR pszText, UINT uiFlag, HRESULT hres, LPCTSTR pszUrl)
{
    int nRet = -1;
    if (E_ACCESSDENIED == hres)
    {
        if(IEHardened() && pszUrl && pszUrl[0] != _T('\0'))
        {
            // Specialized dialog Windows DCR # 771532
            HMODULE hmod = LoadLibrary(TEXT("urlmon.dll"));

            if(hmod)
            {
                int (*pfnShowTrustAlertDialog)(HWND, IInternetSecurityManager *, LPVOID, LPCWSTR) = 
                    (int (*)(HWND, IInternetSecurityManager *, LPVOID, LPCWSTR))GetProcAddress(hmod, "ShowTrustAlertDialog");
                    
                if(pfnShowTrustAlertDialog)
                {
                    if(-1 == (nRet = pfnShowTrustAlertDialog(hWnd, NULL, NULL, pszUrl )) )
                    {
                        TraceMsg(DM_WARNING, "ShowTrustAlertDialog call from ProcessStartbindingError failed %x", GetLastError());
                    }
                }
                FreeLibrary(hmod);
            }
        }
        else
        {
            pszText = MAKEINTRESOURCE(IDS_DOWNLOADDISALLOWED);
            pszTitle = MAKEINTRESOURCE(IDS_SECURITYALERT);
            uiFlag = MB_ICONWARNING;
        }
    }

    if(-1 == nRet)
    {
        MLShellMessageBox(hWnd, pszText, pszTitle, MB_OK | MB_SETFOREGROUND | uiFlag );
    }

    if (IsValidHWND(hWnd))
    {
        FORWARD_WM_COMMAND(hWnd, IDCANCEL, NULL, 0, PostMessage);
    }
}

HRESULT SelectPidlInSFV(IShellFolderViewDual *psfv, LPCITEMIDLIST pidl, DWORD dwOpts)
{
    VARIANT var;
    HRESULT hr = InitVariantFromIDList(&var, pidl);
    if (SUCCEEDED(hr))
    {
        hr = psfv->SelectItem(&var, dwOpts);
        VariantClear(&var);
    }

    return hr;
}

void OpenFolderPidl(LPCITEMIDLIST pidl)
{
    SHELLEXECUTEINFO shei = { 0 };

    shei.cbSize     = sizeof(shei);
    shei.fMask      = SEE_MASK_INVOKEIDLIST;
    shei.nShow      = SW_SHOWNORMAL;
    shei.lpIDList   = (LPITEMIDLIST)pidl;
    ShellExecuteEx(&shei);
}

STDAPI OpenContainingFolderAndGetShellFolderView(HWND hwnd, LPCITEMIDLIST pidlFolder, IShellFolderViewDual **ppsfv)
{
    *ppsfv = NULL;
    
    IWebBrowserApp *pauto;
    HRESULT hr = SHGetIDispatchForFolder(pidlFolder, &pauto);
    if (SUCCEEDED(hr))
    {
        // We have IDispatch for window, now try to get one for
        // the folder object...
        HWND hwnd;
        if (SUCCEEDED(pauto->get_HWND((LONG_PTR *)&hwnd)))
        {
            // Make sure we make this the active window
            SetForegroundWindow(hwnd);
            ShowWindow(hwnd, SW_SHOWNORMAL);

        }
        IDispatch * pautoDoc;
        hr = pauto->get_Document(&pautoDoc);
        if (SUCCEEDED(hr))
        {
            hr = pautoDoc->QueryInterface(IID_PPV_ARG(IShellFolderViewDual, ppsfv));
            pautoDoc->Release();
        }
        pauto->Release();
    }
    return hr;
}

//
// Stolen (and modified) from shell\ext\mydocs2\prop.cpp which was from link.c in shell32.dll
//
void FindTarget(HWND hDlg, LPTSTR pPath)
{
    USHORT uSave;

    LPITEMIDLIST pidl = ILCreateFromPath( pPath );
    if (!pidl)
        return;

    LPITEMIDLIST pidlLast = ILFindLastID(pidl);

    // get the folder, special case for root objects (My Computer, Network)
    // hack off the end if it is not the root item
    if (pidl != pidlLast)
    {
        uSave = pidlLast->mkid.cb;
        pidlLast->mkid.cb = 0;
    }
    else
        uSave = 0;

    LPITEMIDLIST pidlDesk;
    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY, &pidlDesk)))
    {
        BOOL fIsDesktopDir = pidlDesk && ILIsEqual(pidl, pidlDesk);

        if (fIsDesktopDir || !uSave)  // if it's in the desktop dir or pidl == pidlLast (uSave == 0 from above)
        {
            //
            // It's on the desktop...
            //

            MLShellMessageBox(hDlg, (LPTSTR)IDS_ON_DESKTOP, (LPTSTR)IDS_FIND_TITLE,
                             MB_OK | MB_ICONINFORMATION | MB_APPLMODAL | MB_TOPMOST);
        }
        else
        {
            if (WhichPlatform() == PLATFORM_BROWSERONLY)
            {
                OpenFolderPidl(pidl);
            }
            else
            {
                IShellFolderViewDual *psfv;
                if (SUCCEEDED(OpenContainingFolderAndGetShellFolderView(hDlg, uSave ? pidl : pidlDesk, &psfv)))
                {
                    if (uSave)
                        pidlLast->mkid.cb = uSave;
                    SelectPidlInSFV(psfv, pidlLast, SVSI_SELECT | SVSI_FOCUSED | SVSI_DESELECTOTHERS | SVSI_ENSUREVISIBLE);
                    psfv->Release();
                }
            }
        }
        ILFree(pidlDesk);
    }

    ILFree(pidl);
}

BOOL SetExemptDelta(LPCTSTR pszURL, DWORD dwExemptDelta)
{
    BOOL fRC;
    INTERNET_CACHE_ENTRY_INFO icei;
    icei.dwStructSize = sizeof(icei);
    icei.dwExemptDelta = dwExemptDelta;    // Number of seconds from last access time to keep entry
    // Retry setting the exempt delta if it fails since wininet may have either not have created the
    //    entry yet or might have it locked.
    for (int i = 0; i < 5; i++)
    {
        if (fRC = SetUrlCacheEntryInfo(pszURL, &icei, CACHE_ENTRY_EXEMPT_DELTA_FC))
            break;
        Sleep(1000);
    }
    return fRC;
}

INT_PTR CALLBACK DownloadDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static fInBrowseDir = FALSE;
    CDownload* pdld = (CDownload*) GetWindowLongPtr(hDlg, DWLP_USER);
    DWORD dwExStyle = 0;
    TCHAR szURL[MAX_URL_STRING];    // make copies since EndDialog will delete CDownload obj
    BOOL fDownloadAborted;

    DWNLDMSG4("DownloadDlgProc ", uMsg, wParam, lParam);

    if ((pdld == NULL) && (uMsg != WM_INITDIALOG))
    {
        RIPMSG(TRUE, "CDownload freed (pdld == NULL) && (uMsg != WM_INITDIALOG)");
        return FALSE;
    }
    
    switch (uMsg) {
    case WM_INITDIALOG:
    {
        TCHAR szYesNo[20];
        DWORD dwType = REG_SZ;
        DWORD dwSize = ARRAYSIZE(szYesNo);

        if (lParam == NULL)
            return FALSE;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pdld = (CDownload*)lParam;
        pdld->_hDlg = hDlg;

        EnableMenuItem(GetSystemMenu(hDlg, FALSE), SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(GetSystemMenu(hDlg, FALSE), SC_SIZE, MF_BYCOMMAND | MF_GRAYED);

        EnableWindow(GetDlgItem(hDlg, IDD_OPENFILE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_BROWSEDIR), FALSE);

        // On BiDi Loc Win98 & NT5 mirroring will take care of that
        // Need to fix only on BiBi Win95 Loc
        if (g_bBiDiW95Loc)
        {
            SetWindowBits(GetDlgItem(hDlg, IDD_DIR), GWL_EXSTYLE, WS_EX_RTLREADING, WS_EX_RTLREADING);
        }
        MLLoadString(IDS_DEFDLGTITLE, pdld->_szDefDlgTitle, ARRAYSIZE(pdld->_szDefDlgTitle));

        if (pdld->_hwndToolTips = CreateWindowEx(dwExStyle, TOOLTIPS_CLASS, NULL, WS_POPUP | TTS_ALWAYSTIP,
                                  CW_USEDEFAULT, CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
                                  hDlg, NULL, HINST_THISDLL, NULL))
        {
            TOOLINFO ti;

            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
            ti.hwnd = hDlg;
            ti.uId = (UINT_PTR) GetDlgItem(hDlg, IDD_NAME);
            ti.lpszText = LPSTR_TEXTCALLBACK;
            ti.hinst = HINST_THISDLL;
            GetWindowRect((HWND)ti.uId, &ti.rect);
            SendMessage(pdld->_hwndToolTips, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
        }
        // make sure we support cross-lang platform
        SHSetDefaultDialogFont(hDlg, IDD_NAME);

        pdld->SetDismissDialogFlag(FALSE);
        if ( SHRegGetUSValue( TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                              TEXT("NotifyDownloadComplete"),
                              &dwType, (void *)szYesNo, &dwSize, FALSE, NULL, 0 ) == ERROR_SUCCESS )
        {
            pdld->SetDismissDialogFlag(!StrCmpI(szYesNo, TEXT("No")));
        }
        CheckDlgButton(hDlg, IDD_DISMISS, pdld->GetDismissDialogFlag());

        DWNLDMSG("DownloadDlgProc", "Got WM_INITDIALOG");
        Animate_OpenEx(GetDlgItem(hDlg, IDD_ANIMATE), HINST_THISDLL, MAKEINTRESOURCE(IDA_DOWNLOAD));
        ShowWindow(GetDlgItem(hDlg, IDD_DOWNLOADICON), SW_HIDE);

        g_hCritOpMutex = CreateMutexA(NULL, TRUE, "CritOpMutex");
        
        // Automatically start binding if we are posting synchronously.
        if (pdld->_IsModal()) 
        {
            HRESULT hres = pdld->StartBinding(pdld->_pmk);
            ASSERT(pdld->_pmk);
            if (FAILED(hres))
            {
                ProcessStartbindingError(hDlg, MAKEINTRESOURCE(IDS_DOWNLOADFAILED),
                                         pdld->_szDisplay, MB_ICONWARNING, hres, pdld->_szURL);
            }
        }

        return TRUE;
    }

    case WM_SIZE:
        if ((wParam == SIZE_MAXIMIZED) || (wParam == SIZE_RESTORED))
            SetWindowText(hDlg, pdld->_szDefDlgTitle);
        break;

    case WM_NOTIFY:
    {
        LPTOOLTIPTEXT lpTT = (LPTOOLTIPTEXT) lParam;
        if (lpTT->hdr.code == TTN_NEEDTEXT)
        {
            lpTT->lpszText = pdld->_szURL;
            lpTT->hinst = NULL;
        }
    }
    break;

    case WM_COMMAND:
        DWNLDMSG2("DownloadDlgProc WM_COMMAND id =", GET_WM_COMMAND_ID(wParam, lParam));
        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        {
        case IDD_SAVEAS:
            if (pdld) 
            {
                pdld->AddRefDLD();
                BOOL fSuccess = FALSE;

                // Prevent someone from canceling dialog while the shell copy etc. is going on
                EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);
                
                // If zone check fails or if we found virus, bail out and remove file from cache.
                if (pdld->PerformVirusScan(pdld->_szPath) != S_OK) 
                {
                    pdld->_fDeleteFromCache = TRUE;
                    pdld->EndDialogDLD(IDCANCEL);
                    break;
                }

                fSuccess = pdld->_SaveFile();

                AddUrlToUrlHistoryStg(pdld->_pwszDisplayName, NULL, NULL, pdld->_fWriteHistory, NULL, NULL, NULL);
                // -- BharatS --- Only add to history if Visible ?

                IEPlaySound(TEXT("SystemAsterisk"), TRUE);
                
                if (fSuccess)
                {
                    if (pdld->SetDismissDialogFlag(IsDlgButtonChecked(hDlg, IDD_DISMISS) == BST_CHECKED))
                    {
                        StrCpyN(szURL, pdld->_szURL, ARRAYSIZE(szURL));
                        pdld->EndDialogDLD(IDCANCEL);
                        SetExemptDelta(szURL, 0);
                    }
                    else
                    {
                        TCHAR szStr[MAX_PATH];

                        if (MLLoadString(IDS_CLOSE, szStr, ARRAYSIZE(szStr)))
                        {
                            SetWindowText(GetDlgItem(hDlg, IDCANCEL), szStr);
                        }

                        ShowWindow(GetDlgItem(hDlg, IDD_ANIMATE), SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDD_DNLDESTTIME), SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDD_DNLDCOMPLETEICON), SW_SHOW);
                        ShowWindow(GetDlgItem(hDlg, IDD_DNLDCOMPLETETEXT), SW_SHOW);
                        ShowWindow(GetDlgItem(hDlg, IDD_DNLDTIME), SW_SHOW);
                        
                        MLLoadString(IDS_SAVED, szStr, ARRAYSIZE(szStr));
                        SetDlgItemText(hDlg, IDD_OPENIT, szStr);

                        MLLoadString(IDS_DOWNLOADCOMPLETE, szStr, ARRAYSIZE(szStr));
                        SetWindowText(hDlg, szStr);

                        EnableWindow(GetDlgItem(hDlg, IDD_OPENFILE), TRUE);
                        EnableWindow(GetDlgItem(hDlg, IDD_BROWSEDIR), TRUE);

                        pdld->ShowStats();
                        pdld->ReleaseDLD();
                    }
                }
                else
                {
                    pdld->ReleaseDLD();
                }
                
                EnableWindow(GetDlgItem(hDlg, IDCANCEL), TRUE);
            }
            break;

        case IDCANCEL:  // Cancel on abort, Close on dismiss
            if (pdld && IsWindowEnabled(GetDlgItem(hDlg, IDCANCEL))) 
            {
                pdld->AddRefDLD();
                fDownloadAborted  = pdld->_fDownloadStarted && !pdld->_fDownloadCompleted;
                StrCpyN(szURL, pdld->_szURL, ARRAYSIZE(szURL));
                
                if (pdld->_pib) 
                {
                    HRESULT hresT;
                    hresT = pdld->_pib->Abort();
                    TraceMsg(DM_DOWNLOAD, "DownloadDlgProc::IDCANCEL: called _pib->Abort() hres=%x", pdld->_pib, hresT);
                }
                pdld->EndDialogDLD(IDCANCEL);
                
                // Download was canceled.  Increase exempt time to keep downloaded a bit in case download is resumed
                SetExemptDelta(szURL, fDownloadAborted ?60*60*24 :0);
            }
            break;

        case IDD_BROWSEDIR:
                if (!fInBrowseDir) 
                {
                    pdld->AddRefDLD();  
                    fInBrowseDir = TRUE;    
                    
                    FindTarget(hDlg, pdld->_szSaveToFile);
                    
                    // Since EndDialogDLD will probably release our structure...
                    HWND hwndToolTips = pdld->_hwndToolTips;
                    pdld->_hwndToolTips = NULL;
                    pdld->EndDialogDLD(IDOK);

                    if (IsWindow(hwndToolTips))
                        DestroyWindow(hwndToolTips);
                        
                    fInBrowseDir = FALSE;
                }
#if DEBUG
                else
                {
                    TraceMsg(DM_DOWNLOAD, "DownloadDlgProc rcvd IDD_BROWSEDIR msg while already processing IDD_BROWSEDIR");
                }
#endif
                break;

        case IDD_OPENFILE:
            StrCpyN(pdld->_szPath, pdld->_szSaveToFile, ARRAYSIZE(pdld->_szPath));
        case IDOK:
            ShowWindow(GetDlgItem(hDlg, IDD_DISMISS), SW_HIDE);
            
            if (pdld)
            {
                pdld->AddRefDLD();
                
                if (pdld->_fGotFile) 
                {
                    // If zone check fails or if we found virus, bail out and remove file from cache.
                    if ( pdld->PerformVirusScan(pdld->_szPath) != S_OK ) 
                    {
                        pdld->_fDeleteFromCache = TRUE;
                    }
                    else
                    {
                        TCHAR  szQuotedPath[MAX_PATH];
                        StrCpyN(szQuotedPath, pdld->_szPath, MAX_PATH);

                        if (PLATFORM_INTEGRATED == WhichPlatform())
                        {
                            PathQuoteSpaces(szQuotedPath);
                        }

                        SHELLEXECUTEINFO sei = { sizeof(SHELLEXECUTEINFO),
                                                 SEE_MASK_NOZONECHECKS, hDlg, NULL, szQuotedPath, NULL, NULL, SW_SHOWNORMAL, NULL};
                        if (!ShellExecuteEx(&sei))
                        {
                            DWNLDMSG2("ShellExecute failed", GetLastError());
                        }
                    }
                }

                if (!pdld->_fDeleteFromCache)
                    AddUrlToUrlHistoryStg(pdld->_pwszDisplayName, NULL, NULL, pdld->_fWriteHistory, NULL, NULL, NULL);

                // Since EndDialogDLD will probably release our structure...
                HWND hwndToolTips = pdld->_hwndToolTips;
                pdld->_hwndToolTips = NULL;
                StrCpyN(szURL, pdld->_szURL, ARRAYSIZE(szURL));
                
                pdld->EndDialogDLD(!pdld->_fDeleteFromCache ?IDOK :IDCANCEL);

                if (IsWindow(hwndToolTips))
                    DestroyWindow(hwndToolTips);
                SetExemptDelta(szURL, 0);
            }
            break;
        }
        break;


    case WM_ACTIVATE:
        if (pdld && pdld->_IsModal())
            return FALSE;
        else 
        {
            // There can be race conditions here. If the WA_ACTIVATE messages came in reverse
            // order, we might end up setting up the wrong hDlg as the active window. As of right now,
            // the only thing g_hDlgActive is being used for is for the IsDialogMessage in
            // CDownload_MayProcessMessage. And since there is only one tab-able control in this
            // dialog, a wrong hDlg in the g_hDlgActive should not hurt.
            ENTERCRITICAL;
            if (LOWORD(wParam) == WA_INACTIVE) 
            {
                if (g_hDlgActive == hDlg)
                {
                    MDLGMSG(TEXT("being inactivated"), hDlg);
                    g_hDlgActive = NULL;
                }
            } 
            else 
            {
                MDLGMSG(TEXT("being activated"), hDlg);
                g_hDlgActive = hDlg;
            }
            LEAVECRITICAL;
        }
        break;

    case WM_NCDESTROY:
        MDLGMSG(TEXT("being destroyed"), hDlg);
        ASSERT((pdld && pdld->_IsModal()) || (g_hDlgActive != hDlg));
        SetWindowLongPtr(hDlg, DWLP_USER, NULL);
        return FALSE;

    case WM_DESTROY:
        SHRemoveDefaultDialogFont(hDlg);
        return FALSE;

    default:
        return FALSE;
    }

    return TRUE;
}

void CDownload::ShowStats(void)
{
    TCHAR szStr[MAX_PATH];
    TCHAR szBytes[MAX_BYTES_STRLEN];
    TCHAR szTime[MAX_BYTES_STRLEN];
    TCHAR *pszTime = szTime;
    DWORD dwSpent = (GetTickCount() - _dwFirstTick);

    SetDlgItemText(_hDlg, IDD_NAME, _szDisplay);
    
    MLLoadString(IDS_BYTESTIME, _szBytesCopied, ARRAYSIZE(_szBytesCopied));
    StrFromTimeInterval(szTime, ARRAYSIZE(szTime), (dwSpent < 1000)  ?1000 :dwSpent, 3);
    while(pszTime && *pszTime && *pszTime == TEXT(' '))
        pszTime++;
    _FormatMessage(_szBytesCopied, szStr, ARRAYSIZE(szStr),
                StrFormatByteSize(_dwTotalSize, szBytes, MAX_BYTES_STRLEN), pszTime);
    SetDlgItemText(_hDlg, IDD_TIMEEST, szStr);

    // division below requires at least 1/2 second to have elapsed.
    if (dwSpent < 500)
        dwSpent = 500;
    _FormatMessage(_szTransferRate, szStr, ARRAYSIZE(szStr), 
                StrFormatByteSize(_dwTotalSize / ((dwSpent+500)/1000), szBytes, MAX_BYTES_STRLEN));
    SetDlgItemText(_hDlg, IDD_TRANSFERRATE, szStr);

    SetForegroundWindow(_hDlg);
}

void CDownload::EndDialogDLD(UINT id)
{
    if (ReleaseDLD() != 0)
        return;
        
    ASSERT(!_fEndDialogCalled);
    _fEndDialogCalled = TRUE;

    DWNLDMSG2("EndDialogDLD cRef ==", _cRef);
    TraceMsg(TF_SHDREF, "CDownload::EndDialogDLD called when _cRef=%d", _cRef);

    _fDismissDialog = (IsDlgButtonChecked(_hDlg, IDD_DISMISS) == BST_CHECKED);
    if (SHRegSetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), 
                    TEXT("NotifyDownloadComplete"), 
                    REG_SZ, _fDismissDialog ?TEXT("no") :TEXT("yes"), _fDismissDialog ?sizeof(TEXT("no")-sizeof(TCHAR)) :sizeof(TEXT("yes")-sizeof(TCHAR)), SHREGSET_FORCE_HKCU) != ERROR_SUCCESS)
    {
        DWNLDMSG2("SHRegSetUSValue NotifyDownloadComplete failed", GetLastError());
    }

    // HACK: USER does not send us WM_ACTIVATE when this dialog is
    //  being destroyed when it was activated. We need to work around
    //  this bug(?) by cleaning up g_hDlgActive.
    if (g_hDlgActive == _hDlg) 
    {
        MDLGMSG(TEXT("EndDialogDLD putting NULL in g_hDlgActive"), _hDlg);
        g_hDlgActive = NULL;
    }

    DestroyWindow(_hDlg);
    Release();
}

#define SZEXPLORERKEY  TEXT("Software\\Microsoft\\Internet Explorer")
#define SZDOWNLOADDIRVAL  TEXT("Download Directory")
// _GetSaveLocation
//      -   Tries to get the current download directory from the registry
//          default is the Desktop
//      -   Shows the FileSave Dialog
//      -   If the user changed the download location, save that off into
//          the registry for future downloads
//      -   _szSaveToFile is updated (this will be used by _SaveFile()
//
// Returns TRUE, if successfully done.
//
BOOL _GetSaveLocation(HWND hDlg, LPTSTR pszPath, LPTSTR pszExt, LPTSTR pszSaveToFile, UINT cchSaveToFile, BOOL fUTF8Enabled, UINT uiCP)
{
    BOOL fRet = FALSE;
    TCHAR * pszSaveTo =  NULL;
    HKEY hKey;
    BOOL fRegFileType = FALSE;
    TCHAR szDownloadDir[MAX_PATH];
    TCHAR szBuffer[MAX_PATH];
    TCHAR szTemp[40];
    LPTSTR pszWalk = szBuffer;
    int    cchWalk = ARRAYSIZE(szBuffer);
    int    cch;

    szDownloadDir[0] = 0;

    // If we don't have a download directory in the registry, download to the desktop
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, SZEXPLORERKEY, 0, KEY_READ, &hKey))
    {
        DWORD dwType, cbData = sizeof(szDownloadDir);
        RegQueryValueEx(hKey, SZDOWNLOADDIRVAL, NULL, &dwType, (LPBYTE)szDownloadDir, &cbData);
        RegCloseKey(hKey);
    }

    if (szDownloadDir[0] == 0)
        SHGetSpecialFolderPath(NULL, szDownloadDir, CSIDL_DESKTOPDIRECTORY, FALSE);

    // Get the file name. If there is no filename. create one called using the string resource in IDS_DOCUMENT

    pszSaveTo = PathFindFileName(pszPath);
    if (pszSaveTo)
    {
        DWORD cchData = cchSaveToFile;

        // Unescape the filename suggested by wininet.
        if (_PrepareURLForDisplayUTF8W(pszSaveTo, pszSaveToFile, &cchData, fUTF8Enabled, uiCP) != S_OK)
            StrCpyN(pszSaveToFile, pszSaveTo, cchSaveToFile);
            
        // Strip out any path that may have been encoded
        TCHAR * pszSaveToDst = pszSaveToFile;
        pszSaveTo = PathFindFileName(pszSaveToFile);
        if (pszSaveTo != pszSaveToFile)
        {
            while(*pszSaveTo)
                *pszSaveToDst++ = *pszSaveTo++;
            *pszSaveToDst = *pszSaveTo;
        }

        // Strip out the the cache's typical decoration of "(nn)"
        PathUndecorate (pszSaveToFile);
    }
    else
        MLLoadString(IDS_DOCUMENT, pszSaveToFile, cchSaveToFile);

    if (!g_fRunningOnNT) // Win9x isn't able to deal with DBCS chars in edit controls when UI lang is non-native OS lang
    {
        CHAR szBufA[MAX_PATH*2];
        int iRC = WideCharToMultiByte(CP_ACP, 0, pszSaveToFile, -1, szBufA, ARRAYSIZE(szBufA), NULL, NULL);
        if (iRC == 0)    // If we are unable to convert using system code page
            *pszSaveToFile = TEXT('\0');    // make suggested file name blank
    }
    
    OPENFILENAME OFN = {0};
    OFN.lStructSize        = sizeof(OFN);
    OFN.hwndOwner          = hDlg;
    OFN.nMaxFile           = cchSaveToFile;
    OFN.lpstrInitialDir    = szDownloadDir;

    OFN.lpstrFile = pszSaveToFile;
    OFN.Flags = OFN_HIDEREADONLY  | OFN_OVERWRITEPROMPT | OFN_EXPLORER |
                OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST | OFN_NOCHANGEDIR;

    if (!pszExt || !*pszExt)
        pszExt = PathFindExtension(pszPath);

    if (pszExt && *pszExt)
        OFN.lpstrDefExt = pszExt;

    // Try to get the file type name from the registry. To add to the filter pair strings
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, pszExt, 0, KEY_READ, &hKey))
    {
        DWORD dwType, cbData = sizeof(szBuffer);
        fRegFileType = (ERROR_SUCCESS == RegQueryValueEx(hKey, NULL, NULL, &dwType, (LPBYTE)szBuffer, &cbData));
        RegCloseKey(hKey);
    }

    if (fRegFileType)
    {
        fRegFileType = FALSE;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szBuffer, 0, KEY_READ, &hKey))
        {
            DWORD dwType, cbData = sizeof(szBuffer);
            szBuffer[0] = 0;

            fRegFileType = ERROR_SUCCESS == RegQueryValueEx(hKey, NULL, NULL, &dwType, (LPBYTE)szBuffer, &cbData);
            if (fRegFileType)
            {
                // Now tack on the second part of the filter pair
                int cchBuffer = lstrlen(szBuffer) + 1;
                pszWalk = szBuffer + cchBuffer;
                cchWalk = ARRAYSIZE(szBuffer) - cchBuffer;
                StrCpyN(pszWalk, TEXT("*"), cchWalk);
                StrCatBuff(pszWalk, pszExt, --cchWalk); // sub 1 for * above
            }
            RegCloseKey(hKey);
        }
        cch = lstrlen(pszWalk);
    }

    // There was no registry entry for the file type or the entry did not have a default value
    // So create the file name type - "<file extension> DOCUMENT"
    if (!fRegFileType || !(*szBuffer))
    {
        szBuffer[0] = 0;
        pszWalk = szBuffer;
        cchWalk = ARRAYSIZE(szBuffer);
        MLLoadString(IDS_EXTDOCUMENT, szTemp, ARRAYSIZE(szTemp));
        cch = wnsprintf(pszWalk, cchWalk, szTemp, pszExt, TEXT('\0'), pszExt);
    }

    // Add in the pair for "*.* All files"
    pszWalk += (cch + 1);
    cchWalk -= (cch + 1);

    MLLoadString(IDS_ALLFILES, szTemp, ARRAYSIZE(szTemp));
    StrCpyN(pszWalk, szTemp, cchWalk);

    cch = lstrlen(pszWalk) + 1;
    pszWalk += cch;
    cchWalk -= cch;

    StrCpyN(pszWalk, ALLFILE_WILDCARD, cchWalk);

    cch = (lstrlen( ALLFILE_WILDCARD )+1); //Add the second NULL to the end of the string
    pszWalk += cch;
    cchWalk -= cch;

    if (cchWalk > 0)
        *pszWalk = 0; //because we had some garbage put after memset.

    OFN.lpstrFilter = szBuffer;

    if ((fRet = (!SHIsRestricted2W(hDlg, REST_NoSelectDownloadDir, NULL, 0))) 
        && (fRet = GetSaveFileName(&OFN)))
    {
        // If the download location was changed, save that off to the registry
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, SZEXPLORERKEY, 0, KEY_WRITE, &hKey))
        {
            StrCpyN(szBuffer, pszSaveToFile, ARRAYSIZE(szBuffer));
            PathRemoveFileSpec(szBuffer);

            if (szBuffer[0])
                RegSetValueEx(hKey, SZDOWNLOADDIRVAL, 0, REG_SZ, (LPBYTE)szBuffer, CbFromCch(lstrlen(szBuffer) + 1));

            RegCloseKey(hKey);
        }
    }

    return fRet;
}


BOOL CDownload::_GetSaveLocation()
{
    return ::_GetSaveLocation(_hDlg, _szPath, _szExt, _szSaveToFile, ARRAYSIZE(_szSaveToFile), _fUTF8Enabled, _uiCP);
}

BOOL CDownload::_SaveFile()
{
    SHFILEOPSTRUCT fo = { _hDlg, FO_COPY, _szPath, _szSaveToFile, FOF_NOCONFIRMATION | FOF_NOCOPYSECURITYATTRIBS};

    // Be sure the strings are double terminated
    DWORD dwLen = (DWORD)min(ARRAYSIZE(_szPath), lstrlen(_szPath) + 1);
    if (dwLen == 0)  // Not likely, but better to fail than trash someone else's data
        return FALSE;
    _szPath[dwLen] = TEXT('\0');
    _szPath[dwLen-1] = TEXT('\0');
    
    dwLen = (DWORD)min(ARRAYSIZE(_szSaveToFile), lstrlen(_szSaveToFile) + 1);
    if (dwLen == 0)
        return FALSE;
    _szSaveToFile[dwLen] = TEXT('\0');
    _szSaveToFile[dwLen-1] = TEXT('\0');

    // If the file is in the cache, we probably want to delete it from the
    // cache to free up some disk space rather than wait for it to be scavenged.
    // This is best done after _pib->Release called from ~CDownload.
    _fDeleteFromCache = TRUE;

    // Copy the file (which is locked, so can't move it) to its target destination.
    return !SHFileOperation(&fo);
}

void CDownload::_DeleteFromCache()
{
    INTERNET_CACHE_CONFIG_INFO CCInfo;
    DWORD dwCCIBufSize = sizeof(CCInfo);

    // Obtain the cache directory path.

    if (!GetUrlCacheConfigInfo (&CCInfo, &dwCCIBufSize, CACHE_CONFIG_CONTENT_PATHS_FC))
    {
        ASSERT(FALSE);
    }
    else if (0 == StrCmpNI (_szPath,
        CCInfo.CachePaths[0].CachePath,
        lstrlen(CCInfo.CachePaths[0].CachePath)))
    {
        // Attempt to delete the file from the cache only if resides under
        // the cache directory, otherwise we could in theory nuke a preinstalled
        // or edited cache entry.  Here a prefix match is also a string prefix
        // match since .CachePath will have a trailing slash ('/')

        DeleteUrlCacheEntry(_szURL);
    }
}


void CDownload::OpenUI(IMoniker* pmk, IBindCtx *pbc, BOOL fSaveAs, BOOL fSafe, LPWSTR pwzHeaders, DWORD dwVerb, DWORD grfBINDF, BINDINFO* pbinfo, LPCTSTR pszRedir, UINT uiCP, BOOL fConfirmed)
{
    TraceMsg(DM_DOWNLOAD, "CDownLoad::OpenUI called with fSaveAs=%d, verb=%d", fSaveAs, dwVerb);

    // CDownload will take ownership pbinfo.
    CDownload* pdld = new CDownload(fSaveAs, pwzHeaders, grfBINDF, pbinfo, fSafe, dwVerb, pszRedir, uiCP, fConfirmed);
    if (pdld) 
    {
        HWND hwnd = CreateDialogParam(MLGetHinst(), 
            MAKEINTRESOURCE(DLG_DOWNLOADPROGRESS), NULL, DownloadDlgProc, (LPARAM)pdld);
        pwzHeaders = NULL;   // Owner is now CDownload
        DWNLDMSG2("CDownLoad_OpenUI dialog created", hwnd);
        if (hwnd)
        {
            HRESULT hres = pdld->StartBinding(pmk, pbc);
            if (FAILED(hres))
            {
                TraceMsg(DM_DOWNLOAD, "CDownLoad::OpenUI() - StartBinding() Failed with hres=0x%x!", hres );

                ProcessStartbindingError(hwnd, MAKEINTRESOURCE(IDS_DOWNLOADFAILED),
                                         pdld->_szDisplay, MB_ICONWARNING, hres, pdld->_szURL);
            }
            else
            {
                ShowWindow(hwnd, SW_SHOWNORMAL);
            }
        }
        else
        {
            delete pdld;
            pdld = NULL;
        }
    }

    if (pwzHeaders)
    {
        CoTaskMemFree(pwzHeaders);
        pwzHeaders = NULL;
    }
}

BOOL CDownload_MayProcessMessage(MSG* pmsg)
{
    if (g_hDlgActive)
        return IsDialogMessage(g_hDlgActive, pmsg);

    return FALSE;       // not processed
}

class CDownloadThreadParam {
#ifdef DEBUG
    const DWORD* _pdwSigniture;
    static const DWORD s_dummy;
#endif
public:
    DWORD   _dwVerb;
    DWORD   _grfBINDF;
    BINDINFO *_pbinfo;
    LPWSTR  _pszDisplayName;
    LPWSTR  _pwzHeaders;
    BOOL    _fSaveAs;
    BOOL    _fSafe;
    BOOL    _fConfirmed;
    IStream *_pStream;
    TCHAR   _szRedirURL[MAX_URL_STRING];
    UINT    _uiCP;

    ~CDownloadThreadParam() 
    {
        OleFree(_pszDisplayName);
        if (_pwzHeaders) 
            CoTaskMemFree(_pwzHeaders);
        if (_pStream)
            _pStream->Release();
        // CDownload releases our _pbinfo.
    }

    CDownloadThreadParam(LPWSTR pszDisplayName, LPWSTR pwzHeaders, BOOL fSaveAs, BOOL fSafe=FALSE, DWORD dwVerb=BINDVERB_GET, DWORD grfBINDF = 0, BINDINFO* pbinfo = NULL, LPCTSTR pszRedir=NULL, UINT uiCP=CP_ACP, BOOL fConfirmed=FALSE )
        : _pszDisplayName(pszDisplayName), _fSaveAs(fSaveAs), _fSafe(fSafe), _pwzHeaders(pwzHeaders), _pStream(NULL), _dwVerb(dwVerb), _grfBINDF(grfBINDF), _pbinfo(pbinfo), _uiCP(uiCP), _fConfirmed(fConfirmed)
    {
#ifdef DEBUG
        _pdwSigniture = &s_dummy;
#endif
        if (pszRedir && lstrlen(pszRedir))
            StrCpyN(_szRedirURL, pszRedir, MAX_URL_STRING - 1);
        // CDownload releases our _pbinfo.
    }

    void SetStream(IStream *pStm)
    {
        if (_pStream)
        {
            _pStream->Release();
        }
        _pStream = pStm;

        if (_pStream)
        {
            _pStream->AddRef();
        }
    }
};

DWORD CALLBACK IEDownload_ThreadProc(void *pv)
{
    CDownloadThreadParam* pdtp = (CDownloadThreadParam*)pv;

    HRESULT hr;

    IBindCtx *pbc = NULL;
    if (pdtp->_pStream)
    {
        pdtp->_pStream->AddRef();
        hr = pdtp->_pStream->Seek(c_li0,STREAM_SEEK_SET,0);
        hr = CoGetInterfaceAndReleaseStream(pdtp->_pStream, IID_PPV_ARG(IBindCtx, &pbc));
        pdtp->SetStream(NULL);
    }

    if (pbc == NULL)
        CreateBindCtx(0, &pbc);

    //winse#12726:Give other thread a chance to finish its work.
    Sleep(100);

    hr = CDownLoad_OpenUIURL(pdtp->_pszDisplayName, pbc, pdtp->_pwzHeaders, TRUE, pdtp->_fSaveAs, pdtp->_fSafe,
                             pdtp->_dwVerb, pdtp->_grfBINDF, pdtp->_pbinfo, pdtp->_szRedirURL, pdtp->_uiCP, NULL, pdtp->_fConfirmed);

    if (SUCCEEDED(hr)) 
    {
        pdtp->_pwzHeaders = NULL;   // CDownload owns freeing headers now
        pdtp->_pbinfo = NULL;       // CDownload owns freeing pbinfo now.
    }

    delete pdtp;
    pdtp = NULL;

    if (pbc)
    {
        pbc->Release();
        pbc = NULL;
    }

    while (1)
    {
        MSG msg;

        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
                break;

            // Note that for IE 3.0, the parking thread is also
            //  the owner of all modeless download dialog.
            if (CDownload_MayProcessMessage(&msg)) 
                continue;

            TranslateMessage(&msg);
            DispatchMessage(&msg);
            continue;
        }
        WaitMessage();
    }

    return 0;
}

void CDownLoad_OpenUI(IMoniker *pmk, IBindCtx *pbc, BOOL fSync, BOOL fSaveAs, BOOL fSafe, LPWSTR pwzHeaders, DWORD dwVerb, DWORD grfBINDF, BINDINFO* pbinfo, LPCTSTR pszRedir, UINT uiCP, IUnknown *punk, BOOL fConfirmed)
{
    TraceMsg(DM_DOWNLOAD, "CDownLoad_OpenUI called with fSync=%d fSaveAs=%d", fSync, fSaveAs);
    ASSERT(dwVerb == BINDVERB_GET || dwVerb == BINDVERB_POST);

    if (fSync) 
    {
        CDownload::OpenUI(pmk, pbc, fSaveAs, fSafe, pwzHeaders, dwVerb, grfBINDF, pbinfo, pszRedir, uiCP, fConfirmed);
        pwzHeaders = NULL;  // CDownload now owns headers
        return;
    }

    IDownloadManager *pdlm;
    HRESULT hr = IUnknown_QueryService(punk, SID_SDownloadManager, IID_PPV_ARG(IDownloadManager, &pdlm));
    if (FAILED(hr))
    {
        hr = CreateFromRegKey(TSZIEPATH, TEXT("DownloadUI"), IID_PPV_ARG(IDownloadManager, &pdlm));
    }

    if (SUCCEEDED(hr))
    {
        hr = pdlm->Download(pmk, pbc, dwVerb, grfBINDF, pbinfo, pwzHeaders, pszRedir, uiCP);
        pdlm->Release();
    }

    if (FAILED(hr))
    {
        if (pbc == NULL)
        {
            hr = CreateBindCtx(0, &pbc);
        }
        else
        {
            hr = S_OK;
            pbc->AddRef();
        }

        if (SUCCEEDED(hr))
        {
            LPWSTR pszDisplayName = NULL;
            hr = pmk->GetDisplayName(pbc, NULL, &pszDisplayName);
            if (SUCCEEDED(hr)) 
            {
                CDownloadThreadParam* pdtp = new CDownloadThreadParam(pszDisplayName, pwzHeaders, fSaveAs, fSafe, dwVerb, grfBINDF, pbinfo, pszRedir, uiCP, fConfirmed);
                if (pdtp) 
                {
                    pwzHeaders = NULL;  // ownership is to CDTP

                    // Note: IAsyncBindCtx has identicial interface as IBindCtx
                    IBindCtx *pbcAsync;
                    hr = pbc->QueryInterface(IID_IAsyncBindCtx, (void **)&pbcAsync);
                    if (SUCCEEDED(hr))
                    {
                        // This introduces a double bind, but only for the mk: protocol and
                        // the fix is needed for displaying pdfs and other special mime types.
                        if (_tcsnicmp(pszDisplayName, _T("mk:"), 3) == 0)
                        {
                            pbcAsync->Release();
                            pbcAsync = NULL;
                            hr = CreateBindCtx(0, &pbcAsync);
                        }

                        if (SUCCEEDED(hr))
                        {
                            IStream *pStm;
                            hr = CoMarshalInterThreadInterfaceInStream(IID_IBindCtx, pbcAsync, &pStm);
                            if (hr == S_OK)
                            {
                                pdtp->SetStream(pStm);
                                pStm->Release();
                            }
                            pbcAsync->Release();
                        }
                    }

                    if (!SHCreateThread(IEDownload_ThreadProc, pdtp, CTF_PROCESS_REF | CTF_REF_COUNTED | CTF_COINIT, NULL))
                    {
                        delete pdtp;
                        pdtp = NULL;
                    }
                } 
                else 
                {
                    OleFree(pszDisplayName);
                }
            }
            pbc->Release();
        }
    }

    CoTaskMemFree(pwzHeaders);  // may be NULL, we consume this in all cases
}

HRESULT CDownLoad_OpenUIURL(LPCWSTR pwszURL, IBindCtx *pbc, LPWSTR pwzHeaders, BOOL fSync,BOOL fSaveAs, BOOL fSafe, DWORD dwVerb, DWORD grfBINDF, BINDINFO* pbinfo, LPCTSTR pszRedir, UINT uiCP, IUnknown *punk, BOOL fConfirmed)
{
    HRESULT hr;
    ASSERT(pwszURL);
    if (pwszURL) 
    {
        IMoniker* pmk = NULL;
        hr = CreateURLMoniker(NULL, pwszURL, &pmk);
        if (SUCCEEDED(hr)) 
        {
            CDownLoad_OpenUI(pmk, pbc, fSync, fSaveAs, fSafe, pwzHeaders, dwVerb, grfBINDF, pbinfo, pszRedir, uiCP, punk, fConfirmed);
            pwzHeaders = NULL;  // CDownload now owns headers
            pmk->Release();
            hr = S_OK;
        }
        if (pwzHeaders)
            CoTaskMemFree(pwzHeaders);
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

HRESULT CDownload::StartBinding(IMoniker* pmk, IBindCtx *pbc)
{
    ASSERT(_pbc==NULL);
    HRESULT hr = S_OK;

    if (pbc == NULL)
    {
        hr = CreateBindCtx(0, &_pbc);
    }
    else
    {
        _pbc = pbc;
        _pbc->AddRef();
    }

    if (SUCCEEDED(hr))
    {
        hr = RegisterBindStatusCallback(_pbc, this, 0, 0);
        if (SUCCEEDED(hr)) 
        {
            hr = pmk->GetDisplayName(_pbc, NULL, &_pwszDisplayName);
            if (SUCCEEDED(hr))
            {
                TCHAR szBuf[MAX_PATH];
                DWORD dwSize = ARRAYSIZE(szBuf);
                DWORD dwPUAF = PUAF_NOUI;

                DWORD dwPolicy = 0, dwContext = 0;
                int cch = lstrlen(_szURL);

                if (!cch)
                {
                    SHUnicodeToTChar(_pwszDisplayName, _szURL, ARRAYSIZE(_szURL));
                }

                TraceMsg(TF_SHDNAVIGATE, "CDld::StartBinding SHUnicodeToTChar returns %d (%s)", cch, _szURL);

                // The URL from GetDisplayName() is always fully
                // canonicalized and escaped.  Prepare it for display.
                if (PrepareURLForDisplay(_szURL, szBuf, &dwSize))
                    FormatUrlForDisplay(szBuf, _szDisplay, ARRAYSIZE(_szDisplay), NULL, 0, TRUE, _uiCP, NULL);
                else
                    FormatUrlForDisplay(_szURL, _szDisplay, ARRAYSIZE(_szDisplay), NULL, 0, TRUE, _uiCP, NULL);

                SetWindowText(GetDlgItem(_hDlg, IDD_NAME), _szDisplay);

                if (_grfBINDF & BINDF_ENFORCERESTRICTED)
                {
                    dwPUAF |= PUAF_ENFORCERESTRICTED;
                }

                ZoneCheckUrlEx(_szURL, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                               URLACTION_SHELL_FILE_DOWNLOAD, dwPUAF, NULL);
                dwPolicy = GetUrlPolicyPermissions(dwPolicy);
                if ((dwPolicy == URLPOLICY_ALLOW) || (dwPolicy == URLPOLICY_QUERY)) 
                {
                    IUnknown* punk = NULL;
                    hr = pmk->BindToStorage(_pbc, NULL, IID_PPV_ARG(IUnknown, &punk));
                    DWNLDMSG3("StartBinding pmk->BindToStorage returned", hr, punk);
                    if (SUCCEEDED(hr) || hr == E_PENDING)
                    {
                        hr = S_OK;
                        if (punk)
                        {
                            ASSERT(0);
                            punk->Release();
                        }

                    }
                    else 
                    {
                        TraceMsg(DM_ERROR, "CDld::StartBinding pmk->BindToStorage failed %x", hr);

                        HRESULT hrRevoke = RevokeBindStatusCallback( _pbc, this );

                        ASSERT( SUCCEEDED( hrRevoke ) );
                    }
                } 
                else
                {
                    TraceMsg(DM_ERROR, "CDld::StartBinding: Zone does not allow file download");

                    HRESULT hrRevoke = RevokeBindStatusCallback( _pbc, this );

                    ASSERT( SUCCEEDED( hrRevoke ) );

                    hr = E_ACCESSDENIED;
                }
            }
            else
            {
                TraceMsg(DM_ERROR, "CDld::StartBinding pmk->GetDisplayName failed %x", hr);

                HRESULT hrRevoke = RevokeBindStatusCallback( _pbc, this );

                ASSERT( SUCCEEDED( hrRevoke ) );
            }
        }
        else 
        {
            TraceMsg(DM_ERROR, "CDld::StartBinding RegisterBSC failed %x", hr);
        }
    }
    else
    {
        TraceMsg(DM_ERROR, "CDld::StartBinding CreateBindCtx failed %x", hr);
    }
    return hr;
}

HRESULT CDownload::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CDownload, IBindStatusCallback),   // IID_IBindStatusCallback
        QITABENT(CDownload, IAuthenticate),         // IID_IAuthenticate
        QITABENT(CDownload, IServiceProvider),      // IID_IServiceProvider
        QITABENT(CDownload, IHttpNegotiate),        // IID_IHttpNegotiate
        QITABENT(CDownload, IWindowForBindingUI),
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDownload::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDownload::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);

    DWNLDMSG2("CDownload::Release cRef=", cRef);

    if ( 0 == cRef )
    {
        CDownload* pdld = (CDownload*) GetWindowLongPtr(_hDlg, DWLP_USER);
        if (pdld == this)
        {
            SetWindowLongPtr(_hDlg, DWLP_USER, NULL);
        }

        DWNLDMSG3("CDownload::Release delete this", pdld, this);

        delete this;
    }

    return cRef;
}

ULONG CDownload::AddRefDLD()
{
    return InterlockedIncrement(&_cRefDLD);
}

ULONG CDownload::ReleaseDLD()
{
    ASSERT( 0 != _cRefDLD );
    return InterlockedDecrement(&_cRefDLD);
}

CDownload::~CDownload()
{
    if (_pbinfo) {
        ReleaseBindInfo(_pbinfo);
        LocalFree(_pbinfo);
        _pbinfo = NULL;
    }

    if (_pib) {
        _pib->Release();
    }

    if (_pbc) {
        _pbc->Release();
    }

    if (_hicon) {
        DestroyIcon(_hicon);
    }

    if (_pwszDisplayName)
        OleFree(_pwszDisplayName);

    if (_fDeleteFromCache)
        _DeleteFromCache();

    if ( _pwzHeaders )
        CoTaskMemFree( _pwzHeaders );

    TraceMsg(TF_SHDLIFE, "CDownload::~CDownload being destructed");

    TraceMsg(TF_SHDTHREAD, "CDownload::EndDialogDLD calling PostQuitMessage");
    // Post the quit message ONLY if this flag is set. The constructor for the
    // derived class CDownloadURL resets the flag to FALSE because it doesn't
    // need any quit messages.
    if (!_fDontPostQuitMsg)
        PostQuitMessage(0);
}

#ifdef USE_LOCKREQUEST
HRESULT CDownload::LockRequestHandle(void)
{
    HRESULT hres = E_FAIL;
    HANDLE hLock;
    
    if (_pib)
    {
        IWinInetInfo* pwinet;
        hres = _pib->QueryInterface(IID_PPV_ARG(IWinInetInfo, &pwinet));
        if (SUCCEEDED(hres)) 
        {
            DWORD cbSize = sizeof(HANDLE);
            hres = pwinet->QueryOption(WININETINFO_OPTION_LOCK_HANDLE, &hLock, &cbSize);

            pwinet->Release();
        }
    }
    return hres;
}
#endif

HRESULT CDownload::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
    DWNLDMSG3("OnStartBinding", _pib, pib);
    if (_pib) 
    {
        _pib->Release();
    }

    _pib = pib;
    if (_pib) 
    {
        _pib->AddRef();
    }

    SetQueryNetSessionCount(SESSION_INCREMENT);

    _fUTF8Enabled = UTF8Enabled();

    return S_OK;
}

HRESULT CDownload::GetPriority(LONG *pnPriority)
{
    DWNLDMSG("GetPriority", "called");
    *pnPriority = NORMAL_PRIORITY_CLASS;
    return S_OK;
}

HRESULT CDownload::OnLowResource(DWORD reserved)
{
    DWNLDMSG("OnLowResource", "called");
    return S_OK;
}


#define WM_DIALMON_FIRST        WM_USER+100

// message sent to dial monitor app window indicating that there has been
// winsock activity and dial monitor should reset its idle timer
#define WM_WINSOCK_ACTIVITY             WM_DIALMON_FIRST + 0

#define MIN_ACTIVITY_MSG_INTERVAL       15000

void IndicateWinsockActivity(void)
{
    // if there is an autodisconnect monitor, send it an activity message
    // so that we don't get disconnected during long downloads.  For perf's sake,
    // don't send a message any more often than once every MIN_ACTIVITY_MSG_INTERVAL
    // milliseconds (15 seconds).  Use GetTickCount to determine interval;
    // GetTickCount is very cheap.
    DWORD dwTickCount = GetTickCount();
    // Sharing this among multiple threads is OK
    static DWORD dwLastActivityMsgTickCount = 0;
    DWORD dwElapsed = dwTickCount - dwLastActivityMsgTickCount;
    
    // have we sent an activity message recently?
    if (dwElapsed > MIN_ACTIVITY_MSG_INTERVAL) 
    {
        HWND hwndMonitorApp = FindWindow(TEXT("MS_AutodialMonitor"), NULL);
        if (hwndMonitorApp) 
        {
            PostMessage(hwndMonitorApp, WM_WINSOCK_ACTIVITY, 0, 0);
        }
        hwndMonitorApp = FindWindow(TEXT("MS_WebcheckMonitor"), NULL);
        if (hwndMonitorApp) 
        {
            PostMessage(hwndMonitorApp, WM_WINSOCK_ACTIVITY, 0, 0);
        }
        
        // record the tick count of the last time we sent an
        // activity message
        dwLastActivityMsgTickCount = dwTickCount;
    }
}

#define MAXCALCCNT 5

HRESULT CDownload::OnProgress(
     ULONG ulProgress,
     ULONG ulProgressMax,
     ULONG ulStatusCode,
     LPCWSTR pwzStatusText)
{
    DWNLDMSG4("OnProgress", ulProgress, ulProgressMax, ulStatusCode);
    TCHAR szBytes[MAX_BYTES_STRLEN];
    TCHAR szBytesMax[MAX_BYTES_STRLEN];
    TCHAR szBuf[MAX_PATH];      // OK with MAX_PATH
    LPTSTR pszFileName = NULL;
    HWND hwndShow;
    DWORD dwCur;

    switch (ulStatusCode)
    {
        case BINDSTATUS_BEGINDOWNLOADDATA:
            hwndShow = GetDlgItem(_hDlg, ulProgressMax ? IDD_PROBAR : IDD_NOFILESIZE);
            if (!IsWindowVisible(hwndShow))
            {
                ShowWindow(GetDlgItem(_hDlg, ulProgressMax ? IDD_NOFILESIZE : IDD_PROBAR), SW_HIDE);
                ShowWindow(hwndShow, SW_SHOW);
            }

            _ulOldProgress = ulProgress;
            // fall thru
        case BINDSTATUS_DOWNLOADINGDATA:
        case BINDSTATUS_ENDDOWNLOADDATA:
            // Prevent machines with APM enabled from suspending during download
            _SetThreadExecutionState(ES_CONTINUOUS | ES_SYSTEM_REQUIRED);
                
            _dwFileSize = max(ulProgressMax, ulProgress);
            
            // every once in a while, send message
            // to the hidden window that detects inactivity so that it doesn't
            // think we are inactive during a long download
            IndicateWinsockActivity();
            // Sometimes OnProgress is called by folks who do not create a dialog
            if (_hDlg )
            {
                if (!_fStrsLoaded)
                {
                     MLLoadString(IDS_TITLEPERCENT, _szTitlePercent, ARRAYSIZE(_szTitlePercent));
                     MLLoadString(IDS_ESTIMATE, _szEstimateTime, ARRAYSIZE(_szEstimateTime));
                     MLLoadString(IDS_TITLEBYTES, _szTitleBytes, ARRAYSIZE(_szTitleBytes));
                     MLLoadString(IDS_BYTESCOPIED, _szBytesCopied, ARRAYSIZE(_szBytesCopied));
                     MLLoadString(IDS_TRANSFERRATE, _szTransferRate, ARRAYSIZE(_szTransferRate));
                    _fStrsLoaded = TRUE;
                }

                // Get the file name of the file being downloaded
                pszFileName = PathFindFileName(_szURL);

                dwCur = GetTickCount();
                if (_dwOldCur == 0)   // Allow the download to get started before displaying stats
                    _dwOldCur = dwCur;

                if ((ulProgressMax > 0) && _fDownloadStarted)
                {
                    if (_hDlg) 
                    {
                        SendMessage(GetDlgItem(_hDlg, IDD_PROBAR), PBM_SETRANGE32, 0, _dwFileSize);
                        SendMessage(GetDlgItem(_hDlg, IDD_PROBAR), PBM_SETPOS, ulProgress, 0);
                    }

                    if (!_fFirstTickValid) 
                    {
                        _dwFirstSize = ulProgress;
                        _fFirstTickValid = TRUE;

                        SetWindowText(GetDlgItem(_hDlg, IDD_NAME), _szDisplay);
                    } 
                    else
                    {
                        if ((ulProgress - _dwFirstSize) && _hDlg) 
                        {
                            // Recompute and display stats at least every second
                            if ((dwCur - _dwOldCur) >= 1000)
                            {
                                _dwOldCur = dwCur;  // Save current tick count
                                
                                TCHAR szTime[32];
                                DWORD dwSpent = ((dwCur - _dwFirstTick)+500) / 1000;
                                ULONG ulLeft = _dwFileSize - ulProgress;
                                DWORD dwRate = _dwOldRate;
                                dwRate = (ulProgress - _ulOldProgress) / (dwSpent ? dwSpent : 1);

                                TraceMsg(DM_PROGRESS, "OnProgress ulProgress=%d ulGot=%d dwSpent=%d ulLeft=%d", ulProgress, (ulProgress - _dwFirstSize), dwSpent, ulLeft);
                                
                                // Compute & display estimated time left to download, bytes so far, total bytes
                                DWORD dwEst;
                                if (ulLeft > 0x100000L)     // To avoid overflow, use KB for >1MB file.
                                    dwEst = (ulLeft >> 10) / ((dwRate >> 10) ?(dwRate >> 10) :1);
                                else
                                    dwEst = ulLeft / (dwRate ?dwRate :1);
                                    
                                if (dwEst == 0)
                                    dwEst = 1;

                                TraceMsg(DM_PROGRESS, "OnProgress Estimated time left = %d", dwEst);

                                StrFromTimeInterval(szTime, ARRAYSIZE(szTime), dwEst * 1000, 3);
                                LPTSTR pszTime = szTime;
                                while(*pszTime && (*pszTime == ' '))
                                    pszTime++;
                                _FormatMessage(_szEstimateTime, szBuf, ARRAYSIZE(szBuf), pszTime,
                                               StrFormatByteSize(ulProgress, szBytes, MAX_BYTES_STRLEN),
                                               StrFormatByteSize(_dwFileSize, szBytesMax, MAX_BYTES_STRLEN));
                                TraceMsg(DM_PROGRESS, "OnProgress Estimated string = %s", szBuf);
                                SetDlgItemText(_hDlg, IDD_TIMEEST, szBuf);
                                
                                _dwOldEst = dwEst;

                                // Compute & display transfer rate
                                if (dwRate != _dwOldRate)
                                {
                                    _dwOldRate = dwRate;
                                    _FormatMessage(_szTransferRate, szBuf, ARRAYSIZE(szBuf), StrFormatByteSize(dwRate, szBytes, MAX_BYTES_STRLEN));
                                    SetDlgItemText(_hDlg, IDD_TRANSFERRATE, szBuf);
                                }
                            }

                            // Compute & display percentage of download completed
                            DWORD dwPcent = (100 - MulDiv(_dwFileSize - ulProgress, 100, _dwFileSize));
                            if (dwPcent != _dwOldPcent)
                            {
                                _dwOldPcent = dwPcent;
                                if (dwPcent == 100)  // Don't peg the meter until we've completed
                                    dwPcent = 99;
                                    
                                TCHAR szBuf2[MAX_PATH];
                                DWORD dwSize = ARRAYSIZE(szBuf2);
                                if (PrepareURLForDisplay(pszFileName, szBuf2, &dwSize))
                                    _FormatMessage(_szTitlePercent, szBuf, ARRAYSIZE(szBuf), (UINT)dwPcent, szBuf2);
                                else
                                    _FormatMessage(_szTitlePercent, szBuf, ARRAYSIZE(szBuf), (UINT)dwPcent, pszFileName);

                                SetWindowText(_hDlg, szBuf);
                            }
                        }
                    }
                }
                else if (_hDlg && _fDownloadStarted)    // Unknown file size, just show bytes and rate
                {
                    // Recompute and display stats at most every second
                    if ((dwCur - _dwOldCur) >= 1000)
                    {
                        _dwOldCur = dwCur;  // Save current tick count

                        DWORD dwSpent = ((dwCur - _dwFirstTick)+500) / 1000;
                        DWORD dwRate = ulProgress / (dwSpent ? dwSpent : 1);

                        _FormatMessage(_szBytesCopied, szBuf, ARRAYSIZE(szBuf),
                                         StrFormatByteSize(ulProgress, szBytes, MAX_BYTES_STRLEN));
                        TraceMsg(DM_PROGRESS, "OnProgress string = %s", szBuf);
                        SetDlgItemText(_hDlg, IDD_TIMEEST, szBuf);

                        _FormatMessage(_szTransferRate, szBuf, ARRAYSIZE(szBuf), StrFormatByteSize(dwRate, szBytes, MAX_BYTES_STRLEN));
                        SetDlgItemText(_hDlg, IDD_TRANSFERRATE, szBuf);

                        {
                            TCHAR szBuf2[MAX_PATH];
                            DWORD dwSize = ARRAYSIZE(szBuf2);

                            if (PrepareURLForDisplay (pszFileName, szBuf2, &dwSize))
                                _FormatMessage(_szTitleBytes, szBuf, ARRAYSIZE(szBuf),
                                                StrFormatByteSize(ulProgress, szBytes, MAX_BYTES_STRLEN),szBuf2);
                            else
                                _FormatMessage(_szTitleBytes, szBuf, ARRAYSIZE(szBuf),
                                                StrFormatByteSize(ulProgress, szBytes, MAX_BYTES_STRLEN), pszFileName);
                            SetWindowText(_hDlg, szBuf);
                        }
                    }
                }
            }
            break;
        default:    // ulStatusCode
            break;
    }
    return S_OK;
}

HRESULT CDownload::OnStopBinding(HRESULT hrError, LPCWSTR szError)
{
    TraceMsg(DM_DOWNLOAD, "OnStopBinding called with hrError==%x", hrError);

    HRESULT hrDisplay = hrError;
    AddRef(); // Guard against last Release by _RevokeObjectParam

    HRESULT hres = RevokeBindStatusCallback(_pbc, this);
    AssertMsg(SUCCEEDED(hres), TEXT("URLMON bug??? RevokeBindStatusCallback failed %x"), hres);

    if (_pib) 
    {
        CLSID clsid;
        LPWSTR pwszError = NULL;

        HRESULT hresT = _pib->GetBindResult(&clsid, (DWORD *)&hrDisplay, &pwszError, NULL);
        TraceMsg(TF_SHDBINDING, "DLD::OnStopBinding called GetBindResult %x->%x (%x)", hrError, hrDisplay, hresT);
        if (SUCCEEDED(hresT)) 
        {
            //
            // URLMON returns a native Win32 error.
            //
            if (hrDisplay && SUCCEEDED(hrDisplay))
                hrDisplay = HRESULT_FROM_WIN32(hrDisplay);

            if (pwszError)
                OleFree(pwszError);
        }

        // We don't call IBinding::Release until ~CDownload
        // because we need to guarantee the download file
        // exists until we have copied or executed it.
    }

#ifdef DEBUG
    if (hrError==S_OK && GetKeyState(VK_CONTROL) < 0) 
    {
        hrError = E_FAIL;
    }
#endif

    if (FAILED(hrError) && hrError != E_ABORT) 
    {
        IE_ErrorMsgBox(NULL, _hDlg, hrDisplay, szError,_szDisplay, IDS_CANTDOWNLOAD, MB_OK|MB_ICONSTOP);
    }

    if (g_hCritOpMutex != NULL)
    {
        CloseHandle(g_hCritOpMutex);
        g_hCritOpMutex = NULL;
    }

    SetQueryNetSessionCount(SESSION_DECREMENT);
    
    if (!_fGotFile || !_fDownloadCompleted) 
    {
        AssertMsg(FAILED(hrError), TEXT("CDownload::OnStopBinding is called, but we've never got a file -- URLMON bug"));

        if (!_fEndDialogCalled) 
        {
            FORWARD_WM_COMMAND(_hDlg, IDCANCEL, NULL, 0, PostMessage);
        }
    }

    Release(); // Guard against last Release by _RevokeObjectParam
    return S_OK;
}

HRESULT CDownload::GetBindInfo(DWORD* grfBINDINFOF, BINDINFO *pbindinfo)
{
    TraceMsg(DM_DOWNLOAD, "DWNLD::GetBindInfo called when _pbinfo==%x", _pbinfo);

    if ( !grfBINDINFOF || !pbindinfo || !pbindinfo->cbSize )
        return E_INVALIDARG;

    if (_pbinfo) {
        // Give the ownership to URLMON... shallow copy; don't use CopyBindInfo().
        // Don't forget to keep pbindinfo cbSize!
        DWORD cbSize = pbindinfo->cbSize;
        CopyMemory( pbindinfo, _pbinfo, min(_pbinfo->cbSize, cbSize) );
        pbindinfo->cbSize = cbSize;

        if (pbindinfo->cbSize > _pbinfo->cbSize)
        {
            ZeroMemory((BYTE *)pbindinfo + _pbinfo->cbSize, pbindinfo->cbSize - _pbinfo->cbSize);
        }

        LocalFree(_pbinfo);
        _pbinfo = NULL;

    } else {
        // We don't have a BINDINFO our selves so
        // clear BINDINFO except cbSize
        DWORD cbSize = pbindinfo->cbSize;
        ZeroMemory( pbindinfo, cbSize );
        pbindinfo->cbSize = cbSize;
        if (UTF8Enabled())
            pbindinfo->dwOptions = BINDINFO_OPTIONS_ENABLE_UTF8;
    }

    // #52524. With post build ~1100, If we do not return the following flags when URLMon calls
    // GetBindInfo(), It will bind to the storage synchronously. (judej, danpoz)
    *grfBINDINFOF = _grfBINDF | BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;
    return S_OK;
}

HRESULT CDownload::OnDataAvailable(DWORD grfBSC, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
    DWORD dwOptions = 0;

    DWNLDMSG3("OnDataAvailable (grf,pstg)", grfBSC, pstgmed);

    _dwTotalSize = dwSize; // keep track of number of bytes downloaded
    
    if (SUCCEEDED(_GetRequestFlagFromPIB(_pib, &dwOptions)) && (dwOptions & INTERNET_REQFLAG_CACHE_WRITE_DISABLED)) 
    {
        _fWriteHistory = FALSE;
    }
    
    if (grfBSC & BSCF_LASTDATANOTIFICATION) 
    {
        _fDownloadCompleted = TRUE;
    }
    //
    //   This code gets the file name from pstgmed, when it became
    //  available. URLMon is supposed to pass it even though the file
    //  is not completely ready yet.
    //
    if (!_fGotFile && pstgmed) 
    {
        Animate_Stop(GetDlgItem(_hDlg, IDD_ANIMATE));
        if (pstgmed->tymed == TYMED_FILE) 
        {
            TCHAR szBuf[MAX_PATH];  // ok with MAX_PATH (because we truncate)

            SHUnicodeToTChar(pstgmed->lpszFileName, _szPath, ARRAYSIZE(_szPath));

            // Because of redirection the _szURL could be http://.../redir.dll or query.exe.
            // Whereas the actual filename would be something else. The Cache filename is generated
            // by wininet after it has figured out what the real filename is. However, it might contain
            // a "(1)" or a "(2)" at the end of the file name.

            TCHAR szURL[MAX_URL_STRING];

            StrCpyN(szURL, _szURL, ARRAYSIZE(szURL));

            TCHAR * pszURLFName = PathFindFileName(szURL);
            TCHAR * pszCacheFName = PathFindFileName(_szPath);

            // Unescape the filename suggested by wininet.
            DWORD cch = ARRAYSIZE(szBuf);
            if (_PrepareURLForDisplayUTF8W(pszCacheFName, szBuf, &cch, _fUTF8Enabled, _uiCP) != S_OK)
                StrCpyN(szBuf, pszCacheFName, ARRAYSIZE(szBuf));


            // Strip out any path that may have been encoded
            pszCacheFName = szBuf;
            TCHAR *pszSrc = PathFindFileName(szBuf);
            if (pszSrc != szBuf)
            {
                while(*pszSrc)
                    *pszCacheFName++ = *pszSrc++;
                *pszCacheFName = *pszSrc;
            }

            // Use the Cache name. pszURLFName point to the file name in szURL. Just overwrite it
            if (pszURLFName && szBuf)
            {
                *pszURLFName = 0;
                StringCchCat(szURL, ARRAYSIZE(szURL), szBuf);

                FormatUrlForDisplay(szURL, _szDisplay, ARRAYSIZE(_szDisplay), NULL, 0, TRUE, _uiCP, NULL);
            }

            DWNLDMSG("OnDataAvailable got TYMED_FILE", _szPath);
            _fGotFile = TRUE;

            TCHAR szMime[MAX_PATH];
            if (GetClipboardFormatName(pformatetc->cfFormat, szMime, sizeof(szMime)/sizeof(szMime[0])))
            {
                MIME_GetExtension(szMime, (LPTSTR) _szExt, SIZECHARS(_szExt));
            }

            SetWindowText(GetDlgItem(_hDlg, IDD_NAME), _szDisplay);

            UINT uRet = _MayAskUserIsFileSafeToOpen(szMime);
            switch (uRet) {
            case IDOK:
                MLLoadString(IDS_OPENING, szBuf, ARRAYSIZE(szBuf));
                break;

            case IDD_SAVEAS:
                _fSaveAs = TRUE;
                _fCallVerifyTrust = FALSE;
                MLLoadString(IDS_SAVING, szBuf, ARRAYSIZE(szBuf));
                break;

            case IDCANCEL:
                FORWARD_WM_COMMAND(_hDlg, IDCANCEL, NULL, 0, PostMessage);

                //
                // HACK: Under a certain condition, we receive one more
                //  OnDataAvailable from URLMON with BSCF_LASTDATANOTIFICATION
                //  before this posted message is dispatched. It causes
                //  WinVerifyTrust call, which is wrong. To prevent it,
                //  we unset this flag.
                //
                //  We still assumes that OnStopBinding will not happen before
                //  this message is dispatched. In IE 4.0, we should introduce
                //  another flag (_fCancelled) to make it more robust.
                //
                _fCallVerifyTrust = FALSE;
                return S_OK;

            }

            SetDlgItemText(_hDlg, IDD_OPENIT, szBuf);

            if (_fSaveAs)
            {
                if (!_GetSaveLocation())
                {
                    FORWARD_WM_COMMAND(_hDlg, IDCANCEL, NULL, 0, PostMessage);
                    return S_OK;
                }
                StrCpyN(szBuf, _szSaveToFile, ARRAYSIZE(szBuf));

                RECT rect;
                GetClientRect(GetDlgItem(_hDlg, IDD_DIR), &rect);
                PathCompactPath(NULL, szBuf, rect.right);
            }
            else
                MLLoadString(IDS_DOWNLOADTOCACHE, szBuf, ARRAYSIZE(szBuf));

            SetDlgItemText(_hDlg, IDD_DIR, szBuf);
            Animate_Play(GetDlgItem(_hDlg, IDD_ANIMATE),0, -1, -1);
            
            if (_dwFirstTick == 0)   // Start the timer
                _dwFirstTick = GetTickCount();
        }
        else
        {
            TraceMsg(DM_WARNING, "CDownload::OnDataAvailable pstgmed->tymed (%d) != TYMED_FILE", pstgmed->tymed);
        }
        _fDownloadStarted = TRUE;
    }

    if (_fDownloadCompleted) 
    {
#ifdef CALL_WVT
        if (_fCallVerifyTrust)
        {
            ShowWindow(_hDlg, SW_HIDE);
            UINT uRet = _VerifyTrust(_hDlg, _szPath, _szDisplay);
            switch (uRet) {
            case IDOK:
                break;

            default:
                // We assume _VerifyTrust always is able to open the file
                // passed from URLMON. If it fails, we bail with no UI.
                ASSERT(0);
                // Fall through
            case IDCANCEL:
                _fDeleteFromCache = TRUE;
                FORWARD_WM_COMMAND(_hDlg, IDCANCEL, NULL, 0, PostMessage);
                return S_OK;
            }
        }
#endif // CALL_WVT

        DWNLDMSG3("OnDataAvailable calling Animate_Stop", _hDlg, GetDlgItem(_hDlg, IDD_ANIMATE));
        Animate_Stop(GetDlgItem(_hDlg, IDD_ANIMATE));

        SendMessage(GetDlgItem(_hDlg, IDD_PROBAR), PBM_SETRANGE32, 0, 100);
        SendMessage(GetDlgItem(_hDlg, IDD_PROBAR), PBM_SETPOS, 100, 0);

        if (_fSaveAs) {
            FORWARD_WM_COMMAND(_hDlg, IDD_SAVEAS, NULL, 0, PostMessage);
        } else {
#ifdef USE_LOCKREQUEST
            LockRequestHandle();  // Tell wininet that we want the file locked to allow the app to open it.
                                  // This prevents wininet from deleting the file from the cache before the
                                  // app gets a chance to use it.  When wininet sees this file is locked, it
                                  // will add the file to the scavenger leak list and attempt to delete the
                                  // file in the future.
#endif
            
            FORWARD_WM_COMMAND(_hDlg, IDOK, NULL, 0, PostMessage);
        }
    }
    return S_OK;
}

HRESULT CDownload::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    DWORD dwOptions = 0;

    DWNLDMSG3("OnObjectAvailable (riid,punk)", riid, punk);

    if (SUCCEEDED(_GetRequestFlagFromPIB(_pib, &dwOptions)) && (dwOptions & INTERNET_REQFLAG_CACHE_WRITE_DISABLED)) 
    {
        _fWriteHistory = FALSE;
    }

    return S_OK;
}

/* *** IHttpNegotiate ***  */
HRESULT CDownload::BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
        DWORD dwReserved, LPWSTR *pszAdditionalHeaders)
{
    if ((!_pwzHeaders) || (!pszAdditionalHeaders))
        return S_OK;

    DWORD cbHeaders = (lstrlenW(_pwzHeaders) + 1) * sizeof(WCHAR);
    LPWSTR pwzHeaders = (LPWSTR)CoTaskMemAlloc(cbHeaders + sizeof(WCHAR));

    if (pwzHeaders)
    {
        memcpy (pwzHeaders, _pwzHeaders, cbHeaders);
        *pszAdditionalHeaders = pwzHeaders;
    }
    // Caller owns freeing *pszAdditionalHeaders
    return S_OK;
}

HRESULT CDownload::OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders, 
                              LPCWSTR szRequestHeaders, LPWSTR *pszAdditionalRequestHeaders)
{
    return S_OK;
}


BOOL _RememberFileIsSafeToOpen(LPCTSTR szFileClass)
{
    DWORD dwEditFlags;
    ULONG cb = sizeof(dwEditFlags);

    HRESULT hr;
    IQueryAssociations *passoc = NULL;
    BOOL bRet = FALSE;

    hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &passoc));
    if (SUCCEEDED(hr) && passoc)
    {
        hr = passoc->Init(NULL, szFileClass, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            hr = passoc->GetData(NULL, ASSOCDATA_EDITFLAGS, NULL, &dwEditFlags, &cb);
            if (SUCCEEDED(hr))
            {
                dwEditFlags &= ~FTA_NoEdit;
                dwEditFlags |= FTA_OpenIsSafe;
            }
        }
        passoc->Release();
    }

    if (FAILED(hr))
        dwEditFlags = FTA_OpenIsSafe;   

    return (SHSetValue(HKEY_CLASSES_ROOT, szFileClass, TEXT("EditFlags"),
                             REG_BINARY, (BYTE*)&dwEditFlags,
                             sizeof(dwEditFlags)) == ERROR_SUCCESS);
}


struct SAFEOPENDLGPARAM {
    LPCTSTR pszFileClass;
    LPCTSTR pszFriendlyURL;
    LPCTSTR pszURL;
    HWND    hwndTT;
    TCHAR*  pszTTText;
    LPCTSTR pszCacheFile;
    DWORD   uiCP;
    BOOL    fTypeMismatch;
    BOOL    fShellExecPrompt;
    BOOL    fPackagerCommandPrompt;
};

INT_PTR CALLBACK SafeOpenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UINT id;
    static BOOL bCancelled;
    SAFEOPENDLGPARAM* param = (SAFEOPENDLGPARAM*) GetWindowLongPtr(hDlg, DWLP_USER);

    if ((param == NULL) && (uMsg != WM_INITDIALOG))
        return FALSE;
        
    switch (uMsg) {
    case WM_INITDIALOG:
    {
        BOOL fUnsafeFile;
        TCHAR szFriendlyName[MAX_DISPLAY_LEN] = {TEXT('\0')};
        TCHAR szFriendlyFrom[MAX_DISPLAY_LEN] = {TEXT('\0')};
        TCHAR szProcessedURL[MAX_URL_STRING] = {TEXT('\0')};
        DWORD dwSize = ARRAYSIZE(szProcessedURL);

        if (lParam == NULL)
            return FALSE;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        param = (SAFEOPENDLGPARAM*)lParam;

        // init unsafe file to mismatch between progid and file
        fUnsafeFile = param->fTypeMismatch;

        // Determine whether or not to gray out the Always ask checkbox. We wil gray out in the following cases
        // 1. If we were not told what the file class is
        // 2. If the file class is in the unsafe extensions list
        // 3. if the file extension in the URL is in the unsafe extensions list
        // 4. if the cache file extension is in the unsafe extensions list (if we are redirected)
        TCHAR * pszExt = NULL;
        TCHAR * pszCacheExt = NULL;

        if (param->pszURL)
            pszExt = PathFindExtension(param->pszURL);

        if (param->pszCacheFile)
            pszCacheExt = PathFindExtension(param->pszCacheFile);

        if(param->fPackagerCommandPrompt)
        {
            fUnsafeFile = TRUE;
        }
        else if (pszExt || pszCacheExt)
        {
            if (pszExt && AssocIsDangerous(pszExt))
                fUnsafeFile = TRUE;
            else if (pszCacheExt && AssocIsDangerous(pszCacheExt))
                fUnsafeFile = TRUE;
        }
        else
        {
            fUnsafeFile = TRUE;
        }
        
        if (fUnsafeFile || SHRestricted2(REST_AlwaysPromptWhenDownload, NULL, 0))
            EnableWindow(GetDlgItem(hDlg, IDC_SAFEOPEN_ALWAYS), FALSE);
        // The check box is always checked by default
        CheckDlgButton(hDlg, IDC_SAFEOPEN_ALWAYS, TRUE);
        
        // adjust the warning
        if (fUnsafeFile)
        {
            HICON hIcon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_PRIVACY_WARN),
                            IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
            if (hIcon != NULL)
                SendDlgItemMessage(hDlg, IDC_SAFEOPEN_WARNICON, STM_SETICON, (WPARAM)hIcon, 0);
        }
        else
        {
            ShowWindow(GetDlgItem(hDlg, IDC_SAFEOPEN_WARNTEXT), SW_HIDE);
        }

        // cross-lang platform support
        SHSetDefaultDialogFont(hDlg, IDC_SAFEOPEN_FILENAME);
        SHSetDefaultDialogFont(hDlg, IDC_SAFEOPEN_FILETYPE);
        SHSetDefaultDialogFont(hDlg, IDC_SAFEOPEN_FILEFROM);
        
        // Get the URL for the tooltip. Also get URL for the display string if we weren't passed one
        if (param->pszURL)
        {
            if (!PrepareURLForDisplay(param->pszURL, szProcessedURL, &dwSize))
            {
                dwSize = ARRAYSIZE(szProcessedURL);
                StrCpyN(szProcessedURL, param->pszURL, dwSize);
            }
        }

        // Now figure out what we want to display
        if(param->fPackagerCommandPrompt)
        {
            // If this was a packager command line, then just display the full command as passed in param->pszURL
            StrCpyN(szFriendlyName, param->pszURL, ARRAYSIZE(szFriendlyName));
        }
        else
        {
            FormatUrlForDisplay((LPTSTR)param->pszURL, szFriendlyName, ARRAYSIZE(szFriendlyName), szFriendlyFrom, ARRAYSIZE(szFriendlyFrom),
                            TRUE, param->uiCP, (PWSTR)param->pszCacheFile);
        }

        SetDlgItemText(hDlg, IDC_SAFEOPEN_FILENAME, szFriendlyName);

        if(param->fPackagerCommandPrompt)
        {
            // If it was a packager command line, then display "Unknown" for the from
            MLLoadString(IDS_VALUE_UNKNOWN, szFriendlyFrom, ARRAYSIZE(szFriendlyFrom)); 
            SetDlgItemText(hDlg, IDC_SAFEOPEN_FILEFROM, szFriendlyFrom);
        }
        else
        {
            if (szFriendlyFrom[0] != '\0')
                SetDlgItemText(hDlg, IDC_SAFEOPEN_FILEFROM, szFriendlyFrom);
        }

        if (param->pszFileClass || pszCacheExt)
        {
            DWORD cchName = ARRAYSIZE(szFriendlyName);

            if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_FRIENDLYDOCNAME,
                (param->pszFileClass ? param->pszFileClass : pszCacheExt), NULL, szFriendlyName, &cchName)))
            {
                SetDlgItemText(hDlg, IDC_SAFEOPEN_FILETYPE, szFriendlyName);
            }
        }

        int cch = lstrlen(szProcessedURL) + 1;
        param->pszTTText = (TCHAR*)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if (param->pszTTText)
        {
            StrCpyN(param->pszTTText, szProcessedURL, cch);
            if (param->hwndTT = CreateWindow(TOOLTIPS_CLASS, NULL, WS_POPUP | TTS_ALWAYSTIP,
                                      CW_USEDEFAULT, CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
                                      hDlg, NULL, HINST_THISDLL, NULL))
            {
                TOOLINFO ti;

                ti.cbSize = sizeof(ti);
                ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
                ti.hwnd = hDlg;
                ti.uId = (UINT_PTR) GetDlgItem(hDlg, IDC_SAFEOPEN_FILENAME);
                ti.lpszText = LPSTR_TEXTCALLBACK;
                ti.hinst = HINST_THISDLL;
                GetWindowRect((HWND)ti.uId, &ti.rect);
                SendMessage(param->hwndTT, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
                SendMessage(param->hwndTT, TTM_SETMAXTIPWIDTH, 0, 300);
            }
        }

        if (param->fShellExecPrompt)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_SAFEOPEN_AUTOSAVE), FALSE);
            // make Cancel the default action
            SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDCANCEL), TRUE);
        }
        else
        {
            // make Save the default action
            SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDC_SAFEOPEN_AUTOSAVE), TRUE);
        }
        return FALSE;
    }

    case WM_NOTIFY:
    {
        LPTOOLTIPTEXT lpTT = (LPTOOLTIPTEXT) lParam;
        if (lpTT->hdr.code == TTN_NEEDTEXT)
        {
            lpTT->lpszText = param->pszTTText;
            lpTT->hinst = NULL;
        }
        break;
    }

   case WM_DESTROY:

        //deal with checkbox
        if ((!bCancelled) &&  (!IsDlgButtonChecked(hDlg, IDC_SAFEOPEN_ALWAYS)) && param->pszURL)
        {
            // Now save EditFlags at the key value value that the filetypes dialog will get/set.
            TCHAR * pszExt = PathFindExtension(param->pszURL);
            if (*pszExt)
            {
                TCHAR szFileClass[MAX_PATH];
                ULONG cb = sizeof(szFileClass);
                *szFileClass = TEXT('\0');
                SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szFileClass, &cb);
                if (*szFileClass)
                    _RememberFileIsSafeToOpen(szFileClass);
            }
        }

        SHRemoveDefaultDialogFont(hDlg);

        if (IsWindow(param->hwndTT))
            DestroyWindow(param->hwndTT);

        if (param->pszTTText)
        {
            LocalFree(param->pszTTText);
            param->pszTTText = NULL;
        }

        return FALSE;

    case WM_COMMAND:
        id = GET_WM_COMMAND_ID(wParam, lParam);
        switch (id) 
        {
        case IDC_SAFEOPEN_AUTOOPEN:
            EndDialog(hDlg, IDOK);
            break;

        case IDC_SAFEOPEN_AUTOSAVE:
            EndDialog(hDlg, IDD_SAVEAS);
            break;
        
        case IDM_MOREINFO:
            SHHtmlHelpOnDemandWrap(hDlg, TEXT("iexplore.chm > iedefault"), HH_DISPLAY_TOPIC, (DWORD_PTR) TEXT("filedown.htm"), ML_CROSSCODEPAGE);
            break;

        case IDCANCEL:
            bCancelled = TRUE;
            EndDialog(hDlg, id);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

UINT OpenSafeOpenDialog(HWND hwnd, UINT idRes, LPCTSTR pszFileClass, LPCTSTR pszURL, LPCTSTR pszRedirURL, LPCTSTR pszCacheName, LPCTSTR pszDisplay, UINT uiCP, IUnknown *punk, BOOL fTypeMismatch)
{
    UINT uRet;
    IDownloadManager *pdlm;
    HRESULT hr = IUnknown_QueryService(punk, SID_SDownloadManager, IID_PPV_ARG(IDownloadManager, &pdlm));
    if (SUCCEEDED(hr))
    {
        pdlm->Release();
        return IDD_SAVEAS;
    }
    
    LPCTSTR pszTemp = pszURL;
    if (pszRedirURL && lstrlen(pszRedirURL))
        pszTemp = pszRedirURL;

    SAFEOPENDLGPARAM param = { pszFileClass, pszDisplay, pszTemp, 0, 0, pszCacheName, uiCP, fTypeMismatch, FALSE, FALSE};
    uRet = (UINT) DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(idRes), hwnd, SafeOpenDlgProc, (LPARAM)&param);
    return uRet;
}

STDAPI_(BOOL) SafeOpenPromptForShellExec(HWND hwnd, PCWSTR pszFile)
{
    SAFEOPENDLGPARAM param = { PathFindExtension(pszFile), NULL, pszFile, 0, 0, NULL, CP_ACP, TRUE, TRUE, FALSE};
    return IDOK == (UINT) DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_SAFEOPEN), hwnd, SafeOpenDlgProc, (LPARAM)&param);
}

STDAPI_(BOOL) SafeOpenPromptForPackager(HWND hwnd, PCWSTR pszFile, BOOL bFromCommandLine)
{
    SAFEOPENDLGPARAM param = { PathFindExtension(pszFile), NULL, pszFile, 0, 0, NULL, CP_ACP, TRUE, TRUE, bFromCommandLine};
    return IDOK == (UINT) DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_SAFEOPEN), hwnd, SafeOpenDlgProc, (LPARAM)&param);
}

BOOL _OpenIsSafe(LPCTSTR pszClass)
{
    BOOL bRet = FALSE;
    IQueryAssociations *passoc;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &passoc));
    if (SUCCEEDED(hr))
    {
        hr = passoc->Init(NULL, pszClass, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            DWORD dwEditFlags;
            ULONG cb = sizeof(dwEditFlags);
            hr = passoc->GetData(NULL, ASSOCDATA_EDITFLAGS, NULL, &dwEditFlags, &cb);
            if (SUCCEEDED(hr))
            {
                if (dwEditFlags & FTA_OpenIsSafe)
                    bRet = TRUE;
            }
        }
        passoc->Release();
    }
    return bRet;
}

UINT MayOpenSafeOpenDialog(HWND       hwnd,
                           LPCTSTR    pszFileClass,
                           LPCTSTR    pszURL,
                           LPCTSTR    pszCacheName,
                           LPCTSTR    pszDisplay,
                           UINT       uiCP,
                           IUnknown * punk,
                           IOleCommandTarget * pCmdTarget = NULL,
                           BOOL       fDisableOpen = FALSE)
{
    // Has some association
    UINT uiRet = IDIGNORE;  // default for no dlg displayed
    const LPCTSTR c_szExcluded[] = {TEXT(".ins"),TEXT(".isp")};
    const LPCTSTR c_szNoZoneCheckExtns[] = {TEXT(".cdf")};

    BOOL fSafe = _OpenIsSafe(pszFileClass);

    // We will not do Zone check on CDF files..#56297.
    if (!IsTypeInList(pszFileClass, c_szNoZoneCheckExtns, ARRAYSIZE(c_szNoZoneCheckExtns)))
    {
        DWORD dwPolicy = 0, dwContext = 0;
        ZoneCheckUrlEx(pszURL, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                    URLACTION_SHELL_FILE_DOWNLOAD, PUAF_NOUI, NULL);
        dwPolicy = GetUrlPolicyPermissions(dwPolicy);
        if ((dwPolicy != URLPOLICY_ALLOW) && (dwPolicy != URLPOLICY_QUERY))
        {
            ProcessStartbindingError(hwnd, NULL, NULL, MB_ICONWARNING, E_ACCESSDENIED, pszURL);
            return IDCANCEL;
        }
    }


    // Always ask for certain the types that we know to be unsafe. We will allow .ins and .isp
    // files through for the ICW folks.
    if (AssocIsDangerous(pszFileClass) &&
        !IsTypeInList(pszFileClass, c_szExcluded, ARRAYSIZE(c_szExcluded)))
        fSafe = FALSE;

    if (!fSafe || SHRestricted2(REST_AlwaysPromptWhenDownload, NULL,0))
    {
        VARIANT varOut = {0};

        if (pCmdTarget)
        {
            pCmdTarget->Exec(&CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD, 0, NULL, &varOut);
        }

        if ((V_VT(&varOut) != VT_BOOL) || (VARIANT_FALSE == V_BOOL(&varOut)))
        { 
            uiRet = OpenSafeOpenDialog(hwnd,
                                       DLG_SAFEOPEN,
                                       pszFileClass,
                                       pszURL,
                                       NULL,
                                       pszCacheName,
                                       pszDisplay,
                                       uiCP,
                                       punk,
                                       fDisableOpen);
        }
    }

    if (uiRet != IDOK && uiRet != IDD_SAVEAS && uiRet != IDIGNORE)
        DeleteUrlCacheEntry(pszURL);

    return(uiRet);
}

#ifdef CALL_WVT
// Returns:
//
//  IDOK     -- If it's trusted
//  IDNO     -- If it's not known (warning dialog requried)
//  IDCANCEL -- We need to stop download it
//
UINT _VerifyTrust(HWND hwnd, LPCTSTR pszFileName, LPCWSTR pszStatusText)
{
    UINT uRet = IDNO; // assume unknown
    HANDLE hFile = CreateFile(pszFileName, GENERIC_READ, FILE_SHARE_READ,
                    NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        HRESULT hres =  g_wvt.VerifyTrust(hFile, hwnd, pszStatusText);
        if (SUCCEEDED(hres)) 
        {
            uRet = IDOK;
        } 
        else 
        {
            ASSERT((hres != HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND)) &&
                   (hres != HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND)));

            uRet = IDCANCEL;
        }

        CloseHandle(hFile);
    } 
    else
    {
        TraceMsg(DM_WARNING, "_VerifyTrust CreateFile failed %x", GetLastError());
    }

    TraceMsg(DM_WVT, "_VerifyTrust returning %d", uRet);
    return uRet;
}
#endif // CALL_WVT

//
// Returns:
//  IDOK: Continue download and open it
//  IDD_SAVEAS: Save it as a file
//  IDCANCEL: Stop downloading
//
UINT CDownload::_MayAskUserIsFileSafeToOpen(LPCTSTR pszMime)
{
    if (_fSaveAs || _fSafe) 
    {
        return (_fSaveAs ? IDD_SAVEAS : IDOK);    // no need to ask
    }

    // Force save as dialog if we are using SSL and 
    // HKCU\software\microsoft\windows\currentversion\internet settings\DisableCachingOfSSLPages is set
    DWORD dwValue;
    DWORD dwDefault = 0;
    DWORD dwSize;
    dwSize = sizeof(dwValue);
    SHRegGetUSValue(TSZWININETPATH, TEXT("DisableCachingOfSSLPages"), NULL, (LPBYTE)&dwValue, &dwSize, FALSE, (void *) &dwDefault, sizeof(dwDefault));

    if (dwValue != 0 && URL_SCHEME_HTTPS == GetUrlScheme(_szURL))
    {
        return(IDD_SAVEAS);
    }

    if(_fConfirmed)
    {
        return IDOK;
    }

    BOOL fUnknownType = TRUE;
    UINT uRet = IDNO;   // assume no extension or no association
    LPTSTR pszExt = PathFindExtension(_szPath);

    if (*pszExt) 
    {
        TCHAR szFileClass[MAX_PATH];
        memset(szFileClass, 0, ARRAYSIZE(szFileClass));
#ifdef CALL_WVT
        //
        //  If this is an EXE and we have WINTRUST ready to call,
        // don't popup any UI here at this point.
        if ((StrCmpI(pszExt, TEXT(".exe"))==0) && SUCCEEDED(g_wvt.Init()))
        {
            TraceMsg(DM_WVT, "_MayAskUIFSTO this is EXE, we call _VerifyTrust later");
            _fCallVerifyTrust = TRUE;
        }
#endif // CALL_WVT

        ULONG cb = SIZEOF(szFileClass);
        if ((RegQueryValue(HKEY_CLASSES_ROOT, pszExt, szFileClass, (LONG*)&cb)
                == ERROR_SUCCESS) && * szFileClass)
        {
            fUnknownType = FALSE;
            uRet = MayOpenSafeOpenDialog(_hDlg, szFileClass, _szURL, _szPath, _szDisplay, _uiCP, NULL, NULL, FALSE);
            if (uRet == IDIGNORE)   // caller doesn't recognize IDIGNORE
                uRet = IDOK;
        }
    }

    if (fUnknownType) 
    {
        uRet = OpenSafeOpenDialog(_hDlg, DLG_SAFEOPEN, NULL, _szURL, NULL, _szPath, _szDisplay, _uiCP, NULL, FALSE);
    }

    return uRet;
}

// *** IAuthenticate ***
HRESULT CDownload::Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword)
{
    if (!phwnd || !pszUsername || !pszPassword)
        return E_POINTER;

    *phwnd = _hDlg;
    *pszUsername = NULL;
    *pszPassword = NULL;
    return S_OK;
}

HRESULT CDownload::GetWindow(REFGUID RefGUID, HWND *phWnd)
{
    if (IsEqualGUID(RefGUID, IID_IHttpSecurity))
    {
        *phWnd = _hDlg;
        return S_OK;
    }
    else
        return E_FAIL;
}

// *** IServiceProvider ***
HRESULT CDownload::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualGUID(guidService, IID_IAuthenticate))
    {
        return QueryInterface(riid, ppvObj);
    }
    return E_FAIL;
}

//   S_OK : continue with operation
//   S_FALSE : cancel operation.

HRESULT CDownload::PerformVirusScan(LPCTSTR szFileName)
{
    HRESULT hr = S_OK;  // default to accepting the file

    IVirusScanner *pvs;
    if (SUCCEEDED(CreateFromRegKey(TSZIEPATH, TEXT("VirusScanner"), IID_PPV_ARG(IVirusScanner, &pvs))))
    {
        STGMEDIUM stg;
        WCHAR wszFileName[MAX_PATH];

        VIRUSINFO vi;
        vi.cbSize = sizeof(VIRUSINFO);

        //
        // VIRUSINFO lpszFileName is not defined as 'const' so we need to copy
        // szFileName into a buffer.  If it really should be const get rid of
        // this copy and use a cast.
        //
        StrCpyN(wszFileName, szFileName, ARRAYSIZE(wszFileName));
        stg.tymed = TYMED_FILE;
        stg.lpszFileName = wszFileName;
        stg.pUnkForRelease = NULL;

        hr = pvs->ScanForVirus(_hDlg, &stg, _pwszDisplayName, SFV_DELETE, &vi);

        switch (hr) {

        case S_OK:
            break;

        case VSCAN_E_NOPROVIDERS:   //No virus scanning providers
        case VSCAN_E_CHECKPARTIAL:  //Atleast one of providers didn't work.
        case VSCAN_E_CHECKFAIL:     //No providers worked.
            hr = S_OK;
            break;

        case VSCAN_E_DELETEFAIL:    //Tried to delete virus file but failed.
        case S_FALSE:               // Virus found.
            hr = E_FAIL;
            break;

        // If some bizarre result, continue on.
        default:
            hr = S_OK;
            break;
        }

        pvs->Release();
    }

    return hr;
}

// Starts a download of a file in its own window.

// This function is exported and called by HTML doc object.
// Someday we probably want to put this in a COM interface.
// Currently it just calls the internal function CDownLoad_OpenUIURL.

STDAPI DoFileDownload(LPCWSTR pwszURL)
{
    return CDownLoad_OpenUIURL(pwszURL, NULL, NULL, FALSE,TRUE);
}

STDAPI DoFileDownloadEx(LPCWSTR pwszURL, BOOL fSaveAs)
{
    return CDownLoad_OpenUIURL(pwszURL, NULL, NULL, FALSE, fSaveAs);
}

#ifdef DEBUG
const DWORD CDownloadThreadParam::s_dummy = 0;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\explband.cpp ===
#include "priv.h"
#include "sccls.h"
#include "nscband.h"
#include "resource.h"
#include "uemapp.h"   // KMTF: Included for instrumentation
#include "shlguid.h"
#include <dpa.h>
#include <mluisupp.h>
#include "varutil.h"
#include "apithk.h"

#define TF_EXPLORERBAND  0

typedef struct
{
    LPITEMIDLIST pidl;
    IShellFolder *psf;
} SFCITEM;

class CExplorerBand : public CNSCBand,
                    public IDispatch
{
public:

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CNSCBand::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) { return CNSCBand::Release(); };

    // *** IOleCommandTarget methods ***
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDockingWindow methods ***
    STDMETHODIMP CloseDW(DWORD dw);
    STDMETHODIMP ShowDW(BOOL fShow);

    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** INamespaceProxy methods ***
    STDMETHODIMP Invoke(LPCITEMIDLIST pidl);
    STDMETHODIMP OnSelectionChanged(LPCITEMIDLIST pidl);
    STDMETHODIMP CacheItem(LPCITEMIDLIST pidl) {_MaybeAddToLegacySFC(pidl); return S_OK;}
    
    // *** IDispatch methods ***
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) {return E_NOTIMPL;}
    STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) {return E_NOTIMPL;}
    STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) {return E_NOTIMPL;}
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                  DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

protected:
    CExplorerBand() : _fCanSelect(TRUE), _fIgnoreSelection(TRUE)
    {}
    virtual ~CExplorerBand();
    
    virtual HRESULT _TranslatePidl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib);
    virtual BOOL _ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib);
    virtual HRESULT _InitializeNsc();
    virtual DWORD _GetTVStyle();
    virtual DWORD _GetTVExStyle();
    virtual DWORD _GetEnumFlags();
    void _MaybeAddToLegacySFC(LPCITEMIDLIST pidl);
    void _AddToLegacySFC(LPCITEMIDLIST pidl, IShellFolder *psf);
    BOOL _IsInSFC(LPCITEMIDLIST pidl);
    BOOL _IsFloppy(LPCITEMIDLIST pidl);
    void _OnNavigate();
    HRESULT _ConnectToBrowser(BOOL fConnect);    
    friend HRESULT CExplorerBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

    static void s_DVEnumReadyCallback(void *pvData);

    CDSA<SFCITEM> *_pdsaLegacySFC;
    DWORD _dwcpCookie;
    LPITEMIDLIST _pidlView; //pidl view is navigated to
    BOOL _fCanSelect;
    BOOL _fIgnoreSelection; //so we don't navigate away from the web page when user opens explorer pane
    BOOL _fFloppyRefresh;
};

HRESULT _UnwrapRootedPidl(LPCITEMIDLIST pidlRooted, BOOL bOnlyIfRooted, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_FAIL;
    if (ILIsRooted(pidlRooted))
    {
        hr = SHILCombine(ILRootedFindIDList(pidlRooted), _ILNext(pidlRooted), ppidl);
    }
    else if (!bOnlyIfRooted)
    {
        hr = SHILClone(pidlRooted, ppidl);
    }

    return hr;
}


BOOL IsFTPPidl(LPCITEMIDLIST pidl)
{
    BOOL fIsFTP = FALSE;
    IShellFolder * psf;

    if (pidl && SUCCEEDED(IEBindToObject(pidl, &psf)))
    {
        fIsFTP = IsFTPFolder(psf);
        psf->Release();
    }

    return fIsFTP;
}


void CExplorerBand::_OnNavigate()
{
    IBrowserService* pbs;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IBrowserService, &pbs));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        hr = pbs->GetPidl(&pidl);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlNew;
            hr = _UnwrapRootedPidl(pidl, FALSE, &pidlNew);
            if (SUCCEEDED(hr))
            {
                // We must go in this code path if the pidl is an FTP pidl.  FTP pidls can contain
                // passwords so it needs to replace any existing pidl.  Whistler #252206.
                if (!_pidlView || !ILIsEqual(pidlNew, _pidlView) || IsFTPPidl(pidlNew))
                {
                    DWORD dwAttributes = SFGAO_FOLDER;
                    // only let folders go through (to filter out Web pages)
                    hr = IEGetAttributesOf(pidlNew, &dwAttributes);
                    if (SUCCEEDED(hr) && (dwAttributes & SFGAO_FOLDER))
                    {
                        BOOL fExpand = (_pidlView == NULL); //the very first time we expand the folder the view is navigated to
                        Pidl_Set(&_pidlView, pidlNew);
                        _fIgnoreSelection = FALSE; //in the web page case we don't come here because the page does not have folder attribute
                        
                        if (_fCanSelect)
                        {
                            if (fExpand)
                            {
                                VARIANT var;
                                hr = InitVariantFromIDList(&var, _pidlView);
                                if (SUCCEEDED(hr))
                                {
                                    IShellNameSpace *psns;
                                    hr = _pns->QueryInterface(IID_PPV_ARG(IShellNameSpace, &psns));
                                    if (SUCCEEDED(hr))
                                    {
                                        psns->Expand(var, 1);
                                        psns->Release();
                                    }
                                    VariantClear(&var);
                                }
                            }
                            else
                            {
                                _pns->SetSelectedItem(_pidlView, TRUE, FALSE, 0);
                            }
                        }
                    }
                }
                // view navigation is asynchronous so we don't know if it failed in OnSelectionChanged
                // but the view is getting navigated to the old pidl and _fCanSelect is false (which happens after we try
                // to navigate the view) so it is safe to assume that navigation failed.
                // we need to update the selection to match the view
                else if (ILIsEqual(pidlNew, _pidlView) && !_fCanSelect)
                {
                    _pns->SetSelectedItem(_pidlView, TRUE, FALSE, 0);
                }
                
                _fCanSelect = TRUE;
                ILFree(pidlNew);
            }
            ILFree(pidl);
        }
        pbs->Release();
    }

    if (FAILED(hr))
    {
        Pidl_Set(&_pidlView, NULL);
    }
}

HRESULT CExplorerBand::Invoke(DISPID dispidMember, REFIID riid,LCID lcid, WORD wFlags,
                  DISPPARAMS *pdispparams, VARIANT *pvarResult,
                  EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT hr = S_OK;

    if (!pdispparams)
        return E_INVALIDARG;

    switch(dispidMember)
    {
    case DISPID_NAVIGATECOMPLETE2:
    case DISPID_DOCUMENTCOMPLETE:
        {
            BOOL fCallNavigateFinished = TRUE;
            IDVGetEnum *pdvge;
            if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IDVGetEnum, &pdvge))))
            {
                // callback will call it
                fCallNavigateFinished = FALSE;
                if (dispidMember == DISPID_NAVIGATECOMPLETE2)
                    pdvge->SetEnumReadyCallback(s_DVEnumReadyCallback, this);
                    
                pdvge->Release();
            }
            _OnNavigate();
            if (fCallNavigateFinished && DISPID_DOCUMENTCOMPLETE == dispidMember)
            {
                // need to let nsc know the navigation finished in case we navigated to a 3rd party namespace extension (w/ its own view impl)
                // because it does not implement IDVGetEnum, hence s_DVEnumReadyCallback will not get called
                LPITEMIDLIST pidlClone = ILClone(_pidlView);
                // should we unwrap this pidl if rooted?
                if (pidlClone)
                    _pns->RightPaneNavigationFinished(pidlClone); // takes ownership
            }
        }
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}

void CExplorerBand::s_DVEnumReadyCallback(void *pvData)
{
    CExplorerBand *peb = (CExplorerBand *) pvData;
    IBrowserService* pbs;
    if (SUCCEEDED(IUnknown_QueryService(peb->_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IBrowserService, &pbs))))
    {
        LPITEMIDLIST pidlTemp;
        if (SUCCEEDED(pbs->GetPidl(&pidlTemp)))
        {
            LPITEMIDLIST pidl;
            if (SUCCEEDED(_UnwrapRootedPidl(pidlTemp, FALSE, &pidl)))
            {
                peb->_pns->RightPaneNavigationFinished(pidl);   // takes ownership
            }
            ILFree(pidlTemp);
        }
        pbs->Release();
    }
}

const TCHAR c_szLink[] = TEXT("link");
const TCHAR c_szRename[] = TEXT("rename");
const TCHAR c_szMove[] = TEXT("cut");
const TCHAR c_szPaste[] = TEXT("paste");
const TCHAR c_szCopy[] = TEXT("copy");
const TCHAR c_szDelete[] = TEXT("delete");
const TCHAR c_szProperties[] = TEXT("properties");

// IOleCommandTarget
HRESULT CExplorerBand::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    if (pguidCmdGroup == NULL)
    {
        IContextMenu *pcm = NULL;
        HRESULT hr = _QueryContextMenuSelection(&pcm);
        if (SUCCEEDED(hr))
        {
            HMENU hmenu = CreatePopupMenu();
            if (hmenu)
            {
                hr = pcm->QueryContextMenu(hmenu, 0, 0, 255, 0);
                if (SUCCEEDED(hr))
                {
                    UINT ilast = GetMenuItemCount(hmenu);
                    for (UINT ipos=0; ipos < ilast; ipos++)
                    {
                        MENUITEMINFO mii = {0};
                        TCHAR szVerb[40];
                        UINT idCmd;

                        mii.cbSize = SIZEOF(MENUITEMINFO);
                        mii.fMask = MIIM_ID|MIIM_STATE;

                        if (!GetMenuItemInfoWrap(hmenu, ipos, TRUE, &mii)) continue;
                        if (0 != (mii.fState & (MF_GRAYED|MF_DISABLED))) continue;
                        idCmd = mii.wID;

                        hr = ContextMenu_GetCommandStringVerb(pcm, idCmd, szVerb, ARRAYSIZE(szVerb));
                        if (SUCCEEDED(hr))
                        {
                            LPCTSTR szCmd = NULL;

                            for (ULONG cItem = 0; cItem < cCmds; cItem++)
                            {
                                switch (rgCmds[cItem].cmdID)
                                {
                                case OLECMDID_CUT:
                                    szCmd = c_szMove;
                                    break;
                                case OLECMDID_COPY:
                                    szCmd = c_szCopy;
                                    break;
                                case OLECMDID_PASTE:
                                    szCmd = c_szPaste;
                                    break;
                                case OLECMDID_DELETE:
                                    szCmd = c_szDelete;
                                    break;
                                case OLECMDID_PROPERTIES:
                                    szCmd = c_szProperties;
                                    break;
                                }
                                
                                if (StrCmpI(szVerb, szCmd)==0)
                                {
                                    rgCmds[cItem].cmdf = OLECMDF_ENABLED;
                                }
                            }
                        }
                    }
                }
                DestroyMenu(hmenu);
            }
            else
            {
                hr = E_FAIL;
            }
            pcm->Release();
        }
            
        if (SUCCEEDED(hr))
            return hr;
    }

    return CNSCBand::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

HRESULT CExplorerBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL)
    {
        HRESULT hr;
        
        switch(nCmdID) 
        {
        case OLECMDID_CUT:
            hr = _InvokeCommandOnItem(c_szMove);
            break;
        case OLECMDID_COPY:
            hr = _InvokeCommandOnItem(c_szCopy);
            break;
        case OLECMDID_PASTE:
            hr = _InvokeCommandOnItem(c_szPaste);
            break;
        case OLECMDID_DELETE:
            hr = _InvokeCommandOnItem(c_szDelete);
            break;
        case OLECMDID_PROPERTIES:
            hr = _InvokeCommandOnItem(c_szProperties);
            break;
        default:
            hr = E_FAIL;
            break;
        }

        if (SUCCEEDED(hr))
            return hr;
    }

    return CNSCBand::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

// IDockingWindow
HRESULT CExplorerBand::CloseDW(DWORD dw)
{
    _ConnectToBrowser(FALSE);
    return CNSCBand::CloseDW(dw);
}

HRESULT CExplorerBand::ShowDW(BOOL fShow)
{
    return CNSCBand::ShowDW(fShow);
}

// IObjectWithSite
HRESULT CExplorerBand::SetSite(IUnknown* punkSite)
{
    HRESULT hr = CNSCBand::SetSite(punkSite);

    if (punkSite)
        _ConnectToBrowser(TRUE);

    return hr;
}

int _SFCDestroyCB(SFCITEM *psfcItem, void *pv)
{
    psfcItem->psf->Release();
    ILFree(psfcItem->pidl);
    return 1;
}

CExplorerBand::~CExplorerBand()
{
    ILFree(_pidlView);
    if (_pdsaLegacySFC)
    {
        _pdsaLegacySFC->DestroyCallback(_SFCDestroyCB, NULL);
        delete _pdsaLegacySFC;
    }
}

HRESULT CExplorerBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CExplorerBand, IDispatch),
        { 0 },
    };
    
    HRESULT hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr))
        hr = CNSCBand::QueryInterface(riid, ppvObj);
    return hr;
}

DWORD CExplorerBand::_GetEnumFlags()
{
    DWORD dwFlags = SHCONTF_FOLDERS;
    SHELLSTATE ss = {0};
    
    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
    if (ss.fShowAllObjects)
        dwFlags |= SHCONTF_INCLUDEHIDDEN;
        
    return dwFlags;
}

DWORD CExplorerBand::_GetTVExStyle()
{
    DWORD dwExStyle = 0;
    
    if (IsOS(OS_WHISTLERORGREATER) &&
        SHRegGetBoolUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
        TEXT("FriendlyTree"), FALSE, TRUE))
    {
        dwExStyle |= TVS_EX_NOSINGLECOLLAPSE;
    }

    return dwExStyle;
}

DWORD CExplorerBand::_GetTVStyle()
{
    DWORD dwStyle = WS_CHILD | WS_CLIPSIBLINGS | WS_TABSTOP | WS_HSCROLL | TVS_EDITLABELS | TVS_SHOWSELALWAYS;

    if (SHRegGetBoolUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"), TEXT("FriendlyTree"), FALSE, TRUE))
    {
        dwStyle |= TVS_HASBUTTONS | TVS_SINGLEEXPAND | TVS_TRACKSELECT;
    }
    else
    {
        dwStyle |= TVS_HASBUTTONS | TVS_HASLINES;
    }

    // If the parent window is mirrored then the treeview window will inheret the mirroring flag
    // And we need the reading order to be Left to right, which is the right to left in the mirrored mode.
    if (_hwndParent && IS_WINDOW_RTL_MIRRORED(_hwndParent)) 
    {
        // This means left to right reading order because this window will be mirrored.
        _dwStyle |= TVS_RTLREADING;
    }

    return dwStyle;
}

HRESULT CExplorerBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    CExplorerBand * peb = new CExplorerBand();
    if (!peb)
        return E_OUTOFMEMORY;

    if (SUCCEEDED(peb->_Init((LPCITEMIDLIST)CSIDL_DESKTOP)))
    {
        peb->_pns = CNscTree_CreateInstance();
        if (peb->_pns)
        {
            ASSERT(poi);
            peb->_poi = poi;   
            // if you change this cast, fix up CFavBand_CreateInstance
            *ppunk = SAFECAST(peb, IDeskBand *);

            IUnknown_SetSite(peb->_pns, *ppunk);
            peb->_SetNscMode(MODE_NORMAL);

            return S_OK;
        }
    }
    
    peb->Release();

    return E_FAIL;
}

HRESULT CExplorerBand::_ConnectToBrowser(BOOL fConnect)
{
    IBrowserService* pbs;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IBrowserService, &pbs));
    if (SUCCEEDED(hr))
    {
        if (fConnect)
        {
            LPITEMIDLIST pidlTemp = NULL;
            // try to get the pidl the browser is navigated to
            // this usually fails if user just opened Explorer window because navigation is asynchronous
            // so we're not initialized yet
            if (FAILED(pbs->GetPidl(&pidlTemp)))
            {
                IBrowserService2 *pbs2;
                if (SUCCEEDED(pbs->QueryInterface(IID_PPV_ARG(IBrowserService2, &pbs2))))
                {
                    LPCBASEBROWSERDATA pbbd;
                    // our last hope is the pidl browser is navigating to...
                    if (SUCCEEDED(pbs2->GetBaseBrowserData(&pbbd)) && pbbd->_pidlPending)
                    {
                        pidlTemp = ILClone(pbbd->_pidlPending);
                    }
                    pbs2->Release();
                }
            }

            if (pidlTemp)
            {
                LPITEMIDLIST pidl;
                // see if we're dealing with a rooted namespace
                if (SUCCEEDED(_UnwrapRootedPidl(pidlTemp, TRUE, &pidl)))
                {
                    _Init(pidl); //if so, reinitialize ourself with the rooted pidl
                    ILFree(pidl);
                }
                ILFree(pidlTemp);
            }
        }
        
        IConnectionPointContainer* pcpc;
        hr = IUnknown_QueryService(pbs, SID_SWebBrowserApp, IID_PPV_ARG(IConnectionPointContainer, &pcpc));
        // Let's now have the Browser Window give us notification when something happens.
        if (SUCCEEDED(hr))
        {
            hr = ConnectToConnectionPoint(SAFECAST(this, IDispatch*), DIID_DWebBrowserEvents2, fConnect,
                                          pcpc, &_dwcpCookie, NULL);
            pcpc->Release();
        }

        pbs->Release();
    }
    
    ASSERT(SUCCEEDED(hr));
    return hr;
}

HRESULT CExplorerBand::_InitializeNsc()
{
    HRESULT hr = _pns->Initialize(_pidl, _GetEnumFlags(), NSS_DROPTARGET | NSS_BROWSERSELECT);
    if (SUCCEEDED(hr))
        _OnNavigate();

    return hr;
}

HRESULT CExplorerBand::_TranslatePidl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib)
{
    HRESULT hr = E_INVALIDARG;

    if (pidl && ppidlTarget && pulAttrib)
    {
        hr = IEGetAttributesOf(pidl, pulAttrib);
        if (SUCCEEDED(hr))
        {
            hr = SHILClone(pidl, ppidlTarget);
        }
    }
    
    return hr;
}

BOOL CExplorerBand::_ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib)
{
    return ulAttrib & SFGAO_FOLDER;
}

BOOL CExplorerBand::_IsFloppy(LPCITEMIDLIST pidl)
{
    BOOL fRet = FALSE;

    WCHAR szPath[MAX_PATH];
    if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
    {
        if (DRIVE_REMOVABLE == GetDriveType(szPath))
        {
            fRet = (L'A' == szPath[0] || L'B' == szPath[0] || L'a' == szPath[0] || L'b' == szPath[0]);
        }
    }

    return fRet;
}

HRESULT CExplorerBand::Invoke(LPCITEMIDLIST pidl)
{
    HRESULT hr;

    // allow user to navigate to an already selected item if they opened Explorer band in Web browser
    // (because we put selection on the root node but don't navigate away from the web page, if they click
    // on the root we don't navigate there, because selection never changed)
    
    if (!_pidlView)
    {
        _fIgnoreSelection = FALSE;
        hr = OnSelectionChanged(pidl);
    }
    else if (ILIsEqual(pidl, _pidlView) && _IsFloppy(pidl))
    {
        // If the drive is a floppy and the user reselects the drive refresh the contents.  This enables
        // a user to refresh when a floppy is replaced.
        _fFloppyRefresh = TRUE;
        hr = OnSelectionChanged(pidl);
        _fFloppyRefresh = FALSE;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT CExplorerBand::OnSelectionChanged(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_INVALIDARG;

    if (!_fIgnoreSelection)
    {
        if (pidl)
        {
            ULONG ulAttrib = SFGAO_FOLDER;
            LPITEMIDLIST pidlTarget;

            hr = GetNavigateTarget(pidl, &pidlTarget, &ulAttrib);
            if (hr == S_OK)
            {
                if (!_pidlView || _fFloppyRefresh || !ILIsEqual(pidlTarget, _pidlView))
                {
                    hr = CNSCBand::Invoke(pidlTarget);
                    if (SUCCEEDED(hr))
                        _fCanSelect = FALSE;
                    _pns->RightPaneNavigationStarted(pidlTarget);
                    pidlTarget = NULL;  // ownership passed
                }
                ILFree(pidlTarget);
            }
#ifdef DEBUG
            else if (hr == S_FALSE)
            {
                ASSERT(pidlTarget == NULL);
            }
#endif
        }
    }
    else
    {
        _fIgnoreSelection = FALSE; //we ignore only first selection
    }
    
    return hr;
}

void CExplorerBand::_MaybeAddToLegacySFC(LPCITEMIDLIST pidl)
{
    IShellFolder *psf = NULL;
    if (pidl && SUCCEEDED(SHBindToObjectEx(NULL, pidl, NULL, IID_PPV_ARG(IShellFolder, &psf))))
    {
        //
        //  APPCOMPAT LEGACY - Compatibility.  needs the Shell folder cache,  - ZekeL - 4-MAY-99
        //  some apps, specifically WS_FTP and AECO Zip Pro,
        //  rely on having a shellfolder existing in order for them to work.
        //  we pulled the SFC because it wasnt any perf win.
        //
        if (OBJCOMPATF_OTNEEDSSFCACHE & SHGetObjectCompatFlags(psf, NULL))
            _AddToLegacySFC(pidl, psf);
        psf->Release();
    }
}

BOOL CExplorerBand::_IsInSFC(LPCITEMIDLIST pidl)
{
    BOOL bReturn = FALSE;

    ASSERT(_pdsaLegacySFC);
    for (int i=0; i<_pdsaLegacySFC->GetItemCount(); i++)
    {
        SFCITEM *psfcItem = _pdsaLegacySFC->GetItemPtr(i);
        if (ILIsEqual(psfcItem->pidl, pidl))
        {
            bReturn = TRUE;
            break;
        }
    }

    return bReturn;
}

void CExplorerBand::_AddToLegacySFC(LPCITEMIDLIST pidl, IShellFolder *psf)
{
    if (!_pdsaLegacySFC)
    {
        _pdsaLegacySFC = new CDSA<SFCITEM>;
        if (_pdsaLegacySFC && !_pdsaLegacySFC->Create(4))
        {
            delete _pdsaLegacySFC;
            _pdsaLegacySFC = NULL;
        }
    }

    if (_pdsaLegacySFC)
    {
        LPITEMIDLIST pidlCache;
        if (!_IsInSFC(pidl) && SUCCEEDED(SHILClone(pidl, &pidlCache)))
        {
            SFCITEM sfc = {pidlCache, psf};
            if (-1 != _pdsaLegacySFC->InsertItem(0, &sfc))
                psf->AddRef();
            else
                ILFree(pidlCache);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\favorite.h ===
#ifndef _FAVORITE_H_
#define _FAVORITE_H_

STDAPI        AddToFavorites(HWND hwnd, LPCITEMIDLIST pidlCur, LPCTSTR pszTitle, BOOL fDisplayUI, IOleCommandTarget *pCommandTarget, IHTMLDocument2 *pDoc);
STDAPI_(BOOL) DoOrganizeFavDlg(HWND hwnd, LPSTR pszInitDir);
STDAPI_(BOOL) DoOrganizeFavDlgW(HWND hwnd, LPWSTR pszInitDir);

BOOL IsSubscribed(LPWSTR pwzUrl);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\dochost.cpp ===
//
// NOTES:
//
//  This is the code which enables the explorer hosting (being a container)
// a DocObject (a super set of OLE in-place object). In a nut shell, this
// code creates an object (class CDocObjectHost) which can be plugged into
// the explorer's right pane (by supporting IShellView) is also a DocObject
// container (by supporting IOleClientSite, IOleInPlaceSite, ...).
//
//  This CDocObjectHost directly supports following interfaces:
//
// Group 1 (to be plugged in):
//   IShellView, IDropTarget
// Group 2 (to be a Doc site):
//   IOleClientSite, IOleDocumentSite
// Group 3 (to be a View Site)
//   IOleInPlaceSite

//  It also supports following interfaces indirectly via contained object,
// CDocObjectFrame.
//
//  IOleInPlaceFrame, IOleCommandTarget
//
//  The reason we export them separately is because we may need to return
// a different hwnd for GetWindow method. The CDocObjectHost object always
// returns hwnd of the view window, but the CDocObjectFrame returns hwnd
// of the explorer in case the explorer support IOleInPlaceUIWindow.
//
//  It also supports following interface indirectly via contained object,
// CProxyActiveObject.
//
//  IOleInPlaceActiveObject
//
//
//  --------------------------------------------------------
//      Explorer (browser)
//  --------------------------------------------------------
//        ^          |          |
//        |          |          |
//   ISB (+IOIUI)   ISV       IOIAO
//        |          |          |
//        |          V          |
//  ----------------------------V---------------------------
//       CDocObjectHost  CProxyActiveObject CDocObjectFrame
//  ----------------------------------------------^---------
//        ^                |                      |
//        |                |                      |
//  IOCS/IOIPS/IMDS   IO/IOIPO/IMV/IMCT    IOIUI/IOIF/IMCT
//        |                |                      |
//        |                V                      |
//  ---------------------------------------------------------
//       DocObject (Doc + View)
//  ---------------------------------------------------------
//

#include "priv.h"
#include "iehelpid.h"
#include "bindcb.h"
#include "winlist.h"
#include "droptgt.h"
#include <mshtml.h>     // CLSID_HTMLDocument
#include <mshtmcid.h>
#include "resource.h"
#include <htmlhelp.h>
#include <prsht.h>
#include <inetcpl.h>
#include <optary.h>
#include "impexp.h"
#include "impexpwz.h"
#include "thicket.h"
#include "uemapp.h"
#include "iextag.h"   // web folders
#include "browsext.h"
#include "interned.h" // IHTMLPrivateWindow
#include "dochost.h"
#include <mluisupp.h>
#include <varutil.h>
#include "msiehost.h"
#include "shdocfl.h"
#include "mediautil.h"
#include "mediahlpr.h"
#include "privacyui.hpp"
#include "brdispp.h"

// temp, going away once itbar edit stuff moves here
#define  CITIDM_EDITPAGE  10
// Command group for private communication with CITBar
// 67077B95-4F9D-11D0-B884-00AA00B60104
const GUID CGID_PrivCITCommands = { 0x67077B95L, 0x4F9D, 0x11D0, 0xB8, 0x84,
0x00, 0xAA, 0x00, 0xB6, 0x01, 0x04 };
// end temp itbar stuff

// Command group for accessing Bind Context Param set by Trident (Media Bar hook) 
// (copied from mshtml\src\other\include\othrguid.h)
static const GUID CGID_DownloadObjectBindContext = { 0x3050f3df, 0x98b5, 0x11cf, 0xbb, 0x82, 
0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b };

static const GUID CLSID_JITWMP8 = { 0x6BF52A52, 0x394A, 0x11d3, 0xb1, 0x53, 0x00, 0xc0, 0x4f, 0x79, 0xfa, 0xa6 };


#define  DBG_ACCELENTRIES 2
#define  OPT_ACCELENTRIES 1

#define  EXPLORER_EXE TEXT("explorer.exe")
#define  IEXPLORE_EXE TEXT("iexplore.exe")
#define  DBG_ACCELENTRIES_WITH_FILEMENU 6
#define  OPT_ACCELENTRIES_WITH_FILEMENU 5

EXTERN_C const GUID IID_IDocHostObject  = {0x67431840L, 0xC511, 0x11CF, 0x89, 0xA9, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29};
EXTERN_C const GUID IID_IMimeInfo       = {0xF77459A0L, 0xBF9A, 0x11cf, 0xBA, 0x4E, 0x00, 0xC0, 0x4F, 0xD7, 0x08, 0x16};
EXTERN_C const GUID IID_IsPicsBrowser   = {0xF114C2C0L, 0x90BE, 0x11D0, 0x83, 0xB1, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xB2};

#include <shlwapi.h>
#include <ratingsp.h>
#include <ratings.h>

#define DM_ZONECROSSING 0
#define DM_SAVEASHACK   0
#define DM_MIMEMAPPING  0
#define DM_SELFASC      TF_SHDBINDING
#define DM_ACCEPTHEADER 0
#define DM_DEBUGTFRAME  0
#define DM_DOCHOSTUIHANDLER 0
#define DM_PREMERGEDMENU    0
#define DM_FOCUS        0
#define DM_DOCCP        0
#define DM_PICS         0
#define DM_SSL              0

#define KEY_BINDCONTEXTPARAM  _T("BIND_CONTEXT_PARAM")

// media bar entries
#define WZ_RADIO_PROTOCOL   L"vnd.ms.radio:"

enum PlayMimeOptions {PLAYMIME_YES, PLAYMIME_NO, PLAYMIME_YESSAVE, PLAYMIME_NOSAVE};

// WARNING: Never define it in shipping product.
#ifdef DEBUG
// #define TEST_DELAYED_SHOWMSOVIEW
#endif

void CShdAdviseSink_Advise(IBrowserService * pwb, IOleObject* pole);

UINT MayOpenSafeOpenDialog(HWND                hwndOwner,
                           LPCTSTR             pszFileClass,
                           LPCTSTR             pszURL,
                           LPCTSTR             pszCacheName,
                           LPCTSTR             pszDisplay,
                           UINT                uiCP,
                           IUnknown          * punk,
                           IOleCommandTarget * pCmdTarget = NULL,
                           BOOL                fDisableOK = FALSE);

LONG _GetSearchFormatString(DWORD dwIndex, LPTSTR psz, DWORD cbpsz);
DWORD _GetErrorThreshold(DWORD dwError);
BOOL IsRegisteredClient(LPCTSTR pszClient);

HRESULT _GetSearchString(IServiceProvider * psp, VARIANT * pvarSearch);
int     EUIndexFromError(DWORD dwError);
BOOL    IsErrorHandled(DWORD dwError);
HRESULT _GetSearchInfo(IServiceProvider * psp,
                       LPDWORD   pdwIndex,
                       LPBOOL    pfAllowSearch,
                       LPBOOL    pfContinueSearch,
                       LPBOOL    pfSentToEngine,
                       VARIANT * pvarUrl);

STDAPI _URLMONMonikerFromPidl(LPCITEMIDLIST pidl, IMoniker ** ppmk, BOOL * pfFileProtocol);
LRESULT CALLBACK PolicyDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
extern BOOL IsImportExportDisabled(void);

// macros
#define DO_SEARCH_ON_STATUSCODE(x) ((x == 0) || (x == HTTP_STATUS_BAD_GATEWAY) || (x == HTTP_STATUS_GATEWAY_TIMEOUT))

// Suite Apps Registry keys
#define NEW_MAIL_DEF_KEY            TEXT("Mail")
#define NEW_NEWS_DEF_KEY            TEXT("News")
#define NEW_CONTACTS_DEF_KEY        TEXT("Contacts")
#define NEW_CALL_DEF_KEY            TEXT("Internet Call")
#define NEW_APPOINTMENT_DEF_KEY     TEXT("Appointment")
#define NEW_MEETING_DEF_KEY         TEXT("Meeting")
#define NEW_TASK_DEF_KEY            TEXT("Task")
#define NEW_TASKREQUEST_DEF_KEY     TEXT("Task Request")
#define NEW_JOURNAL_DEF_KEY         TEXT("Journal")
#define NEW_NOTE_DEF_KEY            TEXT("Note")

#ifdef DEBUG
DWORD g_dwPerf = 0;
#endif

// #include "..\shell32\fstreex.h"              // for IDFOLDER
// HACK:
struct IDFOLDERA
{
    WORD    cb;
    BYTE    bFlags;
};
typedef IDFOLDERA* LPIDFOLDERA;

const ITEMIDLIST s_idNull = { {0} };


//
// Icons are globally shared among multiple threads.
//
HICON g_hiconSSL = NULL;
HICON g_hiconFortezza = NULL;
HICON g_hiconOffline = NULL;
HICON g_hiconPrinter = NULL;
HICON g_hiconScriptErr = NULL;
HICON g_hiconPrivacyImpact = NULL;

HICON g_ahiconState[IDI_STATE_LAST-IDI_STATE_FIRST+1] = { NULL };
#define MAX_MIXED_STR_LEN   32

// OpenUIURL is just a wrapper for OpenUI, calling CreateURLMoniker() if the
// caller only has an URL.

extern BOOL __cdecl _FormatMessage(LPCSTR szTemplate, LPSTR szBuf, UINT cchBuf, ...);

#include "asyncrat.h"



#define MAX_STATUS_SIZE 128

//
// Set this flag if we are going to use IHlinkBrowseContext in HLINK.DLL
// #define HLINK_EXTRA
//

// Array of http error codes and file names.
//
extern ErrorUrls c_aErrorUrls[];

#define DM_RECYCLE      DM_TRACE
#define DM_BINDAPPHACK  TF_SHDAPPHACK
#define DM_ADVISE       TF_SHDLIFE
#define DM_APPHACK      DM_WARNING

#define NAVMSG3(psz, x, y)      TraceMsg(0, "shdv NAV::%s %x %x", psz, x, y)
#define PAINTMSG(psz,x)         TraceMsg(0, "shd TR-PAINT::%s %x", psz, x)
#define JMPMSG(psz, psz2)       TraceMsg(0, "shd TR-CDOV::%s %s", psz, psz2)
#define JMPMSG2(psz, x)         TraceMsg(0, "shd TR-CDOV::%s %x", psz, x)
#define DOFMSG(psz)             TraceMsg(0, "shd TR-DOF::%s", psz)
#define DOFMSG2(psz, x)         TraceMsg(0, "shd TR-DOF::%s %x", psz, x)
#define URLMSG(psz)             TraceMsg(TF_SHDBINDING, "shd TR-DOF::%s", psz)
#define URLMSG2(psz, x)         TraceMsg(TF_SHDBINDING, "shd TR-DOF::%s %x", psz, x)
#define URLMSG3(psz, x, y)      TraceMsg(TF_SHDBINDING, "shd TR-DOF::%s %x %x", psz, x, y)
#define OIPSMSG(psz)            TraceMsg(0, "shd TR-OIPS::%s", psz)
#define OIPSMSG3(psz, sz, p)    TraceMsg(0, "shd TR-OIPS::%s %s,%x", psz, sz,p)
#define VIEWMSG(psz)            TraceMsg(0, "sdv TR CDOV::%s", psz)
#define VIEWMSG2(psz,xx)        TraceMsg(0, "sdv TR CDOV::%s %x", psz,xx)
#define OPENMSG(psz)            TraceMsg(TF_SHDBINDING, "shd OPENING %s", psz)
#define OPENMSG2(psz, x)        TraceMsg(TF_SHDBINDING, "shd OPENING %s %x", psz, x)
#define HFRMMSG(psz)            TraceMsg(0, "shd HFRM::%s", psz)
#define HFRMMSG2(psz, x, y)     TraceMsg(0, "shd HFRM::%s %x %x", psz, x, y)
#define MNKMSG(psz, psz2)       TraceMsg(0, "shd MNK::%s (%s)", psz, psz2)
#define CHAINMSG(psz, x)        TraceMsg(0, "shd CHAIN::%s %x", psz, x)
#define SHVMSG(psz, x, y)       TraceMsg(0, "shd SHV::%s %x %x", psz, x, y)
#define HOMEMSG(psz, psz2, x)   TraceMsg(TF_SHDNAVIGATE, "shd HOME::%s %s %x", psz, psz2, x)
#define SAVEMSG(psz, x)         TraceMsg(0, "shd SAVE::%s %x", psz, x)
#define PERFMSG(psz, x)         TraceMsg(TF_SHDPERF, "PERF::%s %d msec", psz, x)

static const TCHAR  szRegKey_SMIEM[] =              TEXT("Software\\Microsoft\\Internet Explorer\\Main");
static const TCHAR  szRegVal_ErrDlgPerErr[] =       TEXT("Error Dlg Displayed On Every Error");
static const TCHAR  szRegVal_ErrDlgDetailsOpen[] =  TEXT("Error Dlg Details Pane Open");

////////////////////////////////////////////////////////////
// ShabbirS (980917) - BugFix# 34259
// Repair menuitem in the Help Menu.

typedef HRESULT (* FIXIEPROC) (BOOL, DWORD);

void RepairIE()
{
    HINSTANCE   hIESetup;
    FIXIEPROC   fpFixIE;

    hIESetup = LoadLibrary(L"IESetup.dll");
    if (hIESetup)
    {
        fpFixIE = (FIXIEPROC) GetProcAddress(hIESetup,"FixIE");
        if (fpFixIE)
        {
            fpFixIE(TRUE,0);
        }
        FreeLibrary(hIESetup);
    }
}


BOOL _IsDesktopItem(CDocObjectHost * pdoh)
{
    BOOL fIsDesktopItem = FALSE;
    IServiceProvider  * psb;

    ASSERT(pdoh);
    //Check if we are a desktop component.
    if (SUCCEEDED(pdoh->QueryService(SID_STopLevelBrowser, IID_IServiceProvider, (void **)&psb)))
    {
        LPTARGETFRAME2  ptgf;
        if (SUCCEEDED(psb->QueryService(IID_ITargetFrame2, IID_ITargetFrame2, (void **)&ptgf)))
        {
            DWORD dwOptions;

            if (SUCCEEDED(ptgf->GetFrameOptions(&dwOptions)))
            {
                //Is this a desktop component?
                if (IsFlagSet(dwOptions, FRAMEOPTIONS_DESKTOP))
                    fIsDesktopItem = TRUE;
            }
            ptgf->Release();
        }
        psb->Release();
    }

    return fIsDesktopItem;
}

BOOL _IsImmediateParentDesktop(CDocObjectHost *pdoh, IServiceProvider *psp)
{
    BOOL    fImmediateParentIsDesktop = FALSE;
    LPTARGETFRAME2  ptgf;

    //First check if this is hosted on desktop.
    if (!_IsDesktopItem(pdoh))
        return FALSE;     //This is not a desktop item. So, the immediate parent can't be desktop!

    //We know that this is a desktop item. Check if the immediate parent is desktop
    // or it is hosted too deep on desktop!
    if (psp && SUCCEEDED(psp->QueryService(IID_ITargetFrame2, IID_ITargetFrame2, (void **)&ptgf)))
    {
        IUnknown *pUnkParent;

        //Get it's immediate parent.
        if(SUCCEEDED(ptgf->GetParentFrame(&pUnkParent)))
        {
            if(pUnkParent)
            {
                //Has a parent. So, the immediate parent can't be desktop!
                pUnkParent->Release();

                fImmediateParentIsDesktop = FALSE;
            }
            else
                fImmediateParentIsDesktop = TRUE; //No parent. Must be a desktop comp.
        }
        ptgf->Release();
    }
    return(fImmediateParentIsDesktop);
}

// Gets the current display name in wide char
//
// If fURL is TRUE, it returns file-URL with file: prefix.
//
HRESULT CDocObjectHost::_GetCurrentPageW(LPOLESTR * ppszDisplayName, BOOL fURL)
{
    HRESULT hres = E_FAIL;
    ASSERT(_pmkCur);

    *ppszDisplayName = NULL;

    if (_pmkCur) {
        IBindCtx* pbc;
        hres = CreateBindCtx(0, &pbc);
        if (SUCCEEDED(hres))
        {
            hres = _pmkCur->GetDisplayName(pbc, NULL, ppszDisplayName);

            //
            //  special handling just for file: urls.
            //
            if (SUCCEEDED(hres) && _fFileProtocol)
            {
                ASSERT(*ppszDisplayName);

                WCHAR szText[MAX_URL_STRING];
                DWORD cchText = SIZECHARS(szText);
                if (!fURL)
                {
                     hres = PathCreateFromUrlW(*ppszDisplayName, szText, &cchText, 0);
                }
                else
                {
                    //  we need this to be in the normalized form of the URL
                    //  for internal usage.  urlmon keeps them in the funny PATHURL style
                    hres = UrlCanonicalizeW(*ppszDisplayName, szText, &cchText, 0);
                }

                if (SUCCEEDED(hres))
                {
                    UINT cchDisplayName = lstrlenW(*ppszDisplayName);

                    if (cchText > cchDisplayName)
                    {
                        //  need to resize
                        CoTaskMemFree(*ppszDisplayName);
                        *ppszDisplayName = (WCHAR *)CoTaskMemAlloc((cchText + 1) * SIZEOF(WCHAR));

                        if (*ppszDisplayName)
                        {
                            //  go ahead and copy it in
                            StrCpyNW(*ppszDisplayName, szText, cchText + 1);
                        }
                        else
                            hres = E_OUTOFMEMORY;
                    }
                    else
                    {
                        StrCpyNW(*ppszDisplayName, szText, cchDisplayName + 1);
                    }
                }
            }
            pbc->Release();
        }
    }

    if (FAILED(hres) && *ppszDisplayName)
    {
        OleFree(*ppszDisplayName);
        *ppszDisplayName = NULL;
    }

    return hres;
}

//
//  We fire NavigateError in one location in DocObjectHost
//  However it is fired from (n) locations in DocHostBsc 
//  so I have extracted the common code
//
void
CDocObjectHost::_FireNavigateErrorHelper(IHTMLWindow2 * pHTMLWindow2,
                                         DWORD          dwStatusCode,
                                         BOOL         * pfCancelAutoSearch,
                                         BSTR           bstrURL /* = NULL */)
{
    ASSERT(!pHTMLWindow2 || !IsBadReadPtr(pHTMLWindow2, sizeof(IHTMLWindow2*)));
    ASSERT(dwStatusCode != 0);
    ASSERT(!IsBadWritePtr(pfCancelAutoSearch, sizeof(BOOL)));
    ASSERT(!bstrURL || !IsBadReadPtr(bstrURL, sizeof(BSTR)));

    if ( ! _pwb )
    {
        TraceMsg( TF_ERROR, "CDocObjectHost::_FireNavigateErrorHelper() - _pwb is NULL!" );
        return;
    }

    ITridentService2 * pTridentSvc2;

    HRESULT hres = _pwb->QueryInterface(IID_ITridentService2, (void**)&pTridentSvc2);

    if (SUCCEEDED(hres))
    {
        LPOLESTR pwzURL        = NULL;
        BSTR     bstrMkURL     = NULL;
        BSTR     bstrPidlURL   = NULL;
        BSTR     bstrFrameName = NULL;

        if (!bstrURL)
        {
            ASSERT(!_pmkCur || !IsBadReadPtr(_pmkCur, sizeof(_pmkCur)));
            ASSERT(!_pbcCur || !IsBadReadPtr(_pbcCur, sizeof(_pbcCur)));

            if (_pmkCur && _pbcCur)
            {
                EVAL(S_OK == _pmkCur->GetDisplayName(_pbcCur, NULL, &pwzURL));
                bstrMkURL = SysAllocString(pwzURL);
            }
            else if (_pidl)
            {
                TCHAR szUrl[MAX_URL_STRING];
                HRESULT hresGDN = IEGetDisplayName(_pidl, szUrl, SHGDN_FORPARSING);
                
                if (SUCCEEDED(hresGDN))
                {
                   bstrPidlURL = SysAllocString(szUrl);
                }
                else
                {
                   bstrPidlURL = SysAllocString(_T(""));
                }
            }
        }

        if (pHTMLWindow2)
            pHTMLWindow2->get_name(&bstrFrameName);

        pTridentSvc2->FireNavigateError(pHTMLWindow2,
                                        bstrURL ? bstrURL : bstrMkURL ? bstrMkURL : bstrPidlURL,
                                        bstrFrameName,
                                        dwStatusCode,
                                        pfCancelAutoSearch);
        pTridentSvc2->Release();

        OleFree(pwzURL);
        SysFreeString(bstrPidlURL);
        SysFreeString(bstrMkURL);
        SysFreeString(bstrFrameName);
    }
}

HRESULT CDocObjectHost::_GetCurrentPage(LPTSTR szBuf, UINT cchMax, BOOL fURL)
{
    szBuf[0] = 0;   // zero out buffer

    WCHAR * pszDisplayName;
    HRESULT hres = _GetCurrentPageW(&pszDisplayName, fURL);

    if (SUCCEEDED(hres))
    {
        StrCpyN(szBuf, pszDisplayName, cchMax);
        OleFree(pszDisplayName);
    }

    return hres;
}

//========================================================================
// CDocObjectHost members
//========================================================================

CDocObjectHost::CDocObjectHost(BOOL fWindowOpen /* = FALSE */) : _cRef(1), _uState(SVUIA_DEACTIVATE)
{
    DllAddRef();
    TraceMsg(TF_SHDLIFE, "ctor CDocObjectHost %x", this);
    TraceMsg(DM_DEBUGTFRAME, "ctor CDocObjectHost %x, %x", this, &_bsc);

    // Initialize proxy objects (which are contained)
    _dof.Initialize(this);
    _xao.Initialize(this);

#ifdef HLINK_EXTRA
    HRESULT hres = HlinkCreateBrowseContext(NULL, IID_IHlinkBrowseContext, (void **)&_pihlbc);
    TraceMsg(0, "sdv TR CDOV::constructor HlinkCreateBrowseContext returned %x", hres);
#endif // HLINK_EXTRA

    ::_RefPicsQueries();    /* we'll free PICS async query list when last dochost is destroyed */

    _dwPicsKeyBase = 1;

    _pScriptErrList = NULL;
    _fScriptErrDlgOpen = FALSE;

    _strPriorityStatusText = NULL;

    _iString = -1;
    _uiCP = CP_ACP;

    _PicsProcBase._pdoh = this;

    VariantInit(&_varUserEnteredUrl);

    _fWindowOpen = fWindowOpen;

    ASSERT(!_fDocCanNavigate);
    ASSERT(!_fPrevDocHost);
}

CDocObjectHost::~CDocObjectHost()
{
    ASSERT(_pole==NULL);    // to catch extra release.
    ASSERT(_psp==NULL);     // to cache extra release.
    ASSERT(_hwnd==NULL);
    ASSERT(_pmsoc==NULL);
    ASSERT(_pmsot==NULL);
    ASSERT(_pmsov==NULL);
    ASSERT(_pcmdMergedMenu==NULL);
    ASSERT(NULL == _pHTMLWindow);
    ASSERT(VT_EMPTY == V_VT(&_varUserEnteredUrl));

    if (_pScriptErrList != NULL)
    {
        _pScriptErrList->Release();
    }

    if (_strPriorityStatusText != NULL)
    {
        SysFreeString(_strPriorityStatusText);
    }

#ifdef HLINK_EXTRA
    ASSERT(_phls == NULL);
    ATOMICRELEASE(_pihlbc);
#endif // HLINK_EXTRA

    ::_ReleasePicsQueries();

    if (    _PicsProcBase._pRootDownload 
        ||  _PicsProcBase._pPicsProcNext) {
        ASSERT(0);  /* need to destroy this earlier to prevent Trident problems */
        _RemoveAllPicsProcessors();
    }

    if (_padvise) {
        _padvise->OnClose();
        ATOMICRELEASE(_padvise);
    }

    if (_pwszRefreshUrl)
        OleFree(_pwszRefreshUrl);

    if (_hmenuBrowser) {
        AssertMsg(0, TEXT("_hmenuBrowser should be NULL!"));
        DestroyMenu(_hmenuBrowser);
    }

    if (_hmenuFrame) {
        DestroyMenu(_hmenuFrame);
    }

    if (_hacc)
    {
        DestroyAcceleratorTable(_hacc);
        _hacc = NULL;
    }

    if (_hinstInetCpl)
        FreeLibrary(_hinstInetCpl);

    if (_ptbStd)
        delete [] _ptbStd;

    if (_pBrowsExt)
    {
        _pBrowsExt->Release();
    }

    ILFree(_pidl);
    _pidl = NULL;

    // Make it sure that View Window is released (and _psb)
    DestroyHostWindow();        // which will call _CloseMsoView and _UnBind

    _ResetOwners();

    TraceMsg(TF_SHDLIFE, "dtor CDocObjectHost %x", this);
    DllRelease();
}


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Dump the menu handles for this docobj.  Optionally
         breaks after dumping handles.

Returns:
Cond:    --
*/
void
CDocObjectHost::_DumpMenus(
    IN LPCTSTR pszMsg,
    IN BOOL    bBreak)
{
    if (IsFlagSet(g_dwDumpFlags, DF_DEBUGMENU))
    {
        ASSERT(pszMsg);

        TraceMsg(TF_ALWAYS, "DocHost: Dumping menus for %#08x %s", (LPVOID)this, pszMsg);
        TraceMsg(TF_ALWAYS, "   _hmenuBrowser = %x, _hmenuSet = %x, _hmenuFrame = %x",
                 _hmenuBrowser, _hmenuSet, _hmenuFrame);
        TraceMsg(TF_ALWAYS, "   _hmenuCur = %x, _hmenuMergedHelp = %x, _hmenuObjHelp = %x",
                 _hmenuCur, _hmenuMergedHelp, _hmenuObjHelp);

        _menulist.Dump(pszMsg);

        if (bBreak && IsFlagSet(g_dwBreakFlags, BF_ONDUMPMENU))
            DebugBreak();
    }
}
#endif

HRESULT CDocObjectHost::QueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CDocObjectHost, IOleInPlaceSite, IOleInPlaceSiteEx),
        QITABENTMULTI(CDocObjectHost, IOleWindow, IOleInPlaceSiteEx),
        QITABENT(CDocObjectHost, IOleClientSite),
        QITABENT(CDocObjectHost, IOleDocumentSite),
        QITABENT(CDocObjectHost, IOleCommandTarget),
        QITABENT(CDocObjectHost, IServiceProvider),
        QITABENT(CDocObjectHost, IViewObject),
        QITABENT(CDocObjectHost, IAdviseSink),
        QITABENT(CDocObjectHost, IDocHostObject),
        QITABENT(CDocObjectHost, IDocHostUIHandler),
        QITABENT(CDocObjectHost, IDocHostUIHandler2),
        QITABENT(CDocObjectHost, IDocHostShowUI),
        QITABENT(CDocObjectHost, IDispatch),
        QITABENT(CDocObjectHost, IPropertyNotifySink),
        QITABENT(CDocObjectHost, IOleControlSite),
        { 0 },
    };

    static const QITAB qit1[] = {
        QITABENT(CDocObjectHost, IOleInPlaceSiteEx),
        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);

    if (hr == S_OK)
        return S_OK;

    if (_pWebOCInPlaceSiteEx)
        return QISearch(this, qit1, riid, ppvObj);

    return hr;
}

void CDocObjectHost::_ResetOwners()
{
    _pszLocation = NULL;
    _uiCP = CP_ACP;

    _ReleasePendingObject();

    ATOMICRELEASE(_psv);
    ATOMICRELEASE(_pmsoctView);
    ATOMICRELEASE(_pdvs);
    ATOMICRELEASE(_psb);
    ATOMICRELEASE(_pwb);
    ATOMICRELEASE(_phf);
    ATOMICRELEASE(_pocthf);
    ATOMICRELEASE(_punkSFHistory);
    ATOMICRELEASE(_pmsoctBrowser);
    ATOMICRELEASE(_psp);
    ATOMICRELEASE(_peds);
    ATOMICRELEASE(_pedsHelper);
    ATOMICRELEASE(_pWebOCUIHandler);
    ATOMICRELEASE(_pWebOCUIHandler2);
    ATOMICRELEASE(_pWebOCShowUI);
    ATOMICRELEASE(_pWebOCInPlaceSiteEx);

    // Release cached OleInPlaceUIWindow of the browser
    ATOMICRELEASE(_pipu);

    // Tell embedded CDocHostUIHandler object to release its references on us.
    _dhUIHandler.SetSite(NULL);
}



ULONG CDocObjectHost::AddRef()
{
    _cRef++;
    TraceMsg(TF_SHDREF, "CDocObjectHost(%x)::AddRef called, new _cRef=%d", this, _cRef);
    return _cRef;
}

ULONG CDocObjectHost::Release()
{
    _cRef--;
    TraceMsg(TF_SHDREF, "CDocObjectHost(%x)::Release called, new _cRef=%d", this, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

// cut & paste from browseui\itbar.cpp
int RemoveHiddenButtons(TBBUTTON* ptbn, int iCount)
{
    int i;
    int iTotal = 0;
    TBBUTTON* ptbn1 = ptbn;
    for (i = 0; i < iCount; i++, ptbn1++) {
        if (!(ptbn1->fsState & TBSTATE_HIDDEN)) {
            if (ptbn1 != ptbn) {
                *ptbn = *ptbn1;
            }
            ptbn++;
            iTotal++;
        }
    }
    return iTotal;
}

// We use two different image lists in the TBBUTTON array.  The bitmaps for browser-specific buttons
// cut/copy/paste have been moved to shdocvw, and are therefore obtained from a second image list.
// MAKELONG(0,1) accesses the first image from this second list.  Without a call to MAKELONG there is
// a 0 in the upper integer, thereby referencing the first list by default.
static const TBBUTTON c_tbStd[] = {
    {10, DVIDM_SHOWTOOLS,       TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 10},
    {13, DVIDM_MAILNEWS,        TBSTATE_ENABLED, BTNS_WHOLEDROPDOWN, {0,0}, 0, 13 },
    { 8, DVIDM_FONTS,           TBSTATE_ENABLED, BTNS_WHOLEDROPDOWN, {0,0}, 0, 8 },
    { 7, DVIDM_PRINT,           TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 7 },
    { 9, DVIDM_EDITPAGE,        TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 9 },
    {15, DVIDM_DISCUSSIONS,     TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 15 },
    {MAKELONG(0,1), DVIDM_CUT,             TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 0 },
    {MAKELONG(1,1), DVIDM_COPY,            TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 0 },
    {MAKELONG(2,1), DVIDM_PASTE,           TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 0 },
    {MAKELONG(3,1), DVIDM_ENCODING,        TBSTATE_ENABLED, BTNS_WHOLEDROPDOWN, {0,0}, 0, 0 },
    {MAKELONG(5,1), DVIDM_PRINTPREVIEW,    TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 0 },
};

// c_tbStd and c_rest need to match exactly
static const BROWSER_RESTRICTIONS c_rest[] = {
    REST_BTN_TOOLS,
    REST_BTN_MAIL,
    REST_BTN_FONTS,
    REST_BTN_PRINT,
    REST_BTN_EDIT,
    REST_BTN_DISCUSSIONS,
    REST_BTN_CUT,
    REST_BTN_COPY,
    REST_BTN_PASTE,
    REST_BTN_ENCODING,
    REST_BTN_PRINTPREVIEW,
};

#ifdef DEBUG
void _AssertRestrictionOrderIsCorrect()
{
    COMPILETIME_ASSERT(ARRAYSIZE(c_tbStd) == ARRAYSIZE(c_rest));

    for (UINT i = 0; i < ARRAYSIZE(c_tbStd); i++)
    {
        // If any of these rip, it means that c_rest and c_tbStd have
        // gotten out of sync.  Need to fix up c_rest to match c_tbStd.
        switch (c_tbStd[i].idCommand)
        {
            case DVIDM_SHOWTOOLS:       ASSERT(c_rest[i] == REST_BTN_TOOLS);        break;
            case DVIDM_MAILNEWS:        ASSERT(c_rest[i] == REST_BTN_MAIL);         break;
            case DVIDM_FONTS:           ASSERT(c_rest[i] == REST_BTN_FONTS);        break;
            case DVIDM_PRINT:           ASSERT(c_rest[i] == REST_BTN_PRINT);        break;
            case DVIDM_EDITPAGE:        ASSERT(c_rest[i] == REST_BTN_EDIT);         break;
            case DVIDM_DISCUSSIONS:     ASSERT(c_rest[i] == REST_BTN_DISCUSSIONS);  break;
            case DVIDM_CUT:             ASSERT(c_rest[i] == REST_BTN_CUT);          break;
            case DVIDM_COPY:            ASSERT(c_rest[i] == REST_BTN_COPY);         break;
            case DVIDM_PASTE:           ASSERT(c_rest[i] == REST_BTN_PASTE);        break;
            case DVIDM_ENCODING:        ASSERT(c_rest[i] == REST_BTN_ENCODING);     break;
            case DVIDM_PRINTPREVIEW:    ASSERT(c_rest[i] == REST_BTN_PRINTPREVIEW); break;
            default:                    ASSERT(0);                                  break;
        }
    }
}
#endif

BYTE _BtnStateFromRestIfAvailable(BOOL fAvailable, DWORD dwRest)
{
    if (fAvailable)
        return SHBtnStateFromRestriction(dwRest, TBSTATE_ENABLED);

    return TBSTATE_HIDDEN;
}

BOOL CDocObjectHost::_ToolsButtonAvailable()
{
    OLECMD rgcmd = { OLECMDID_HIDETOOLBARS, 0 };

    if (_pmsoctBrowser)
        _pmsoctBrowser->QueryStatus(NULL, 1, &rgcmd, NULL);

    return (rgcmd.cmdf & OLECMDF_SUPPORTED);
}

__inline BYTE CDocObjectHost::_DefToolsButtonState(DWORD dwRest)
{
    BOOL fAvailable = _ToolsButtonAvailable();
    return _BtnStateFromRestIfAvailable(fAvailable, dwRest);
}

static const TCHAR c_szRegKeyCoolbar[] = TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar");

BYTE CDocObjectHost::_DefFontsButtonState(DWORD dwRest)
{
    BYTE fsState = TBSTATE_ENABLED;

    // default to whatever the IE4 reg key specifies,
    // or FALSE if reg key not present (clean install)
    if (!SHRegGetBoolUSValue(c_szRegKeyCoolbar, TEXT("ShowFonts"), FALSE, FALSE))
        fsState |= TBSTATE_HIDDEN;

    return SHBtnStateFromRestriction(dwRest, fsState);
}

DWORD CDocObjectHost::_DiscussionsButtonCmdf()
{
    if (SHRegGetBoolUSValue(c_szRegKeyCoolbar,
                                TEXT("ShowDiscussionButton"), FALSE, TRUE) &&
       _pmsoctBrowser) {

        OLECMD rgcmds[] = {
            { SBCMDID_DISCUSSIONBAND, 0 },
        };
        static const int buttonsInternal[] = {
            DVIDM_DISCUSSIONS,
        };
        _pmsoctBrowser->QueryStatus(&CGID_Explorer, ARRAYSIZE(rgcmds), rgcmds, NULL);
        return rgcmds[0].cmdf;
    }

    return 0;
}

__inline BOOL CDocObjectHost::_DiscussionsButtonAvailable()
{
    return (_DiscussionsButtonCmdf() & OLECMDF_SUPPORTED);
}

__inline BYTE CDocObjectHost::_DefDiscussionsButtonState(DWORD dwRest)
{
    BOOL fAvailable = _DiscussionsButtonAvailable();
    return _BtnStateFromRestIfAvailable(fAvailable, dwRest);
}

BOOL CDocObjectHost::_MailButtonAvailable()
{
    OLECMD rgcmdMailFavs[] = { { SBCMDID_DOMAILMENU, 0} };

    if (_pmsoctBrowser)
        _pmsoctBrowser->QueryStatus(&CGID_Explorer, ARRAYSIZE(rgcmdMailFavs), rgcmdMailFavs, NULL);

    if (rgcmdMailFavs[0].cmdf & OLECMDF_ENABLED)
        return TRUE;

    return FALSE;
}

__inline BYTE CDocObjectHost::_DefMailButtonState(DWORD dwRest)
{
    BOOL fAvailable = _MailButtonAvailable();
    return _BtnStateFromRestIfAvailable(fAvailable, dwRest);
}


// We default the edit button to visible if there is an html editer registered
BOOL CDocObjectHost::_EditButtonAvailable()
{
    DWORD cchVerb;
    return (SUCCEEDED(AssocQueryString(0, ASSOCSTR_COMMAND, TEXT(".htm"), TEXT("edit"), NULL, &cchVerb)) ||
        SUCCEEDED(AssocQueryString(0, ASSOCSTR_COMMAND, TEXT("htmlfile"), TEXT("edit"), NULL, &cchVerb)));
}

__inline BYTE CDocObjectHost::_DefEditButtonState(DWORD dwRest)
{
    BYTE fsState;

    if (_EditButtonAvailable())
        fsState = TBSTATE_ENABLED;
    else
        fsState = TBSTATE_HIDDEN;

    return SHBtnStateFromRestriction(dwRest, fsState);
}


void CDocObjectHost::_MarkDefaultButtons(PTBBUTTON tbStd)
{
    // We're assuming tbStd is the same size as c_tbStd

#ifdef DEBUG
    _AssertRestrictionOrderIsCorrect();
#endif

    DWORD dwRest[ARRAYSIZE(c_tbStd)];

    BOOL fCheckRestriction = SHRestricted2(REST_SPECIFYDEFAULTBUTTONS, NULL, 0);
    for (UINT i = 0; i < ARRAYSIZE(c_rest); i++) {
        if (fCheckRestriction)
            dwRest[i] = SHRestricted2(c_rest[i], NULL, 0);
        else
            dwRest[i] = RESTOPT_BTN_STATE_DEFAULT;
    }

    // We want the Cut, Copy, Paste buttons to default off of the toolbar
    // (but available in the view-toolbars-customize dialog)
    // We set the state of the buttons to TBSTATE_HIDDEN here, but leave them alone
    // in ETCMDID_GETBUTTONS so that they appear in the customize dialog.

    ASSERT(tbStd[6].idCommand == DVIDM_CUT);
    ASSERT(tbStd[7].idCommand == DVIDM_COPY);
    ASSERT(tbStd[8].idCommand == DVIDM_PASTE);
    ASSERT(tbStd[9].idCommand == DVIDM_ENCODING);
    ASSERT(tbStd[10].idCommand == DVIDM_PRINTPREVIEW);

    for (i = 6; i <= 10; i++)
        tbStd[i].fsState = SHBtnStateFromRestriction(dwRest[i], tbStd[i].fsState | TBSTATE_HIDDEN);

    ASSERT(tbStd[0].idCommand == DVIDM_SHOWTOOLS);
    tbStd[0].fsState = _DefToolsButtonState(dwRest[0]);

    ASSERT(tbStd[1].idCommand == DVIDM_MAILNEWS);
    tbStd[1].fsState = _DefMailButtonState(dwRest[1]);

    ASSERT(tbStd[2].idCommand == DVIDM_FONTS);
    tbStd[2].fsState = _DefFontsButtonState(dwRest[2]);

    ASSERT(tbStd[3].idCommand == DVIDM_PRINT);
    tbStd[3].fsState = SHBtnStateFromRestriction(dwRest[3], TBSTATE_ENABLED);

    ASSERT(tbStd[4].idCommand == DVIDM_EDITPAGE);
    tbStd[4].fsState = _DefEditButtonState(dwRest[4]);

    ASSERT(tbStd[5].idCommand == DVIDM_DISCUSSIONS);
    tbStd[5].fsState = _DefDiscussionsButtonState(dwRest[5]);
}

const GUID* CDocObjectHost::_GetButtonCommandGroup()
{
    if (_ToolsButtonAvailable())
        return &CLSID_MSOButtons;
    else
        return &CLSID_InternetButtons;
}

void CDocObjectHost::_AddButtons(BOOL fForceReload)
{
    if (!_pBrowsExt)
        return;

    IExplorerToolbar* pxtb;
    if (_psp && SUCCEEDED(_psp->QueryService(SID_SExplorerToolbar, IID_IExplorerToolbar, (void **)&pxtb)))
    {
        const GUID* pguid = _GetButtonCommandGroup();

        HRESULT hr = pxtb->SetCommandTarget((IOleCommandTarget*)this, pguid, 0);

        if (!fForceReload && hr == S_FALSE) {
            // Another dochost already merged the buttons into the toolbar under the
            // same command group, so don't bother re-merging.  We just need to initialize
            // _iString, since we're skipping the call to _pBrowsExt->InitButtons below.
            VARIANT var = { VT_I4 };
            IUnknown_Exec(_pBrowsExt, &CLSID_PrivBrowsExtCommands, PBEC_GETSTRINGINDEX, 0, &var, NULL);   // should always succeed
            _iString = var.lVal;
        } else {

            UINT nNumExtButtons = 0;

            _pBrowsExt->GetNumButtons(&nNumExtButtons);

            int nNumButtons = nNumExtButtons + ARRAYSIZE(c_tbStd);

            // GetTBArray insures that tbStd != NULL, so we don't need that check here
            TBBUTTON    *tbStd = new TBBUTTON[nNumButtons];

            if (tbStd != NULL)
            {
                memcpy(tbStd, c_tbStd, SIZEOF(TBBUTTON) * ARRAYSIZE(c_tbStd));

                UINT iStringIndex = (UINT)-1;  // result of adding the string buffer to the toolbar string list
                HRESULT hr = _pBrowsExt->InitButtons(pxtb, &iStringIndex, pguid);

                ASSERT(tbStd[6].idCommand == DVIDM_CUT);
                ASSERT(tbStd[7].idCommand == DVIDM_COPY);
                ASSERT(tbStd[8].idCommand == DVIDM_PASTE);
                ASSERT(tbStd[9].idCommand == DVIDM_ENCODING);
                ASSERT(tbStd[10].idCommand == DVIDM_PRINTPREVIEW);

                if (SUCCEEDED(hr) && iStringIndex != -1)
                {
                    tbStd[6].iString = iStringIndex;
                    tbStd[7].iString = iStringIndex + 1;
                    tbStd[8].iString = iStringIndex + 2;
                    tbStd[9].iString = iStringIndex + 3;
                    tbStd[10].iString = iStringIndex+ 4;
                    _iString = (int)iStringIndex;
                }
                else
                {
                    tbStd[6].iString = tbStd[7].iString = tbStd[8].iString = tbStd[9].iString = tbStd[10].iString = -1;
                    _iString = -1;
                }

                // Add custom buttons to the toolbar array.  We pass in the nNumButtons
                // as a *sanity check*...
                _pBrowsExt->GetButtons(&tbStd[ARRAYSIZE(c_tbStd)], nNumExtButtons, TRUE);

                _MarkDefaultButtons(tbStd);

                nNumButtons = RemoveHiddenButtons(tbStd, nNumButtons);

                pxtb->AddButtons(pguid, nNumButtons, tbStd);

                delete [] tbStd;
            }
        }

        pxtb->Release();
    }
}

HRESULT CDocObjectHost::UIActivate(UINT uState, BOOL fPrevViewIsDocView)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::UIActivate called %d->%d (this=%x)",
             _uState, uState, this);

    HRESULT hres = S_OK;
    UINT uStatePrev = _uState;

    // We are supposed to update the menu
    if (uState != _uState)
    {
        // There was a state transition.
        //
        _uState = uState;

        // If the new state is SVUIA_DEACTIVATE
        //
        if (_uState == SVUIA_DEACTIVATE)
        {
            //
            //  When we are deactivating (we are navigating away)
            // we UIDeactivate the current MsoView.
            //

            _UIDeactivateMsoView();

            _IPDeactivateMsoView(_pmsov);
            _DestroyBrowserMenu();
        }
        else if (_uState == SVUIA_INPLACEACTIVATE && uStatePrev == SVUIA_ACTIVATE_FOCUS)
        {
            // Transition from SVUIA_ACTIVATE_FOCUS->SVUIA_INPLACEACTIVATE
            //
            //  If we set this DONT_UIDEACTIVATE, then we stop calling
            //  UIActivate(FALSE) when a DocObject in a frameset looses a focus.
            //  It will solve some problems with Office apps (Excel, PPT), which
            //  InPlaceDeactivate when we call UIActivate(FALSE). We want to treat
            //  it as a bug, but unfortunately DocObject spec says that's OK.
            //
            //   Putting this work around, however, slightly confuses MSHTML
            //  (both classic and Trident). Once it's UIActivated, it keep
            //  thinking that it's UIActivated and never calls onUIActivate.
            //  Until we figure out what's the right implementation,
            //  we can't turn this on.             (SatoNa -- 11/04/96).
            //
            _GetAppHack(); // get if we don't have it yet.
            if (_dwAppHack & BROWSERFLAG_DONTUIDEACTIVATE) {
                //
                // HACK: We are supposed to just call UIActivate(FALSE) when
                //  another DocObject (in the case of a frame set) became
                //  UIActivated. Excel/PPT, however, InplaceDeactivate instead.
                //  To work around, SriniK suggested us to call
                //  OnDocWindowActivate(FALSE). (SatoNa)
                //
                IOleInPlaceActiveObject* piact = _xao.GetObject(); // no AddRef
                TraceMsg(TF_SHDAPPHACK, "DOH::UIActivate APPHACK calling %x->OnDocWindowActivate (this=%x)",
                         piact, this);
                if (piact)
                {
                    piact->OnDocWindowActivate(FALSE);
                }
            }
            else if (!(_dwAppHack & BROWSERFLAG_DONTDEACTIVATEMSOVIEW))
            {
                // HACK: In Excel, if we deactiveate the view, it never gets focus again
                // fix for the bug: #20906
                // Also, we don't want to deactivate the view 
                // if the document is currently navigating.
                //
                _UIDeactivateMsoView();
            }
            else
            {
                // We're transitioning from SVUIA_ACTIVATE_FOCUS->SVUIA_INPLACEACTIVATE
                // and BROWSERFLAG_DONTDEACTIVATEMSOVIEW is set.
                // call the object's IOleInPlactActiveObject::OnFrameWindowActivate(FALSE);
                IOleInPlaceActiveObject* piact = _xao.GetObject(); // no AddRef
                if (piact)
                {
                    piact->OnFrameWindowActivate(FALSE);
                }
            }
        }
        else if (uStatePrev == SVUIA_DEACTIVATE)
        {

            //
            //  If UIActivate is called either
            // (1) when the binding is pending; _bsc._pbc!=NULL
            // (2) when the async binding is done; _bsc._pole!=NULL
            //
            SHVMSG("UIActivate about to call _Bind", _bsc._pbc, NULL);
            if (_pole == NULL && _bsc._pbc)
            {
                ASSERT(_pmkCur);
                IBindCtx* pbc = _bsc._pbc;
                pbc->AddRef();
                HRESULT hresT = _BindSync(_pmkCur, _bsc._pbc, _bsc._psvPrev);
                pbc->Release();
                ASSERT(_bsc._pbc==NULL);
                ASSERT(_bsc._psvPrev==NULL);
                ASSERT(_bsc._pbscChained==NULL);
            }

            hres = _EnsureActivateMsoView();

            // We are being asked to UI activate and we are currently deactivated.  Show
            // the view now.
            if (SUCCEEDED(hres) && DocCanHandleNavigation())
            {
                _ShowMsoView();
            }

            _AddButtons(FALSE);

        }
        else
        {
            // opening a new document for 1st time (to UIActive or IPActive)
            goto GoSetFocus;
        }
    }
    else
    {
        TraceMsg(TF_SHDUIACTIVATE, "DOH:::UIActivate -- same uState (%x)", _uState);
GoSetFocus:
        if ((_uState == SVUIA_ACTIVATE_FOCUS)) {
            // see if object is already UIActive.
            if (_ActiveHwnd()) {
                // if it is, we have an hwnd and all we need to do
                // is SetFocus (for compatibility w/ weird guys...)

                if ( IsChildOrSelf( _ActiveHwnd(), GetFocus() ) != S_OK )
                {
                    TraceMsg(TF_SHDUIACTIVATE, "DOH:::UIActivate -- calling SetFocus(%x)", _ActiveHwnd());
                    SetFocus(_ActiveHwnd());
                }
            }
            else {
                // we're in the OC, and it's IPActive not UIActive.
                // (either that or it's the very 1st time for the main view).
                // NOTE: Due to CBaseBrowser code that defers SVUIA_ACTIVATE_FOCUS until
                // application is active, we can have a top level docobject go
                // SVUIA_INPLACEACTIVE and then on activation of the window,
                // we transition to SVUIA_ACTIVATE_FOCUS, thus never UIActivating
                // the docobject (cf: BUG 62138)

                hres = _DoVerbHelper(FALSE);
            }
        }
    }
    if ((_uState == SVUIA_INPLACEACTIVATE) || (_uState  == SVUIA_ACTIVATE_FOCUS))
        _PlaceProgressBar();

    return hres;
}

//***   _DoVerbHelper -- DoVerb w/ various hacks
// NOTES
//  do comments in _OnSetFocus apply here?
HRESULT CDocObjectHost::_DoVerbHelper(BOOL fOC)
{
    HRESULT hres = E_FAIL;
    LONG iVerb = OLEIVERB_SHOW;
    MSG msg;
    LPMSG pmsg = NULL;

    if (_pole)
    {
        if (_uState == SVUIA_INPLACEACTIVATE) 
        {
            iVerb = OLEIVERB_INPLACEACTIVATE;
        }
        else if ((_uState == SVUIA_ACTIVATE_FOCUS)) 
        {
            iVerb = OLEIVERB_UIACTIVATE;
        }
        else 
        {
            TraceMsg(TF_ERROR, "DOC::_DoVerbHelper untested (and probably the wrong iVerb mapping)");
        }

        if (_pedsHelper)
        {
            if (SUCCEEDED(_pedsHelper->GetDoVerbMSG(&msg)))
            {
                pmsg = &msg;
            }
        }
        hres = _pole->DoVerb(iVerb, pmsg, this, (UINT)-1, _hwnd, &_rcView);
        if (hres == OLEOBJ_E_INVALIDVERB && iVerb == OLEIVERB_INPLACEACTIVATE) 
        {
            hres = _pole->DoVerb(OLEIVERB_SHOW, pmsg, this, (UINT)-1, _hwnd, &_rcView);
        }

        if (FAILED(hres)) 
        {
            TraceMsg(DM_ERROR, "DOC::_DoVerbHelper _pole->DoVerb ##FAILED## %x", hres);
        }
    }

    return hres;
}

void CDocObjectHost::_IPDeactivateMsoView(IOleDocumentView* pmsov)
{
    IInitViewLinkedWebOC* pInitViewLinkedWebOC;

    BOOL fIsViewLinked = FALSE;

    TraceMsg(TF_SHDUIACTIVATE, "DOH::_IPDeactivateMsoView called (this==%x)", this);

    if (pmsov)
    {   
        // Because of NativeFrames, in the viewlinked WebOC case, the ReleaseShellView does not 
        // Deactivate the DocumentView. The sequence of these events is critical to Application 
        // Compatibility. So we force the show before the InPlaceDeactivate if we have a viewlinked WebOC.
        ASSERT(_pwb);

        HRESULT hres = E_FAIL;

        if ( _pwb )
        {
            hres = _pwb->QueryInterface(IID_IInitViewLinkedWebOC, (void**)&pInitViewLinkedWebOC);
        }

        if (SUCCEEDED(hres))
        {
            hres = pInitViewLinkedWebOC->IsViewLinkedWebOC(&fIsViewLinked);
            
            if (SUCCEEDED(hres) && fIsViewLinked)
            {
                pmsov->Show(FALSE);
            }

            pInitViewLinkedWebOC->Release();
        }

        IOleInPlaceObject* pipo = NULL;
        HRESULT hresT = _pole->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo);
        if (SUCCEEDED(hresT))
        {
            pipo->InPlaceDeactivate();
            pipo->Release();
        }

        if (!fIsViewLinked) 
            pmsov->Show(FALSE);     
    }
}

void CDocObjectHost::_UIDeactivateMsoView(void)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::_UIDeactivateMsoView called (this==%x)", this);

    if (_pmsov)
    {
        _pmsov->UIActivate(FALSE);
    }
}

//
// Hide the office toolbar
//
void CDocObjectHost::_HideOfficeToolbars(void)
{
    if (_pmsot) {
        OLECMD rgcmd = { OLECMDID_HIDETOOLBARS, 0 };

        _pmsot->QueryStatus(NULL, 1, &rgcmd, NULL);

        // LATCHED means hidden
        rgcmd.cmdf &= (OLECMDF_SUPPORTED | OLECMDF_LATCHED);

        // If it's supported and visible (not LATCHED), toggle it.
        if (rgcmd.cmdf == OLECMDF_SUPPORTED) {
            _pmsot->Exec(NULL, OLECMDID_HIDETOOLBARS, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
        }
    }
}

void CDocObjectHost::_ShowMsoView(void)
{
    HRESULT hres;

    //
    // HACK: Word97 UIDeactivate when we call SetInPlaceSite even with the
    //  same in-place site.
    //
    IOleInPlaceSite* psite;
    hres = _pmsov->GetInPlaceSite(&psite);
    if (SUCCEEDED(hres) && psite) {
        if (psite!=this) {
            _pmsov->SetInPlaceSite(this);
        } else {
            TraceMsg(TF_SHDAPPHACK, "DOH::_ShowMsoView not calling SetInPlaceSite because it's already set");
        }
        psite->Release();

    } else {
        _pmsov->SetInPlaceSite(this);
    }

    GetClientRect(_hwnd, &_rcView);

    if ((_uState != SVUIA_INPLACEACTIVATE)      
        || !(_dwAppHack & BROWSERFLAG_MSHTML)  //   or if it's not Trident (office apps expect this call)
        )
    {
        // Trident is sending progress changed messages here -- and causing Compuserve a problem.
        // Flag the fact that we're UIActivating them, and suppress forwarding ProgressChanged
        // messages to our container when this flag is true.  (IE v4.1 bug 54787)
        //
        _fUIActivatingView = TRUE;
        _pmsov->UIActivate(TRUE);
        _fUIActivatingView = FALSE;
    }

    //
    // HACK:
    //
    //  We call _HideOfficeToolbars when our OnUIActivate is called.
    // SriniK suggested us to do it in order to avoid flashing.
    // It works well with Excel (3404), but does not work with Word.
    // Word does not hide its toolbars correctly. To work around that
    // bug, we call _HideofficeToolbars here again.
    //
    _HideOfficeToolbars();

    hres = _pmsov->SetRect(&_rcView);

    if (FAILED(hres)) {
        TraceMsg(DM_ERROR, "DOC::_ShowMsoView _pmsov->SetRect ##FAILED## %x", hres);
    }

    if (FAILED(hres) && _uState == SVUIA_INPLACEACTIVATE) {
        TraceMsg(TF_SHDAPPHACK, "APPHACK# DOH::_ShowMsoView calling UIActivate");
        // HACKHACK: for word.  they refuse to show if they aren't UIActivated.
        // if the setrect fails, and we didn't do a UIActivate, do it now.
        _fDontInplaceActivate = TRUE;
        TraceMsg(TF_SHDAPPHACK, "HACK: CDOH::_ShowMsoView calling UIActive(TRUE) to work around Word bug");
        _pmsov->UIActivate(TRUE);
        _pmsov->SetRect(&_rcView);
    }

    // This is the other case where Trident sends Progress changed messages.
    //
    _fUIActivatingView = TRUE;
    hres = _pmsov->Show(TRUE);
    _fUIActivatingView = FALSE;

    if (FAILED(hres)) {
        TraceMsg(DM_ERROR, "DOH::_ShowMsoView _pmsov->Show ##FAILED## %x", hres);
    }

    _fDrawBackground = FALSE;   /* now that we've shown the object, no need to paint our own background */
}

HRESULT CDocObjectHost::_ActivateMsoView()
{
    _EnableModeless(FALSE);

#ifdef DEBUG
    PERFMSG(TEXT("_ActivateMsoView"), GetCurrentTime() - g_dwPerf);
    g_dwPerf = GetCurrentTime();
#endif

    HRESULT hres = NOERROR;

    if (!DocCanHandleNavigation() || _fWindowOpen)    
    {
        if (!_phls)
        {
            _pole->QueryInterface(IID_IHlinkSource, (void **)&_phls);
        }

        if (_phls && !_fIsHistoricalObject)
        {
            //
            // Special test case for IHlinkFrame marshaling.
            //

            hres = _phls->Navigate(0, _pszLocation);
    
            //
            // If this is one of our internal error pages, we can ignore the
            // failure on the bogus location.  In this case pwszLocation will
            // be the original url that failed preceeded with a '#'.
            //
            LPOLESTR pwszUrl;

            if (FAILED(hres) && SUCCEEDED(_GetCurrentPageW(&pwszUrl, TRUE)))
            {
                // if it begins with res: it may be our erro page
                if (pwszUrl[0] == L'r' && pwszUrl[1] == L'e' && IsErrorUrl(pwszUrl))
                {
                    // It's our internal error page, so ignore the error
                    hres = S_OK;
                }

                OleFree(pwszUrl);
            }

#ifdef DEBUG
            if (!_fWindowOpen && FAILED(hres))
            {
                TraceMsg(DM_ERROR, "DOC::_ActivateMsoView _phls->Navigate(%s) ##FAILED## %x",
                         _pszLocation ? _pszLocation : TEXT(""), hres);
            }
#endif
        }
        else
        {
            // todo: use _DoVerbHelper? (but careful! ACT_FOCUS different)
            LONG iVerb = OLEIVERB_SHOW;
            MSG msg;
            LPMSG pmsg = NULL;

            if (_uState == SVUIA_INPLACEACTIVATE) {
                iVerb = OLEIVERB_INPLACEACTIVATE;
            }
            if (_pedsHelper)
            {
                if (SUCCEEDED(_pedsHelper->GetDoVerbMSG(&msg)))
                {
                    pmsg = &msg;
                }
            }
            hres = _pole->DoVerb(iVerb, pmsg, this, (UINT)-1, _hwnd, &_rcView);
            if (hres == OLEOBJ_E_INVALIDVERB && iVerb == OLEIVERB_INPLACEACTIVATE)
                hres = _pole->DoVerb(OLEIVERB_SHOW, pmsg, this, (UINT)-1, _hwnd, &_rcView);

            if (FAILED(hres)) {
                TraceMsg(DM_ERROR, "DOC::_ActivateMsoView _pole->DoVerb ##FAILED## %x", hres);
            }
        }
    }

    _fPrevDocHost = TRUE;

    // the doc is activated
    if (SUCCEEDED(hres))
    {
        _ReleasePendingObject();

        if (_fHaveParentSite)
        {
            _HideOfficeToolbars();
        }
    }

    _EnableModeless(TRUE);

    return hres;
}

void CDocObjectHost::OnInitialUpdate()
{
    _fWindowOpen = FALSE;

    ResetRefreshUrl();
}

void CDocObjectHost::ResetRefreshUrl()
{
    if (_pwszRefreshUrl)
    {
        OleFree(_pwszRefreshUrl);
        _pwszRefreshUrl = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_NavigateDocument
//
//  Synopsis : Navigates the document to the given URL
//
//+---------------------------------------------------------------------------

HRESULT
CDocObjectHost::_NavigateDocument(BSTR bstrUrl, BSTR bstrLocation)
{
    HRESULT hres = E_FAIL;
    DWORD   dwFlags = 0;
    IHTMLPrivateWindow * pPrivWindow  = NULL;

    ASSERT(_fDocCanNavigate && (_fPrevDocHost || _uState == SVUIA_DEACTIVATE));
    ASSERT(_pHTMLWindow);

    // Waiting for the real navigate call so we don't get duplicate events
    
    if (_pwb)
    {
        _pwb->SetNavigateState(BNS_NORMAL);
    }
    

    if (_pHTMLWindow)  // Stress fix
    {
        hres = _pHTMLWindow->QueryInterface(IID_IHTMLPrivateWindow, (void**)&pPrivWindow);

        if (S_OK == hres)
        {
            CComBSTR cbstrShortCut;

            IBindStatusCallback * pBindStatusCallback;
            LPTSTR pszHeaders = NULL;
            LPBYTE pPostData = NULL;
            DWORD cbPostData = 0;
            STGMEDIUM stgPostData;
            BOOL fHavePostStg = FALSE;

            BSTR bstrHeaders = NULL;
            VARIANT vaHeaders = {0};
            SAFEARRAY * psaPostData = NULL;
            VARIANT vaPostData = {0};

            if (SUCCEEDED(IUnknown_QueryService(_phf, SID_SHlinkFrame, IID_PPV_ARG(IBindStatusCallback, &pBindStatusCallback))))
            {
                GetHeadersAndPostData(pBindStatusCallback, &pszHeaders, &stgPostData, &cbPostData, NULL);
                pBindStatusCallback->Release();
                fHavePostStg = TRUE;

                if (stgPostData.tymed == TYMED_HGLOBAL) 
                {
                    pPostData = (LPBYTE) stgPostData.hGlobal;

                    if (pPostData && cbPostData)
                    {
                        // make a SAFEARRAY for post data
                        psaPostData = MakeSafeArrayFromData(pPostData, cbPostData);

                        // put the post data SAFEARRAY into a variant so we can pass through automation
                        if (psaPostData)
                        {
                            V_VT(&vaPostData) = VT_ARRAY | VT_UI1;
                            V_ARRAY(&vaPostData) = psaPostData;
                        }
                    }
                }

                if (pszHeaders && pszHeaders[0])
                {
                    bstrHeaders = SysAllocStringT(pszHeaders);
                    V_VT(&vaHeaders) = VT_BSTR;
                    V_BSTR(&vaHeaders) = bstrHeaders;
                }
            }

            _GetShortCutPath(&cbstrShortCut);
            _GetDocNavFlags(&dwFlags);

            // Do the navigate
            //
            hres = pPrivWindow->SuperNavigate(bstrUrl,
                                              bstrLocation,
                                              cbstrShortCut,
                                              NULL,
                                              &vaPostData,
                                              &vaHeaders,
                                              dwFlags);
            pPrivWindow->Release();

            if (fHavePostStg) 
            {
                ReleaseStgMedium(&stgPostData);
            }

            if (bstrHeaders)
            {
                SysFreeString(bstrHeaders);
            }

            if (V_ARRAY(&vaPostData))
            {
                ASSERT(V_VT(&vaPostData) == (VT_ARRAY | VT_UI1));
                VariantClearLazy(&vaPostData);
            }

            _fRefresh = FALSE; // clear the refresh flag.
        }
    }

    return hres;
}

//+---------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_GetShortCutPath
//
//  Synopsis : Returns the shortcut path.
//
//+---------------------------------------------------------------------------

void
CDocObjectHost::_GetShortCutPath(BSTR * pbstrShortCutPath)
{
    HRESULT hres;
    VARIANT varShortCutPath = {0};
    IOleCommandTarget * pcmdt;

    ASSERT(pbstrShortCutPath);

    *pbstrShortCutPath = NULL;

    hres = QueryService(SID_SHlinkFrame, IID_IOleCommandTarget, (void **)&pcmdt);

    if (S_OK == hres)
    {
       hres = pcmdt->Exec(&CGID_Explorer, SBCMDID_GETSHORTCUTPATH, 0, NULL, &varShortCutPath);

       if (S_OK == hres && VT_BSTR == V_VT(&varShortCutPath) && V_BSTR(&varShortCutPath))
       {
           *pbstrShortCutPath = SysAllocString(V_BSTR(&varShortCutPath));
       }
       else if (_pocthf)
       {
           VariantClear(&varShortCutPath);

           // if we couldn't find it on that service, try the cached HLink interface
           // this is necessary for ND & Mars which provide a different implementation for the HLink interface
           hres = _pocthf->Exec(&CGID_Explorer, SBCMDID_GETSHORTCUTPATH, 0, NULL, &varShortCutPath);

           if (S_OK == hres && VT_BSTR == V_VT(&varShortCutPath) && V_BSTR(&varShortCutPath))
           {
               *pbstrShortCutPath = SysAllocString(V_BSTR(&varShortCutPath));
           }
       }

       pcmdt->Release();
    }

    VariantClear(&varShortCutPath);
}

//+---------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_GetDocNavFlags
//
//  Synopsis : Returns the flags for navigation.
//
//+---------------------------------------------------------------------------

void
CDocObjectHost::_GetDocNavFlags(DWORD * pdwDocNavFlags)
{
    // Find out if we are in the middle of an autosearch.
    // If we are, set the necessary document flags.
    //
    HRESULT hr;
    DWORD   dwSuffixIdx     = -1;
    BOOL    fAllowSearch    = FALSE;
    BOOL    fContinueSearch = FALSE;
    DWORD   dwNavFlags      = 0;

    ASSERT(pdwDocNavFlags);

    hr = _GetSearchInfo(_psp, &dwSuffixIdx, &fAllowSearch,
                        &fContinueSearch, NULL, NULL);

    if (SUCCEEDED(hr) && dwSuffixIdx > 1 && fContinueSearch)
    {
        // We aren't really in an autosearch, but are in 
        // a redirection from an autosearch (i.e., there is
        // a long standing bug where the MSN autosearch page
        // is placed in the travel log. When you press back,
        // the search is restarted. However, if the search
        // info is not reset here, the suffix index is incorrect.
        // 
        if (!fAllowSearch)
        {
            _bsc._SetSearchInfo(this, 0, fAllowSearch, fContinueSearch, FALSE);
        }
    }

    // Check to see if the navigation should be suppressed from the history
    //
    if ( _pwb && (S_OK == _pwb->GetFlags(&dwNavFlags))
       && (dwNavFlags & BSF_NAVNOHISTORY))
    {
        *pdwDocNavFlags |= DOCNAVFLAG_DONTUPDATETLOG;
    }

    if ( _fRefresh )
    {
        *pdwDocNavFlags |= DOCNAVFLAG_REFRESH;
    }
}

HRESULT CDocObjectHost::_EnsureActivateMsoView()
{
    HRESULT hres = E_FAIL;

    // if we've got an ole object and
    // either we don't have a view, or we don't have an active view..
    // do the activation
    if (_pole)
    {

        if (!_pmsov || !_ActiveObject()) {

            hres = _ActivateMsoView();

            // Note that we should not UIActivate it here. We should wait
            // until the DocObject calls our ActivateMe
            // _ShowMsoView();
        }
    }

    return hres;
}

//
// This member closes the MsoView window and releases interface
// pointers. This is essentially the reverse of _CreateMsoView.
//
void CDocObjectHost::_CloseMsoView(void)
{
    ATOMICRELEASE(_pmsot);

    if (_pmsov)
    {
        VIEWMSG(TEXT("_CloseMsoView calling pmsov->UIActivate(FALSE)"));
        IOleDocumentView* pmsov = _pmsov;
        _pmsov = NULL;
        _fDontInplaceActivate = FALSE;

#ifdef DONT_UIDEACTIVATE
        if (_uState != SVUIA_DEACTIVATE)
            pmsov->UIActivate(FALSE);
#else // DONT_UIDEACTIVATE
        if (_uState == SVUIA_ACTIVATE_FOCUS)
            pmsov->UIActivate(FALSE);
#endif // DONT_UIDEACTIVATE
       
        _IPDeactivateMsoView(pmsov);

        pmsov->CloseView(0);
        pmsov->SetInPlaceSite(NULL);
        pmsov->Release();
        VIEWMSG(TEXT("_CloseMsoView called pmsov->Release()"));
    }

    ATOMICRELEASE(_pmsoc);


}

void CDocObjectHost::_OnPaint(HDC hdc)
{
    if (_pmsov && !_ActiveObject())
    {
        HRESULT hres;
        RECT rcClient;
        GetClientRect(_hwnd, &rcClient);
        hres = OleDraw(_pmsov, DVASPECT_CONTENT, hdc, &rcClient);
        TraceMsg(0, "shd TR ::_OnPaint OleDraw returns %x", hres);
    }
}

HRESULT _GetDefaultLocation(LPWSTR pszPath, DWORD cchPathSizeIn, UINT id)
{
    WCHAR szPath[MAX_URL_STRING];
    DWORD cbSize = SIZEOF(szPath);
    DWORD cchPathSize = cchPathSizeIn;
    HRESULT hres = E_FAIL;
    HKEY hkey;

    // Share this code!!!
    // This is Internet Explorer Specific

    HKEY hkeyroot = id == IDP_CHANNELGUIDE ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;
    if (RegOpenKeyW(hkeyroot,
            L"Software\\Microsoft\\Internet Explorer\\Main",
            &hkey)==ERROR_SUCCESS)
    {
        DWORD dwType;

        LPCWSTR pszName;

        switch(id) {
        default:
            ASSERT(0);
        case DVIDM_GOHOME:
            pszName = L"Default_Page_URL";
            break;

        case DVIDM_GOSEARCH:
            pszName = L"Default_Search_URL";
            break;

        case IDP_UPDATE:
            pszName = L"Default_Update_URL";
            break;

        case IDP_CHANNELGUIDE:
            pszName = L"ChannelsURL";
            break;

        }

        if (RegQueryValueExW(hkey, pszName,
            0, &dwType, (LPBYTE)szPath, &cbSize)==ERROR_SUCCESS)
        {
            // When reading a URL from registry, treat it like it was typed
            // in on the address bar.

            hres = S_OK;

            if(!ParseURLFromOutsideSourceW(szPath, pszPath, &cchPathSize, NULL))
                StrCpyNW(pszPath, szPath, cchPathSizeIn);

            if(IsFileUrlW(pszPath))
            {
                cchPathSize = cchPathSizeIn;
                hres = PathCreateFromUrlW(pszPath, pszPath, &cchPathSize, 0);
            }
        }
        RegCloseKey(hkey);
    }



    HOMEMSG("_GetStdLocation returning",
            (SUCCEEDED(hres) ? pszPath : TEXT("Error")), hres);

    return hres;
}

HRESULT _GetStdLocation(LPTSTR pszPath, DWORD cchPathSize, UINT id)
{
    TCHAR szPathTemp[MAX_URL_STRING];
    DWORD cchTempSize = ARRAYSIZE(szPathTemp);
    HRESULT hres = E_FAIL;
    LPCWSTR pszName = NULL;

    ASSERT(cchPathSize >= cchTempSize);     // If we hit this, we will truncate the URL in some cases.
    ASSERT(pszPath && (cchPathSize > 0)); // Not Optional
    pszPath[0] = TEXT('\0');

    // Share this code!!!
    // This is Internet Explorer Specific
    switch(id) {
    default:
        ASSERT(0);
    case DVIDM_GOHOME:
        pszName = L"Start Page";
        break;

    case DVIDM_GOFIRSTHOME:
    case DVIDM_GOFIRSTHOMERO:
        pszName = L"First Home Page";
        break;

    case DVIDM_GOSEARCH:
        pszName = L"Search Page";
        break;

    case DVIDM_SEARCHBAR:
        pszName = L"Search Bar";
        break;

    case DVIDM_GOLOCALPAGE:
        pszName = L"Local Page";
        break;
    }

    hres = URLSubRegQuery(szRegKey_SMIEM, pszName, TRUE,
                       szPathTemp, cchTempSize, URLSUB_ALL);
    if (FAILED(hres) &&
        ((DVIDM_GOFIRSTHOME == id) || (DVIDM_GOFIRSTHOMERO == id)))
    {
        // The First Home key doesn't exist so use the home key.
        pszName = TEXT("Start Page");
        hres = URLSubRegQuery(szRegKey_SMIEM, pszName, TRUE,
                           szPathTemp, cchTempSize, URLSUB_ALL);
        id = DVIDM_GOHOME;
    }

    if (SUCCEEDED(hres))
    {
        // When reading a URL from registry, treat it like it was typed
        // in on the address bar.

        // Recursion block.  If requesting the home page, and the home page is "about:home", substitute
        // "about:blank" (otherwise we'll recurse to death)

        if (DVIDM_GOHOME == id && !StrCmpI(szPathTemp, TEXT("about:home")) )
        {
            StrCpyN(szPathTemp, TEXT("about:blank"), MAX_URL_STRING);
        }

        if(ParseURLFromOutsideSourceW(szPathTemp, pszPath, &cchPathSize, NULL))
        {
            if(IsFileUrlW(pszPath))
                hres = PathCreateFromUrlW(pszPath, pszPath, &cchPathSize, 0);
        }
    }

    if (DVIDM_GOFIRSTHOME == id)    // Delete that FIRSTHOME key
    {
        HUSKEY hUSKey;

        if (ERROR_SUCCESS == SHRegOpenUSKey(szRegKey_SMIEM, KEY_WRITE, NULL, &hUSKey, FALSE))
        {
            SHRegDeleteUSValue(hUSKey, TEXT("First Home Page"), SHREGDEL_DEFAULT);
            SHRegCloseUSKey(hUSKey);
        }
        hres = S_OK;
    }

    HOMEMSG("_GetStdLocation returning",
            (SUCCEEDED(hres) ? pszPath : TEXT("Error")), hres);

    return hres;
}


HRESULT WINAPI _GetDefaultLocation(UINT idp, LPWSTR pszPath, UINT cchMax)
{
    switch (idp)
    {
    case IDP_UPDATE:
    case IDP_CHANNELGUIDE:
        URLSubLoadString(NULL, IDS_DEF_UPDATE+(idp-IDP_UPDATE), pszPath, cchMax, URLSUB_ALL);
        break;

    default:
        _GetDefaultLocation(pszPath, cchMax, (idp == IDP_SEARCH) ? DVIDM_GOSEARCH : DVIDM_GOHOME);
        break;
    }

    return S_OK;
}


HRESULT WINAPI SHDGetPageLocation(HWND hwndOwner, UINT idp, LPWSTR pszPath, UINT cchMax, LPITEMIDLIST *ppidlOut)
{
    TCHAR szBuf[MAX_URL_STRING];
    if (pszPath==NULL) {
        pszPath = szBuf;
        cchMax = ARRAYSIZE(szBuf);
    }
    *pszPath = L'\0';
    *ppidlOut = NULL;
    HRESULT hres = S_OK;
    switch (idp) {
    case IDP_UPDATE:
    case IDP_CHANNELGUIDE:
        ASSERT(IDP_CHANNELGUIDE-IDP_UPDATE == IDS_DEF_CHANNELGUIDE-IDS_DEF_UPDATE);
        if (FAILED(hres = _GetDefaultLocation(pszPath, cchMax, idp)))
        {
            hres = _GetDefaultLocation(idp, pszPath, cchMax);
        }
        break;

    default:
        ASSERT(idp==IDP_START || idp==IDP_SEARCH);
        hres = _GetStdLocation(pszPath, cchMax,
                    (idp == IDP_SEARCH) ? DVIDM_GOSEARCH : DVIDM_GOHOME);
        if (FAILED(hres))
        {
            hres = _GetDefaultLocation(idp, pszPath, cchMax);
        }
        break;
    }

    if (SUCCEEDED(hres))
    {
        hres = IECreateFromPath(pszPath, ppidlOut);
        if (FAILED(hres))
        {
            // IECreateFromPath() above could have failed if the default location
            // was invalid. (Like file://server_no_exist/
            _GetDefaultLocation(idp, pszPath, cchMax);
            hres = IECreateFromPath(pszPath, ppidlOut);
        }

        HOMEMSG("SHDGetPageLocation SHILCreateFromPage returned", pszPath, hres);
    }

    return hres;
}


void CDocObjectHost::_ChainBSC()
{
    if (!_bsc._pbscChained && _phf) 
    {
        // Get "chaigned" bind status, if any
        IServiceProvider * psp = NULL;

        HRESULT hres = _phf->QueryInterface(IID_IServiceProvider, (void **)&psp);

        CHAINMSG("_StartAsyncBinding hlf->QI returns", hres);

        if (SUCCEEDED(hres)) 
        {
            ASSERT(NULL == _bsc._pbscChained);

            hres = psp->QueryService(SID_SHlinkFrame, IID_IBindStatusCallback, (void **)&_bsc._pbscChained);

            CHAINMSG("_StartAsyncBinding psp(hlf)->QS returns", hres);
            psp->Release();

            if (SUCCEEDED(hres))
            {
                ASSERT(NULL==_bsc._pnegotiateChained);
                _bsc._pbscChained->QueryInterface(IID_IHttpNegotiate, (void **)&_bsc._pnegotiateChained);
            }
        }
    }
}

//
// WARNING: Following two global variables are shared among multiple-threads
//  in a thread. Therefore, all right-access must be serialized and all read
//  access should be blocked when right is going on.
//
//   Right now, we just initialize them once (based on the registry setting)
//  and never update. It allows us to simplify the code quite a bit. If we
//  need to update, then _RegisterMediaTypeClass should be changed significantlly
//  so that we can safely handle multiple access to those hdsa's. (SatoNa)
//
HDSA g_hdsaCls = NULL;
HDSA g_hdsaStr = NULL;

BOOL CDocObjectHost::_BuildClassMapping(void)
{
    if (g_hdsaCls) 
    {
        return DSA_GetItemCount(g_hdsaCls) == DSA_GetItemCount(g_hdsaStr);
    }

    ENTERCRITICAL;
    if (!g_hdsaCls) {
        g_hdsaStr = DSA_Create(SIZEOF(LPCSTR), 32);
        if (g_hdsaStr)
        {
            HDSA hdsaCls = DSA_Create(SIZEOF(CLSID), 32);
            if (hdsaCls)
            {
                HKEY hkey;
                if (RegOpenKey(HKEY_LOCAL_MACHINE,
                        TEXT("Software\\Microsoft\\Internet Explorer\\MediaTypeClass"),
                        &hkey) == ERROR_SUCCESS)
                {
                    TCHAR szCLSID[64];  // enough for "{CLSID}"
                    for (int iKey=0;
                         RegEnumKey(hkey, iKey, szCLSID, SIZEOF(szCLSID)/sizeof(szCLSID[0]))==ERROR_SUCCESS;
                         iKey++)
                    {
                        CLSID clsid;
                        if (FAILED(CLSIDFromString(szCLSID, &clsid))) {
                            TraceMsg(DM_WARNING, "CDOH::_RMTC CLSIDFromString(%x) failed", szCLSID);
                            continue;
                        }

                        TraceMsg(DM_MIMEMAPPING, "CDOH::_RMTC RegEnumKey found %s", szCLSID);
                        HKEY hkeyCLSID;
                        if (RegOpenKey(hkey, szCLSID, &hkeyCLSID) == ERROR_SUCCESS)
                        {
                            for (int iValue=0; ; iValue++)
                            {
                                CHAR szFormatName[128];
                                DWORD dwType;
                                DWORD cchValueName = ARRAYSIZE(szFormatName);
                                //
                                // Keep the name ansi because it needs to get
                                // passed to urlmon's RegisterMediaTypeClass as
                                // ansi.
                                //
                                if (RegEnumValueA(hkeyCLSID, iValue, szFormatName, &cchValueName, NULL,
                                                 &dwType, NULL, NULL)==ERROR_SUCCESS)
                                {
                                    TraceMsg(DM_MIMEMAPPING, "CDOH::_RMTC RegEnumValue found %s", szFormatName);
                                    LPSTR psz = StrDupA(szFormatName);
                                    if (psz) {
                                        DSA_InsertItem(hdsaCls, 0xffff, &clsid);
                                        if (DSA_InsertItem(g_hdsaStr, 0xffff, &psz)<0) {
                                            LocalFree(psz);
                                            psz = NULL;
                                            break;
                                        }
                                    }
                                } else {
                                    break;
                                }
                            }
                            RegCloseKey(hkeyCLSID);
                        } else {
                            TraceMsg(DM_WARNING, "CDOH::_RMTC RegOpenKey(%s) failed", szCLSID);
                        }
                    }
                    RegCloseKey(hkey);
                } else {
                    TraceMsg(0, "CDOH::_RMTC RegOpenKey(MediaTypeClass) failed");
                }

                //
                // Update g_hdsaCls at the end so that other thread won't
                // access while we are adding items.
                //
                g_hdsaCls = hdsaCls;
                ASSERT(DSA_GetItemCount(g_hdsaCls)==DSA_GetItemCount(g_hdsaStr));
            }
        }
    }

    LEAVECRITICAL;

    return (g_hdsaCls && DSA_GetItemCount(g_hdsaCls)==DSA_GetItemCount(g_hdsaStr));
}

HRESULT CDocObjectHost::_RegisterMediaTypeClass(IBindCtx* pbc)
{
    HRESULT         hres    = S_FALSE; // Assume no mapping

    if (_BuildClassMapping() && DSA_GetItemCount(g_hdsaCls)) {
        //
        // WARNING: This code assumes that g_hdsaCls/g_hdsaStr never
        //  changes once they are initializes. Read notes above
        //  those global variables for detail.
        //
        hres = RegisterMediaTypeClass(pbc,
                        DSA_GetItemCount(g_hdsaCls),
                        (LPCSTR*)DSA_GetItemPtr(g_hdsaStr, 0),
                        (CLSID*)DSA_GetItemPtr(g_hdsaCls, 0), 0);

        TraceMsg(DM_MIMEMAPPING, "CDOH::_StartAsyncBinding RegisterMTC returns %x", hres);
    }

    // Now see if the container has anything that needs to be registered
    //
    if (_psp)
    {
        IMimeInfo * pIMimeInfo;
        hres = _psp->QueryService(SID_IMimeInfo, IID_IMimeInfo, (void **)&pIMimeInfo);

        if (SUCCEEDED(hres))
        {
            UINT            cTypes  = 0;
            LPCSTR          *ppszTypes = NULL;
            CLSID           *pclsIDs= NULL;
            ASSERT(pIMimeInfo);
            hres = pIMimeInfo->GetMimeCLSIDMapping(&cTypes, &ppszTypes, &pclsIDs);

            if (SUCCEEDED(hres)) {
                if (cTypes && ppszTypes && pclsIDs) {
                    // Last one to register wins, so if the container wants to override what is
                    // already registered this should do it.
                    //  URLMon will handle the duplicates corectly.
                    //
                    hres = RegisterMediaTypeClass(pbc, cTypes, ppszTypes, pclsIDs, 0);

                    TraceMsg(DM_MIMEMAPPING, "CDOH::_StartAsyncBinding RegisterMTC for Container returns %x", hres);
                }
                // RegisterMediaTypeClass should have made copies
                // so free the containers allocations as it expects us to do
                //
                //      CoTaskMemFree(NULL) is OK
                //
                CoTaskMemFree(ppszTypes);
                CoTaskMemFree(pclsIDs);
            }
            pIMimeInfo->Release();
        } else {
            hres = S_FALSE;
        }
    }
    return hres;
}

HRESULT _RegisterAcceptHeaders(IBindCtx* pbc, IShellBrowser* psb)
{
    return RegisterDefaultAcceptHeaders(pbc, psb);
}

HRESULT GetAmbientBoolProp(IExpDispSupport* peds, DISPID dispid, BOOL *pb)
{
    VARIANT var = {0};

    // Assume failure
    *pb = FALSE;

    HRESULT hres = peds->OnInvoke(dispid, IID_NULL, NULL, DISPATCH_PROPERTYGET, (DISPPARAMS *)&g_dispparamsNoArgs, &var, NULL, NULL);
    if (SUCCEEDED(hres))
    {
        // VB returns success with VT_EMPTY, so we can't assert here
        if (var.vt == VT_BOOL)
        {
            *pb = (var.boolVal) ? TRUE : FALSE;
        }
        else
        {
            // Even though VB says VT_EMPTY, we don't know what other containers
            // might shove in here. Make sure we clean up.
            //
            VariantClear(&var);
        }
    }
    else
    {
        hres = E_FAIL;
    }

    return hres;
}

HRESULT CDocObjectHost::_GetOfflineSilent(BOOL *pbIsOffline, BOOL *pbIsSilent)
{
    if (_peds)
    {
        if (pbIsOffline)
            GetAmbientBoolProp(_peds, DISPID_AMBIENT_OFFLINEIFNOTCONNECTED, pbIsOffline);

        if (pbIsSilent)
            GetAmbientBoolProp(_peds, DISPID_AMBIENT_SILENT, pbIsSilent);
    }
    else
    {
        if (pbIsOffline)
            *pbIsOffline = FALSE;
        if (pbIsSilent)
            *pbIsSilent = FALSE;
    }

    return S_OK;
}



/*
    Callback function for RatingObtainQuery
*/
void RatingObtainQueryCallback(DWORD dwUserData, HRESULT hr, LPCSTR pszRating, LPVOID lpvInpageRating)
{
    TraceMsg(DM_PICS, "RatingObtainQueryCallback given result %x", hr);

    /* WARNING: This function is called by MSRATING.DLL on a separate thread,
     * not the main message loop thread.  Touch nothing in important data
     * structures not protected by critical sections!
     *
     * Merely format up a windows message with the info we have;  we'll handle
     * this in the main thread, if we ever get there.
     *
     * Note that pszRating is ignored, we count on the ratings engine to have
     * called RatingCheckUserAccess for us and provide the HRESULT.
     */
    if (!::_PostPicsMessage(dwUserData, hr, lpvInpageRating))
    {
        if ( lpvInpageRating )
        {
            ::RatingFreeDetails(lpvInpageRating);
            lpvInpageRating = NULL;
        }
    }
}


HRESULT CDocObjectHost::_StartAsyncBinding(IMoniker * pmk, IBindCtx * pbc, IShellView * psvPrev)
{
    URLMSG(TEXT("_StartAsyncBinding called"));
    HRESULT hres;

    ASSERT(_bsc._pbc == NULL && _pole == NULL);
    _bsc._RegisterObjectParam(pbc);

    //
    //  Associate the client site as an object parameter to this
    // bind context so that Trident can pick it up while processing
    // IPersistMoniker::Load().
    //
    pbc->RegisterObjectParam(WSZGUID_OPID_DocObjClientSite, SAFECAST(this, IOleClientSite*));

    _ChainBSC();

    IUnknown * punk = NULL;

    _bsc._pbc = pbc;
    pbc->AddRef();


    // Decide right here whether or not this frame is offline
    BOOL bFrameIsOffline = FALSE;
    BOOL bFrameIsSilent = FALSE;


    this->_GetOfflineSilent(&bFrameIsOffline, &bFrameIsSilent);

    _bsc._bFrameIsOffline = bFrameIsOffline ? TRUE : FALSE;
    _bsc._bFrameIsSilent  = bFrameIsSilent ? TRUE : FALSE;
    BOOL bSuppressUI = (_bsc._bFrameIsSilent || _IsDesktopItem(SAFECAST(this, CDocObjectHost*))) ? TRUE : FALSE;

#ifdef DEBUG
    PERFMSG(TEXT("_StartAsyncBinding Calling pmk->BindToObject"), GetCurrentTime()-g_dwPerf);
    g_dwPerf = GetCurrentTime();
#endif

#ifdef DEBUG
    if (g_dwPrototype & 0x00000800) {
        TraceMsg(DM_TRACE, "CDOH::_StartAsyncBinding skipping CLSID mapping");
    }
    else
#endif
    {
        // Register overriding mime->CLSID mapping
        _RegisterMediaTypeClass(pbc);
    }

    // Register accept headers
    _RegisterAcceptHeaders(pbc, _psb);

    if (_pwb)
    {
        _pwb->SetNavigateState(BNS_BEGIN_NAVIGATE);
    }

    _StartBasePicsProcessor();

    //
    //  Crazy sync/async behavior of URLMON.  - zekel - 6-AUG-97
    //  any of the following may occur:
    //
    //  1.  SUCCESS or FAILURE:  we receive sync E_PENDING from BindToObject,
    //      and then get an Async HRESULT on OnStopBinding().
    //      this is the most common case and the basic design.
    //
    //  2.  SUCCESS:  we receive sync S_OK from BindToObject and
    //      need to complete the async behavior on our BSCB ourself
    //      since urlmon started but did not finish.
    //
    //  3.  SUCCESS:  while inside BindToObject(), we receive sync S_OK
    //      from OnStopBinding(), and then BindToObject returns with S_OK.
    //
    //  4.  FAILURE:  simplest case is an error being returned from BindToObject()
    //      but without an any OnStopBinding() so we need to complete
    //      the async behavior on our BSCB ourself since urlmon started but did not finish.
    //      this usually occurs when accessing local files.
    //
    //  5.  FAILURE:  while inside BindToObject(), we receive sync S_OK from OnStopBinding(),
    //      and then BindToObject returns with some other error that needs to be handled.
    //      this occurs with some malformed urls.
    //
    //  6.  FAILURE:  while inside BindToObject(), we receive a sync error from OnStopBinding(),
    //      and then BindToObject returns with some other error (usually E_FAIL).
    //      we need to trust the first one.  this occurs when wininet
    //      returns syncronous errors, and its error is the one returned in OnStopBinding()
    //
    //  7.  FAILURE:  while inside BindToObject(), we receive a sync error from OnStopBinding(),
    //      and then BindToObject returns with E_PENDING.  which we think means everything
    //      is going great, and urlmon thinks it is done.  this happens with a file: to
    //      a resource that is not hostable.  we need to show the download UI.
    //
    //  in order to support all the errors in the most consistent and safe manner,
    //  we defer any errors in OnStopBinding() if they are delivered synchronously
    //  on BindToObject().  the OnStopBinding() error always overrides the BindToObject()
    //  error, but any error will always override any success.
    //


    ASSERT(S_OK == _hrOnStopBinding);

    _fSyncBindToObject = TRUE;

    URLMSG(TEXT("_StartAsyncBinding calling pmk->BindToObject"));

    hres = pmk->BindToObject(pbc, NULL, IID_IUnknown, (void**)&punk);

    URLMSG3(TEXT("_StartAsyncBinding pmk->BindToObject returned"), hres, punk);

    _fSyncBindToObject = FALSE;

    if (SUCCEEDED(_hrOnStopBinding) && (SUCCEEDED(hres) || hres==E_PENDING))
    {
        hres = S_OK;

        if (_bsc._pbc) {
            //
            // In case OnStopBinding hasn't been called.
            //
            if (!_pole)
            {
                if (psvPrev)
                {
                    _bsc._psvPrev = psvPrev;
                    psvPrev->AddRef();
                }
            }
            else
            {
                URLMSG3(TEXT("_StartAsyncBinding we've already got _pole"), hres, _pole);
            }

            //
            // If moniker happen to return the object synchronously, emulate
            // OnDataAvailable callback and OnStopBinding.
            //
            if (punk)
            {
                _bsc.OnObjectAvailable(IID_IUnknown, punk);
                _bsc.OnStopBinding(hres, NULL);
                punk->Release();
                ASSERT(_bsc._pbc==NULL);

            }
        }
        else
        {
            //
            // OnStopBinding has been already called.
            //
            if (punk)
            {
                AssertMsg(0, TEXT("CDOH::_StartAsyncBinding pmk->BindToObject returned punk after calling OnStopBinding")); // Probably URLMON bug.
                punk->Release();
            }
        }
    }
    else
    {
        // Binding failed.
        TraceMsg(DM_WARNING, "CDOH::_StartAsyncBinding failed (%x)", hres);

        //
        //  Urlmon is inconsistent in it's error handling - zekel - 4-AUG-97
        //  urlmon can return errors in three different ways from BindToObject()
        //  1.  it can return back a simple syncronous error.  without calling OnStopBinding()
        //
        //  2.  it can return a sync error,
        //          but call OnStopBinding() with S_OK first on the same thread;
        //
        //  3.  it can return a sync error,
        //          but also call OnStopBinding() with the real Error first on the same thread.
        //
        //  4.  it can return E_PENDING,
        //          but already have called OnStopBinding() with the real error.
        //
        //  SOLUTIONS:
        //  in all cases of error in OnStopBinding(), we will now postpone the OnStopBinding processing util after
        //  we have returned from the BindToObject().  we try to use the best error.
        //  we allow successful OnStopBinding() to pass through unmolested, and trap
        //  the error here if necessary.
        //

        if (FAILED(_hrOnStopBinding))
            hres = _hrOnStopBinding;

        if (_bsc._pbc)
            _bsc.OnStopBinding(hres, NULL);
        else if (!bSuppressUI)
        {
            //
            //  OnStopBinding was already called, but with a success
            //  so we need to handle the error here.  this happens
            //  with some invalid URLs like http:/server
            //

            BOOL fCancelErrorPage = FALSE;

            _FireNavigateErrorHelper(NULL, ERRORPAGE_SYNTAX, &fCancelErrorPage); 

            if (fCancelErrorPage)
            {
                _CancelPendingNavigation(TRUE, FALSE);
            }
            else
            {
                // Fix for W98 webtv app.  If we're in a frame don't
                // blow away the frame set to dispaly the error.
                //
                if (!_fHaveParentSite)
                {
                    _bsc._NavigateToErrorPage(ERRORPAGE_SYNTAX, this, FALSE);
                }
            }
        }

        ASSERT(_bsc._pbc==NULL);
    }

    return hres;
}

void CDocObjectHost::_ReleasePendingObject(BOOL fIfInited)
{
    HRESULT hres;
    IOleObject *polePending;
#ifdef TRIDENT_NEEDS_LOCKRUNNING
    IRunnableObject *pro;
#endif

    if (fIfInited == FALSE && _fPendingWasInited == FALSE)
        return;

    if (_punkPending)
    {
        if (_fCreatingPending)
        {
            _fAbortCreatePending = 1;
            return;
        }

        if (!_fPendingNeedsInit && !IsSameObject(_punkPending, _pole))
        {
            hres = _punkPending->QueryInterface(IID_IOleObject, (void **) &polePending);
            if (SUCCEEDED(hres)) {
                LPOLECLIENTSITE pcs;
                if (SUCCEEDED(polePending->GetClientSite(&pcs)) && pcs)
                {
                    if (pcs == SAFECAST(this, LPOLECLIENTSITE))
                    {
                        polePending->SetClientSite(NULL);
                    }
                    pcs->Release();
                }
                polePending->Release();
            }
        }
#ifdef TRIDENT_NEEDS_LOCKRUNNING
        //  TRIDENT NO LONGER SUPPORTS IRunnableObject
        hres = _punkPending->QueryInterface(IID_IRunnableObject, (void **) &pro);
        if (SUCCEEDED(hres))
        {
            hres = pro->LockRunning(FALSE, TRUE);
            pro->Release();
        }
#endif
        SAFERELEASE(_punkPending);
        _fPendingWasInited = FALSE;
    }
}

void CDocObjectHost::_ReleaseOleObject(BOOL fIfInited)
{
    TraceMsg(DM_DEBUGTFRAME, "CDocObjectHost::_ReleaseOleObject called %x (%x)", _pole, this);

    // Minimize impact by cleaning up in affected cases only.
    if (fIfInited == FALSE && _fPendingWasInited == FALSE)
        return;

    // release _pole object and all the associated QI'ed pointers
    if (_phls) {
        _phls->SetBrowseContext(NULL); // probably no need
        ATOMICRELEASE(_phls);
    }

    if (_pvo) {
        IAdviseSink *pSink;
        // paranoia: only blow away the advise sink if it is still us
        if (SUCCEEDED(_pvo->GetAdvise(NULL, NULL, &pSink)) && pSink) {
            if (pSink == (IAdviseSink *)this) {
                _pvo->SetAdvise(0, 0, NULL);
            } else {
                ASSERT(0);  // do we really hit this case?
            }

            pSink->Release();
        }
        ATOMICRELEASE(_pvo);
    }

    if (_pole)
    {
        LPOLECLIENTSITE pcs;
        if (SUCCEEDED(_pole->GetClientSite(&pcs)) && pcs)
        {
            if (IsSameObject(pcs, SAFECAST(this, LPOLECLIENTSITE)))
            {
                _pole->SetClientSite(NULL);
            }
            pcs->Release();
        }

        // Notes: Make it sure that we don't hold a bogus _pole even
        //  for a moment (while we call Release).
        ATOMICRELEASE(_pole);
    }
}


//
// This member releases all the interfaces to the DocObject, which is
// essentially the reverse of _Bind.
//
void CDocObjectHost::_UnBind(void)
{
    ATOMICRELEASE(_pHTMLWindow);
    ATOMICRELEASE(_pmsot);

    VariantClear(&_varUserEnteredUrl);
    
    ASSERT(!_pmsov); // paranoia
    ATOMICRELEASE(_pmsov);

    ASSERT(!_pmsoc); // paranoia
    ATOMICRELEASE(_pmsoc);

    _xao.SetActiveObject(NULL);

    if (_pole)
    {

        // Just in case we're destroyed while we were waiting
        // for the docobj to display itself.
        //
        _RemoveTransitionCapability();

        //
        //  If this is NOT MSHTML, cache the OLE server so that we don't
        // need to restart or load the OLE server again.
        //
        if (!(_dwAppHack & (BROWSERFLAG_MSHTML | BROWSERFLAG_DONTCACHESERVER)))
        {
            IBrowserService *pbs;
            if (SUCCEEDED(QueryService(SID_STopLevelBrowser, IID_IBrowserService, (void **)&pbs)))
            {
                pbs->CacheOLEServer(_pole);
                pbs->Release();
            }
        }

        TraceMsg(DM_ADVISE, "CDocObjectHost::_UnBind about to call Close of %x", _pole);
        _pole->Close(OLECLOSE_NOSAVE);

        _ReleaseOleObject();
    }

    _ReleasePendingObject();

    ATOMICRELEASE(_pstg);
    ATOMICRELEASE(_pbcCur);
    ATOMICRELEASE(_pmkCur);
}

//
// HACK: If we open Excel95 objects directly, Excel goes crazy and eventually
//  hit GPF. Here is the background info, I've got Office guys (SatoNa).
//
// From:        Rajeev Misra (Xenix)
//
//   1) Excel does not handle the foll. case very well. Taking a normal file
//   loading it through IPersistFile:Load and then bringing it up as an
//   embedded object. The code was always tested so that the embedded
//   objects always got loaded through ScPrsLoad. I am seeing a bunch of
//   asserts in Excel that say that this assumption is being destroyed.
//   ASSERT(_pole);
//
// From:        Srini Koppolu
//
//   For you, there is only one case, i.e. you always deal with the files. Then your code should look like this
//
//     CreateFileMoniker from the file
//     pUIActiveObject->OnFrameWindowActivate(FALSE);
//     pmk->BindToObject(IID_IDataObject, &pdobj)
//     pUIActiveObject->OnFrameWindowActivate(TRUE);
//     OleCreateFromData()
//
//   OnFrameWindowActivate is done to take care of another excel problem.
//   If you currently have and Excel object UIActive in you and you try to
//   do IPersistFile::Load on Excel, then it will cause problems.
//

void CDocObjectHost::_AppHackForExcel95(void)
{
    ASSERT(_pole);

    HRESULT hres;
    IDataObject* pdt = NULL;
    hres = _pole->QueryInterface(IID_IDataObject, (void **)&pdt);
    TraceMsg(DM_BINDAPPHACK, "_PostBindAppHack -- QI(IOleDataObject) returned %x", hres);

    if (SUCCEEDED(hres))
    {
        ASSERT(_pstg==NULL);
        hres = StgCreateDocfile(NULL,
                STGM_DIRECT | STGM_CREATE | STGM_READWRITE
                | STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE,
                0, &_pstg);
        TraceMsg(DM_BINDAPPHACK, "_PostBindAppHack StgCreateDocFile(NULL) returned %x", hres);
        if (SUCCEEDED(hres))
        {
            IOleObject* poleCopy = NULL;
            hres = OleCreateFromData(pdt, IID_IOleObject, OLERENDER_NONE,
                                     NULL, this, _pstg, (void **)&poleCopy);
            TraceMsg(DM_BINDAPPHACK, "_PostBindAppHack OleCreateFromData(IOleObject) returned %x", hres);

            if (SUCCEEDED(hres)) {
                _fCantSaveBack = TRUE;
                ATOMICRELEASE(_pole);
                _pole = poleCopy;
            }
        }

        pdt->Release();
    }
}

//
//  This function get the UserClassID from the object and opens the regkey
// for that CLSID and returns. If pdwAppHack is non-NULL AND CLSID is
// CLSID_HTMLDocument, we skip all and returns the default apphack flag.
// This is a perf optimization, but prevents us from setting browser
// flags for Trident, which is fine. (SatoNa)
//
HKEY _GetUserCLSIDKey(IOleObject* pole, const CLSID* pclsid, DWORD* pdwAppHack)
{
    HKEY hkey = NULL;   // assume error
    HRESULT hres;
    CLSID clsid = CLSID_NULL;
    if (pole) 
    {
        hres = pole->GetUserClassID(&clsid);
        //  GetUserClassID is optional, can return E_FAIL, then is defined to be
        //  the same as that returned by IPersist::GetClassID. cf, msdev documentation
        //  for GetUserClassID
        if (FAILED(hres))
        {
            hres = IUnknown_GetClassID(pole, &clsid);
        }
    }
    else if (pclsid)
    {
        clsid = *pclsid;
        hres = S_OK;
    }
    else
    {
        return NULL;
    }

    //
    // Notice that we check for two CLSIDs to see if this is MSHTML.
    //
    if (pdwAppHack)
    {
        static const IID IID_IVBOleObj =
            {0xb88c9640, 0x14e0, 0x11d0, { 0xb3, 0x49, 0x0, 0xa0, 0xc9, 0xa, 0xea, 0x82 } };
        IUnknown *   pVBOleObj;

        if (    IsEqualGUID(clsid, CLSID_HTMLDocument)
             || IsEqualGUID(clsid, CLSID_MHTMLDocument)
             || IsEqualGUID(clsid, CLSID_HTMLPluginDocument) )
        {
            TraceMsg(TF_SHDAPPHACK, "_GetUserCLSID this is Trident. Skip opening reg key");
            *pdwAppHack = BROWSERFLAG_NEVERERASEBKGND | BROWSERFLAG_SUPPORTTOP
                            | BROWSERFLAG_MSHTML;
            return NULL;
        }
        else if (pole && SUCCEEDED(pole->QueryInterface(IID_IVBOleObj, (void**)&pVBOleObj) ))
        {
            // If the object answers to IID_IVBOleObj, it's a VB doc object and shouldn't be cached.
            //
            pVBOleObj->Release();
            *pdwAppHack = BROWSERFLAG_DONTCACHESERVER;
        }

    }

    //
    // HACK: MSHTML.DLL does not implement GetUserClassID, but
    //  returns S_OK. That's why we need to check for CLSID_NULL.
    //
    if (SUCCEEDED(hres) && !IsEqualGUID(clsid, CLSID_NULL)) {
        TCHAR szBuf[50];        // 50 is enough for GUID
        SHStringFromGUID(clsid, szBuf, ARRAYSIZE(szBuf));

        TraceMsg(DM_BINDAPPHACK, "_PostBindAppHack GetUserClassID = %s", szBuf);
        TCHAR szKey[60];    // 60 is enough for CLSID\\{CLSID_XX}
        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("CLSID\\%s"), szBuf);

        if (RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hkey)!=ERROR_SUCCESS)
        {
            TraceMsg(DM_WARNING, "_GetUserCLSIDKey RegOpenKey(%s) failed", szKey);
            // I don't trust RegOpenKey.
            hkey = NULL;
        }
    }
    return hkey;
}


BOOL _GetAppHackKey(LPCTSTR pszProgID, DWORD* pdwData)
{
    BOOL fSuccess = FALSE;
    HKEY hkey;
    if (RegOpenKey(HKEY_CLASSES_ROOT, pszProgID, &hkey)==ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD cbSize = SIZEOF(*pdwData);
        if (RegQueryValueEx(hkey, TEXT("BrowserFlags"), NULL,
            &dwType, (LPBYTE)pdwData, &cbSize)==ERROR_SUCCESS
            && (dwType==REG_DWORD || (dwType==REG_BINARY && cbSize==SIZEOF(*pdwData))))
        {
            fSuccess = TRUE;
        }
        else
        {
            //
            // Unlike IE3, we make it absolutely sure that the type of object
            // has either "DocObject" key or "BrowseInPlace" key under the
            // ProgID. We can't rely on QI(IID_IOleDocument) because MFC 4.2
            // has a bug and returns S_OK to it. As far as I know, MS-Paint
            // and OmniPage pro are affected by this. We could individually
            // address each of them, but it's probably impossible to catch
            // all. This change has a small risk of breaking existing DocObject
            // server which does not have neither key. If we find such a
            // server, we'll address those individually (which is much easier
            // than covering all MFC apps). (SatoNa)
            //
            TCHAR ach[MAX_PATH];
            BOOL fBrowsable = FALSE;
            LONG cb = SIZEOF(ach);
            if (RegQueryValue(hkey, TEXT("DocObject"), ach, &cb) == ERROR_SUCCESS)
            {
                fBrowsable = TRUE;
            }
            else 
            {
                cb=SIZEOF(ach);
                if (RegQueryValue(hkey, TEXT("BrowseInPlace"), ach, &cb) == ERROR_SUCCESS)
                {
                    fBrowsable = TRUE;
                }
            }

            if (!fBrowsable) {
                TraceMsg(DM_WARNING, "_GetAppHackKey this is neither DocObject or BrowseInPlace");
                *pdwData = BROWSERFLAG_DONTINPLACE;
            }
        }
        RegCloseKey(hkey);
    }
    return fSuccess;
}


void GetAppHackFlags(IOleObject* pole, const CLSID* pclsid, DWORD* pdwAppHack)
{
    HKEY hkey = _GetUserCLSIDKey(pole, pclsid, pdwAppHack);
    if (hkey)
    {
        TCHAR szValue[MAX_PATH];
        LONG cb = SIZEOF(szValue);
        if (RegQueryValue(hkey, TEXT("ProgID"), szValue, &cb) == ERROR_SUCCESS)
        {
            //
            // First, check if we have an BrowserFlags flag in the registry.
            // If there is, use it. Otherwise, try hard-coded progIDs as
            // we did in IE 3.0
            //
            _GetAppHackKey(szValue, pdwAppHack);
            if (!(*pdwAppHack & BROWSERFLAG_REPLACE)) {
                typedef struct _APPHACK {
                    LPCTSTR pszProgID;
                    DWORD   dwAppHack;
                } APPHACK;

                //
                // We no longer need to disable in-place activation of
                // MS-PAINT because we look for "BrowseInPlace" or
                // "DocObject" key
                //
                // { "Paint.Picture", BROWSERFLAG_DONTINPLACE },
                //
                const static APPHACK s_aah[] = {
                    { TEXT("Excel.Sheet.5"), BROWSERFLAG_OPENCOPY },
                    { TEXT("Excel.Chart.5"), BROWSERFLAG_OPENCOPY },
                    { TEXT("SoundRec"), BROWSERFLAG_OPENVERB },
                    { TEXT("Word.Document.6"), BROWSERFLAG_SETHOSTNAME },
                    { TEXT("Word.Document.8"), BROWSERFLAG_DONTUIDEACTIVATE | BROWSERFLAG_SETHOSTNAME },
                    { TEXT("PowerPoint.Show.8"), BROWSERFLAG_DONTUIDEACTIVATE | BROWSERFLAG_PRINTPROMPTUI },
                    { TEXT("Excel.Sheet.8"), BROWSERFLAG_DONTDEACTIVATEMSOVIEW | BROWSERFLAG_INITNEWTOKEEP },
                    { TEXT("Excel.Chart.8"), BROWSERFLAG_DONTDEACTIVATEMSOVIEW | BROWSERFLAG_INITNEWTOKEEP },
                    { TEXT("ABCFlowCharter6.Document"), BROWSERFLAG_DONTINPLACE },
                    { TEXT("ABCFlowCharter7.Document"), BROWSERFLAG_DONTINPLACE },
                    { TEXT("FlowCharter7.Document"), BROWSERFLAG_DONTINPLACE },
                    { TEXT("ChannelFile"), BROWSERFLAG_DONTAUTOCLOSE },
                    { TEXT("Visio.Drawing.5"), BROWSERFLAG_ENABLETOOLSBTN | BROWSERFLAG_SAVEASWHENCLOSING },
                    { TEXT("Visio.Drawing.4"), BROWSERFLAG_ENABLETOOLSBTN | BROWSERFLAG_SAVEASWHENCLOSING }
                };
                const static TCHAR s_ActiveMoveCtx[] = TEXT("AMOVIE.ActiveMovieControl");

                if (!StrCmpN(szValue, s_ActiveMoveCtx, ARRAYSIZE(s_ActiveMoveCtx)-1))
                {
                    *pdwAppHack = BROWSERFLAG_DONTAUTOCLOSE;
                }
                else
                {
                    for (int i=0; i<ARRAYSIZE(s_aah); i++) {
                        if (StrCmp(szValue, s_aah[i].pszProgID)==0)
                        {
                            *pdwAppHack |= s_aah[i].dwAppHack;
                            break;
                        }
                    }
                }
            }

            TraceMsg(DM_BINDAPPHACK, "_GetAppHack ProgID=%s, *pdwAppHack=%x",
                     szValue, *pdwAppHack);

        } else {
            TraceMsg(DM_BINDAPPHACK, "_GetAppHack RegQueryValue(ProgID) failed");
        }

        RegCloseKey(hkey);
    }
}

DWORD CDocObjectHost::_GetAppHack(void)
{
    ASSERT(_pole);
    if (!_fHaveAppHack && _pole)
    {
        _dwAppHack = 0;     // Assume no hack
        _fHaveAppHack = TRUE;
        ::GetAppHackFlags(_pole, NULL, &_dwAppHack);
    }
    return _pole ? _dwAppHack : 0;
}

void CDocObjectHost::_PostBindAppHack(void)
{
    _GetAppHack();

    if (_fAppHackForExcel()) {
        _AppHackForExcel95();
    }
}


//
// This member binds to the object specified by a moniker.
//
HRESULT CDocObjectHost::_BindSync(IMoniker* pmk, IBindCtx* pbc, IShellView* psvPrev)
{
    ASSERT(pbc || !_pole);

    HRESULT hres = S_OK;
    ASSERT(_pole==NULL);

    // Check if we are in the middle of asynchronous binding
    if (_bsc._fBinding)
    {
        // Yes, wait until it's done or canceled/stopped
        URLMSG(TEXT("_Bind called in the middle of async-binding. Wait in a message loop"));
        while(_bsc._fBinding)
        {
           MSG msg;
           if (GetMessage(&msg, NULL, 0, 0))
           {
               TranslateMessage(&msg);
               DispatchMessage(&msg);
           }
        }

        if (!_pole)
        {
            hres = E_FAIL;      // Get the error code from OnStopBinding
        }
    }
    else
    {
        // No, bind synchronously
        URLMSG(TEXT("_Bind. Performing syncronous binding"));
        hres = pmk->BindToObject(pbc, NULL, IID_IOleObject, (void **)&_pole);
    }

    TraceMsg(0, "sdv TR : _Bind -- pmk->BindToObject(IOleObject) returned %x", hres);

    _OnBound(hres);

    return hres;
}

void CDocObjectHost::_OnBound(HRESULT hres)
{
    if (SUCCEEDED(hres)) {
        _PostBindAppHack();
        _InitOleObject();
    }
}

//
//  This function returns TRUE if the specified file's open command is
// associated with "explorer.exe" or "iexplore.exe".
//
// NOTES: It does not check if the "open" command is actually the default
//  or not, but that's sufficient in 99.99 cases.
//
BOOL IsAssociatedWithIE(LPCWSTR szPath)
{
    LPCTSTR pszExtension = PathFindExtension(szPath);

    BOOL bRet = FALSE;
    TCHAR szBuf[MAX_PATH];
    TCHAR szExt[_MAX_EXT];
    DWORD cchBuf = ARRAYSIZE(szBuf);

    if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_COMMAND, szExt, TEXT("open"), szBuf, &cchBuf)))
    {
        TraceMsg(TF_SHDBINDING, "IsAssociatedWithIE(%s) found %s as open command", szPath, szBuf);
        LPCTSTR pszFound;
        if ( (pszFound=StrStrI(szBuf, IEXPLORE_EXE))
             || (pszFound=StrStrI(szBuf, EXPLORER_EXE)) )
        {
            if (pszFound==szBuf || *(pszFound - 1)==TEXT('\\'))
            {
                bRet = TRUE;
            }
        }
    }
    TraceMsg(DM_SELFASC, "IsAssociatedWithIE(%s) returning %d", szPath, bRet);

    return bRet;
}


HRESULT CDocObjectHost::_MayHaveVirus(REFCLSID rclsid)
{
    //
    // We'll call this function twice if the file is associated
    // with a bogus CLSID (such as ImageComposer).
    //
    if (_fConfirmed)
    {
        TraceMsg(TF_SHDAPPHACK, "CDOH::_MayHaveVirus called twice. Return S_OK");
        return S_OK;
    }

    TraceMsg(TF_SHDPROGRESS, "DOH::_MayHaveVirus called");

    LPWSTR pwzProgID = NULL;
    HRESULT hresT = E_FAIL;

    if (SUCCEEDED(ProgIDFromCLSID(rclsid, &pwzProgID)))
    {
        if (   StrCmpI(pwzProgID, TEXT("htmlfile")) != 0
            && StrCmpI(pwzProgID, TEXT("htmlfile_FullWindowEmbed")) != 0
            && StrCmpI(pwzProgID, TEXT("mhtmlfile")) != 0
            && StrCmpI(pwzProgID, TEXT("xmlfile")) != 0
            && StrCmpI(pwzProgID, TEXT("xslfile")) != 0)
        {
            TCHAR   szURL[MAX_URL_STRING];
            TCHAR * pszURL = szURL;

            hresT = _GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE);

            if (SUCCEEDED(hresT))
            {
                UINT uRet = IDOK;

                if (_PicsProcBase._fbPicsWaitFlags || !_PicsProcBase._fPicsAccessAllowed)
                {
                    _PicsProcBase._fbPicsWaitFlags &= ~(PICS_WAIT_FOR_INDOC | PICS_WAIT_FOR_END);   /* indoc ratings only on htmlfile */
                    TraceMsg(DM_PICS, "CDOH::_MayHaveVirus found non-HTML, waitflags now %x", (DWORD)_PicsProcBase._fbPicsWaitFlags);
                    uRet = _PicsProcBase._PicsBlockingDialog();
                }
                
                if (uRet == IDOK)
                {
                    TraceMsg(TF_SHDPROGRESS, "DOH::_MayHaveVirus calling MayOpenSafeDialogOpenDialog(%s)", pwzProgID);

                    if (_bsc._pszRedirectedURL && *_bsc._pszRedirectedURL)
                        pszURL = _bsc._pszRedirectedURL;

                    IUnknown * punk;
                    BOOL  fDisableOpen = TRUE;
                    LPCTSTR pszExt = NULL;

                    if (_bsc._pszCacheFileName)
                        pszExt = PathFindExtension(_bsc._pszCacheFileName);
                    else if (pszURL)
                        pszExt = PathFindExtension(pszURL);

                    if (pszExt)
                    {
                        TCHAR szClassName[MAX_PATH];
                        DWORD cbSize = SIZEOF(szClassName);

                        // if the ProgIDs don't match then disable the open button
                        if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szClassName, &cbSize))
                            fDisableOpen = StrCmpI(pwzProgID, szClassName);
                    }

                    QueryInterface(IID_IUnknown, (void**)&punk);

                    uRet = MayOpenSafeOpenDialog(_hwnd, pwzProgID, pszURL, _bsc._pszCacheFileName, NULL, _uiCP, punk, _pmsoctBrowser, fDisableOpen);

                    ATOMICRELEASE(punk);

                    _fCalledMayOpenSafeDlg = TRUE;
                }

                switch(uRet)
                {
                case IDIGNORE:
                    //
                    // allow the safeopen dlg to pop up later if necessary
                    //
                    _fCalledMayOpenSafeDlg = FALSE;
                    _fConfirmed = FALSE;
                    break;  // continue download

                case IDOK:
                    //
                    // Set this flag to avoid poppping this dialog box twice.
                    //
                    _fConfirmed = TRUE;
                    break;  // continue download

                case IDD_SAVEAS:
                    IUnknown *punk;
                    hresT = QueryInterface(IID_IUnknown, (void**)&punk);

                    if(SUCCEEDED(hresT))
                    {
                        CDownLoad_OpenUI(_pmkCur, _bsc._pbc, FALSE, TRUE, NULL, NULL, NULL, NULL, NULL, _bsc._pszRedirectedURL, _uiCP, punk);
                        punk->Release();
                    }
                    // fall through to abort binding.

                case IDCANCEL:
                    hresT = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    break;
                }
            }
            else
            {
                TraceMsg(DM_ERROR, "DOH::_MayHaveVirus _GetCurrentPage failed %x", hresT);
            }
        }
        else
        {
            TraceMsg(TF_SHDPROGRESS, "DOH::_MayHaveVirus this is htmlfile -- don't call MayOpenSafeDialogOpenDialog");
            _fPicsBlockLate = TRUE;
        }

        OleFree(pwzProgID);
    }

    return hresT;
}

STDMETHODIMP CDocObjectHost::SaveObject(void)
{
    TraceMsg(0, "sdv TR: CDOV::SaveObject called");
    // Implemente it later.
    return S_OK;
}

STDMETHODIMP CDocObjectHost::GetMoniker(DWORD dwAssign,
    DWORD dwWhichMoniker,
    IMoniker **ppmk)
{
    HRESULT hres = E_INVALIDARG;
    *ppmk = NULL;
    TraceMsg(TF_SHDBINDING, "CDOH::GetMoniker called dwWhichMoniker=%x", dwWhichMoniker);

    switch(dwWhichMoniker)
    {
    case OLEWHICHMK_OBJREL:
    case OLEWHICHMK_OBJFULL:
        if (_pmkCur)
        {
            *ppmk = _pmkCur;
            _pmkCur->AddRef();
            hres = S_OK;
        }
        else
        {
            hres = E_UNEXPECTED;
        }
        break;
    }

    return hres;
}

STDMETHODIMP CDocObjectHost::GetContainer(
    IOleContainer **ppContainer)
{
    //  According to CKindel, we should implement this method
    //  as the way for a DocObject to access IDispatch interface of
    //  the container (i.e., frame). I'm currently thinking leaving
    //  all it's non-IUnknown memeber unimplemented. If there is no
    //  need to enumerates objects, we can simply QI from IShellBrowser
    //  to IOleContainer and return it. (SatoNa)
    //
    // NOTE: If trident calls this after DestroyHostWindow, we have nothing
    //  to give out. Hopefully this is not bad. (MikeSh)

    TraceMsg(0, "sdv TR: CDOV::GetContainer called");
    if (_psb)
        return _psb->QueryInterface(IID_IOleContainer, (void **)ppContainer);
    return E_FAIL;
}

STDMETHODIMP CDocObjectHost::ShowObject(void)
{
    TraceMsg(0, "sdv TR: CDOV::ShowObject called");
    return E_NOTIMPL;   // As specified in Kraig's document
}

STDMETHODIMP CDocObjectHost::OnShowWindow(BOOL fShow)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::OnShowWindow(%d) called (this=%x)", fShow, this);
    return E_NOTIMPL;   // As specified in Kraig's document
}

STDMETHODIMP CDocObjectHost::RequestNewObjectLayout(void)
{
    TraceMsg(0, "sdv TR: CDOV::RequestNewObjectLayout called");
    return E_NOTIMPL;   // As specified in Kraig's document
}



//
//  This is the standard way for non-active embedding to access
// the IHlinkFrame interface. We happened to use our QI to implement
// this, but the semantics of QueryService is different from QI.
// It does not necessary return the same object.
//
HRESULT CDocObjectHost::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if( IsEqualGUID(guidService, IID_IElementNamespaceTable) )
    {
        return IUnknown_QueryService(_pole, IID_IElementNamespaceTable, riid, ppvObj);
    }
    // In order for the context menu to work correctly inside IFrames, we
    // need to fail a certain query ONLY for IFrames on desktop.
    else if (!IsEqualGUID(guidService, CLSID_HTMLDocument) || !_IsImmediateParentDesktop(this, _psp))
    {
        //
        //  Delegate ISP to the _psb.
        //
        if (_psb && _psp)
            return _psp->QueryService(guidService, riid, ppvObj);
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

/*----------------------------------------------------------
Purpose: Remove the submenu(s) that are in _hmenuFrame
         from _hmenuBrowser.

*/
void CDocObjectHost::_RemoveFrameSubMenus(void)
{
    HMENU hmenu;

    ASSERT(IS_VALID_HANDLE(_hmenuBrowser, MENU));
    ASSERT(IS_VALID_HANDLE(_hmenuFrame, MENU));

    // The file menu in _hmenuBrowser consists of the file menu from
    // _hmenuFrame and IShellBrowser.  The part added by _hmenuFrame
    // includes a submenu (Send To), which must be removed before
    // _hmenuBrowser is destroyed.

    // We could just explicitly remove the Send To submenu.  But to
    // prevent the expensive bug hunt that it took to find this in the
    // first place, we're going to iterate thru the menu and, for
    // any submenus that belong to our template, we'll remove them.

    int citemFile = 0;
    UINT nID = 0;

    // Get the count of menu items in our template's File menu and
    // the ID of the first menu item.
    hmenu = GetMenuFromID(_hmenuFrame, FCIDM_MENU_FILE);
    if (hmenu)
    {
        citemFile = GetMenuItemCount(hmenu);
        nID = GetMenuItemID(hmenu, 0);
    }

    // Now look at the browser menu's File menu and, starting at
    // nID, remove any submenus.
    hmenu = GetMenuFromID(_hmenuBrowser, FCIDM_MENU_FILE);
    if (hmenu)
    {
        int citem = GetMenuItemCount(hmenu);
        int iTop;
        int i;

        // Where does our template file menu start?
        for (iTop = 0; iTop < citem; iTop++)
        {
            if (GetMenuItemID(hmenu, iTop) == nID)
            {
                // Start at where our template file menu ends and work up
                for (i = iTop + citemFile - 1; 0 < citemFile ; i--, citemFile--)
                {
                    HMENU hmenuSub = GetSubMenu(hmenu, i);

                    if (hmenuSub)
                        RemoveMenu(hmenu, i, MF_BYPOSITION);
                }
                break;
            }
        }
    }
}


/*----------------------------------------------------------
Purpose: Destroy the browser menu.

*/
HRESULT CDocObjectHost::_DestroyBrowserMenu(void)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::_DestroyBrowserMenu called");

    if (_hmenuBrowser) {
        // First remove any submenus that are held by other menus,
        // so we don't blow them away.

        _RemoveFrameSubMenus();

        if (EVAL(_psb)) {
            _psb->RemoveMenusSB(_hmenuBrowser);
        }

        DestroyMenu(_hmenuBrowser);
        _hmenuBrowser = NULL;
    }
    return S_OK;
}


HRESULT CDocObjectHost::_CreateBrowserMenu(LPOLEMENUGROUPWIDTHS pmw)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::_CreateBrowserMenu called");

    if (_hmenuBrowser) {
        return S_OK;
    }

    _hmenuBrowser = CreateMenu();
    if (!_hmenuBrowser) {
        return E_OUTOFMEMORY;
    }

    HRESULT hres = E_FAIL;

    // Allow IShellBrowser a chance to add its menus
    if (EVAL(_psb))
        hres = _psb->InsertMenusSB(_hmenuBrowser, pmw);

    // HACK: Win95 explorer returns E_NOTIMPL
    if (hres==E_NOTIMPL) {
        hres = S_OK;
    }

    if (SUCCEEDED(hres)) {
        // Load our menu if not loaded yet
        if (!_hmenuFrame)
        {
            _hmenuFrame = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(MID_FOCUS));
        }

        // Get the "File" sub-menu from the shell browser.
        MENUITEMINFO mii;
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_SUBMENU;

        if (GetMenuItemInfo(_hmenuBrowser, FCIDM_MENU_FILE, FALSE, &mii))
        {
            HMENU hmenuFileBrowse = mii.hSubMenu;

            // Merge our menuitems into this submenu.
            if (_hmenuFrame)
            {
                MENUITEMINFO miiItem;
                miiItem.cbSize = SIZEOF(MENUITEMINFO);
                miiItem.fMask = MIIM_SUBMENU;

                if (GetMenuItemInfo(_hmenuFrame, FCIDM_MENU_FILE, FALSE, &miiItem))
                {
                    TCHAR szItem[128];
                    HMENU hmenuFileT = miiItem.hSubMenu;
                    UINT citem = GetMenuItemCount(hmenuFileT);
                    for (int i=citem-1; i>=0 ; i--)
                    {
                        // We need to reset for each item.
                        miiItem.fMask = MIIM_STATE | MIIM_ID | MIIM_SUBMENU | MIIM_CHECKMARKS | MIIM_TYPE | MIIM_DATA;
                        miiItem.fType = MFT_STRING;
                        miiItem.cch = ARRAYSIZE(szItem);
                        miiItem.dwTypeData = szItem;
                        miiItem.dwItemData = 0;
                        if (GetMenuItemInfo(hmenuFileT, i, TRUE, &miiItem)) {
                            InsertMenuItem(hmenuFileBrowse, 0, TRUE, &miiItem);
                        }
                    }
                }
            }

            if (!IEHardened() && -1 != GetMenuState(hmenuFileBrowse, DVIDM_ADDSITE, MF_BYCOMMAND))
            {
                DeleteMenu(hmenuFileBrowse, DVIDM_ADDSITE, MF_BYCOMMAND);
            }

        }
        else
        {
            TraceMsg(TF_SHDUIACTIVATE, "DOH::_CreateBrowseMenu parent has no File menu (it's probably a browser OC)");
            ASSERT(0); // DocObject in OC is not supposed to call InsertMenus.
        }
    }

    DEBUG_CODE( _DumpMenus(TEXT("after _CreateBrowserMenu"), TRUE); )

    return hres;
}

//
// IOleInPlaceFrame::InsertMenus equivalent
//
HRESULT CDocObjectHost::_InsertMenus(
    /* [in] */ HMENU hmenuShared,
    /* [out][in] */ LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    HRESULT hres = S_OK;
    int nMenuOffset = 0;
    TraceMsg(TF_SHDUIACTIVATE, "DOH::InsertMenus called (this=%x)", this);

    // Assume error (no menu merge)
    lpMenuWidths->width[0] = 0;
    lpMenuWidths->width[2] = 0;
    lpMenuWidths->width[4] = 0;
    lpMenuWidths->width[5] = 0;

    // be extra safe and don't attempt menu merging if we're not top level
    if (_fHaveParentSite)
        return S_OK;

    OLEMENUGROUPWIDTHS mw = { {0} };
    hres = _CreateBrowserMenu(&mw);
    if (FAILED(hres)) {
        TraceMsg(DM_ERROR, "DOH::InsertMenus _CreateBrpwserMenu failed");
        return hres;
    }

    // Get the "File" sub-menu from the shell browser.
    MENUITEMINFO mii;
    TCHAR szSubMenu[128];

    mii.cbSize = SIZEOF(mii);
    mii.fMask = MIIM_SUBMENU|MIIM_TYPE|MIIM_ID;
    mii.cch = ARRAYSIZE(szSubMenu);
    mii.dwTypeData = szSubMenu;

    if (EVAL(GetMenuItemInfo(_hmenuBrowser, FCIDM_MENU_FILE, FALSE, &mii)))
    {
        ASSERT(szSubMenu == mii.dwTypeData);
        InsertMenuItem(hmenuShared, nMenuOffset++, TRUE, &mii);
        lpMenuWidths->width[0] = 1;
    }

    // Note that we need to re-initialize mii
    mii.cch = ARRAYSIZE(szSubMenu);

    if (EVAL(GetMenuItemInfo(_hmenuBrowser, FCIDM_MENU_EXPLORE, FALSE, &mii)))
    {
        // GetMenuItemInfo is recursive (why?).  The item it retrieves 
        // for FCIDM_MENU_EXPLORE can either be the top level Go menu, or if that
        // does not exist (NT5 case), it returns the Go To submenu of View.  
        // 
        // Code has been added in in the SetMenu implementations of Shell Browser 
        // and Dochost to detect the second case, because the menu dispatch list
        // does not recognize this kind of menu merging (80734).

        DeleteMenu(mii.hSubMenu, FCIDM_PREVIOUSFOLDER, MF_BYCOMMAND);
        InsertMenuItem(hmenuShared, nMenuOffset++, TRUE, &mii);
        lpMenuWidths->width[4]++;
    }

    mii.cch = ARRAYSIZE(szSubMenu);

    if (EVAL(GetMenuItemInfo(_hmenuBrowser, FCIDM_MENU_FAVORITES, FALSE, &mii)))
    {
        InsertMenuItem(hmenuShared, nMenuOffset++, TRUE, &mii);
        lpMenuWidths->width[4]++;
    }

    if (_hmenuFrame)
    {
        // Micro-merge the help menu.
        mii.cch = ARRAYSIZE(szSubMenu);

        if (EVAL(GetMenuItemInfo(_hmenuFrame, FCIDM_MENU_HELP, FALSE, &mii)))
        {
            InsertMenuItem(hmenuShared, nMenuOffset++, TRUE, &mii);
            lpMenuWidths->width[5]++;
        }
    }

    DEBUG_CODE( _DumpMenus(TEXT("after InsertMenus"), TRUE); )

    return hres;
}


/*----------------------------------------------------------
Purpose: Different objects may add their own Help menu (like
         Word and Excel).  This function detects if the object
         added its own help menu, or if it added items to our
         help menu, or if it is just using our help menu.

         If they added their own help menu, we remove ours.

*/
void CDocObjectHost::_CompleteHelpMenuMerge(HMENU hmenu)
{
    HMENU hmenuHelp;
    MENUITEMINFO mii;
    TCHAR szSubMenu[80];

    mii.cbSize = SIZEOF(mii);
    mii.fMask = MIIM_SUBMENU;

    // see if they added anything to our menu
    if (GetMenuItemInfo(_hmenuFrame, FCIDM_MENU_HELP, FALSE, &mii))
    {
        hmenuHelp = mii.hSubMenu;
        int iMenuCount = GetMenuItemCount(mii.hSubMenu);

        // Did the number of items in the help menu change?
        if (iMenuCount != HELP_ITEM_COUNT) {
            // Yes; that means they added something.  This has been micro-merged.
            _hmenuMergedHelp = mii.hSubMenu;
            _hmenuObjHelp = GetSubMenu(mii.hSubMenu, iMenuCount -1);
            goto Bail;
        }

        // Our menu didn't change.  Now find out if they added their own
        // help menu or if we ARE the help.  If they added their own, we need
        // to remove our help menu.

        _hmenuMergedHelp = NULL;
        _hmenuObjHelp = NULL;

        int iCount = GetMenuItemCount(hmenu) - 1;
        int i;
        for (i = iCount ; i >= 0 ; i--) {

            mii.fMask = MIIM_SUBMENU|MIIM_TYPE;
            mii.cch = ARRAYSIZE(szSubMenu);
            mii.dwTypeData = szSubMenu;

            if (GetMenuItemInfo(hmenu, i, TRUE, &mii)) {
                if (mii.hSubMenu == hmenuHelp) {

                    BOOL bRemove = FALSE;

                    if (iCount != i) {
                        // if we're not the last one, then we're not it
                        bRemove = TRUE;
                    } else {
                        // if we are the last one see if the help menu was added
                        // right before us
                        TCHAR szMenuTitle[80];
                        mii.cch = ARRAYSIZE(szMenuTitle);
                        mii.dwTypeData = szMenuTitle;
                        if (GetMenuItemInfo(hmenu, i-1, TRUE, &mii)) {
                            if (!StrCmpI(szMenuTitle, szSubMenu)) {
                                // same menu string yank ours
                                bRemove = TRUE;
                            }
                        }
                    }

                    if (bRemove) {
                        RemoveMenu(hmenu, i, MF_BYPOSITION);
                    }
                }
            }
        }
    }

Bail:;
    DEBUG_CODE( _DumpMenus(TEXT("after _CompleteHelpMenuMerge"), TRUE); )
}


//
// IOleInPlaceFrame::SetMenu equivalent
//
HRESULT CDocObjectHost::_SetMenu(
    /* [in] */ HMENU hmenuShared,           OPTIONAL
    /* [in] */ HOLEMENU holemenu,           OPTIONAL
    /* [in] */ HWND hwndActiveObject)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::SetMenus(%x) called (this=%x)",
             hmenuShared, this);

    // be extra safe and don't attempt menu merging if we're not top level
    if (_fHaveParentSite)
        return S_OK;

    // A NULL hmenuShared means to reinstate the container's original menu.
    if (hmenuShared)
    {
        // Clean up duplicate help menus
        _CompleteHelpMenuMerge(hmenuShared);
    }

    // Simply forwarding it to IShellBrowser
    _hmenuSet = hmenuShared;
    HRESULT hres = E_FAIL;
    if (EVAL(_psb))
        hres = _psb->SetMenuSB(hmenuShared, holemenu, hwndActiveObject);

    if (SUCCEEDED(hres))
    {
        // need to tell the shell browser that we want doc obj style menu merging
        if (_pmsoctBrowser)
            _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_ACTIVEOBJECTMENUS, 0, NULL, NULL);

        // Compose our list of object/frame menus, so our menuband
        // can dispatch the messages correctly.  Essentially this is
        // the same as the contents of holemenu, but since we don't
        // have access to the internal struct, we must derive this
        // info ourselves.
        _menulist.Set(hmenuShared, _hmenuBrowser);

        if (_hmenuMergedHelp)
            _menulist.RemoveMenu(_hmenuMergedHelp);

        if (_hmenuObjHelp)
            _menulist.AddMenu(_hmenuObjHelp);

        _hmenuCur = hmenuShared;
        HWND hwndFrame;
        _psb->GetWindow(&hwndFrame);

        // 80734: Was the Go To menu taken from the View menu and grafted onto the
        // main menu by DocHost?  The menulist won't detect this graft, so we have
        // to check ourselves and make sure it's not marked as belonging to the 
        // docobject.
        //
        // This test is duplicated in CShellBrowser2::SetMenuSB

        MENUITEMINFO mii;
        mii.cbSize = SIZEOF(mii);
        mii.fMask = MIIM_SUBMENU;

        if (hmenuShared && _hmenuBrowser && 
            GetMenuItemInfo(hmenuShared, FCIDM_MENU_EXPLORE, FALSE, &mii))
        {
            HMENU hmenuGo = mii.hSubMenu;

            if (GetMenuItemInfo(_hmenuBrowser, FCIDM_MENU_EXPLORE, FALSE, &mii) &&
                mii.hSubMenu == hmenuGo && _menulist.IsObjectMenu(hmenuGo))
            {
                _menulist.RemoveMenu(hmenuGo);
            }
        }

        // (scotth): why are we calling this, since this isn't compatible
        // with menubands?  That's the whole reason we have _menulist.
        hres = OleSetMenuDescriptor(holemenu, hwndFrame, hwndActiveObject, &_dof, _ActiveObject());
    }

    DEBUG_CODE( _DumpMenus(TEXT("after SetMenu"), TRUE); )

    return hres;
}


/*----------------------------------------------------------
Purpose: Returns TRUE if the given menu belongs to the browser
         (as opposed to the object)

*/
BOOL CDocObjectHost::_IsMenuShared(HMENU hmenu)
{
    ASSERT(hmenu);

    // (scotth): can we use _menulist here? (it would be faster)

    if (_hmenuBrowser) {
        for (int i = GetMenuItemCount(_hmenuBrowser) - 1 ; i >= 0; i--) {
            if (GetSubMenu(_hmenuBrowser, i) == hmenu)
                return TRUE;
        }
    }

    // We have to special case the help menu.  It's possible that the
    // help menu in the shared menu actually came from _hmenuFrame
    // (not _hmenuBrowser).  We need to detect this case, otherwise
    // the help menu gets destroyed but it is still referenced in
    // _hmenuFrame.

    MENUITEMINFO mii;

    mii.cbSize = SIZEOF(mii);
    mii.fMask = MIIM_SUBMENU;

    ASSERT(IS_VALID_HANDLE(_hmenuFrame, MENU));

    // Is this our help menu from _hmenuFrame?
    if (GetMenuItemInfo(_hmenuFrame, FCIDM_MENU_HELP, FALSE, &mii) &&
        mii.hSubMenu == hmenu)
    {
        // Yes
        return TRUE;
    }

    return FALSE;
}

//
// IOleInPlaceFrame::RemoveMenus equivalent
//
HRESULT CDocObjectHost::_RemoveMenus(/* [in] */ HMENU hmenuShared)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::RemoveMenus called (this=%x)", this);

    // be extra safe and don't attempt menu merging if we're not top level
    if (_fHaveParentSite)
        return S_OK;

    ASSERT(GetMenuItemCount(hmenuShared) != (UINT)-1);

    //
    // It is ok to simply remove sub-menus here.
    // because ours are shared with the _hmenuBrowser
    // and destroying that below will take care of cleanup.
    // However, we need to only remove menus that are ours.
    //
    for (int i = (int)GetMenuItemCount(hmenuShared) - 1 ; i >= 0; i--)
    {
        // TraceMsg(0, "sdv TR - ::RemoveMenus calling RemoveMenu(0)");
        HMENU hmenu = GetSubMenu(hmenuShared, i);

        if (hmenu && _IsMenuShared(hmenu)) {
            RemoveMenu(hmenuShared, i, MF_BYPOSITION);
        }
    }

    // TraceMsg(0, "sdv TR - ::RemoveMenus exiting");
    return S_OK;
}

//
// IOleInPlaceFrame::SetStatusText equivalent
//
HRESULT CDocObjectHost::_SetStatusText(/* [in] */ LPCOLESTR pszStatusText)
{
    LPCOLESTR pszForward;

    if (_psb != NULL)
    {
        // if it's NULL or just "" then give precedence to
        // _strPriorityStatusText, otherwise we display
        // whatever we're given

        if (pszStatusText != NULL && pszStatusText[0] != TEXT('\0') ||
            _strPriorityStatusText == NULL)
        {
            pszForward = pszStatusText;
        }
        else
        {
            pszForward = _strPriorityStatusText;
        }

        _psb->SetStatusTextSB(pszForward);
    }

    // Always return S_OK or scripting will put up an error dialog.
    return S_OK;
}

void CDocObjectHost::_SetPriorityStatusText(LPCOLESTR pszPriorityStatusText)
{
    // if they gave us a new string, replace the old one,
    // otherwise just NULL out the old one

    if (_strPriorityStatusText != NULL)
    {
        SysFreeString(_strPriorityStatusText);
    }

    if (pszPriorityStatusText != NULL)
    {
        _strPriorityStatusText = SysAllocString(pszPriorityStatusText);
    }
    else
    {
        _strPriorityStatusText = NULL;
    }

    _SetStatusText(_strPriorityStatusText);
}

HRESULT CDocObjectHost::_EnableModeless(/* [in] */ BOOL fEnable)
{
    TraceMsg(0, "sdv TR - ::EnableModeless called");

    // Note that we used call _CancelPendingNavigation here.
    // We do it in CBaseBrowser:::EnableModelesSB intead. (Satona)

    // Simply forwarding it (which is not implemented)
    if (EVAL(_psb))
        return _psb->EnableModelessSB(fEnable);

    return E_FAIL;
}

HRESULT CDocObjectHost::TranslateHostAccelerators(LPMSG lpmsg)
{
    if (_hacc && ::TranslateAccelerator(_hwnd, _hacc, lpmsg)) {
        return S_OK;
    }
    return S_FALSE;
}

// IOleInPlaceFrame equivalent ::TranslateAccelerator
//  Forwarding it from DocObject -> Browser
HRESULT CDocObjectHost::_TranslateAccelerator(
    /* [in] */ LPMSG lpmsg,
    /* [in] */ WORD wID)
{
    // TranslateAccelerator goes to the guy with the focus first
    if (EVAL(_psb))
        if (S_OK == _psb->TranslateAcceleratorSB(lpmsg, wID))
            return S_OK;

#ifdef DEBUG
    if (lpmsg->message == WM_KEYDOWN) {
        TraceMsg(0, "CDocObjectHost::TrAcc(UP) called");
    }
#endif
    return TranslateHostAccelerators(lpmsg);
}

// IViewObject
HRESULT CDocObjectHost::Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
    DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
    const RECTL *lprcBounds, const RECTL *lprcWBounds,
    BOOL (*pfnContinue)(ULONG_PTR), ULONG_PTR dwContinue)
{
    if (_pvo && lprcBounds)
    {
        if (_uState == SVUIA_DEACTIVATE && _hwnd)
        {
            HRESULT hresT = S_OK;
            RECT rcClient;
            GetClientRect(_hwnd, &rcClient);

            //
            // We should not call SetExtent with an empty rectangle.
            // It happens when we print a page with a floating frame.
            //
            if (rcClient.right > 0 && rcClient.bottom > 0)
            {
                SIZEL sizel;
                sizel.cx = MulDiv( rcClient.right, 2540, GetDeviceCaps( hdcDraw, LOGPIXELSX ) );
                sizel.cy = MulDiv( rcClient.bottom, 2540, GetDeviceCaps( hdcDraw, LOGPIXELSY ) );
                hresT = _pole->SetExtent(DVASPECT_CONTENT, &sizel);
            }

#ifdef DEBUG
            MoveToEx(hdcDraw, lprcBounds->left, lprcBounds->top, NULL);
            LineTo(hdcDraw, lprcBounds->right, lprcBounds->bottom);
            LineTo(hdcDraw, lprcBounds->left, lprcBounds->bottom);
            LineTo(hdcDraw, lprcBounds->right, lprcBounds->top);
#endif

            if (hresT!=S_OK) {
                TraceMsg(DM_ERROR, "CDOH::Draw SetExtent returns non S_OK %x", hresT);
            }
        }
        return _pvo->Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev,
            hdcDraw, lprcBounds, lprcWBounds, pfnContinue, dwContinue);
    }

    return OLE_E_BLANK;
}

HRESULT CDocObjectHost::GetColorSet(DWORD dwAspect, LONG lindex,
    void *pvAspect, DVTARGETDEVICE *ptd, HDC hicTargetDev,
    LOGPALETTE **ppColorSet)
{
    if (_pvo)
    {
        return _pvo->GetColorSet(dwAspect, lindex, pvAspect, ptd, hicTargetDev,
            ppColorSet);
    }

    if (ppColorSet)
        *ppColorSet = NULL;

    return S_FALSE;
}

HRESULT CDocObjectHost::Freeze(DWORD, LONG, void *, DWORD *pdwFreeze)
{
    if (pdwFreeze)
        *pdwFreeze = 0;

    return E_NOTIMPL;
}

HRESULT CDocObjectHost::Unfreeze(DWORD)
{
    return E_NOTIMPL;
}

HRESULT CDocObjectHost::SetAdvise(DWORD dwAspect, DWORD advf,
    IAdviseSink *pSink)
{
    if (dwAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    if (advf & ~(ADVF_PRIMEFIRST | ADVF_ONLYONCE))
        return E_INVALIDARG;

    if (pSink != _padvise)
    {
        ATOMICRELEASE(_padvise);

        _padvise = pSink;

        if (_padvise)
            _padvise->AddRef();
    }

    if (_padvise)
    {
        _advise_aspect = dwAspect;
        _advise_advf = advf;

        if (advf & ADVF_PRIMEFIRST)
            OnViewChange(_advise_aspect, -1);
    }
    else
        _advise_aspect = _advise_advf = 0;

    return S_OK;
}

HRESULT CDocObjectHost::GetAdvise(DWORD *pdwAspect, DWORD *padvf,
    IAdviseSink **ppSink)
{
    if (pdwAspect)
        *pdwAspect = _advise_aspect;

    if (padvf)
        *padvf = _advise_advf;

    if (ppSink)
    {
        if (_padvise)
            _padvise->AddRef();

        *ppSink = _padvise;
    }

    return S_OK;
}

// IAdviseSink
void CDocObjectHost::OnDataChange(FORMATETC *, STGMEDIUM *)
{
}

void CDocObjectHost::OnViewChange(DWORD dwAspect, LONG lindex)
{
    dwAspect &= _advise_aspect;

    if (dwAspect && _padvise)
    {
        IAdviseSink *pSink = _padvise;
        IUnknown *punkRelease;

        if (_advise_advf & ADVF_ONLYONCE)
        {
            punkRelease = pSink;
            _padvise = NULL;
            _advise_aspect = _advise_advf = 0;
        }
        else
            punkRelease = NULL;

        pSink->OnViewChange(dwAspect, lindex);

        if (punkRelease)
            punkRelease->Release();
    }
}

void CDocObjectHost::OnRename(IMoniker *)
{
}

void CDocObjectHost::OnSave()
{
}

void CDocObjectHost::OnClose()
{
    //
    // the doc object below went away so tell our advisee something changed
    //
    if (_padvise)
        OnViewChange(_advise_aspect, -1);
}

// IOleWindow
HRESULT CDocObjectHost::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;
    return S_OK;
}

HRESULT CDocObjectHost::ContextSensitiveHelp(BOOL fEnterMode)
{
    // NOTES: This is optional
    return E_NOTIMPL;   // As specified in Kraig's document (optional)
}

// IOleInPlaceSite
HRESULT CDocObjectHost::CanInPlaceActivate(void)
{
    OIPSMSG(TEXT("CanInPlaceActivate called"));
    return S_OK;
}

HRESULT CDocObjectHost::OnInPlaceActivate(void)
{
    OIPSMSG(TEXT("OnInPlaceActivate called"));
    return S_OK;
}

HRESULT CDocObjectHost::OnUIActivate( void)
{
    TraceMsg(TF_SHDUIACTIVATE, "-----------------------------------");
    TraceMsg(TF_SHDUIACTIVATE, "OH::OnUIActivate called (this=%x)", this);

    //
    //  Hide Office toolbars early enough so that it won't flash.
    //
    _HideOfficeToolbars();

    // REVIEW:
    //  Should we remove 'our' menu here instead?
    //
    // [Copied from OLE 2.01 Spec]
    //  The container should remove any UI associated with its own
    // activation. This is significant if the container is itself
    // an embedded object.
    //
    OIPSMSG(TEXT("OnUIActivate called"));
    if (EVAL(_psb))
    {
        // If we had the DocObject in SVUIA_INPLACEACTIVATE send it to SVUIA_ACTIVATE_FOCUS
        //
        // NOTES: Unlike IE3.0, we don't call _psv->UIActivate which has a side
        //  effect. We just update the _uState.
        //
        // _psv->UIActivate(SVUIA_ACTIVATE_FOCUS);
        //
        _uState = SVUIA_ACTIVATE_FOCUS;

        return _psb->OnViewWindowActive(_psv);
    }

    return E_FAIL;
}

void CDocObjectHost::_GetClipRect(RECT* prc)
{
    GetClientRect(_hwnd, prc);
    prc->right -= _bwTools.right;
    prc->bottom -= _bwTools.bottom;
}

IOleInPlaceSite* CDocObjectHost::_GetParentSite()
{
    IOleInPlaceSite* pparentsite = NULL; // the parent's inplace site
    if (_pwb)
    {
        _pwb->GetParentSite(&pparentsite);
    }
    return pparentsite;

}

HRESULT CDocObjectHost::GetWindowContext(
    /* [out] */ IOleInPlaceFrame **ppFrame,
    /* [out] */ IOleInPlaceUIWindow **ppDoc,
    /* [out] */ LPRECT lprcPosRect,
    /* [out] */ LPRECT lprcClipRect,
    /* [out][in] */ LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    OIPSMSG(TEXT("GetWindowContext called"));

    // Todo: verify that lpFrameInfo->cb is the correct size!

    // TraceMsg(0, "sdv TR - ::GetWindowContext called with lpFI->cb=%d (%d)",
    //           lpFrameInfo->cb, sizeof(*lpFrameInfo));
    *ppFrame = &_dof; AddRef();
    *ppDoc = NULL; // indicating that doc window == frame window

    _GetClipRect(lprcClipRect);

    lpFrameInfo->fMDIApp = FALSE;

    //
    //  If the frame has IOleInPlaceUIWindow (both IE and Shell have),
    // return that hwnd as hwndFrame so that OLE's menu dispatching
    // code works correctly.
    //
    _dof.GetWindow(&lpFrameInfo->hwndFrame);

    //
    //  We need to find out (from SriniK or KraigB), what is the
    //  implecation of this accelerator. Dealing with Word, it seems that
    //  Word does not call our TranslateAccelerator at all, unless the key
    //  stroke is the accelerator. If that's the spec. (of DocObject),
    //  there is no way to process the accelerator of the browser.
    //
    lpFrameInfo->haccel = _hacc;

    if (!SHRestricted(REST_NOFILEMENU))
    {
#ifdef DEBUG
        lpFrameInfo->cAccelEntries = DBG_ACCELENTRIES_WITH_FILEMENU; // WARNING: see shdocvw.rc, ACCELL_DOCVIEW
#else
        lpFrameInfo->cAccelEntries = OPT_ACCELENTRIES_WITH_FILEMENU; // WARNING: see shdocvw.rc, ACCELL_DOCVIEW
#endif
    }
    else
    {
#ifdef DEBUG
        lpFrameInfo->cAccelEntries = DBG_ACCELENTRIES; // WARNING: see shdocvw.rc, ACCELL_DOCVIEW
#else
        lpFrameInfo->cAccelEntries = OPT_ACCELENTRIES; // WARNING: see shdocvw.rc, ACCELL_DOCVIEW
#endif
    }

    *lprcPosRect = _rcView;
    return S_OK;
}

HRESULT CDocObjectHost::Scroll(
    /* [in] */ SIZE scrollExtant)
{
    TraceMsg(0, "sdv TR - ::Scroll called");
    return E_NOTIMPL;   // As specified in Kraig's document
}

HRESULT CDocObjectHost::OnUIDeactivate(
    /* [in] */ BOOL fUndoable)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOH::OnUIDeactivate called (this=%x)", this);

    DEBUG_CODE( _DumpMenus(TEXT("on OnUIDeactivate"), TRUE); )

    if (_hmenuSet) {
        OIPSMSG(TEXT("OnUIDeactivate We need to SetMenu(NULL, NULL, NULL)"));
        _SetMenu(NULL, NULL, NULL);
    }

    return S_OK;
}

HRESULT CDocObjectHost::OnInPlaceDeactivate( void)
{
    OIPSMSG(TEXT("OnInPlaceDeactivate called"));
    return S_OK;
}


HRESULT CDocObjectHost::DiscardUndoState( void)
{
    TraceMsg(0, "sdv TR - ::DiscardUndoState called");
    return S_OK;
}

HRESULT CDocObjectHost::DeactivateAndUndo( void)
{
    TraceMsg(0, "sdv TR - ::DeactivateAndUndo called");
    return S_OK;
}

HRESULT CDocObjectHost::OnPosRectChange(
    /* [in] */ LPCRECT lprcPosRect)
{
    return E_NOTIMPL;   // As specified in Kraig's document
}

HRESULT CDocObjectHost::OnInPlaceActivateEx(
    /* [out] */ BOOL __RPC_FAR *pfNoRedraw,
    /* [in] */ DWORD dwFlags)
{
    OIPSMSG(TEXT("OnInPlaceActivateEx called"));
    return S_OK;
}

HRESULT CDocObjectHost::OnInPlaceDeactivateEx(
    /* [in] */ BOOL fNoRedraw)
{
    OIPSMSG(TEXT("OnInPlaceDeactivateEx called"));
    return S_OK;
}

HRESULT CDocObjectHost::RequestUIActivate( void)
{
    if (_pWebOCInPlaceSiteEx)
        return _pWebOCInPlaceSiteEx->RequestUIActivate();
    else
        return TRUE;
}

void CDocObjectHost::_OnNotify(LPNMHDR lpnm)
{
    switch(lpnm->code) {

    case TBN_BEGINDRAG:
#define ptbn ((LPTBNOTIFY)lpnm)
        _OnMenuSelect(ptbn->iItem, 0, NULL);
        break;
    }
}

void MapAtToNull(LPTSTR psz)
{
    while (*psz)
    {
        if (*psz == TEXT('@'))
        {
            LPTSTR pszNext = CharNext(psz);
            *psz = 0;
            psz = pszNext;
        }
        else
        {
            psz = CharNext(psz);
        }
    }
}

void BrowsePushed(HWND hDlg)
{
    TCHAR szText[MAX_PATH];
    DWORD cchText = ARRAYSIZE(szText);
    TCHAR szFilter[MAX_PATH];
    TCHAR szTitle[MAX_PATH];
    LPITEMIDLIST pidl;
    LPCITEMIDLIST pidlChild;
    IShellFolder * pSF;

    // load the filter and then replace all the @ characters with NULL.  The end of the string will be doubly
    // null-terminated
    MLLoadShellLangString(IDS_BROWSEFILTER, szFilter, ARRAYSIZE(szFilter));
    MapAtToNull(szFilter);

    GetDlgItemText(hDlg, IDD_COMMAND, szText, ARRAYSIZE(szText));
    PathUnquoteSpaces(szText);

    // eliminate the "file://" stuff if necessary
    if (IsFileUrlW(szText))
        PathCreateFromUrl(szText, szText, &cchText, 0);

    MLLoadShellLangString(IDS_TITLE, szTitle, ARRAYSIZE(szTitle));

    if (GetFileNameFromBrowse(hDlg, szText, ARRAYSIZE(szText), NULL,
            TEXT(".htm"), szFilter, szTitle))
    {
        if (SUCCEEDED(IECreateFromPath(szText, &pidl)))
        {
            if (SUCCEEDED(IEBindToParentFolder(pidl, &pSF, &pidlChild)))
            {
                HWND hWndCombo = GetDlgItem(hDlg, IDD_COMMAND);

                COMBOBOXEXITEM cbexItem = {0};
                cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
                cbexItem.pszText = szText;
                cbexItem.cchTextMax = ARRAYSIZE(szText);
                cbexItem.iItem = -1;
                cbexItem.iImage = IEMapPIDLToSystemImageListIndex(pSF, pidlChild, &cbexItem.iSelectedImage);
                INT_PTR iPosition = SendMessage(hWndCombo, CBEM_INSERTITEM, (WPARAM)0, (LPARAM)(LPVOID)&cbexItem);
                SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM)iPosition, (LPARAM)0);
                pSF->Release();
            }
            ILFree(pidl);
        }
        else
        {
            PathUnquoteSpaces(szText);
            SetDlgItemText(hDlg, IDD_COMMAND, szText);
        }

        EnableOKButtonFromID(hDlg, IDD_COMMAND);
        // place the focus on OK
        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDOK), TRUE);
    }
}

struct SOpenDlg {
    TCHAR           szURL[MAX_URL_STRING];
    IAddressEditBox *paebox;   // Object that controls ComboBoxEx
    IBandSite       *pbs;   // Used in AEBox Init call (used as a Connection Site)
    IWinEventHandler *pweh;    // Used to funnel IDD_COMMAND messages to the AEBox
};

const DWORD c_mapCtrlToContextIds[] = { 0, 0 };

const DWORD c_aRunHelpIds[] = {
        IDD_ICON,             NO_HELP,
        IDD_PROMPT,           NO_HELP,
        IDD_RUNDLGOPENPROMPT, IDH_IE_RUN_COMMAND,
        IDD_COMMAND,          IDH_IE_RUN_COMMAND,
        IDD_BROWSE,           IDH_RUNBROWSE,
        IDC_ASWEBFOLDER,      IDH_WEB_FOLDERS_CKBOX,

        0, 0
};

HRESULT OpenDlgOnWebFolderOK(HWND hDlg, SOpenDlg * podlg)
{
    ASSERT(podlg);

    HRESULT hr = S_OK;

    HWND hWndOpenBox = GetDlgItem(hDlg, IDD_COMMAND);
    ComboBox_GetText(hWndOpenBox, podlg->szURL, ARRAYSIZE(podlg->szURL));
    PathRemoveBlanks(podlg->szURL);

//    int iScheme = GetUrlScheme(podlg->szURL);

//    if ((URL_SCHEME_HTTP != iScheme) &&
//        (URL_SCHEME_HTTPS != iScheme))
//    {
        // no, we don't support that protocol!!
//        WCHAR wszMessage[MAX_PATH];
//        WCHAR wszTitle[MAX_PATH];
//        WCHAR wszErrorMessage[MAX_PATH + MAX_URL_STRING + 1];

//        MLLoadShellLangString(IDS_ERRORBADURL, wszMessage, ARRAYSIZE(wszMessage));
//        MLLoadShellLangString(IDS_ERRORBADURLTITLE, wszTitle, ARRAYSIZE(wszTitle));
//        wnsprintf(wszErrorMessage, ARRAYSIZE(wszErrorMessage), wszMessage, podlg->szURL);
//        MessageBox(hDlg, wszErrorMessage, wszTitle, MB_OK | MB_ICONERROR);
//        hr = E_FAIL;
//    }
    return hr;
}

HRESULT OpenDlgOnOK(HWND hDlg, SOpenDlg * podlg)
{
    ASSERT(podlg);

    HRESULT hr = S_OK;
    /*
        Try to use newer parsing code if we have an AddressEditBox object
    */
    if (podlg->paebox)
        hr = podlg->paebox->ParseNow(SHURL_FLAGS_NONE);
    else
    {
        HWND hWndOpenBox = GetDlgItem(hDlg, IDD_COMMAND);
        ComboBox_GetText(hWndOpenBox, podlg->szURL, ARRAYSIZE(podlg->szURL));
        PathRemoveBlanks(podlg->szURL);
    }

    return hr;
}

void CleanUpAutoComplete(SOpenDlg *podlg)
{
    ATOMICRELEASE(podlg->paebox);
    ATOMICRELEASE(podlg->pweh);
    ATOMICRELEASE(podlg->pbs);

    ZeroMemory((PVOID)podlg, SIZEOF(SOpenDlg));
}


BOOL_PTR CALLBACK CDocObjectHost::s_RunDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SOpenDlg* podlg = (SOpenDlg*)GetWindowLongPtr(hDlg, DWLP_USER);
    switch (uMsg)
    {
    case WM_DESTROY:
        SHRemoveDefaultDialogFont(hDlg);
        return FALSE;

    case WM_INITDIALOG:
    {
        ASSERT(lParam);

        HWND hWndOpenBox = GetDlgItem(hDlg, IDD_COMMAND);
        HWND hWndEditBox = (HWND)SendMessage(hWndOpenBox, CBEM_GETEDITCONTROL, 0,0);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        podlg = (SOpenDlg *)lParam;

        // cross-lang platform support
        SHSetDefaultDialogFont(hDlg, IDD_COMMAND);

        if (podlg->paebox)
        {
            if ( FAILED(podlg->paebox->Init(hWndOpenBox, hWndEditBox, AEB_INIT_DEFAULT | AEB_INIT_NOASYNC, podlg->pbs)) ||
                 FAILED(IUnknown_SetOwner(podlg->paebox, podlg->pbs)))
                CleanUpAutoComplete(podlg);
        }
        // this limit.
        SendMessage(hWndOpenBox, CB_LIMITTEXT, CBEMAXSTRLEN-1, 0L);

        EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
        if (SHRestricted(REST_NORUN))
            EnableWindow(GetDlgItem(hDlg, IDC_ASWEBFOLDER), FALSE); // disable open as web folder
            
        break;

    }

    case WM_HELP:
        SHWinHelpOnDemandWrap((HWND) ((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPTSTR) c_aRunHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        SHWinHelpOnDemandWrap((HWND) wParam, c_szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPTSTR) c_aRunHelpIds);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
       {
        case IDHELP:
            break;

        case IDD_BROWSE:
            BrowsePushed(hDlg);
            break;

        case IDD_COMMAND:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case CBN_SELCHANGE:
                break;

            case CBN_EDITCHANGE:
            case CBN_SELENDOK:
                if (podlg->pweh)
                    podlg->pweh->OnWinEvent(hDlg, uMsg, wParam, lParam, NULL);
                EnableOKButtonFromID(hDlg, IDD_COMMAND);
                break;

            default:
                if (podlg->pweh)
                    podlg->pweh->OnWinEvent(hDlg, uMsg, wParam, lParam, NULL);
                break;
            }
            break;

        case IDOK:
            {
                HWND hwndCheckBox = GetDlgItem(hDlg, IDC_ASWEBFOLDER);
                if (hwndCheckBox)
                {
                    LRESULT lrState = SendMessage(hwndCheckBox, BM_GETCHECK, 0, 0);
                    if (lrState == BST_CHECKED)
                    {
                        if (SUCCEEDED(OpenDlgOnWebFolderOK(hDlg, podlg)))
                            EndDialog(hDlg, IDC_ASWEBFOLDER);
                        break;
                    }
                    else if (FAILED(OpenDlgOnOK(hDlg, podlg)))
                        break;
                }
            }
            // Fall through to IDCANCEL to close dlg

        case IDCANCEL:
            EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void CDocObjectHost::_Navigate(LPCWSTR pwszURL)
{
    IWebBrowser2* pwb2;
    if (SUCCEEDED(IUnknown_QueryService(_psb, SID_SContainerDispatch, IID_IWebBrowser2, (void **)&pwb2)))
    {
        //
        // HACK: We are not passing BSTR, but LPWSTR, which
        //  will work as far as IWebBrowser2 can handle
        //  NULL-terminated string correctly.
        //
        pwb2->Navigate((BSTR)pwszURL, NULL, NULL, NULL, NULL);
        pwb2->Release();
    }
}


HRESULT CDocObjectHost::_PrepFileOpenAddrBand(IAddressEditBox ** ppaeb, IWinEventHandler ** ppweh, IBandSite ** ppbs)
{
    HRESULT hr;

    *ppaeb = NULL;
    *ppweh = NULL;
    *ppbs = NULL;

    //  If our CoCreateInstance fails, s_rundlgproc will know because paebox
    //  will be NULL
    hr = CoCreateInstance(CLSID_AddressEditBox, NULL, CLSCTX_INPROC_SERVER, IID_IAddressEditBox, (void **)ppaeb);
    if (EVAL(SUCCEEDED(hr)))
    {
        IServiceProvider *pspT;
        hr = (*ppaeb)->QueryInterface(IID_IWinEventHandler, (void **)ppweh);

        //  Travel up the object hierarchy, and obtain the same pointer that
        //  the address bar was ::Init'ed with
        //  WARNING: This is not optional.  The addressband will fault if this fails.
        if (EVAL(SUCCEEDED(hr) && _psp))
        {
            hr = _psp->QueryService(SID_SExplorerToolbar, IID_IServiceProvider, (void **)&pspT);
            // In framed cases, CBaseBrowser2::QueryService() will filter out SID_SExplorerToolbar
            // because it's afraid of Toolbars appearing in the frame.  We won't have that problem,
            // so we may need to go the TopLevelBrowser first and then ask around there.
            if (FAILED(hr))
            {
                IServiceProvider *pspT2;

                hr = _psp->QueryService(SID_STopLevelBrowser, IID_IServiceProvider, (void **)&pspT2);
                if (EVAL(SUCCEEDED(hr)))
                {
                    hr = pspT2->QueryService(SID_SExplorerToolbar, IID_IServiceProvider, (void **)&pspT);
                    pspT2->Release();
                }
            }

            if (EVAL(SUCCEEDED(hr)))
            {
                if (EVAL(SUCCEEDED(hr = pspT->QueryService(IID_IBandSite, IID_IBandSite, (void **)ppbs))))
                {
                    IDeskBand *pdbT;
                    // Had to include "ITBAR.H" to access CBIDX_ADDDRESS
// HACKHACK
#define CBIDX_ADDRESS           4
                    // If any of the following fails, I don't care because the MRU can be out of
                    // synch.
                    if (SUCCEEDED((*ppbs)->QueryBand(CBIDX_ADDRESS, &pdbT, NULL, NULL, 0)))
                    {
                        IUnknown_Exec(pdbT, &CGID_AddressEditBox, AECMDID_SAVE, 0, NULL, NULL);
                        pdbT->Release();
                    }
                }
                pspT->Release();
            }
        }

    }

    if (FAILED(hr))
    {
        ATOMICRELEASE(*ppaeb);
        ATOMICRELEASE(*ppweh);
        ATOMICRELEASE(*ppbs);
    }

    return hr;
}

void CDocObjectHost::_OnOpen(void)
{
    HWND hwndFrame;
    SOpenDlg odlg ={0};

    _psb->GetWindow(&hwndFrame);

    if (SHIsRestricted2W(_hwnd, REST_NoFileOpen, NULL, 0))
        return;

    if (EVAL(SUCCEEDED(_PrepFileOpenAddrBand(&(odlg.paebox), &odlg.pweh, &odlg.pbs))))
    {
        // TODO: Make it a helper member, which notifies up and down.
        _psb->EnableModelessSB(FALSE);

        INT_PTR iRet = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_RUN), hwndFrame, s_RunDlgProc, (LPARAM)&odlg);

        _psb->EnableModelessSB(TRUE);

        if (iRet==IDOK)
        {
            if (g_dwStopWatchMode)   // Perf mode to mark start time
                StopWatch_MarkSameFrameStart(hwndFrame);

            if (odlg.paebox)
                odlg.paebox->Execute(SHURL_EXECFLAGS_NONE);
            else
                _Navigate(odlg.szURL);
        }

        if (iRet == IDC_ASWEBFOLDER)
        {
            BSTR bstrUrl = SysAllocString(odlg.szURL);
            if (bstrUrl != NULL)
            {
                _NavigateFolder(bstrUrl);
                SysFreeString(bstrUrl);
            }
        }

        IUnknown_SetOwner(odlg.paebox, NULL);
    }

    // Cleanup ref counts
    CleanUpAutoComplete(&odlg);
}

void CDocObjectHost::_OnClose() const
{
    ASSERT(_pwb);

    if (!_HideBrowserBar())
    {
        HRESULT hr = E_FAIL;
        HWND    hwnd = NULL;
        IOleWindow * pOleWindow;

        if ( _pwb )
        {
            hr = _pwb->QueryInterface(IID_PPV_ARG(IOleWindow, &pOleWindow));
        }

        if (SUCCEEDED(hr))
        {
            pOleWindow->GetWindow(&hwnd);
            pOleWindow->Release();

            if ( hwnd )
            {
                PostMessage(hwnd, WM_CLOSE, 0, 0);
            }
        }
    }
}

BOOL CDocObjectHost::_HideBrowserBar() const
{
    ASSERT(_pwb);
    
    // Get the proxy browser. We only have
    // a proxy browser if we are in a band.
    //
    IShellBrowser * pPrxyBrowser;
    HRESULT hr = IUnknown_QueryService(_pwb,
                               SID_SProxyBrowser,
                               IID_IShellBrowser,
                               (void**)&pPrxyBrowser);
    if (SUCCEEDED(hr))
    {
        hr = IUnknown_ShowBrowserBar(_psb, CLSID_SearchBand, FALSE);
    }

    return (SUCCEEDED(hr) ? TRUE : FALSE);
}

void CDocObjectHost::_OnImportExport(HWND hwnd)
{
     // Decide if import/export is allowed here
    if (IsImportExportDisabled())
    {
        MLShellMessageBox(
                        hwnd, 
                        MAKEINTRESOURCE(IDS_EXPORT_DISABLED),
                        MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_FAV), 
                        MB_OK);
        return;
    }

    RunImportExportFavoritesWizard(hwnd);
}

void CDocObjectHost::_OnAddToSitesList(HWND hwnd, DWORD dwZone)
{
    HMODULE hmod = LoadLibrary(TEXT("inetcpl.cpl"));
    if(hmod)
    {
        BOOL (*pfnAddSitesDlg)(HWND, DWORD, LPCWSTR) = (BOOL (*)(HWND, DWORD, LPCWSTR))GetProcAddress(hmod, "LaunchAddSitesDialog");
        if(pfnAddSitesDlg)
        {
            LPOLESTR pszUrl;
            if (SUCCEEDED(_GetCurrentPageW(&pszUrl, TRUE)))
            {
                pfnAddSitesDlg(hwnd, dwZone, pszUrl);
                OleFree(pszUrl);
            }
        }
        FreeLibrary(hmod);
    }
}

UINT_PTR CALLBACK DocHostSaveAsOFNHook(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            /* Hide the "Save as Type" text box */
            CommDlg_OpenSave_HideControl(GetParent(hDlg), stc2);
            /* Hide the listbox with save type extensions */
            CommDlg_OpenSave_HideControl(GetParent(hDlg), cmb1);
            /* Hide the Open as read-only control */
            CommDlg_OpenSave_HideControl(GetParent(hDlg), chx1);
            break;
        }

        default:
                break;
    }
    return FALSE;
}

#define IDS_HELPURL_SUPPORT         IDS_HELPMSWEB+4
#define SZ_REGKEY_HELPURL_OVERRIDE  TEXT("Software\\Microsoft\\Internet Explorer\\Help_Menu_URLs")
#define SZ_REGVAL_HELPURL_SUPPORT   TEXT("Online_Support")
#define SZ_REGVAL_HELPURL_TEMPLATE  TEXT("%d")

void CDocObjectHost::_OnHelpGoto(UINT idRes)
{
    HRESULT hr = E_FAIL;
    WCHAR szURL[MAX_PATH];  // this is enough for our own

    // First try to get a copy from the registry because this is where Admins (with the IEAK) over ride
    // our default values.

    // We special case the Online_Support URL because it was supported in IE3.
    if (IDS_HELPURL_SUPPORT == idRes)
    {
        hr = URLSubRegQuery(SZ_REGKEY_HELPURL_OVERRIDE, SZ_REGVAL_HELPURL_SUPPORT, TRUE, szURL, ARRAYSIZE(szURL), URLSUB_ALL);
    }
    else
    {
        WCHAR szValue[MAX_PATH];

        wnsprintfW(szValue, ARRAYSIZE(szValue), SZ_REGVAL_HELPURL_TEMPLATE, (idRes - IDS_HELPMSWEB + 1));
        hr = URLSubRegQuery(SZ_REGKEY_HELPURL_OVERRIDE, szValue, TRUE, szURL, ARRAYSIZE(szURL), URLSUB_ALL);
    }

    if (FAILED(hr))
        hr = URLSubLoadString(NULL, idRes, szURL, ARRAYSIZE(szURL), URLSUB_ALL);

    if (SUCCEEDED(hr))
    {
        _Navigate(szURL);
    }
}

STDAPI_(void) IEAboutBox( HWND hWnd );


// WM_COMMAND from _WndProc - execs are going down
void CDocObjectHost::_OnCommand(UINT wNotify, UINT id, HWND hwndControl)
{
    if (_ShouldForwardMenu(WM_COMMAND, MAKEWPARAM(id, wNotify), (LPARAM)hwndControl))
    {
        _ForwardObjectMsg(WM_COMMAND, MAKEWPARAM(id, wNotify), (LPARAM)hwndControl);
        return;
    }

    switch(id)
    {
    case DVIDM_HELPTUTORIAL:
        _OnHelpGoto(IDS_HELPTUTORIAL);
        break;

    // ShabbirS (980917): BugFix# 34259 - Repair IE option.

    case DVIDM_HELPREPAIR:
        RepairIE();
        break;

    case DVIDM_HELPABOUT:
        IEAboutBox( _hwnd );
        break;

    case DVIDM_HELPSEARCH:
    {
        uCLSSPEC ucs;
        QUERYCONTEXT qc = { 0 };
        ucs.tyspec = TYSPEC_CLSID;
        ucs.tagged_union.clsid = CLSID_IEHelp;

        HRESULT hres = FaultInIEFeature(_hwnd, &ucs, &qc, FIEF_FLAG_FORCE_JITUI);

        if ( SUCCEEDED( hres ) )
        {
            // MLHtmlHelp runs on a separate thread and should therefore be
            // safe against the kinds of message loops problems indicated above

            ULONG_PTR uCookie = 0;
            SHActivateContext(&uCookie);
            MLHtmlHelp(_hwnd, TEXT("iexplore.chm > iedefault"), HH_DISPLAY_TOPIC, 0, ML_CROSSCODEPAGE);
            if (uCookie)
            {
                SHDeactivateContext(uCookie);
            }
        }
        else
        {
            TraceMsg( TF_WARNING, "CDocObjectHost::_OnCommand() - FaultInIEFeature() Failed with hr=0x%x!", hres );
        }
        break;
    }

    case DVIDM_DHFAVORITES:
        _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_ADDTOFAVORITES, OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
        break;

    case DVIDM_GOHOME:
    case DVIDM_GOSEARCH:
        {
            TCHAR szPath[MAX_URL_STRING];
            LPITEMIDLIST pidl;
            HRESULT hres = SHDGetPageLocation(_hwnd,
                                      (id==DVIDM_GOSEARCH) ? IDP_SEARCH : IDP_START,
                                      szPath, ARRAYSIZE(szPath), &pidl);
            if (SUCCEEDED(hres))
            {
                _psb->BrowseObject(pidl, SBSP_ABSOLUTE | SBSP_SAMEBROWSER);
                ILFree(pidl);
            }
            else
            {
                TCHAR szMessage[256];
                BOOL fSuccess = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                      NULL, hres, 0, szMessage, ARRAYSIZE(szMessage), NULL);
                if (!fSuccess)
                    szMessage[0] = 0;

                MLShellMessageBox(_hwnd,
                                MAKEINTRESOURCE(IDS_CANTACCESSDOCUMENT),
                                szPath, MB_OK | MB_SETFOREGROUND | MB_ICONSTOP, szMessage);
            }
        }
        break;

    case DVIDM_STOPDOWNLOAD:
        // We need to tell the container to cancel a pending navigation
        // if any. Notice that the Cancel button serves for two purposes:
        //  (1) canceling a pending navigation
        //  (2) cancel any downloading
        if (_psb)
            _CancelPendingNavigation(FALSE);
        goto TryDocument;

    case DVIDM_NEWWINDOW:
        // make sure the top level browser gets cloned, not an explorer bar
        IShellBrowser* psbTop;
        if (!SHIsRestricted2W(_hwnd, REST_NoOpeninNewWnd, NULL, 0)     &&
            !SHIsRestricted2W(_hwnd, REST_NoFileNew, NULL, 0) &&
            EVAL(SUCCEEDED(_psp->QueryService(SID_STopLevelBrowser, IID_IShellBrowser, (void **)&psbTop))) && psbTop)
        {
            BOOL fHandled = FALSE;

            if (_pWebOCUIHandler)
            {
                // Give the WebOC host a chance to handle this command, since it may
                // not want an IE window to be created

                if (S_OK == IUnknown_Exec(_pWebOCUIHandler, &CGID_DocHostCommandHandler, 
                     IDM_NEW_TOPLEVELWINDOW, 0, NULL, NULL))
                {
                    fHandled = TRUE;
                }
            }

            if (!fHandled)
            {
                // tell the top level browser to save its window size to the registry so 
                // that our new window can pick it up and cascade properly
                IUnknown_Exec(psbTop, &CGID_Explorer, SBCMDID_SUGGESTSAVEWINPOS, 0, NULL, NULL);
            
                psbTop->BrowseObject(&s_idNull, SBSP_RELATIVE|SBSP_NEWBROWSER);
                psbTop->Release();
            }
        }
        break;

    case DVIDM_OPEN:
        _OnOpen();
        break;

    case DVIDM_SAVE:
        if (!SHIsRestricted2W(_hwnd, REST_NoBrowserSaveAs, NULL, 0))
        {
            // There's a scenario where the XML MimeViewer, when aggregating Trident, answers "disabled" to 
            // OLECMDID_SAVE.  However, since we don't call QueryStatus on the ACCELERATOR key sequence,
            // we end up calling into Trident's IPersistFile::Save(), overwriting the XML file with the converted
            // HTML.
            //
            // The right thing to do is to QS and beep if disabled.
            //
            if (_dwAppHack & BROWSERFLAG_MSHTML)
            {
                if (_pmsot)
                {
                    OLECMD rgcmds[] = { { OLECMDID_SAVE, 0 }, };

                    _pmsot->QueryStatus(NULL, ARRAYSIZE(rgcmds), rgcmds, NULL);

                    if (!(rgcmds[0].cmdf & OLECMDF_ENABLED))
                    {
                        // If SAVE is disabled, provide user feedback.
                        MessageBeep(0);
                        break;
                    }
                }
            }
            _OnSave();
        }
        break;

    case DVIDM_DESKTOPSHORTCUT:
        IUnknown_Exec(_psb, &CGID_Explorer, SBCMDID_CREATESHORTCUT, 0, NULL, NULL);
        break;

    case DVIDM_SENDPAGE:
        IUnknown_Exec(_psb, &CGID_Explorer, SBCMDID_SENDPAGE, 0, NULL, NULL);
        break;

    case DVIDM_SENDSHORTCUT:
        IUnknown_Exec(_psb, &CGID_Explorer, SBCMDID_SENDSHORTCUT, 0, NULL, NULL);
        break;

    case DVIDM_NEWMESSAGE:
        if (FAILED(DropOnMailRecipient(NULL, 0))) 
        {
            SHRunIndirectRegClientCommand(_hwnd, NEW_MAIL_DEF_KEY);
        }
        break;

    case DVIDM_NEWPOST:
        SHRunIndirectRegClientCommand(_hwnd, NEW_NEWS_DEF_KEY);
        break;

    case DVIDM_NEWCONTACT:
        SHRunIndirectRegClientCommand(_hwnd, NEW_CONTACTS_DEF_KEY);
        break;

    case DVIDM_NEWAPPOINTMENT:
        SHRunIndirectRegClientCommand(_hwnd, NEW_APPOINTMENT_DEF_KEY);
        break;

    case DVIDM_NEWMEETING:
        SHRunIndirectRegClientCommand(_hwnd, NEW_MEETING_DEF_KEY);
        break;

    case DVIDM_NEWTASK:
        SHRunIndirectRegClientCommand(_hwnd, NEW_TASK_DEF_KEY);
        break;

    case DVIDM_NEWTASKREQUEST:
        SHRunIndirectRegClientCommand(_hwnd, NEW_TASKREQUEST_DEF_KEY);
        break;

    case DVIDM_NEWJOURNAL:
        SHRunIndirectRegClientCommand(_hwnd, NEW_JOURNAL_DEF_KEY);
        break;

    case DVIDM_NEWNOTE:
        SHRunIndirectRegClientCommand(_hwnd, NEW_NOTE_DEF_KEY);
        break;

    case DVIDM_CALL:
        SHRunIndirectRegClientCommand(_hwnd, NEW_CALL_DEF_KEY);
        break;

    case DVIDM_SAVEASFILE:
        //
        //  Handle the case where DocObject does not support "SaveAs"
        // and we have enabled the menuitem anyway.
        //
        if (SHIsRestricted2W(_hwnd, REST_NoBrowserSaveAs, NULL, 0))
            break;

        if (_pmsot)
        {
            OLECMD rgcmds[] = { { OLECMDID_SAVEAS, 0 }, };

            _pmsot->QueryStatus(NULL, ARRAYSIZE(rgcmds), rgcmds, NULL);

            ASSERT(rgcmds[0].cmdf & OLECMDF_ENABLED);
            if (!(rgcmds[0].cmdf & OLECMDF_ENABLED))
                _OnSaveAs();
            else
                goto TryDocument;
        }
        break;

    case DVIDM_IMPORTEXPORT:
        _OnImportExport(_hwnd);
        break;

    case DVIDM_HELPIESEC:
        _OnHelpGoto(IDS_HELPIESEC);
        break;

    case DVIDM_INTRANETSITES:
        _OnAddToSitesList(_hwnd, URLZONE_INTRANET);
        break;

    case DVIDM_TRUSTEDSITES:
        _OnAddToSitesList(_hwnd, URLZONE_TRUSTED);
        break;

    default:
        if (IsInRange(id, DVIDM_HELPMSWEB, DVIDM_HELPMSWEBLAST))
        {
            if (id == FCIDM_HELPNETSCAPEUSERS)
                SHHtmlHelpOnDemandWrap(_hwnd, TEXT("iexplore.chm > iedefault"), HH_DISPLAY_TOPIC, (DWORD_PTR) TEXT("lvg_nscp.htm"), ML_CROSSCODEPAGE);
            else
                _OnHelpGoto(IDS_HELPMSWEB + (id - DVIDM_HELPMSWEB));
        }
        else if (IsInRange(id, DVIDM_MSHTML_FIRST, DVIDM_MSHTML_LAST))
        {
            TraceMsg(DM_PREMERGEDMENU, "Processing merged menuitem %d", id - DVIDM_MSHTML_FIRST);
            ASSERT(_pcmdMergedMenu);
            if (_pcmdMergedMenu) {
                HRESULT hresT=_pcmdMergedMenu->Exec(&CGID_MSHTML, id - DVIDM_MSHTML_FIRST, 0, NULL, NULL);
                if (FAILED(hresT)) {
                    TraceMsg(DM_ERROR, "CDOH::_OnCommand _pcmdMergedMenu->Exec(%d) failed %x",
                             id - DVIDM_MSHTML_FIRST, hresT);
                }
            }
        }
        else if (IsInRange (id, DVIDM_MENUEXT_FIRST, DVIDM_MENUEXT_LAST))
        {
            // Menu Extensions
            IUnknown_Exec(_pBrowsExt, &CLSID_ToolbarExtButtons, id, 0, NULL, NULL);
        }
        else
        {
TryDocument:
            if (_pmsot)
            {
                // Check if we need to call object's Exec.
                UINT idMso = _MapToMso(id);
                if (idMso != (UINT)-1)
                {
                    // Yes. Call it.
                    _pmsot->Exec(NULL, idMso, OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
                }
                else if (id == DVIDM_PRINTFRAME)
                {
                    _pmsot->Exec(&CGID_ShellDocView, SHDVID_PRINTFRAME, OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
                }
            }
        }
        break;
    }
}

HRESULT CDocObjectHost::_OnSaveAs(void)
{
    HRESULT hres = S_OK;

    TraceMsg(DM_SAVEASHACK, "DOH::_OnSaveAs called");

    ASSERT(_pole);

    if (_dwAppHack & BROWSERFLAG_MSHTML)
    {
        SaveBrowserFile( _hwnd, _pole );
    }
    else // old dochost stuff
    {
        TCHAR szSaveTo[MAX_PATH];   // ok with MAX_PATH
        MLLoadString(IDS_DOCUMENT, szSaveTo, ARRAYSIZE(szSaveTo));
        TCHAR szDesktop[MAX_PATH];

        SHGetSpecialFolderPath(_hwnd, szDesktop, CSIDL_DESKTOPDIRECTORY, FALSE);

        OPENFILENAME OFN;
        OFN.lStructSize        = sizeof(OPENFILENAME);
        OFN.hwndOwner          = _hwnd;
        OFN.lpstrFileTitle     = 0;
        OFN.nMaxCustFilter     = 0;
        OFN.nFilterIndex       = 0;

        OFN.nMaxFile           = ARRAYSIZE(szSaveTo);
        OFN.lpfnHook           = DocHostSaveAsOFNHook;
        OFN.Flags              = 0L;/* for now, since there's no readonly support */
        OFN.lpstrTitle         = NULL;
        OFN.lpstrInitialDir    = szDesktop;

        OFN.lpstrFile = szSaveTo;
        OFN.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ENABLEHOOK | OFN_EXPLORER |
                    OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST;
        OFN.lpstrFilter      = NULL;
        OFN.lpstrCustomFilter = NULL;


        OFN.lpstrDefExt = TEXT("");     // no extension
        TCHAR szValue[MAX_PATH+1];      // +1 for for double-null
        TCHAR szExt[40];

        HKEY hkey = _GetUserCLSIDKey(_pole, NULL, NULL);
        if (hkey)
        {
            LONG cb = SIZEOF(szValue);
            if (RegQueryValue(hkey, TEXT("DefaultExtension"), szValue, &cb) == ERROR_SUCCESS)
            {
                TraceMsg(DM_SAVEASHACK, "DOH::_OnSaveAs DefExt is %s", szValue);

                // It is suposed to be like ".xls, Excel Workbook (*.xls)"
                if (szValue[0]==TEXT('.')) {
                    StrCpyN(szExt, szValue+1, ARRAYSIZE(szExt));
                    LPTSTR pszEnd = StrChr(szExt, TEXT(','));
                    if (pszEnd) {
                        *pszEnd = 0;
                    }

                    OFN.lpstrDefExt = szExt;
                    OFN.lpstrFilter = szValue;
                    OFN.Flags &= ~OFN_ENABLEHOOK;

                    TraceMsg(DM_SAVEASHACK, "DOH::_OnSaveAs OFN.lpstrDefExt is %s", OFN.lpstrDefExt);
                }
            }
            RegCloseKey(hkey);
        }

        if (GetSaveFileName(&OFN))
        {
            IPersistFile* ppf;
            ASSERT(_pole);
            hres = _pole->QueryInterface(IID_IPersistFile, (void **)&ppf);
            if (SUCCEEDED(hres))
            {
                TraceMsg(DM_APPHACK, "APPHACK DOH SaveAs'ing to %s", szSaveTo);
                hres = ppf->Save(szSaveTo, FALSE);
                ppf->Release();
            }
            else
            {
                ASSERT(0);
            }
        }
        else
        {
            hres = S_FALSE;
        }
    }

    return hres;
}

#ifndef POSTPOSTSPLIT
HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState)
{
    IDropTarget *pdrop;
    HRESULT hres = CoCreateInstance(CLSID_MailRecipient,
        NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
        IID_IDropTarget, (void**)&pdrop);

    if (SUCCEEDED(hres))
    {
        hres = SimulateDrop(pdrop, pdtobj, grfKeyState, NULL, NULL);
        pdrop->Release();
    }
    return hres;
}
#endif //  POSTPOSTSPLIT

void _EnableRemoveMenuItem(HMENU hmenu, DWORD cmdf, UINT uCmd)
{
    if (!(cmdf & (OLECMDF_SUPPORTED | OLECMDF_ENABLED)))
        RemoveMenu(hmenu, uCmd, MF_BYCOMMAND);
    else
        _EnableMenuItem(hmenu, uCmd,
                        cmdf & OLECMDF_ENABLED);
}

void CDocObjectHost::_OnInitMenuPopup(HMENU hmInit, int nIndex, BOOL fSystemMenu)
{
    if (!_hmenuCur)
        return;

    DEBUG_CODE( _DumpMenus(TEXT("on _OnInitMenuPopup"), TRUE); )

    if (GetMenuFromID(_hmenuCur, FCIDM_MENU_VIEW) == hmInit) {
        OLECMD rgcmd1[] = {
            { IDM_SCRIPTDEBUGGER, 0 },
        };

        DeleteMenu (hmInit, DVIDM_MSHTML_FIRST+IDM_SCRIPTDEBUGGER, MF_BYCOMMAND);
        if (SUCCEEDED(QueryStatusDown(&CGID_MSHTML, ARRAYSIZE(rgcmd1), rgcmd1, NULL)) && (rgcmd1[0].cmdf & OLECMDF_ENABLED)) {
            //
            // We need the script debugger popup menu.  We should check to see if this
            // needs to be loaded.
            //

            HMENU           hMenuDebugger;
            MENUITEMINFO   mii;
            const UINT      cchBuf = 128;
            TCHAR           szItem[cchBuf];

            hMenuDebugger = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(MENU_SCRDEBUG));

            mii.fMask = MIIM_SUBMENU | MIIM_TYPE | MIIM_ID;
            mii.fType = MFT_STRING;
            mii.cch = cchBuf;
            mii.dwTypeData = szItem;
            mii.cbSize = sizeof(mii);
            GetMenuItemInfo(hMenuDebugger, 0, TRUE, &mii);

            mii.fMask |= MIIM_STATE;
            mii.fState = MFS_ENABLED;

            InsertMenuItem(hmInit, FCIDM_THEATER, FALSE, &mii);


            OLECMD rgcmd[] = {
                { IDM_BREAKATNEXT, 0 },
                { IDM_LAUNCHDEBUGGER, 0 },
            };

            HRESULT hr = QueryStatusDown(&CGID_MSHTML, ARRAYSIZE(rgcmd), rgcmd, NULL);
            _EnableMenuItem(mii.hSubMenu, DVIDM_MSHTML_FIRST+rgcmd[0].cmdID, SUCCEEDED(hr) && (rgcmd[0].cmdf & OLECMDF_ENABLED));
            _EnableMenuItem(mii.hSubMenu, DVIDM_MSHTML_FIRST+rgcmd[1].cmdID, SUCCEEDED(hr) && (rgcmd[1].cmdf & OLECMDF_ENABLED));

        }

        if (_pmsot)
        {
            OLECMD rgcmd2[] = {
                { IDM_VIEWSOURCE, 0 },
            };

            if (SHRestricted2(REST_NoViewSource, NULL, 0) == 0)
            {
                // we only want to modify the state of the view source item
                // if it isn't restricted by the IEAK. if it's restricted, we
                // need to leave it disabled regardles of what the object
                // we're hosting says

                HRESULT hr = _pmsot->QueryStatus(&CGID_MSHTML, ARRAYSIZE(rgcmd2), rgcmd2, NULL);
        
                _EnableMenuItem(hmInit, DVIDM_MSHTML_FIRST + rgcmd2[0].cmdID, 
                    SUCCEEDED(hr) && (rgcmd2[0].cmdf & OLECMDF_ENABLED));
            }
        }

    }
    else if (GetMenuFromID(_hmenuCur, FCIDM_MENU_FILE) == hmInit)
    {
        if (_pmsot)
        {
            TraceMsg(0, "sdv TR _OnInitMenuPopup : step 5");
            OLECMD rgcmds[] = {
                { OLECMDID_PRINT, 0 },
                { OLECMDID_PAGESETUP, 0 },
                { OLECMDID_PROPERTIES, 0 },
                { OLECMDID_SAVE, 0 },
                { OLECMDID_SAVEAS, 0 },
                { OLECMDID_PRINTPREVIEW, 0 },
            };

            _pmsot->QueryStatus(NULL, ARRAYSIZE(rgcmds), rgcmds, NULL);

            // Adding a comment for my sanity: we use SHDVID_PRINTFRAME instead
            // of OLECMDID_PRINT because IE40 is going to support the printing
            // of entire framesets, instead of the current behavior or forwarding
            // the command to the active frame.
            //
            OLECMD rgcmds1[] = {
                { SHDVID_PRINTFRAME, 0 },
            };

            _pmsot->QueryStatus(&CGID_ShellDocView, ARRAYSIZE(rgcmds1), rgcmds1, NULL);

            //
            //  If OLECMDID_SAVEAS is not supported (neither ENABLED nor
            // SUPPORTED is set) by the DocObject, check if the object
            // support IPersistFile. If it does, enable it. Note that
            // this mechanism allows the DocObject to disable this menu
            // item (by setting only OLECMDF_SUPPORTED). (SatoNa)
            //
            ASSERT(rgcmds[4].cmdID == OLECMDID_SAVEAS);

            // Only apply the save as restriction to the browser. If it is the
            // browser, and save as is restricted, then make the item disappear.
            if ( (_dwAppHack & BROWSERFLAG_MSHTML) &&
                 SHRestricted2( REST_NoBrowserSaveAs, NULL, 0 ))
                rgcmds[4].cmdf &= ~(OLECMDF_ENABLED | OLECMDF_SUPPORTED);
            else if (!(rgcmds[4].cmdf & (OLECMDF_ENABLED | OLECMDF_SUPPORTED)))
            {
                IPersistFile* ppf;
                ASSERT(_pole);
                HRESULT hresT = _pole->QueryInterface(IID_IPersistFile, (void **)&ppf);
                if (SUCCEEDED(hresT))
                {
                    TraceMsg(DM_APPHACK, "APPHACK DOH Enabling SaveAs menu for Excel95");
                    rgcmds[4].cmdf |= OLECMDF_ENABLED;
                    ppf->Release();
                }
            }

            if (SHRestricted2(REST_NoPrinting, NULL, 0))
            {
                rgcmds[0].cmdf &= ~(OLECMDF_ENABLED | OLECMDF_SUPPORTED);   // print
                rgcmds[1].cmdf &= ~(OLECMDF_ENABLED | OLECMDF_SUPPORTED);   // page setup
                rgcmds[5].cmdf &= ~(OLECMDF_ENABLED | OLECMDF_SUPPORTED);   // print preview
            }

            //
            // APPHACK: Office apps do not enable "Save" correctly.
            //  Automatically enable it if the moniker is a FILE moniker
            //  AND the document has been altered by the user.
            //
            if (_fFileProtocol && _IsDirty(NULL))
            {
                if (!(rgcmds[3].cmdf & OLECMDF_ENABLED))
                {
                    TraceMsg(DM_APPHACK, "APPHACK DOH Enabling Save for Office Apps");
                }
                rgcmds[3].cmdf |= OLECMDF_ENABLED;
            }

            // Remove/disable/enable the "Print" command as appropriate.
            // Excel doesn't set SUPPORTED bit when it sets ENABLED bit
            // so we have to check both bits.
            _EnableRemoveMenuItem(hmInit, rgcmds[0].cmdf, DVIDM_PRINT);

            _EnableMenuItem(hmInit, DVIDM_PAGESETUP,
                    (rgcmds[1].cmdf & OLECMDF_ENABLED));
            _EnableMenuItem(hmInit, DVIDM_PROPERTIES,
                    (rgcmds[2].cmdf & OLECMDF_ENABLED));

            _EnableRemoveMenuItem(hmInit, rgcmds[3].cmdf, DVIDM_SAVE);
            _EnableRemoveMenuItem(hmInit, rgcmds[4].cmdf, DVIDM_SAVEASFILE);
            _EnableRemoveMenuItem(hmInit, rgcmds[5].cmdf, DVIDM_PRINTPREVIEW);
            _EnableRemoveMenuItem(hmInit, rgcmds1[0].cmdf, DVIDM_PRINTFRAME);


            HMENU hmFileNew = SHGetMenuFromID(hmInit, DVIDM_NEW);

            if (hmFileNew) 
            {
                const static struct {
                    LPCTSTR pszClient;
                    UINT idCmd;
                } s_Clients[] = {
                    { NEW_MAIL_DEF_KEY, DVIDM_NEWMESSAGE },
                    { NEW_CONTACTS_DEF_KEY, DVIDM_NEWCONTACT },
                    { NEW_NEWS_DEF_KEY, DVIDM_NEWPOST },
                    { NEW_APPOINTMENT_DEF_KEY, DVIDM_NEWAPPOINTMENT },
                    { NEW_MEETING_DEF_KEY, DVIDM_NEWMEETING },
                    { NEW_TASK_DEF_KEY, DVIDM_NEWTASK },
                    { NEW_TASKREQUEST_DEF_KEY, DVIDM_NEWTASKREQUEST },
                    { NEW_JOURNAL_DEF_KEY, DVIDM_NEWJOURNAL },
                    { NEW_NOTE_DEF_KEY, DVIDM_NEWNOTE },
                    { NEW_CALL_DEF_KEY, DVIDM_CALL }
                };

                BOOL bItemRemoved = FALSE;

                for (int i = 0; i < ARRAYSIZE(s_Clients); i++)
                {
                    if (!SHIsRegisteredClient(s_Clients[i].pszClient))
                    {
                        if (RemoveMenu(hmFileNew, s_Clients[i].idCmd, MF_BYCOMMAND))
                          bItemRemoved = TRUE;
                    }
                }

                // Menu item "File/New/Window Ctrl+N" needs to be disabled if the restriction is set
                if( SHRestricted2W(REST_NoOpeninNewWnd, NULL, 0))
                {
                    EnableMenuItem(hmFileNew, DVIDM_NEWWINDOW, MF_BYCOMMAND | MF_GRAYED);
                }

                if (bItemRemoved) // ensure the last item is not a separator
                    _SHPrettyMenu(hmFileNew);
            }
        }
    }
    else if (GetMenuFromID(_hmenuCur, FCIDM_VIEWFONTS) == hmInit
            || GetMenuFromID(_hmenuCur, FCIDM_ENCODING) == hmInit)
    {
        if (_pmsot)
        {
            // Handling fonts popup in view menu
            OLECMD rgcmd[] = {
                { SHDVID_GETFONTMENU,  0 },
                { SHDVID_GETMIMECSETMENU, 0 },
            };

            _pmsot->QueryStatus(&CGID_ShellDocView, ARRAYSIZE(rgcmd), rgcmd, NULL);

            int idx = (GetMenuFromID(_hmenuCur, FCIDM_VIEWFONTS) == hmInit ? 0 : 1);

            if (rgcmd[idx].cmdf & OLECMDF_ENABLED)
            {
                VARIANTARG v = {0};
                HRESULT hr;

                hr = _pmsot->Exec(&CGID_ShellDocView, rgcmd[idx].cmdID, 0, NULL, &v);
                if (S_OK == hr)
                {
                    // (on NT/Unix) DestroyMenu(hmInit) shouldn't work, because
                    // we're inside the processing of WM_INITMENUPOPUP message
                    // for hmInit. DestroyMenu will make the hmInit handle
                    // invalid.
                    //
                    // Instead of that we'll empty hmInit and copy hmenuFonts
                    // over. hmenuFonts will be destroyed to prevent the
                    // memory leak.
                    //
                    //
                    MENUITEMINFO mii;
                    UINT uItem = 0;
//$ WIN64: mshtml\src\site\base\formmso.cxx needs to return VT_INT_PTR instead
//                  HMENU hmenuFonts = (HMENU)v.byref;
                    HMENU hmenuFonts = (HMENU)LongToHandle(v.lVal);

                    // deleting menu while processing WM_INITMENUPOPUP
                    // can cause assertion failure on NT. However, copying
                    // submenu using InsertMenuItem() doesn't work on Win9x.
                    // see the comments above and Menu_Replace() in menu.cpp
                    //
                    if (!g_fRunningOnNT)
                        DestroyMenu(hmInit);

                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_ID|MIIM_SUBMENU;
                    while (GetMenuItemInfo(hmenuFonts, uItem, TRUE, &mii))
                    {
                        if (idx == 1 && mii.hSubMenu != NULL)
                        {
                            UINT uItemSub = 0;
                            HMENU hMenuSub = mii.hSubMenu;
                            while (GetMenuItemInfo(hMenuSub, uItemSub, TRUE, &mii))
                            {
                                mii.wID += DVIDM_MSHTML_FIRST;
                                SetMenuItemInfo(hMenuSub, uItemSub++, TRUE, &mii);
                            }
                        }
                        else
                        {
                            mii.wID += DVIDM_MSHTML_FIRST;
                            SetMenuItemInfo(hmenuFonts, uItem, TRUE, &mii);
                        }
                        uItem++;
                    }

                    if (!g_fRunningOnNT)
                    {
                        mii.cbSize = sizeof(mii);
                        mii.fMask = MIIM_SUBMENU;
                        mii.hSubMenu = hmenuFonts;
                        SetMenuItemInfo(_hmenuCur,
                                       (idx == 0 ? FCIDM_VIEWFONTS:FCIDM_ENCODING),
                                        FALSE, &mii);
                    }
                    else
                    {
                        Menu_Replace(hmInit, hmenuFonts);
                        DestroyMenu(hmenuFonts);
                    }
                }
            }
        }
    }
    else  if (GetMenuFromID(_hmenuCur, FCIDM_MENU_TOOLS) == hmInit ||
              GetMenuFromID(_hmenuCur, FCIDM_MENU_HELP) == hmInit)
    {
        // Add Tools and help Menu Extensions
        if (_pBrowsExt)
        {
            _pBrowsExt->OnCustomizableMenuPopup(_hmenuCur, hmInit);
        }
    }
}

//
// ATTEMPT: Handling WM_SETFOCUS message here caused several problems
//  under IE 3.0. Since we can't find any code scenario that requires
//  this code, I'm yanking out. If might introduce a new bug, but dealing
//  with those bugs is probably better than dealing with this code.
//  (SatoNa)
//

/*----------------------------------------------------------
Purpose: Determines if this message should be forwarded onto
         the object.

Returns: TRUE if the message needs to be forwarded
*/
BOOL CDocObjectHost::_ShouldForwardMenu(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_MENUSELECT:
    {
        // In USER menu bars, the first menuselect will be sent for the
        // selected top-level menu item, in which case hmenu == _hmenuCur.
        // We expect menubands to behave similarly.
        //
        // We check that hmenu == _hmenuCur because we only keep a list
        // of the top-level popup menus.  We don't keep track of any
        // cascading submenus.  We should only need to check who owns
        // the menu at the initial popup, all subsequent messages for
        // that menu should go to the same destination (frame or object).
        //
        // The same goes for CShellBrowser::_ShouldForwardMenu().
        //
        HMENU hmenu = GET_WM_MENUSELECT_HMENU(wParam, lParam);
        if (hmenu && (MF_POPUP & GET_WM_MENUSELECT_FLAGS(wParam, lParam)))
        {
            HMENU hmenuSub = GetSubMenu(hmenu, GET_WM_MENUSELECT_CMD(wParam, lParam));

            if (hmenu == _hmenuCur)
            {
                // Normal case, where we just look at the topmost popdown menus
                _fForwardMenu = _menulist.IsObjectMenu(hmenuSub);
            }
            else if (_menulist.IsObjectMenu(hmenuSub))
            {
                // This happens if the cascading submenu (micro-merged help menu for
                // example) should be forwarded on, but the parent menu should
                // not.
                _fForwardMenu = TRUE;
            }
            else if (GetMenuFromID(_hmenuCur, FCIDM_MENU_HELP) == hmenu 
                     && !_menulist.IsObjectMenu(hmenu) )
            {
                // 80430 Appcompat: notice that our menu fowarding doesn't work for the 
                // micro-merged Help menu.  If the user previously selected the merged
                // submenu, and we end up here, it means a non-merged submenu was just
                // selected and our _fForwardMenu was still set to TRUE.  If we don't 
                // reset it, the next WM_INITMENUPOPUP gets forwarded, which crashes Visio.
                //
                // We know that a submenu of the Help menu has just popped up, and we know
                // the submenu belongs to us.  So don't forward to the docobj until the
                // next popup.

                _fForwardMenu = FALSE;
            }
        }
        break;
    }

    case WM_COMMAND:
        if (_fForwardMenu)
        {
            // Stop forwarding menu messages after WM_COMMAND
            _fForwardMenu = FALSE;

            // If it wasn't from an accelerator, forward it
            if (0 == GET_WM_COMMAND_CMD(wParam, lParam))
                return TRUE;
        }
        break;
    }
    return _fForwardMenu;
}


/*----------------------------------------------------------
Purpose: Forwards messages to the in-place object.

         This is used to forward menu messages to the object for
         menu bands, since the menu bands do not work with the
         standard OLE FrameFilterWndProc.

         Also, the help menu is sometimes a combination of the
         object and the frame.  This function will forward as
         appropriate.

*/
LRESULT CDocObjectHost::_ForwardObjectMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0L;
    IOleInPlaceActiveObject *piact = _xao.GetObject();
    ASSERT(IS_VALID_CODE_PTR(piact, IOleInPlaceActiveObject));

    if (piact)
    {
        HWND hwnd;

        piact->GetWindow(&hwnd);
        ASSERT(IS_VALID_HANDLE(hwnd, WND));

        if (hwnd)
        {
            if (uMsg == WM_COMMAND)
                PostMessage(hwnd, uMsg, wParam, lParam);
            else
                lRet = SendMessage(hwnd, uMsg, wParam, lParam);
        }
    }

    return lRet;
}


void CDocObjectHost::_OnMenuSelect(UINT id, UINT mf, HMENU hmenu)
{
    if (_psb)
    {
        if (IsInRange(id, DVIDM_MSHTML_FIRST, DVIDM_MSHTML_LAST))
        {
            if (_pcmdMergedMenu) {
                OLECMD rgcmd = { id - DVIDM_MSHTML_FIRST, 0 };
                struct {
                    OLECMDTEXT  cmdtxt;
                    WCHAR       szExtra[MAX_PATH];
                } cmdt;

                cmdt.cmdtxt.cmdtextf = OLECMDTEXTF_STATUS;
                cmdt.cmdtxt.cwActual = 0;
                cmdt.cmdtxt.cwBuf    = MAX_PATH;
                cmdt.cmdtxt.rgwz[0]  = 0;

                HRESULT hresT=_pcmdMergedMenu->QueryStatus(&CGID_MSHTML, 1, &rgcmd, &cmdt.cmdtxt);
                if (SUCCEEDED(hresT) && cmdt.cmdtxt.rgwz[0]) {
                    _psb->SetStatusTextSB(cmdt.cmdtxt.rgwz);
                } else {
                    TraceMsg(DM_ERROR, "CDOH::_OnMenuSelect QueryStatus failed %x %d",
                        hresT, cmdt.cmdtxt.cwActual);
                }
            }
            else
                // An ASSERT was replaced with this TraceMsg to allow testing on Win9x.
                // 70240 which reported the assert was pushed to IE6.
                TraceMsg(TF_WARNING, "CDocObjectHost::_OnMenuSelect   _pcmdMergedMenu == NULL");
        }
        else if (IsInRange(id, DVIDM_MENUEXT_FIRST, DVIDM_MENUEXT_LAST))
        {
            // Menu Extensions go here
            if (_pBrowsExt)
            {
                _pBrowsExt->OnMenuSelect(id);
            }
        }
        else
        {
            WCHAR wszT[MAX_STATUS_SIZE];
            if (MLLoadStringW(IDS_HELP_OF(id), wszT, ARRAYSIZE(wszT)))
            {
                _psb->SetStatusTextSB(wszT);
            }
        }
    }
}

LRESULT CDocObjectHost::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0L;

    switch(uMsg)
    {
    case WM_TIMER:
        if (wParam == IDTIMER_PROGRESS)
        {
            _OnSetProgressPos(0, PROGRESS_TICK);
            break;
        }
        else if (wParam == IDTIMER_PROGRESSFULL)
        {
            _OnSetProgressPos(-2, PROGRESS_RESET);
            break;
        }
        else
        {
#ifdef TEST_DELAYED_SHOWMSOVIEW
            MessageBeep(0);
            KillTimer(_hwnd, 100);
            ActivateMe(NULL);
            break;
#else
            ASSERT(FALSE);
            break;
#endif // TEST_DELAYED_SHOWMSOVIEW
        }

    /* WM_PICS_ASYNCCOMPLETE is posted by the async thread fetching ratings
     * from label bureaus, etc.
     */
    case WM_PICS_ASYNCCOMPLETE:
    {
        TraceMsg(DM_PICS, "CDOH::v_WndProc got WM_PICS_ASYNCCOMPLETE");

        PicsQuery pq;
        HRESULT hr;
        LPVOID lpvRatingDetails;
        DWORD dwSerialComplete = (DWORD)lParam;
        CPicsProcessor * pPicsProc = NULL;

        if (::_GetPicsQuery(dwSerialComplete, &pq)) {
            ::_RemovePicsQuery(dwSerialComplete);
            hr = (HRESULT)wParam;
            lpvRatingDetails = pq.lpvRatingDetails;
        }
        else {
            hr = E_FAIL;
            lpvRatingDetails = NULL;
        }

        pPicsProc = _GetPicsProcessorFromSerialNumber(dwSerialComplete);
        
        if (pPicsProc)
        {
            pPicsProc->_GotLabel(hr, lpvRatingDetails, PICS_WAIT_FOR_ASYNC);
        }
        else
        {
            TraceMsg( DM_PICS, "CDOH::v_WndProc no PicsProc for ASYNCCOMPLETE %x", dwSerialComplete);

            if ( lpvRatingDetails )
            {
                ::RatingFreeDetails(lpvRatingDetails);
                lpvRatingDetails = NULL;
            }
        }

        break;
    }

    case WM_PICS_ROOTDOWNLOADCOMPLETE:
    {
        TraceMsg(DM_PICS, "CDOH::v_WndProc got WM_PICS_ROOTDOWNLOADCOMPLETE %x", lParam);

        if (_PicsProcBase._pRootDownload != NULL) 
        {
            _PicsProcBase._pRootDownload->CleanUp();
            ATOMICRELEASET(_PicsProcBase._pRootDownload,CPicsRootDownload);
        }

        break;
    }

    /* WM_PICS_ALLCHECKSCOMPLETE is posted when we finally want to either
     * cancel the navigation or go through with it, according to ratings
     * checks.  Posting a message allows all denial blocking message loops
     * to unwind before we cancel navigation, which could otherwise delete
     * objects that still have functions operating on them.
     */
    case WM_PICS_ALLCHECKSCOMPLETE:
        TraceMsg(DM_PICS, "CDOH::v_WndProc got WM_PICS_ALLCHECKSCOMPLETE, lParam=%x", lParam);

        if (lParam == IDOK) {
            if (!_fSetTarget)
            {
                TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_ASYNCCOMPLETE) execing SHDVID_ACTIVATEMENOW");
                _pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_ACTIVATEMENOW, NULL, NULL, NULL);
            }
            else {
                TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_ASYNCCOMPLETE) not execing SHDVID_ACTIVATEMENOW");
            }
        }
        else {
            ASSERT(!_fSetTarget);
            TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_ASYNCCOMPLETE) calling _CancelPendingNavigation");
            _CancelPendingNavigation(FALSE);
//        _pmsoctBrowser->Exec(NULL, OLECMDID_STOP, NULL, NULL, NULL);
        }
        break;

    /* WM_PICS_DOBLOCKINGUI is posted when we decide we need to put up
     * denial UI.  Posting a message allows download of this object and
     * other frames to continue while we post the UI, which in turn allows
     * any denials from other frames to be coalesced into the one dialog.
     */
    case WM_PICS_DOBLOCKINGUI:
        {
            TraceMsg(DM_PICS, "CDOH::v_WndProc got WM_PICS_DOBLOCKINGUI %x", lParam);

            CPicsProcessor * pPicsProc = _GetPicsProcessorFromKey(lParam);

            if (pPicsProc)
            {
                UINT id = pPicsProc->_PicsBlockingDialog();

                if (pPicsProc->_pPrivWindow)
                {
                    ASSERT( _fDocCanNavigate );
                    TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_DOBLOCKINGUI) posting WM_PICS_RESULTTOPRIVWIN");
                    if (!PostMessage( _hwnd, WM_PICS_RESULTTOPRIVWIN, id, lParam))
                    {
                        TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_DOBLOCKINGUI) couldn't post message!");
                    }
                }
                else
                {
                    TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_DOBLOCKINGUI) posting WM_PICS_ALLCHECKSCOMPLETE");
                    if (!PostMessage(_hwnd, WM_PICS_ALLCHECKSCOMPLETE, 0, id)) 
                    {
                        TraceMsg(DM_PICS, "CDOH::v_WndProc(WM_PICS_DOBLOCKINGUI) couldn't post message!");
                    }
                }

                // We may have been terminated while the
                // dialog was up -- finish cleaning up here.
                if (   !pPicsProc->_fInDialog 
                    &&  pPicsProc->_fTerminated 
                    &&  pPicsProc != &_PicsProcBase)
                {
                    delete pPicsProc;
                }

            }
            else
            {
                TraceMsg( DM_PICS, "CDOH::v_WndProc no PicsProc for DOBLOCKINGUI");
            }
        }
        break;

    case WM_PICS_RESULTTOPRIVWIN:
        {
            ASSERT( _fDocCanNavigate );

            TraceMsg(DM_PICS, "CDOH::v_WndProc got WM_PICS_RESULTTOPRIVWIN %x", lParam);

            CPicsProcessor * pPicsProc = _GetPicsProcessorFromKey(lParam);

            if (pPicsProc)
            {
                ASSERT( pPicsProc->_pPrivWindow );

                IHTMLPrivateWindow * pPrivWindow = pPicsProc->_pPrivWindow;
                pPrivWindow->AddRef();

                if (pPicsProc->_pRootDownload != NULL) 
                {
                    pPicsProc->_pRootDownload->CleanUp();
                    ATOMICRELEASET(pPicsProc->_pRootDownload,CPicsRootDownload);
                }

                // Remove ourselves from the list
                _RemovePicsProcessorByKey( lParam );

                // Make Trident let go of our command target
                pPrivWindow->SetPICSTarget(NULL);

                // Tell the window the answer
                pPrivWindow->PICSComplete( wParam == IDOK );

                pPrivWindow->Release();
            }
            else
            {
                TraceMsg( DM_PICS, "CDOH::v_WndProc no PicsProc for WM_PICS_RESULTTOPRIVWIN");
            }
        }
        break;

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
        MessageBeep(0);
        break;


    case WM_MENUSELECT:
        if (_ShouldForwardMenu(uMsg, wParam, lParam))
            lRet = _ForwardObjectMsg(uMsg, wParam, lParam);
        else
        {
            UINT uMenuFlags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);
            WORD wID = GET_WM_MENUSELECT_CMD(wParam, lParam);
            HMENU hMenu = GET_WM_MENUSELECT_HMENU(wParam, lParam);

            // Check for popup menus so we can display help strings for them
            if (uMenuFlags & MF_POPUP)
            {
                MENUITEMINFO miiSubMenu;

                miiSubMenu.cbSize = SIZEOF(MENUITEMINFO);
                miiSubMenu.fMask = MIIM_SUBMENU|MIIM_ID;
                if (GetMenuItemInfoWrap(hMenu, wID, TRUE, &miiSubMenu))
                {
                    // Change the parameters to simulate a "normal" menu item
                    wID = (WORD)miiSubMenu.wID;
                }
            }

            _OnMenuSelect(wID, uMenuFlags, hMenu);
        }
        break;

    case WM_INITMENUPOPUP:
        if (_ShouldForwardMenu(uMsg, wParam, lParam))
            lRet = _ForwardObjectMsg(uMsg, wParam, lParam);
        else
            _OnInitMenuPopup((HMENU)wParam, LOWORD(lParam), HIWORD(lParam));
        break;

    case WM_DRAWITEM:
    case WM_MEASUREITEM:
        if (_ShouldForwardMenu(uMsg, wParam, lParam))
            lRet = _ForwardObjectMsg(uMsg, wParam, lParam);
        else
            goto DoDefault;
        break;

    case WM_NOTIFY:
        _OnNotify((LPNMHDR)lParam);
        break;

    case WM_COMMAND:
        _OnCommand(HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
        break;

    case WM_SIZE:
        if (_pmsov)
        {
            RECT rcClient;
            GetClientRect(_hwnd, &rcClient);
            //
            // We should call ResizeBorder only if the browser is
            // not an IOleInPlaceUIWindow.
            //
            if (_pipu==NULL)
            {
                TraceMsg(TF_SHDUIACTIVATE, "DOH::WM_SIZE calling _piact->ResizeBorder");
                _xao.ResizeBorder(&rcClient, &_dof, TRUE);
            }

            _rcView.left = _bwTools.left;
            _rcView.top = _bwTools.top;
            _rcView.right = rcClient.right - _bwTools.right;
            _rcView.bottom = rcClient.bottom - _bwTools.bottom;

            TraceMsg(TF_SHDUIACTIVATE, "DOH::WM_SIZE calling SetRect (%d, %d, %d, %d)", _rcView.left, _rcView.top, _rcView.right, _rcView.bottom);
            _pmsov->SetRect(&_rcView);
        }

        _PlaceProgressBar(TRUE);

        break;

//
// ATTEMPT: Handling WM_SETFOCUS message here caused several problems
//  under IE 3.0. Since we can't find any code scenario that requires
//  this code, I'm yanking out. If might introduce a new bug, but dealing
//  with those bugs is probably better than dealing with this code.
//  (SatoNa)
//

    case WM_PRINT:
        _OnPaint((HDC)wParam);
        break;

    case WM_QUERYNEWPALETTE:
    case WM_PALETTECHANGED:
    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
    case WM_ENTERSIZEMOVE:
    case WM_EXITSIZEMOVE:
    {
        HWND hwndT;
        if (_pole && SUCCEEDED(IUnknown_GetWindow(_pole, &hwndT)) && hwndT)
            return SendMessage(hwndT, uMsg, wParam, lParam);
        return 0;
    }

    case WM_PAINT:
        PAINTSTRUCT ps;
        HDC hdc;
        hdc = BeginPaint(_hwnd, &ps);

        // we don't need them to paint into our dc...
        // docobj has own hwnd.
        //_OnPaint(hdc);

        EndPaint(_hwnd, &ps);
        break;

    case WM_LBUTTONUP:
        if (_uState != SVUIA_ACTIVATE_FOCUS) {
            SetFocus(_hwnd);
        }
        break;

    case WM_ERASEBKGND:
        // Checking _bsc._fBinding will catch the first page case.
        
        if (_fDrawBackground ||
            (!(_dwAppHack & BROWSERFLAG_NEVERERASEBKGND)
             && ((_pmsov && _uState!=SVUIA_DEACTIVATE)
                 || _bsc._fBinding)))
        {
            PAINTMSG("WM_ERASEBKGND", this);
            goto DoDefault;
        }
        
        // Don't draw WM_ERASEBKGND if we have no view activated.
        return TRUE; // TRUE = fErased

    case WM_HELP:
        //
        // Give it to the parent to do.  we need to do this in case we're hosted as a
        // control
        //
    {
        IOleCommandTarget *pcmdtTop;
        if (SUCCEEDED(QueryService(SID_STopLevelBrowser, IID_IOleCommandTarget, (void **)&pcmdtTop))) {
            pcmdtTop->Exec(&CGID_ShellDocView, SHDVID_HELP, 0, NULL, NULL);
            pcmdtTop->Release();
        }
        // do nothing in failure...  let the parent own completely
    }
        break;

    case WM_WININICHANGE:
        _PlaceProgressBar(TRUE);
        break;

    default:
        // Handle the MSWheel message
        if ((uMsg == GetWheelMsg()) && _pole)
        {
            HWND hwndT;

            // If for some reason our window has focus we just need to
            // swallow the message. If we don't we may create an infinite loop
            // because most clients send the message to the focus window.
            if (GetFocus() == _hwnd)
                return 1;

            //
            // try to find a window to forward along to
            //
            if (SUCCEEDED(IUnknown_GetWindow(_pole, &hwndT)))
            {
                PostMessage(hwndT, uMsg, wParam, lParam);
                return 1;
            }
            // Fall through...
        }
DoDefault:

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lRet;
}

const TCHAR c_szViewClass[] = TEXT("Shell DocObject View");

void CDocObjectHost::_RegisterWindowClass(void)
{
    WNDCLASS wc = {0};

    wc.style         = CS_PARENTDC;
    wc.lpfnWndProc   = s_WndProc ;
    //wc.cbClsExtra    = 0;
    wc.cbWndExtra    = SIZEOF(CDocObjectHost*);
    wc.hInstance     = g_hinst ;
    //wc.hIcon         = NULL ;
    //wc.hCursor       = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    //wc.lpszMenuName  = NULL ;
    wc.lpszClassName = c_szViewClass;

    SHRegisterClass(&wc);

}

void CDocObjectHost::_InitOleObject()
{
    if (!_fClientSiteSet)
    {
        _fClientSiteSet = TRUE;

#ifdef DEBUG
        IOleClientSite * pcliT = NULL;

        if (SUCCEEDED(_pole->GetClientSite(&pcliT)) && pcliT)
        {
            // Trident now grabs the client site from the bind context.
            // We don't want to hit this assertin this case (pcliT==this).
            //
            AssertMsg(IsSameObject(pcliT, SAFECAST(this, IOleClientSite*)),
                      TEXT("CDocObjectHost::_InitOleObject _pole (%x) already has a client site (%x) (this=%x)"),
                      _pole, pcliT, this);

            pcliT->Release();
        }
#endif

        HRESULT hresT = _pole->SetClientSite(this);

        if (FAILED(hresT))
        {
            TraceMsg(TF_SHDAPPHACK, "DOH::_InitOleObject SetClientSite failed (%x). Don't in-place navigate", hresT);
            _dwAppHack |= BROWSERFLAG_DONTINPLACE;
        }

        ASSERT(NULL==_pvo);

        _pole->QueryInterface(IID_IViewObject, (void **)&_pvo);

        if (_pvo)
        {
            TraceMsg(DM_DEBUGTFRAME, "CDocObjectHost::_InitOleObject about call SetAdvise on %x (%x)", _pole, this);
            _pvo->SetAdvise(DVASPECT_CONTENT, ADVF_PRIMEFIRST, this);
        }
        //
        //  According to SteveRa (Word developer), a word object has an
        // internal flag which indicates whether or not it is created
        // from a file. If that flag is set, UIActivate will open the
        // window in Word. Calling SetHostName will reset that flag.
        //
        _GetAppHack(); // Make it sure that we have _dwAppHack

        if (_fCallSetHostName())
        {
            TraceMsg(TF_SHDAPPHACK, "DOH::_InitOleObject calling SetHostName for Word95");

            WCHAR wszTitle[128];
            MLLoadStringW(IDS_TITLE, wszTitle, ARRAYSIZE(wszTitle));

            _pole->SetHostNames(wszTitle, wszTitle);
        }
    }
}

//+-----------------------------------------------------------------------------
//
// IE Media Bar hook
// -----------------
// At least one and only one of the args must be non-null.
//
// If pbc is non-null:
//  If this bind ctx is for a media url and was delegated to shdocvw from trident,
//  trident has already stored the mime-type as a string on the bind ctx.
//
// If pwzMimeType is non-null:
//  The given mime type is used
// 
// Ask the media bar if it wants to handle this mime-type and if it does,
// return true, else return false.
//
//-------------------------------------------------------------------------------
BOOL CDocObjectHost::_DelegateToMediaBar(IBindCtx * pbc, LPCWSTR pwzMimeType)
{
    USES_CONVERSION;

    LPWSTR pstrMime  = NULL;
    TCHAR szURL[MAX_URL_STRING];
    BOOL fRet = FALSE;
    CComVariant svarMime(pstrMime);

    CComPtr<IUnknown>           spUnkObj;
    CComPtr<IOleCommandTarget>  spOCTMimeType;
    CComPtr<IOleCommandTarget>  spOCTMediaBar;

    // We want to delegate only under the following conditions:
    // 1. In Explorer or IE
    // 2. If autoplay is enabled
    // 3. If autoplay is not turned off for the first navigation
    // 4. If NOT NT4 or IA64 (WMP7/8 doesn't support these platforms)
    // 5. If WMP7/8 is present (if it isn't, we will try to fault-in once.)
    // 6. the media bar isn't restricted
    if (!(IsInternetExplorerApp() 
          && CMediaBarUtil::GetAutoplay()
          && !SHRestricted2(REST_No_LaunchMediaBar, NULL, 0)
          && CMediaBarUtil::IsWMP7OrGreaterCapable()
          && FAILED(QueryService(CLSID_MediaBand, IID_PPV_ARG(IUnknown, &spUnkObj)))))
    {
        goto done;
    }

    // release so we can reuse the pointer later
    spUnkObj.Release();

    // get the current URL
    if (FAILED(_GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE)))
        goto done;

    // At least one and only one of the args must be non-null.
    if (pbc && !pwzMimeType)
    {
        // get the custom parameter that trident uses to set the media mime-type
        // QI for IOleCommandTarged to access the mime-type string. 
        // get the mime-type string
        if (FAILED(pbc->GetObjectParam(L"MediaBarMime", &spUnkObj))
           || FAILED(spUnkObj->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &spOCTMimeType)))
           || FAILED(spOCTMimeType->Exec(&CGID_DownloadObjectBindContext, 0, NULL, NULL, &svarMime)))
            goto done;
    }
    else if (!pbc && pwzMimeType)
    {
        svarMime = pwzMimeType;
    }
    else
    {
        ASSERT(FALSE && L"Either one of bind ctx or mime-type is expected"); 
        goto done;
    }

    // proceed only if mime type string is available
    if ((VT_BSTR == svarMime.vt)
       && svarMime.bstrVal)
    {
        // Ask the media bar if it wants to handle this mime-type
        BOOL fShouldPlay = FALSE;
        BOOL fShow = TRUE;
        CComVariant svarUrl;
        HRESULT hr = S_OK;
        
        svarUrl = !StrCmpNIW(WZ_RADIO_PROTOCOL, szURL, wcslen(WZ_RADIO_PROTOCOL)) ? (szURL + wcslen(WZ_RADIO_PROTOCOL)) : szURL;

        if (!(V_BSTR(&svarMime) && V_BSTR(&svarUrl)))
            goto done;

        // check if we can play this mime type
        hr = CMediaBarUtil::ShouldPlay(W2T(V_BSTR(&svarMime)), &fShouldPlay);
        if (FAILED(hr) 
           || (!fShouldPlay))
        {
            goto done;
        }

        // ShouldPlay returns S_FALSE if this is the first time playing this mime type.
        if (S_FALSE == hr)
        {
            BOOL bSaveSetting = FALSE;
            LONGLONG iRetCode = PLAYMIME_NO;

            iRetCode = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_MEDIA_MIME), _hwnd, s_MimeDlgProc, NULL);

            switch (iRetCode)
            {
                case PLAYMIME_YES:
                {
                    fShouldPlay = TRUE;
                    bSaveSetting = FALSE;
                }
                break;

                case PLAYMIME_YESSAVE:
                {
                    fShouldPlay = TRUE;
                    bSaveSetting = TRUE;
                }
                break;
        
                case PLAYMIME_NO:
                {
                    fShouldPlay = FALSE;
                    bSaveSetting = FALSE;
                }
                break;
        
                case PLAYMIME_NOSAVE:
                {
                    fShouldPlay = FALSE;
                    bSaveSetting = TRUE;
                }
                break;
        
                default:
                {
                    ASSERT(FALSE && L"Unexpected return value");
                }
                break;
            }

            // check if the setting needs to be saved
            if (TRUE == bSaveSetting)
            {
                DWORD dwVal = fShouldPlay ? 0x1 : 0x0;

                hr = CMediaBarUtil::SetMediaRegValue(V_BSTR(&svarMime), REG_BINARY, (void*) &dwVal, (DWORD) 1, TRUE);     
                ASSERT(SUCCEEDED(hr));
            }

            // Bail if user told us not to play this mime type
            if (!fShouldPlay)
                goto done;
        }
        else
        {
            // "don't prompt" means "play all types", unless autoplay is turned off
            // in which case we have already bailed
        }

        // Yay. They want to try out our feature. But WAIT. We need WMP7/8. Is that installed? No? Well, let's go get it.
        // If the user decides _not_ to install WMP7, though, we should disable ourselves.
        if (!CMediaBarUtil::IsWMP7OrGreaterInstalled())
        {
            if (!IsOS(OS_WHISTLERORGREATER))
            {
                // Here we do the stuff to web-jit WMP7. ISSUE: We assume that it'll always be on Whistler
                uCLSSPEC ucs;
                QUERYCONTEXT qc = { 0 };

                ucs.tyspec = TYSPEC_CLSID;
                ucs.tagged_union.clsid = CLSID_JITWMP8;

                hr = FaultInIEFeature(_hwnd, &ucs, &qc, FIEF_FLAG_FORCE_JITUI);
            }
            if (!CMediaBarUtil::IsWMP7OrGreaterInstalled())
            {
                // We give up. Delegate. We'll never try autoplay again.
                MLShellMessageBox(_hwnd, MAKEINTRESOURCE(IDS_MEDIABAR_NOWMP7), MAKEINTRESOURCE(IDS_MEDIABAR_NOWMP7TITLE), MB_OK);
                CMediaBarUtil::ToggleAutoplay(FALSE);
                goto done;
            }
        }

        // QS for the media bar
        if (FAILED(QueryService(SID_SMediaBar, IID_PPV_ARG(IOleCommandTarget, &spOCTMediaBar))))
        {
            // The media bar may not have been created yet
            _ForceCreateMediaBar();

            // QS for the media bar once again
            if (FAILED(QueryService(SID_SMediaBar, IID_PPV_ARG(IOleCommandTarget, &spOCTMediaBar))))
                goto done;

            fShow = FALSE;
        }

        hr = IUnknown_Exec(spOCTMediaBar, &CGID_MediaBar, MBID_PLAY, 0, &svarMime, &svarUrl);
        ASSERT(SUCCEEDED(hr));

        // The Media Bar clears the URL if it accepts the navigation
        if (VT_BSTR != svarUrl.vt)
        {
            // Cancel the navigation
            fRet = TRUE; 

            // Ensure that the media bar is visible
            if (fShow)
            {
                CComVariant svarPopout;
                if (SUCCEEDED(IUnknown_Exec(spOCTMediaBar, &CGID_MediaBar, MBID_POPOUT, 0, NULL, &svarPopout))
                   && ((VT_BOOL!=svarPopout.vt)
                       || (VARIANT_FALSE==svarPopout.boolVal)))
                {
                    _ForceCreateMediaBar();
                }
            }
        }
    }

done:
    return fRet;
}


//+---------------------------------------------------------------------------------
//
// IE Media Bar Hook
// ------------------
// 
// Force the Media Bar to be displayed
//
//----------------------------------------------------------------------------------
void CDocObjectHost::_ForceCreateMediaBar()
{
    IUnknown_ShowBrowserBar(_psp, CLSID_MediaBand, TRUE);
}

//+---------------------------------------------------------------------------------
//
// IE Media Bar Hook
// ------------------
// 
// Dialog proc for Media Bar per-mime-type dialog
//
//----------------------------------------------------------------------------------

INT_PTR CALLBACK 
CDocObjectHost::s_MimeDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UINT id;

    switch(uMsg)
    {
        case WM_INITDIALOG:
            CheckDlgButton(hDlg, IDC_MEDIA_MIME_CHKBOX, TRUE);  // The first option is always checked
            if (!CMediaBarUtil::IsWMP7OrGreaterInstalled())
            {
                TCHAR szTemp[500];
                if (MLLoadString(IDS_MEDIABAR_NEEDWMP7, szTemp, ARRAYSIZE(szTemp)))
                {
                    SetDlgItemText(hDlg, IDC_MEDIABAR_EXTRA, szTemp);
                }
            }
            return TRUE;

        case WM_DESTROY:
            return FALSE;

        case WM_COMMAND:
        {
            id = GET_WM_COMMAND_ID(wParam, lParam);
            switch (id) 
            {
                case IDOK:
                {
                    if (IsDlgButtonChecked(hDlg, IDC_MEDIA_MIME_CHKBOX))
                    {
                        id = PLAYMIME_YESSAVE;
                    }
                    else
                    {
                        id = PLAYMIME_YES;
                    }

                    EndDialog(hDlg, id);
                }
                break;

                case IDCANCEL:
                {
                    if (IsDlgButtonChecked(hDlg, IDC_MEDIA_MIME_CHKBOX))
                    {
                        id = PLAYMIME_NOSAVE;
                    }
                    else
                    {
                        id = PLAYMIME_NO;
                    }
                    EndDialog(hDlg, id);
                }
                break;

                case IDC_MEDIA_MOREINFO:
                {
                    SHHtmlHelpOnDemandWrap(GetParent(hDlg), TEXT("iexplore.chm > iedefault"), 0, (DWORD_PTR) TEXT("mediabar_settings.htm"), ML_CROSSCODEPAGE);
                }
                break;
            }
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}


HRESULT CDocObjectHost::SetTarget(IMoniker* pmk, UINT uiCP, LPCTSTR pszLocation, LPITEMIDLIST pidlKey,
                                  IShellView* psvPrev, BOOL fFileProtocol)
{
    HRESULT hres = NOERROR;
    BOOL fLoadedHistory = FALSE;
    ATOMICRELEASE(_pmkCur);

    _pmkCur = pmk;
    pmk->AddRef();

    ILFree(_pidl);
    _pidl = ILClone(pidlKey);
    
    _fFileProtocol = fFileProtocol;
    _pszLocation = pszLocation;
    _uiCP = uiCP;

    //  this is only set if we did a successful LoadHistory()
    _fIsHistoricalObject = FALSE;

    if (_bsc._hszPostData)
    {
        GlobalFree(_bsc._hszPostData);
        _bsc._hszPostData = NULL;
    }
    if (_bsc._pszHeaders)
    {
        LocalFree(_bsc._pszHeaders);
        _bsc._pszHeaders = NULL;
    }

    ATOMICRELEASE(_bsc._pbc);

    //
    //  this replaces the old style of caching.
    //  if something has been cached, it was cached
    //  way above us before we ever existed.  now it is
    //  waiting for us.
    //
    IBrowserService * pbs;
    IStream  * pstm = NULL;
    IBindCtx * pbcHistory = NULL;

    if (SUCCEEDED(QueryService(SID_SShellBrowser, IID_IBrowserService, (void **)&pbs)))
    {
        //  just in case there is one already there, like in the case of local anchor navigates
        ATOMICRELEASE(_pole);

        pbs->GetHistoryObject(&_pole, &pstm, &pbcHistory);
        TraceMsg(TF_TRAVELLOG, "DOH::SetTarget History object: _pole = %X, pstm = %X, pbc = %X", _pole, pstm, pbcHistory);
        pbs->Release();

    }

    if (_pole) 
    {
        //  some objects (MSHTML for one)  need their clientsite before anything else.
        //  so we need to init first
        _InitOleObject();

        if (pstm)
        {
            IPersistHistory *pph;
            if (SUCCEEDED(_pole->QueryInterface(IID_IPersistHistory, (void **)&pph)))
            {
                if (SUCCEEDED(pph->LoadHistory(pstm, pbcHistory)))
                {
                    //
                    //  this is to make sure that we wait for
                    //  the pole to tell us when it is ready.
                    //  when there is a pstm, that means that they may have
                    //  to do a full reparse or whatever, and we cant make
                    //  any assumptions about the readystate.
                    //
                    hres = S_FALSE;
                    _fIsHistoricalObject = TRUE;
                    _SetUpTransitionCapability();
                    fLoadedHistory = TRUE;
                    
                    // we may need to redo the pics stuff too.
                    // PrepPicsForAsync();
                    TraceMsg(TF_TRAVELLOG, "DOH::SetTarget pph->LoadHistory Successful");
                }
                else
                    ATOMICRELEASE(_pole);

                pph->Release();
            }

            ATOMICRELEASE(pstm);
        }
        else
            hres = S_OK;

        ATOMICRELEASE(pbcHistory);

        //  we shouldnt fail a load history, because the data in
        //  is just what the document gave us in SaveHistory...
        AssertMsg(NULL != _pole, TEXT("DOH::SetTarget pph->LoadHistory Failed"));

        // if we were already up and created, just scroll to it.
        // if we were created DEACTIVATED, (possible in the ocx case)
        // don't do this activation
        if (_uState != SVUIA_DEACTIVATE && !DocCanHandleNavigation())
        {
            hres = _ActivateMsoView();
        }

        //    
        // allow navigation - when you're deactivated. So you can navigate an invisible WebOC. 
        // IE6 Bug# 5449
        // 

        if ( DocCanHandleNavigation() ||
             ( _fDocCanNavigate &&
               _uState == SVUIA_DEACTIVATE && 
               !fLoadedHistory ) )
        {
            // If the _fPrevDocHost flag is not
            // set, we better be deactivated.
            //
            AssertMsg((_fPrevDocHost || _uState == SVUIA_DEACTIVATE),
                      _T("_fPrevDocHost is not set and we are activated"));
            
            // If the document is handling the navigation,
            // we must store the user entered URL here. 
            // Otherwise, if the navigation fails,
            // the user-entered URL is NULL by the time
            // _bsc._HandleFailedNavigationSearch is called,
            //
            VariantClear(&_varUserEnteredUrl);
            _GetSearchString(_psp, &_varUserEnteredUrl);

            WCHAR wzUrl[MAX_URL_STRING];

            hres = IEGetNameAndFlagsEx(_pidl, SHGDN_FORPARSING, IEGDN_NOFRAGMENT, wzUrl, ARRAYSIZE(wzUrl), NULL);

            if (S_OK == hres)
            {
                _EnableModeless(FALSE);

                WCHAR wzLocation[MAX_URL_STRING] = {0};

                IEILGetFragment(_pidl, wzLocation, SIZECHARS(wzLocation));

                hres = _NavigateDocument(CComBSTR(wzUrl), CComBSTR(wzLocation));

                _EnableModeless(TRUE);
            }
        }
    }

    if (!_pole)
    {
        ASSERT(!pstm);
        ASSERT(!pbcHistory);

        IBindCtx * pbc = NULL;

        TraceMsg(TF_TRAVELLOG, "DOH::SetTarget No obj from TravelLog, calling pmk->BindToObject");

        if (_psp)
        {
            hres = _psp->QueryService(SID_SShellBrowser, IID_IBindCtx, (void **)&pbc);
        }

        if (pbc == NULL)
        {
            hres = CreateBindCtx(0, &pbc);
        }
        else
        {
            hres = S_OK;
        }

        if (SUCCEEDED(hres))
        {
            HRESULT    hr         = E_FAIL;
            IBindCtx * pbcAsync   = NULL;
            IBindCtx * pbcWrapper = NULL;

            if (pbc)
            {
                // If the bind context supports IAsyncBindCtx, then it
                // is a bind context that was created by UrlMon and passed
                // to us to reuse. We must pass this bind context to UrlMon
                // as-is and not wrapped in a BCW object.
                // Note: IAsyncBindCtx has identicial interface as IBindCtx
                //
                hr = pbc->QueryInterface(IID_IAsyncBindCtx, (void**)&pbcAsync);
                ATOMICRELEASE(pbcAsync);
            }

            if (SUCCEEDED(hr))
            {
                // If this is a media url delegated to shdocvw from trident,
                // and if the IE Media Bar wants to handle the url, cancel
                // the navigation, else continue the navigation. 

                if (_DelegateToMediaBar(pbc, NULL))
                {
                    _CancelPendingNavigation(TRUE);

                    if (_pwb)
                    {
                        _pwb->SetNavigateState(BNS_NORMAL);
                    }
                    
                    ATOMICRELEASE(pbc);
                    return S_FALSE;
                }
                else
                {
                    ATOMICRELEASE(_pbcCur);
                    _fDelegatedNavigation = TRUE;

                   _pbcCur = pbc;  // No need to AddRef - pbc is AddRef'ed by QS.
                }
            }
            else
            {
                pbcWrapper = BCW_Create(pbc);

                if (pbcWrapper == NULL)
                {
                    pbcWrapper = pbc;
                }
                else
                {
                    pbc->Release();
                }

                pbc = NULL;

                hres = CreateAsyncBindCtxEx(pbcWrapper, 0, NULL, NULL, &pbcAsync, 0);

                if (SUCCEEDED(hres))
                {

                    ASSERT(pbcAsync);
                    ATOMICRELEASE(_pbcCur);

                    _pbcCur = pbcAsync;
                    _pbcCur->AddRef();

                    pbcWrapper->Release();
                    pbcWrapper = pbcAsync;
                }
            }

            if (SUCCEEDED(hres))
            {
#ifdef DEBUG
                DWORD dwMksys;
                hres = pmk->IsSystemMoniker(&dwMksys);
                ASSERT((SUCCEEDED(hres) && dwMksys!=MKSYS_FILEMONIKER));
#endif
                ASSERT(FALSE == _fSetTarget);

                BOOL fWindowOpen = FALSE;

                if (_pbcCur)
                {
                    IUnknown * punkBindCtxParam = NULL;

                    hres = _pbcCur->GetObjectParam(KEY_BINDCONTEXTPARAM, &punkBindCtxParam);
                    if (SUCCEEDED(hres))
                    {
                        fWindowOpen = TRUE;
                        punkBindCtxParam->Release();
                    }
                }

                // If we are being called in response to window.open
                // we create the document here and call InitNew on it
                // to load about:blank. We do this so that the user won't
                // see a transparent window while the URL is being
                // located. When Trident calls Invoke to get the 
                // new window object, we will then load the real document.
                // 
                if (fWindowOpen)
                {
                    hres = _CreatePendingDocObject(TRUE, TRUE);

                    ASSERT(S_OK == hres && _punkPending);

                    if (_punkPending)
                    {
                        ATOMICRELEASE(_pole);
                        hres = _punkPending->QueryInterface(IID_IOleObject, (void**)&_pole);

                        ASSERT(SUCCEEDED(hres));

                        // IE Media Bar: turn auto-play off for the first navigation
                        // This is needed to make the target="_blank" feature work.
                        CMediaBarHelper::DisableFirstAutoPlay(_punkPending);
                    }
                }
                else
                {
                    // Hack: The AddRef & Release protect against an error page
                    // navigation from freeing the pdoh out from under us (edwardp)
                    AddRef();

                    _fSetTarget = TRUE;
                    hres = _StartAsyncBinding(pmk, _pbcCur, psvPrev);
                    _fSetTarget = FALSE;

                    // Hack: Matching Release()
                    //
                    Release();

                    if (SUCCEEDED(hres))
                    {
                        hres = S_FALSE;
                    }
                }
            }

            ATOMICRELEASE(pbcWrapper);  // CreateAsyncBindCtx addrefs as well.
        }

    }

    return hres;
}

#define USE_HISTBMOFFSET 0
#define USE_MYBMOFFSET   1
#define USE_STDBMOFFSET  2

void CDocObjectHost::_MergeToolbarSB()
{
}

HICON _LoadSmallIcon(int id)
{
    return (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(id),
                                IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
}

void _InitIcons(void)
{
    ENTERCRITICAL;

    if (g_hiconScriptErr == NULL)
    {
        g_hiconScriptErr = _LoadSmallIcon(IDI_STATE_SCRIPTERROR);
        if (IS_BIDI_LOCALIZED_SYSTEM())
            MirrorIcon(&g_hiconScriptErr, NULL);
    }


    if (!g_hiconSSL)
    {
        g_hiconSSL = _LoadSmallIcon(IDI_SSL);
        if (IS_BIDI_LOCALIZED_SYSTEM())
            MirrorIcon(&g_hiconSSL, NULL);
    }


    if (!g_hiconFortezza)
    {
        g_hiconFortezza = _LoadSmallIcon(IDI_FORTEZZA);
        if (IS_BIDI_LOCALIZED_SYSTEM())
            MirrorIcon(&g_hiconFortezza, NULL);
    }

    for (UINT id = IDI_STATE_FIRST; id <= IDI_STATE_LAST; id++)
    {
        if (!g_ahiconState[id-IDI_STATE_FIRST])
        {
            g_ahiconState[id-IDI_STATE_FIRST]= _LoadSmallIcon(id);
            if (IS_BIDI_LOCALIZED_SYSTEM())
                 MirrorIcon(&g_ahiconState[id-IDI_STATE_FIRST], NULL);
        }
    }


    if (!g_hiconOffline)
    {
        g_hiconOffline = _LoadSmallIcon(IDI_OFFLINE);
        if (IS_BIDI_LOCALIZED_SYSTEM())
            MirrorIcon(&g_hiconOffline, NULL);
    }


    if (!g_hiconPrinter)
    {
        g_hiconPrinter = _LoadSmallIcon(IDI_PRINTER);
        if (IS_BIDI_LOCALIZED_SYSTEM())
            MirrorIcon(&g_hiconPrinter, NULL);
    }

    if (!g_hiconPrivacyImpact)
    {
        g_hiconPrivacyImpact = _LoadSmallIcon( IDI_PRIVACY_IMPACT);
        if (IS_BIDI_LOCALIZED_SYSTEM())
            MirrorIcon(&g_hiconPrivacyImpact, NULL);
    }

    LEAVECRITICAL;
}

// This function initializes whatever the Class needs for manipulating the history
// we try to delay this till absolutely needed in order to not load
// wininet till the end

IUnknown *
CDocObjectHost::get_punkSFHistory()
{
    if (_pocthf && !_punkSFHistory)
    {
        VARIANT var;

        VariantInit(&var);
        if (SUCCEEDED(_pocthf->Exec(&CGID_Explorer, SBCMDID_HISTSFOLDER, TRUE, NULL, &var)))
        {
            if (VT_UNKNOWN == var.vt && NULL != var.punkVal)
            {
                _punkSFHistory = var.punkVal;
                _punkSFHistory->AddRef();
            }
        }
        VariantClearLazy(&var);
    }
    return _punkSFHistory;
}


//
//  This function (re)initializes CDocObjectHost object with the buddy
// IShellView (which is always CShellDocView) and the IShellBrowser.
// If this is the first time (_hwnd==NULL), it creates the view window
// and other associated windows as well. Otherwise (_hwnd!=NULL) -- it
// means this object is passed from one CDocViewObject to another because
// of intra-page jump -- we move it to the specified location (prcView)
// to make it really sure that we show it at the right place.
//
BOOL CDocObjectHost::InitHostWindow(IShellView* psv, IShellBrowser* psb,
                                    LPRECT prcView)
{
    HWND hwndParent;
    IServiceProvider  * pspTop;
    IOleObject        * pTopOleObject;
    IOleClientSite    * pOleClientSite;

    _ResetOwners();

    ASSERT(psv);
    _psv = psv;
    _psv->AddRef();
    ASSERT(NULL==_pmsoctView);
    _psv->QueryInterface(IID_IOleCommandTarget, (void **)&_pmsoctView);
    ASSERT(NULL==_pdvs);
    _psv->QueryInterface(IID_IDocViewSite, (void **)&_pdvs);

    ASSERT(psb);
    _psb = psb;
    _psb->AddRef();

    ASSERT(NULL==_pwb);
    _psb->QueryInterface(IID_IBrowserService, (void **)&_pwb);
    ASSERT(NULL==_pmsoctBrowser);
    _psb->QueryInterface(IID_IOleCommandTarget, (void **)&_pmsoctBrowser);

    ASSERT(NULL==_psp);
    _psb->QueryInterface(IID_IServiceProvider, (void **)&_psp);
    ASSERT(NULL==_pipu);
    _psb->QueryInterface(IID_IOleInPlaceUIWindow, (void **)&_pipu);
    ASSERT(_pipu);

    _Init();
    
    ASSERT(_psp);
    if (_psp)
    {

        // Get the object that manages the extended buttons from the top-level browser
        // But only if we don't already have it.
        if (NULL == _pBrowsExt)
            _psp->QueryService(SID_STopLevelBrowser, IID_IToolbarExt, (void **)&_pBrowsExt);

        //
        // LATER: I don't like that CDocObjectHost is directly accessing
        //  the automation service object to fire events. We should
        //  probably move all the progress UI code above IShellBrowser
        //  so that we don't need to do this shortcut. (SatoNa)
        //
        ASSERT(NULL==_peds);
        _psp->QueryService(IID_IExpDispSupport, IID_IExpDispSupport, (void **)&_peds);
        ASSERT(_peds);
        ASSERT(NULL==_pedsHelper);
        _peds->QueryInterface(IID_IExpDispSupportOC, (void **)&_pedsHelper);
        ASSERT(NULL==_phf);
        _psp->QueryService(SID_SHlinkFrame, IID_IHlinkFrame, (void **)&_phf);
        if (_phf)
        {
            _phf->QueryInterface(IID_IUrlHistoryNotify, (void **)&_pocthf);
        }
        // _punkSFHistory was being initialized here - but in order to delay the load of wininet.dll
        // we initialize it just before we use it

        ASSERT(_pWebOCUIHandler == NULL);
        ASSERT(_pWebOCUIHandler2 == NULL);
        ASSERT(_pWebOCInPlaceSiteEx == NULL);
        ASSERT(_fDocCanNavigate || _fWebOC == FALSE);

        if (SUCCEEDED(_psp->QueryService(SID_STopLevelBrowser, IID_IServiceProvider, (void **)&pspTop)) && pspTop)
        {
            if (SUCCEEDED(pspTop->QueryService(SID_SContainerDispatch, IID_IOleObject, (void **)&pTopOleObject)) && pTopOleObject)
            {
                _fWebOC = TRUE; // there was a container so we're a WebOC

                pTopOleObject->GetClientSite(&pOleClientSite);
                if (pOleClientSite)
                {
                    pOleClientSite->QueryInterface(IID_IDocHostUIHandler, (void**)&_pWebOCUIHandler);
                    pOleClientSite->QueryInterface(IID_IDocHostUIHandler2, (void**)&_pWebOCUIHandler2);
                    pOleClientSite->QueryInterface(IID_IDocHostShowUI, (void**)&_pWebOCShowUI);
                    pOleClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void**)&_pWebOCInPlaceSiteEx);
                    pOleClientSite->Release();
                }
                pTopOleObject->Release();
            }
            pspTop->Release();
        }
    }

    _dhUIHandler.SetSite( (IDocHostUIHandler *) this); // Apparently we need to disamiguate the IUnknown reference.

    _psb->GetWindow(&hwndParent);

    if (!_hwnd) {
        // There are several things we don't attempt to do when
        // we're not toplevel. Frameset type DOH should never
        // try to menu merge or dork with the statusbar.
        // Do this before the CreateWindowEx call 'cuz during
        // creation we party on the status bar.
        {
            IOleInPlaceSite* pparentsite = _GetParentSite();

            if (pparentsite) {
                _fHaveParentSite = TRUE;
                pparentsite->Release();
            }
        }

        _RegisterWindowClass();

        // really create the window
        DWORD dwStyle = WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE | WS_TABSTOP;
        //
        //  In Office 95, Excel and PowerPoint don't draw the client edge,
        //  while Word does draw the client edge. To avoid having double edges,
        //  we remove it for now. SriniK (Office) will find out which will be
        //  the standard for Office 96. (SatoNa)
        //
        _hwnd = SHNoFusionCreateWindowEx(0 /* WS_EX_CLIENTEDGE */,
                                c_szViewClass, NULL,
                                dwStyle,
                                prcView->left, prcView->top, prcView->right-prcView->left, prcView->bottom-prcView->top,
                                hwndParent,
                                (HMENU)0,
                                HINST_THISDLL,
                                (LPVOID)SAFECAST(this, CImpWndProc*));

        if (!_hwnd) {
            goto Bail;
        }

        UINT uiAcc = ACCEL_DOCVIEW;
        if (SHRestricted(REST_NOFILEMENU))
            uiAcc = ACCEL_DOCVIEW_NOFILEMENU;

        if (_hacc)
        {
            DestroyAcceleratorTable(_hacc);
            _hacc = NULL;
        }

        _hacc = LoadAccelerators(MLGetHinst(), MAKEINTRESOURCE(uiAcc));
        _InitIcons();

    } else {
        ASSERT(GetParent(_hwnd) == hwndParent);
        MoveWindow(_hwnd, prcView->left, prcView->top,
                   prcView->right-prcView->left, prcView->bottom - prcView->top, TRUE);
    }



Bail:

    return (bool) _hwnd;
}

void CDocObjectHost::_CleanupProgress(void)
{
    TraceMsg(TF_SHDPROGRESS, "CDOH::CleanupProgress fTimer = %d, fFull = %d, hwndProg = %X", _fProgressTimer, _fProgressTimerFull, _hwndProgress);

    if (_fProgressTimer)
    {
        KillTimer(_hwnd, IDTIMER_PROGRESS);
        _fProgressTimer = FALSE;
    }

    if (_fProgressTimerFull)
    {
        //  we are being stopped, and the hwnd is destroyed
        //  before we clear the status bar.  zekel - 22-JUL-97
        _OnSetProgressPos(-2, PROGRESS_RESET);
        KillTimer(_hwnd, IDTIMER_PROGRESSFULL);
        ASSERT(!_fProgressTimerFull);
    }

    _OnSetProgressMax(0);

    _hwndProgress = NULL;
}

void CDocObjectHost::DestroyHostWindow()
{
    // Turn off the simple mode when we are leaving.
    if (_psb)
        _psb->SendControlMsg(FCW_STATUS, SB_SIMPLE, 0, 0, NULL);

    // really destroy the window

    _fCanceledByBrowser = TRUE;
    _bsc.AbortBinding();

    _RemoveAllPicsProcessors();

    _CloseMsoView();

    //
    // Notes: We need to delete OLE object from this side (container),
    //  otherwise, we leak because of circular reference.
    //
    _UnBind();

    _CleanupProgress();

    if (_hwndTooltip) {
        DestroyWindow(_hwndTooltip);
        _hwndTooltip = NULL;
    }

    //
    // Note that we need to destroy the parent after destroying children.
    //
    // OLE seems to recurse back into this function when we destroy the hwnd
    // and we try to destroy it a second time causing a RIP. Avoid this RIP
    // by NULLing out our internal variables before we destroy the hwnds.
    if (_hwnd) {
        HWND hwndT = _hwnd;
        _hwnd = NULL;
        DestroyWindow(hwndT);
    }

    ATOMICRELEASE(_psp);

    _ResetOwners();
}


//
// This member creates a view (IOleDocumentView) of the DocObject we have (_pole).
// This function is called only once from ::CreateViewWindow.
//
HRESULT CDocObjectHost::_CreateMsoView(void)
{
    ASSERT(_pmsov == NULL);
    ASSERT(_pmsoc == NULL);
    HRESULT hres = OleRun(_pole);
    if (SUCCEEDED(hres))
    {

        //// WARNING:
        // if you add anything to here, you should also pass it along
        // in _CreateDocObjHost
        //

        IOleDocument* pmsod = NULL;
        hres = _pole->QueryInterface(IID_IOleDocument, (void **)&pmsod);
        if (SUCCEEDED(hres)) {
            hres = pmsod->CreateView(this, NULL ,0,&_pmsov);

            if (SUCCEEDED(hres)) {
                //
                //  HACK: Working about MSHTML bug (#28756). We really
                //  want to take this hack out before we ship. (SatoNa)
                //
                _pmsov->SetInPlaceSite(this);
            } else {
                TraceMsg(DM_ERROR, "DOH::_CreateMsoView pmsod->CreateView() ##FAILED## %x", hres);
            }

            if (SUCCEEDED(hres) && !_pmsot) {
                _pmsov->QueryInterface(IID_IOleCommandTarget, (void **)&_pmsot);
            }

            if (SUCCEEDED(hres) && !_pmsoc) {
                _pmsov->QueryInterface(IID_IOleControl, (void **)&_pmsoc);
            }
#ifdef HLINK_EXTRA
            if (_pihlbc)
            {
                if (_phls)
                {
                    _phls->SetBrowseContext(_pihlbc);
                }

                ASSERT(_pmkCur);
                hres = HlinkOnNavigate(this, _pihlbc, 0,
                                       _pmkCur, NULL, NULL);
                // TraceMsg(0, "sdv TR : _CreateMsoView HlinkOnNavigate returned %x", hres);
            }
#endif // HLINK_EXTRA
            pmsod->Release();
        } else {
            TraceMsg(DM_ERROR, "DOH::_CreateMsoView _pole->QI(IOleDocument) ##FAILED## %x", hres);
        }
    } else {
        TraceMsg(DM_ERROR, "DOH::_CreateMsoView OleRun ##FAILED## %x", hres);
    }

    return hres;
}

HRESULT CDocObjectHost::_ForwardSetSecureLock(int lock)
{
    HRESULT hr = E_FAIL;
    TraceMsg(DM_SSL, "[%X}DOH::ForwardSecureLock() lock = %d",this, lock, hr);

    VARIANT va = {0};
    va.vt = VT_I4;
    va.lVal = lock;

    //  we should only suggest if we are not the topframe
    if (_psp && _psb && !IsTopFrameBrowser(_psp, _psb))
    {
        IOleCommandTarget *pmsoct;

        if (SUCCEEDED(_psp->QueryService(SID_STopFrameBrowser, IID_IOleCommandTarget, (void **)&pmsoct)))
        {
            ASSERT(pmsoct);
            if (lock < SECURELOCK_FIRSTSUGGEST)
                va.lVal += SECURELOCK_FIRSTSUGGEST;

            hr = pmsoct->Exec(&CGID_Explorer, SBCMDID_SETSECURELOCKICON, 0, &va, NULL);
            pmsoct->Release();
        }
    }
    else
        if (_pmsoctBrowser)
            hr = _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_SETSECURELOCKICON, 0, &va, NULL);

    return hr;
}

//
// This is the only method of IOleDocumentSite, which we MUST implement.
//
HRESULT CDocObjectHost::ActivateMe(IOleDocumentView *pviewToActivate)
{
    TraceMsg(TF_SHDUIACTIVATE, "DOC::ActivateMe called when _pmsov is %x", _pmsov);

    HRESULT hres = S_OK;
    if (_pmsov==NULL) {



        hres = _CreateMsoView();

#ifdef TEST_DELAYED_SHOWMSOVIEW
        SetTimer(_hwnd, 100, 1500, NULL);
        MessageBeep(0);
        return hres;
#endif // TEST_DELAYED_SHOWMSOVIEW
    }

    if (SUCCEEDED(hres)) 
    {
        _ShowMsoView();
        _MergeToolbarSB();
        _InitToolbarButtons();

        ASSERT(_pmsoctBrowser);
        if (_fSetSecureLock)
            _ForwardSetSecureLock(_eSecureLock);
    }

    return hres;
}

//Helper routine for QueryStatus for status messages
ULONG ulBufferSizeNeeded(wchar_t *wsz, int ids, ULONG ulBufferLen)
{
    TraceMsg(0, "sdv TR ulBufferSizeNeeded called with (%x)", ids);
    ASSERT(ulBufferLen > 0);

    DWORD dwLen;
    WCHAR szTemp[MAX_STATUS_SIZE+1];
    dwLen = MLLoadStringW(ids, szTemp, MAX_STATUS_SIZE);
    if (dwLen!= 0 && dwLen < (DWORD)ulBufferLen)
        MoveMemory(wsz, szTemp, (dwLen+1) * sizeof(WCHAR)); // +1 for the NULL not included in LoadString count
    else
        *wsz = 0;
    return ((ULONG)dwLen);
}

HRESULT CDocObjectHost::OnQueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext, HRESULT hres)
{
    if (pguidCmdGroup == NULL)
    {
        ULONG i;

        if (rgCmds == NULL)
            return E_INVALIDARG;

        for (i=0 ; i<cCmds ; i++)
        {
            // ONLY say that we support the stuff we support in ::OnExec
            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_OPEN:
            case OLECMDID_SAVE:
            case OLECMDID_UPDATECOMMANDS:
            case OLECMDID_SETPROGRESSMAX:
            case OLECMDID_SETPROGRESSPOS:
            case OLECMDID_SETPROGRESSTEXT:
            case OLECMDID_SETTITLE:
                rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            default:
                if (SUCCEEDED(hres))
                {
                    // _pmsoctBrowser already filled this in
                }
                else
                {
                    rgCmds[i].cmdf = 0;
                }
                break;
            }
        }

        /* for now we deal only with status text*/
        if (pcmdtext)
        {
            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_OPEN:
            case OLECMDID_SAVE:
                pcmdtext->cwActual = ulBufferSizeNeeded(pcmdtext->rgwz,
                        IDS_HELP_OF(_MapFromMso(rgCmds[0].cmdID)),
                        pcmdtext->cwBuf);
                break;

            default:
                if (SUCCEEDED(hres))
                {
                    // _pmsoctBrowser already filled this in
                }
                else
                {
                    pcmdtext->cmdtextf = OLECMDTEXTF_NONE;
                    pcmdtext->cwActual = 0;
                    if (pcmdtext->rgwz && pcmdtext->cwBuf>0)
                        *pcmdtext->rgwz = TEXT('\0');
                }
                break;
            }
        }

        hres = S_OK;
    }
    else if (IsEqualGUID(*pguidCmdGroup, CLSID_InternetButtons) ||
             IsEqualGUID(*pguidCmdGroup, CLSID_MSOButtons))
    {
        for (UINT i = 0 ; i < cCmds ; i++)
        {
            // CommandIDs from DVIDM_MENUEXT_FIRST to DVIDM_MENUEXT_LAST are reserved for toolbar extension buttons
            // Do NOT use this range for constants within the scope of CLSID_InternetButtons/CLSID_MSOButtons!
            if (IsInRange(rgCmds[i].cmdID, DVIDM_MENUEXT_FIRST, DVIDM_MENUEXT_LAST))
            {
                // We'll pass specificially this OLECMD through to the custom button
                IUnknown_QueryStatus(_pBrowsExt, &CLSID_ToolbarExtButtons, 1, &rgCmds[i], pcmdtext);
            }
            else
            {
                switch (rgCmds[i].cmdID)
                {
                case DVIDM_PRINT:
                case DVIDM_PRINTPREVIEW:
                    if (_pmsoctBrowser)
                    {
                        OLECMD ocButton;
                        static const int tbtab[] =
                        {
                            DVIDM_PRINT,
                            DVIDM_FONTS,
                            DVIDM_PRINTPREVIEW,
                        };
                        static const int cttab[] =
                        {
                            OLECMDID_PRINT,
                            OLECMDID_ZOOM,
                            OLECMDID_PRINTPREVIEW,
                        };
                        ocButton.cmdID = SHSearchMapInt(tbtab, cttab, ARRAYSIZE(tbtab), rgCmds[i].cmdID);
                        ocButton.cmdf = 0;
                        _pmsoctBrowser->QueryStatus(NULL, 1, &ocButton, NULL);
                        rgCmds[i].cmdf = ocButton.cmdf;
                    }
                    break;

                case DVIDM_FONTS:   // Always enable for IE5B2
                case DVIDM_CUT:
                case DVIDM_COPY:
                case DVIDM_PASTE:
                case DVIDM_ENCODING:
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                    break;

                case DVIDM_SHOWTOOLS:
                    if (_ToolsButtonAvailable())
                        rgCmds[i].cmdf = OLECMDF_ENABLED;
                    break;

                case DVIDM_MAILNEWS:
                    if (_MailButtonAvailable())
                        rgCmds[i].cmdf = OLECMDF_ENABLED;
                    break;

                case DVIDM_DISCUSSIONS:
                    // In addition to enabled/disabled, discussions button is checked/unchecked
                    rgCmds[i].cmdf = _DiscussionsButtonCmdf();
                    break;

                case DVIDM_EDITPAGE:
                    if (_psp)
                    {
                        // Temp code -- forward to itbar
                        // itbar edit code is moving here soon
                        IExplorerToolbar* pxtb;
                        if (SUCCEEDED(_psp->QueryService(SID_SExplorerToolbar, IID_IExplorerToolbar, (void **)&pxtb)))
                        {
                            OLECMD ocButton = { CITIDM_EDITPAGE, 0 };
                            IUnknown_QueryStatus(pxtb, &CGID_PrivCITCommands, 1, &ocButton, NULL);
                            rgCmds[i].cmdf = ocButton.cmdf;
                            pxtb->Release();
                        }
                    }
                    break;
                }
            }
        }
        hres = S_OK;
    }
    return hres;
}

HRESULT CDocObjectHost::QueryStatus(
    /* [unique][in] */ const GUID *pguidCmdGroup,
    /* [in] */ ULONG cCmds,
    /* [out][in][size_is] */ OLECMD rgCmds[  ],
    /* [unique][out][in] */ OLECMDTEXT *pcmdtext)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    // Now that BaseBrowser understands that CGID_MSHTML should be directed to the DocObject, we'll
    // get caught in a loop if we send those Execs through here.  Cut it off at the pass.
    if (pguidCmdGroup && IsEqualGUID(CGID_MSHTML, *pguidCmdGroup))
        return hres;

    if (_pmsoctBrowser)
        hres = _pmsoctBrowser->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);

    return OnQueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext, hres);
}

void CDocObjectHost::_OnSave(void)
{
    if (_pole && _fFileProtocol)
    {
        IPersistFile * ppf = 0;
        HRESULT hres = _pole->QueryInterface(IID_IPersistFile, (void **)&ppf);

        if (SUCCEEDED(hres))
        {
            LPOLESTR pszDisplayName = NULL;
            hres = _GetCurrentPageW(&pszDisplayName);

            if (SUCCEEDED(hres))
            {
                // fRemember = TRUE for normal case
                hres = ppf->Save(pszDisplayName, !_fCantSaveBack);

                if (FAILED(hres))
                {
                    TraceMsg(DM_ERROR, "DOH::_OnSave ppf->Save(psz, FALSE) failed with %x", hres);
                }

                OleFree(pszDisplayName);
            }
            ppf->Release();
        }
    }
}

HRESULT CDocObjectHost::_OnContentDisposition()
{
    HRESULT hr = S_OK;
    TCHAR   szURL[MAX_URL_STRING];    
    HRESULT hresT;
        
    hresT = _GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE);

    if (SUCCEEDED(hresT)) 
    {
        TCHAR    * pszURL;
        UINT       uRet;
        IUnknown * punk;

        if (_bsc._pszRedirectedURL && lstrlen(_bsc._pszRedirectedURL))
        {
            pszURL = _bsc._pszRedirectedURL;
        }
        else
        {
            pszURL = szURL;
        }

        hresT = QueryInterface(IID_IUnknown, (void**)&punk);

        if (SUCCEEDED(hresT))
        {
            uRet = OpenSafeOpenDialog(_hwnd, DLG_SAFEOPEN, NULL, pszURL, NULL, NULL, NULL, _uiCP, punk);

            switch(uRet) 
            {
                case IDOK:
                    //
                    // Set this flag to avoid poppping this dialog box twice.
                    // 
                    _fConfirmed = TRUE;
                    break;  // continue download

                case IDD_SAVEAS:
                    CDownLoad_OpenUI(_pmkCur, _bsc._pbc, FALSE, TRUE, NULL, NULL, NULL, NULL, NULL, _bsc._pszRedirectedURL, _uiCP, punk);
                    // fall thru to AbortBinding

                case IDCANCEL:
                    _CancelPendingNavigation(FALSE);
                    hr = E_ABORT;
                    break;
            }

            punk->Release();
        }
    }

    return hr;
}

void CDocObjectHost::_OnSetProgressPos(DWORD dwPos, DWORD state)
{
    //  trident will reset with -1
    if (dwPos == -1)
        state = PROGRESS_RESET;

    switch(state)
    {
    case PROGRESS_RESET:
        TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() RESET, timer = %d", _fProgressTimer);
        if (_fProgressTimer)
        {
            KillTimer(_hwnd, IDTIMER_PROGRESS);
            _fProgressTimer = FALSE;
        }

        if (_dwProgressMax)
        {
            // this will always finish up the progress bar
            //  so that when trident doesnt send us the last update
            //  we do it anyway
            if (_fProgressTimerFull && dwPos == -2)
            {
                _fProgressTimerFull = FALSE;
                KillTimer(_hwnd, IDTIMER_PROGRESSFULL);
                _dwProgressPos = 0;
                _OnSetProgressMax(0);
                _fShowProgressCtl = FALSE;
                _PlaceProgressBar(TRUE);
            }
            else if (!_fProgressTimerFull)
            {
                _OnSetProgressPos(0, PROGRESS_FULL);
                _fProgressTimerFull = TRUE;
                SetTimer(_hwnd, IDTIMER_PROGRESSFULL, 500, NULL);
            }
        }
        else
        {
            _fShowProgressCtl = FALSE;
            _PlaceProgressBar(TRUE);
        }

        break;

    case PROGRESS_FINDING:
        //this covers the first 10%
        TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() FINDING, timer = %d", _fProgressTimer);
        ASSERT(!dwPos);
        if (!_fProgressTimer)
            SetTimer(_hwnd, IDTIMER_PROGRESS, 500, NULL);
        _fProgressTimer = TRUE;
        _OnSetProgressMax(10000);
        _dwProgressInc = PROGRESS_INCREMENT;
        _dwProgressPos = 100;
        _dwProgressTicks = 0;
        _dwProgressMod = (PROGRESS_FINDMAX - _dwProgressPos) / (2 * _dwProgressInc);
        break;

    case PROGRESS_SENDING:
        TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() SENDING, timer = %d, dwPos = %d", _fProgressTimer, dwPos);
        ASSERT(!dwPos);
        if (!_fProgressTimer)
            SetTimer(_hwnd, IDTIMER_PROGRESS, 500, NULL);
        _fProgressTimer = TRUE;
        _OnSetProgressMax(10000);
        _dwProgressInc = PROGRESS_INCREMENT;
        _dwProgressTicks = 0;
        //dwProgressPos is already set from FINDING
        _dwProgressMod = (PROGRESS_SENDMAX - _dwProgressPos) / (2 * _dwProgressInc);
        break;

    case PROGRESS_RECEIVING:
        TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() RECEIVING, timer = %d, dwPos = %d", _fProgressTimer, dwPos);
        if (_fProgressTimer)
        {
            KillTimer(_hwnd, IDTIMER_PROGRESS);
            _fProgressTimer = FALSE;

            //  this is the base spot on the progress bar for trident
            _dwProgressBase = _dwProgressPos / PROGRESS_REBASE;
            TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() Rebasing at %d%%", _dwProgressPos * 100/ PROGRESS_TOTALMAX);
        }
        // progress max should be set from outside of here....
        _dwProgressPos = ADJUSTPROGRESSPOS(dwPos);
        break;

    case PROGRESS_TICK:
        if (_fProgressTimer)
        {
            if (_dwProgressInc)
                _dwProgressPos += _dwProgressInc;

            // Else we post the still waiting message...
            //
            if (_dwProgressMod && 0 == (++_dwProgressTicks % _dwProgressMod))
            {
                // this means we are about half way.
                _dwProgressInc /= 2;
            }

            TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() TICK, dwPos = %d, ticks = %d, inc = %d", _dwProgressPos, _dwProgressTicks, _dwProgressInc);
        }
        else
            TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() TICKNOT");
        break;

    case PROGRESS_FULL:
        {
            _dwProgressPos = _dwProgressMax;

            // if there are script errors, make sure the status
            // bar is properly set (re: icon and text)
            if (_pScriptErrList != NULL &&
                !_pScriptErrList->IsEmpty())
            {
                TCHAR   szMsg[MAX_PATH];

                // set the script error icon
                if (g_hiconScriptErr != NULL)
                {
                    if (_psb != NULL)
                    {
                        _psb->SendControlMsg(FCW_STATUS,
                                             SB_SETICON,
                                             STATUS_PANE_NAVIGATION,
                                             (LPARAM)g_hiconScriptErr,
                                             NULL);
                    }
                }

                // set the script error text
                MLLoadString(IDS_DONE_WITH_SCRIPT_ERRORS, szMsg, ARRAYSIZE(szMsg));
                _SetPriorityStatusText(szMsg);
            }

            TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() FULL");
        }
        break;

    default:
        ASSERT(FALSE);
    }

    if (_hwndProgress)
    {
        _psb->SendControlMsg(FCW_PROGRESS, PBM_SETPOS, _dwProgressPos, 0, NULL);
        TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressPos() updating, pos = %d, %d%% full", _dwProgressPos, _dwProgressMax ? _dwProgressPos * 100/ _dwProgressMax : 0);

    }

    // fire an event that progress has changed
    if (_peds)
    {
        //  if we are sent a -1, we must forward the event on so that
        //  our host gets it too.  some containers rely on this.
        //  specifically DevStudio's HTMLHelp
        //
        if (dwPos != -1)
            dwPos = _dwProgressPos;

        if (!_fUIActivatingView)
        {
            FireEvent_DoInvokeDwords(_peds,DISPID_PROGRESSCHANGE,dwPos,_dwProgressMax);
        }
    }
}


void CDocObjectHost::_OnSetProgressMax(DWORD dwMax)
{
    // remember the maximum range so we have it when we want to fire progress events
    if (_dwProgressMax != dwMax && _psb)
    {
        _dwProgressMax = dwMax;

        TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressMax() max = %d", _dwProgressMax);

        if (!_hwndProgress) {
            _psb->GetControlWindow(FCW_PROGRESS, &_hwndProgress);
        }

        if (_hwndProgress) {
            _psb->SendControlMsg(FCW_PROGRESS, PBM_SETRANGE32, 0, dwMax, NULL);
            TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressMax() updating (%d of %d)", _dwProgressPos, _dwProgressMax);
        }
        else
            TraceMsg(TF_SHDPROGRESS, "DOH::OnSetProgressMax() No hwndProgress");
    }
}

UINT CDocObjectHost::_MapCommandID(UINT id, BOOL fToMsoCmd)
{
    // HEY, this maps OLECMDID commands *only*
    static const UINT s_aicmd[][2] = {
        { DVIDM_PROPERTIES, OLECMDID_PROPERTIES },
        { DVIDM_PRINT,      OLECMDID_PRINT },
        { DVIDM_PRINTPREVIEW, OLECMDID_PRINTPREVIEW },
        { DVIDM_PAGESETUP,  OLECMDID_PAGESETUP},
        { DVIDM_SAVEASFILE, OLECMDID_SAVEAS },
        { DVIDM_CUT,        OLECMDID_CUT },
        { DVIDM_COPY,       OLECMDID_COPY },
        { DVIDM_PASTE,      OLECMDID_PASTE },
        { DVIDM_REFRESH,          OLECMDID_REFRESH },
        { DVIDM_STOPDOWNLOAD,     OLECMDID_STOP },
        // subset - above this line document handles
        { DVIDM_OPEN,       OLECMDID_OPEN },
        { DVIDM_SAVE,       OLECMDID_SAVE },
        { DVIDM_SHOWTOOLS,  OLECMDID_HIDETOOLBARS },
    };
#define CCMD_MAX        (sizeof(s_aicmd)/sizeof(s_aicmd[0]))

    UINT iFrom = fToMsoCmd ? 0 : 1;

    for (UINT i = 0; i < CCMD_MAX; i++) {
        if (s_aicmd[i][iFrom]==id) {
            return s_aicmd[i][1-iFrom];
        }
    }
    return (UINT)-1;
#undef CCMD_MAX
}

void CDocObjectHost::_InitToolbarButtons()
{
    OLECMD acmd[] = {
        { OLECMDID_ZOOM,  0 },  // Notes: This must be the first one
        { OLECMDID_PRINT, 0 },
        { OLECMDID_CUT,   0 },
        { OLECMDID_COPY,  0 },
        { OLECMDID_PASTE, 0 },
        { OLECMDID_REFRESH, 0 },
        { OLECMDID_STOP,  0 },  // Notes: This must be the last one
    };

    if (_pmsot) {
        _pmsot->QueryStatus(NULL, ARRAYSIZE(acmd), acmd, NULL);
    }
    if (_pmsoctBrowser) {
        // the browser may support stop also, so override the document
        // with what the browser says. this is okay because the browser
        // forwards stop back down the chain.
        _pmsoctBrowser->QueryStatus(NULL, 1, &acmd[ARRAYSIZE(acmd)-1], NULL);
    }

    if (_psb)
    {
        for (int i=1; i<ARRAYSIZE(acmd); i++)
        {
            UINT idCmd = _MapFromMso(acmd[i].cmdID);
            _psb->SendControlMsg(FCW_TOOLBAR, TB_ENABLEBUTTON, idCmd,
                        (LPARAM)acmd[i].cmdf, NULL);
        }
    }

    // Check if ZOOM command is supported.
    if (acmd[0].cmdf) 
    {
        VARIANTARG var;
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = 0;

        // get the current zoom depth
        _pmsot->Exec(NULL, OLECMDID_ZOOM, OLECMDEXECOPT_DONTPROMPTUSER, NULL, &var);
        if (var.vt == VT_I4) 
        {
            _iZoom = var.lVal;
        }
        else
        {
            VariantClear(&var);
        }

        // get the current zoom range
        var.vt = VT_I4;
        var.lVal = 0;
        _pmsot->Exec(NULL, OLECMDID_GETZOOMRANGE, OLECMDEXECOPT_DONTPROMPTUSER, NULL, &var);
        if (var.vt == VT_I4) 
        {
            _iZoomMin = (int)(short)LOWORD(var.lVal);
            _iZoomMax = (int)(short)HIWORD(var.lVal);
        }
        else
        {
            VariantClear(&var);
        }
    }
}

void CDocObjectHost::_OnSetStatusText(VARIANTARG* pvarIn)
{
    LPCWSTR pwch = VariantToStrCast(pvarIn);
    if (pwch && _psb) 
    {
        IShellView *psvActive;
        _psb->QueryActiveShellView(&psvActive);
        if (psvActive)
        {
            // Suppress sending status messages if we aren't the active view - else
            // we could be reporting nasties from unapproved PICS pages
            if (IsSameObject(_psv, psvActive))
            {
                TCHAR szHint[256];

                if (pwch)
                    SHUnicodeToTChar(pwch, szHint, ARRAYSIZE(szHint));
                else
                    szHint[0] = 0;

                _SetStatusText(szHint);
            }
            psvActive->Release();
        }
    }
}

//
// This function returns TRUE if
//  (1) the DocObject supports IPersistFile and
//  (2) IPersistFile::IsDirty returns S_OK.
// Caller may pass pppf to retrieve IPersistFile*, which will be AddRef'ed
// and returned only when this function returns TRUE.
//
BOOL CDocObjectHost::_IsDirty(IPersistFile** pppf)
{
    BOOL fDirty = FALSE;    // Assume non-dirty
    if (pppf)
        *pppf = NULL;

    if (_pole) 
    {
        IPersistFile* ppf;
        HRESULT hresT = _pole->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hresT))
        {
            if (ppf->IsDirty()==S_OK) 
            {
                fDirty = TRUE;
                if (pppf) 
                {
                    *pppf = ppf;
                    ppf->AddRef();
                }
            }
            ppf->Release();
        }
    }
    return fDirty;
}

void CDocObjectHost::_OnSetTitle(VARIANTARG *pvTitle)
{
    LPCWSTR pwch = VariantToStrCast(pvTitle);
    if (pwch) 
    {
        if (_pwb)
        {
            _pwb->SetTitle(_psv, pwch);
        }
    }

    // tell our parent DocObjectView about this as well
    if (_pdvs)
        _pdvs->OnSetTitle(pvTitle);
}


void CDocObjectHost::_OnCodePageChange(const VARIANTARG* pvarargIn)
{
    if (pvarargIn && pvarargIn->vt == VT_I4) 
    {
        TraceMsg(DM_DOCCP, "CDOH::OnExec SHDVID_ONCOEPAGECHANGE got %d", pvarargIn->lVal);
        VARIANT var = *pvarargIn;

        //
        // Since the UI (View->Fond) does not say "default codepage",
        // we don't need to be smart about it.
        //
        // if ((UINT)var.lVal == GetACP()) {
        //     var.lVal = CP_ACP;
        // }

        //
        // Change the 'current' codepage.
        //
        IBrowserService *pbs;
        if (SUCCEEDED(QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IBrowserService, &pbs))))
        {
            pbs->GetSetCodePage(&var, NULL);
            pbs->Release();
        }

        //
        // Write the codepage to the URL history
        //
        IUniformResourceLocator *   purl = NULL;
        HRESULT hresT = CoCreateInstance(CLSID_InternetShortcut, NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_PPV_ARG(IUniformResourceLocator, &purl));

        if (SUCCEEDED(hresT)) 
        {
            TCHAR szURL[MAX_URL_STRING];
            _GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE);
            _ValidateURL(szURL, UQF_DEFAULT);

            hresT = purl->SetURL(szURL, 0);
            if (SUCCEEDED(hresT)) 
            {
                IPropertySetStorage *ppropsetstg;
                hresT = purl->QueryInterface(IID_PPV_ARG(IPropertySetStorage, &ppropsetstg));
                if (SUCCEEDED(hresT)) 
                {
                    IPropertyStorage *ppropstg;
                    hresT = ppropsetstg->Open(FMTID_InternetSite, STGM_READWRITE, &ppropstg);
                    if (SUCCEEDED(hresT)) 
                    {
                        const static PROPSPEC c_aprop[] = {
                            { PRSPEC_PROPID, PID_INTSITE_CODEPAGE},
                        };
                        PROPVARIANT prvar = { 0 };
                        prvar.vt = VT_UI4;
                        prvar.lVal = var.lVal;
                        hresT = ppropstg->WriteMultiple(1, c_aprop, &prvar, 0);
                        TraceMsg(DM_DOCCP, "CDOH::_OnCodePageChange WriteMultile returned %x", hresT);

                        ppropstg->Commit(STGC_DEFAULT);
                        ppropstg->Release();
                    }
                    else
                    {
                        TraceMsg(DM_WARNING, "CDOH::_OnCodePageChange Open failed %x", hresT);
                    }

                    ppropsetstg->Release();
                }
                else
                {
                    TraceMsg(DM_WARNING, "CDOH::_OnCodePageChange QI failed %x", hresT);
                }
            }
            else
            {
                TraceMsg(DM_WARNING, "CDOH::_OnCodePageChange SetURL failed %x", hresT);
            }
            purl->Release();
        }
        else
        {
            TraceMsg(DM_WARNING, "CDOH::_OnCodePageChange CoCreate failed %x", hresT);
        }
    }
    else
    {
        ASSERT(0);
    }
}


void CDocObjectHost::_MappedBrowserExec(DWORD nCmdID, DWORD nCmdexecopt)
{
    if (_pmsoctBrowser)
    {
        DWORD nCmdIDCT = _MapToMso(nCmdID);
        ASSERT(nCmdIDCT != -1);     // if this rips, need to add missing case to _MapCommandID

        OLECMD rgcmd = {nCmdIDCT, 0};

        // Trident sometimes executes commands that are disabled (cut, paste) so
        // ensure that the command is enabled first
        
        BOOL fEnabled = (S_OK == _pmsoctBrowser->QueryStatus(NULL, 1, &rgcmd, NULL)) &&
                        (rgcmd.cmdf & OLECMDF_ENABLED);

        // APPHACK - 80104 Visio doesn't return OLECMDF_ENABLED, but we need to 
        // be able to execute the command to show the toolbars because they start off hidden. 

        if (!fEnabled && (nCmdID == DVIDM_SHOWTOOLS) && 
            (_GetAppHack() & BROWSERFLAG_ENABLETOOLSBTN))
        {
            fEnabled = TRUE;
        }

        if (fEnabled)
        {
            _pmsoctBrowser->Exec(NULL, nCmdIDCT, nCmdexecopt, NULL, NULL);
        }
    }
}

HRESULT CDocObjectHost::OnExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL)
    {
        // _InitToolbarButtons and _OnSetStatusText reference _psb directly
        if (!_psb)
            return E_FAIL;

        switch (nCmdID)
        {
        //
        // The containee has found an http-equiv meta tag; handle it
        // appropriately (client pull, PICS, etc)
        //
        case OLECMDID_HTTPEQUIV:
        case OLECMDID_HTTPEQUIV_DONE:
            if (_pwb)
            {
                _pwb->OnHttpEquiv(_psv, (nCmdID == OLECMDID_HTTPEQUIV_DONE), pvarargIn, pvarargOut);

                // Always return S_OK so that we don't try other codepath.
            }
            return S_OK;

        case OLECMDID_PREREFRESH:
            _fShowProgressCtl = TRUE;
            _PlaceProgressBar(TRUE);
            _OnSetProgressPos(0, PROGRESS_FINDING);
            if (IsGlobalOffline())
            {
                // This is pointing to a web address and we're offline
                // Ask the user if (s)he wants to go online
                TCHAR szURL[MAX_URL_STRING];
                if (SUCCEEDED(_GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE)) &&
                    UrlHitsNet(szURL))
                {
                    if (InternetGoOnline(szURL, _hwnd, TRUE) && _psb)
                    {
                        // Tell all browser windows to update their title and status pane
                        SendShellIEBroadcastMessage(WM_WININICHANGE,0,0, 1000);
                    }
                }
            }
            return S_OK;

        case OLECMDID_REFRESH:
            if (_pmsot)
                _pmsot->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            return S_OK;

        case OLECMDID_OPEN:
            _OnOpen();
            return S_OK;

        case OLECMDID_SAVE:
            _OnSave();
            return S_OK;

        case OLECMDID_CLOSE:
            _OnClose();
            return S_OK;

        case OLECMDID_UPDATECOMMANDS:
            _InitToolbarButtons();
            return E_FAIL; // lie and say we don't do anything to forward the command on

        case OLECMDID_SETPROGRESSMAX:
            ASSERT(pvarargIn->vt == VT_I4);
            TraceMsg(TF_SHDPROGRESS, "DOH::Exec() SETPROGRESSMAX = %d", pvarargIn->lVal );
            if (pvarargIn->lVal)
                _OnSetProgressMax(ADJUSTPROGRESSMAX((DWORD) pvarargIn->lVal));
            return S_OK;

        case OLECMDID_SETPROGRESSPOS:
            ASSERT(pvarargIn->vt == VT_I4);
            TraceMsg(TF_SHDPROGRESS, "DOH::Exec() SETPROGRESSPOS = %d", pvarargIn->lVal );
            if (pvarargIn->lVal)
                _OnSetProgressPos((DWORD) pvarargIn->lVal, PROGRESS_RECEIVING);
            return S_OK;

        case OLECMDID_SETPROGRESSTEXT:
            _OnSetStatusText(pvarargIn);
            return S_OK;

        case OLECMDID_SETTITLE:
            if (!pvarargIn)
                return E_INVALIDARG;

            _OnSetTitle(pvarargIn); // We are guaranteed to get atleast 1 OLECMDID_SETTITLE.
            return S_OK;

        // case OLECMDID_PRINT:
        //   In the up direction, this case is handled by the outermost frame as
        // a request to print from the docobj. It handles it by sending an OLECMDID_PRINT
        // back to the docobj to print. (Or, as in Binder, to all the docobjects.)

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
            case SHDVID_SSLSTATUS:
            {
                // Ask the user if (s)he wants to go online
                TCHAR szURL[MAX_URL_STRING];
                if (SUCCEEDED(_GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE)))
                {
                    if (_bsc._pszRedirectedURL && *_bsc._pszRedirectedURL)
                        StrCpyN(szURL, _bsc._pszRedirectedURL, ARRAYSIZE(szURL));

                    ULONG_PTR uCookie = 0;
                    SHActivateContext(&uCookie);
                    InternetShowSecurityInfoByURL(szURL, _hwnd);
                    if (uCookie)
                    {
                        SHDeactivateContext(uCookie);
                    }
                }

                break;
            }

            case SHDVID_ZONESTATUS:
            {
                // Load the current url into the properties page
                if (!SHRestricted2W(REST_NoBrowserOptions, NULL, 0))
                {
                    TCHAR szBuf[MAX_URL_STRING];
                    _GetCurrentPage(szBuf, ARRAYSIZE(szBuf));

                    ULONG_PTR uCookie = 0;
                    SHActivateContext(&uCookie);
                    ZoneConfigureW(_hwnd, szBuf);
                    if (uCookie)
                    {
                        SHDeactivateContext(uCookie);
                    }
                }
                return S_OK;
            }

            case SHDVID_PRIVACYSTATUS:
            {
                IEnumPrivacyRecords     *pEnum = NULL;
                LPOLESTR                pszName = NULL;
                BOOL                    fReportAllSites = (nCmdexecopt == TRUE);

                if(_pmkCur)
                {
                    if(FAILED(_pmkCur->GetDisplayName(_pbcCur, NULL, &pszName)))
                    {
                        pszName = NULL;
                    }
                }

                if(_psp && SUCCEEDED(_psp->QueryService(IID_IEnumPrivacyRecords, IID_IEnumPrivacyRecords, (void **)&(pEnum))))
                {
                    BOOL fImpacted;

                    if(fReportAllSites ||
                        (SUCCEEDED(pEnum->GetPrivacyImpacted(&fImpacted)) && fImpacted))
                    {
                        DoPrivacyDlg(_hwnd, pszName, pEnum, fReportAllSites);
                    }
                    pEnum->Release();
                }

                if(pszName)
                {
                    OleFree(pszName);
                }

                return S_OK;
            }

            case SHDVID_QUERYMERGEDHELPMENU:
                if (_hmenuMergedHelp)
                {
                    pvarargOut->vt = VT_INT_PTR;
                    pvarargOut->byref = _hmenuMergedHelp;
                    return S_OK;
                }
                return S_FALSE;

            case SHDVID_QUERYOBJECTSHELPMENU:
                if (_hmenuObjHelp)
                {
                    pvarargOut->vt = VT_INT_PTR;
                    pvarargOut->byref = _hmenuObjHelp;
                    return S_OK;
                }
                return S_FALSE;

            case SHDVID_GETSYSIMAGEINDEX:
                if (_dwAppHack & BROWSERFLAG_MSHTML) {
                    ASSERT(pvarargOut->vt==0);
                    pvarargOut->vt = VT_I4;
                    pvarargOut->lVal = _GetIEHTMLImageIndex();
                    return S_OK;
                }
                return E_FAIL;

            case SHDVID_AMBIENTPROPCHANGE:
                // An ambient property above us has changed, let the docobj know
                if (_pmsoc)
                {
                    ASSERT(pvarargIn->vt == VT_I4);
                    return(_pmsoc->OnAmbientPropertyChange(pvarargIn->lVal));
                }
                return E_FAIL;

            case SHDVID_CANDOCOLORSCHANGE:
                return IUnknown_Exec(_pole, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

            case SHDVID_ONCOLORSCHANGE:
                // this comes from trident and needs passing back up to our parent ...
                if ( _pmsoctBrowser )
                {
                    return _pmsoctBrowser->Exec( pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut );
                }
                else
                    return E_FAIL;

            case SHDVID_GETOPTIONSHWND:
                if ( _pmsoctBrowser )
                {
                    return _pmsoctBrowser->Exec( pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut );
                }
                else
                {
                    return E_FAIL;
                }

            case SHDVID_DOCWRITEABORT:
                //  pending DocObject wants to us to abort any binding and activate
                //  it directly
                if (_bsc._pib && _bsc._fBinding && _punkPending && !_pole)
                {
                    _bsc._fDocWriteAbort = 1;
                    _bsc.OnObjectAvailable(IID_IUnknown, _punkPending);
                    _bsc.AbortBinding();
                }
                //  report READYSTATE_COMPLETE so that when document.open() falls
                //  back to READYSTATE_INTERACTIVE Trident doesn't get confused...
                //
                //  chrisfra 4/15/97, is this the only way to force TRIDENT
                //  to not lose fact of download complete when document.open()
                //  falls back to READYSTATE_INTERACTIVE.
                //
                //  During the above OnObjectAvailable call, we fire a READYSTATE_COMPLETE
                //  event if (1) object doesn't support it or (2) object already at it.
                //  (Neither of these should be the case, but we should be careful, eh?)
                //  We want to force a READYSTATE_COMPLETE here in other cases, so unhook
                //  the IPropertyNotifySink (to prevent multiple _COMPLETE events). If we
                //  unhook the sink, then we didn't fire _COMPLETE above, so fire it now.
                //
                if (_dwPropNotifyCookie)
                {
                    _OnReadyState(READYSTATE_COMPLETE);
                }

                return S_OK;

            case SHDVID_CANACTIVATENOW:
            {
                HRESULT hres = (_PicsProcBase._fPicsAccessAllowed && !_PicsProcBase._fbPicsWaitFlags && _pole && _fReadystateInteractiveProcessed) ? S_OK : S_FALSE;
                TraceMsg(DM_PICS, "CDOH::OnExec(SHDVID_CANACTIVATENOW) returning %ls", (hres == S_OK) ? "S_OK" : "S_FALSE");
                return hres;
            }

            case SHDVID_SETSECURELOCK:
                {
                    //
                    //  if we are already active, then we need to go ahead
                    //  and forward this up the browser. otherwise, cache it
                    //  and wait until activated to forward it
                    //
                    TraceMsg(DM_SSL, "[%X]DOH::Exec() SETSECURELOCK lock = %d", this, pvarargIn->lVal);

                    _fSetSecureLock = TRUE;
                    _eSecureLock = pvarargIn->lVal;

                    IShellView *psvActive;
                    if (_psb && SUCCEEDED(_psb->QueryActiveShellView(&psvActive) ))
                    {
                        if (psvActive && IsSameObject(_psv, psvActive))
                            _ForwardSetSecureLock(pvarargIn->lVal);

                        ATOMICRELEASE(psvActive);
                    }
                    return S_OK;
                }

            case SHDVID_FORWARDSECURELOCK:
                _ForwardSetSecureLock(_fSetSecureLock ? _eSecureLock : SECURELOCK_SET_UNSECURE);
                return S_OK;

            case SHDVID_ONCODEPAGECHANGE:
                _OnCodePageChange(pvarargIn);
                return S_OK;

            case SHDVID_DISPLAYSCRIPTERRORS:
            case SHDVID_NAVIGATIONSTATUS:
            {
                // if we're a weboc then this script err list should be null
                ASSERT(!_fWebOC || _pScriptErrList == NULL);

                if (_pScriptErrList != NULL && !_pScriptErrList->IsEmpty())
                {
                    // do the script error info dialog
                    _ScriptErr_Dlg(TRUE);
                }

                return S_OK;
            }
            break;

            case SHDVID_RESETSTATUSBAR:
                {
                    _ResetStatusBar();
                    return S_OK;
                }
                break;

            default:
                return OLECMDERR_E_NOTSUPPORTED;
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        switch (nCmdID) {
        case SBCMDID_MAYSAVECHANGES:
            return _OnMaySaveChanges();

        case SBCMDID_GETPANE:
            switch(nCmdexecopt)
            {
                case PANE_NAVIGATION:
                    V_I4(pvarargOut) = STATUS_PANE_NAVIGATION;
                    return S_OK;

                case PANE_PROGRESS:
                    V_I4(pvarargOut) = STATUS_PANE_PROGRESS;
                    return S_OK;

                case PANE_ZONE:
                    V_I4(pvarargOut) = STATUS_PANE_ZONE;
                    return S_OK;

                case PANE_OFFLINE:
                    V_I4(pvarargOut) = STATUS_PANE_OFFLINE;
                    return S_OK;

                case PANE_PRINTER:
                    V_I4(pvarargOut) = STATUS_PANE_PRINTER;
                    return S_OK;

                case PANE_SSL:
                    V_I4(pvarargOut) = STATUS_PANE_SSL;
                    return S_OK;

                case PANE_PRIVACY:
                    V_I4(pvarargOut) = STATUS_PANE_PRIVACY;
                    return S_OK;

                default:
                    V_I4(pvarargOut) = PANE_NONE;
                    return S_OK;
            }

        case SBCMDID_ONCLOSE:
            _fClosing = TRUE;
            return S_OK;

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        } // switch
    }
    else if (IsEqualGUID(CGID_DocHostCommandHandler, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
        case OLECMDID_SAVEAS:
            _OnSaveAs();
            return S_OK;

        case OLECMDID_SHOWSCRIPTERROR:
            {
                HRESULT hr;

                hr = S_OK;

                if (_fWebOC)
                {
                    // we're a web oc.
                    // pass the handling of this script error to
                    // an appropriate CDocHostUIHandler

                    if (_pWebOCUIHandler != NULL)
                    {
                        IOleCommandTarget * pioct;

                        ASSERT(IS_VALID_CODE_PTR(_pWebOCUIHandler, IDocHostUIHandler));

                        hr = _pWebOCUIHandler->QueryInterface(IID_IOleCommandTarget, (void **) &pioct);
                        if (SUCCEEDED(hr))
                        {
                            hr = pioct->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

                            pioct->Release();
                        }
                    }
                    else
                    {
                        hr = _dhUIHandler.Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                    }
                }
                else
                {
                    ASSERT(IS_VALID_READ_PTR(pvarargIn, VARIANTARG));
                    ASSERT(IS_VALID_WRITE_PTR(pvarargOut, VARIANTARG));

                    // we're not a web oc so we have to handle this
                    // ourselves, so cache the errors for later
                    // display in the new script error dialog

                    if (pvarargIn == NULL || pvarargOut == NULL)
                    {
                        hr = E_INVALIDARG;
                    }

                    if (SUCCEEDED(hr))
                    {
                        if (_pScriptErrList == NULL)
                        {

                            // create a new script error list
                            _pScriptErrList = new CScriptErrorList;
                            if (_pScriptErrList == NULL)
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }

                        if (SUCCEEDED(hr))
                        {
                            TCHAR   szMsg[MAX_PATH];

                            // stuff the error icon into the status bar
                            if (g_hiconScriptErr != NULL)
                            {
                                if (_psb != NULL)
                                {
                                    _psb->SendControlMsg(FCW_STATUS,
                                                         SB_SETICON,
                                                         STATUS_PANE_NAVIGATION,
                                                         (LPARAM)g_hiconScriptErr,
                                                         NULL);
                                }
                            }

                            // stuff the error text into the status bar
                            MLLoadString(IDS_SCRIPT_ERROR_ON_PAGE, szMsg, ARRAYSIZE(szMsg));
                            _SetPriorityStatusText(szMsg);

                            // stuff the error data into the cache
                            _ScriptErr_CacheInfo(pvarargIn);

                            // pop up the dialog
                            _ScriptErr_Dlg(FALSE);

                            V_VT(pvarargOut) = VT_BOOL;
                            if (_pScriptErrList->IsFull())
                            {
                                // stop running scripts
                                V_BOOL(pvarargOut) = VARIANT_FALSE;
                            }
                            else
                            {
                                // keep running scripts
                                V_BOOL(pvarargOut) = VARIANT_TRUE;
                            }
                        }
                    }
                }

                return hr;
            }
            break;

        case OLECMDID_SHOWMESSAGE:
        case OLECMDID_SHOWFIND:
        case OLECMDID_SHOWPAGESETUP:
        case OLECMDID_SHOWPRINT:
        case OLECMDID_PROPERTIES:
            {
                return _dhUIHandler.Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            }
            break;

        //
        // Refresh the original page if an error page is dispalyed.
        //

        case IDM_REFRESH:
        case IDM_REFRESH_TOP:
        case IDM_REFRESH_TOP_FULL:
        case IDM_REFRESH_THIS:
        case IDM_REFRESH_THIS_FULL:
        {
            HRESULT hr = OLECMDERR_E_NOTSUPPORTED;

            if (_pScriptErrList != NULL)
            {
                // clear out the script error list
                _pScriptErrList->ClearErrorList();
                _SetPriorityStatusText(NULL);

                // reset the text and icon
                _ResetStatusBar();
            }

            //
            // If there is a refresh url for this object use it for the refresh.
            // Otherwise fall through and let the client handle it.
            //

            if (_pwszRefreshUrl)
            {
                _fRefresh = TRUE;
                _DoAsyncNavigation(_pwszRefreshUrl);
                hr = S_OK;
            }
            else
            {
                //
                // Non http errors (syntax, DNS, etc) are handled by a async nav
                // to res://shdocvw/error.htm#originalurl.  Handle the refresh
                // for those pages here.
                //
                if (_pmkCur)
                {
                    LPOLESTR pstrUrl;

                    if (SUCCEEDED(_pmkCur->GetDisplayName(_pbcCur, NULL, &pstrUrl)))
                    {

                        if (IsErrorUrl(pstrUrl) && _pszLocation && *_pszLocation)
                        {
                            //
                            // The error url has the form:
                            // "res://shdocvw.dll/http404.htm#http://foo.bar"
                            // Where foo.bar is the the url the user tried to navigate to.
                            // _pszLocation points to "#foo.bar"
                            DWORD dwScheme = GetUrlScheme(_pszLocation + 1);
                            BOOL fDoNavigation = ((URL_SCHEME_HTTP == dwScheme) ||
                               (URL_SCHEME_HTTPS == dwScheme) ||
                               (URL_SCHEME_FTP == dwScheme) ||
                               (URL_SCHEME_GOPHER == dwScheme));

                            //
                            if (fDoNavigation) // otherwise it's a security problem !
                            {
                                _fRefresh = TRUE;
                                _DoAsyncNavigation(_pszLocation + 1);
                            }
                            hr = S_OK;
                        }

                        OleFree(pstrUrl);
                    }
                }
            }

            return hr;
            break;
        }
        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }
    else if (IsEqualGUID(*pguidCmdGroup, CLSID_InternetButtons) ||
             IsEqualGUID(*pguidCmdGroup, CLSID_MSOButtons))
    {
        UEMFireEvent(&UEMIID_BROWSER, UEME_UITOOLBAR, UEMF_XEVENT, UIG_OTHER, nCmdID);
        if (nCmdexecopt == OLECMDEXECOPT_PROMPTUSER) {
            // the user hit the drop down
            if (_pmsoctBrowser && pvarargIn && pvarargIn->vt == VT_INT_PTR)
            {
                // v.vt = VT_INT_PTR;
                POINT pt;
                RECT* prc = (RECT*)pvarargIn->byref;
                pt.x = prc->left;
                pt.y = prc->bottom;

                switch (nCmdID)
                {
                case DVIDM_MAILNEWS:
                    {
                        VARIANTARG v = {VT_I4};
                        v.lVal = MAKELONG(prc->left, prc->bottom);
                        _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_DOMAILMENU, 0, &v, NULL);
                        break;
                    }

                case DVIDM_FONTS:
                    {
                        VARIANTARG v = {VT_I4};
                        v.lVal = MAKELONG(prc->left, prc->bottom);
                        _pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_FONTMENUOPEN, 0, &v, NULL);
                        break;
                    }

                case DVIDM_ENCODING:
                    {
                        VARIANTARG v = {VT_I4};
                        v.lVal = MAKELONG(prc->left, prc->bottom);
                        _pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_MIMECSETMENUOPEN, 0, &v, NULL);
                        break;
                    }
                }
            }
            return S_OK;
        }

        // CommandIDs from DVIDM_MENUEXT_FIRST to DVIDM_MENUEXT_LAST are reserved for toolbar extension buttons
        // Do NOT use this range for constants within the scope of CLSID_InternetButtons/CLSID_MSOButtons!
        if (InRange(nCmdID, DVIDM_MENUEXT_FIRST, DVIDM_MENUEXT_LAST))
        {
            IUnknown_Exec(_pBrowsExt, &CLSID_ToolbarExtButtons, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
        else
        {
            switch(nCmdID) {

            case DVIDM_DISCUSSIONS:
                if (_pmsoctBrowser)
                    _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_DISCUSSIONBAND, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
                break;

            case DVIDM_CUT:
            case DVIDM_COPY:
            case DVIDM_PASTE:
                _MappedBrowserExec(nCmdID, 0);
                break;

            case DVIDM_PRINT:
            case DVIDM_PRINTPREVIEW:
            case DVIDM_SHOWTOOLS:
                _MappedBrowserExec(nCmdID, OLECMDEXECOPT_DONTPROMPTUSER);
                break;

            case DVIDM_EDITPAGE:
                if (_psp) {
                    // temp code -- forward to itbar
                    // itbar edit code is moving here soon
                    IExplorerToolbar* pxtb;
                    if (SUCCEEDED(_psp->QueryService(SID_SExplorerToolbar, IID_IExplorerToolbar, (void **)&pxtb))) {
                        IUnknown_Exec(pxtb, &CGID_PrivCITCommands, CITIDM_EDITPAGE, nCmdexecopt, pvarargIn, pvarargOut);
                        pxtb->Release();
                    }
                }
                break;
            }
        }
        return S_OK;
    }
    else if (IsEqualGUID(IID_IExplorerToolbar, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case ETCMDID_GETBUTTONS:
        {
            int nNumExtButtons = 0;

            if (_pBrowsExt)
            {
                _pBrowsExt->GetNumButtons((UINT*)&nNumExtButtons);
            }

            int nNumButtons = nNumExtButtons + ARRAYSIZE(c_tbStd);

            if ((_nNumButtons != nNumButtons) && (_ptbStd != NULL))
            {
                delete [] _ptbStd;
                _ptbStd = NULL;
            }

            if (_ptbStd == NULL)
            {
                _ptbStd = new TBBUTTON[nNumButtons];
                if (_ptbStd == NULL)
                {
                    return E_OUTOFMEMORY;
                }
                _nNumButtons = nNumButtons;
            }

            memcpy(_ptbStd, c_tbStd, SIZEOF(TBBUTTON) * ARRAYSIZE(c_tbStd));

            // Init the string ids
            ASSERT(_ptbStd[6].idCommand == DVIDM_CUT);
            ASSERT(_ptbStd[7].idCommand == DVIDM_COPY);
            ASSERT(_ptbStd[8].idCommand == DVIDM_PASTE);
            ASSERT(_ptbStd[9].idCommand == DVIDM_ENCODING);
            ASSERT(_ptbStd[10].idCommand == DVIDM_PRINTPREVIEW);

            if (-1 != _iString)
            {
                _ptbStd[6].iString = _iString;
                _ptbStd[7].iString = _iString + 1;
                _ptbStd[8].iString = _iString + 2;
                _ptbStd[9].iString = _iString + 3;
                _ptbStd[10].iString = _iString + 4;
            }
            else
            {
                _ptbStd[6].iString = _ptbStd[7].iString = _ptbStd[8].iString = _ptbStd[9].iString = _ptbStd[10].iString = -1;
            }

            if (_pBrowsExt)
            {
                _pBrowsExt->GetButtons(&_ptbStd[ARRAYSIZE(c_tbStd)], nNumExtButtons, FALSE);
            }

            ASSERT(_ptbStd[0].idCommand == DVIDM_SHOWTOOLS);
            if (!_ToolsButtonAvailable())
                _ptbStd[0].fsState |= TBSTATE_HIDDEN;

            ASSERT(_ptbStd[1].idCommand == DVIDM_MAILNEWS);
            if (!_MailButtonAvailable())
                _ptbStd[1].fsState |= TBSTATE_HIDDEN;

            ASSERT(_ptbStd[5].idCommand == DVIDM_DISCUSSIONS);
            if (!_DiscussionsButtonAvailable())
                _ptbStd[5].fsState |= TBSTATE_HIDDEN;

            nNumButtons = RemoveHiddenButtons(_ptbStd, nNumButtons);

            pvarargOut->vt = VT_BYREF;
            pvarargOut->byref = (LPVOID)_ptbStd;
            *pvarargIn->plVal = nNumButtons;
            break;
        }
        case ETCMDID_RELOADBUTTONS:
            _AddButtons(TRUE);
            break;
        }
        return S_OK;
    }
    else if (IsEqualGUID(CGID_InternetExplorer, *pguidCmdGroup))
    {
        switch (nCmdID) {
        case IECMDID_SET_INVOKE_DEFAULT_BROWSER_ON_NEW_WINDOW:
        case IECMDID_GET_INVOKE_DEFAULT_BROWSER_ON_NEW_WINDOW:
        case IECMDID_BEFORENAVIGATE_GETSHELLBROWSE:
        case IECMDID_BEFORENAVIGATE_DOEXTERNALBROWSE: 
        case IECMDID_BEFORENAVIGATE_GETIDLIST:
            if ( _pmsoctBrowser )
            {
                return _pmsoctBrowser->Exec( pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut );
            }
            else
            {
                return E_FAIL;
            }

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }

    return OLECMDERR_E_UNKNOWNGROUP;
}


HRESULT CDocObjectHost::_OnMaySaveChanges(void)
{
   HRESULT hres = S_OK;

    //
    // ASSUMPTIONS:
    //  1. Not supporting IPersistFile indicates we don't need to worry
    //   about prompting the user for "save as".
    //  2. DocObject which returns S_OK for IPersistFile::S_OK implements
    //   OLECMDID_SAVEAS.
    //
    if (_fFileProtocol || _pmsot)
    {
        IPersistFile* ppf;
        if (_IsDirty(&ppf))
        {
            ASSERT(ppf);

            TCHAR szBuf[MAX_URL_STRING];
            UINT id;

            _GetCurrentPage(szBuf, ARRAYSIZE(szBuf));
            id = MLShellMessageBox(_hwnd,
                MAKEINTRESOURCE(IDS_MAYSAVEDOCUMENT), szBuf, MB_YESNOCANCEL);
            switch(id) {
            case IDCANCEL:
                hres = S_FALSE;
                break;

            case IDYES:
                if (_fFileProtocol) {
                    // 80105 APPHACK: Due to valid fixes in Urlmon, Visio is unable to save
                    // because we are loading the object with read-only flags.  So we show
                    // the Save As dialog to let the user choose another filename.

                    if (_GetAppHack() & BROWSERFLAG_SAVEASWHENCLOSING)
                    {
                        if (_OnSaveAs() != S_OK)
                            hres = S_FALSE;
                    }
                    else
                        _OnSave();

                } else {
                    HRESULT hresT=_pmsot->Exec(NULL, OLECMDID_SAVEAS, OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
                    SAVEMSG("Exec(OLECMDID_SAVEAS) returned", hresT);

                    // Cancel the navigation if it failed.
                    if (FAILED(hresT)) {
                        // Beep if it is not canceled by the end user.
                        TraceMsg(DM_WARNING, "CDOH::_OnMaySaveChanges Exec(OELCMDID_SAVEAS) returned %x", hresT);
                        if (hresT != OLECMDERR_E_CANCELED) {
                            MessageBeep(0);
                        }
                        hres = S_FALSE;
                    }
                }

                break;

            case IDNO:
                //
                //  If user says 'No' to save changes to this page,
                // we should remove it from the cache so that
                // the user won't see that discarded change.
                //
                //  (pri-2) This object discarding mechanism
                // does not work for POSTed result, which is cached
                // in the travel log.
                //
                break;
            }

            ppf->Release();
        } else {
            ASSERT(ppf==NULL);
        }
    }

    //
    //  In addition, we give a chance to save the contents of the page (when
    // the document is acted as a form -- data-bound Trident page is a good
    // example) to the backend database.
    //
    
    if (hres == S_OK && _pmsot && (!_fDocCanNavigate || _fClosing))
    {
        VARIANT varOut = {0};
        HRESULT hresT = _pmsot->Exec(NULL, OLECMDID_ONUNLOAD, OLECMDEXECOPT_PROMPTUSER, NULL, &varOut);

        if (varOut.vt == VT_BOOL && varOut.boolVal != VARIANT_TRUE)
        {
            hres = S_FALSE;
        }
    }

    return hres;
}

BOOL _ExecNearest(const GUID *pguidCmdGroup, DWORD nCmdID, BOOL fDown)
{
    // Some commands we want to do in the closest frame to the docobj,
    // some in the farthest-away frame, and some we want to handle
    // in the top-most dochost. Look at the command to figure out
    // the routing and then do it.
    BOOL fNearest = FALSE; // most everything goes to the farthest-away frame
    if (pguidCmdGroup==NULL)
    {
        switch(nCmdID)
        {
        case OLECMDID_OPEN:
        case OLECMDID_SAVE:
        case OLECMDID_SETTITLE:
        case OLECMDID_HTTPEQUIV:
        case OLECMDID_HTTPEQUIV_DONE:
            fNearest = TRUE;
            break;

        // some are top-most down, so nearest depends on direction.
        case OLECMDID_REFRESH:
        // say top-most for commands that only work on the topmost guy.
        // (ie, these probably should be implemented in CShellBrowser!)
        // do this even though these are really "upwards-only" commands.
        case OLECMDID_UPDATECOMMANDS:
        case OLECMDID_SETPROGRESSMAX:
        case OLECMDID_SETPROGRESSPOS:
        case OLECMDID_SETPROGRESSTEXT:
        case OLECMDID_SHOWSCRIPTERROR:
            fNearest = fDown;
            break;
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SHDVID_AMBIENTPROPCHANGE:
        case SHDVID_GETSYSIMAGEINDEX:
        case SHDVID_DOCWRITEABORT:
        case SHDVID_ONCODEPAGECHANGE:
        case SHDVID_CANDOCOLORSCHANGE:
        case SHDVID_SETSECURELOCK:
        case SHDVID_QUERYMERGEDHELPMENU:
        case SHDVID_QUERYOBJECTSHELPMENU:
            fNearest = TRUE;
            break;

        case SHDVID_DISPLAYSCRIPTERRORS:
            fNearest = fDown;
            break;
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
        case SBCMDID_MAYSAVECHANGES:    // since OLECMDID_SAVE is to the nearest frame
            fNearest = TRUE;
            break;
        }
    }
    else if (IsEqualGUID(IID_IExplorerToolbar, *pguidCmdGroup) ||
             IsEqualGUID(CLSID_InternetButtons, *pguidCmdGroup) ||
             IsEqualGUID(CLSID_MSOButtons, *pguidCmdGroup))
    {
        fNearest = TRUE;
    }

    return fNearest;
}

HRESULT CDocObjectHost::Exec(const GUID * pguidCmdGroup,
                             DWORD        nCmdID,
                             DWORD        nCmdexecopt,
                             VARIANTARG * pvarargIn,
                             VARIANTARG * pvarargOut)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup)
    {
        // Now that BaseBrowser understands that CGID_MSHTML should be directed to the DocObject, we'll
        // get caught in a loop if we send those Execs through here.  Cut it off at the pass.
        if (IsEqualGUID(CGID_MSHTML, *pguidCmdGroup))
        {
            return hres;
        }
        else if (IsEqualGUID(CGID_DocHostCommandHandler, *pguidCmdGroup))
        {
            BOOL fHandled = FALSE;

            HRESULT hr = _HandleDocHostCmds(nCmdID,
                                            nCmdexecopt, 
                                            pvarargIn, 
                                            pvarargOut,
                                            &fHandled);
            if (fHandled)
            {
                return hr;
            }
        }
        else if (IsEqualGUID(CGID_DocHostCmdPriv, *pguidCmdGroup))
        {
            BOOL fHandled = FALSE;

            HRESULT hr = _HandleDocHostCmdPriv(nCmdID,
                                               nCmdexecopt,
                                               pvarargIn,
                                               pvarargOut,
                                               &fHandled);
            if (fHandled)
            {
                return hr;
            }
        }
        else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
        {
            if (_HandleShdocvwCmds(nCmdID, nCmdexecopt, pvarargIn, pvarargOut))
            {
                return S_OK;
            }
        }
    }

    BOOL fNearest = _ExecNearest(pguidCmdGroup, nCmdID, FALSE);

    if (fNearest)
        hres = OnExec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    if (FAILED(hres) && _pmsoctBrowser)
    {
        hres = _pmsoctBrowser->Exec(pguidCmdGroup, nCmdID, nCmdexecopt,
                                    pvarargIn, pvarargOut);
    }

    // If this is a command that puts up UI and the user presses
    // cancel in the above call, we may try to handle the call here,
    // and that would be bad. Steal OleCmdHRHandled() from MSHTML.
    if (FAILED(hres) && !fNearest)
        hres = OnExec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    return hres;
}

//+---------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_HandleDocHostCmds
//
//  Synopsis : Handles the CMD IDs for CGID_DocHostCommandHandler.
//
//+---------------------------------------------------------------------------

HRESULT
CDocObjectHost::_HandleDocHostCmds(DWORD nCmdID,
                                   DWORD nCmdexecopt,
                                   VARIANTARG * pvarargIn,
                                   VARIANTARG * pvarargOut,
                                   BOOL       * pfHandled)
{
    HRESULT hres = E_FAIL;

    ASSERT(pfHandled);

    *pfHandled = TRUE;

    switch(nCmdID) 
    {
    // Call from Trident printing with the page # of the currently spooling page.
    // Convert it to a bool indicating whether or not to draw the print icon in the browser.
    case OLECMDID_UPDATEPAGESTATUS:
        hres = E_INVALIDARG;

        if (pvarargIn && pvarargIn->vt == VT_I4)
        {
            VARIANTARG varIn;
            V_VT(&varIn) = VT_BOOL;
            V_BOOL(&varIn)= (pvarargIn->lVal > 0) ? VARIANT_TRUE : VARIANT_FALSE;

            hres = _pmsoctBrowser->Exec(&CGID_ShellDocView,
                                        SHDVID_SETPRINTSTATUS,
                                        0,
                                        &varIn,
                                        NULL);

        } 

        break;

    case OLECMDID_REFRESH:
        // if the print Preview template is up, then we need to block refresh. IE bug (99685)
        hres = _dhUIHandler.Exec(&CGID_DocHostCommandHandler,
                                  OLECMDID_REFRESH,
                                  nCmdexecopt, pvarargIn, pvarargOut);
        break;

    // Allow the command ID to be passed down the Exec chain.
    //
    default:
        *pfHandled = FALSE;
        break;
    }

    return hres;
}

//+---------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_HandleDocHostCmdPriv
//
//  Synopsis : Handles the CMD IDs for CGID_DocHostCmdPriv
//
//+---------------------------------------------------------------------------

HRESULT
CDocObjectHost::_HandleDocHostCmdPriv(DWORD nCmdID,
                                      DWORD nCmdexecopt,
                                      VARIANTARG * pvarargIn,
                                      VARIANTARG * pvarargOut,
                                      BOOL       * pfHandled)
{
    HRESULT hres = E_FAIL;

    ASSERT(pfHandled);

    *pfHandled = TRUE;

    switch(nCmdID) 
    {
    case DOCHOST_DOCCANNAVIGATE:
        {
            // We only set the navigation window for the top-level browser.
            // Even though the WebOC is no longer in frames, it can still
            // be present on a web page as a view link or control.
            //
            DWORD dwFlags = 0;

            if ( _pwb )
            {
                hres = _pwb->GetFlags(&dwFlags);
            }

            if ((dwFlags & BSF_TOPBROWSER) || _IsInBrowserBand())
            {
                ATOMICRELEASE(_pHTMLWindow);

                if (pvarargIn && VT_UNKNOWN == V_VT(pvarargIn) && V_UNKNOWN(pvarargIn))
                {
                    _fDocCanNavigate = TRUE;
        
                    hres = V_UNKNOWN(pvarargIn)->QueryInterface(IID_IHTMLWindow2,
                                                                (void**)&_pHTMLWindow);
                }
                else
                {
                    _fDocCanNavigate = FALSE;
                }
            }

            // Pass to the parent shell browser.
            if (_pmsoctBrowser)
            {
                hres = _pmsoctBrowser->Exec(&CGID_DocHostCmdPriv, nCmdID,
                                            nCmdexecopt, pvarargIn, pvarargOut);
            }
        }

        break;

    case DOCHOST_READYSTATE_INTERACTIVE:
        if ( _pScriptErrList != NULL)
            ClearScriptError();
        hres = S_OK;            
        break;
        
    case DOCHOST_NAVIGATION_ERROR:
        hres = _HandleFailedNavigation(pvarargIn, pvarargOut );
        break;

    case DOCHOST_NOTE_ERROR_PAGE:
        _fErrorPage = TRUE;
        break;

    case DOCHOST_CONTENTDISPOSITIONATTACH:
        hres = _OnContentDisposition();
        break;

    case DOCHOST_RESETSEARCHINFO:
        // Reset search info.
        _bsc._SetSearchInfo(this, 0, FALSE, FALSE, FALSE);
        break;

    case DOCHOST_SENDINGREQUEST:
        _OnSetProgressPos(0, PROGRESS_SENDING);

        _fShowProgressCtl = TRUE;
        _PlaceProgressBar(TRUE);

        hres = S_OK;
        break;

    case DOCHOST_FINDINGRESOURCE:
        _OnSetProgressPos(0, PROGRESS_FINDING);

        _fShowProgressCtl = TRUE;
        _PlaceProgressBar(TRUE);

        hres = S_OK;
        break;

    // Allow the command ID to be passed down the Exec chain.
    //
    default:
        *pfHandled = FALSE;
        break;
    }

    return (S_FALSE == hres) ? S_OK : hres;
}

//+---------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_HandleShdocvwCmds
//
//  Synopsis : Handles the CMD IDs for CGID_ShellDocView.
//
//+---------------------------------------------------------------------------

BOOL
CDocObjectHost::_HandleShdocvwCmds(DWORD        nCmdID,
                                   DWORD        nCmdexecopt,
                                   VARIANTARG * pvarargIn,
                                   VARIANTARG * pvarargOut)
{
    BOOL fHandled = TRUE;

    switch(nCmdID)
    {
    case SHDVID_STARTPICSFORWINDOW:
        _StartPicsForWindow(pvarargIn, pvarargOut);
        break;
        
    case SHDVID_CANCELPICSFORWINDOW:
        _CancelPicsForWindow(pvarargIn);
        break;

    case SHDVID_ISPICSENABLED:
        _IsPicsEnabled(pvarargOut);
        break;

    default:
        fHandled = FALSE;
    }

    return fHandled;
}

//+-----------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_StartPicsForWindow
//
//+-----------------------------------------------------------------------------

void
CDocObjectHost::_StartPicsForWindow(VARIANTARG * pvarargIn, VARIANTARG * pvarargOut)
{
    ASSERT(pvarargIn);
    ASSERT(VT_UNKNOWN == V_VT(pvarargIn));
    ASSERT(V_UNKNOWN(pvarargIn));
    ASSERT(pvarargOut);
    ASSERT(V_VT(pvarargOut) == VT_EMPTY);

    IHTMLPrivateWindow * pPrivWin;

    V_VT(pvarargOut)   = VT_BOOL;
    V_BOOL(pvarargOut) = VARIANT_FALSE;

    if (SUCCEEDED(V_UNKNOWN(pvarargIn)->QueryInterface(IID_IHTMLPrivateWindow, (void**)&pPrivWin)))
    {
        // Ignore the HR
        //
        if (_StartSecondaryPicsProcessor(pPrivWin) == S_OK)
        {
            V_BOOL(pvarargOut) = VARIANT_TRUE;
        }

        pPrivWin->Release();
    }
}

BOOL
CDocObjectHost::_IsInBrowserBand() const
{
    if (_psp)
    {
        IShellBrowser * pShlBrowser;

        HRESULT hr = _psp->QueryService(SID_SProxyBrowser,
                                        IID_PPV_ARG(IShellBrowser, &pShlBrowser));
        if (SUCCEEDED(hr))
        {
            pShlBrowser->Release();
            return TRUE;
        }
    }

    return FALSE;
}

//+-----------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_CancelPicsForWindow
//
//+-----------------------------------------------------------------------------

void
CDocObjectHost::_CancelPicsForWindow(VARIANTARG * pvarargIn)
{
    ASSERT(pvarargIn);
    ASSERT(VT_UNKNOWN == V_VT(pvarargIn));
    ASSERT(V_UNKNOWN(pvarargIn));

    IUnknown * pUnkPrivWin;

    if (SUCCEEDED(V_UNKNOWN(pvarargIn)->QueryInterface(IID_IUnknown, (void**)&pUnkPrivWin)))
    {
        _RemovePicsProcessorByPrivWindowUnk(pUnkPrivWin);

        pUnkPrivWin->Release();
    }

}

//+-----------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_IsPicsEnabled
//
//  Synopsis : Returns a variant that specifies whether or not PICS is enabled.
//
//+-----------------------------------------------------------------------------

void
CDocObjectHost::_IsPicsEnabled(VARIANTARG * pvarargOut)
{
    ASSERT(pvarargOut);
    ASSERT(VT_EMPTY == V_VT(pvarargOut));

    V_VT(pvarargOut)   = VT_BOOL;
    V_BOOL(pvarargOut) = VARIANT_FALSE;

    IRatingNotification* pRatingNotify;
    HRESULT hres = QueryService(SID_SRatingNotification, IID_PPV_ARG(IRatingNotification, &pRatingNotify));

    if (SUCCEEDED(hres))
    {
        V_BOOL(pvarargOut) = pRatingNotify->IsRatingsEnabled() ? VARIANT_FALSE : VARIANT_TRUE;
        pRatingNotify->Release();
    }
    else
    {
        if (IS_RATINGS_ENABLED() && S_OK == ::RatingEnabledQuery())
        {
            V_BOOL(pvarargOut) = VARIANT_TRUE;
        }
    }
}

//+-----------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_UpdateState
//
//  Synopsis : Updates the state of the dochost.
//
//+-----------------------------------------------------------------------------

HRESULT
CDocObjectHost::_UpdateState(LPITEMIDLIST pidl, BOOL fIsErrorUrl)
{
    HRESULT hres;

    if (_fSetSecureLock)
    {
        _ForwardSetSecureLock(_eSecureLock);
    }

    ASSERT(_pwb);

    if (!fIsErrorUrl)
    {
        ResetRefreshUrl();
    }
    
    IMoniker * pmk;
    BOOL fFileProtocol;

    hres = ::_URLMONMonikerFromPidl(pidl, &pmk, &fFileProtocol);

    if (S_OK == hres)
    {
        ATOMICRELEASE(_pmkCur);
        _pmkCur = pmk;

        DEBUG_CODE(_TraceMonikerDbg(_pmkCur, _T("CDocObjectHost::_UpdateState")));
    }

    _fFileProtocol = fFileProtocol;

    // This is only set if we did a successful LoadHistory()
    //
    _fIsHistoricalObject = FALSE;

    // This flag used to be set to false in IE5 
    // for each navigation because the dochost was
    // destroyed and a new one was created. Now that Trident
    // knows how to navigate, this flag doesn't get reset. This
    // prevents activation of the view in the case where a 
    // modal dialog is being displayed.
    //
    _fReadystateInteractiveProcessed = FALSE;

    return hres;
}


//+-----------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_Init
//
//  Synopsis : Clears the cached redirection URL in case the previous navigation
//             was a redirection. THis is needed so that further navigations to https://
//             sites don't get the redirection URL as their SSL base.
//+-----------------------------------------------------------------------------
void
CDocObjectHost::_Init()
{
    _fDelegatedNavigation = FALSE;
    _fErrorPage = FALSE;

    if (_bsc._pszRedirectedURL)
    {
        LocalFree(_bsc._pszRedirectedURL);
        _bsc._pszRedirectedURL = NULL;
    }
}

#ifdef DEBUG
void 
CDocObjectHost::_TraceMonikerDbg(IMoniker * pmk, TCHAR * pszCaller) const
{
    ASSERT(pmk);

    LPOLESTR pstrDisplayName;
    HRESULT  hr = pmk->GetDisplayName(NULL, NULL, &pstrDisplayName);

    if (S_OK == hr)
    {
        TraceMsg(DM_TRACE, "%ws - Moniker=\"%ws\"", pszCaller, pstrDisplayName);
        OleFree(pstrDisplayName);
    }
}
#endif

//
//  Only available in the DDK so defined here 
//
#define E_INVALID_SYNTAX  0x800401E4

//+-------------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_HandleFailedNavigation
//
//  Synopsis : Handles a failed navigation by initiating 
//             the AutoSearch function or displaying an
//             error page.
//
//  Scenario : - The user navigates to a bogus URL such as "sdfg".
//             - _HandleFailedNavigation is called via Exec with
//               DOCHOST_NAVIGATION_ERROR.
//             - The AutoSearch initiates with a search index of 0.
//             - AutoSearch expands the URL with the first 
//               UrlTemplate from the registry (usually www.%s.com).
//             - Navigation to the new URL is attempted.
//             - Upon failure, this method is called again with
//               an error code of HTTP_STATUS_BAD_GATEWAY or
//               HTTP_STATUS_GATEWAY_TIMEOUT.
//             - The search index in the property bag is incremented (by
//               two if it is currently 0.)
//             - AutoSearch then tries the next UrlTemplate, and so on.
//
//             If this method is called with an error code other than
//             HTTP_STATUS_BAD_GATEWAY, HTTP_STATUS_GATEWAY_TIMEOUT,
//             INET_E_RESOURCE_NOT_FOUND, INET_E_DATA_NOT_AVAILABLE or
//             if the error code is INET_E_RESOURCE_NOT_FOUND or
//             INET_E_DATA_NOT_AVAILABLEthe and the URL entered by the
//             user contains a protocol identifier (e.g., http://) an
//             error page contained in shdoclc.dll is displayed.
//
//  Input    : pvarargIn - a SafeArray that contains the following 
//                         data in this order.
//                     0 - Binding error or HTTP status code. (VT_I4)
//                     1 - URL being navigated to. (VT_BSTR)
//                     2 - IBinding interface (VT_UNKNOWN)
//                     3 - IHTMLWindow2 of the current window (VT_UNKNOWN)
//
//-------------------------------------------------------------------------

HRESULT
CDocObjectHost::_HandleFailedNavigation(VARIANTARG * pvarargIn, VARIANTARG* pvarargOut /*=NULL*/)
{
    HRESULT hr = E_FAIL;

    ASSERT(pvarargIn);
    ASSERT(_fDocCanNavigate);
    
    if (pvarargIn && VT_ARRAY == V_VT(pvarargIn) && V_ARRAY(pvarargIn))
    {
        // Get the error code from the SafeArray.
        //
        CComVariant cvarErrorCode;
        CComVariant cvarAddrBarNav;
        CComVariant cvarRefresh;

        long  lIdx    = 0;
        DWORD dwError = ERRORPAGE_DNS;
        BOOL  fShouldDisplayError = TRUE;
        BOOL  fDidSuperNavigate = TRUE;

        //
        // We use to use the window only in one place. To avoid QI several times
        // We QI just before the first use, and keep track if we were successful.
        //
        CComVariant cvarWindow;
        IHTMLWindow2 * pCurrentWindow = NULL;
        HRESULT hrWinQI = E_FAIL;
        
        hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lIdx, &cvarErrorCode);

        if (SUCCEEDED(hr) && V_VT(&cvarErrorCode) == VT_I4)
        {
            lIdx = 4;
            hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lIdx, &cvarAddrBarNav);

            if (SUCCEEDED(hr) && V_VT(&cvarAddrBarNav) == VT_BOOL)
            {
                // We fire NavigateError and if the host wishes to cancel
                // we can skip the rest of this method.

                BOOL fCancelAutoSearch = FALSE;
                DWORD dwStatusCode = V_I4(&cvarErrorCode);

                CComVariant cvarWindow;

                // Get the pending URL from the SafeArray.
                //
                CComVariant cvarUrl;

                lIdx = 1;
                hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lIdx, &cvarUrl);

                if (SUCCEEDED(hr) && (VT_BSTR == V_VT(&cvarUrl)) && V_BSTR(&cvarUrl))
                {
                    // Get the current window from the SafeArray.
                    //
                    lIdx = 3;
                    hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lIdx, &cvarWindow);
    
                    if (SUCCEEDED(hr) && V_VT(&cvarWindow) == VT_UNKNOWN && V_UNKNOWN(&cvarWindow))
                    {
                        hr = V_UNKNOWN(&cvarWindow)->QueryInterface(IID_IHTMLWindow2, (void**)&pCurrentWindow);

                        _FireNavigateErrorHelper(SUCCEEDED(hr) ? pCurrentWindow : NULL,
                                                 dwStatusCode,
                                                 &fCancelAutoSearch,
                                                 V_BSTR(&cvarUrl)); 
                        hrWinQI = hr;
                    }
                }

                if (fCancelAutoSearch)
                {
                   if (!_fCanceledByBrowser)
                   {
                       _CancelPendingNavigation(FALSE, TRUE);
                   }

                   return hr;
                }
        
                lIdx = 0;

                switch (V_I4(&cvarErrorCode))
                {
                    case HTTP_STATUS_BAD_GATEWAY:
                    case HTTP_STATUS_GATEWAY_TIMEOUT:

                        if (VARIANT_TRUE == V_BOOL(&cvarAddrBarNav))
                        {
                            hr = _DoAutoSearch(pvarargIn,
                                               ++lIdx,
                                               V_I4(&cvarErrorCode),
                                               FALSE,
                                               &fShouldDisplayError);

                            if ( fShouldDisplayError )
                            {
                                fDidSuperNavigate = FALSE;
                            }
                        }
                        break;
            
                    // Only autosearch if the error code is
                    // INET_E_RESOURCE_NOT_FOUND or INET_E_DATA_NOT_AVAILABLE
                    //
                    case INET_E_RESOURCE_NOT_FOUND:
                    case INET_E_DATA_NOT_AVAILABLE:

                        if (VARIANT_TRUE == V_BOOL(&cvarAddrBarNav))
                        {
                            hr = _DoAutoSearch(pvarargIn,
                                               ++lIdx,
                                               0,
                                               TRUE,
                                               &fShouldDisplayError);

                            // We must reset here so that the index will be
                            // correct the next time around.
                            //

                        }
                
                    // Intentional fall-through

                    case INET_E_DOWNLOAD_FAILURE:
                        if (IsGlobalOffline())
                            break; 
                
                    // otherwise fall through to do default handling
            
                    default:
                        if (hr || fShouldDisplayError)
                        {
                            if (  V_I4(&cvarErrorCode) >= HTTP_STATUS_BAD_REQUEST
                               && V_I4(&cvarErrorCode) <= HTTP_STATUS_LAST)
                            {
                               dwError = V_I4(&cvarErrorCode);
                            }

                            // Special for Trident Invalid Syntax
                            // Trident passes the raw hr to Shdocvw
                            // instead of the friendly code.

                            if (V_I4(&cvarErrorCode) == E_INVALID_SYNTAX)
                            {
                                dwError = ERRORPAGE_SYNTAX;
                            }

                            // Get the pending URL from the SafeArray.
                            //
                            CComVariant cvarUrl;

                            lIdx = 1;
                            hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lIdx, &cvarUrl);

                            if (SUCCEEDED(hr) && V_VT(&cvarUrl) == VT_BSTR && V_BSTR(&cvarUrl))
                            {
                                if (SUCCEEDED(hrWinQI))
                                {
                                    //
                                    // Get the refresh flag - indicating whether this is a refresh.
                                    // ( this was originally set when we called SuperNavigate )
                                    // 
                                    lIdx = 5;
                                    hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lIdx, &cvarRefresh);

                                    if (SUCCEEDED(hr))
                                    {
                                        hr = _DisplayHttpErrorPage(pCurrentWindow,
                                                                   V_BSTR(&cvarUrl),
                                                                   dwError,
                                                                   V_BOOL(&cvarAddrBarNav),
                                                                   V_BOOL(&cvarRefresh ) );
                                        ATOMICRELEASE(pCurrentWindow);
                                    }
                                }
                            }
                        }
            
                        break;
                
                }  // switch

                if ( pvarargOut && ( V_VT( pvarargOut ) == VT_BOOL ) )
                {
                    V_BOOL( pvarargOut ) = fDidSuperNavigate ? VARIANT_TRUE : VARIANT_FALSE;
                }
                
            }  // if (SUCCEEDED(hr) && V_VT(&cvarAddrBarNav) == VT_BOOL)
        } // if (SUCCEEDED(hr) && V_VT(&cvarErrorCode) == VT_I4)
    }
    
    return (S_FALSE == hr ? S_OK : hr);
}

//+------------------------------------------------------------------
//
//  Member   : CDocObjectHost::_DoAutoSearch
//
//  Synopsis : Performs the autosearch function. 
//
//  Input    : pvarargIn    - a SafeArray of arguments. See 
//                            _HandleFailedNavigation for info about
//                            the format of pvarargIn.
//             lStartIdx    - the position in the SafeArray where
//                            the data begins.
//             dwStatusCode - the HTTP status code.
//
//  Output   : pfShouldDisplayError - TRUE if an error page
//                                    should be displayed.
//
//------------------------------------------------------------------

HRESULT
CDocObjectHost::_DoAutoSearch(VARIANTARG   * pvarargIn,
                              long           lStartIdx,
                              DWORD          dwStatusCode,
                              BOOL           fAddMRU,
                              BOOL         * pfShouldDisplayError)
{
    ASSERT(pvarargIn);
    ASSERT(_fDocCanNavigate);
    ASSERT(pfShouldDisplayError);

    *pfShouldDisplayError = TRUE;
    
    // Url
    CComVariant cvarUrl;
    HRESULT hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lStartIdx, &cvarUrl);

    if (SUCCEEDED(hr) && V_VT(&cvarUrl) == VT_BSTR && V_BSTR(&cvarUrl))
    {
       CComVariant cvarBinding;
       IBinding  * pBinding;
    
       // Binding interface pointer
       lStartIdx++;
       hr = SafeArrayGetElement(V_ARRAY(pvarargIn), &lStartIdx, &cvarBinding);
    
       if (SUCCEEDED(hr) && V_VT(&cvarBinding) == VT_UNKNOWN && V_UNKNOWN(&cvarBinding))
       {
           hr = V_UNKNOWN(&cvarBinding)->QueryInterface(IID_IBinding, (void**)&pBinding);
           if (SUCCEEDED(hr))
           {
               hr = _bsc._HandleFailedNavigationSearch(pfShouldDisplayError, dwStatusCode, this, 0, V_BSTR(&cvarUrl),
                                                       L"Resource Not Found", pBinding, fAddMRU, TRUE);

               if (hr == S_FALSE)
                   _fErrorPage = TRUE;  // Don't update the history if no auto-search
               ATOMICRELEASE(pBinding);
           }
        }
    }
        
    return (S_FALSE == hr ? S_OK : hr);
}

//+---------------------------------------------------------------
//
//  Member   : CDocObjectHost::_DisplayHttpErrorPage
//
//  Synopsis : Displays the HTML page that corresponds to 
//             the given error code.
//
//  Input    : pCurrentWindow - the window to use for navigation.
//             dwError        - the error code.
//
//---------------------------------------------------------------

HRESULT
CDocObjectHost::_DisplayHttpErrorPage(IHTMLWindow2 * pCurrentWindow,
                                      BSTR           bstrUrl,
                                      DWORD          dwError,
                                      BOOL           fAddrBarNav,
                                      BOOL           fRefresh /*=FALSE*/)
{
    HRESULT hr = E_FAIL;
    TCHAR   szErrorUrl[MAX_URL_STRING];
    const   WCHAR * const pszFmt = L"#%s";
    IHTMLPrivateWindow * pPrivWindow = NULL;

    ASSERT(pCurrentWindow);
    ASSERT(_fDocCanNavigate);
    
    _bsc._DontAddToMRU(this);
    
    if (IsErrorHandled(dwError))
    {
        _fErrorPage = TRUE;
        if (_bsc._DisplayFriendlyHttpErrors())
        {
            hr = MLBuildResURLWrap(_T("shdoclc.dll"),
                                   HINST_THISDLL,
                                   ML_CROSSCODEPAGE,
                                   (TCHAR*)c_aErrorUrls[EUIndexFromError(dwError)].pszUrl,
                                   szErrorUrl,
                                   ARRAYSIZE(szErrorUrl),
                                   _T("shdocvw.dll"));
            if (SUCCEEDED(hr))
            {
                LPOLESTR pwszLocation = OLE2W(bstrUrl);

                if (!IsFrameWindow(pCurrentWindow))
                {
                    // Save the url the user attempted to navigate to.  It will be used
                    // to refresh the page.
                    //
                    OleFree(_pwszRefreshUrl);
                    hr = SHStrDupW(OLE2W(bstrUrl), &_pwszRefreshUrl);
                }

                if (SUCCEEDED(hr))
                {
                    int nLenWritten = lstrlen(szErrorUrl);

                    // Append the #<refresh URL>
                    //
                    wnsprintf(szErrorUrl + nLenWritten,
                              ARRAYSIZE(szErrorUrl) - nLenWritten,
                              pszFmt,
                              pwszLocation ? pwszLocation : L"");


                    hr = pCurrentWindow->QueryInterface(IID_IHTMLPrivateWindow,
                                                        (void**)&pPrivWindow);
                    if (SUCCEEDED(hr))
                    {
                        // Navigate to the URL
                        //
                        BSTR bstrErrorUrl = SysAllocString(szErrorUrl);

                        DWORD dwFlags = (fAddrBarNav ? 
                                            DOCNAVFLAG_DONTUPDATETLOG | DOCNAVFLAG_HTTPERRORPAGE :
                                            DOCNAVFLAG_HTTPERRORPAGE) ;

                        if ( fRefresh )
                            dwFlags |= DOCNAVFLAG_REFRESH;
                            
                        if (bstrErrorUrl)
                        {
                            hr = pPrivWindow->SuperNavigate(bstrErrorUrl,
                                                            NULL,
                                                            NULL,
                                                            NULL,
                                                            NULL,
                                                            NULL,
                                                            dwFlags);
                            SysFreeString(bstrErrorUrl);
                        }

                        pPrivWindow->Release();
                    }
                }
            }
        }
    }
    
    return hr;
}

HRESULT CDocObjectHost::_GetUrlVariant(VARIANT *pvarargOut)
{
    ASSERT( pvarargOut);

    if (_pmkCur)
    {
        LPOLESTR pszDisplayName = NULL;
        LPTSTR pszRedirectedURL = NULL;

        if (_bsc._pszRedirectedURL && *_bsc._pszRedirectedURL)
            pszRedirectedURL = _bsc._pszRedirectedURL;

        if (pszRedirectedURL || SUCCEEDED(_GetCurrentPageW(&pszDisplayName, TRUE)))
        {
            pvarargOut->bstrVal = SysAllocString(pszRedirectedURL ? pszRedirectedURL : pszDisplayName);

            if (pvarargOut->bstrVal)
                pvarargOut->vt = VT_BSTR;

            if (pszDisplayName)
                OleFree(pszDisplayName);
        }
    }
    return (pvarargOut->bstrVal == NULL) ? E_FAIL : S_OK;
}

HRESULT CDocObjectHost::_CoCreateHTMLDocument(REFIID riid, void ** ppvOut)
{
    IOleCommandTarget* pcmd;
    
    HRESULT hres = QueryService(SID_STopLevelBrowser, IID_IOleCommandTarget, (void **)&pcmd);
    if (SUCCEEDED(hres)) {
        VARIANT varOut = { 0 };
        hres = pcmd->Exec(&CGID_Explorer, SBCMDID_COCREATEDOCUMENT, 0, NULL, &varOut);
        if (SUCCEEDED(hres) && varOut.vt == VT_UNKNOWN) {
            hres = varOut.punkVal->QueryInterface(riid, ppvOut);
            // Clean it up by ourself so that we don't load OLEAUT32
            varOut.punkVal->Release();
        } else {
            ASSERT(varOut.vt == VT_EMPTY);
            VariantClear(&varOut);
        }
        pcmd->Release();
    }
    return hres;
}

HRESULT CDocObjectHost::_CreatePendingDocObject(BOOL fMustInit, BOOL fWindowOpen /* = FALSE */)
{
    HRESULT hres = S_OK;

    if (_punkPending == NULL)
    {
        hres = _CoCreateHTMLDocument(IID_IUnknown, (void **)&_punkPending);
        _fPendingNeedsInit = 1;   // lazy InitNew only if absolutely necessary

        if (fWindowOpen)
        {
            IUnknown_Exec(_punkPending, &CGID_ShellDocView, SHDVID_WINDOWOPEN, 0, NULL, NULL);
        }
    }

    if (_fPendingNeedsInit && fMustInit && SUCCEEDED(hres))
    {
        IOleObject * polePending;
#ifdef TRIDENT_NEEDS_LOCKRUNNING
        IRunnableObject * pro;
#endif
        _fCreatingPending = 1;    // we are creating _punkPending
        _fAbortCreatePending = 0;
        _fPendingNeedsInit = 0;

        IPersistStreamInit * pipsi;

        hres = _punkPending->QueryInterface(IID_IPersistStreamInit, (void**)&pipsi);
        if (SUCCEEDED(hres))
        {
            hres = pipsi->InitNew();
            pipsi->Release();
        }

        // if the InitNew is a re-entrant request (such as doing execDown to get a securityctx
        //  while in the process of loading the document), trident will respond with E_PENDING
        //  since there is already a load in progress, this call/init is a timing issue, and
        //  we can use the exisitng one.
        //
        if (SUCCEEDED(hres) || hres==E_PENDING)
        {
            hres = _punkPending->QueryInterface(IID_IOleObject, (void**)&polePending);
            if (SUCCEEDED(hres))
            {
                hres = polePending->SetClientSite(this);
                polePending->Release();
            }

#ifdef TRIDENT_NEEDS_LOCKRUNNING
        //  TRIDENT NO LONGER SUPPORTS IRunnableObject
            //  RegisterObjectParam/RevokeObjectParam calls LockRunning on object being
            //  registered.  LockRunning(FALSE,FALSE) implied in the Revoke will result
            //  in OleClose being called on _punkPending if we haven't activated it
            //  by end of binding.  Thus we must call LockRunning ourself
            if (SUCCEEDED(hres))
            {
                hres = _punkPending->QueryInterface(IID_IRunnableObject, (void**)&pro);
                if (SUCCEEDED(hres))
                {
                    hres = pro->LockRunning(TRUE, TRUE);
                    pro->Release();
                }
            }
#endif
        }

        _fCreatingPending = 0;
        _fPendingWasInited = 1;

        if (FAILED(hres))
        {
            SAFERELEASE(_punkPending);
        }
        else if (_fAbortCreatePending)
        {
            //  Detect AOL pumping messages and reentering and attempting to release
            //  _punkPending
            _fAbortCreatePending = 0;
            _ReleasePendingObject();
            hres = E_FAIL;
        }
        else
        {
            //  Pass URL for pending object to it in advance of IPersistMoniker::Load

            //
            // Notes: We don't want to call _GetUrlVariant which will load
            // OLEAUT32.DLL
            //

            LPOLESTR pszDisplayName = NULL;
            LPTSTR pszURL = NULL;

            if (_bsc._pszRedirectedURL && *_bsc._pszRedirectedURL)
                pszURL = _bsc._pszRedirectedURL;

            if (pszURL || SUCCEEDED(_GetCurrentPageW(&pszDisplayName, TRUE)))
            {
                LBSTR::CString              strDisplay;

                strDisplay = ( pszURL ? pszURL : pszDisplayName );

                VARIANT varIn;
                varIn.vt = VT_BSTR;
                varIn.bstrVal = strDisplay;

                IUnknown_Exec(_punkPending, &CGID_ShellDocView, SHDVID_SETPENDINGURL, 0, &varIn, NULL);

                if (pszDisplayName)
                    OleFree(pszDisplayName);
            }
        }

        _fAbortCreatePending = 0;
    }

    return hres;
}

HRESULT
CDocObjectHost::_LoadDocument()
{
    if (!_punkPending)
        return E_FAIL;

    IPersistMoniker * pPersistMk;

    HRESULT hres = _punkPending->QueryInterface(IID_IPersistMoniker, (void**)&pPersistMk);
    if (SUCCEEDED(hres))
    {
        ITridentService * pTridentSvc;

        if ( _pwb )
        {
            hres = _pwb->QueryInterface(IID_ITridentService, (void**)&pTridentSvc);
        }
        else
        {
            TraceMsg( TF_ERROR, "CDocObjectHost::_LoadDocument() - _pwb is NULL!" );
            hres = E_FAIL;
        }

        if (SUCCEEDED(hres))
        {
            BSTR bstrUrl;

            hres = pTridentSvc->GetPendingUrl(&bstrUrl);
            if (SUCCEEDED(hres))
            {
                IMoniker * pMoniker;
                TCHAR *pstr;

                // Parse the URL, removing any location info
                pstr = wcsrchr(bstrUrl, '#');
                if (pstr)
                {
                    *pstr = '\0';
                }

                hres = CreateURLMoniker(NULL, bstrUrl, &pMoniker);
                if (SUCCEEDED(hres))
                {
                    ATOMICRELEASE(_pole);

                    hres = _punkPending->QueryInterface(IID_IOleObject, (void**)&_pole);
                    if (SUCCEEDED(hres))
                    {
                        _GetAppHack();

                        // Call _SetUpTransitionCapability() to set up the advisory sinks
                        // and set readystate to complete. If we don't do this here, the 
                        // view will never be activated after the first navigation
                        // which means that the view will never switched and the
                        // new document will not be displayed. Also, setting readystate
                        // to complete here, is what prevents the window from being transparent
                        // when it is first opened.
                        //
                        _SetUpTransitionCapability(TRUE);
                    }

                    hres = pPersistMk->Load(TRUE, pMoniker, _pbcCur, 0);
                    pMoniker->Release();
                }

                SysFreeString(bstrUrl);
            }

            pTridentSvc->Release();
        }

        pPersistMk->Release();
    }

    return S_OK;
}

// called from CDocObjectView to exec and forward these calls down
//
HRESULT CDocObjectHost::ExecDown(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    //  Special case Exec's that are used to fetch info on pending docobject
    //  for scripting access before OnObjectAvailable
    if (pguidCmdGroup && IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
        case SHDVID_GETPENDINGOBJECT:
            ASSERT( pvarargOut);
            VariantClearLazy(pvarargOut);

            if (_pole)
            {
                _pole->QueryInterface(IID_IUnknown, (void **) &(pvarargOut->punkVal));

                // Check to see if this is a window.open case. If so,
                // the document was created and Init'ed in SetTarget 
                // and the real Url will be loaded now.
                //
                if (_pbcCur)
                {
                    IUnknown * punkBindCtxParam = NULL;

                    hres = _pbcCur->GetObjectParam(KEY_BINDCONTEXTPARAM, &punkBindCtxParam);
                    if (SUCCEEDED(hres))
                    {
                        punkBindCtxParam->Release();

                        _fWindowOpen = TRUE;

                        hres = _LoadDocument();
                        _ActivateMsoView();
                    }
                }
            }
            else
            {
                _CreatePendingDocObject(TRUE);

                if (_punkPending)
                {
                    pvarargOut->punkVal = _punkPending;
                    _punkPending->AddRef();
                }
                else if (_pole)
                {
                    _pole->QueryInterface(IID_IUnknown, (void **) &(pvarargOut->punkVal));
                }
            }

            if (pvarargOut->punkVal != NULL)
            {
                pvarargOut->vt = VT_UNKNOWN;
                hres = S_OK;

            }
            else
            {
                hres = E_FAIL;
            }

            return hres;
            break;

        case SHDVID_GETPENDINGURL:
            ASSERT( pvarargOut);

            VariantClearLazy(pvarargOut);
            hres = _GetUrlVariant(pvarargOut);

            return hres;
            break;

        default:
            break;
        }
    }

    BOOL fNearest = _ExecNearest(pguidCmdGroup, nCmdID, TRUE);

    if (fNearest)
        hres = OnExec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    if (FAILED(hres) && _pmsot) {
        hres = _pmsot->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

        //
        // APPHACK:
        //  PPT in Office 97 fails to print if we pass PRINTFLAG_PROMPTUSER
        // and returns E_INVALIDARG. If we detect this case, we should retry
        // without this flag. PPT will popup the print dialog. (SatoNa)
        //
        if (hres == E_INVALIDARG
            && (_dwAppHack & BROWSERFLAG_PRINTPROMPTUI)
            && pguidCmdGroup == NULL
            && nCmdID == OLECMDID_PRINT)
        {
            TraceMsg(TF_SHDAPPHACK, "DOH::ExecDown(OLECMDID_PRINT) removing PRINTFLAG_PROMPTUSER");
            nCmdexecopt &= ~OLECMDEXECOPT_DONTPROMPTUSER;
        hres = _pmsot->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
    }

    if (FAILED(hres) && !fNearest)
        hres = OnExec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    return hres;
}
HRESULT CDocObjectHost::QueryStatusDown(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hres;

    if (_pmsot)
        hres = _pmsot->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
    else if (pguidCmdGroup && IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
        hres = IUnknown_QueryStatus(_pole, pguidCmdGroup, cCmds, rgCmds, pcmdtext);

    return OnQueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext, hres);
}


HRESULT CDocObjectHost::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams,
                        VARIANT FAR* pVarResult,EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr)
{
    if (!_peds)
        return(E_NOTIMPL);

    return _peds->OnInvoke(dispidMember, iid, lcid, wFlags, pdispparams, pVarResult,pexcepinfo,puArgErr);
}

//*** IOleControlSite {

HRESULT CDocObjectHost::OnControlInfoChanged()
{
    HRESULT hres = E_NOTIMPL;

    if (_pedsHelper)
    {
        hres = _pedsHelper->OnOnControlInfoChanged();
    }

    return(hres);
}

//***   CDOH::TranslateAccelerator (IOCS::TranslateAccelerator)
// NOTES
//  trident (or any other DO that uses IOCS::TA) calls us back when TABing
//  off the last link.  to handle it, we flag it for our original caller
//  (IOIPAO::TA), and then pretend we handled it by telling trident S_OK.
//  trident returns S_OK to IOIPAO::TA, which checks the flag and says
//  'trident did *not* handle it' by returning S_FALSE.  that propagates
//  way up to the top where it sees it was a TAB so it does a CycleFocus.
//
//  that's how we do it when we're top-level.  when we're a frameset, we
//  need to do it the 'real' way, sending it up to our parent IOCS.
HRESULT CDocObjectHost::TranslateAccelerator(MSG __RPC_FAR *pmsg,DWORD grfModifiers)
{

    HRESULT hres = S_FALSE;

    if (_peds) {
        // try it the real way in case we're in a frameset
        // top level: we'll do CImpIExpDispSupport::OnTA which does E_NOTIMPL,
        // frameset:  we'll do CWebBrowserOC::OnTA which talks to trident
        // What if trident (or OC?) gives back E_NOTIMPL too?
        TraceMsg(DM_FOCUS, "DOH::IOCS::TA peds!=NULL forward");
        hres = _peds->OnTranslateAccelerator(pmsg, grfModifiers);
    }
    if (hres != S_OK) {
        // we're at top level (E_NOTIMPL), so we can fake it
        // (or alternately we're not, but our parent said S_FALSE)
#ifdef DEBUG
        if (_peds && SUCCEEDED(hres)) {
            // i'm curious if we ever hit this
            TraceMsg(DM_WARNING, "DOH::IOCS::TA parent hres=%x (!=S_OK)", hres);
        }
#endif
        hres = S_FALSE;
        if (IsVK_TABCycler(pmsg)) {
            TraceMsg(TF_SHDUIACTIVATE, "DOH::TranslateAccelerator called with VK_TAB");
            TraceMsg(DM_FOCUS, "DOH::IOCS::TA(wParam=VK_TAB) ret _fCycleFocus=TRUE hr=S_OK (lie)");
            // defer it, set flag for CDOH::IOIPAO::TA, and pretend we handled it
            ASSERT(!_fCycleFocus);
            _fCycleFocus = TRUE;
            hres = S_OK;
        }
    }

    return hres;
}

// }

//========================================================================
// CDocObjectHost::CPicsProcessor
//========================================================================
CDocObjectHost::CPicsProcessor::CPicsProcessor()
{
    _fPicsAccessAllowed = TRUE;     /* assume no ratings checks unless we download */
    _fInDialog = FALSE;
    _fTerminated = FALSE;
    _fbPicsWaitFlags = 0;
}

STDMETHODIMP CDocObjectHost::CPicsProcessor::QueryInterface(REFIID riid, void ** ppvObj)
{
    if (IsEqualIID(riid, IID_IOleCommandTarget) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IOleCommandTarget *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    CDocObjectHost* pdoh = _pdoh;

    return pdoh->AddRef();
}

STDMETHODIMP_(ULONG) CDocObjectHost::CPicsProcessor::AddRef(void)
{
    return _pdoh->AddRef();
}

STDMETHODIMP_(ULONG) CDocObjectHost::CPicsProcessor::Release(void)
{
    return _pdoh->Release();
}

STDMETHODIMP CDocObjectHost::CPicsProcessor::QueryStatus(const GUID *pguidCmdGroup,
            ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDocObjectHost::CPicsProcessor::Exec(const GUID *pguidCmdGroup,
            DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SHDVID_PICSLABELFOUND:
            if (pvarargIn->vt == (VT_BSTR)) {
                _dwPicsLabelSource = PICS_LABEL_FROM_PAGE;
                _HandleInDocumentLabel(pvarargIn->bstrVal);
            }
            return NOERROR;
        case SHDVID_PICSLABELFOUNDINHTTPHEADER:
            if (pvarargIn->vt == (VT_BSTR)) {
                _dwPicsLabelSource = PICS_LABEL_FROM_HEADER;
                _HandleInDocumentLabel(pvarargIn->bstrVal);
            }
            return NOERROR;
        case SHDVID_NOMOREPICSLABELS:
            _HandleDocumentEnd();
            return NOERROR;

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }

    return OLECMDERR_E_UNKNOWNGROUP;
}

UINT CDocObjectHost::CPicsProcessor::_PicsBlockingDialog()
{
    LPCTSTR pszURL = _pszPicsURL;

    TraceMsg(DM_PICS, "CDOH::CPP::_PicsBlockingDialog() %s", pszURL);

    _StartPicsRootQuery(pszURL);

    _pdoh->_fDrawBackground = TRUE;
    ::InvalidateRect(_pdoh->_hwnd, NULL, TRUE);    /* mega cheesy, but only way to get browser window erased */

    /* This message loop is used to block in non-HTML cases, where we really
     * want to block the download process until ratings are checked.  In the
     * HTML case, this function is never called until the wait flags are all
     * clear, so the message loop is skipped and we go straight to the denial
     * dialog.
     */
    while (_fbPicsWaitFlags) {
        TraceMsg(DM_PICS, "CDOH::CPP::_PicsBlockingDialog entering msg loop, waitflags=%x", (DWORD)_fbPicsWaitFlags);

        MSG msg;
        if (GetMessage(&msg, NULL, 0, 0)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    if (!_fPicsAccessAllowed) {

        TraceMsg(DM_PICS, "CDOH::CPP::_PicsBlockingDialog, access denied");

        BOOL fOldInDialog;

        // If this is silent-mode (no UI == screensaver), always deny access
        // without any dialog.
        BOOL fFrameIsSilent = FALSE;    // Assume non-silent
        _pdoh->_GetOfflineSilent(NULL, &fFrameIsSilent);
        if (fFrameIsSilent) {
            TraceMsg(DM_PICS, "CDOH::CPP::_PicsBlockingDialog access denied in silent mode, aborting");
            return IDCANCEL;
        }

        // Protect against us getting whacked out
        // from under ourselves
        fOldInDialog = _fInDialog;
        _fInDialog = TRUE;

        // This doesn't get down to trident to stop it from navigating.
        // We need some sort of navigation freeze mechanism.
        _pdoh->_EnableModeless(FALSE);

        HRESULT hres = S_OK;
        IOleCommandTarget *pcmdtTop;
        if (SUCCEEDED(_pdoh->QueryService(SID_STopLevelBrowser, IID_IOleCommandTarget, (void **)&pcmdtTop))) {
            VARIANTARG v = { 0 };
            v.vt = VT_INT_PTR;
            v.byref = _pRatingDetails;
            hres = pcmdtTop->Exec(&CGID_ShellDocView, SHDVID_PICSBLOCKINGUI, 0, &v, NULL);
            pcmdtTop->Release();
        }

        UINT uRet = (hres == S_OK) ? IDOK : IDCANCEL;
        _pdoh->_EnableModeless(TRUE);
        _fPicsAccessAllowed = (uRet == IDOK);

        _fInDialog = fOldInDialog;

        TraceMsg(DM_PICS, "CDOH::CPP::_PicsBlockingDialog returning %d", uRet);

        return uRet;
    }
    else {
        TraceMsg(DM_PICS, "CDOH::CPP::_PicsBlockingDialog, access allowed");

        return IDOK;
    }
}

HRESULT CDocObjectHost::CPicsProcessor::_StartPicsQuery(LPCOLESTR pwszRawURL)
{
#ifdef DEBUG

    HRESULT hres;
    IRatingNotification* pRatingNotify;
    hres = _pdoh->QueryService(SID_SRatingNotification, IID_PPV_ARG(IRatingNotification, &pRatingNotify));

    if (SUCCEEDED(hres))
    {
        ASSERT(S_OK == pRatingNotify->IsRatingsEnabled());
        pRatingNotify->Release();
    }
    else
    {
        ASSERT(IS_RATINGS_ENABLED() && ::RatingEnabledQuery() == S_OK);
    }
#endif DEBUG

    TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsQuery entered with ratings enabled");

    BOOL fEnforce = TRUE;
    if (_pszPicsURL != NULL) {
        delete _pszPicsURL;
        _pszPicsURL = NULL;
    }

    {
        /* We have to call CoInternetGetSecurityUrl to convert pluggable
         * protocols into known schemes, so we know whether we need to
         * enforce ratings on them.
         */
        LPOLESTR pwszSecurityURL = NULL;

        if (SUCCEEDED(CoInternetGetSecurityUrl(pwszRawURL, &pwszSecurityURL,
                                               PSU_SECURITY_URL_ONLY, 0)))
        {
            // List of protocols for which we never enforce ratings.
            if (!StrCmpNIW(pwszSecurityURL, L"file:", 5) ||
                !StrCmpNIW(pwszSecurityURL, L"about:", 6) ||
                !StrCmpNIW(pwszSecurityURL, L"mk:", 3)) {
                fEnforce = FALSE;
            }
            else {
                Str_SetPtr(&_pszPicsURL, pwszSecurityURL);
            }

            OleFree(pwszSecurityURL);
        }
    }

    if (fEnforce) {

        TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsQuery (%s) turning on wait flags", _pszPicsURL);

        _fbPicsWaitFlags = PICS_WAIT_FOR_ASYNC
                         | PICS_WAIT_FOR_INDOC
                         | PICS_WAIT_FOR_END
                         | PICS_WAIT_FOR_ROOT
                         ;
        _fPicsAccessAllowed = 0;

        HRESULT hr;
        _dwPicsSerialNumber = ::_AddPicsQuery(_pdoh->_hwnd);
        if (_dwPicsSerialNumber == 0)
            hr = E_OUTOFMEMORY;
        else
        {
            //
            // The ratings apis are ansi.
            //

            CHAR szURL[MAX_URL_STRING];

            SHUnicodeToAnsi(_pszPicsURL, szURL, ARRAYSIZE(szURL));
            hr = RatingObtainQuery(szURL, _dwPicsSerialNumber, RatingObtainQueryCallback, &_hPicsQuery);
        }
        if (FAILED(hr)) {
            TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsQuery no async query queued");
            ::_RemovePicsQuery(_dwPicsSerialNumber);
            _dwPicsSerialNumber = 0;
            _fbPicsWaitFlags &= ~PICS_WAIT_FOR_ASYNC;
        }
        else {
            TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsQuery async query queued");
        }
    }
    else {
        // JHarding: IF we're not enforcing, we need to tell anyone who's waiting on an answer.
        return S_FALSE;
    }   

    return S_OK;
}
void CDocObjectHost::CPicsProcessor::_HandleDocumentEnd(void)
{
    BYTE bFlag = (_pRootDownload != NULL) ? PICS_WAIT_FOR_ROOT : PICS_WAIT_FOR_END;

    TraceMsg(DM_PICS, "CDOH::CPP::_HandleDocumentEnd -- no more PICS labels from source %x", (DWORD)bFlag);

    // If we have a private window, we'll make sure the root download is gone when we
    // notify the window.  This simplifies the lifetime of the secondary CPicsProcessors
    if (!_pPrivWindow)
    {
        if (_pRootDownload != NULL) {
            ::PostMessage(_pdoh->_hwnd, WM_PICS_ROOTDOWNLOADCOMPLETE, 0, 0);
        }
        else {
            /* End of document;  revoke the IOleCommandTarget we gave to the document,
             * so it won't send us any more notifications.
             */
            VARIANTARG v;
            v.vt = VT_UNKNOWN;
            v.punkVal = NULL;

            IUnknown_Exec(_pdoh->_pole, &CGID_ShellDocView, SHDVID_CANSUPPORTPICS, 0, &v, NULL);
        }
    }
    else
    {
        if (_pRootDownload == NULL)
        {
            _pPrivWindow->SetPICSTarget(NULL);
        }
    }

    if (!(_fbPicsWaitFlags & bFlag)) {
        TraceMsg(DM_PICS, "CDOH::CPP::_HandleDocumentEnd skipping due to waitflags %x", (DWORD)_fbPicsWaitFlags);
        return;
    }

    _fbPicsWaitFlags &= ~PICS_WAIT_FOR_INDOC;   /* we know we won't get any more indoc labels */

    LPVOID pDetails = NULL;

    //
    // Ratings has only ansi apis!
    //
    CHAR szURL[MAX_URL_STRING];
    SHUnicodeToAnsi(_pszPicsURL, szURL, ARRAYSIZE(szURL));

    HRESULT hres = ::RatingCheckUserAccess(NULL, szURL, NULL, NULL, _dwPicsLabelSource, &pDetails);

    _GotLabel(hres, pDetails, bFlag);

    if (_pRootDownload == NULL) {
        if (_fbPicsWaitFlags)
            _StartPicsRootQuery(_pszPicsURL);
    }
}

void CDocObjectHost::CPicsProcessor::_GotLabel(HRESULT hres, LPVOID pDetails, BYTE bfSource)
{
    TraceMsg(DM_PICS, "CDOH::CPP::_GotLabel hres=%x, source=%x, waitflags=%x", hres, (DWORD)bfSource, (DWORD)_fbPicsWaitFlags);

    /* If we've already gotten a result from this or a more significant source,
     * ignore this one.
     */
    if (!(_fbPicsWaitFlags & bfSource)) {
        TraceMsg(DM_PICS, "CDOH::CPP::_GotLabel already got label from that source");

        if (pDetails != NULL)
        {
            ::RatingFreeDetails(pDetails);
            pDetails = NULL;
        }
    }
    else {
        /* If the result is an error somehow (label doesn't apply, etc.), and
         * we can expect more labels from this source, then we don't do anything
         * except save the rating details if we haven't got any yet.
         */
        if (FAILED(hres) && (PICS_MULTIPLE_FLAGS & bfSource)) {
            TraceMsg(DM_PICS, "CDOH::CPP::_GotLabel label error and may be multiple");

            if (_pRatingDetails == NULL)
            {
                _pRatingDetails = pDetails;
            }
            else
            {
                if ( pDetails )
                {
                    ::RatingFreeDetails(pDetails);
                    pDetails = NULL;
                }
            }
        }
        else {
            /* Either we got a definitive answer from this rating source, or
             * this is the only answer we'll get from it.  We clear at least
             * the flag for this source so we know we've heard from it.  If
             * the response was not an error, then clear flags for all less
             * significant sources as well, so that we'll ignore them.  On
             * the other hand, if this source returned an error, it didn't
             * give us anything useful, so we keep looking at other sources.
             */
            if (SUCCEEDED(hres))
                _fbPicsWaitFlags &= bfSource - 1;
            else
                _fbPicsWaitFlags &= ~bfSource;

            TraceMsg(DM_PICS, "CDOH::CPP::_GotLabel, waitflags now %x", (DWORD)_fbPicsWaitFlags);

            if (hres == S_OK) {
                TraceMsg(DM_PICS, "CDOH::CPP::_GotLabel allowing access");

                if ( pDetails )
                {
                    ::RatingFreeDetails( pDetails );  /* don't need this if access allowed */
                    pDetails = NULL;
                }

                _fPicsAccessAllowed = 1;
            }
            else {
                /* Access denied or error.  Meaningful details from this result
                 * can override details from an earlier, less significant
                 * result.  Only explicitly deny access if not an error,
                 * though (this handles the valid root label followed by
                 * invalid in-document label, for example).
                 */
                if (pDetails != NULL) {
                    if (_pRatingDetails != NULL)
                    {
                        ::RatingFreeDetails(_pRatingDetails);
                    }

                    _pRatingDetails = pDetails;
                }
                if (SUCCEEDED(hres))
                    _fPicsAccessAllowed = 0;
            }
        }
    }

    // If we are a secondary processor (_pPrivWindow != NULL) then
    // we always want to report when the check is complete
    //
    if ((_pPrivWindow || _pdoh->_fPicsBlockLate) && !_fbPicsWaitFlags)
    {
        _HandlePicsChecksComplete();
    }
}


void CDocObjectHost::CPicsProcessor::_HandleInDocumentLabel(LPCTSTR pszLabel)
{
    BYTE bFlag = (_pRootDownload != NULL) ? PICS_WAIT_FOR_ROOT : PICS_WAIT_FOR_INDOC;

    TraceMsg(DM_PICS, "CDOH::CPP::_HandleInDocumentLabel source %x gave label %s", (DWORD)bFlag, pszLabel);

    if (!(_fbPicsWaitFlags & bFlag)) {
        TraceMsg(DM_PICS, "CDOH::CPP::_HandleInDocumentLabel rejecting based on waitflags %x", (DWORD)_fbPicsWaitFlags);
        return;
    }

    LPVOID pDetails = NULL;
    //
    // Ratings has only ansi apis!
    //
    CHAR szURL[MAX_URL_STRING];
    SHUnicodeToAnsi(_pszPicsURL, szURL, ARRAYSIZE(szURL));


    UINT cbMultiByte = WideCharToMultiByte(CP_ACP, 0, pszLabel,
                                           -1, NULL, 0, NULL, NULL);
    if (cbMultiByte > 0) {
        char *pszLabelAnsi = new char[cbMultiByte+1];
        if (pszLabelAnsi != NULL)
        {
            if (WideCharToMultiByte(CP_ACP, 0, pszLabel, -1, pszLabelAnsi,
                                    cbMultiByte+1, NULL, NULL))
            {
                HRESULT hres = ::RatingCheckUserAccess(NULL, szURL,
                                                       pszLabelAnsi, NULL, _dwPicsLabelSource,
                                                       &pDetails);
                _GotLabel(hres, pDetails, bFlag);
            }

            delete [] pszLabelAnsi;
        }
    }
}

/* This function parses the URL being downloaded and, if the URL doesn't
 * already refer to the root document of the site, sets up a subordinate
 * CDocObjectHost to download that root document, so we can get ratings
 * out of it.
 */
void CDocObjectHost::CPicsProcessor::_StartPicsRootQuery(LPCTSTR pszURL)
{
    if (_fbPicsWaitFlags & PICS_WAIT_FOR_ROOT) {
        BOOL fQueued = FALSE;

        TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsRootQuery parsing %s", pszURL);

        WCHAR wszRootURL[MAX_URL_STRING+1];
        DWORD cchResult;

        /* The pszURL we're passed is actually the result of calling
         * CoInternetGetSecurityUrl, and so may not be the scheme that
         * the caller is browsing to.  To support pluggable protocols
         * determining the root location themselves, we first use the
         * URL reported by _GetCurrentPage, which may refer to a
         * pluggable protocol; if that fails, we use the more standard
         * URL.
         */
        HRESULT hres = INET_E_DEFAULT_ACTION;

        LPOLESTR pwszURL = NULL;
        if (SUCCEEDED(_pdoh->_GetCurrentPageW(&pwszURL, TRUE)))
        {
            hres = CoInternetParseUrl(pwszURL, PARSE_ROOTDOCUMENT, 0, wszRootURL,
                                      ARRAYSIZE(wszRootURL), &cchResult, 0);

            OleFree(pwszURL);
        }

        if (pszURL != NULL && (hres == INET_E_DEFAULT_ACTION || hres == E_FAIL)) {
            /* Pluggable protocol doesn't support PARSE_ROOTDOCUMENT.  Use the
             * more standard URL we were supplied with.
             */
            hres = CoInternetParseUrl(pszURL, PARSE_ROOTDOCUMENT, 0, wszRootURL,
                                      ARRAYSIZE(wszRootURL), &cchResult, 0);
        }

        if (SUCCEEDED(hres)) {
            IMoniker *pmk = NULL;
            hres = MonikerFromURL(wszRootURL, &pmk);

            if (SUCCEEDED(hres)) {
                BOOL fFrameIsSilent = FALSE;
                BOOL fFrameIsOffline = FALSE;

                _pdoh->_GetOfflineSilent(&fFrameIsOffline, &fFrameIsSilent);

                _pRootDownload = new CPicsRootDownload(this, fFrameIsOffline, fFrameIsSilent);
                if (_pRootDownload != NULL) {
                    TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsRootQuery starting download");
                    hres = _pRootDownload->StartDownload(pmk);
                    if (SUCCEEDED(hres))
                        fQueued = TRUE;
                }
            }
            if (pmk != NULL)
                pmk->Release();
        }
        if (!fQueued) {
            _fbPicsWaitFlags &= ~PICS_WAIT_FOR_ROOT;
            TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsRootQuery queueing failed, waitflags now %x", (DWORD)_fbPicsWaitFlags);
            if (!_fbPicsWaitFlags) {
                _HandlePicsChecksComplete();
            }
        }
    }
    else {
        TraceMsg(DM_PICS, "CDOH::CPP::_StartPicsRootQuery no query queued, waitflags=%x", (DWORD)_fbPicsWaitFlags);
    }
}

void CDocObjectHost::CPicsProcessor::_HandlePicsChecksComplete(void)
{
    if (!_fPicsAccessAllowed) 
    {
        TraceMsg(DM_PICS, "CDOH::CPP::_HandlePicsChecksComplete access denied, posting WM_PICS_DOBLOCKINGUI to hwnd %x", (DWORD_PTR)_pdoh->_hwnd);

        /* Allow download of this and other frames to continue while we post
         * the denial UI.
         */
        if (!PostMessage(_pdoh->_hwnd, WM_PICS_DOBLOCKINGUI, 0, _GetKey())) {
            TraceMsg(DM_PICS, "CDOH::CPP::_HandlePicsChecksComplete couldn't post message!");
        }
    }
    else 
    {
        if( _pPrivWindow )
        {
            TraceMsg(DM_PICS, "CDOH::CPP::_HandlePicsChecksComplete access allowed, posting WM_PICS_RESULTTOPRIVWIN");

            if (!PostMessage( _pdoh->_hwnd, WM_PICS_RESULTTOPRIVWIN, IDOK, _GetKey()))
            {
                TraceMsg(DM_PICS, "CDOH::CPP::_HandlePicsChecksComplete couldn't post message!");
            }
        }
        else
        {
            TraceMsg(DM_PICS, "CDOH::CPP::_HandlePicsChecksComplete access allowed, execing ACTIVATEMENOW");
            if (!_pdoh->_fSetTarget && _pdoh->_pmsoctBrowser)
            {
                _pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_ACTIVATEMENOW, NULL, NULL, NULL);
            }
        }
    }
}



void CDocObjectHost::CPicsProcessor::_ReInit()
{
    TraceMsg(DM_PICS, "CDOH::CPP::_ReInit");

    _fPicsAccessAllowed = TRUE;
    _fInDialog = FALSE;
    _fTerminated = FALSE;

    _fbPicsWaitFlags = 0;
    _dwPicsLabelSource = 0;

    if (_pPrivWindow)
    {
        _pPrivWindow->SetPICSTarget(NULL);
        _pPrivWindow->Release();
        _pPrivWindow = NULL;
    }

    if (_pRootDownload != NULL) {
        _pRootDownload->CleanUp();
        ATOMICRELEASET(_pRootDownload,CPicsRootDownload);
    }

    _pPicsProcNext = NULL;

    if (_pRatingDetails){
        ::RatingFreeDetails(_pRatingDetails);
        _pRatingDetails = NULL;
    }

    if (_dwPicsSerialNumber) {
        ::_RemovePicsQuery(_dwPicsSerialNumber);
        _dwPicsSerialNumber = 0;
    }

    if (_hPicsQuery)
    {
        RatingObtainCancel(_hPicsQuery);
        _hPicsQuery = NULL;
    }

    if ( _pszPicsURL )
    {
        delete _pszPicsURL;
        _pszPicsURL = NULL;
    }
}

void 
CDocObjectHost::CPicsProcessor::_Terminate()
{
    ASSERT( this != &(_pdoh->_PicsProcBase) );

    if (!_fInDialog)
    {
        delete this;
    }
    else
    {
        _fTerminated = TRUE;
    }
    
}


CDocObjectHost::CPicsProcessor * 
CDocObjectHost::_GetPicsProcessorFromKey(LONG_PTR lKey)
{
    CPicsProcessor * ppp = &_PicsProcBase;

    while( ppp )
    {
        if (ppp->_GetKey() == lKey)
            return ppp;
        ppp = ppp->_pPicsProcNext;
    }

    return NULL;
}

CDocObjectHost::CPicsProcessor * 
CDocObjectHost::_GetPicsProcessorFromSerialNumber(DWORD dwSerial)
{
    CPicsProcessor * ppp = &_PicsProcBase;

    ASSERT( dwSerial != NULL );

    while( ppp )
    {
        if (ppp->_dwPicsSerialNumber == dwSerial)
            return ppp;
        ppp = ppp->_pPicsProcNext;
    }

    return NULL;
}

void CDocObjectHost::_StartBasePicsProcessor()
{
    HRESULT hres;
    BOOL bRatingsEnabled;
    IRatingNotification* pRatingNotify;

    hres = QueryService(SID_SRatingNotification, IID_PPV_ARG(IRatingNotification, &pRatingNotify));

    if (SUCCEEDED(hres))
    {
        bRatingsEnabled = pRatingNotify->IsRatingsEnabled() ? FALSE : TRUE;
        pRatingNotify->Release();
    }
    else
    {
        bRatingsEnabled = IS_RATINGS_ENABLED() && ::RatingEnabledQuery() == S_OK;
    }

    if(bRatingsEnabled)
    {
        TraceMsg(DM_PICS, "CDOH::_StartBasePicsProcessor entered with ratings enabled");

        LPOLESTR pwszRawURL = NULL;

        if (SUCCEEDED(_GetCurrentPageW(&pwszRawURL, TRUE)))
        {
            _PicsProcBase._StartPicsQuery(pwszRawURL);

            OleFree(pwszRawURL);
        }
    }
}

HRESULT CDocObjectHost::_StartSecondaryPicsProcessor(IHTMLPrivateWindow * pPrivWin)
{
    HRESULT hr = S_FALSE;

    ASSERT( pPrivWin );

    HRESULT hres;
    BOOL bRatingsEnabled;
    IRatingNotification* pRatingNotify;

    hres = QueryService(SID_SRatingNotification, IID_PPV_ARG(IRatingNotification, &pRatingNotify));

    if (SUCCEEDED(hres))
    {
        bRatingsEnabled = pRatingNotify->IsRatingsEnabled() ? FALSE : TRUE;
        pRatingNotify->Release();
    }
    else
    {
        bRatingsEnabled = IS_RATINGS_ENABLED() && ::RatingEnabledQuery() == S_OK;
    }
    
    if (bRatingsEnabled)
    {
        LPOLESTR          pwszURL = NULL;

        // CWindow::GetPendingUrl() has LPOLESTR * parameter. 
        hr = pPrivWin->GetPendingUrl( &pwszURL );
        if ( SUCCEEDED(hr) && pwszURL )
        {
            CPicsProcessor * pPicsProc = new CPicsProcessor;
            if( pPicsProc )
            {
                pPicsProc->_pdoh = this;
                pPicsProc->_pPrivWindow = pPrivWin;
                pPrivWin->AddRef();
                pPicsProc->_dwKey = _dwPicsKeyBase++;

                hr = pPicsProc->_StartPicsQuery( pwszURL );
                if( hr == S_FALSE )
                {
                    delete pPicsProc;
                }
                else
                {
                    pPicsProc->_pPicsProcNext = _PicsProcBase._pPicsProcNext;
                    _PicsProcBase._pPicsProcNext = pPicsProc;
                    pPrivWin->SetPICSTarget( SAFECAST(pPicsProc, IOleCommandTarget *) );
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            OleFree( pwszURL );
        }
    }

    return hr;
}

HRESULT CDocObjectHost::_RemovePicsProcessorByKey(LONG_PTR lKey)
{
    ASSERT( lKey != 0 );

    // The base Proc has a 0 key and should never be removed

    CPicsProcessor * ppp = &_PicsProcBase;
    CPicsProcessor * pppLast = NULL;

    while( ppp )
    {
        if (ppp->_GetKey() == lKey)
        {
            ASSERT(pppLast);
            pppLast->_pPicsProcNext = ppp->_pPicsProcNext;

            ppp->_Terminate();
            return S_OK;
        }

        pppLast = ppp;
        ppp = ppp->_pPicsProcNext;
    }

    return S_FALSE;
}

HRESULT CDocObjectHost::_RemovePicsProcessorByPrivWindowUnk(IUnknown* pUnkFind)
{
    ASSERT( pUnkFind );

    // The base Proc has a 0 key and should never be removed

    CPicsProcessor * ppp = &_PicsProcBase;
    CPicsProcessor * pppLast = NULL;

    while( ppp )
    {
        if (ppp->_pPrivWindow)
        {
            IUnknown * pUnkThisOne;

            if (SUCCEEDED( ppp->_pPrivWindow->QueryInterface( IID_IUnknown, (void**)&pUnkThisOne ) ))
            {
                if (pUnkThisOne == pUnkFind)
                {
                    ASSERT(pppLast);
                    pppLast->_pPicsProcNext = ppp->_pPicsProcNext;

                    ppp->_Terminate();

                    pUnkThisOne->Release();
                    return S_OK;
                }
                pUnkThisOne->Release();
            }
        }

        pppLast = ppp;
        ppp = ppp->_pPicsProcNext;
    }

    return S_FALSE;
}

HRESULT CDocObjectHost::_RemoveAllPicsProcessors()
{
    CPicsProcessor * ppp = &_PicsProcBase;
    CPicsProcessor * pppNext;

    while( ppp )
    {
        pppNext = ppp->_pPicsProcNext;
        if (ppp != &_PicsProcBase)
            ppp->_Terminate();
        else
            ppp->_ReInit();
        ppp = pppNext;
    }

    return S_OK;
}

HRESULT CDocObjectFrame::QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj)
{
    return _pdoh->QueryService(guidService, riid, ppvObj);
}

HRESULT CDocObjectFrame::QueryInterface(REFIID riid, void ** ppvObj)
{
    if (IsEqualIID(riid, IID_IOleInPlaceFrame) ||
        IsEqualIID(riid, IID_IOleInPlaceUIWindow) ||
        IsEqualIID(riid, IID_IOleWindow) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IOleInPlaceFrame*);
    }
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
    {
        *ppvObj = SAFECAST(this, IOleCommandTarget*);
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppvObj = SAFECAST(this, IServiceProvider*);
    }
    else if (IsEqualIID(riid, IID_IInternetSecurityMgrSite))
    {
        *ppvObj = SAFECAST(this, IInternetSecurityMgrSite*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    _pdoh->AddRef();
    return NOERROR;
}

ULONG CDocObjectFrame::AddRef(void)
{
    return _pdoh->AddRef();
}

ULONG CDocObjectFrame::Release(void)
{
    return _pdoh->Release();
}

HRESULT CDocObjectFrame::GetWindow(HWND * lphwnd)
{
    DOFMSG(TEXT("GetWindow called"));
    return _pdoh->_pipu ?
        _pdoh->_pipu->GetWindow(lphwnd) :
        _pdoh->_psb ? _pdoh->_psb->GetWindow(lphwnd) :
        _pdoh->GetWindow(lphwnd);
}

HRESULT CDocObjectFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    DOFMSG(TEXT("ContextSensitiveHelp called"));
    return _pdoh->ContextSensitiveHelp(fEnterMode);
}

HRESULT CDocObjectFrame::GetBorder(LPRECT lprectBorder)
{
    // DOFMSG(TEXT("GetBorder called"));
    return _pdoh->_pipu ?
        _pdoh->_pipu->GetBorder(lprectBorder) : E_UNEXPECTED;
}

HRESULT CDocObjectFrame::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    DOFMSG(TEXT("RequestBorderSpace called"));
    return _pdoh->_pipu ?
        _pdoh->_pipu->RequestBorderSpace(pborderwidths) : E_UNEXPECTED;
}

HRESULT CDocObjectFrame::SetBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    // DOFMSG(TEXT("SetBorderSpace called"));
    return _pdoh->_pipu ?
        _pdoh->_pipu->SetBorderSpace(pborderwidths) : E_UNEXPECTED;
}

HRESULT CDocObjectFrame::SetActiveObject(
        IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName)
{
    DOFMSG(TEXT("SetActiveObject called"));

    // Note that we need to call both.
    _pdoh->_xao.SetActiveObject(pActiveObject);

    if (_pdoh->_pipu) {
        //
        // Note that we should pass proxy IOleActiveObject pointer instead.
        //
        _pdoh->_pipu->SetActiveObject(pActiveObject ? &_pdoh->_xao : NULL, pszObjName);
    }
    return S_OK;
}

HRESULT CDocObjectFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    DOFMSG2(TEXT("InsertMenus called with"), hmenuShared);
    return _pdoh->_InsertMenus(hmenuShared, lpMenuWidths);
}

HRESULT CDocObjectFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    DOFMSG2(TEXT("SetMenu called with"), hmenuShared);
    return _pdoh->_SetMenu(hmenuShared, holemenu, hwndActiveObject);
}

HRESULT CDocObjectFrame::RemoveMenus(HMENU hmenuShared)
{
    DOFMSG(TEXT("RemoveMenus called"));
    return _pdoh->_RemoveMenus(hmenuShared);
}

HRESULT CDocObjectFrame::SetStatusText(LPCOLESTR pszStatusText)
{
    DOFMSG(TEXT("SetStatusText called"));
    return _pdoh->_SetStatusText(pszStatusText);
}

HRESULT CDocObjectFrame::EnableModeless(BOOL fEnable)
{
    DOFMSG(TEXT("EnableModeless called"));
    return _pdoh->_EnableModeless(fEnable);
}

// IOleInPlaceFrame::TranslateAccelerator
HRESULT CDocObjectFrame::TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    // NOTES: This code remains as-is. If we have something special
    //  it should be done in CDocObjectHost::TranslateAccelerator
    return _pdoh->_TranslateAccelerator(lpmsg, wID);
}

HRESULT CDocObjectFrame::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    DOFMSG(TEXT("QueryStatus called"));
    return _pdoh->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

HRESULT CDocObjectFrame::Exec(const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    DOFMSG(TEXT("Exec called"));
    return _pdoh->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

//***   CPAO::TranslateAccelerator (IOIPAO::TranslateAccelerator)
//
HRESULT CProxyActiveObject::TranslateAccelerator(
    LPMSG lpmsg)
{
    HRESULT hres = E_FAIL;

    // IShellBrowser is supporsed to call ISV::TranslateAcceleratorSV,
    // but why not be nice?
    ASSERT(!_pdoh->_fCycleFocus);

    //
    // Don't call DocObject's TranslateAccelarator with non-key messages.
    // It's better to be IE compatible.
    //
    BOOL fKeybrdMsg = IsInRange(lpmsg->message, WM_KEYFIRST, WM_KEYLAST);
    if (fKeybrdMsg && _piact && (hres = _piact->TranslateAccelerator(lpmsg)) == S_OK) {
        if (_pdoh->_fCycleFocus) {
            // we got called back by trident (IOCS::TA), but deferred it.
            // time to pay the piper.
            TraceMsg(DM_FOCUS, "DOH::IOIPAO::TA piao->TA==S_OK ret _fCycleFocus=FALSE hr=S_FALSE (piper)");
            _pdoh->_fCycleFocus = FALSE;
            return S_FALSE;     // time to pay the piper
        }
        return S_OK;
    }
    if (_pdoh->_fCycleFocus) {
        TraceMsg(DM_ERROR, "DOH::IOIPAO::TA _fCycleFocus && hres=%x (!=S_OK)", hres);
        _pdoh->_fCycleFocus = FALSE;
        return S_FALSE;
    }

    return _pdoh->TranslateHostAccelerators(lpmsg);
}

HRESULT CProxyActiveObject::OnFrameWindowActivate(
    BOOL fActivate)
{
    TraceMsg(TF_SHDUIACTIVATE, "CProxyAO::OnFrameWindowActivate called with %d (_piact=%x)",
             fActivate, _piact);
    if (_piact) {
        return _piact->OnFrameWindowActivate(fActivate);
    }
    return S_OK;
}

HRESULT CProxyActiveObject::OnDocWindowActivate(
    BOOL fActivate)
{
    return S_OK;
}

HRESULT CProxyActiveObject::ResizeBorder(
    LPCRECT prcBorder,
    IOleInPlaceUIWindow *pUIWindow,
    BOOL fFrameWindow)
{
    if (_piact) {
        //
        // Note that we must pass our proxy frame instead!
        //
        return _piact->ResizeBorder(prcBorder, &_pdoh->_dof, TRUE);
    }
    return E_FAIL;
}
void CProxyActiveObject::SetActiveObject(IOleInPlaceActiveObject *piact )
{
    if (_piact)
    {
        ATOMICRELEASE(_piact);
        _hwnd = NULL;
    }

    if (piact) {
        _piact = piact;
        _piact->AddRef();
        _piact->GetWindow(&_hwnd);
    }
}

HRESULT CProxyActiveObject::EnableModeless(
    BOOL fEnable)
{
    // IShellBrowser is supporsed to call ISV::EnableModelessSV,
    // but why not be nice?
    HRESULT hres = S_OK;
    if (_piact)
        hres = _piact->EnableModeless(fEnable);
    return hres;
}

HRESULT CProxyActiveObject::QueryInterface(REFIID riid, void ** ppvObj)
{
    if (IsEqualIID(riid, IID_IOleInPlaceActiveObject) ||
        IsEqualIID(riid, IID_IOleWindow) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IOleInPlaceActiveObject*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    _pdoh->AddRef();
    return NOERROR;
}

ULONG CProxyActiveObject::AddRef(void)
{
    return _pdoh->AddRef();
}

ULONG CProxyActiveObject::Release(void)
{
    return _pdoh->Release();
}

HRESULT CProxyActiveObject::GetWindow(HWND * lphwnd)
{
    return _pdoh->GetWindow(lphwnd);
}

HRESULT CProxyActiveObject::ContextSensitiveHelp(BOOL fEnterMode)
{
    return _pdoh->ContextSensitiveHelp(fEnterMode);
}

#define ANIMATION_WND_WIDTH     (100+3)

void CDocObjectHost::_PlaceProgressBar(BOOL fForcedLayout)
{
    if (_psb) {
        HWND hwndStatus = NULL;
        _psb->GetControlWindow(FCW_STATUS, &hwndStatus);
        if (hwndStatus) {
            RECT rc;
            INT_PTR fSimple = SendMessage(hwndStatus, SB_ISSIMPLE, 0, 0);

            if (!fSimple || fForcedLayout) {
                // While processing WM_SIZE, turn off the simple mode temporarily.
                if (fSimple)
                    _psb->SendControlMsg(FCW_STATUS, SB_SIMPLE, 0, 0, NULL);

                GetClientRect(hwndStatus, &rc);
                const UINT cxZone = ZoneComputePaneSize(hwndStatus);
                UINT cxProgressBar = (_fShowProgressCtl) ? 100 : 0;

                INT nSBWidth = rc.right - rc.left;
                INT arnRtEdge[STATUS_PANES] = {1};
                INT nIconPaneWidth = GetSystemMetrics(SM_CXSMICON) +
                                     (GetSystemMetrics(SM_CXEDGE) * 4);
                INT nWidthReqd = cxZone + cxProgressBar + (nIconPaneWidth * 3);

                arnRtEdge[STATUS_PANE_NAVIGATION] = max(1, nSBWidth - nWidthReqd);

                nWidthReqd -= cxProgressBar;
                arnRtEdge[STATUS_PANE_PROGRESS] = max(1, nSBWidth - nWidthReqd);

                nWidthReqd -= (nIconPaneWidth);
                arnRtEdge[STATUS_PANE_OFFLINE] = max(1, nSBWidth - nWidthReqd);

                nWidthReqd -= (nIconPaneWidth);
                arnRtEdge[STATUS_PANE_PRIVACY] = max(1, nSBWidth - nWidthReqd);

//                nWidthReqd -= (nIconPaneWidth);
//                arnRtEdge[STATUS_PANE_PRINTER] = max(1, nSBWidth - nWidthReqd);

                nWidthReqd -= (nIconPaneWidth);
                arnRtEdge[STATUS_PANE_SSL] = max(1, nSBWidth - nWidthReqd);

                arnRtEdge[STATUS_PANE_ZONE] = -1;

                LRESULT nParts = 0;
                nParts = SendMessage(hwndStatus, SB_GETPARTS, 0, 0L);
                if (nParts != STATUS_PANES)
                {
                    for ( int n = 0; n < nParts; n++)
                    {
                        SendMessage(hwndStatus, SB_SETTEXT, n | SBT_NOTABPARSING, NULL);
                        SendMessage(hwndStatus, SB_SETICON, n, NULL);
                    }
                    SendMessage(hwndStatus, SB_SETPARTS, 0, 0L);
                }

                SendMessage(hwndStatus, SB_SETPARTS, STATUS_PANES, (LPARAM)arnRtEdge);

                if (!_hwndProgress) {
                    _psb->GetControlWindow(FCW_PROGRESS, &_hwndProgress);
                }

                if (_hwndProgress) {
                    if (SendMessage(hwndStatus, SB_GETRECT, 1, (LPARAM)&rc))
                    {
                        InflateRect(&rc, -GetSystemMetrics(SM_CXEDGE), -GetSystemMetrics(SM_CYEDGE));
                    }
                    else
                    {
                        rc.left = rc.top = rc.right = rc.bottom = 0;
                    }

                    SetWindowPos(_hwndProgress, NULL,
                                 rc.left, rc.top,
                                 rc.right-rc.left, rc.bottom-rc.top,
                                 SWP_NOZORDER | SWP_NOACTIVATE);
                }

                SendMessage(hwndStatus, SB_SETTEXT, 1 | SBT_NOTABPARSING, (LPARAM)TEXT(""));
                SendMessage(hwndStatus, SB_SETMINHEIGHT, GetSystemMetrics(SM_CYSMICON) +
                                                         GetSystemMetrics(SM_CYBORDER) * 2, 0L);

                // Restore
                if (fSimple)
                     SendMessage(hwndStatus, SB_SIMPLE, TRUE, 0);
            }
        }
    } else {
        TraceMsg(TF_WARNING, "_PlaceProgressBar ASSERT(_psb) this=%x", this);
    }
}

void CDocObjectHost::_ActivateOleObject(void)
{
    HRESULT hres;
    _pole->SetClientSite(NULL);

    if (_fDontInPlaceNavigate())
    {
        TraceMsg(TF_SHDAPPHACK, "CDOH::_ActivateOleObject calling DoVerb because of _fDontInPlaceNavigate()");
    }

    _EnableModeless(FALSE);

    hres = _pole->DoVerb(
                _fUseOpenVerb() ? OLEIVERB_OPEN : OLEIVERB_PRIMARY,
                NULL, NULL, (UINT)-1, NULL, NULL);

    _EnableModeless(TRUE);

    if (SUCCEEDED(hres))
    {
        CShdAdviseSink_Advise(_pwb, _pole);
    }
#ifdef DEBUG
    else if (!_fDelegatedNavigation)
    {
        TraceMsg(DM_ERROR, "CDOH::_ActivateOleObject DoVerb failed %x.", hres);
    }
#endif

    // We must release the OLE object to avoid calling Close
    // from _UnBind.
    _ReleaseOleObject();

    _ReleasePendingObject();

}

void CDocObjectHost::ClearScriptError()
{
    // clear out the script error list
    _pScriptErrList->ClearErrorList();
    _SetPriorityStatusText(NULL);

    // reset the text and icon
    _ResetStatusBar();
}

//
// The docobject's READYSTATE property may have changed
//
void CDocObjectHost::_OnReadyState(long lVal, BOOL fUpdateHistory /* = TRUE */)
{
    // Forward this to the browser so we can source ReadyState events properly
    //  TRACE this zekel
    if (_psb)
    {
        IDocNavigate *pdn;
        if (SUCCEEDED(_psb->QueryInterface(IID_IDocNavigate, (void **)&pdn)))
        {
            ASSERT(_psv);
            pdn->OnReadyStateChange(_psv, lVal);
            pdn->Release();
        }
    }

    // NOTE: The below code is rather wasteful. The OmWindow stuff
    // should trigger off the above ReadyState code.
    //
    IShellHTMLWindowSupport *phtmlWS;
    if (_psp && SUCCEEDED(_psp->QueryService(SID_SOmWindow, IID_IShellHTMLWindowSupport, (void**)&phtmlWS)))
    {
        phtmlWS->ReadyStateChangedTo(lVal, _psv);
        phtmlWS->Release();
    }

    if (    (lVal == READYSTATE_INTERACTIVE)
        &&  (_pScriptErrList != NULL))
    {
        ClearScriptError();
    }    

    if (lVal >= READYSTATE_INTERACTIVE)
    {
        // Technically we can get this value multiple times,
        // so make sure we call _Navigate only once.
        //
        if (!_fReadystateInteractiveProcessed)
        {
            _fReadystateInteractiveProcessed = TRUE;

            _Navigate();
        }

        if (lVal == READYSTATE_COMPLETE)
        {
            _OnSetProgressPos(0, PROGRESS_RESET);

            // We aren't going to commit error pages to the history
            //
            if (_pwb && !_fErrorPage && fUpdateHistory)
            {
                WCHAR szTitle[MAX_PATH]; // titles are only stored up to this size

                if (SUCCEEDED(_pwb->GetTitle(_psv, szTitle, ARRAYSIZE(szTitle))))
                {
                    // BharatS : 01/09/97 : There is no need to tie the updating of the title in the
                    // history to the updating of the INTSITE database. Thus the INTSITE database
                    // update can be moved out of AddUrlToUrlHistoryStg() in history.cpp when time permits
                    // to a more logical place such as someplace in dochost.cpp
                    //
                    _UpdateHistoryAndIntSiteDB(szTitle);
                }
                else
                {
                    _UpdateHistoryAndIntSiteDB(NULL);
                }
            }
        }
    }
}

HRESULT CDocObjectHost::_OnChangedReadyState()
{
    IDispatch * p_idispatch;

    ASSERT(_pole || _fFriendlyError);
    if (!_pole)
        return E_UNEXPECTED;

    if (SUCCEEDED(_pole->QueryInterface( IID_IDispatch, (void **) &p_idispatch)))
    {
        VARIANTARG va;
        EXCEPINFO exInfo;

        va.vt = 0;
        if (EVAL(SUCCEEDED(p_idispatch->Invoke( DISPID_READYSTATE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, (DISPPARAMS *)&g_dispparamsNoArgs, &va, &exInfo, NULL))
          && va.vt == VT_I4))
        {
            _OnReadyState(va.lVal);

            // If we are hosting Trident's native frames build,
            // we don't want to call _RemoveTransitionCapability().
            //
            if (!_fDocCanNavigate && va.lVal == READYSTATE_COMPLETE)
            {
                _RemoveTransitionCapability();
            }

        }
        p_idispatch->Release();
    }

    return( NOERROR );
}

HRESULT CDocObjectHost::OnRequestEdit(DISPID dispid)
{
    return E_NOTIMPL;
}

//
// OnChanged
//
//   Notification from the DocObject that one of its
//   properties has changed.
//
HRESULT CDocObjectHost::OnChanged(DISPID dispid)
{
    if (DISPID_READYSTATE == dispid || DISPID_UNKNOWN == dispid)
        return _OnChangedReadyState();

    return S_OK;
}

extern BOOL _ValidateURL(LPTSTR pszName);

void CDocObjectHost::_UpdateHistoryAndIntSiteDB(LPCWSTR pwszTitle)
{
    TCHAR szUrl[MAX_URL_STRING];

    if (SUCCEEDED(_GetCurrentPage(szUrl, MAX_URL_STRING, TRUE)) &&
        _ValidateURL(szUrl, UQF_DEFAULT))
    {
        // update history and intsite if this isn't a silent browse
        BOOL bSilent = FALSE;
        HRESULT hr   = _GetOfflineSilent(NULL, &bSilent);

        if (SUCCEEDED(hr) && (!bSilent))
        {
            BOOL fWriteHistory,
                 fSelectHistory;

            fWriteHistory  = TRUE;
            fSelectHistory = TRUE;

            if (NULL != _pocthf)
            {
                MSOCMD rgCmd[] = { { SBCMDID_WRITEHIST, 0 }, { SBCMDID_SELECTHISTPIDL, 0 } };

                _pocthf->QueryStatus(&CGID_Explorer, ARRAYSIZE(rgCmd), rgCmd, NULL);

                fWriteHistory  = BOOLIFY(rgCmd[0].cmdf & MSOCMDF_ENABLED);
                fSelectHistory = BOOLIFY(rgCmd[1].cmdf & MSOCMDF_ENABLED);
            }

            AddUrlToUrlHistoryStg(szUrl,
                      pwszTitle,
                      _psb,
                      fWriteHistory,
                      fSelectHistory ? _pocthf : NULL,
                      get_punkSFHistory(), NULL);

            //
            //  Satona had the redirect code ifdef'd out, but for
            //  netscape compatibility, we need to update the history
            //  for the redirected URL as well.  - zekel - 22-JUL-97
            //

            // If this page is a redirect, update intsite for destination too
            INTERNET_CACHE_ENTRY_INFO *pCacheEntry = NULL;

            WCHAR    chBuf[MAX_CACHE_ENTRY_INFO_SIZE];

            // Find entry in cache using redirect map
            pCacheEntry = (INTERNET_CACHE_ENTRY_INFO *)chBuf;

            DWORD dwSize = SIZEOF(chBuf);
            BOOL fSuccess = GetUrlCacheEntryInfoEx(szUrl, pCacheEntry, &dwSize, NULL, 0, NULL, 0);

            if (fSuccess)
            {
                // If we have a different url than we started with, update it too
                if (StrCmp(szUrl, pCacheEntry->lpszSourceUrlName)) 
                {
                    AddUrlToUrlHistoryStg(pCacheEntry->lpszSourceUrlName,
                              pwszTitle,
                              _psb,
                              fWriteHistory,
                              fSelectHistory ? _pocthf : NULL,
                              get_punkSFHistory(), NULL);
                }
            }
        }
    }
}



//
// CDocObjectHost::_SetUpTransitionCapability()
//
//   Returns TRUE if all the following hold true:
//      - object has readystate property
//      - readystate property is currently < interactive
//      - Object supports IPropertyNotifySink
//   Then this object supports delayed switching when it
//   it tells us that it is ready...
//
//   This is how we switch pages only when the new page is ready to be
//   switched to.    Also, by doing this we can also make the switch smooth
//   by applying graphical transitions.
//

BOOL CDocObjectHost::_SetUpTransitionCapability(BOOL fWindowOpen /* = FALSE */)
{
    // By default DocObject doesn't have gray-flash communication
    BOOL fSupportsReadystate = FALSE;
    long lReadyState = 0;   // Init to avoid a bogus C4701 warning

    // Sanity Check
    if (!_pole)
        return(fSupportsReadystate);

    // Check for proper readystate support
    BOOL fReadyStateOK = FALSE;
    IDispatch * p_idispatch;
    if (SUCCEEDED(_pole->QueryInterface( IID_IDispatch, (void **) &p_idispatch )))
    {
        VARIANTARG va;
        EXCEPINFO exInfo;

        if (SUCCEEDED(p_idispatch->Invoke( DISPID_READYSTATE, IID_NULL, LOCALE_USER_DEFAULT,  DISPATCH_PROPERTYGET, (DISPPARAMS *)&g_dispparamsNoArgs, &va, &exInfo, NULL)))
        {
            if ((va.vt == VT_I4) && (va.lVal < READYSTATE_COMPLETE))
            {
                lReadyState = fWindowOpen ? READYSTATE_COMPLETE : va.lVal;
                fReadyStateOK = TRUE;
            }
        }

        p_idispatch->Release();
    }

    if (fReadyStateOK)
    {
        // Check and Set-Up IPropertyNotifySink
        if (SUCCEEDED(ConnectToConnectionPoint(SAFECAST(this, IPropertyNotifySink*), IID_IPropertyNotifySink, TRUE, _pole, &_dwPropNotifyCookie, NULL)))
        {
            fSupportsReadystate = TRUE;
            _OnReadyState(lReadyState);
        }
    }

    // If no ReadyState, we simulate it
    if (!fSupportsReadystate)
    {
        if (fWindowOpen)
        {
            // Connect the property notify sink or we
            // will never activate the pending view.
            //
            ConnectToConnectionPoint(SAFECAST(this, IPropertyNotifySink*),
                                     IID_IPropertyNotifySink, 
                                     TRUE, 
                                     _pole,
                                     &_dwPropNotifyCookie,
                                     NULL);
        }

        _OnReadyState(READYSTATE_COMPLETE, !fWindowOpen);
    }

    return(fSupportsReadystate);
}

// This removes any property notify sink we set up
//
BOOL CDocObjectHost::_RemoveTransitionCapability()
{
    BOOL fRet = FALSE;

    if (_dwPropNotifyCookie)
    {
        ConnectToConnectionPoint(NULL, IID_IPropertyNotifySink, FALSE, _pole, &_dwPropNotifyCookie, NULL);
        fRet = TRUE;
    }

    return(fRet);
}

HRESULT _GetRequestFlagFromPIB(IBinding *pib, DWORD *pdwOptions)
{
    HRESULT hres = E_FAIL;
    *pdwOptions = 0;
    if (pib)
    {
        IWinInetInfo* pwinet;
        hres = pib->QueryInterface(IID_IWinInetInfo, (void **)&pwinet);
        if (SUCCEEDED(hres)) {
            DWORD cbSize = SIZEOF(*pdwOptions);
            hres = pwinet->QueryOption(INTERNET_OPTION_REQUEST_FLAGS,
                                (LPVOID)pdwOptions, &cbSize);
            TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() pwinet->QueryOptions hres=%x dwOptions=%x", hres, *pdwOptions);

            pwinet->Release();
        }
    }
    return hres;
}

void CDocObjectHost::_Navigate()
{
    NAVMSG3(TEXT("_Navigate calling SHDVID_ACTIVATEMENOW"), 0, NULL);

    if (_pmsoctBrowser)
    {
        VARIANT varSynch;

        V_VT(&varSynch)   = VT_BOOL;
        V_BOOL(&varSynch) = _fDocCanNavigate ? VARIANT_TRUE : VARIANT_FALSE;

        _pmsoctBrowser->Exec(&CGID_ShellDocView,
                             SHDVID_ACTIVATEMENOW,
                             NULL,
                             &varSynch,
                             NULL);
    }
}

void CDocObjectHost::_NavigateFolder(BSTR bstrUrl)
{
    // This code accesses one of IE's default behaviors which
    // allows for navigation to a web folder.
    // ------------------------------------------------------

    Iwfolders * pWF = NULL;
    IElementBehaviorFactory * pebf = NULL;
    IElementBehavior * pPeer = NULL;
    HWND hwndOwner = NULL;
    IServiceProvider * psp = NULL;
    IUnknown * punkwb = NULL;

    // Make the peer factory
    if  ( !_psb || (FAILED(_psb->GetWindow (&hwndOwner))) ||
          (FAILED(CoCreateInstance(CLSID_PeerFactory, NULL, CLSCTX_INPROC,
                          IID_IElementBehaviorFactory, (void **)&pebf))) ||
          (FAILED(pebf->FindBehavior(L"httpFolder", NULL, NULL, &pPeer))) ||
          (FAILED(pPeer->QueryInterface(IID_Iwfolders, (void **)&pWF))) ||
          (FAILED(QueryService(SID_STopLevelBrowser, IID_IServiceProvider, (void **)&psp))) ||
          (FAILED(psp->QueryService(SID_SContainerDispatch, IID_IUnknown, (void **)&punkwb))) )
    {
        WCHAR wszMessage[MAX_PATH];
        WCHAR wszTitle[MAX_PATH];

        MLLoadShellLangString(IDS_ERRORINTERNAL, wszMessage, ARRAYSIZE(wszMessage));
        MLLoadShellLangString(IDS_NAME, wszTitle, ARRAYSIZE(wszTitle));

        ULONG_PTR uCookie = 0;
        SHActivateContext(&uCookie);
        MessageBox(hwndOwner, wszMessage, wszTitle, MB_OK | MB_ICONERROR);
        if (uCookie)
        {
            SHDeactivateContext(uCookie);
        }
        goto done;
    }

    // Sundown: coercion to unsigned long is valid for HWNDs
    pWF->navigateNoSite(bstrUrl, NULL, PtrToUlong(hwndOwner), punkwb);

done:
    if (pebf)
        pebf->Release();
    if (pPeer)
        pPeer->Release();
    if (pWF)
        pWF->Release();
    if (punkwb)
        punkwb->Release();
    if (psp)
        psp->Release();
}

void CDocObjectHost::_CancelPendingNavigation(BOOL fAsyncDownload,
                                              BOOL fSyncReally, /* = FALSE */
                                              BOOL fDontShowNavCancelPage, /* = FALSE */
                                              BOOL fForceClose /* = FALSE */)
{
    ASSERT(_phf);

     // TODO: We need to clean up the call to this method and eliminate need for fSyncReally
    //
    // Passing NULL for the 4th argument (instead of passing in a
    // variant like we do in the case when fAsyncDownload is TRUE) looks plain wrong!
    // See how this command+argument is interpreted in CBaseBrowser2::Exec.
    // It is too close to RTM (of IE5.5) now to fix this. The net result is that
    // when this function is called with fAsyncDownload=FALSE, we end up posting
    // ASYNCOP_CANCELPENDINGNAVIGATION, which is just what the caller does not want.
    // To workaround this, I have introduced the argument fSyncReally.

    // the hlframe no longer knows if the clear was a cancel or a start of navigation
    // because we don't call anything tosignal a successfull navigation
    if (_pmsoctBrowser)
    {
        TraceMsg(DM_TRACE, "DOH::_CancelPendingNavigation calling _pmsc->Exec");

        if (_pwb && fDontShowNavCancelPage)
        {
            _pwb->SetFlags(BSF_DONTSHOWNAVCANCELPAGE, BSF_DONTSHOWNAVCANCELPAGE);
        }

        if (fForceClose && _fWindowOpen)  // Force the browser to close
        {
             HideBrowser();  // Makes the browser appear to go away faster.

            _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_CANCELANDCLOSE, 0, NULL, NULL);
        }
        else if (fAsyncDownload)
        {
            VARIANT var = {0};
            var.vt = VT_I4;
            ASSERT(var.lVal == FALSE);    // asynd download is done.

            _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_CANCELNAVIGATION, 0, &var, NULL);
        }
        else if (fSyncReally)
        {
            VARIANT var = { 0 };
            var.vt = VT_I4;
            var.lVal = TRUE;

            _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_CANCELNAVIGATION, 0, &var, NULL);
        }
        else
        {
            // This actually causes an async cancel
            //
            _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_CANCELNAVIGATION, 0, NULL, NULL);
        }
    }

    // Release our navigation state.
    // Doing a "fSyncReally" may cause us to lose our _phf member value.  Check it again.
    //
    if (_phf)
    {
        _phf->Navigate(0, NULL, NULL, (IHlink*)-1);
    }
}

void CDocObjectHost::_ResetStatusBar()
{
    _SetStatusText(TEXT(""));
    if (_psb)
        _psb->SendControlMsg(FCW_STATUS, SB_SETICON, STATUS_PANE_NAVIGATION,
                              (LPARAM)g_ahiconState[IDI_STATE_NORMAL-IDI_STATE_FIRST], NULL);
    return;
}

void CDocObjectHost::_DoAsyncNavigation(LPCTSTR pszURL)
{
    if (_pmsoctBrowser) {
        VARIANT vararg = {0};

        vararg.vt = VT_BSTR;
        vararg.bstrVal = SysAllocStringT(pszURL);
        if (vararg.bstrVal)
        {
            TraceMsg(DM_TRACE, "DOH::_DoAsyncNavigation calling _pmsc->Exec");
            _pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_ASYNCNAVIGATION, 0, &vararg, NULL);
            VariantClear(&vararg);
        }
    }
}

// note: szError is never used, so don't waste time setting it
UINT SHIEErrorMsgBox(IShellBrowser* psb,
                    HWND hwndOwner, HRESULT hrError, LPCWSTR szError, LPCTSTR pszURLparam,
                    UINT idResource, UINT wFlags)
{
    UINT uRet = IDCANCEL;
    TCHAR szMsg[MAX_PATH];
    LPCTSTR pszURL = TEXT("");
    HWND hwndParent = hwndOwner;
    IShellBrowser *psbParent = NULL;

    // if a URL was specified, use it; otherwise use empty string
    if (pszURLparam)
        pszURL = pszURLparam;

    //
    // NOTES: This table of error code will be mapped to (IDS_ERRMSG_FIRST +
    //  offset) and we MLLoadString it.
    //
    const static c_ahres[] = {
        HRESULT_FROM_WIN32(ERROR_INTERNET_INVALID_URL),
        HRESULT_FROM_WIN32(ERROR_INTERNET_NAME_NOT_RESOLVED),
        INET_E_UNKNOWN_PROTOCOL,
        INET_E_REDIRECT_FAILED,
        INET_E_DATA_NOT_AVAILABLE,
    };

    for (int i=0; i<ARRAYSIZE(c_ahres); i++) {
        if (c_ahres[i]==hrError) {
            MLLoadString(IDS_ERRMSG_FIRST+i, szMsg, ARRAYSIZE(szMsg));
            break;
        }
    }

    if (i >= ARRAYSIZE(c_ahres))
    {
        // Default message if FormatMessage doesn't recognize dwLastError
        MLLoadString(IDS_UNDEFINEDERR, szMsg, ARRAYSIZE(szMsg));

        if (hrError >= HRESULT_FROM_WIN32(INTERNET_ERROR_BASE)
            && hrError <= HRESULT_FROM_WIN32(INTERNET_ERROR_LAST))
        {
            HMODULE hmod = GetModuleHandle(TEXT("WININET"));
            ASSERT(hmod);
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, (LPCVOID)hmod, HRESULT_CODE(hrError), 0L,
                szMsg, ARRAYSIZE(szMsg), NULL);

        } else {
            // See if one of the system components has an error message
            // for this error.  If not, szMsg will retain our default
            // message to handle this.
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hrError, 0L,
                szMsg, ARRAYSIZE(szMsg), NULL);
        }
    }

    psbParent = psb;
    if (psbParent)
    {
        psbParent->AddRef();
    }

    //  Here we make an heroic effort to find a visible window to run the dialog against
    //  If we can't, then we bail, to avoid weird UI effect (particularly when the frametop
    //  browser is in kiosk mode
    if (!IsWindowVisible(hwndParent))
    {
        if (NULL == psb || FAILED(psb->GetWindow(&hwndParent)) || !IsWindowVisible(hwndParent))
        {
            hwndParent = NULL;
            ATOMICRELEASE(psbParent);
        }
        if (NULL == hwndParent && psb)
        {
            IUnknown_QueryService(psb, SID_STopFrameBrowser, IID_IShellBrowser, (void **)&psbParent);
            if (NULL == psbParent || FAILED(psbParent->GetWindow(&hwndParent)) || !IsWindowVisible(hwndParent))
            {
                hwndParent = NULL;
            }
        }
    }

    if (hwndParent)
    {
        if (psbParent) {
            psbParent->EnableModelessSB(FALSE);
        }

        uRet = MLShellMessageBox(hwndParent,
                               MAKEINTRESOURCE(idResource),
                               MAKEINTRESOURCE(IDS_TITLE),
                               wFlags, pszURL,szMsg);

        if (psbParent) {
            psbParent->EnableModelessSB(TRUE);
        }
    }

    if (psbParent)
    {
        UINT cRef = psbParent->Release();

        AssertMsg(cRef>0, TEXT("IE_ErrorMsgBox psb->Release returned 0."));
    }

    return uRet;
}

//
// See if the URL is of a type that we should
// ShellExecute()
//
HRESULT IsProtocolRegistered(LPCTSTR pcszProtocol);

BOOL ShouldShellExecURL(LPTSTR pszURL)
{
    BOOL fRet = FALSE;
    PARSEDURL pu = {sizeof(pu)};
    HRESULT hr = ParseURL(pszURL, &pu);
    if (SUCCEEDED(hr) && pu.nScheme != URL_SCHEME_SHELL)
    {
        TCHAR sz[MAX_PATH];
        *sz = 0;
        hr = StringCchCatN(sz, ARRAYSIZE(sz), pu.pszProtocol, pu.cchProtocol);
        if (SUCCEEDED(hr))
        {
            hr = IsProtocolRegistered(sz);
            if (SUCCEEDED(hr))
            {
                //
                //  HACKHACK - telnet.exe will fault on buffer overrun
                //      if the url is > 230. we special case here.
                //
                if (lstrlen(pszURL) <= 230 ||
                        (StrCmpI(sz, TEXT("telnet")) && 
                         StrCmpI(sz, TEXT("rlogin")) &&
                         StrCmpI(sz, TEXT("tn3270"))
                        )
                   )
                {
                    fRet = TRUE;
                }
            }
        }
    }
    return fRet;
}


//========================================================================
// class CShdAdviseSink
//========================================================================

class CShdAdviseSink : public IAdviseSink
{
public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAdviseSink methods ***
    virtual void __stdcall OnDataChange(
        FORMATETC *pFormatetc,
        STGMEDIUM *pStgmed);
    virtual void __stdcall OnViewChange(
        DWORD dwAspect,
        LONG lindex);
    virtual void __stdcall OnRename(
        IMoniker *pmk);
    virtual void __stdcall OnSave( void);
    virtual void __stdcall OnClose( void);

    CShdAdviseSink(IBrowserService* pwb, IOleObject* pole);
    ~CShdAdviseSink();

protected:
    UINT _cRef;
    IOleObject* _pole;
    DWORD       _dwConnection;
};

//
//  We'd better maintain the list of those CShdAdviseSink
//  per-thread so that we don't leak all those oleobjects when
//  the thread is terminated before those objects are closed.
//
void CShdAdviseSink_Advise(IBrowserService* pwb, IOleObject* pole)
{
    IAdviseSink* padv = new CShdAdviseSink(pwb, pole);
    // If pole->Advise succeeds, it will addreff to IAdviseSink.
    if (padv != NULL)
    {
        padv->Release();
    }
}

CShdAdviseSink::CShdAdviseSink(IBrowserService* pwb, IOleObject* pole)
    : _cRef(1)
{
    ASSERT(pole);
    TraceMsg(DM_ADVISE, "CShdAdviseSink(%x) being constructed", this);
    HRESULT hres = pole->Advise(this, &_dwConnection);
    if (SUCCEEDED(hres)) {
        _pole = pole;
        pole->AddRef();

        TraceMsg(DM_ADVISE, "CShdAdviseSink(%x) called pole->Advise. new _cRef=%d (%x)", this, _cRef, _dwConnection);
    }
}

CShdAdviseSink::~CShdAdviseSink()
{
    TraceMsg(DM_ADVISE, "CShdAdviseSink(%x) being destroyed", this);
    ATOMICRELEASE(_pole);
}

ULONG CShdAdviseSink::AddRef()
{
    _cRef++;
    TraceMsg(TF_SHDREF, "CShdAdviseSink(%x)::AddRef called, new _cRef=%d", this, _cRef);
    return _cRef;
}

ULONG CShdAdviseSink::Release()
{
    _cRef--;
    TraceMsg(TF_SHDREF, "CShdAdviseSink(%x)::Release called, new _cRef=%d", this, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CShdAdviseSink::QueryInterface(REFIID riid, void ** ppvObj)
{
    if (IsEqualIID(riid, IID_IAdviseSink) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IAdviseSink*)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

void CShdAdviseSink::OnDataChange(
    FORMATETC *pFormatetc,
    STGMEDIUM *pStgmed)
{
}

void CShdAdviseSink::OnViewChange(
    DWORD dwAspect,
    LONG lindex)
{
}

void CShdAdviseSink::OnRename(
    IMoniker *pmk)
{
}

void CShdAdviseSink::OnSave( void)
{
}

void CShdAdviseSink::OnClose( void)
{
    TraceMsg(DM_ADVISE, "CShdAdviseSink(%x)::OnClose called. Calling Unadvise. _cRef=%d", this, _cRef);
    HRESULT hres;
    AddRef();
    ASSERT(_pole);
    if (_pole)  // paranoia
    {
        hres = _pole->Unadvise(_dwConnection);
        ATOMICRELEASE(_pole);
        TraceMsg(DM_ADVISE, "CShdAdviseSink(%x)::OnClose. Called Unadvise(%x). new _cRef=%d", this, hres, _cRef);
    }
    Release();
}

/// adding property sheet pages

HRESULT CDocObjectHost::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    HRESULT hres = S_OK;
    IShellPropSheetExt *pspse;
    /*
     * Create a property sheet page for required page, including imported File
     * Types property sheet.
     */
    // add stuff that the docobj itself has.
    if (_pole)
    {
        if (SUCCEEDED(_pole->QueryInterface(IID_IShellPropSheetExt, (void **)&pspse)))
        {
            hres = pspse->AddPages(lpfnAddPage, lParam);
            pspse->Release();
        }
        else
        {
            // Some docobjects don't know about IShellPropSheetExt (ie, Visual Basic),
            // so do it ourselves.

            if (NULL == _hinstInetCpl)
                _hinstInetCpl = LoadLibrary(TEXT("inetcpl.cpl"));

            if (_hinstInetCpl)
            {
                PFNADDINTERNETPROPERTYSHEETSEX pfnAddSheet = (PFNADDINTERNETPROPERTYSHEETSEX)GetProcAddress(_hinstInetCpl, STR_ADDINTERNETPROPSHEETSEX);
                if (pfnAddSheet)
                {
                    IEPROPPAGEINFO iepi = {0};

                    // we just want the security page.
                    iepi.cbSize = sizeof(iepi);
                    iepi.dwFlags = (DWORD)-1;       // all pages

                    hres = pfnAddSheet(lpfnAddPage, lParam, 0, 0, &iepi);
                }
                // Don't FreeLibrary here, otherwise PropertyPage will GP-fault!
            }
        }
    }

    return hres;
}


//==========================================================================
// IDocHostUIHandler implementation
//==========================================================================

HRESULT CDocObjectHost::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->TranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID);
    return _dhUIHandler.TranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID);
}


HRESULT CDocObjectHost::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    // REVIEW: Does this apply anymore?
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetDropTarget called");

    HRESULT hres;

    if (_pWebOCUIHandler)
    {
        hres = _pWebOCUIHandler->GetDropTarget(pDropTarget, ppDropTarget);
        
        if (SUCCEEDED(hres))
            return hres;
    }
     
    if (pDropTarget) 
    {   
        hres = S_OK;
        IDropTarget *pdtFrame;
        IDropTarget *pdt3;
        IDropTarget *pdtBlocking;

        QueryService(SID_STopFrameBrowser, IID_IDropTarget, (void **)&pdtFrame);

        // hack: this is because we need to look all the way through to top parents for a containing drop target
        // what we really need is a per dataobject drop target
        //
        // this is not required to be obtained
        QueryService(SID_ITopViewHost, IID_IDropTarget, (void **)&pdt3);
        if (IsSameObject(pdt3, pdtFrame)) {
            ATOMICRELEASE(pdt3);
        }

        // allow constrained browser bands like Search to prevent drop
        QueryService(SID_SDropBlocker, IID_IUnknown, (void **)&pdtBlocking);
        if (pdtBlocking)
        {
            ATOMICRELEASE(pdt3);
            pDropTarget = NULL;
        }

        if (pdtFrame) 
        {
            *ppDropTarget = DropTargetWrap_CreateInstance(pDropTarget, pdtFrame, _hwnd, pdt3);
            if (!*ppDropTarget)
                hres = E_OUTOFMEMORY;

            TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetDropTarget returning S_OK");
            ASSERT(hres == S_OK);

            pdtFrame->Release();
        } 
        else 
        {
            ASSERT(0);
            hres = E_UNEXPECTED;
        }

        ATOMICRELEASE(pdtBlocking);
        ATOMICRELEASE(pdt3);
    } 
    else 
    {
        hres = E_INVALIDARG;
    }

    return hres;
}

HRESULT CDocObjectHost::ShowUI(
    DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
    IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
    IOleInPlaceUIWindow *pDoc)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->ShowUI(dwID, pActiveObject, pCommandTarget, pFrame, pDoc);

    if (_dwAppHack & BROWSERFLAG_MSHTML) // Who else will call on this interface?
    {
        if (_pmsoctBrowser)
        {
            TraceMsg(DM_PREMERGEDMENU, "DOH::ShowUI called this=%x pcmd=%x",
                     this,pCommandTarget);
            VARIANT var = { 0 };
            HRESULT hresT=_pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_SETMERGEDWEBMENU, 0, NULL, &var);
            if (SUCCEEDED(hresT))
            {
                if (_pcmdMergedMenu)
                {
                    // Tell Trident to stop calling us twice
                    TraceMsg(DM_WARNING, "DOH::ShowUI called twice! "
                             "this=%x pcmdCur=%x pcmdNew=%x",
                             this, _pcmdMergedMenu, pCommandTarget);
                    _pcmdMergedMenu->Release();
                }
                _pcmdMergedMenu = pCommandTarget;
                _pcmdMergedMenu->AddRef();
                ASSERT(var.vt == VT_INT_PTR);
                _hmenuCur = (HMENU)var.byref;

                DEBUG_CODE( _DumpMenus(TEXT("after ShowUI"), TRUE); )
                return S_OK;
            }
        }
    }

    return S_FALSE;
}


HRESULT CDocObjectHost::HideUI(void)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->HideUI();

    if (_pcmdMergedMenu) {
        _pcmdMergedMenu->Release();
        _pcmdMergedMenu = NULL;
    }

    return S_FALSE;
}

HRESULT CDocObjectHost::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    IServiceProvider * psp = NULL;
    IWebBrowser2     * pwb = NULL;
    VARIANT_BOOL       b = VARIANT_FALSE;
    DWORD              dwFlagsWebOC = 0;
    HRESULT            hr;

    if (_pWebOCUIHandler
        && SUCCEEDED(_pWebOCUIHandler->GetHostInfo(pInfo))
        )
    {
        dwFlagsWebOC = pInfo->dwFlags;
    }

    _dhUIHandler.GetHostInfo(pInfo);

    // Merge flags
    //
    pInfo->dwFlags |= dwFlagsWebOC;

    // Add the local machine flag, if we're in iexplore.exe or explorer.exe.
    if (IsInternetExplorerApp())
        pInfo->dwFlags |= DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK;

    // Get the top level browser
    //
    hr = QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IServiceProvider, &psp));
    if (hr)
        goto Cleanup;

    // Get the IWebBrowser2 object/interface
    //
    hr = psp->QueryService(SID_SContainerDispatch, IID_IWebBrowser2, (void **)&pwb);
    if (hr)
        goto Cleanup;

    // Tell the browser what our dochost flags are
    IEFrameAuto *pIEFrameAuto;
    if (SUCCEEDED(pwb->QueryInterface(IID_PPV_ARG(IEFrameAuto, &pIEFrameAuto))))
    {
        pIEFrameAuto->SetDocHostFlags(pInfo->dwFlags);
        pIEFrameAuto->Release();
    }

    // Is the browser in Theater Mode?
    //
    hr = pwb->get_TheaterMode(&b);
    if (hr)
        goto Cleanup;

    // If so, turn on flat scrollbars.
    //
    if (b == VARIANT_TRUE)
        pInfo->dwFlags |= DOCHOSTUIFLAG_FLAT_SCROLLBAR;

Cleanup:
    ATOMICRELEASE(psp);
    ATOMICRELEASE(pwb);
    
    return S_OK;
}

HRESULT CDocObjectHost::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
    HRESULT             hr;
    OLECMD              rgcmd = { IDM_BROWSEMODE, 0 };

    // If we're in the WebOC and it has a IDocHostUIHandler, use it.
    //
    if ( _pWebOCUIHandler && !SHRestricted2W(REST_NoBrowserContextMenu, NULL, 0))
    {
        hr = _pWebOCUIHandler->ShowContextMenu(dwID, ppt, pcmdtReserved, pdispReserved);
        if (hr == S_OK)
            goto Cleanup;
    }

    // Find out if the DocObject is in Edit mode
    // Don't need apphack here as only Trident responds to CGID_MSHTML
    //

    hr = IUnknown_QueryStatus(pcmdtReserved, &CGID_MSHTML, 1, &rgcmd, NULL);
    if (    hr == S_OK
        &&  !(rgcmd.cmdf & OLECMDF_LATCHED))   // if not LATCHED means we're in edit mode.
    {
        hr = S_FALSE;
    }
    else
    {
        hr = _dhUIHandler.ShowContextMenu(dwID, ppt, pcmdtReserved, pdispReserved);
    }

Cleanup:
    return hr;
}

HRESULT CDocObjectHost::UpdateUI(void)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->UpdateUI();
    return _dhUIHandler.UpdateUI();
}

HRESULT CDocObjectHost::EnableModeless(BOOL fEnable)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->EnableModeless(fEnable);
    return _dhUIHandler.EnableModeless(fEnable);
}

HRESULT CDocObjectHost::OnDocWindowActivate(BOOL fActivate)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->OnDocWindowActivate(fActivate);
    return _dhUIHandler.OnDocWindowActivate(fActivate);
}

HRESULT CDocObjectHost::OnFrameWindowActivate(BOOL fActivate)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->OnFrameWindowActivate(fActivate);
    return _dhUIHandler.OnFrameWindowActivate(fActivate);
}

HRESULT CDocObjectHost::ResizeBorder( LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->ResizeBorder(prcBorder, pUIWindow, fRameWindow);
    return _dhUIHandler.ResizeBorder(prcBorder, pUIWindow, fRameWindow);
}

HRESULT CDocObjectHost::GetOptionKeyPath(BSTR *pbstrKey, DWORD dw)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->GetOptionKeyPath(pbstrKey, dw);
    return _dhUIHandler.GetOptionKeyPath(pbstrKey, dw);
}

HRESULT CDocObjectHost::GetExternal(IDispatch **ppDisp)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->GetExternal(ppDisp);
    return _dhUIHandler.GetExternal(ppDisp);
}

HRESULT CDocObjectHost::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->TranslateUrl(dwTranslate, pchURLIn, ppchURLOut);
    return _dhUIHandler.TranslateUrl(dwTranslate, pchURLIn, ppchURLOut);
}

HRESULT CDocObjectHost::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    if (_pWebOCUIHandler)
        return _pWebOCUIHandler->FilterDataObject(pDO, ppDORet);
    return _dhUIHandler.FilterDataObject(pDO, ppDORet);
}

HRESULT CDocObjectHost::GetOverrideKeyPath(LPOLESTR *pchKey, DWORD dw)
{
    if (_pWebOCUIHandler2)
        return _pWebOCUIHandler2->GetOverrideKeyPath(pchKey, dw);
    return _dhUIHandler.GetOverrideKeyPath(pchKey, dw);
}

HRESULT CDocObjectHost::ShowMessage(HWND hwnd, LPOLESTR lpstrText, LPOLESTR lpstrCaption,
           DWORD dwType, LPOLESTR lpstrHelpFile, DWORD dwHelpContext, LRESULT __RPC_FAR *plResult)
{
    if (_pWebOCShowUI)
    {
        return _pWebOCShowUI->ShowMessage(hwnd, lpstrText, lpstrCaption, dwType,
                                            lpstrHelpFile, dwHelpContext, plResult);
    }

    return E_FAIL;
}

HRESULT CDocObjectHost::ShowHelp(HWND hwnd, LPOLESTR pszHelpFile, UINT uCommand, DWORD dwData,
           POINT ptMouse, IDispatch __RPC_FAR *pDispatchObjectHit)
{
    if (_pWebOCShowUI)
    {
        return _pWebOCShowUI->ShowHelp(hwnd, pszHelpFile, uCommand, dwData, ptMouse,
                                                pDispatchObjectHit);
    }

    return E_FAIL;
}

void
CDocObjectHost::HideBrowser() const
{
    if (_psp && _fWindowOpen && !(_dwAppHack & BROWSERFLAG_DONTAUTOCLOSE))
    {
        IWebBrowser2 * pWebBrowser;

        HRESULT hres = _psp->QueryService(SID_SWebBrowserApp,
                                          IID_PPV_ARG(IWebBrowser2, &pWebBrowser));
        if (SUCCEEDED(hres))
        {
            pWebBrowser->put_Visible(VARIANT_FALSE);
            pWebBrowser->Release();
        }
    }
}

//
// support for script error caching and status bar notification
//

void
CDocObjectHost::_ScriptErr_Dlg(BOOL fOverridePerErrorMode)
{
    // we can get reentered through the message pump ShowHTMLDialog runs
    // therefore we might already have a dialog open when a second dialog
    // is requested

    if (_fScriptErrDlgOpen)
    {
        // a dialog is already open lower in the callstack
        // request an up-to-date dialog be shown
        // we have to do this because otherwise we might
        // be in per-error-mode and miss some errors which
        // arrived while the dialog lower in the callstack
        // was open. note that we only do this if we're set
        // to show notifications for every error.

        _fShowScriptErrDlgAgain = SHRegGetBoolUSValue(szRegKey_SMIEM,
                                                      szRegVal_ErrDlgPerErr,
                                                      FALSE,
                                                      TRUE);
    }
    else
    {
        _fScriptErrDlgOpen = TRUE;

        // keep showing dialogs as long as someone farther up the
        // call stack keeps requesting them

        do
        {
            BOOL    fShowDlg;

            _fShowScriptErrDlgAgain = FALSE;

            // if the user double clicked on the status bar, then we
            // show the dialog regardless of per-error-mode settings

            if (fOverridePerErrorMode)
            {
                fShowDlg = TRUE;

                // because of other script errors hitting the
                // _fScriptErrDlgOpen code above, we can arrive
                // here multiple times. The first time we show a
                // dialog can be because the user requested it,
                // but all subsequent times must be because we're
                // in "show every error" mode.

                fOverridePerErrorMode = FALSE;
            }
            else
            {
                fShowDlg = SHRegGetBoolUSValue(szRegKey_SMIEM,
                                               szRegVal_ErrDlgPerErr,
                                               FALSE,
                                               TRUE);
            }

            if (fShowDlg)
            {
                HRESULT hr;
                TCHAR   szResURL[MAX_URL_STRING];

                hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                       HINST_THISDLL,
                                       ML_CROSSCODEPAGE,
                                       TEXT("ieerror.dlg"),
                                       szResURL,
                                       ARRAYSIZE(szResURL),
                                       TEXT("shdocvw.dll"));
                if (SUCCEEDED(hr))
                {
                    IMoniker *  pmk;
                    HWND        hwnd;

                    hr = CreateURLMoniker(NULL, szResURL, &pmk);
                    if (SUCCEEDED(hr))
                    {
                        VARIANT varErrorCache;

                        V_VT(&varErrorCache) = VT_DISPATCH;
                        V_DISPATCH(&varErrorCache) = _pScriptErrList;

                        GetWindow(&hwnd);
                        ShowHTMLDialog(hwnd, pmk, &varErrorCache, L"help:no", NULL);
                        ATOMICRELEASE(pmk);
                    }
                }
            }
        } while (_fShowScriptErrDlgAgain);

        _fScriptErrDlgOpen = FALSE;
    }
}

HRESULT
CDocObjectHost::_ScriptErr_CacheInfo(VARIANTARG *pvarIn)

{
    IHTMLDocument2 *    pOmDoc;
    IHTMLWindow2 *      pOmWindow;
    IHTMLEventObj *     pEventObj;
    HRESULT             hr;

    TCHAR *       apchNames[] =
                            { TEXT("errorLine"),
                              TEXT("errorCharacter"),
                              TEXT("errorCode"),
                              TEXT("errorMessage"),
                              TEXT("errorUrl")
                            };
    DISPID              aDispid[ARRAYSIZE(apchNames)];
    VARIANT             varOut[ARRAYSIZE(apchNames)];
    int                 i;

    pOmDoc = NULL;
    pOmWindow = NULL;
    pEventObj = NULL;

    // load the script error object

    hr = V_UNKNOWN(pvarIn)->QueryInterface(IID_IHTMLDocument2, (void **) &pOmDoc);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pOmDoc->get_parentWindow(&pOmWindow);
    ATOMICRELEASE(pOmDoc);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pOmWindow->get_event(&pEventObj);
    ATOMICRELEASE(pOmWindow);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // copy the interesting data out of the event object
    //

    for (i = 0; i < ARRAYSIZE(apchNames); i++)
    {
        DISPPARAMS  params;

        // get the property's dispid
        hr = pEventObj->GetIDsOfNames(IID_NULL, &apchNames[i], 1, LOCALE_SYSTEM_DEFAULT, &aDispid[i]);
        if (hr != S_OK)
        {
            ATOMICRELEASE(pEventObj);
            return hr;
        }

        params.cArgs = 0;
        params.cNamedArgs = 0;

        hr = pEventObj->Invoke(aDispid[i], IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET, &params, &varOut[i], NULL, NULL);
        if (hr != S_OK)
        {
            ATOMICRELEASE(pEventObj);
            return hr;
        }
    }

    ATOMICRELEASE(pEventObj);

    ASSERT(V_VT(&varOut[0]) == VT_I4);
    ASSERT(V_VT(&varOut[1]) == VT_I4);
    ASSERT(V_VT(&varOut[2]) == VT_I4);
    ASSERT(V_VT(&varOut[3]) == VT_BSTR);
    ASSERT(V_VT(&varOut[4]) == VT_BSTR);
    ASSERT(ARRAYSIZE(apchNames) == 5);

    hr = _pScriptErrList->AddNewErrorInfo(V_I4(&varOut[0]),         // line
                                          V_I4(&varOut[1]),       // char
                                          V_I4(&varOut[2]),       // code
                                          V_BSTR(&varOut[3]),     // message
                                          V_BSTR(&varOut[4]));    // url

    return hr;
}

//
// CScriptErrorList manages an array of _CScriptErrInfo objects
// the script error handler dialogs access this information
// when requested by the user
//

CScriptErrorList::CScriptErrorList() :
    CImpIDispatch(LIBID_SHDocVw, 1, 1, IID_IScriptErrorList)
{
    ASSERT(_lDispIndex == 0);

    _ulRefCount = 1;

    _hdpa = DPA_Create(4);
}

CScriptErrorList::~CScriptErrorList()
{
    if (_hdpa != NULL)
    {
        ClearErrorList();
        DPA_Destroy(_hdpa);
        _hdpa = NULL;
    }
}

HRESULT
CScriptErrorList::AddNewErrorInfo(LONG lLine,
                                  LONG lChar,
                                  LONG lCode,
                                  BSTR strMsg,
                                  BSTR strUrl)
{
    HRESULT             hr;
    _CScriptErrInfo *   pNewData;

    if (strMsg == NULL || strUrl == NULL)
    {
        return E_INVALIDARG;
    }

    pNewData = new _CScriptErrInfo;
    if (pNewData != NULL)
    {
        hr = pNewData->Init(lLine, lChar, lCode, strMsg, strUrl);
        if (SUCCEEDED(hr))
        {
            if (_hdpa != NULL)
            {
                DPA_AppendPtr(_hdpa, (LPVOID)pNewData);
                _lDispIndex = DPA_GetPtrCount(_hdpa)-1;
            }
            else
            {
                delete pNewData;
                hr = E_FAIL;
            }
        }
        else
        {
            delete pNewData;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

void
CScriptErrorList::ClearErrorList()
{
    if (_hdpa != NULL)
    {
        int iDel;
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        // delete from end to beginning to avoid unnecessary packing
        for (iDel = cPtr-1; iDel >= 0; iDel--)
        {
            delete ((_CScriptErrInfo *)DPA_GetPtr(_hdpa, iDel));
            DPA_DeletePtr(_hdpa, iDel);
        }

        _lDispIndex = 0;
    }
}

STDMETHODIMP
CScriptErrorList::QueryInterface(REFIID iid, void ** ppObj)
{
    ASSERT(ppObj != NULL);

    if (IsEqualIID(iid, IID_IUnknown) ||
        IsEqualIID(iid, IID_IDispatch) ||
        IsEqualIID(iid, IID_IScriptErrorList))
    {
        *ppObj = (IScriptErrorList *)this;
    }
    else
    {
        *ppObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();

    return S_OK;
}

STDMETHODIMP_(ULONG)
CScriptErrorList::AddRef()
{
    _ulRefCount++;
    return _ulRefCount;
}

STDMETHODIMP_(ULONG)
CScriptErrorList::Release()
{
    _ulRefCount--;
    if (_ulRefCount > 0)
    {
        return _ulRefCount;
    }

    delete this;
    return 0;
}

STDMETHODIMP
CScriptErrorList::advanceError()
{
    HRESULT hr;

    hr = E_FAIL;

    if (_hdpa != NULL)
    {
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        if (_lDispIndex < cPtr-1)
        {
            _lDispIndex++;
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::retreatError()
{
    if (_lDispIndex < 1)
    {
        return E_FAIL;
    }

    _lDispIndex--;

    return S_OK;
}

STDMETHODIMP
CScriptErrorList::canAdvanceError(BOOL * pfCanAdvance)
{
    HRESULT hr;

    ASSERT(pfCanAdvance != NULL);

    hr = E_FAIL;

    if (_hdpa != NULL)
    {
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);
        *pfCanAdvance = _lDispIndex < cPtr-1;

        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::canRetreatError(BOOL * pfCanRetreat)
{
    ASSERT(pfCanRetreat != NULL);

    *pfCanRetreat = _lDispIndex > 0;

    return S_OK;
}

STDMETHODIMP
CScriptErrorList::getErrorLine(LONG * plLine)
{
    HRESULT hr;

    ASSERT(plLine != NULL);
    ASSERT(_lDispIndex >= 0);

    hr = E_FAIL;
    if (_hdpa != NULL)
    {
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        ASSERT(_lDispIndex < cPtr || _lDispIndex == 0);

        if (cPtr > 0)
        {
            _CScriptErrInfo *    pInfo;

            pInfo = (_CScriptErrInfo *)DPA_GetPtr(_hdpa, _lDispIndex);
            *plLine = pInfo->_lLine;
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::getErrorChar(LONG * plChar)
{
    HRESULT hr;

    ASSERT(plChar != NULL);
    ASSERT(_lDispIndex >= 0);

    hr = E_FAIL;
    if (_hdpa != NULL)
    {
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        ASSERT(_lDispIndex < cPtr || _lDispIndex == 0);

        if (cPtr > 0)
        {
            _CScriptErrInfo *   pInfo;

            pInfo = (_CScriptErrInfo *)DPA_GetPtr(_hdpa, _lDispIndex);
            *plChar  = pInfo->_lChar;
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::getErrorCode(LONG * plCode)
{
    HRESULT hr;

    ASSERT(plCode != NULL);
    ASSERT(_lDispIndex >= 0);

    hr = E_FAIL;
    if (_hdpa != NULL)
    {
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        ASSERT(_lDispIndex < cPtr || _lDispIndex == 0);

        if (cPtr > 0)
        {
            _CScriptErrInfo *   pInfo;

            pInfo = (_CScriptErrInfo *)DPA_GetPtr(_hdpa, _lDispIndex);
            *plCode = pInfo->_lCode;
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::getErrorMsg(BSTR * pstrMsg)
{
    HRESULT hr;

    ASSERT(pstrMsg != NULL);
    ASSERT(_lDispIndex >= 0);

    hr = E_FAIL;
    if (_hdpa != NULL)
    {
        int cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        ASSERT(_lDispIndex < cPtr || _lDispIndex == 0);

        if (cPtr > 0)
        {
            _CScriptErrInfo *   pInfo;

            pInfo = (_CScriptErrInfo *)DPA_GetPtr(_hdpa, _lDispIndex);
            *pstrMsg = SysAllocString(pInfo->_strMsg);

            if (*pstrMsg != NULL)
            {
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::getErrorUrl(BSTR * pstrUrl)
{
    HRESULT hr;

    ASSERT(pstrUrl != NULL);
    ASSERT(_lDispIndex >= 0);

    hr = E_FAIL;
    if (_hdpa != NULL)
    {
        int     cPtr;

        cPtr = DPA_GetPtrCount(_hdpa);

        ASSERT(_lDispIndex < cPtr || _lDispIndex == 0);

        if (cPtr > 0)
        {
            _CScriptErrInfo *   pInfo;

            pInfo = (_CScriptErrInfo *)DPA_GetPtr(_hdpa, _lDispIndex);
            *pstrUrl = SysAllocString(pInfo->_strUrl);

            if (*pstrUrl != NULL)
            {
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

STDMETHODIMP
CScriptErrorList::getAlwaysShowLockState(BOOL * pfAlwaysShowLocked)
{
    *pfAlwaysShowLocked = IsInetcplRestricted(TEXT("Advanced"));

    return S_OK;
}

STDMETHODIMP
CScriptErrorList::getDetailsPaneOpen(BOOL * pfDetailsPaneOpen)
{
    *pfDetailsPaneOpen =
        SHRegGetBoolUSValue(szRegKey_SMIEM,
                            szRegVal_ErrDlgDetailsOpen,
                            FALSE,
                            FALSE);
    return S_OK;
}

STDMETHODIMP
CScriptErrorList::setDetailsPaneOpen(BOOL fDetailsPaneOpen)
{
    TCHAR   szYes[] = TEXT("yes");
    TCHAR   szNo[] = TEXT("no");
    LPTSTR  pszVal;
    int     cbSize;

    if (fDetailsPaneOpen)
    {
        pszVal = szYes;
        cbSize = sizeof(szYes);
    }
    else
    {
        pszVal = szNo;
        cbSize = sizeof(szNo);
    }

    SHRegSetUSValue(szRegKey_SMIEM,
                    szRegVal_ErrDlgDetailsOpen,
                    REG_SZ,
                    pszVal,
                    cbSize,
                    SHREGSET_HKCU | SHREGSET_FORCE_HKCU);

    // even if it failed, we can't do anything about it...
    return S_OK;
}

STDMETHODIMP
CScriptErrorList::getPerErrorDisplay(BOOL * pfPerErrorDisplay)
{
    *pfPerErrorDisplay =
        SHRegGetBoolUSValue(szRegKey_SMIEM,
                            szRegVal_ErrDlgPerErr,
                            FALSE,
                            FALSE);
    return S_OK;
}

STDMETHODIMP
CScriptErrorList::setPerErrorDisplay(BOOL fPerErrorDisplay)
{
    TCHAR   szYes[] = TEXT("yes");
    TCHAR   szNo[] = TEXT("no");
    LPTSTR  pszVal;
    int     cbSize;

    if (fPerErrorDisplay)
    {
        pszVal = szYes;
        cbSize = sizeof(szYes);
    }
    else
    {
        pszVal = szNo;
        cbSize = sizeof(szNo);
    }

    SHRegSetUSValue(szRegKey_SMIEM,
                    szRegVal_ErrDlgPerErr,
                    REG_SZ,
                    pszVal,
                    cbSize,
                    SHREGSET_HKCU | SHREGSET_FORCE_HKCU);

    // even if it failed, we can't do anything about it...
    return S_OK;
}

HRESULT
CScriptErrorList::_CScriptErrInfo::Init(LONG lLine,
                                        LONG lChar,
                                        LONG lCode,
                                        BSTR strMsg,
                                        BSTR strUrl)
{
    ASSERT(_strMsg == NULL);
    ASSERT(_strUrl == NULL);

    _strMsg = SysAllocString(strMsg);
    if (_strMsg == NULL)
    {
        return E_OUTOFMEMORY;
    }

    _strUrl = SysAllocString(strUrl);
    if (_strUrl == NULL)
    {
        SysFreeString(_strMsg);
        return E_OUTOFMEMORY;
    }

    _lLine = lLine;
    _lChar = lChar;
    _lCode = lCode;

    return S_OK;
}

CScriptErrorList::_CScriptErrInfo::~_CScriptErrInfo()
{
    if (_strMsg != NULL)
    {
        SysFreeString(_strMsg);
    }
    if (_strUrl != NULL)
    {
        SysFreeString(_strUrl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\dochostbsc.cpp ===
#include "priv.h"
#include "iehelpid.h"
#include "bindcb.h"
#include "winlist.h"
#include "droptgt.h"
#include <mshtml.h>     // CLSID_HTMLDocument
#include "resource.h"
#include <htmlhelp.h>
#include <prsht.h>
#include <inetcpl.h>
#include <optary.h>
#include "shdocfl.h"
#include "interned.h" // IHTMLPrivateWindow

#ifdef FEATURE_PICS
#include <shlwapi.h>
#include <ratings.h>
#endif

#include "dochost.h"

#include <mluisupp.h>

#define THISCLASS CDocObjectHost
#define SUPERCLASS CDocHostUIHandler

#define BSCMSG(psz, i, j)       TraceMsg(TF_SHDBINDING, "shd TR-BSC::%s %x %x", psz, i, j)
#define BSCMSG3(psz, i, j, k)   TraceMsg(0, "shd TR-BSC::%s %x %x %x", psz, i, j, k)
#define BSCMSG4(psz, i, j, k, l)        TraceMsg(0, "shd TR-BSC::%s %x %x %x %x", psz, i, j, k, l)
#define BSCMSGS(psz, sz)        TraceMsg(0, "shd TR-BSC::%s %s", psz, sz)
#define CHAINMSG(psz, x)        TraceMsg(0, "shd CHAIN::%s %x", psz, x)
#define PERFMSG(psz, x)         TraceMsg(TF_SHDPERF, "PERF::%s %d msec", psz, x)
#define OPENMSG(psz)            TraceMsg(TF_SHDBINDING, "shd OPENING %s", psz)

#define DM_DOCCP        0
#define DM_DEBUGTFRAME  0
#define DM_SELFASC      TF_SHDBINDING
#define DM_SSL              0
#define DM_PICS         0

#define DO_SEARCH_ON_STATUSCODE(x) ((x == 0) || (x == HTTP_STATUS_BAD_GATEWAY) || (x == HTTP_STATUS_GATEWAY_TIMEOUT))

const static c_aidRes[] = {
    IDI_STATE_NORMAL,          // 0
    IDI_STATE_FINDINGRESOURCE, // BINDSTATUS_FINDINGRESOURCE
    IDI_STATE_FINDINGRESOURCE, // BINDSTATUS_CONNECTING
    IDI_STATE_FINDINGRESOURCE, // BINDSTATUS_REDIRECTING
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_BEGINDOWNLOADDATA
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_DOWNLOADINGDATA
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_ENDDOWNLOADDATA
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_BEGINDOWNLOADCOMPONENTS
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_INSTALLINGCOMPONENTS
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_ENDDOWNLOADCOMPONENTS
    IDI_STATE_SENDINGREQUEST,  // BINDSTATUS_USINGCACHEDCOPY
    IDI_STATE_SENDINGREQUEST,  // BINDSTATUS_SENDINGREQUEST
    IDI_STATE_DOWNLOADINGDATA, // BINDSTATUS_CLASSIDAVAILABLE
};

extern HICON g_ahiconState[IDI_STATE_LAST-IDI_STATE_FIRST+1];


#define SEARCHPREFIX        L"? "
#define SEARCHPREFIXSIZE    sizeof(SEARCHPREFIX)
#define SEARCHPREFIXLENGTH  2

// Put the most common errors first in c_aErrorUrls.
//

//========================================================
//
// WARNING - Thinking of changing the Table ?
//
// You also need to update the IsErrorHandled in mshtml
//  src\site\download\dwnbind.cxx
//
//========================================================

ErrorUrls c_aErrorUrls[] =
{
    {404, TEXT("http_404.htm")}, 
    {ERRORPAGE_DNS, TEXT("dnserror.htm")},
    {ERRORPAGE_NAVCANCEL, TEXT("navcancl.htm")},
    {ERRORPAGE_SYNTAX, TEXT("syntax.htm")},
    {400, TEXT("http_400.htm")},
    {403, TEXT("http_403.htm")},
    {405, TEXT("http_gen.htm")},
    {406, TEXT("http_406.htm")},
    {408, TEXT("servbusy.htm")},
    {409, TEXT("servbusy.htm")},
    {410, TEXT("http_410.htm")},
    {500, TEXT("http_500.htm")},
    {501, TEXT("http_501.htm")},
    {505, TEXT("http_501.htm")},
    {ERRORPAGE_OFFCANCEL, TEXT("offcancl.htm")},
    {ERRORPAGE_CHANNELNOTINCACHE, TEXT("cacheerr.htm")},
};
                   
//
// Determine if there is an internal error page for the given http error.
//

BOOL IsErrorHandled(DWORD dwError)
{
    BOOL fRet = FALSE;

    for (int i = 0; i < ARRAYSIZE(c_aErrorUrls); i++)
    {
        if (dwError == c_aErrorUrls[i].dwError)
        {
            fRet = TRUE;
            break;
        }
    }

    return fRet;
}


const SA_BSTRGUID s_sstrSearchIndex = {
    38 * SIZEOF(WCHAR),
    L"{265b75c0-4158-11d0-90f6-00c04fd497ea}"
};

//extern const SA_BSTRGUID s_sstrSearchFlags;
const SA_BSTRGUID s_sstrSearchFlags = {
    38 * SIZEOF(WCHAR),
    L"{265b75c1-4158-11d0-90f6-00c04fd497ea}"
};

EXTERN_C const SA_BSTRGUID s_sstrSearch = {
    38 * SIZEOF(WCHAR),
    L"{118D6040-8494-11d2-BBFE-0060977B464C}"
};

EXTERN_C const SA_BSTRGUID s_sstrFailureUrl = {
    38 * SIZEOF(WCHAR),
    L"{04AED800-8494-11d2-BBFE-0060977B464C}"
};


//
// Clears that parameters set by window.external.AutoScan()
//
HRESULT _ClearSearchString(IServiceProvider* psp)
{
    HRESULT hr = E_FAIL;

    if (psp == NULL)
        return hr;

    IWebBrowser2 *pWB2 = NULL;
    hr = psp->QueryService(SID_SHlinkFrame, IID_IWebBrowser2, (LPVOID*)&pWB2);
    if (pWB2 && SUCCEEDED(hr))
    {
        VARIANT v;
        VariantInit(&v);
        v.vt = VT_EMPTY;

        hr = pWB2->PutProperty((BSTR)s_sstrSearch.wsz, v);
        hr = pWB2->PutProperty((BSTR)s_sstrFailureUrl.wsz, v);
        pWB2->Release();
    }
    return hr;
}

//
// Gets the string that was entered in the addressbar
//
HRESULT _GetSearchString(IServiceProvider* psp, VARIANT* pvarSearch)
{
    HRESULT hr = E_FAIL;

    if (psp != NULL)
    {
        VariantInit(pvarSearch);
        IDockingWindow* psct = NULL;
        IOleCommandTarget* poct;

        // first see if there is an ISearchContext to get this information from
        ISearchContext * pSC = NULL;
        hr = psp->QueryService(SID_STopWindow, IID_ISearchContext, (void **) &pSC);
        if (SUCCEEDED(hr))
        {
            RIP(pSC != NULL);

            pvarSearch->vt = VT_BSTR;
            hr = pSC->GetSearchText(&(pvarSearch->bstrVal));

            pSC->Release();
        }
        else
        {
            // otherwise try to get the search string directly out of the address bar
            hr = psp->QueryService(SID_SExplorerToolbar, IID_IDockingWindow, (LPVOID*)&psct);
            if (SUCCEEDED(hr))
            {
                hr = psct->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&poct);
                if (SUCCEEDED(hr)) 
                {
                    // NULL is the first parameter so our ErrorMsgBox
                    // doesn't call EnableModelessSB()
                    // If we don't, our pdoh members may be freed 
                    // by the time we return.
                    hr = poct->Exec(&CGID_Explorer, SBCMDID_GETUSERADDRESSBARTEXT, 0, NULL, pvarSearch);
                    poct->Release();
                }
                psct->Release();
            }
        }
    }

    return hr;
}

//
// Get page that should be displayed if the AutoScan fails
//
HRESULT _GetScanFailureUrl(IServiceProvider* psp, VARIANT* pvarFailureUrl)
{
    HRESULT hr = E_FAIL;

    if (psp == NULL)
        return hr;

    //
    // See if a default failure page is stored as a property of the page
    //
    IWebBrowser2 *pWB2 = NULL;
    hr = psp->QueryService(SID_SHlinkFrame, IID_IWebBrowser2, (LPVOID*)&pWB2);
    if (pWB2 && SUCCEEDED(hr))
    {
        hr = pWB2->GetProperty((BSTR)s_sstrFailureUrl.wsz, pvarFailureUrl);
        pWB2->Release();
    }
    return hr;
}

HRESULT _GetSearchInfo(IServiceProvider *psp, LPDWORD pdwIndex, LPBOOL pfAllowSearch, LPBOOL pfContinueSearch, LPBOOL pfSentToEngine, VARIANT* pvarUrl)
{
    HRESULT hr = E_FAIL;
    DWORD   dwFlags = 0;

    if (psp) {
        IWebBrowser2 *pWB2 = NULL;
        hr = psp->QueryService(SID_SHlinkFrame, IID_IWebBrowser2, (LPVOID*)&pWB2);
        if (pWB2 && SUCCEEDED(hr)) {
            if (pdwIndex) {
                VARIANT v;
                if (SUCCEEDED(pWB2->GetProperty((BSTR)s_sstrSearchIndex.wsz, &v))) {
                    if (v.vt == VT_I4)
                        *pdwIndex = v.lVal;
                    VariantClear(&v);
                }
            }
            if (pfAllowSearch || pfContinueSearch || pfSentToEngine) {
                VARIANT v;
                if (SUCCEEDED(pWB2->GetProperty((BSTR)s_sstrSearchFlags.wsz, &v))) {
                    if (v.vt == VT_I4)
                        dwFlags = v.lVal;
                    VariantClear(&v);
                }
            }

            //
            // If we have a search string property, and the index is zero, we start
            // with the second autoscan index.  This is because the first index should
            // have already been tried (see window.external.AutoScan()).
            //
            if (pvarUrl)
            {
                VariantInit(pvarUrl); // in case of failure
                if (SUCCEEDED(pWB2->GetProperty((BSTR)s_sstrSearch.wsz, pvarUrl)) &&
                    pvarUrl->vt == VT_BSTR && pdwIndex && *pdwIndex == 0)
                {
                    *pdwIndex = 2;
                }
            }

            if (pfAllowSearch)
                *pfAllowSearch = ((dwFlags & 0x01) ? TRUE : FALSE);
            if (pfContinueSearch)
                *pfContinueSearch = ((dwFlags & 0x02) ? TRUE : FALSE);
            if (pfSentToEngine)
                *pfSentToEngine = ((dwFlags & 0x04) ? TRUE : FALSE);

            pWB2->Release();
        }
    }
    return hr;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::_SetSearchInfo(CDocObjectHost *pdoh, DWORD dwIndex, BOOL fAllowSearch, BOOL fContinueSearch, BOOL fSentToEngine)
{
    HRESULT hr = E_FAIL;
    DWORD   dwFlags = 0;

    dwFlags = (fAllowSearch ? 0x01 : 0) +
              (fContinueSearch ? 0x02 : 0) +
              (fSentToEngine ? 0x04 : 0);

    if (pdoh->_psp)
    {
        IWebBrowser2 *pWB2 = NULL;
        hr = pdoh->_psp->QueryService(SID_SHlinkFrame, IID_IWebBrowser2, (LPVOID*)&pWB2);
        if (pWB2 && SUCCEEDED(hr))
        {
            VARIANT v;
            VariantInit (&v);

            v.vt = VT_I4;
            v.lVal = dwIndex;
            pWB2->PutProperty((BSTR)s_sstrSearchIndex.wsz, v);

            v.vt = VT_I4;
            v.lVal = dwFlags;
            pWB2->PutProperty((BSTR)s_sstrSearchFlags.wsz, v);

            pWB2->Release();
        }
    }

    // If we are done, clear any parameters set by window.external.AutoScan().
    if (!fContinueSearch)
    {
        _ClearSearchString(pdoh->_psp);
    }
    TraceMsg(TF_SHDNAVIGATE, "::HFNS_SetSearchInfo() hr = %X, index = %d, allow = %d, cont = %d, sent = %d", hr, dwIndex, fAllowSearch, fContinueSearch, fSentToEngine);
    
    return hr;
}

//
// Gets the prefix/postfix to use for autoscanning (www.%s.com, etc)
//
LONG GetSearchFormatString(DWORD dwIndex, LPTSTR psz, DWORD cbpsz) 
{
    TCHAR  szValue[11]; //Should be large enough to hold max dword 4294967295
    DWORD dwType;

    wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), dwIndex);
    return SHRegGetUSValue(REGSTR_PATH_SEARCHSTRINGS, szValue, &dwType, (LPVOID)psz, &cbpsz, FALSE, NULL, 0);
}


// dwSearchForExtensions : 0     do not search
// dwSearchForExtensions : 1     search through list of exts.
// dwSearchForExtensions : 2     move on to autosearch

// 0 = never ask, never search
// 1 = always ask
// 2 = never ask, always search

HRESULT GetSearchKeys(IServiceProvider * psp, LPDWORD pdwSearchStyle, LPDWORD pdwSearchForExtensions, LPDWORD pdwDo404Search)
{
    RIP(pdwSearchStyle != NULL);
    RIP(pdwSearchForExtensions != NULL);
    RIP(pdwDo404Search != NULL);

    GetSearchStyle(psp, pdwSearchStyle);

    if (*pdwSearchStyle == 0)
    {
        *pdwSearchForExtensions = NO_SUFFIXES;
        *pdwDo404Search = NEVERSEARCH;
    }
    else
    {
        *pdwSearchForExtensions = SCAN_SUFFIXES;
        *pdwDo404Search = ALWAYSSEARCH;
    }

    return S_OK;
} // GetSearchKeys




//
// Map error codes to error urls.
//

int EUIndexFromError(DWORD dwError)
{
    for (int i = 0; i < ARRAYSIZE(c_aErrorUrls); i++)
    {
        if (dwError == c_aErrorUrls[i].dwError)
            break;
    }

    ASSERT(i < ARRAYSIZE(c_aErrorUrls));

    return i;
}

//
// IsErrorUrl determines if the given url is an internal error page url.  
//


BOOL IsErrorUrl(LPCWSTR pwszDisplayName)
{
    BOOL fRet = FALSE;
    TCHAR szDisplayName[MAX_URL_STRING];
    UnicodeToTChar(pwszDisplayName, szDisplayName, ARRAYSIZE(szDisplayName));

    //
    // First check if the prefix matches.
    //

    if (0 == StrCmpN(szDisplayName, TEXT("res://"), 6))
    {
        int iResStart;

        // find the resource name part of the URL
        // use the fact that the DLL path will be using
        // '\' as delimiters while the URL in general
        // uses '/'

        iResStart = 6;
        while (szDisplayName[iResStart] != TEXT('/'))
        {
            if (szDisplayName[iResStart] == TEXT('\0'))
                return fRet;

            iResStart++;
        }
        iResStart++;    // get off the '/'

        //
        // Check each url in order.
        //
        for (int i = 0; i < ARRAYSIZE(c_aErrorUrls); i++)
        {
            if (0 == StrCmpN(szDisplayName + iResStart, c_aErrorUrls[i].pszUrl,
                             lstrlen(c_aErrorUrls[i].pszUrl)))
            {
                fRet = TRUE;
                break;
            }
        }
    }

    return fRet;
}

//
// When an http error occurs the server generally returns a page.  The
// threshold value this function returns is used to determine if the
// server page is displayed (if the size of the returned page is greater than
// the threshold) or if an internal error page is shown (if the returned page
// is smaller than the threshold).
//

DWORD _GetErrorThreshold(DWORD dwError)
{
    DWORD dwRet;

    TCHAR  szValue[11]; //Should be large enough to hold max dword 4294967295
    DWORD cbValue = ARRAYSIZE(szValue);
    DWORD cbdwRet = sizeof(dwRet);
    DWORD dwType  = REG_DWORD;

    wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), dwError);

    if (ERROR_SUCCESS != SHRegGetUSValue(REGSTR_PATH_THRESHOLDS, szValue,
                                          &dwType, (LPVOID)&dwRet, &cbdwRet,
                                          FALSE, NULL, 0))
    {
        dwRet = 512; // hard coded default size if all else fails.
    }

    return dwRet;
}

void CDocObjectHost::CDOHBindStatusCallback::_RegisterObjectParam(IBindCtx* pbc)
{
    // pbc->RegisterObjectParam(L"BindStatusCallback", this);

    _fAborted = FALSE;
    HRESULT hres = RegisterBindStatusCallback(pbc, this, 0, 0);
    BSCMSG3(TEXT("_RegisterObjectParam returned"), hres, this, pbc);
}

void CDocObjectHost::CDOHBindStatusCallback::_RevokeObjectParam(IBindCtx* pbc)
{
    // pbc->RevokeObjectParam(L"BindStatusCallback");
    HRESULT hres = RevokeBindStatusCallback(pbc, this);
    AssertMsg(SUCCEEDED(hres), TEXT("URLMON bug??? RevokeBindStatusCallback failed %x"), hres);
    BSCMSG3(TEXT("_RevokeObjectParam returned"), hres, this, pbc);
}

CDocObjectHost::CDOHBindStatusCallback::~CDOHBindStatusCallback()
{
    TraceMsg(DM_DEBUGTFRAME, "dtor CDocObjectHost::CBSC %x", this);

    if (_pib) {
        AssertMsg(0, TEXT("CBSC::~ _pib is %x (this=%x)"), _pib, this);
    }
    ATOMICRELEASE(_pib);

    if (_pbc) {
        AssertMsg(0, TEXT("CBSC::~ _pbc is %x (this=%x)"), _pbc, this);
    }
    ATOMICRELEASE(_pbc);

    if (_psvPrev) {
        AssertMsg(0, TEXT("CBSC::~ _psvPrev is %x (this=%x)"), _psvPrev, this);
    }

    ATOMICRELEASE(_psvPrev);
    ATOMICRELEASE(_pbscChained);
    ATOMICRELEASE(_pnegotiateChained);

    if (_hszPostData)
    {
        GlobalFree(_hszPostData);
        _hszPostData = NULL;
    }
    if (_pszHeaders)
    {
        LocalFree(_pszHeaders);
        _pszHeaders = NULL;
    }
    if (_pszRedirectedURL)
    {
        LocalFree(_pszRedirectedURL);
        _pszRedirectedURL = NULL;
    }
    if(_pszCacheFileName)
    {
        LocalFree(_pszCacheFileName);
        _pszCacheFileName = NULL;
    }
    if (_pszPolicyRefURL)
    {
        LocalFree(_pszPolicyRefURL);
        _pszPolicyRefURL = NULL;
    }
    if (_pszP3PHeader)
    {
        LocalFree(_pszP3PHeader);
        _pszP3PHeader = NULL;
    }
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IBindStatusCallback) || 
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IBindStatusCallback*);
    }
    else if (IsEqualIID(riid, IID_IHttpNegotiate))
    {
        *ppvObj = SAFECAST(this, IHttpNegotiate*);
    }
    else if (IsEqualIID(riid, IID_IAuthenticate))
    {
        *ppvObj = SAFECAST(this, IAuthenticate*);
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppvObj = SAFECAST(this, IServiceProvider*);
    }
    else if (IsEqualIID(riid, IID_IHttpSecurity))
    {
        *ppvObj = SAFECAST(this, IHttpSecurity*);
    }
    else if (IsEqualIID(riid, IID_IWindowForBindingUI))
    {
        *ppvObj = SAFECAST(this, IWindowForBindingUI*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

ULONG CDocObjectHost::CDOHBindStatusCallback::AddRef(void)
{
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    return pdoh->AddRef();
}

ULONG CDocObjectHost::CDOHBindStatusCallback::Release(void)
{
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    return pdoh->Release();
}

void SetBindfFlagsBasedOnAmbient(BOOL fAmbientOffline, DWORD *grfBindf);


#define CP_UCS_2                1200  // Unicode, ISO 10646
#define CP_UCS_2_BIGENDIAN      1201  // Unicode
#define CP_UTF_8                65001

UINT
NavigatableCodePage(UINT cp)
{
    return (cp == CP_UCS_2 || cp == CP_UCS_2_BIGENDIAN) ? CP_UTF_8 : cp;
}


HRESULT CDocObjectHost::CDOHBindStatusCallback::GetBindInfo(
     DWORD* grfBINDF,
     BINDINFO *pbindinfo)
{
    if ( !grfBINDF || !pbindinfo || !pbindinfo->cbSize )
        return E_INVALIDARG;

    DWORD dwConnectedStateFlags = 0;
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    BSCMSG(TEXT("GetBindInfo"), 0, 0);

    *grfBINDF = BINDF_ASYNCHRONOUS;

    // Delegation is valid ONLY for the ::GetBindInfo() method
    if (_pbscChained) {
        CHAINMSG("GetBindInfo", grfBINDF);
        _pbscChained->GetBindInfo(grfBINDF, pbindinfo);
        
        DWORD dwFlags = 0;

        if (pdoh->_pwb)
        {
            pdoh->_pwb->GetFlags(&dwFlags);
        }

        pbindinfo->dwCodePage = (dwFlags & BSF_SETNAVIGATABLECODEPAGE)
                                ? NavigatableCodePage(pdoh->_uiCP)
                                : pdoh->_uiCP;
        
        // As far as offline mode is concerned, we want the latest
        // info. Over-rule what the delegated IBSC returned

        SetBindfFlagsBasedOnAmbient(_bFrameIsOffline, grfBINDF);

        if(_bFrameIsSilent)
            *grfBINDF |= BINDF_NO_UI;  
        else
            *grfBINDF &= ~BINDF_NO_UI;
           
    }
    else
    {
        // fill out the BINDINFO struct
        *grfBINDF = 0;
        BuildBindInfo(grfBINDF,pbindinfo,_hszPostData,_cbPostData,
            _bFrameIsOffline, _bFrameIsSilent, FALSE, /* bHyperlink */
            (IBindStatusCallback *) this);

        // HTTP headers are added by the callback to our
        // IHttpNegotiate::BeginningTransaction() method

    }

    // Remember it to perform modeless download for POST case.
    _dwBindVerb = pbindinfo->dwBindVerb;

    // Remember this to use when populating the threadparams for CDownload.
    // (FerhanE): We are only remembering the restricted zone enforcement 
    //            to not break anything that depended on other flags being
    //            not set before.
    _dwBindf = *grfBINDF & BINDF_ENFORCERESTRICTED;

    return S_OK;
}

// *** IAuthenticate ***
HRESULT CDocObjectHost::CDOHBindStatusCallback::Authenticate(
    HWND *phwnd,
    LPWSTR *pszUsername,
    LPWSTR *pszPassword)
{
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);

    if (!phwnd || !pszUsername || !pszPassword)
        return E_POINTER;



    if(!_bFrameIsSilent){
        if (pdoh->_psb) {
            pdoh->_psb->GetWindow(phwnd);
        } else {
            *phwnd = pdoh->_hwnd;
        }
    }else{
        *phwnd = NULL;
    }

    *pszUsername = NULL;
    *pszPassword = NULL;
    // If we're a frame in the active desktop, then find out
    // the user name and password are stored with the subscription
    // and use it
    if(_IsDesktopItem(pdoh))
    {
        // Get the URL
        LPOLESTR pszURL;
        HRESULT hres;
        hres = pdoh->_GetCurrentPageW(&pszURL, TRUE);
        if(SUCCEEDED(hres))
        {
            IActiveDesktop *pActiveDesk;
         
            hres = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IActiveDesktop, (LPVOID*)&pActiveDesk);
            
            if(SUCCEEDED(hres))
            {
                // Get the subscribed URL for this
                COMPONENT Component;

                Component.dwSize = SIZEOF(Component);
                Component.wszSubscribedURL[0] = TEXT('\0');
                hres = pActiveDesk->GetDesktopItemBySource(pszURL, &Component, 0);
                if(SUCCEEDED(hres) && Component.wszSubscribedURL[0])
                {
                    // We have a non null subscribed URL
                    // Gotta find the user name and password 
                    // associated with this subscription
                    ISubscriptionMgr *pSubsMgr;

                    hres = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                                            CLSCTX_INPROC_SERVER, 
                                    IID_ISubscriptionMgr, (LPVOID*)&pSubsMgr);

                    if(SUCCEEDED(hres))
                    {
                        SUBSCRIPTIONINFO SubInfo;
                        SubInfo.cbSize = sizeof(SUBSCRIPTIONINFO);
                        SubInfo.fUpdateFlags = (SUBSINFO_NEEDPASSWORD | SUBSINFO_TYPE 
                                                 | SUBSINFO_USER | SUBSINFO_PASSWORD);
                        SubInfo.bstrUserName = NULL;
                        SubInfo.bstrPassword = NULL;
                        hres = pSubsMgr->GetSubscriptionInfo(Component.wszSubscribedURL, &SubInfo);
                        if(SUCCEEDED(hres) && SubInfo.bNeedPassword)
                        {
                            if((SubInfo.bstrUserName) && (SubInfo.bstrPassword))
                            {
                                // Copy  user name and password
                                SHStrDupW(SubInfo.bstrPassword, pszPassword);
                                SHStrDupW(SubInfo.bstrUserName, pszUsername);
                            }
                        
                        }   
                        if(SubInfo.bstrPassword)
                            SysFreeString(SubInfo.bstrPassword);
                        if(SubInfo.bstrUserName)
                            SysFreeString(SubInfo.bstrUserName);
                        pSubsMgr->Release();
                    }
                }
                pActiveDesk->Release();
            }

            OleFree(pszURL);
        }
        
    }
    
    return S_OK;
}

// *** IServiceProvider ***
HRESULT CDocObjectHost::CDOHBindStatusCallback::QueryService(REFGUID guidService,
                            REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL;

    if (IsEqualGUID(guidService, IID_IAuthenticate)) {
        return QueryInterface(riid, ppvObj);
    }
    else if (IsEqualGUID(guidService, IID_ITargetFrame2))
    {
        return IToClass(CDocObjectHost, _bsc, this)->QueryService(
                    guidService,
                    riid,
                    ppvObj);
    }
    else if (_pbscChained)
    {
        // Has a delegating IBindStatusCallback.
        IServiceProvider* psp;
        hres = _pbscChained->QueryInterface(IID_IServiceProvider, (LPVOID*)&psp);
        if (SUCCEEDED(hres)) {
            // It supports ServiceProvider, just delegate.
            hres = psp->QueryService(guidService, riid, ppvObj);
            psp->Release();
        } else if (IsEqualGUID(guidService, riid)) {
            // It does not supports ServiceProvide, try QI.
            hres = _pbscChained->QueryInterface(riid, ppvObj);
        }
    }

    return hres;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnStartBinding(
            DWORD grfBSCOption, IBinding *pib)
{

    BSCMSG(TEXT("OnStartBinding"), _pib, pib);
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);

    _fBinding = TRUE;
    _fDocWriteAbort = FALSE;
    _fBoundToMSHTML = FALSE;
    ASSERT(pdoh->_pocthf);

    // ASSERT(_pib==NULL);
    ATOMICRELEASE(_pib);

    _pib = pib;
    if (_pib) {
        _pib->AddRef();
    }

#ifndef NO_DELEGATION
    if (_pbscChained) {
        CHAINMSG("OnStartBinding", grfBSCOption);
    _pbscChained->OnStartBinding(grfBSCOption, pib);
    }
#endif

    pdoh->_fShowProgressCtl = TRUE;
    pdoh->_PlaceProgressBar(TRUE);

    _privacyQueue.Reset();
    ResetPrivacyInfo();

    return S_OK;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::GetPriority(LONG *pnPriority)
{
    BSCMSG(TEXT("GetPriority"), 0, 0);
    *pnPriority = NORMAL_PRIORITY_CLASS;
#ifndef NO_DELEGATION
    if (_pbscChained) {
        _pbscChained->GetPriority(pnPriority);
    }
#endif
    return S_OK;
}

void CDocObjectHost::CDOHBindStatusCallback::ResetPrivacyInfo()
{
    _dwPrivacyFlags = 0;

    if (_pszPolicyRefURL)
    {
        LocalFree(_pszPolicyRefURL);
        _pszPolicyRefURL = NULL;
    }
    if (_pszP3PHeader)
    {
        LocalFree(_pszP3PHeader);
        _pszP3PHeader = NULL;
    }
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::AddToPrivacyQueue(LPTSTR * ppszUrl, 
                                                                  LPTSTR * ppszPolicyRef, 
                                                                  LPTSTR * ppszP3PHeader, 
                                                                  DWORD dwFlags)
{
    CPrivacyRecord *pRecord = new CPrivacyRecord;
    
    if (!pRecord)
    {
        return E_OUTOFMEMORY;        
    }
    
    HRESULT hRes = S_OK;

    hRes = pRecord->Init(ppszUrl, ppszPolicyRef, ppszP3PHeader, dwFlags);

    if (SUCCEEDED(hRes))
        _privacyQueue.Queue(pRecord);
    else
        delete pRecord;

    return hRes;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::BuildRecord()
{
    HRESULT hRes = S_OK;
    
    CDocObjectHost* pdoh    = NULL; 
    TCHAR         * pszUrl  = NULL;    

    if (_pszRedirectedURL) 
    {
        hRes = AddToPrivacyQueue(&_pszRedirectedURL, &_pszPolicyRefURL, &_pszP3PHeader, _dwPrivacyFlags);
        goto cleanup;
    }

    pdoh = IToClass(CDocObjectHost, _bsc, this);

    // Get the current URL to add 
    pszUrl = new TCHAR[MAX_URL_STRING];
    if (!pszUrl)
    {
        hRes = E_OUTOFMEMORY;
        goto cleanup;
    }
    
    pszUrl[0] = TEXT('\0');

    if (pdoh->_pidl)
    {
        hRes = IEGetDisplayName(pdoh->_pidl, pszUrl, SHGDN_FORPARSING);
    }
    else
    {
        LPOLESTR pwUrl = NULL;
        hRes = pdoh->_GetCurrentPageW(&pwUrl, TRUE);
        if (SUCCEEDED(hRes))
        {        
            StrCpyN(pszUrl, pwUrl, MAX_URL_STRING);
            OleFree(pwUrl);
        }
    }

    hRes = AddToPrivacyQueue(&pszUrl, &_pszPolicyRefURL, &_pszP3PHeader, _dwPrivacyFlags);
    
cleanup:
    
    if (!SUCCEEDED(hRes)) 
    {
        delete [] pszUrl;
    }

    return hRes;
}

void CDocObjectHost::CDOHBindStatusCallback::_Redirect(LPCWSTR pwzNew)
{
    LPITEMIDLIST pidlNew;
    WCHAR wszPath[MAX_URL_STRING] = TEXT("");
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    LPOLESTR pwszCurrent = NULL;
    BOOL fAllow = FALSE;

    if (SUCCEEDED(IECreateFromPath(pwzNew, &pidlNew))) {
        TraceMsg(TF_SHDNAVIGATE, "CDOH::CBSC::_Redirect calling NotifyRedirect(%s)", pwzNew);

        if ( pdoh->_pwb )
        {
            pdoh->_pwb->NotifyRedirect(pdoh->_psv, pidlNew, NULL);
        }

        // Important - Do this before we destroy the old redirect url
        BuildRecord();
        ResetPrivacyInfo();

        // Save te redirected URL
        if (_pszRedirectedURL)
           LocalFree( _pszRedirectedURL );
        _pszRedirectedURL = StrDup(pwzNew);

        // We need to account for a bookmark that might appear
        // in the redirected URL.
        if(IEILGetFragment(pidlNew, wszPath, SIZECHARS(wszPath))) {
            LocalFree((LPVOID) pdoh->_pszLocation);
            pdoh->_pszLocation = StrDup(wszPath);
        }

        ILFree(pidlNew);
    }

    AddUrlToUrlHistoryStg(pwzNew, NULL, pdoh->_psb, FALSE,
                                NULL, NULL, NULL);

    // Security:  Release the pre-created object and start over for
    // server-side redirects.  The only security check for the
    // document reference occurs when someone tries to obtain it.
    // Therefore, we want to orphan the reference if x-domain, so the
    // client will need to obtain a new reference to the redirected
    // document.
    if (SUCCEEDED(pdoh->_GetCurrentPageW(&pwszCurrent, TRUE)))
    {
        fAllow = AccessAllowed(pdoh->_psp, pwszCurrent, pwzNew);
        OleFree(pwszCurrent);
    }

    if (!fAllow)
        pdoh->_ReleasePendingObject(FALSE);
}


//
// In this function, we get the codepage for the current URL. If that's not
// CP_ACP, we pass it to Trident via IBindCtx*.
//
void CDocObjectHost::CDOHBindStatusCallback::_CheckForCodePageAndShortcut(void)
{
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    LPWSTR pwszURL;
    HRESULT hres = pdoh->_GetCurrentPageW(&pwszURL, TRUE);

    

    if (SUCCEEDED(hres)) {
        UINT codepage = CP_ACP;
        IOleCommandTarget *pcmdt;
        VARIANT varShortCutPath = {0};
        BOOL fHasShortcut = FALSE;
        hres = pdoh->QueryService(SID_SHlinkFrame, IID_IOleCommandTarget, (void **)&pcmdt);
        if(S_OK == hres) 
        {
           ASSERT(pcmdt);
           hres = pcmdt->Exec(&CGID_Explorer, SBCMDID_GETSHORTCUTPATH, 0, NULL, &varShortCutPath);

           //
           // App Compat:  Imagineer Technical returns S_OK for the above Exec
           // but of course doesn't set the output parameter.
           //
           if((S_OK) == hres && VT_BSTR == varShortCutPath.vt && varShortCutPath.bstrVal)
           {
               fHasShortcut = TRUE;
           }
           pcmdt->Release();
        }
        if(UrlHitsNetW(pwszURL))
        {
            // Don't do this for File: files - we can live
            // with getting the code page late for file: even
            // if it slows down file: display somewhat if the
            // trident parser needs to restarted
            AddUrlToUrlHistoryStg(pwszURL, NULL, pdoh->_psb, FALSE,
                                NULL, NULL, &codepage);
        }
        TraceMsg(DM_DOCCP, "CDOH::CBSC::_CheckForCodePageAndShortcut codepage=%d", codepage);

        if ((codepage != CP_ACP || fHasShortcut) && _pbc) {
            // Here is where we pass the codepage to Trident.
            // (Mars): Clients may have already registered HtmlLoadOptions with
            // the bind context in order to specify the shortcut path.  In this case,
            // registering it again to set the codepage would fail.  However, we should
            // first verify that this codepage stuff actually gets used.
            IHtmlLoadOptions *phlo;
            HRESULT hres = CoCreateInstance(CLSID_HTMLLoadOptions,
                NULL, CLSCTX_INPROC_SERVER,
                IID_IHtmlLoadOptions, (void**)&phlo);

            if (SUCCEEDED(hres) && phlo)
            {
                if(codepage != CP_ACP)
                {
                    hres = phlo->SetOption(HTMLLOADOPTION_CODEPAGE, &codepage, sizeof(codepage));
                }
                if (SUCCEEDED(hres))
                {
                    if(fHasShortcut)
                    {
                        // deliberately ignore failures here
                        phlo->SetOption(HTMLLOADOPTION_INETSHORTCUTPATH, varShortCutPath.bstrVal, 
                                                (lstrlenW(varShortCutPath.bstrVal) + 1)*sizeof(WCHAR));
                    }
                    _pbc->RegisterObjectParam(L"__HTMLLOADOPTIONS", phlo);
                }
                phlo->Release();
            } else {
                TraceMsg(DM_WARNING, "DOH::_CheckForCodePagecut CoCreateInst failed (%x)", hres);
            }
        }
        VariantClear(&varShortCutPath);
        OleFree(pwszURL);
    }
}

#ifdef BETA1_DIALMON_HACK
extern void IndicateWinsockActivity();
#endif // BETA1_DIALMON_HACK


HRESULT CDocObjectHost::CDOHBindStatusCallback::OnProgress(
     ULONG ulProgress,
     ULONG ulProgressMax,
     ULONG ulStatusCode,
     LPCWSTR pwzStatusText)
{
    HRESULT hr = S_OK;
    HRESULT hrPrivacy = S_OK;
    
    TCHAR         * pszPrivacyURL = NULL;
    static TCHAR  * pszNULL       = NULL;
    
    
    TraceMsg(TF_SHDPROGRESS, "DOH::BSC::OnProgress (%d of %d) ulStatus=%x",
             ulProgress, ulProgressMax, ulStatusCode);

    // JEFFWE 4/15/96 Beta 1 Hack - every once in a while, send message
    // to the hidden window that detects inactivity so that it doesn't
    // think we are inactive during a long download

#ifdef BETA1_DIALMON_HACK
        IndicateWinsockActivity();
#endif


    CDocObjectHost * pdoh = IToClass(CDocObjectHost, _bsc, this);


#ifdef DEBUG
    if (pwzStatusText)
    {
        char szStatusText[MAX_PATH];    // OK with MAX_PATH
        UnicodeToAnsi(pwzStatusText, szStatusText, ARRAYSIZE(szStatusText));
        TraceMsg(TF_SHDPROGRESS, "DOH::BSC::OnProgress pszStatus=%s", szStatusText);
    }
#endif

    if (pdoh->_psb)
    {
        // we may be switching between multiple proxy/server hosts, so don't prevent
        //  showing them when they change
        if (_bindst != ulStatusCode ||
            ulStatusCode == BINDSTATUS_FINDINGRESOURCE)
        {
            UINT idRes = IDI_STATE_NORMAL;
            _bindst = ulStatusCode;

            if (_bindst < ARRAYSIZE(c_aidRes)) 
                idRes = c_aidRes[_bindst];

            pdoh->_psb->SendControlMsg(FCW_STATUS, SB_SETICON, STATUS_PANE_NAVIGATION, 
                                        (LPARAM)g_ahiconState[idRes-IDI_STATE_FIRST], NULL);

            TCHAR szStatusText[MAX_PATH];        // OK with MAX_PATH

            if (pwzStatusText)
            {
                StrCpyN(szStatusText, pwzStatusText, ARRAYSIZE(szStatusText));
            }
            else
            {
                szStatusText[0] = TEXT('\0');
            }

            //
            // This if-block will open the safe open dialog for OLE Object
            // and DocObject.
            //
            if (_bindst == BINDSTATUS_CLASSIDAVAILABLE)
            {
                TraceMsg(TF_SHDPROGRESS, "DOH::BSC::OnProgress got CLSID=%ws", szStatusText);
                CLSID clsid;

                // WORK-AROUND: CLSIDFromString does not take LPCOLESTR correctly.
                HRESULT hresT = CLSIDFromString((LPOLESTR)pwzStatusText, &clsid);

                if (SUCCEEDED(hresT))
                {
#ifdef DEBUG
                    if (IsEqualGUID(clsid, CLSID_NULL))
                    {
                        TraceMsg(DM_WARNING, "DOH::SBC::OnProgress Got CLSID_NULL");
                    }
#endif
                    //
                    //  Notice that we don't want to use BROWSERFLAG_MSHTML,
                    // which includes other types of MSHMTL CLSIDs.
                    // In this case, we just want to deal with HTMLDocument.
                    // (We allow XMLViewer docobj and *.MHT and *.MHTML too!)
                    BOOL fIsHTML = (IsEqualGUID(clsid, CLSID_HTMLDocument) || 
                                    IsEqualGUID(clsid, CLSID_XMLViewerDocObj) ||
                                    IsEqualGUID(clsid, CLSID_MHTMLDocument));
                    BOOL fAbortDesktopComponent = FALSE;

                    if(!fIsHTML)
                    {
                        //Check if we are a desktop component.
                        if (_IsDesktopItem(pdoh))
                        {
                            //Because this is NOT html, then don't show it!
                            fAbortDesktopComponent = TRUE;
                        }
                    }

                    if (fAbortDesktopComponent)
                    {
                        AbortBinding();
                        hr = E_ABORT;
                    }
                    else
                    {
                        _fBoundToMSHTML = fIsHTML; // Remember this and suppress redundant
                                               // AddUrl to history

                        //  There is an interval of time between OnProgress and OnObjectAvailable
                        //  in which the om might be required.
                        if (fIsHTML && pdoh->_punkPending == NULL)
                        {
                            pdoh->_CreatePendingDocObject(FALSE);
                        }
                        if (pdoh->_punkPending)
                        {
                            IPersist *pip;

                            hresT = pdoh->_punkPending->QueryInterface(IID_IPersist, (LPVOID *) &pip);
                            if (SUCCEEDED(hresT))
                            {
                                CLSID clsidPending;

                                hresT = pip->GetClassID(&clsidPending);
                                if (SUCCEEDED(hresT) && IsEqualGUID(clsid, clsidPending))
                                {
                                    _pbc->RegisterObjectParam(L"__PrecreatedObject", pdoh->_punkPending);
                                }
                                pip->Release();
                            }
                        }

                        hresT = pdoh->_MayHaveVirus(clsid);

                        if (hresT == HRESULT_FROM_WIN32(ERROR_CANCELLED))
                        {
                            hr = E_ABORT;
                            AbortBinding();

                            if (pdoh->_pmsoctBrowser && pdoh->_fWindowOpen)
                            {
                                pdoh->_pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_CANCELANDCLOSE, 0, NULL, NULL);
                            }
                        }

                    }
                }
                else
                {
                    TraceMsg(DM_ERROR, "DOH::BSC::OnProgress CLSIDFromString failed %x", hresT);
                }

                //
                //  Notice that URLMON will call IPersistMoniker::Load right
                // after we return from this notification. Therefore, this
                // is the latest moment we have a chance to pass the code
                // page to Trident.
                //              
                _CheckForCodePageAndShortcut();
            }
            else if (_bindst == BINDSTATUS_CACHEFILENAMEAVAILABLE)
            {
                TraceMsg(DM_SELFASC, "DOH::OnProgress got BINDSTATUS_CACHEFILENAMEAVAILABLE");
                _fSelfAssociated = IsAssociatedWithIE(pwzStatusText);

                if(_pszCacheFileName)
                     LocalFree(_pszCacheFileName);
                _pszCacheFileName = StrDup(pwzStatusText);
            }
            else if (_bindst == BINDSTATUS_CONTENTDISPOSITIONATTACH)
            {
                TCHAR szURL[MAX_URL_STRING];
                TCHAR * pszURL = szURL;
                HRESULT hresT;
        
                hresT = pdoh->_GetCurrentPage(szURL, ARRAYSIZE(szURL), TRUE);

                if (SUCCEEDED(hresT)) 
                {
                    UINT uRet;

                    if (_pszRedirectedURL && lstrlen(_pszRedirectedURL))
                    {
                        pszURL = _pszRedirectedURL;
                    }

                    IUnknown * punk;

                    hresT = pdoh->QueryInterface(IID_IUnknown, (void**)&punk);

                    if (SUCCEEDED(hresT))
                    {
                        uRet = OpenSafeOpenDialog(pdoh->_hwnd, DLG_SAFEOPEN, NULL, pszURL, NULL, szStatusText, NULL, pdoh->_uiCP, punk);
            
                        switch(uRet) 
                        {
                            case IDOK:
                                //
                                // Set this flag to avoid poppping this dialog box twice.
                                // 
                                pdoh->_fConfirmed = TRUE;
                                break;  // continue download

                            case IDD_SAVEAS:
                                CDownLoad_OpenUI(pdoh->_pmkCur, _pbc, FALSE, TRUE, NULL, NULL, NULL, NULL, NULL, _pszRedirectedURL, pdoh->_uiCP, punk);
                                ATOMICRELEASE(_pbc);
                                ATOMICRELEASE(_psvPrev);
                                // fall thru to AbortBinding

                            case IDCANCEL:
                                pdoh->_CancelPendingNavigation(FALSE);
                                AbortBinding();
                                if (uRet == IDCANCEL)
                                {
                                    _fAborted = TRUE;
                                }
                                break;
                        }

                        punk->Release();
                    }
                }
            }
            
            if (  ( _bindst >= BINDSTATUS_FINDINGRESOURCE
                 && _bindst <= BINDSTATUS_SENDINGREQUEST)
                 || _bindst == BINDSTATUS_PROXYDETECTING)
            {
                TCHAR szTemplate[MAX_PATH];              // OK with MAX_PATH
                UINT idResource = IDS_BINDSTATUS+_bindst;

                if ( _bindst == BINDSTATUS_PROXYDETECTING )
                {
                    idResource = IDS_BINDSTATUS_PROXYDETECTING;
                }

                // If we are connecting over proxy, don't say "web site found".
                //
                if (fOnProxy() && idResource == IDS_BINDSTATUS_SEND)
                {
                    idResource = IDS_BINDSTATUS_CON;

                    TCHAR szUrl[MAX_URL_STRING];

                    pdoh->_GetCurrentPage(szUrl, SIZECHARS(szUrl));
                    DWORD cchStatusText = SIZECHARS(szStatusText);

                    UrlGetPart(szUrl, szStatusText, &cchStatusText, URL_PART_HOSTNAME, 0);
                }

                if (MLLoadString(idResource, szTemplate, ARRAYSIZE(szTemplate)))
                {
                    BSCMSGS("OnProgress szTemplate=", szTemplate);

                    TCHAR szMessage[MAX_PATH];          // OK with MAX_PATH
                    BOOL fSuccess = wnsprintf(szMessage, ARRAYSIZE(szMessage), szTemplate, szStatusText);

                    if (fSuccess)
                    {
                        
                        BSCMSGS("OnProgress szMessage=", szMessage);
                        pdoh->_SetStatusText(szMessage);
                    }
                }
            }
        }

        DWORD dwState = 0;

        switch (ulStatusCode)
        {
        case BINDSTATUS_REDIRECTING:
            // they're redirecting.  treat this as a rename.
            _Redirect(pwzStatusText);
            break;
        
        case BINDSTATUS_FINDINGRESOURCE:
            dwState = PROGRESS_FINDING;
            ASSERT(!ulProgressMax);
            break;

        case BINDSTATUS_SENDINGREQUEST:
            dwState = PROGRESS_SENDING;
            ASSERT(!ulProgressMax);
            break;

        //Handle privacy notifications
        case BINDSTATUS_COOKIE_SENT:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_COOKIE_SENT"), 0 ,0);
            if (pwzStatusText && *pwzStatusText)
            {
                pszPrivacyURL = new TCHAR[MAX_URL_STRING];
                if (!pszPrivacyURL)
                    break;
                StrCpyN(pszPrivacyURL, pwzStatusText, MAX_URL_STRING);
                hrPrivacy = AddToPrivacyQueue(&pszPrivacyURL, &pszNULL, &pszNULL, COOKIEACTION_READ);
                if (!SUCCEEDED(hrPrivacy))
                    delete [] pszPrivacyURL;
            }
            else
            {
                _dwPrivacyFlags |= COOKIEACTION_READ;
            }
            break;
        case BINDSTATUS_COOKIE_SUPPRESSED:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_COOKIE_SUPPRESSED"), 0, 0);
            if (pwzStatusText && *pwzStatusText)
            {
                pszPrivacyURL = new TCHAR[MAX_URL_STRING];
                if (!pszPrivacyURL)
                    break;
                StrCpyN(pszPrivacyURL, pwzStatusText, MAX_URL_STRING);
                hrPrivacy = AddToPrivacyQueue(&pszPrivacyURL, &pszNULL, &pszNULL, COOKIEACTION_SUPPRESS);
                if (!SUCCEEDED(hrPrivacy))
                    delete [] pszPrivacyURL;
            }
            else
            {
                _dwPrivacyFlags |= COOKIEACTION_SUPPRESS;
            }            
            break;

        case BINDSTATUS_COOKIE_STATE_UNKNOWN:
            BSCMSG(TEXT("Shdocvw should never BINDSTATUS_COOKIE_STATE_UNKNOWN from Wininet/Urlmon"), 0, 0);
            break;
        case BINDSTATUS_COOKIE_STATE_ACCEPT:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_COOKIE_STATE_ACCEPT"), 0, 0);
            if (pwzStatusText && *pwzStatusText)
            {
                pszPrivacyURL = new TCHAR[MAX_URL_STRING];
                if (!pszPrivacyURL)
                    break;
                StrCpyN(pszPrivacyURL, pwzStatusText, MAX_URL_STRING);
                hrPrivacy = AddToPrivacyQueue(&pszPrivacyURL, &pszNULL, &pszNULL, COOKIEACTION_ACCEPT);
                if (!SUCCEEDED(hrPrivacy))
                    delete [] pszPrivacyURL;
            }
            else
            {
                _dwPrivacyFlags |= COOKIEACTION_ACCEPT;
            }
            break;
        case BINDSTATUS_COOKIE_STATE_REJECT:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_COOKIE_STATE_REJECT"), 0, 0);
            if (pwzStatusText && *pwzStatusText)
            {
                pszPrivacyURL = new TCHAR[MAX_URL_STRING];
                if (!pszPrivacyURL)
                    break;
                StrCpyN(pszPrivacyURL, pwzStatusText, MAX_URL_STRING);
                hrPrivacy = AddToPrivacyQueue(&pszPrivacyURL, &pszNULL, &pszNULL, COOKIEACTION_REJECT);
                if (!SUCCEEDED(hrPrivacy))
                    delete [] pszPrivacyURL;
            }
            else
            {
                _dwPrivacyFlags |= COOKIEACTION_REJECT;
            }
            break;
        case BINDSTATUS_COOKIE_STATE_PROMPT:
            BSCMSG(TEXT("Shdocvw should never BINDSTATUS_COOKIE_STATE_PROMPT from Wininet/Urlmon"), 0, 0);
            break;
        case BINDSTATUS_COOKIE_STATE_LEASH:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_COOKIE_STATE_LEASH"), 0, 0);            
            if (pwzStatusText && *pwzStatusText)
            {
                pszPrivacyURL = new TCHAR[MAX_URL_STRING];
                if (!pszPrivacyURL)
                    break;
                StrCpyN(pszPrivacyURL, pwzStatusText, MAX_URL_STRING);
                hrPrivacy = AddToPrivacyQueue(&pszPrivacyURL, &pszNULL, &pszNULL, COOKIEACTION_LEASH);
                if (!SUCCEEDED(hrPrivacy))
                    delete [] pszPrivacyURL;
            }
            else
            {
                _dwPrivacyFlags |= COOKIEACTION_LEASH;
            }
            break;
        case BINDSTATUS_COOKIE_STATE_DOWNGRADE:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_COOKIE_STATE_DOWNGRADE"), 0, 0);
            if (pwzStatusText && *pwzStatusText)
            {
                pszPrivacyURL = new TCHAR[MAX_URL_STRING];
                if (!pszPrivacyURL)
                    break;
                StrCpyN(pszPrivacyURL, pwzStatusText, MAX_URL_STRING);
                hrPrivacy = AddToPrivacyQueue(&pszPrivacyURL, &pszNULL, &pszNULL, COOKIEACTION_DOWNGRADE);
                if (!SUCCEEDED(hrPrivacy))
                    delete [] pszPrivacyURL;
            }
            else
            {
                _dwPrivacyFlags |= COOKIEACTION_DOWNGRADE;
            }
            break;
            
        case BINDSTATUS_COMPACT_POLICY_RECEIVED:
            _dwPrivacyFlags |= PRIVACY_URLHASCOMPACTPOLICY;
            break;            

        case BINDSTATUS_POLICY_HREF:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_POLICY_HREF"), 0, 0);
            ASSERT(pwzStatusText && *pwzStatusText);
            // We are getting two notifications from urlmon, once that is fixed, need to uncomment this assert
            //ASSERT(!_pszPolicyRefURL);
            if (_pszPolicyRefURL)
            {
                LocalFree(_pszPolicyRefURL);
            }
            _pszPolicyRefURL = StrDup(pwzStatusText);
            _dwPrivacyFlags |= PRIVACY_URLHASPOLICYREFHEADER;
            break;

        case BINDSTATUS_P3P_HEADER:
            BSCMSG(TEXT("OnProgress - Received BINDSTATUS_P3P_HEADER"), 0, 0);
            ASSERT(pwzStatusText && *pwzStatusText);
            // We are getting two notifications from urlmon, once that is fixed, need to uncomment this assert
            //ASSERT(!_pszP3PHeader);
            if (_pszP3PHeader)
            {
                LocalFree(_pszP3PHeader);
            }
            _pszP3PHeader = StrDup(pwzStatusText);
            _dwPrivacyFlags |= PRIVACY_URLHASP3PHEADER;
            break;
        }

        if (dwState)
        {
            pdoh->_OnSetProgressPos(ulProgress, dwState);
        }

        if (BINDSTATUS_BEGINDOWNLOADDATA == ulStatusCode)
        {
            _cbContentLength = ulProgress;
        }
        else if (BINDSTATUS_MIMETYPEAVAILABLE == ulStatusCode)
        {
            // delegate to media bar if this is a media mime-type
            if (    pwzStatusText
                &&  (   !StrCmpNIW(pwzStatusText, _T("audio"), 5)
                     || !StrCmpNIW(pwzStatusText, _T("video"), 5)))
            {
                if (pdoh->_DelegateToMediaBar(NULL, pwzStatusText))
                {
                    // Cancel the navigation
                    pdoh->_CancelPendingNavigation(FALSE);
                    AbortBinding();
                    _fAborted = TRUE;

                    if (pdoh->_pwb)
                    {
                        pdoh->_pwb->SetNavigateState(BNS_NORMAL);
                    }
                }
            }
        }
    }

#ifndef NO_DELEGATION
    if (_pbscChained)
    {
        _pbscChained->OnProgress(ulProgress, ulProgressMax, ulStatusCode, pwzStatusText);
    }
#endif
    return hr;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnDataAvailable(
            /* [in] */ DWORD grfBSC,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed)
{
    BSCMSG(TEXT("OnDataAvailable (grf,pstg)"), grfBSC, pstgmed);

#ifndef NO_DELEGATION
    if (_pbscChained)
    {
        _pbscChained->OnDataAvailable(grfBSC, dwSize, pformatetc, pstgmed);
    }
#endif
    return S_OK;
}

void CDocObjectHost::CDOHBindStatusCallback::_UpdateSSLIcon(void)
{
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    ASSERT(_pib);
    //
    //  if we have already been set by our object, we dont 
    //  want to override it.
    if (_pib  && !pdoh->_fSetSecureLock) 
    {
        pdoh->_eSecureLock = SECURELOCK_SET_UNSECURE;

        IWinInetInfo* pwinet;
        HRESULT hresT = _pib->QueryInterface(IID_IWinInetInfo, (LPVOID*)&pwinet);

        if (SUCCEEDED(hresT))
        {
            DWORD dwOptions = 0;
            DWORD cbSize = SIZEOF(dwOptions);
            
            hresT = pwinet->QueryOption(INTERNET_OPTION_SECURITY_FLAGS,
                                (LPVOID)&dwOptions, &cbSize);

            TraceMsg(DM_SSL, "pwinet->QueryOptions hres=%x dwOptions=%x", hresT, dwOptions);

            if (SUCCEEDED(hresT))
            {
                LPWSTR pwzUrl;

                pdoh->_fSetSecureLock = TRUE;

                if(dwOptions & SECURITY_FLAG_SECURE)
                {
                    pdoh->_dwSecurityStatus = dwOptions;

                    if (pdoh->_dwSecurityStatus & SECURITY_FLAG_40BIT)
                    {
                        pdoh->_eSecureLock = SECURELOCK_SET_SECURE40BIT;
                    }
                    else if (pdoh->_dwSecurityStatus & SECURITY_FLAG_128BIT)
                    {
                        pdoh->_eSecureLock = SECURELOCK_SET_SECURE128BIT;
                    }
                    else if (pdoh->_dwSecurityStatus & SECURITY_FLAG_FORTEZZA)
                    {
                        pdoh->_eSecureLock = SECURELOCK_SET_FORTEZZA;
                    }
                    else if (pdoh->_dwSecurityStatus & SECURITY_FLAG_56BIT)
                    {
                        pdoh->_eSecureLock = SECURELOCK_SET_SECURE56BIT;
                    }
                }
                else if (SUCCEEDED(_GetRequestFlagFromPIB(_pib, &dwOptions)) && 
                    (dwOptions & INTERNET_REQFLAG_FROM_CACHE) && 
                    SUCCEEDED(pdoh->_GetCurrentPageW(&pwzUrl, TRUE)))
                {
                    // 
                    //  when secure pages are cached, they lose their
                    //  security context, but should still be displayed
                    //  as secure.  therefore we use the UnknownBit level
                    //  of security.
                    //
                    if(URL_SCHEME_HTTPS == GetUrlSchemeW(pwzUrl))
                        pdoh->_eSecureLock = SECURELOCK_SET_SECUREUNKNOWNBIT;

                    OleFree(pwzUrl);
                }
            }
            else 
            {
                pdoh->_dwSecurityStatus = 0;
            }

            //  we will update the browser when we are activated

            pwinet->Release();
        }
        else
        {
            TraceMsg(DM_SSL, "QI to IWinInetInfo failed");
        }

        TraceMsg(DM_SSL, "[%X] UpdateSslIcon() setting _eSecureLock = %d", pdoh, pdoh->_eSecureLock);
    }
    else
    {
        TraceMsg(DM_SSL, "[%X] UpdateSslIcon() already set _eSecureLock = %d", pdoh, pdoh->_eSecureLock);
    }
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnObjectAvailable(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk)
{
    BSCMSG(TEXT("OnObjectAvailable (riid,punk)"), riid, punk);

    CDocObjectHost * pdoh = IToClass(CDocObjectHost, _bsc, this);

#ifdef DEBUG
    extern DWORD g_dwPerf;
    PERFMSG(TEXT("OnObjectAvailable called"), GetCurrentTime()-g_dwPerf);
    g_dwPerf = GetCurrentTime();
#endif

    //  If we get this far, DocObject has been inited by UrlMon or
    //  in process of retrieving pending object via IOleCommandTarget::Exec()
    if (pdoh->_punkPending)
    {
        pdoh->_fPendingNeedsInit = 0;
    }

    //
    //  When this notification is called first time, we should ask
    // the browser to activate us (which causes BindToObject).
    //
    if (pdoh->_pole==NULL && punk)
    {
        HRESULT hresT = punk->QueryInterface(IID_IOleObject, (LPVOID*)&(pdoh->_pole));

        if (SUCCEEDED(hresT))
        {
            IOleDocument * pmsod = NULL;

            pdoh->_OnBound(S_OK);

            hresT = (pdoh->_fDontInPlaceNavigate() ? E_NOINTERFACE : punk->QueryInterface(IID_IOleDocument, (LPVOID*)&pmsod));

            if (SUCCEEDED(hresT))
            {
                pmsod->Release();       // We don't use it at this point.

                // Case 1: DocObject
                OPENMSG(TEXT("OnObjectAvailable ASYNC DocObject"));

                ASSERT(pdoh->_psb);

                if (pdoh->_pmsoctBrowser)
                {
                    VARIANT var = {0};
                    VARIANT varOut = {0};

                    // Tell the host that we know this is a document object. 
                    V_VT(&var) = VT_BOOL;
                    V_BOOL(&var) = VARIANT_TRUE;

                    pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD, 0, &var, &varOut);
                }

#ifdef FEATURE_PICS
                BOOL fSupportsPICS = FALSE;

                if (pdoh->_PicsProcBase._fbPicsWaitFlags)
                {
                    VARIANTARG v;
                    v.vt = VT_UNKNOWN;
                    v.byref = (LPVOID)(IOleCommandTarget *)&pdoh->_PicsProcBase;

                    hresT = IUnknown_Exec(pdoh->_pole, &CGID_ShellDocView, SHDVID_CANSUPPORTPICS, 0, &v, NULL);
                    if (hresT == S_OK)
                    {
                        BSCMSG(TEXT("OnObjectAvailable - obj supports PICS"), 0, 0);
                        fSupportsPICS = TRUE;
                    }
                    else
                    {
                        BSCMSG(TEXT("OnObjectAvailable - obj either doesn't support IOleCommandTarget or doesn't support PICS"), hresT, 0);
                    }
                }
#endif
                BSCMSG(TEXT("OnObjectAvailable calling pdoh->_Navigate"), 0, 0);

                pdoh->_SetUpTransitionCapability();
                
                _UpdateSSLIcon();
#ifdef FEATURE_PICS
                // If we can't get labels out of the document (or don't need
                // to, because we already got one from a bureau or HTTP header),
                // see if we can complete PICS checking now.
                //
                if (!fSupportsPICS)
                {
                    pdoh->_PicsProcBase._fbPicsWaitFlags &= ~(PICS_WAIT_FOR_INDOC | PICS_WAIT_FOR_END);   /* no indoc ratings */

                    if (!pdoh->_PicsProcBase._fbPicsWaitFlags)
                    {
                        TraceMsg(DM_PICS, "OnObjectAvailable calling _HandlePicsChecksComplete");
                        pdoh->_PicsProcBase._HandlePicsChecksComplete();
                    }
                }
#endif
            }
            else
            {
                // Case 2: OLE object

                OPENMSG(TEXT("OnDataAvailable ASYNC OLE Object"));
                pdoh->_ActivateOleObject();
                
                // We need to tell the browser not to add this one to the
                // browse history.
                // We also want to close the browser window if this is the first
                // download - that's why we pass TRUE - to treat it like a code
                // download
                //
                if (pdoh->_dwAppHack & BROWSERFLAG_DONTAUTOCLOSE)
                {
                    pdoh->_CancelPendingNavigation(FALSE);
                }
                else
                {
                    pdoh->_CancelPendingNavigation(TRUE, FALSE, FALSE, TRUE);
                }

                if (pdoh->_fDelegatedNavigation)
                {
                    VARIANT        varOut = {0};
                    IDocNavigate * pDocNavigate;

                    pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView,
                                               SHDVID_FIREFILEDOWNLOAD,
                                               0, NULL, &varOut);

                    HRESULT hr = E_FAIL;
                    
                    if ( pdoh->_pwb )
                    {
                        hr = pdoh->_pwb->QueryInterface(IID_PPV_ARG(IDocNavigate, &pDocNavigate));
                    }

                    if (S_OK == hr)
                    {
                        pDocNavigate->OnReadyStateChange(NULL, READYSTATE_COMPLETE);
                        pDocNavigate->Release();
                    }
                }

                //
                // If this is the very first page, we should draw the background.
                //
                pdoh->_fDrawBackground = TRUE;

                //If the following assert is hit, then that means that we are
                // going to invalidate the desktop window (which is not
                // intended here)
                //
                ASSERT(pdoh->_hwnd);
                InvalidateRect(pdoh->_hwnd, NULL, TRUE);
            }

        }
        else
        {
            _fBoundToNoOleObject = TRUE;
        }
    }


    // Add privacy info to Trident's list if possible
    if (_fBoundToMSHTML)
    {
        HRESULT               hRes             = E_FAIL;
        IServiceProvider    * pSP              = NULL;
        IPrivacyServices    * pPrivacyServices = NULL;
        DWORD                 dwTopLevelFlag   = 0;

        // QueryService the Trident for the IPrivacyServices interface
        hRes = pdoh->_pole->QueryInterface(IID_IServiceProvider, (void**)&pSP);
        if (SUCCEEDED(hRes) && pSP)
        {
            hRes = pSP->QueryService(IID_IPrivacyServices,IID_IPrivacyServices,(void**)&pPrivacyServices);
            pSP->Release();
        }
        
        if (pPrivacyServices)
        {
            if (pdoh->_psp && pdoh->_psb && IsTopFrameBrowser(pdoh->_psp, pdoh->_psb))
            {
                dwTopLevelFlag |= PRIVACY_URLISTOPLEVEL;
            }

            // Add dummy marker since Trident would have added its records during the BindToStorage call
            // initiated due to shdocvw's current bind only if we are top level
            if (dwTopLevelFlag)
                pPrivacyServices->AddPrivacyInfoToList( TEXT(""), NULL, NULL, 0, PRIVACY_URLISTOPLEVEL);

            // Add each item in the privacy queue (accumulated from redirections) to Trident's list
            CPrivacyRecord *pPrivacyRecord = _privacyQueue.Dequeue();
            
            if (pPrivacyRecord)
            {
                while (pPrivacyRecord)
                {
                    pPrivacyRecord->_dwPrivacyFlags |= dwTopLevelFlag;

                    pPrivacyServices->AddPrivacyInfoToList( pPrivacyRecord->_pszUrl, pPrivacyRecord->_pszPolicyRefUrl, pPrivacyRecord->_pszP3PHeader, 
                                                            0, pPrivacyRecord->_dwPrivacyFlags);
                    delete pPrivacyRecord;

                    // Add the dummy marker separating top level records if this is top level
                    if (dwTopLevelFlag)
                        pPrivacyServices->AddPrivacyInfoToList( TEXT(""), NULL, NULL, 0, PRIVACY_URLISTOPLEVEL);

                    pPrivacyRecord = _privacyQueue.Dequeue();
                }
                // Add the last one redirected url from the class itself since this was not added to the list
                _dwPrivacyFlags |= dwTopLevelFlag;
                pPrivacyServices->AddPrivacyInfoToList(_pszRedirectedURL, _pszPolicyRefURL, _pszP3PHeader, 0, _dwPrivacyFlags);
            }
            else
            {
                TCHAR szUrl[MAX_URL_STRING];
                szUrl[0] = TEXT('\0');
        
                // Get the url used for binding
                if (pdoh->_pidl)
                {
                    hRes = IEGetDisplayName(pdoh->_pidl, szUrl, SHGDN_FORPARSING);
                }
                else
                {
                    LPOLESTR pwUrl = NULL;
                    hRes = pdoh->_GetCurrentPageW(&pwUrl, TRUE);
                    if (SUCCEEDED(hRes))
                    {        
                        StrCpyN(szUrl, pwUrl, ARRAYSIZE(szUrl));
                        OleFree(pwUrl);
                    }
                }

                if (SUCCEEDED(hRes))
                {
                    _dwPrivacyFlags |= dwTopLevelFlag;
                    pPrivacyServices->AddPrivacyInfoToList(szUrl, _pszPolicyRefURL, _pszP3PHeader, 0, _dwPrivacyFlags);
                }
            }

            pPrivacyServices->Release();
        }
    }

#ifndef NO_DELEGATION
    if (_pbscChained)
    {
        _pbscChained->OnObjectAvailable(riid, punk);
    }
#endif
    return S_OK;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnLowResource(DWORD reserved)
{
    BSCMSG(TEXT("OnLowResource"), 0, 0);

#ifndef NO_DELEGATION
    if (_pbscChained) {
        _pbscChained->OnLowResource(reserved);
    }
#endif
    return S_OK;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
                DWORD dwReserved, LPWSTR __RPC_FAR * ppwzAdditionalHeaders)
{
    HRESULT hres;

#ifndef NO_DELEGATION
    if (_pnegotiateChained) {
        hres = _pnegotiateChained->BeginningTransaction(szURL, szHeaders, dwReserved, ppwzAdditionalHeaders);
    }
    else
    {
#endif
        //  Here we pass headers to URLMon

        hres=BuildAdditionalHeaders((LPCTSTR) _pszHeaders,(LPCWSTR *) ppwzAdditionalHeaders);

#ifndef NO_DELEGATION
    }
#endif
    return hres;
}


const WCHAR g_wszPicsLabel[] = L"\r\nPICS-Label:";

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders,
                            LPCWSTR szRequestHeaders,
                            LPWSTR *pszAdditionalRequestHeaders)
{
#ifndef NO_DELEGATION
    if (_pnegotiateChained) {
        _pnegotiateChained->OnResponse(dwResponseCode, szResponseHeaders, szRequestHeaders, pszAdditionalRequestHeaders);
    }
    else
    {
#endif

#ifndef NO_DELEGATION
    }
#endif

#ifdef FEATURE_PICS
    /* CODEWORK: For next release, all response headers should be handled
     * generically through _OnHttpEquiv, and rating labels should be
     * processed there instead of through a private IOleCommandTarget
     * interface with Trident.
     */

    /* NOTE: We still need to check for the PICS label header here, even
     * if we chained to Trident or whoever above.
     */

    // (jbeda) this _dwPicsLabelSource stuff looks really screwy...
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
    if (pdoh->_PicsProcBase._fbPicsWaitFlags & PICS_WAIT_FOR_INDOC) {
        LPCWSTR pwszPicsLabel = StrStrW(szResponseHeaders, g_wszPicsLabel);
        if (pwszPicsLabel != NULL) {
            pdoh->_PicsProcBase._dwPicsLabelSource=PICS_LABEL_FROM_HEADER;
            pwszPicsLabel += ARRAYSIZE(g_wszPicsLabel); /* skip \r\n and label name */
            LPCWSTR pwszPicsLabelEnd = StrChrW(pwszPicsLabel, L'\r');
            if (pwszPicsLabelEnd == NULL) {
                // NOTE: lstrlenW doesn't work on Win95, so we do this manuall