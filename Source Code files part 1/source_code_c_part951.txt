
	        dwBlockSize;
	LPVOID  pInfo = NULL;

	try
    {
        dwBlockSize = GetFileVersionInfoSize((LPTSTR) szFile, &dwTemp);
	    if (dwBlockSize)
        {
		    pInfo = (LPVOID) new BYTE[dwBlockSize + 4];
			memset( pInfo, NULL, dwBlockSize + 4);

		    if (pInfo)
            {
			    UINT len;
			    if (GetFileVersionInfo((LPTSTR) szFile, 0, dwBlockSize, pInfo))
                {	
				    WORD wLang = 0;
					WORD wCodePage = 0; 	
					if(!GetVersionLanguage(pInfo, &wLang, &wCodePage) )
					{
						// on failure: default to English

						// this returns a pointer to an array of WORDs
						WORD *pArray;
						if (VerQueryValue(pInfo, "\\VarFileInfo\\Translation",(void **)(&pArray), &len))
						{
							len = len / sizeof(WORD);

							// find the english one...
							for (int i = 0; i < len; i += 2)
							{
								if( pArray[i] == 0x0409 )	{
									wLang	  = pArray[i];
									wCodePage = pArray[i + 1];
									break;
								}
							}
						}
					}
					
					TCHAR   *pMfg, szTemp[256];
					wsprintf(szTemp, _T("\\StringFileInfo\\%04X%04X\\%s"), wLang, wCodePage, szVar);

					if( VerQueryValue(pInfo, szTemp, (void **)(&pMfg), &len))
                    {
                        strValue = pMfg;
						fRc = TRUE;
					}
			    }
		    }
	    }
    }
    catch(...)
    {
        // We don't need to do anything, just need to protect ourselves
        // from the flaky version.dll calls.
    }

	if (pInfo)
		delete pInfo;

	return fRc;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:		BOOL GetVersionLanguage(void *vpInfo,
									WORD *wpLang,
									WORD *wpCodePage);
 Description:	This function extracts the language and codepage out of a passed GetFileVersionInfo()
				result. Consideration is given to variation in the layout.    
 Arguments:		vpInfo, wpLang, wpCodePage
 Returns:		Boolean
 Inputs:
 Outputs:
 Caveats:
 Courtesy of:	SMS, Nick Dyer
 Raid:
 History:		a-peterc  30-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
BOOL GetVersionLanguage(void *vpInfo, WORD *wpLang, WORD *wpCodePage)
{
  WORD *wpTemp;
  WORD wLength;
  WCHAR *wcpTemp;
  char *cpTemp;
  BOOL bRet = FALSE;

  wpTemp = (WORD *) vpInfo;
  cpTemp = (char *) vpInfo;

  wpTemp++; // jump past buffer length.
  wLength = *wpTemp;  // capture value length.
  wpTemp++; // skip past value length to what should be type code in new format
  if (*wpTemp == 0 || *wpTemp == 1) // new format expect unicode strings.
  {
		cpTemp = cpTemp + 38 + wLength + 8;
		wcpTemp = (WCHAR *) cpTemp;
    if (wcscmp(L"StringFileInfo", wcpTemp) == 0) // OK! were aligned properly.
    {
			bRet = TRUE;

			cpTemp += 30; // skip over "StringFileInfo"
			while ((DWORD) cpTemp % 4 > 0) // 32 bit align
				cpTemp++;

			cpTemp += 6; // skip over length and type fields.

			wcpTemp = (WCHAR *) cpTemp;
			swscanf(wcpTemp, L"%4x%4x", wpLang, wpCodePage);
    }
  }
  else  // old format, expect single byte character strings.
  {
    cpTemp += 20 + wLength + 4;
    if (strcmp("StringFileInfo", cpTemp) == 0) // OK! were aligned properly.
    {
			bRet = TRUE;

			cpTemp += 20; // skip over length fields.
			sscanf(cpTemp, "%4x%4x", wpLang, wpCodePage);
    }
  }

	return (bRet);
}

///////////////////////////////////////////////////////////////////
BOOL GetManufacturerFromFileName(LPCTSTR szFile, CHString &strMfg)
{
    return GetVarFromVersionInfo(szFile, "CompanyName", strMfg);
}

BOOL GetVersionFromFileName(LPCTSTR szFile, CHString &strVersion)
{
    return GetVarFromVersionInfo(szFile, "ProductVersion", strVersion);
}

void ReplaceString(CHString &str, LPCTSTR szFind, LPCTSTR szReplace)
{
    int iWhere,
        nLen = lstrlen(szFind);

    while ((iWhere = str.Find(szFind)) != -1)
    {
        str.Format(
            "%s%s%s",
            (LPCTSTR) str.Left(iWhere),
            szReplace,
            (LPCTSTR) str.Mid(iWhere + nLen));
    }
}

BOOL GetServiceFileName(LPCTSTR szService, CHString &strFileName)
{
    SC_HANDLE   hSCManager,
                hService;
    TCHAR       szBuffer[2048];
    QUERY_SERVICE_CONFIG    
                *pConfig = (QUERY_SERVICE_CONFIG *) szBuffer; 
    DWORD       dwNeeded;
    BOOL        bRet = FALSE;

    hSCManager = 
        OpenSCManager(
            NULL,
            NULL,
            STANDARD_RIGHTS_REQUIRED);
    if (!hSCManager)
        return FALSE;

    hService = 
        OpenService(
        hSCManager,
        szService,
        SERVICE_QUERY_CONFIG);
    
    if (hService)
    {
        if (QueryServiceConfig(
            hService,
            pConfig,
            sizeof(szBuffer),
            &dwNeeded))
        {
            strFileName = pConfig->lpBinaryPathName;

            // Now fix up the path so that it has a drive letter.

            strFileName.MakeUpper();

            // If the filename is using \SYSTEMROOT\, replace it with %SystemRoot%.
            if (strFileName.Find("\\SYSTEMROOT\\") == 0)
                ReplaceString(strFileName, "\\SYSTEMROOT\\", "%SystemRoot%\\");
            // If the filename doesn't start with a replacement string, and if it
            // doesn't have a drive letter, assume it should start with
            // %SystemRoot%.
            else if (strFileName.GetLength() >= 2 && 
                strFileName[0] != '%' && strFileName[1] != ':')
            {
                CHString strTemp;

                strTemp.Format("%%SystemRoot%%\\%s", (LPCTSTR) strFileName);
                strFileName = strTemp;
            }

            TCHAR szOut[MAX_PATH * 2];

            ExpandEnvironmentStrings(strFileName, szOut, sizeof(szOut));
            strFileName = szOut;

            bRet = TRUE;
        }

        CloseServiceHandle(hService);
    }

    CloseServiceHandle(hSCManager);

    return bRet;
}

///////////////////////////////////////////////////////////////////
// Performs a case insensitive compare (such as is required for keys)
// on two variants and returns true if they are the same type and
// the same value, else false.  Note that arrays, VT_NULL, and 
// embedded objects will assert, and return false.
///////////////////////////////////////////////////////////////////
bool CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2) 
{
   
   if (v1->vt == v2->vt) {
      switch (v1->vt) {
      case VT_BOOL: return (v1->boolVal == v2->boolVal);
      case VT_UI1:  return (v1->bVal == v2->bVal);
      case VT_I2:   return (v1->iVal == v2->iVal);
      case VT_I4:   return (v1->lVal == v2->lVal);
      case VT_R4:   return (v1->fltVal == v2->fltVal);
      case VT_R8:   return (v1->dblVal == v2->dblVal);
      case VT_BSTR: return (0 == _wcsicmp(v1->bstrVal, v2->bstrVal));
      default:
         ASSERT_BREAK(0);
      }
   }
   return false;
}

// map standard API return values (defined WinError.h)
// to WBEMish hresults (defined in WbemCli.h)
HRESULT WinErrorToWBEMhResult(LONG error)
{
	HRESULT hr = WBEM_E_FAILED;
	
	switch (error)
	{
		case ERROR_SUCCESS:
			hr = WBEM_S_NO_ERROR;
			break;
		case ERROR_ACCESS_DENIED:
			hr = WBEM_E_ACCESS_DENIED;
			break;
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_OUTOFMEMORY:
			hr = WBEM_E_OUT_OF_MEMORY;
			break;
		case ERROR_ALREADY_EXISTS:
			hr = WBEM_E_ALREADY_EXISTS;
			break;
		case ERROR_BAD_NETPATH:
        case ERROR_INVALID_DATA:
        case ERROR_BAD_PATHNAME:
        case REGDB_E_INVALIDVALUE:
		case ERROR_PATH_NOT_FOUND:
		case ERROR_FILE_NOT_FOUND:
		case ERROR_BAD_USERNAME:
		case NERR_NetNameNotFound:
        case ERROR_NOT_READY:
        case ERROR_INVALID_NAME:
			hr = WBEM_E_NOT_FOUND;
			break;
		default:
			hr = WBEM_E_FAILED;
	}

	return hr;
}

void SetConfigMgrProperties(CConfigMgrDevice *pDevice, CInstance *pInstance)
{
	CHString	strDeviceID;
	DWORD		dwStatus,
				dwProblem;

	if (pDevice->GetDeviceID(strDeviceID))
		pInstance->SetCHString(IDS_PNPDeviceID, strDeviceID);
					
	if (pDevice->GetStatus(&dwStatus, &dwProblem))
		pInstance->SetDWORD("ConfigManagerErrorCode", dwProblem);

	pInstance->SetDWORD("ConfigManagerUserConfig", 
		pDevice->IsUsingForcedConfig());
}

BOOL EnablePrivilegeOnCurrentThread(LPCTSTR szPriv)
{
    BOOL                bRet = FALSE;
    HANDLE              hToken = NULL;
    TOKEN_PRIVILEGES    tkp;
    BOOL                bLookup = FALSE;
    DWORD               dwLastError = ERROR_SUCCESS;

    // Try to open the thread token.  If we fail, it's because no
    // impersonation is going on, so call ImpersonateSelf to get a token.
    // Then call OpenThreadToken again.
    if (OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | 
        TOKEN_QUERY, FALSE, &hToken) ||
        (ImpersonateSelf(SecurityImpersonation) &&
        OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | 
        TOKEN_QUERY, FALSE, &hToken)))
    {

        {
            CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
            bLookup = LookupPrivilegeValue(NULL, szPriv, &tkp.Privileges[0].Luid);
        }
        if (bLookup) 
        {
            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // Clear the last error.
            SetLastError(0);

            // Turn it on
            bRet = AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
                        (PTOKEN_PRIVILEGES) NULL, 0);
            dwLastError = GetLastError();
        }

        CloseHandle(hToken);
    }

    // We have to check GetLastError() because AdjustTokenPrivileges lies about
    // its success but GetLastError() doesn't.
    return bRet && dwLastError == ERROR_SUCCESS;
}

// Takes a pnp id and returns a bios unit number
// To avoid frequent load/unload of a library, the pGetWin9XBiosUnit parameter comes from:
//                     HINSTANCE hInst =  LoadLibrary("cim32net.dll");
//                     pGetWin9XBiosUnit = (fnGetWin9XBiosUnit)GetProcAddress(hInst, "GetWin9XBiosUnit");
BYTE GetBiosUnitNumberFromPNPID(fnGetWin9XBiosUnit pGetWin9XBiosUnit, CHString strDeviceID)
{
    CHString sTemp;
    DRIVE_MAP_INFO stDMI;
    CRegistry Reg1;

    BYTE btBiosUnit = -1;
    
    // Open the associated registry key
    if (Reg1.Open(HKEY_LOCAL_MACHINE, "enum\\" + strDeviceID, KEY_QUERY_VALUE) == ERROR_SUCCESS)
    {
    
        // Get a drive letter for this pnp id
        if ((Reg1.GetCurrentKeyValue("CurrentDriveLetterAssignment", sTemp) != ERROR_SUCCESS) ||
            (sTemp.GetLength() == 0)) {
            // No drive letters, let's try one more thing.  On memphis sp1, this call will also
            // get us a unit number.
            if (pGetWin9XBiosUnit != NULL)
            {
                btBiosUnit = pGetWin9XBiosUnit(strDeviceID.GetBuffer(0));
            }
        } 
        else 
        {
            if (GetDriveMapInfo(&stDMI, toupper(sTemp[0]) - 'A' + 1)) 
            {
                btBiosUnit = stDMI.btInt13Unit;
            }
        }
    }

    return btBiosUnit;
}

HRESULT GetHKUserNames(CHStringList &list)
{
	HRESULT hres;

	// Empty the list.
	list.clear();
	
	if (GetPlatformID() == VER_PLATFORM_WIN32_NT)
	{
		// Enum the profiles from the registry.
		CRegistry	regProfileList;
		CHString	strProfile;
		DWORD		dwErr;

		// Open the ProfileList key so we know which profiles to load up.
		if ((dwErr = regProfileList.OpenAndEnumerateSubKeys(
			HKEY_LOCAL_MACHINE, 
			IDS_RegNTProfileList, 
			KEY_READ)) == ERROR_SUCCESS)
		{
			for (int i = 0; regProfileList.GetCurrentSubKeyName(strProfile) == 
				ERROR_SUCCESS; i++)
			{
				list.push_back(strProfile);
				regProfileList.NextSubKey();
			}
		}

		// Add the .DEFAULT name.
		list.push_back(_T(".DEFAULT"));

		hres = WinErrorToWBEMhResult(dwErr);
	}
	else
	{
		DWORD	dwErr = ERROR_SUCCESS;
#ifdef _DEBUG
		DWORD	dwSize = 10,
#else
		DWORD	dwSize = 1024,
#endif
				dwBytesRead;
		TCHAR	*szBuff = NULL;

		// Keep looping until we read the entire section.
		// You know your buffer wasn't big enough if the returned number
		// of bytes == (size passed in - 2).
		do
		{
			if (szBuff)
			{
				free(szBuff);

				dwSize *= 2;
			}
			
			szBuff = (TCHAR *) malloc(dwSize);
				
			// Out of memory.  Get out of loop.
			if (!szBuff)
				break;
			
			dwBytesRead = 
				GetPrivateProfileString(
					"Password Lists",
					NULL, 
					"", 
					szBuff,
					dwSize, 
					"system.ini");

		} while (dwBytesRead >= dwSize - 2);

		if (szBuff)
		{
			// Loop through the list of names.  Each is null-terminated, and the
			// list is terminated with a double null.
			TCHAR *pszCurrent = szBuff;

			while (*pszCurrent)
			{
				list.push_back(pszCurrent);
				
				pszCurrent += lstrlen(pszCurrent) + 1;
			}
			
			hres = WBEM_S_NO_ERROR;

			// Free the buffer.
			free(szBuff);

			// Add the .DEFAULT name.
			list.push_back(_T(".DEFAULT"));
		}
		else
			// Failed to malloc, so set error code.
			hres = WBEM_E_OUT_OF_MEMORY;
	}

	return hres;
}


VOID EscapeBackslashes(CHString& chstrIn,
                     CHString& chstrOut)
{
    CHString chstrCpyNormPathname = chstrIn;
    LONG lNext = -1L;
    chstrOut.Empty();

    // Find the next '\'
    lNext = chstrCpyNormPathname.Find(_T('\\'));
    while(lNext != -1)
    {
        // Add on to the new string we are building:
        chstrOut += chstrCpyNormPathname.Left(lNext + 1);
        // Add on the second backslash:
        chstrOut += _T('\\');
        // Hack off from the input string the portion we just copied 
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
        lNext = chstrCpyNormPathname.Find(_T('\\'));
    }
    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrOut += chstrCpyNormPathname;
    }
}

VOID EscapeQuotes(CHString& chstrIn,
                  CHString& chstrOut)
{
    CHString chstrCpyNormPathname = chstrIn;
    LONG lNext = -1L;
    chstrOut.Empty();

    // Find the next '\'
    lNext = chstrCpyNormPathname.Find(_T('\"'));
    while(lNext != -1)
    {
        // Add on to the new string we are building:
        chstrOut += chstrCpyNormPathname.Left(lNext);
        // Escape the quote:
        chstrOut += _T("\\\"");
        // Hack off from the input string the portion we just copied 
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
        lNext = chstrCpyNormPathname.Find(_T('\"'));
    }
    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrOut += chstrCpyNormPathname;
    }
} 

VOID RemoveDoubleBackslashes(const CHString& chstrIn, CHString& chstrOut)
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;
    BOOL fDone = FALSE;
    LONG lPos = -1;
    while(!fDone)
    {
        lPos = chstrInCopy.Find(_T("\\\\"));
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += _T("\\");
            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }
    chstrOut = chstrBuildString;
}

CHString RemoveDoubleBackslashes(const CHString& chstrIn)
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;
    BOOL fDone = FALSE;
    LONG lPos = -1;
    while(!fDone)
    {
        lPos = chstrInCopy.Find(_T("\\\\"));
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += _T("\\");
            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }
    return chstrBuildString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_devicedriver.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_DeviceDriver.H

Abstract:
	WBEM provider class definition for PCH_DeviceDriver class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_DeviceDriver_H_
#define _PCH_DeviceDriver_H_

#define PROVIDER_NAME_PCH_DEVICEDRIVER "PCH_DeviceDriver"

// Property name externs -- defined in PCH_DeviceDriver.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pFilename ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pSize ;
extern const WCHAR* pVersion ;

class CPCH_DeviceDriver : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_DeviceDriver(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_DeviceDriver() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

    private:
        virtual HRESULT CreateDriverInstances(CHString chstrDriverName, CConfigMgrDevice *pDevice, MethodContext *pMethodContext);
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_drive.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Drive.H

Abstract:
	WBEM provider class definition for PCH_Drive class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Drive_H_
#define _PCH_Drive_H_

#define PROVIDER_NAME_PCH_DRIVE "PCH_Drive"

// Property name externs -- defined in PCH_Drive.cpp
//=================================================

extern const WCHAR* pAvailable ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDriveLetter ;
extern const WCHAR* pFilesystemType ;
extern const WCHAR* pFree ;
extern const WCHAR* pDescription;
extern const WCHAR* pMediaType;


class CPCH_Drive : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Drive(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Drive() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_bios.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_BIOS.CPP

Abstract:
	WBEM provider class implementation for PCH_BIOS class

Revision History:

	Ghim-Sim Chua       (gschua)   05/05/99
		- Created

    Kalyani Narlanka    (kalyanin)  05/12/99
        - Added Code to get all the properties of this class

    Kalyani Narlanka    (kalyanin)  05/18/99
        

********************************************************************/

#include "pchealth.h"
#include "PCH_BIOS.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_BIOS

CPCH_BIOS MyPCH_BIOSSet (PROVIDER_NAME_PCH_BIOS, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pBIOSDate    = L"BIOSDate" ;
const static WCHAR* pBIOSName    = L"BIOSName" ;
const static WCHAR* pBIOSVersion = L"BIOSVersion" ;
const static WCHAR* pCPU         = L"CPU" ;
const static WCHAR* pINFName     = L"INFName" ;
const static WCHAR* pMachineType = L"MachineType" ;
const static WCHAR* pDriver      = L"Driver" ;
const static WCHAR* pDriverDate  = L"DriverDate" ;
const static WCHAR* pChange      = L"Change";
const static WCHAR* pTimeStamp   = L"TimeStamp";

/*****************************************************************************
*
*  FUNCTION    :    CPCH_BIOS::EnumerateInstances
*
*  DESCRIPTION :    Returns the instance of this class
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  SYSNOPSIS    : There is only instance of this class at any time. This function gives this 
*                  instance.
*                       If there are no instances, returns WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/

HRESULT CPCH_BIOS::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{

    //  Begin Declarations
    //

    TraceFunctEnter("CPCH_BIOS::EnumerateInstances");

    HRESULT                         hRes                            = WBEM_S_NO_ERROR;
    HRESULT                         hRes1;
    HRESULT                         hRes2;

     //  Query String
    
    CComBSTR                        bstrBIOSQuery                   = L"Select Name, ReleaseDate, Version FROM win32_BIOS";
    CComBSTR                        bstrProcessorQuery              = L"Select DeviceId, Name FROM win32_processor";
    CComBSTR                        bstrComputerSystemQuery         = L"Select Name, Description FROM win32_computerSystem";
    CComBSTR                        bstrDriver;

    //  Registry Hive where BIOS Info is stored
    LPCTSTR                         lpctstrSystemHive               = _T("System\\CurrentControlSet\\Services\\Class\\System");
  
    //   Registry Names of interest
    LPCTSTR                         lpctstrDriverDesc               = _T("DriverDesc");
    LPCTSTR                         lpctstrINFName                  = _T("INFPath");
    LPCTSTR                         lpctstrDriverDate               = _T("DriverDate");
    LPCTSTR                         lpctstrSystem                   = _T("System\\");

    //  Property Names
    LPCWSTR                         lpctstrReleaseDate              = L"ReleaseDate";
    LPCWSTR                         lpctstrName                     = L"Name";
    LPCWSTR                         lpctstrVersion                  = L"Version";
    LPCWSTR                         lpctstrDescription              = L"Description";
    LPCTSTR                         lpctstrSystemBoard              = _T("System Board");

    //  Strings
    TCHAR                           tchSubSystemKeyName[MAX_PATH]; 
    TCHAR                           tchDriverDescValue[MAX_PATH];
    TCHAR                           tchDriverDateValue[MAX_PATH];
    TCHAR                           tchINFNameValue[MAX_PATH];


    // Instances
    CComPtr<IEnumWbemClassObject>   pBIOSEnumInst;
    CComPtr<IEnumWbemClassObject>   pProcessorEnumInst;
    CComPtr<IEnumWbemClassObject>   pComputerSystemEnumInst;

    //  Instances
    //  CInstancePtr                   pPCHBIOSInstance;

    //  Objects
    IWbemClassObjectPtr             pBIOSObj;                   // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr             pProcessorObj;              // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr             pComputerSystemObj;         // BUGBUG : WMI asserts if we use CComPtr

    //  Variants
    CComVariant                     varDriver;
    CComVariant                     varDriverDate;
    CComVariant                     varINFName;
    CComVariant                     varSnapshot                     = "SnapShot";

    //  Unsigned Longs....
    ULONG                           ulBIOSRetVal                    = 0;
    ULONG                           ulProcessorRetVal               = 0;
    ULONG                           ulComputerSystemRetVal          = 0;

    LONG                            lRegRetVal;

    //  SystemTime
    SYSTEMTIME                      stUTCTime;

    //  Registry Keys
    HKEY                            hkeySystem;
    HKEY                            hkeySubSystem;

    //  DWORDs
    DWORD                           dwIndex                         = 0;
    DWORD                           dwSize                          = MAX_PATH;
    DWORD                           dwType;

    //  Boolean
    BOOL                            fContinueEnum                   = FALSE;
    BOOL                            fCommit                         = FALSE;
    
    //  FileTime
    PFILETIME                       pFileTime                       = NULL;

    //  End Declarations                            
    

    //  Create a new instance of PCH_BIOS Class based on the passed-in MethodContext
    CInstancePtr pPCHBIOSInstance(CreateNewInstance(pMethodContext), false);

   
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              TIME STAMP                                                                 //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);

    hRes = pPCHBIOSInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
    if (FAILED(hRes))
    {
        //  Could not Set the Time Stamp
        //  Continue anyway
        ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CHANGE                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHBIOSInstance->SetVariant(pChange, varSnapshot);
    if (FAILED(hRes))
    {
        //  Could not Set the Change Property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set  Variant on Change Field failed.");
    }

    //  Execute the query to get Name, ReleaseDate, Version FROM Win32_BIOS
    //  Class.

    //  pBIOSEnumInst contains a pointer to the instance returned.

    hRes = ExecWQLQuery(&pBIOSEnumInst, bstrBIOSQuery );
    if (SUCCEEDED(hRes))
    {
        //  Query Succeeded!
        
        //  Get the instance Object.
        if((pBIOSEnumInst->Next(WBEM_INFINITE, 1, &pBIOSObj, &ulBIOSRetVal)) == WBEM_S_NO_ERROR)
        {

            //  Get Name, Date and Version
       
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              BIOSDATE                                                                   //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            
            CopyProperty(pBIOSObj, lpctstrReleaseDate, pPCHBIOSInstance, pBIOSDate);

            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              BIOSNAME                                                                   //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                
            hRes = CopyProperty(pBIOSObj, lpctstrName, pPCHBIOSInstance, pBIOSName);
            if(SUCCEEDED(hRes))
            {
                fCommit = TRUE;
            }

            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              BIOSVERSION                                                                //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

            CopyProperty(pBIOSObj, lpctstrVersion, pPCHBIOSInstance, pBIOSVersion);

        }

    }
    //  Done with Win32_BIOS Class

    //  Now query Win32_Processor Class to get  "CPU" property

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CPU                                                                    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    hRes = ExecWQLQuery(&pProcessorEnumInst, bstrProcessorQuery);
    if (SUCCEEDED(hRes))
    {
        //  Query Succeeded!
        
        //  Get the instance Object.
        if((pProcessorEnumInst->Next(WBEM_INFINITE, 1, &pProcessorObj, &ulProcessorRetVal)) == WBEM_S_NO_ERROR)
        {

            //  Get Name
       
            CopyProperty(pProcessorObj, lpctstrName, pPCHBIOSInstance, pCPU);

        }
    }


    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              MACHINETYPE                                                                    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    hRes = ExecWQLQuery(&pComputerSystemEnumInst, bstrComputerSystemQuery);
    if (SUCCEEDED(hRes))
    {
        //  Query Succeeded!
        
        //  Get the instance Object.
        if((pComputerSystemEnumInst->Next(WBEM_INFINITE, 1, &pComputerSystemObj, &ulComputerSystemRetVal)) == WBEM_S_NO_ERROR)
        {

            //  Get "Description"
       
            CopyProperty(pComputerSystemObj, lpctstrDescription, pPCHBIOSInstance, pMachineType);

                  

        }
    }
    
    //  Get the remaining properties i.e. INFName, Driver and DriverDate  from the Registry
    //  This is present in one of the keys under the HIVE "HKLM\System\CCS\Services\Class\System"
    //  Enumerate keys under this hive until the regname "DeviceDesc" equals "System Board"

    //  Once you hit "DeviceDesc" = "System Board"  get the INFpath, Driver
    //  DriverDate from there.
    
    lRegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrSystemHive, 0, KEY_READ, &hkeySystem);
    if(lRegRetVal == ERROR_SUCCESS)
	{
		// Opened the Registry key.
        // Enumerate the keys under this hive. One of the keys has 
        // DeviceDesc = "system Board".

        lRegRetVal = RegEnumKeyEx(hkeySystem, dwIndex,  tchSubSystemKeyName, &dwSize, NULL, NULL, NULL, pFileTime);
        if(lRegRetVal == ERROR_SUCCESS)
        {
            fContinueEnum = TRUE;
        }
        while(fContinueEnum)
        {

            //  Open the SubKey.
            lRegRetVal = RegOpenKeyEx(hkeySystem,  tchSubSystemKeyName, 0, KEY_READ, &hkeySubSystem);
            if(lRegRetVal == ERROR_SUCCESS)
            {
                //  Opened the SubKey
                //  Query for , regname "DriverDesc "
                dwSize = MAX_PATH;
                lRegRetVal = RegQueryValueEx(hkeySubSystem, lpctstrDriverDesc , NULL, &dwType, (LPBYTE)tchDriverDescValue, &dwSize);
                if(lRegRetVal == ERROR_SUCCESS)
                {
                    //  Compare if  the value is equal to "System Board"
                    if(_tcsicmp(tchDriverDescValue, lpctstrSystemBoard) == 0)
                    {
                        //  The following statements could 
                        try
                        {
                            // Found the Right DriverDesc 
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              DRIVER                                                                    //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            // Driver = system+lptstrSubSystemKeyName
                            bstrDriver = lpctstrSystem;
                            bstrDriver.Append(tchSubSystemKeyName);
                            varDriver = bstrDriver.Copy();
                            hRes2 = pPCHBIOSInstance->SetVariant(pDriver, varDriver);
                            if(FAILED(hRes2))
                            {
                                //  Could not Set the DRIVER Property
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "Set variant on Driver Failed.");
                            }


                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              DRIVERDATE                                                                 //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            // Query for DriverDate
                            dwSize = MAX_PATH;
                            lRegRetVal = RegQueryValueEx(hkeySubSystem, lpctstrDriverDate, NULL, &dwType, (LPBYTE)tchDriverDescValue, &dwSize);
                            if(lRegRetVal == ERROR_SUCCESS)
                            {
                                //  Set the DriverDate
                                varDriverDate = tchDriverDescValue;
                                hRes2 = pPCHBIOSInstance->SetVariant(pDriverDate, varDriverDate);
                                if(FAILED(hRes2))
                                {
                                    //  Could not Set the DRIVERDATE Property
                                    //  Continue anyway
                                    ErrorTrace(TRACE_ID, "Set variant on DriverDate Failed.");
                                }
                            }

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              INFNAME                                                                     //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        
                            // Query for INFName
                            dwSize = MAX_PATH;
                            lRegRetVal = RegQueryValueEx(hkeySubSystem, lpctstrINFName, NULL, &dwType, (LPBYTE)tchINFNameValue, &dwSize);
                            if(lRegRetVal == ERROR_SUCCESS)
                            {
                                //  Set the INFName
                                varINFName = tchINFNameValue;
                                hRes2 = pPCHBIOSInstance->SetVariant(pINFName, varINFName);
                                if(FAILED(hRes2))
                                {
                                    //  Could not Set the INFNAME Property
                                    //  Continue anyway
                                    ErrorTrace(TRACE_ID, "Set variant on INFNAME Property Failed.");
                                }
                            
                            }

                            // Need not enumerate the rest of the keys
                            fContinueEnum = FALSE;
                        }
                        catch(...)
                        {
                            lRegRetVal = RegCloseKey(hkeySubSystem);
                            lRegRetVal = RegCloseKey(hkeySystem);
                            throw;
                        }

                    }  // end of strcmp
                    
                }  // end of Succeeded  hRes2
                //  Close the Opened Regkey
                lRegRetVal = RegCloseKey(hkeySubSystem);
                if(lRegRetVal != ERROR_SUCCESS)
                {
                    //  Could not close the reg Key
                    ErrorTrace(TRACE_ID, "RegClose Sub Key Failed.");
                }
               
            }
            //  Check to see if further enumeration is required.
            //  continue to enumerate.
            if(fContinueEnum)
            {
                dwSize = MAX_PATH;
		        dwIndex++;
                lRegRetVal = RegEnumKeyEx(hkeySystem, dwIndex,  tchSubSystemKeyName, &dwSize, NULL, NULL, NULL, pFileTime);
                if(lRegRetVal != ERROR_SUCCESS)
                {
                    fContinueEnum = FALSE;
                }
                
            }
            
                    
        } // end of while
        lRegRetVal = RegCloseKey(hkeySystem);
        if(lRegRetVal != ERROR_SUCCESS)
        {
             //  Could not close the reg Key
             ErrorTrace(TRACE_ID, "RegClose Key Failed.");
        }
    }

    // Got all the properties for PCH_BIOS Class

    if(fCommit)
    {
        hRes = pPCHBIOSInstance->Commit();
        if(FAILED(hRes))
        {
            //  Could not Commit the instance
            ErrorTrace(TRACE_ID, "Commit on PCHBiosInstance Failed");
        }
    }

    TraceFunctLeave();
    return hRes ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pchealth.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    pchealth.H

Abstract:
    Main header file for all PCHealth WMI providers
    Contains all defines and includes used elsewhere

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Added GetWbemServices & CopyProperty

    Kalyani Narlanka    (kalyanin) 05/10/99
        - Added #define  INCL_WINSOCK_API_TYPEDEFS
        - Included <winsock2.>


********************************************************************/
#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <sys/stat.h>

#ifndef _pchdef_h_
#define _pchdef_h_

#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif

#define NOTRACE

#include <fwcommon.h>  // This must be the first include.
#include <provider.h>
#include <atlbase.h>
#include "dbgtrace.h"
#include "traceids.h"

#include "smartptr.h"

//
// Namespaces that we'll be working with
//
#define PCH_NAMESPACE   L"root\\pchealth"
#define CIM_NAMESPACE   L"root\\cimv2"


// #include <winsock2.h>
//
// Global Variables
//
extern CComPtr<IWbemServices> g_pWbemServices;

//
// Utility functions
//
HRESULT ExecWQLQuery(IEnumWbemClassObject **ppEnumInst, BSTR bstrQuery);
HRESULT GetWbemServices(IWbemServices **ppServices);
HRESULT CopyProperty(IWbemClassObject * pFrom, LPCWSTR szFrom, CInstance * pTo, LPCWSTR szTo);
HRESULT GetCIMDataFile(BSTR bstrFile, IWbemClassObject ** ppFileObject, BOOL fHasDoubleSlashes = FALSE);
BOOL getCompletePath(CComBSTR bstrFileName, CComBSTR &bstrFileWithPathName);
int DelimitedStringToArray(LPWSTR strDelimitedString, LPTSTR strDelimiter, LPTSTR apstrArray[], int iMaxArraySize);
int DelimitedStringToArray(LPTSTR strDelimitedString, LPTSTR strDelimiter, LPTSTR apstrArray[], int iMaxArraySize);

//-----------------------------------------------------------------------------
// This class is useful for retrieving information about a specific file. It
// uses the version resource code from Dr. Watson. To use it, create an
// instance of the class, and use the QueryFile method to query information
// about a specific file. Then use the Get* access functions to get the 
// values describing the information.
//-----------------------------------------------------------------------------

struct FILEVERSION;
class CFileVersionInfo
{
public:
    CFileVersionInfo();
    ~CFileVersionInfo();

    HRESULT QueryFile(LPCSTR szFile, BOOL fHasDoubleBackslashes = FALSE);
    HRESULT QueryFile(LPCWSTR szFile, BOOL fHasDoubleBackslashes = FALSE);

    LPCTSTR GetVersion();
    LPCTSTR GetDescription();
    LPCTSTR GetCompany();
    LPCTSTR GetProduct();

private:
    FILEVERSION * m_pfv;
};

#endif // _pchdef_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_device.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Device.CPP

Abstract:
	WBEM provider class implementation for PCH_Device class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_Device.h"
// #include "confgmgr.h"
// #include <cregcls.h>

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_DEVICE

CPCH_Device MyPCH_DeviceSet (PROVIDER_NAME_PCH_DEVICE, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDescription = L"Description" ;
const static WCHAR* pDriveLetter = L"DriveLetter" ;
const static WCHAR* pHWRevision = L"HWRevision" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pRegkey = L"Regkey" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_Device::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_Device::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_Device::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    
    ULONG                               ulPNPEntityRetVal;

    //  Instances
    CComPtr<IEnumWbemClassObject>       pPNPEntityEnumInst;

    //  Objects
    IWbemClassObjectPtr                 pPNPEntityObj;

    //  Query Strings
    CComBSTR                            bstrPNPEntityQuery             = L"Select Description, DeviceID FROM Win32_PNPEntity";

    // Enumerate the instances of Win32_PNPEntity Class
    hRes = ExecWQLQuery(&pPNPEntityEnumInst, bstrPNPEntityQuery);
    if (FAILED(hRes))
    {
        //  Cannot get any properties.
        goto END;
    }

    // Query Succeeded
    while(WBEM_S_NO_ERROR == pPNPEntityEnumInst->Next(WBEM_INFINITE, 1, &pPNPEntityObj, &ulPNPEntityRetVal))
    {
	    // Create a new instance based on the passed-in MethodContext. If this fails,
        // we don't need to check for a null pointer because it throws an exception.

        CInstancePtr pPCHDeviceInstance(CreateNewInstance(pMethodContext), false);
             
        CopyProperty(pPNPEntityObj, L"DeviceID", pPCHDeviceInstance, pName);
        CopyProperty(pPNPEntityObj, L"Description", pPCHDeviceInstance, pDescription);

    	hRes = pPCHDeviceInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
    }

END :

    

    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_device.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Device.H

Abstract:
	WBEM provider class definition for PCH_Device class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Device_H_
#define _PCH_Device_H_

#define PROVIDER_NAME_PCH_DEVICE "PCH_Device"

// Property name externs -- defined in PCH_Device.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDescription ;
extern const WCHAR* pDriveLetter ;
extern const WCHAR* pHWRevision ;
extern const WCHAR* pName ;
extern const WCHAR* pRegkey ;

class CPCH_Device : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Device(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Device() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
        // virtual bool IsOneOfMe(void* a_pv);

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_codec.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_Codec.CPP

Abstract:
    WBEM provider class implementation for PCH_CODEC class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

    Jim Martin          (a-jammar) 05/13/99
        - Picked up the remaining properties (groupname and key
          from the registry.

********************************************************************/

#include "pchealth.h"
#include "PCH_Codec.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_CODEC

CPCH_Codec MyPCH_CodecSet (PROVIDER_NAME_PCH_CODEC, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pCodecDriver = L"CodecDriver" ;
const static WCHAR* pDate = L"Date" ;
const static WCHAR* pDescription = L"Description" ;
const static WCHAR* pGroupName = L"GroupName" ;
const static WCHAR* pkey = L"key" ;
const static WCHAR* pSize = L"Size" ;
const static WCHAR* pVersion = L"Version" ;

//-----------------------------------------------------------------------------
// Part of the data from the PCH_CODEC class does not come from the cimv2
// Win32_CODECFile class, but from the registry. The "GroupName" and "Key"
// properties are found at:
//
//    HKLM\System\CurrentControlSet\Control\MediaResources\<group>\<key>:driver
//
// Where the "driver" value is equal to the filename of the CODEC. Due to the 
// way this part of the registry is constructed, we can't find the <group>
// and <key> given the driver name. We'll need to build a map from driver
// to <group> and <key> - building the map requires traversing the registry.
//
// This class is used as a helper for that lookup. When it's created, it
// scans the registry, processing all of the CODEC entries. It can then
// be queried for the key and group associated with a driver.
//-----------------------------------------------------------------------------

#define MAX_DRIVER_LEN  MAX_PATH
#define MAX_KEY_LEN     MAX_PATH
#define MAX_GROUP_LEN   MAX_PATH

class CCODECInfo
{
public:
    CCODECInfo();
    ~CCODECInfo();

    BOOL QueryCODECInfo(LPCTSTR szDriver, LPCSTR * pszKey, LPCSTR * pszGroup);

private:
    struct SCODECNode
    {
        TCHAR        m_szDriver[MAX_DRIVER_LEN];
        TCHAR        m_szKey[MAX_KEY_LEN];
        TCHAR        m_szGroup[MAX_GROUP_LEN];
        SCODECNode * m_pNext;
    };

    SCODECNode * m_pCODECList;
};

//-----------------------------------------------------------------------------
// The constructor reads the CODEC info from the registry and builds a linked
// list (unsorted) of entries. The destructor deletes it.
//-----------------------------------------------------------------------------

CCODECInfo::CCODECInfo() : m_pCODECList(NULL)
{
    TraceFunctEnter("CCODECInfo::CCODECInfo");

    LPCTSTR szCODECKey = _T("System\\CurrentControlSet\\Control\\MediaResources");
    LPTSTR  szDrvValue = _T("driver");
    
    HKEY hkeyCODEC;
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, szCODECKey, 0, KEY_READ, &hkeyCODEC))
        ErrorTrace(TRACE_ID, "RegOpenKeyEx failed on CODEC key.");
    else
    {
        // Enumerate each subkey of the CODEC key. Each subkey corresponds to a group.

        DWORD       dwGroupIndex = 0;
        DWORD       dwSize = MAX_GROUP_LEN;
        FILETIME    ft;
        TCHAR       szGroup[MAX_GROUP_LEN];
        TCHAR       szKey[MAX_KEY_LEN];
        TCHAR       szDriver[MAX_DRIVER_LEN];

        while (ERROR_SUCCESS == RegEnumKeyEx(hkeyCODEC, dwGroupIndex, szGroup, &dwSize, 0, NULL, NULL, &ft))
        {
            // Open the group subkey. Then enumerate it's subkeys. These will be the keys.

            HKEY hkeyGroup;
            if (ERROR_SUCCESS != RegOpenKeyEx(hkeyCODEC, szGroup, 0, KEY_READ, &hkeyGroup))
                ErrorTrace(TRACE_ID, "RegOpenKeyEx failed on group key = %s.", szGroup);
            else
            {
                dwSize = MAX_KEY_LEN;

                DWORD dwKeyIndex = 0;
                while (ERROR_SUCCESS == RegEnumKeyEx(hkeyGroup, dwKeyIndex, szKey, &dwSize, 0, NULL, NULL, &ft))
                {
                    // For each key, attempt to get the value named "driver". This is the
                    // filename for the driver for this CODEC.

                    HKEY hkeyKey;
                    if (ERROR_SUCCESS != RegOpenKeyEx(hkeyGroup, szKey, 0, KEY_READ, &hkeyKey))
                        ErrorTrace(TRACE_ID, "RegOpenKeyEx failed on key = %s.", szKey);
                    else
                    {
                        // Note - there's no trace here because sometimes there may not be
                        // a driver value, and this is not an error for us.

                        dwSize = MAX_DRIVER_LEN * sizeof(TCHAR); // this wants the size in bytes

                        DWORD dwType = REG_SZ;
                        if (ERROR_SUCCESS == RegQueryValueEx(hkeyKey, szDrvValue, NULL, &dwType, (LPBYTE) szDriver, &dwSize))
                        {
                            if (*szGroup && *szKey && *szDriver)
                            {
                                // Here's where we insert a value into the map, using
                                // the strings szDriver, szKey and szGroup.

                                SCODECNode * pNew = new SCODECNode;
                                if (!pNew)
                                {
                                    ErrorTrace(TRACE_ID, "Out of memory.");
                                    RegCloseKey(hkeyKey);
                                    RegCloseKey(hkeyGroup);
                                    RegCloseKey(hkeyCODEC);
                                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                                }

                                _tcscpy(pNew->m_szDriver, szDriver);
                                _tcscpy(pNew->m_szKey, szKey);
                                _tcscpy(pNew->m_szGroup, szGroup);
                                pNew->m_pNext = m_pCODECList;
                                m_pCODECList = pNew;
                            }
                        }

                        if (ERROR_SUCCESS != RegCloseKey(hkeyKey))
                            ErrorTrace(TRACE_ID, "RegCloseKey failed on key.");
                    }

                    dwSize = MAX_KEY_LEN;
                    dwKeyIndex += 1;
                }

                if (ERROR_SUCCESS != RegCloseKey(hkeyGroup))
                    ErrorTrace(TRACE_ID, "RegCloseKey failed on key.");
            }

            dwSize = MAX_GROUP_LEN;
            dwGroupIndex += 1;
        }

        if (ERROR_SUCCESS != RegCloseKey(hkeyCODEC))
            ErrorTrace(TRACE_ID, "RegCloseKey failed on CODEC key.");
    }

    TraceFunctLeave();
}

CCODECInfo::~CCODECInfo()
{
    TraceFunctEnter("CCODECInfo::~CCODECInfo");

    while (m_pCODECList)
    {
        SCODECNode * pNext = m_pCODECList->m_pNext;
        delete m_pCODECList;
        m_pCODECList = pNext;
    }
    
    TraceFunctLeave();
}

//-----------------------------------------------------------------------------
// Search for the requested driver in the list of CODEC information entries.
// If it's found, set pszKey and pszGroup to point to the key and group strings
// in the entry and return TRUE, otherwise return FALSE. Note: copies of the
// strings are not made, so the caller is not responsible for deallocating
// the strings. Another note: the string pointers won't be valid after the
// CCODECInfo object is destructed.
//-----------------------------------------------------------------------------

BOOL CCODECInfo::QueryCODECInfo(LPCTSTR szDriver, LPCTSTR * pszKey, LPCTSTR * pszGroup)
{
    TraceFunctEnter("CCODECInfo::QueryCODECInfo");

    _ASSERT(szDriver && pszKey && pszGroup);

    SCODECNode * pScan = m_pCODECList;
    BOOL         fReturn = FALSE;

    while (pScan)
    {
        if (0 == _tcscmp(szDriver, pScan->m_szDriver))
        {
            *pszKey = pScan->m_szKey;
            *pszGroup = pScan->m_szGroup;
            fReturn = TRUE;
            break;
        }

        pScan = pScan->m_pNext;
    }

    TraceFunctLeave();
    return fReturn;
}

/*****************************************************************************
*
*  FUNCTION    :    CPCH_Codec::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/

HRESULT CPCH_Codec::EnumerateInstances(MethodContext * pMethodContext, long lFlags)
{
    TraceFunctEnter("CPCH_Codec::EnumerateInstances");

    USES_CONVERSION;
    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;
    ULONG                               ulRetVal;
    
    // This instance of CCODECInfo will provide some of the missing information
    // about each CODEC. Constructing it queries the registry for CODEC info.

    CCODECInfo codecinfo;

    // Get the date and time

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // Execute the query

    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("SELECT * FROM Win32_CodecFile"));
    if (FAILED(hRes))
        goto END;

    // enumerate the instances from win32_CodecFile

    while (WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        // Create a new instance based on the passed-in MethodContext

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        CComVariant  varValue;

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"group", pInstance, pCategory);
        (void)CopyProperty(pObj, L"name", pInstance, pCodecDriver);
        (void)CopyProperty(pObj, L"description", pInstance, pDescription);
        (void)CopyProperty(pObj, L"filesize", pInstance, pSize);
        (void)CopyProperty(pObj, L"version", pInstance, pVersion);

        // BUGBUG: WMI does not seem to be populating this field correctly.
        // Even though Win32_CODECFile is derived from CIM_DataFile, it doesn't
        // seem to be inheriting CreationDate. This is what we'd like to do:
        //
        // (void)CopyProperty(pObj, "CreationDate", pInstance, pDate);

        // Get the data which is missing from the Win32_CODECClass. Use the
        // instance of CCODECInfo we declared - we need to pass in just the
        // driver name (without the complete path).

        CComBSTR bstrDriver("name");
        if (FAILED(pObj->Get(bstrDriver, 0, &varValue, NULL, NULL)))
            ErrorTrace(TRACE_ID, "GetVariant on pCodecDriver field failed.");
        else
        {
            CComBSTR    ccombstrValue(V_BSTR(&varValue));

            // Because Win32_CODECFile doesn't seem to be inheriting
            // CreationDate, we need to get the actual creation date
            // by calling API functions.

            LPTSTR szName = W2T(ccombstrValue);
            HANDLE hFile = CreateFile(szName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
            if (INVALID_HANDLE_VALUE == hFile)
                ErrorTrace(TRACE_ID, "Couldn't open codec file to get date.");
            else
            {
                SYSTEMTIME stFileTime;
                FILETIME ftFileTime;

                if (GetFileTime(hFile, NULL, NULL, &ftFileTime))
                    if (FileTimeToSystemTime(&ftFileTime, &stFileTime))
                        if (!pInstance->SetDateTime(pDate, WBEMTime(stFileTime)))
                            ErrorTrace(TRACE_ID, "SetDateTime on date field failed.");

                CloseHandle(hFile);
            }

            // We need to convert the string from a BSTR to a LPCTSTR,
            // and to only include the file part (without the path).

            UINT uLen = SysStringLen(ccombstrValue);

            // Scan backwards through the string until we've either reached
            // the start (shouldn't happen) or a '\'.

            UINT iChar = uLen - 1;
            while (iChar && ccombstrValue[iChar] != L'\\')
                iChar -= 1;

            // Then scan to the end of the string, copying the filename.

            if (ccombstrValue[iChar] == L'\\')
                iChar += 1;

            TCHAR szDriver[MAX_DRIVER_LEN + 1] = _T("");
            int   i = 0;

            while (iChar < uLen && i < MAX_DRIVER_LEN)
                szDriver[i++] = (TCHAR) ccombstrValue[iChar++];
            szDriver[i] = _T('\0');

            LPCSTR szKey = NULL;
            LPCSTR szGroup = NULL;
            if (codecinfo.QueryCODECInfo(szDriver, &szKey, &szGroup))
            {
                if (!pInstance->SetCHString(pkey, szKey))
                    ErrorTrace(TRACE_ID, "SetCHString on key field failed.");

                if (!pInstance->SetCHString(pGroupName, szGroup))
                    ErrorTrace(TRACE_ID, "SetCHString on group field failed.");
            }
            else if (codecinfo.QueryCODECInfo(szName, &szKey, &szGroup))
            {
                // Sometimes the CODEC is stored in the registry with a complete
                // path. If we can't find the CODEC based on just the filename,
                // we might find it with the path.

                if (!pInstance->SetCHString(pkey, szKey))
                    ErrorTrace(TRACE_ID, "SetCHString on key field failed.");

                if (!pInstance->SetCHString(pGroupName, szGroup))
                    ErrorTrace(TRACE_ID, "SetCHString on group field failed.");
            }
        }
        
    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
    }

END:
    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_devicedriver.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_DeviceDriver.CPP

Abstract:
	WBEM provider class implementation for PCH_DeviceDriver class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "confgmgr.h"
#include "PCH_DeviceDriver.h"
#include "cregcls.h"

#define MAX_ARRAY   100

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_DEVICEDRIVER

CPCH_DeviceDriver MyPCH_DeviceDriverSet (PROVIDER_NAME_PCH_DEVICEDRIVER, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDate = L"Date" ;
const static WCHAR* pFilename = L"Filename" ;
const static WCHAR* pManufacturer = L"Manufacturer" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pSize = L"Size" ;
const static WCHAR* pVersion = L"Version" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_DeviceDriver::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_DeviceDriver::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_DeviceDriver::EnumerateInstances");

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    HRESULT hRes = WBEM_S_NO_ERROR;

    if ( cfgManager.GetDeviceList( deviceList ) ) 
    {
        REFPTR_POSITION pos;
    
        if ( deviceList.BeginEnum( pos ) ) 
        {
            try
            {
                CConfigMgrDevice    *pDevice = NULL;
        
                // Walk the list
                while ( (NULL != ( pDevice = deviceList.GetNext( pos ) ) ) )
                {
                    try
                    {

                        CHString chstrVar;

                        // Driver
                        if (pDevice->GetDriver(chstrVar))
                        {
                            // Get device driver info
                            (void)CreateDriverInstances(chstrVar, pDevice, pMethodContext);
                        }
                    }
                    catch(...)
                    {
                        // GetNext() AddRefs
                        pDevice->Release();
                        throw;
                    }

                    // GetNext() AddRefs
                    pDevice->Release();
                }
            }
            catch(...)
            {
                // Always call EndEnum().  For all Beginnings, there must be an End
                deviceList.EndEnum();
                throw;
            }
        
            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
    
    TraceFunctLeave();
    return hRes ;
//			  pInstance->SetVariant(pTimeStamp, <Property Change>);
//            pInstance->SetVariant(pChange, <Property Value>);
//            pInstance->SetVariant(pDate, <Property Value>);
//            pInstance->SetVariant(pFilename, <Property Value>);
//            pInstance->SetVariant(pManufacturer, <Property Value>);
//            pInstance->SetVariant(pName, <Property Value>);
//            pInstance->SetVariant(pSize, <Property Value>);
//            pInstance->SetVariant(pVersion, <Property Value>);
}

//
// QualifyInfFile will find where the inf file is located, in specific
// sections
//
BOOL QualifyInfFile(CHString chstrInfFile, CHString &chstrInfFileQualified)
{
	USES_CONVERSION;
    TCHAR strWinDir[MAX_PATH];
    
    if (GetWindowsDirectory(strWinDir, MAX_PATH))
    {
        // check if the file exists in %windir%\inf
        CHString chstrFullPath(strWinDir);
        chstrFullPath += "\\inf\\";
        chstrFullPath += chstrInfFile;

        // test for presence of the file
        HANDLE hFile = CreateFile(W2A((LPCWSTR)chstrFullPath), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        // if found, then return with value
        if (hFile != INVALID_HANDLE_VALUE)
        {
            chstrInfFileQualified = chstrFullPath;
            CloseHandle(hFile);
            return TRUE;
        }

        // check if the file exists in %windir%\inf\other
        chstrFullPath = strWinDir;
        chstrFullPath += "\\inf\\other\\";
        chstrFullPath += chstrInfFile;

        // test for presence of the file
        hFile = CreateFile(W2A((LPCWSTR)chstrFullPath), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        // if found, then return with value
        if (hFile != INVALID_HANDLE_VALUE)
        {
            chstrInfFileQualified = chstrFullPath;
            CloseHandle(hFile);
            return TRUE;
        }
    }

    return FALSE;
}

BOOL TestFile(LPCTSTR chstrPath1, LPCTSTR chstrPath2, LPCTSTR chstrPath3, CHString &chstrFullPath)
{
	USES_CONVERSION;

    // concatenate all parts of the path
    chstrFullPath = chstrPath1;
    chstrFullPath += chstrPath2;
    chstrFullPath += chstrPath3;

    // test for presence of the file
    HANDLE hFile = CreateFile(W2A(chstrFullPath), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    // if found, then return with value
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
        return TRUE;
    }

    return FALSE;
}

//
// QualifyDriverFile will find where the driver file is located, in specific
// sections
//
BOOL QualifyDriverFile(CHString chstrInfFile, CHString &chstrInfFileQualified)
{
    TCHAR strWinDir[MAX_PATH];
    TCHAR strSysDir[MAX_PATH];

    USES_CONVERSION;
    char * szInfFile = W2A(chstrInfFile);
    
    // Check in Windows Directory
    if (GetWindowsDirectory(strWinDir, MAX_PATH))
    {
        // check to see if it exists in %windir%
        if (TestFile(strWinDir, "\\", szInfFile, chstrInfFileQualified))
            return TRUE;

        // check to see if it exists in %windir%\system32 
        if (TestFile(strWinDir, "\\System32\\", szInfFile, chstrInfFileQualified))
            return TRUE;

        // check if the file exists in %windir%\system32\drivers
        if (TestFile(strWinDir, "\\system32\\drivers\\", szInfFile, chstrInfFileQualified))
            return TRUE;
    }

    // check in System Directory
    if (GetSystemDirectory(strSysDir, MAX_PATH))
    {
        // check to see if it exists in %sysdir%
        if (TestFile(strSysDir, "\\", szInfFile, chstrInfFileQualified))
            return TRUE;

        // check to see if it exists in %sysdir%\iosubsys
        if (TestFile(strSysDir, "\\iosubsys\\", szInfFile, chstrInfFileQualified))
            return TRUE;

        // check to see if it exists in %sysdir%\vmm32
        if (TestFile(strSysDir, "\\vmm32\\", szInfFile, chstrInfFileQualified))
            return TRUE;
    }

    return FALSE;
}

/*****************************************************************************
*
*  FUNCTION    :    CPCH_DeviceDriver::CreateDriverInstances
*
*  DESCRIPTION :    Creates all the device driver instances given the driver name
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*
*    How drivers are obtained from the registry and inf files :
*
*    In the reg hive HKLM\System\CurrentControlSet\Services\Class, each device will have a subkey.
*    In each device subkey, there are two values InfPath and InfSection. In the specified InfPath
*    and InfSection, the drivers are stored in the following fashion :
*
*    // sample.inf
*
*    [InfSection]
*    CopyFiles = Subsection1, Subsection2.....
*
*    [Subsection1]
*    xxx.dll
*    yyy.vxd
*    zzz.sys
*
*    [Subsection2]
*    aaa.dll
*    bbb.vxd
*    zzz.sys
*
*    Plus, there are other values for each different device which may contain driver information :
*
*    ALL             : PortDriver
*    Display         : drv, minivdd (extra level deep : default)
*    Net             : DeviceVxDs
*    Ports           : PortDriver, ConfigDialog
*    Media           : Driver
*
*
*****************************************************************************/
HRESULT CPCH_DeviceDriver::CreateDriverInstances(
    CHString chstrDriverName,
    CConfigMgrDevice* pDevice,
    MethodContext* pMethodContext
    )
{
    TraceFunctEnter("CPCH_DeviceDriver::EnumerateInstances");

    HRESULT     hRes = WBEM_S_NO_ERROR;
    CComVariant varValue;
    CRegistry   Reg;
    int         iDel;
    CHString    chstrInfFileQualified;
    CHString    chstrInfSection;
    TCHAR       strCopyFiles[MAX_PATH];
    LPTSTR      apstrCopyFileArray[MAX_ARRAY];
    LPTSTR      apstrDriverArray[MAX_ARRAY];
    int         iDriverIndex;
    int         iCountDriver;
    int         iCountCopyFile;
    int         iIndex;

    // create the device key
    CHString strDeviceKey("SYSTEM\\CurrentControlSet\\SERVICES\\Class\\");
    strDeviceKey += chstrDriverName;

    // Get the date and time
	SYSTEMTIME stUTCTime;
	GetSystemTime(&stUTCTime);

    USES_CONVERSION;
    char * szInf;
    char * szInfFileQualified;

    // Get the inf filename
    CHString chstrInfFile;
    if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"InfPath", chstrInfFile) != ERROR_SUCCESS)
        goto End;

    if (!QualifyInfFile(chstrInfFile, chstrInfFileQualified))
        goto End;

    // get the inf section
    if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"InfSection", chstrInfSection) != ERROR_SUCCESS)
        goto End;

    // get the subsections to be expanded
    szInf = W2A(chstrInfSection);
    szInfFileQualified = W2A(chstrInfFileQualified);
    GetPrivateProfileString(szInf, "CopyFiles", "Error", strCopyFiles, MAX_PATH, szInfFileQualified);
    if (!_tcscmp("Error", strCopyFiles))
        goto End;

    // add the default driver to the driver array
    iCountDriver = DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriverName, ",", apstrDriverArray, MAX_ARRAY);

    // count number of files to look at
    iCountCopyFile = DelimitedStringToArray(strCopyFiles, ",", apstrCopyFileArray, MAX_ARRAY);

    // loop through all subsections
    for (iIndex = 0; iIndex < iCountCopyFile; iIndex++)
    {
        // get all drivers in the subsection
        TCHAR strDriver[MAX_PATH * MAX_ARRAY];

        if (0 < GetPrivateProfileSection(apstrCopyFileArray[iIndex], strDriver, MAX_PATH * MAX_ARRAY, szInfFileQualified))
        {
            // string is delimited by NULL values so in order to work with the
            // DelimitedStringToArray function, we'll replace it with something else
            int iCIndex = 0;
            while (!((strDriver[iCIndex] == '\0') && (strDriver[iCIndex + 1] == '\0')))
            {
                if (strDriver[iCIndex] == '\0')
                    strDriver[iCIndex] = '%';
                else // do some cleanup here
                    if (!(_istalnum(strDriver[iCIndex])) && !(strDriver[iCIndex] == '.'))
                        strDriver[iCIndex] = '\0';

                    iCIndex++;
            }

            iCountDriver += DelimitedStringToArray(strDriver, "%", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);

            // Scout around for more drivers in special keys
            CHString chstrExtraKey = strDeviceKey;
            chstrExtraKey += "\\default";
            CHString chstrDriver;

            // special case for display and monitor
            if ((!wcsncmp(chstrDriverName, L"display", wcslen(L"display"))) ||
                (!wcsncmp(chstrDriverName, L"monitor", wcslen(L"monitor"))))
            {
                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\####\default for Drv values

                if (Reg.OpenLocalMachineKeyAndReadValue(chstrExtraKey, L"Drv", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }

                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\####\default for MiniVDD values
                if (Reg.OpenLocalMachineKeyAndReadValue(chstrExtraKey, L"MiniVDD", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }
            }

            // special case for net, nettrans, netclient, netservice
            if (!wcsncmp(chstrDriverName, L"net", wcslen(L"net")))
            {
                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\#### for DeviceVxDs values
                if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"DeviceVxDs", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }
            }

            // special case for ports
            if (!wcsncmp(chstrDriverName, L"ports", wcslen(L"ports")))
            {
                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\#### for ConfigDialog values
                if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"ConfigDialog", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }
            }

            // special case for media
            if (!wcsncmp(chstrDriverName, L"media", wcslen(L"media")))
            {
                // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\#### for Driver values
                if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"Driver", chstrDriver) == ERROR_SUCCESS)
                {
                    // add the list of new driver to the driver array
                    iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
                }
            }
            
            // HKLM\SYSTEM\CurrentControlSet\SERVICES\Class\XXXX\#### for PortDriver values
            if (Reg.OpenLocalMachineKeyAndReadValue(strDeviceKey, L"PortDriver", chstrDriver) == ERROR_SUCCESS)
            {
                // add the list of new driver to the driver array
                iCountDriver += DelimitedStringToArray((LPWSTR)(LPCWSTR)chstrDriver, ",", apstrDriverArray + iCountDriver, MAX_ARRAY - iCountDriver);
            }
        }
    }

    // Clean up
    for (iDel = 0; iDel < iCountCopyFile; iDel++)
        delete [] apstrCopyFileArray[iDel];

    // go through list of drivers and create the instances
    for (iDriverIndex = 0; iDriverIndex < iCountDriver; iDriverIndex++)
    {                            
        CHString chstrDriver(apstrDriverArray[iDriverIndex]);
        CHString chstrPath;

        // Check for duplicates
        BOOL bDup = FALSE;
        for (int iDup = 0; iDup < iDriverIndex; iDup++)
        {
            char * szDriver = W2A(chstrDriver);
            if (!_tcsicmp(szDriver, apstrDriverArray[iDup]))
            {
                bDup = TRUE;
                break;
            }
        }

        // if there exists a duplicate, skip it
        if (bDup)
            continue;

        // create instance
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        try
        {
            // Timestamp
            if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
               ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

            // Snapshot
            if (!pInstance->SetCHString(pChange, L"Snapshot"))
                ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

            // Name (key)
            // bug fix : should be name of device (foreign key), NOT driver name
            CHString chstrVar;
            if (pDevice->GetDeviceID(chstrVar))
                if (!pInstance->SetCHString(pName, chstrVar))
                    ErrorTrace(TRACE_ID, "SetCHString on Name field failed.");

            // Set filename (key)
            if (!pInstance->SetCHString(pFilename, chstrDriver))
                ErrorTrace(TRACE_ID, "SetVariant on filename Field failed.");

            // If there exists such a driver file, get the CIM_Datafile object on it
            if (QualifyDriverFile(chstrDriver, chstrPath))
            {
                // get the CIMDatafile object
                IWbemClassObject *pFileObj;
                CComBSTR ccombstrPath((LPCWSTR)chstrPath);

                hRes = GetCIMDataFile(ccombstrPath, &pFileObj);
            
                // if succeeded in getting the CIM_Datafile object, get all file info
                if (SUCCEEDED(hRes))
                {
                    // Get Manufacturer
                    hRes = pFileObj->Get(CComBSTR("Manufacturer"), 0, &varValue, NULL, NULL);
                    if (FAILED(hRes))
                        ErrorTrace(TRACE_ID, "Get Manufacturer failed on file object");
                    else
                        if (!pInstance->SetVariant(pManufacturer, varValue))
                            ErrorTrace(TRACE_ID, "SetVariant on Manufacturer Field failed.");                        

                    // Get size
                    hRes = pFileObj->Get(CComBSTR("Filesize"), 0, &varValue, NULL, NULL);
                    if (FAILED(hRes))
                        ErrorTrace(TRACE_ID, "Get FileSize failed on file object");
                    else
                        if (!pInstance->SetVariant(pSize, varValue))
                            ErrorTrace(TRACE_ID, "SetVariant on Size Field failed.");                        

                    // Get version
                    hRes = pFileObj->Get(CComBSTR("version"), 0, &varValue, NULL, NULL);
                    if (FAILED(hRes))
                        ErrorTrace(TRACE_ID, "Get version failed on file object");
                    else
                        if (!pInstance->SetVariant(pVersion, varValue))
                            ErrorTrace(TRACE_ID, "SetVariant on version Field failed.");                        

                    // Get date
                    hRes = pFileObj->Get(CComBSTR("LastModified"), 0, &varValue, NULL, NULL);
                    if (FAILED(hRes))
                        ErrorTrace(TRACE_ID, "Get LastModified failed on file object");
                    else
                        if (!pInstance->SetVariant(pDate, varValue))
                            ErrorTrace(TRACE_ID, "SetVariant on Date Field failed.");                        
                }
            }

            // commit this
   	        hRes = pInstance->Commit();
            if (FAILED(hRes))
                ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        }
        catch(...)
        {
            // Clean up
            for (iDel = 0; iDel < iCountDriver; iDel++)
                delete [] apstrDriverArray[iDel];
            throw;
        }
    }

    // Clean up
    for (iDel = 0; iDel < iCountDriver; iDel++)
        delete [] apstrDriverArray[iDel];
        
End :
    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_drive.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_Drive.CPP

Abstract:
    WBEM provider class implementation for PCH_Drive class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_Drive.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_DRIVE

#define   maxMediaTypes         (sizeof(szMediaTypeStrings)/sizeof(*szMediaTypeStrings))
#define   KILO                   1024
#define   MAXSIZE                65

const  static  LPCTSTR    szMediaTypeStrings[] = 
{
    _T("Format is Unknown "),                        
    _T("5.25\", 1.2MB,  512 bytes/sector "),         
    _T("3.5\",  1.44MB, 512 bytes/sector "),         
    _T("3.5\",  2.88MB, 512 bytes/sector "),         
    _T("3.5\",  20.8MB, 512 bytes/sector "),         
    _T("3.5\",  720KB,  512 bytes/sector "),         
    _T("5.25\", 360KB,  512 bytes/sector "),         
    _T("5.25\", 320KB,  512 bytes/sector "),         
    _T("5.25\", 320KB,  1024 bytes/sector"),         
    _T("5.25\", 180KB,  512 bytes/sector "),         
    _T("5.25\", 160KB,  512 bytes/sector "),
    _T("Removable media other than floppy "),
    _T("Fixed hard disk media            "),
    _T("3.5\", 120M Floppy                "),
    _T("3.5\" ,  640KB,  512 bytes/sector "),
    _T("5.25\",  640KB,  512 bytes/sector "),
    _T("5.25\",  720KB,  512 bytes/sector "),
    _T("3.5\" ,  1.2Mb,  512 bytes/sector "),
    _T("3.5\" ,  1.23Mb, 1024 bytes/sector"),
    _T("5.25\",  1.23MB, 1024 bytes/sector"),
    _T("3.5\" MO 128Mb   512 bytes/sector "),
    _T("3.5\" MO 230Mb   512 bytes/sector "),
    _T("8\",     256KB,  128 bytes/sector ")
};

CPCH_Drive MyPCH_DriveSet (PROVIDER_NAME_PCH_DRIVE, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pAvailable = L"Available" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDriveLetter = L"DriveLetter" ;
const static WCHAR* pFilesystemType = L"FilesystemType" ;
const static WCHAR* pFree = L"Free" ;
const static WCHAR* pDescription = L"Description";
const static WCHAR* pMediaType = L"MediaType";

/*****************************************************************************
*
*  FUNCTION    :    CPCH_Drive::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_Drive::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_Drive::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;      
    ULONG                               ulRetVal;

    int                                 nMediaType;
    long                                lFreeSpace;
    long                                lAvailable;

    LONGLONG                            llFreeSpace;
    LONGLONG                            llAvailable;

    TCHAR                               tchSize[MAXSIZE];
    TCHAR                               tchFreeSpace[MAXSIZE];

    CComVariant                         varMediaType;
    CComVariant                         varMediaTypeStr;
    CComVariant                         varFreeSpace;
    CComVariant                         varFree;
    CComVariant                         varAvailable;
    CComVariant                         varSize;

    //
    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select DeviceID, FileSystem, FreeSpace, Size, Description, MediaType FROM win32_logicalDisk"));
    if (FAILED(hRes))
        goto END;

    //
    // enumerate the instances from win32_CodecFile
    //
    while(WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {

        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        
        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"DeviceID", pInstance, pDriveLetter);
        (void)CopyProperty(pObj, L"FileSystem", pInstance, pFilesystemType);
        (void)CopyProperty(pObj, L"Description", pInstance, pDescription);

     
        //  Get the Available Space
        varSize.Clear();
        varAvailable.Clear();
        hRes = pObj->Get(CComBSTR(L"Size"),0,&varSize,NULL,NULL);
        if(FAILED(hRes))
        {
            // Cannot Get the "Size" Property.
            ErrorTrace(TRACE_ID, "GetVariant on Size Field failed.");
        }
        else
        {
            // Got the size property.
            if(varSize.vt == VT_BSTR)
            {
                varSize.ChangeType(VT_BSTR, NULL);
                {
                      USES_CONVERSION;
                      _tcscpy(tchSize,OLE2T(varSize.bstrVal));
                }
    
                // Convert this to KB.
                // lAvailable = _ttol(tchSize);
                llAvailable = _ttoi64(tchSize);
            }
            else if(varSize.vt == VT_NULL)
            {
                llAvailable = 0;
            }
            // lAvailable = lAvailable/KILO;
            llAvailable = llAvailable/KILO;
            varAvailable = (long)llAvailable;

            // Set the Size Property
            if (FAILED(pInstance->SetVariant(pAvailable, varAvailable)))
            {
                // Set Available Space Failed
                // Proceed anyway
                ErrorTrace(TRACE_ID, "SetVariant on Available Field failed.");
            }
        }
        varFreeSpace.Clear();
        varFree.Clear();
        hRes = pObj->Get(CComBSTR(L"FreeSpace"),0,&varFreeSpace,NULL,NULL);
        if(FAILED(hRes))
        {
            // Cannot Get the "FreeSpace" Property.
            ErrorTrace(TRACE_ID, "GetVariant on Size Field failed.");
        }
        else
        {
            // Got the FreeSpace property.
            if(varFreeSpace.vt == VT_BSTR)
            {
                varFreeSpace.ChangeType(VT_BSTR, NULL);
                {
                      USES_CONVERSION;
                      _tcscpy(tchFreeSpace,OLE2T(varFreeSpace.bstrVal));
                }
    
                // Convert this to KB.
                // lFreeSpace = _ttol(tchFreeSpace);
                llFreeSpace = _ttoi64(tchFreeSpace);
            }
            else if(varFreeSpace.vt == VT_NULL)
            {
                llFreeSpace = 0;
            }
            
            // lFreeSpace = lFreeSpace/KILO;
            llFreeSpace = llFreeSpace/KILO;
            // varFreeSpace = (long)llFreeSpace;


            // varFree = nFreeSpace;
            // varFree = lFreeSpace;
            varFree = (long)llFreeSpace;

            // Set the Free Property
            if (FAILED(pInstance->SetVariant(pFree, varFree)))
            {
                // Set Free Space Failed
                // Proceed anyway
                ErrorTrace(TRACE_ID, "SetVariant on Free Field failed.");
            }
        }

        varMediaType = NULL;
        hRes = pObj->Get(CComBSTR("MediaType"), 0, &varMediaType, NULL, NULL);
        if (FAILED(hRes))
        {
           //  Cannot get MediaType.
           ErrorTrace(TRACE_ID, "GetVariant on MediaType Field failed.");
        }
        else 
        {
            //  Got the MediaType
            nMediaType = varMediaType.iVal;
            if (nMediaType < 0 || nMediaType > maxMediaTypes)
            {
                //unknown Media Type
                nMediaType = 0;
            }
            varMediaTypeStr = szMediaTypeStrings[nMediaType];
            // Set the Media Type Property
            if (FAILED(pInstance->SetVariant(pMediaType, varMediaTypeStr)))
            {
                // Set MediaType Failed
                // Proceed anyway
                ErrorTrace(TRACE_ID, "SetVariant on MediaType Field failed.");
            }
        }
 
        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Commit failed.");
        }
    }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_fileupload.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_FileUpload.H

Abstract:
	WBEM provider class definition for PCH_FileUpload class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_FileUpload_H_
#define _PCH_FileUpload_H_

#define PROVIDER_NAME_PCH_FILEUPLOAD "PCH_FileUpload"

// Property name externs -- defined in PCH_FileUpload.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pData ;
extern const WCHAR* pDateAccessed ;
extern const WCHAR* pDateCreated ;
extern const WCHAR* pDateModified ;
extern const WCHAR* pFileAttributes ;
extern const WCHAR* pPath ;
extern const WCHAR* pSize ;

class CPCH_FileUpload : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_FileUpload(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_FileUpload() {};

	protected:
		// Reading Functions
		//============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L){ return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) ;

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_module.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Module.H

Abstract:
	WBEM provider class definition for PCH_Module class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Module_H_
#define _PCH_Module_H_

#define PROVIDER_NAME_PCH_MODULE "PCH_Module"

// Property name externs -- defined in PCH_Module.cpp
//=================================================

extern const WCHAR* pAddress ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pPartOf ;
extern const WCHAR* pPath ;
extern const WCHAR* pSize ;
extern const WCHAR* pType ;
extern const WCHAR* pVersion ;

class CPCH_Module : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Module(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Module() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_networkadapter.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_NetworkAdapter.H

Abstract:
	WBEM provider class definition for PCH_NetworkAdapter class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_NetworkAdapter_H_
#define _PCH_NetworkAdapter_H_

#define PROVIDER_NAME_PCH_NETWORKADAPTER "PCH_NetworkAdapter"

// Property name externs -- defined in PCH_NetworkAdapter.cpp
//=================================================

extern const WCHAR* pAdapterType ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
// extern const WCHAR* pDefaultIPGateway ;
extern const WCHAR* pDeviceID ;
extern const WCHAR* pDHCPEnabled ;
extern const WCHAR* pIOPort ;
// extern const WCHAR* pIPAddress ;
// extern const WCHAR* pIPSubnet ;
extern const WCHAR* pIRQNumber ;
// extern const WCHAR* pMACAddress ;
extern const WCHAR* pProductName ;
// extern const WCHAR* pServiceName ;

class CPCH_NetworkAdapter : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_NetworkAdapter(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_NetworkAdapter() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_networkconnection.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_NetworkConnection.CPP

Abstract:
    WBEM provider class implementation for PCH_NetworkConnection class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_NetworkConnection.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_NETWORKCONNECTION

CPCH_NetworkConnection MyPCH_NetworkConnectionSet (PROVIDER_NAME_PCH_NETWORKCONNECTION, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pLocalName = L"LocalName" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pRemoteName = L"RemoteName" ;
const static WCHAR* pStatus = L"Status" ;
const static WCHAR* pType = L"Type" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_NetworkConnection::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_NetworkConnection::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_NetworkConnection::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;      // BUGBUG : WMI asserts if we use CComPtr
    ULONG                               ulRetVal;

    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select Name, LocalName, RemoteName, ResourceType, Status from Win32_NetworkConnection"));
    if (FAILED(hRes))
        goto END;

    //
    // enumerate the instances from win32_CodecFile
    //
    while(WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {

        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"LocalName", pInstance, pLocalName);
        (void)CopyProperty(pObj, L"Name", pInstance, pName);
        (void)CopyProperty(pObj, L"RemoteName", pInstance, pRemoteName);
        (void)CopyProperty(pObj, L"Status", pInstance, pStatus);
        (void)CopyProperty(pObj, L"ResourceType", pInstance, pType);

        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
        }
            
    }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_networkprotocol.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_NetworkProtocol.CPP

Abstract:
    WBEM provider class implementation for PCH_NetworkProtocol class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_NetworkProtocol.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_NETWORKPROTOCOL

CPCH_NetworkProtocol MyPCH_NetworkProtocolSet (PROVIDER_NAME_PCH_NETWORKPROTOCOL, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pConnectionlessService = L"ConnectionlessService" ;
const static WCHAR* pGuaranteesDelivery = L"GuaranteesDelivery" ;
const static WCHAR* pGuaranteesSequencing = L"GuaranteesSequencing" ;
const static WCHAR* pName = L"Name" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_NetworkProtocol::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_NetworkProtocol::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_NetworkProtocol::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;       // BUGBUG : WMI asserts if we use CComPtr
    ULONG                               ulRetVal;

    //
    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select Name, ConnectionlessService, GuaranteesDelivery, GuaranteesSequencing from Win32_NetworkProtocol"));
    if (FAILED(hRes))
        goto END;

    //
    // enumerate the instances from win32_CodecFile
    //
    while(WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {

        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        
        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"ConnectionlessService", pInstance, pConnectionlessService);
        (void)CopyProperty(pObj, L"GuaranteesDelivery", pInstance, pGuaranteesDelivery);
        (void)CopyProperty(pObj, L"GuaranteesSequencing", pInstance, pGuaranteesSequencing);
        (void)CopyProperty(pObj, L"Name", pInstance, pName);

        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            //  Could not Commit
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Commit failed.");
        }
    }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_driver.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_Driver.CPP

Abstract:
    WBEM provider class implementation for PCH_Driver class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

  Brijesh Krishnaswami  (brijeshk) 05/24/99
        - added code for enumerating usermode drivers
        - added code for enumerating msdos drivers
        - added code for getting details on kernel mode drivers
********************************************************************/

#include "pchealth.h"
#include "PCH_Driver.h"
#include "drvdefs.h"
#include "shlwapi.h"

#define Not_VxD
#include <vxdldr.h>             /* For DeviceInfo */


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_DRIVER
#define SYSTEM_INI_MAX  32767

CPCH_Driver MyPCH_DriverSet (PROVIDER_NAME_PCH_DRIVER, PCH_NAMESPACE) ;
void MakeSrchDirs(void);

static BOOL fThunkInit = FALSE;

TCHAR       g_rgSrchDir[10][MAX_PATH];
UINT        g_nSrchDir;


// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDate = L"Date" ;
const static WCHAR* pDescription = L"Description" ;
const static WCHAR* pLoadedFrom = L"LoadedFrom" ;
const static WCHAR* pManufacturer = L"Manufacturer" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pPartOf = L"PartOf" ;
const static WCHAR* pPath = L"Path" ;
const static WCHAR* pSize = L"Size" ;
const static WCHAR* pType = L"Type" ;
const static WCHAR* pVersion = L"Version" ;

CComBSTR bstrPath = L"PathName";


/*****************************************************************************
*
*  FUNCTION    :    CPCH_Driver::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_Driver::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    USES_CONVERSION;
    TraceFunctEnter("CPCH_Driver::AddDriverKernelList");
    

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    CFileVersionInfo                    fileversioninfo;
    CComVariant                         varValue;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    CComPtr<IWbemClassObject>           pFileObj;
    IWbemClassObjectPtr                 pObj;
    ULONG                               ulRetVal;

    //
    // Get the date and time
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // execute query
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("SELECT * FROM Win32_SystemDriver"));
    if (FAILED(hRes))
        goto done;
    
    while(WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        // Create a new instance
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        // Set the timestamp
        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        // Set the category
        if (!pInstance->SetCHString(pCategory, "Kernel"))
            ErrorTrace(TRACE_ID, "SetVariant on Category Field failed.");

        CopyProperty(pObj, L"Name", pInstance, pName);

        hRes = pObj->Get(bstrPath, 0, &varValue, NULL, NULL);

        // if we fail to get the path (or it's an empty string) then just copy the
        //  description from the Win32_SystemDriver class & be done with it...
        if (FAILED(hRes) || V_VT(&varValue) != VT_BSTR || V_BSTR(&varValue) == NULL ||
            SysStringLen(V_BSTR(&varValue)) == 0)
        {
            CopyProperty(pObj, L"Description", pInstance, pDescription);
        }

        // otherwise, use the file object to get the properties
        else
        {
            if (SUCCEEDED(GetCIMDataFile(V_BSTR(&varValue), &pFileObj, TRUE)))
            {
                // Using the CIM_DataFile object, copy over the appropriate properties.

                CopyProperty(pFileObj, L"Version", pInstance, pVersion);
                CopyProperty(pFileObj, L"FileSize", pInstance, pSize);
                CopyProperty(pFileObj, L"CreationDate", pInstance, pDate);
                CopyProperty(pFileObj, L"Name", pInstance, pPath);
                CopyProperty(pFileObj, L"Manufacturer", pInstance, pManufacturer);
            }
/*
            if (SUCCEEDED(fileversioninfo.QueryFile(V_BSTR(&varValue), TRUE)))
            {
                if (!pInstance->SetCHString(pDescription, fileversioninfo.GetDescription()))
                    ErrorTrace(TRACE_ID, "SetCHString on description field failed.");

                if (!pInstance->SetCHString(pPartOf, fileversioninfo.GetProduct()))
                    ErrorTrace(TRACE_ID, "SetCHString on partof field failed.");
            }
*/      }

    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
    }

done:
    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_networkconnection.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_NetworkConnection.H

Abstract:
	WBEM provider class definition for PCH_NetworkConnection class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_NetworkConnection_H_
#define _PCH_NetworkConnection_H_

#define PROVIDER_NAME_PCH_NETWORKCONNECTION "PCH_NetworkConnection"

// Property name externs -- defined in PCH_NetworkConnection.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pLocalName ;
extern const WCHAR* pName ;
extern const WCHAR* pRemoteName ;
extern const WCHAR* pStatus ;
extern const WCHAR* pType ;

class CPCH_NetworkConnection : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_NetworkConnection(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_NetworkConnection() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_networkprotocol.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_NetworkProtocol.H

Abstract:
	WBEM provider class definition for PCH_NetworkProtocol class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_NetworkProtocol_H_
#define _PCH_NetworkProtocol_H_

#define PROVIDER_NAME_PCH_NETWORKPROTOCOL "PCH_NetworkProtocol"

// Property name externs -- defined in PCH_NetworkProtocol.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pConnectionlessService ;
extern const WCHAR* pGuaranteesDelivery ;
extern const WCHAR* pGuaranteesSequencing ;
extern const WCHAR* pName ;

class CPCH_NetworkProtocol : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_NetworkProtocol(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_NetworkProtocol() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_oleregistration.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_OLERegistration.H

Abstract:
	WBEM provider class definition for PCH_OLERegistration class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_OLERegistration_H_
#define _PCH_OLERegistration_H_

#define PROVIDER_NAME_PCH_OLEREGISTRATION "PCH_OLERegistration"

// Property name externs -- defined in PCH_OLERegistration.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pObject ;
extern const WCHAR* pProgramFile ;
extern const WCHAR* pSize ;
extern const WCHAR* pVersion ;

class CPCH_OLERegistration : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_OLERegistration(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_OLERegistration() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_printer.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Printer.H

Abstract:
	WBEM provider class definition for PCH_Printer class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Printer_H_
#define _PCH_Printer_H_

#define PROVIDER_NAME_PCH_PRINTER "PCH_Printer"

// Property name externs -- defined in PCH_Printer.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDefaultPrinter ;
extern const WCHAR* pGenDrv ;
extern const WCHAR* pName ;
extern const WCHAR* pPath ;
extern const WCHAR* pUniDrv ;
extern const WCHAR* pUsePrintMgrSpooling ;

class CPCH_Printer : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Printer(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Printer() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_printerdriver.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_PrinterDriver.H

Abstract:
	WBEM provider class definition for PCH_PrinterDriver class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_PrinterDriver_H_
#define _PCH_PrinterDriver_H_

#define PROVIDER_NAME_PCH_PRINTERDRIVER "PCH_PrinterDriver"

// Property name externs -- defined in PCH_PrinterDriver.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pFilename ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pSize ;
extern const WCHAR* pVersion ;
extern const WCHAR* pPath;

class CPCH_PrinterDriver : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_PrinterDriver(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_PrinterDriver() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_printjob.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_PrintJob.CPP

Abstract:
    WBEM provider class implementation for PCH_PrintJob class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_PrintJob.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTJOB

CPCH_PrintJob MyPCH_PrintJobSet (PROVIDER_NAME_PCH_PRINTJOB, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pPagesPrinted = L"PagesPrinted" ;
const static WCHAR* pSize = L"Size" ;
const static WCHAR* pStatus = L"Status" ;
const static WCHAR* pTimeSubmitted = L"TimeSubmitted" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_PrintJob::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_PrintJob::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_PrintJob::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;      // BUGBUG : WMI asserts if we use CComPtr
    ULONG                               ulRetVal;

    //
    // Get the date and time
    //
    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    //
    // Execute the query
    //
    // To fix Bug : 100551 , we need to read "jobstatus" instead of "status".
    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select Name, Size, JobStatus, TimeSubmitted, PagesPrinted from Win32_printJob"));
    if (FAILED(hRes))
        goto END;

    //
    // enumerate the instances from win32_CodecFile
    //
    while(WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {

        // Create a new instance based on the passed-in MethodContext
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        CComVariant varValue;

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"Name", pInstance, pName);
        (void)CopyProperty(pObj, L"PagesPrinted", pInstance, pPagesPrinted);
        (void)CopyProperty(pObj, L"Size", pInstance, pSize);
        (void)CopyProperty(pObj, L"JobStatus", pInstance, pStatus);
        (void)CopyProperty(pObj, L"TimeSubmitted", pInstance, pTimeSubmitted);

        hRes = pInstance->Commit();
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
        }
           
    }

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_networkadapter.cpp ===
/*****************************************************************************

  Copyright (c) 1999 Microsoft Corporation
  
    Module Name:
    .PCH_NetworkAdapter.CPP
    
      Abstract:
      WBEM provider class implementation for PCH_NetworkAdapter class.
      1. This class gets the foll. properties from Win32_NetworkAdapter Class:
      AdapterType, DeviceID, ProductName
      2. Gets the foll. properties from Win32_NetworkAdapterConfiguration Class:
      ServiceName,IPAddress,IPSubnet,DefaultIPGateway,DHCPEnabled,MACAddress
      3. Gets the foll. properties from Win32_IRQResource Class:
      IRQ Number
      4. Gets the foll. properties from Win32_PortResource Class:
      StartingAddress, EndingAddress
      5. Sets the "Change" property to "Snapshot" always
      
        Revision History:
        
          Ghim Sim Chua       (gschua)                        04/27/99
          - Created
          Kalyani Narlanka      kalyanin
          - Added  ServiceName, IPAddress, IPSubnet, DefaultIPGateway, DHCPEnabled, 
                   MACAddress                                 05/03/99
          - Added  IRQNumber and PORT Resource                07/08 /99
          
            
*******************************************************************************/

#include "pchealth.h"
#include "PCH_NetworkAdapter.h"

///////////////////////////////////////////////////////////////////////////////
//    Begin Tracing stuff
//
#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_NETWORKADAPTER
//
//    End Tracing stuff
///////////////////////////////////////////////////////////////////////////////

//    
CPCH_NetworkAdapter MyPCH_NetworkAdapterSet (PROVIDER_NAME_PCH_NETWORKADAPTER, PCH_NAMESPACE) ;

///////////////////////////////////////////////////////////////////////////////
//....Properties of PCHNetworkAdapter Class
//
const static WCHAR* pAdapterType      = L"AdapterType" ;
const static WCHAR* pTimeStamp        = L"TimeStamp" ;
const static WCHAR* pChange           = L"Change" ;
// const static WCHAR* pDefaultIPGateway = L"DefaultIPGateway" ;
const static WCHAR* pDeviceID         = L"DeviceID" ;
const static WCHAR* pDHCPEnabled      = L"DHCPEnabled" ;
const static WCHAR* pIOPort           = L"IOPort" ;
// const static WCHAR* pIPAddress        = L"IPAddress" ;
// const static WCHAR* pIPSubnet         = L"IPSubnet" ;
const static WCHAR* pIRQNumber        = L"IRQNumber" ;
// const static WCHAR* pMACAddress       = L"MACAddress" ;
const static WCHAR* pProductName      = L"ProductName" ;
// const static WCHAR* pServiceName      = L"ServiceName" ;
//
///////////////////////////////////////////////////////////////////////////////


//*****************************************************************************
//
// Function Name     : CPCH_NetworkAdapter::EnumerateInstances
//
// Input Parameters  : pMethodContext : Pointer to the MethodContext for 
//                                      communication with WinMgmt.
//                
//                     lFlags :         Long that contains the flags described 
//                                      in IWbemServices::CreateInstanceEnumAsync
//                                      Note that the following flags are handled 
//                                      by (and filtered out by) WinMgmt:
//                                      WBEM_FLAG_DEEP
//                                      WBEM_FLAG_SHALLOW
//                                      WBEM_FLAG_RETURN_IMMEDIATELY
//                                      WBEM_FLAG_FORWARD_ONLY
//                                      WBEM_FLAG_BIDIRECTIONAL
// Output Parameters  : None
//
// Returns            : WBEM_S_NO_ERROR 
//                      
//
// Synopsis           : All instances of this class on the machine are returned.
//                      If there are no instances returns WBEM_S_NO_ERROR.
//                      It is not an error to have no instances.
//                 
//
//*****************************************************************************

HRESULT CPCH_NetworkAdapter::EnumerateInstances(MethodContext* pMethodContext,
                                                long lFlags)
{
    TraceFunctEnter("CPCH_NetworkAdapter::EnumerateInstances");
    
    //  Begin Declarations...................................................
    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    
    //  Instances
    CComPtr<IEnumWbemClassObject>       pNetworkAdapterEnumInst;
    CComPtr<IEnumWbemClassObject>       pNetworkAdapterConfigurationEnumInst;
    CComPtr<IEnumWbemClassObject>       pAllocatedResourceEnumInst;
    CComPtr<IEnumWbemClassObject>       pPortResourceEnumInst;
    
    //  PCH_NetworkAdapter Class instance 
    CInstancePtr                         pPCHNetworkAdapterInstance;
    
    //  Objects
    IWbemClassObjectPtr                  pNetworkAdapterObj;                   
    IWbemClassObjectPtr                  pNetworkAdapterConfigurationObj;      
    IWbemClassObjectPtr                  pAllocatedResourceObj;                
    IWbemClassObjectPtr                  pPortResourceObj;                     

    //  Variants
    CComVariant                         varIndex;
    CComVariant                         varDeviceID;
    CComVariant                         varAntecedent;
    CComVariant                         varPortResource;
    CComVariant                         varName;
    CComVariant                         varIRQNumber;
    
    //  Return Values;
    ULONG                               ulNetworkAdapterRetVal               = 0;
    ULONG                               ulNetworkAdapterConfigurationRetVal  = 0;
    ULONG                               ulAllocatedResourceRetVal            = 0;
    ULONG                               ulPortResourceRetVal                 = 0;
    
    //  Query Strings
    CComBSTR                            bstrNetworkAdapterQuery              = L"Select AdapterType, DeviceID, ProductName, Index FROM win32_NetworkAdapter";
    CComBSTR                            bstrNetworkAdapterConfigurationQuery = L"Select ServiceName, IPAddress, IPSubnet, DefaultIPGateway, DHCPEnabled, MACAddress, Index FROM Win32_NetworkAdapterConfiguration WHERE Index=";
    CComBSTR                            bstrAllocatedResourceQuery           = L"SELECT Antecedent, Dependent FROM Win32_AllocatedResource WHERE  Dependent=\"Win32_NetworkAdapter.DeviceID=\\\""; 
    CComBSTR                            bstrPortResourceQuery                = L"Select StartingAddress, Name FROM Win32_PortResource WHERE ";
    
    //  Other Query Strings
    CComBSTR                            bstrNetworkAdapterConfigurationQueryString;
    CComBSTR                            bstrAllocatedResourceQueryString;
    CComBSTR                            bstrPortResourceQueryString;

    //  Other  Strings
    CComBSTR                            bstrPropertyAntecedent = L"antecedent";
    CComBSTR                            bstrPropertyName = L"Name";
    CComBSTR                            bstrIndex = L"Index";
    CComBSTR                            bstrDeviceID = L"DeviceID";
    CComBSTR                            bstrResult;

    //  SystemTime
    SYSTEMTIME                          stUTCTime;

    //  Integers 
    int                                 i;
    int                                 nIRQLen;
    int                                 nIter;

    //  Pattern Strings
    LPCSTR                               strIRQPattern                 = "Win32_IRQResource.IRQNumber=";
    LPCSTR                               strPortPattern                = "Win32_PortResource.StartingAddress=";
    LPCSTR                               strPortPattern2               = "Win32_PortResource.";

    //  Chars
    LPSTR                                strSource;
    LPSTR                                pDest;

    BOOL                                 fValidInt;

    //  End  Declarations...................................................

    //  Should take care of memory allocation failure for CComBSTRs


    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);
    
    //
    // Execute the query to get "AdapterType", "DeviceID", "Name" and "Index"
    // from Win32_NetworkAdapter Class.
    
    // "Index" is required as it is the common property between
    // Win32_NetworkAdapter and Win32_NetworkAdapterConfiguration
    // pNetworkAdapterEnumInst contains a pointer to the list of instances returned.
    //
    hRes = ExecWQLQuery(&pNetworkAdapterEnumInst, bstrNetworkAdapterQuery);
    if (FAILED(hRes))
    {
        //  Cannot get any properties.
        goto END;
    }
    
    //  Query Succeeded!
    
    //  Enumerate the instances from pNetworkAdapterEnumInst.
    //  Get the next instance into pNetworkAdapterObj object.
    
    while(WBEM_S_NO_ERROR == pNetworkAdapterEnumInst->Next(WBEM_INFINITE, 1, &pNetworkAdapterObj, &ulNetworkAdapterRetVal))
    {

        //  Create a new instance of PCH_NetworkAdapter Class based on the passed-in MethodContext
        
        CInstancePtr pPCHNetworkAdapterInstance(CreateNewInstance(pMethodContext), false);

        //  Created a New Instance of PCH_NetworkAdapter Successfully.

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              TIME STAMP                                                                 //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = pPCHNetworkAdapterInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
        if (FAILED(hRes))
        {
            //  Could not Set the Time Stamp
            //  Continue anyway
                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              CHANGE                                                                     //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = pPCHNetworkAdapterInstance->SetCHString(pChange, L"Snapshot");
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }

        //  Copy the following properties from win32_NetworkAdapter class Instance 
        //  TO PCH_NetworkAdapter class Instance.

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              ADAPTERTYPE                                                                //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        CopyProperty(pNetworkAdapterObj, L"AdapterType", pPCHNetworkAdapterInstance, pAdapterType);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              DEVICEID                                                                   //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        CopyProperty(pNetworkAdapterObj, L"DeviceID", pPCHNetworkAdapterInstance, pDeviceID);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              PRODUCTNAME                                                                //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        CopyProperty(pNetworkAdapterObj, L"ProductName", pPCHNetworkAdapterInstance, pProductName);

        /*

        Because of Bug : 100158 , regarding dropping all the privacy related properties, 
        the foll. properties need to be dropped :

        ServiceName, IPAddress, IPSubnet, DefaultIPGateway,  MACAddress

        */



        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              INDEX                                                                      //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            
        //  Get the "Index" property from the current instance Object
        //  Index is the common property between NetworkAdapter and NetworkAdapterConfiguration.

        hRes = pNetworkAdapterObj->Get(bstrIndex, 0, &varIndex, NULL, NULL);
        if (FAILED(hRes))
        {
            //  Cannot get index.
            //  Without Index Cannot get any properties from Win32_NetworkAdapterConfiguration Class
                ErrorTrace(TRACE_ID, "GetVariant on Index Field failed.");
        }
        else 
        {
            //  Got the index. Now we are ready to get the properties from Win32_NetworkAdapterConfiguration Class
            //  With "index" as the key get the corresponding NetworkAdapterConfiguration instance
            //   Make Sure Index is of Type VT_I4 i.e. long
            //   Convert the Index to type VT_I4 
            hRes = varIndex.ChangeType(VT_I4, NULL);
            if FAILED(hRes)
            {
                //  Not of type VT_I4 So there is no way to get the Corresponding 
                //  NetworkAdapter Configuration instance
            }
            else
            {
                //  index of expected Type. Get the corr. NetworkAdapterConfiguration instance

                //  Append the "index" to the Query String

                bstrNetworkAdapterConfigurationQueryString =  bstrNetworkAdapterConfigurationQuery;

                //  Change varIndex to BSTR type so that it can be appended
                varIndex.ChangeType(VT_BSTR, NULL);

                bstrNetworkAdapterConfigurationQueryString.Append(V_BSTR(&varIndex));

                //  Execute the query to get "ServiceName", "IPAddress", "IPSubnet", 
                //  "DefaultIPGateway", "DHCPEnabled", "MACAddress", "Index"
                //  from Win32_NetworkAdapter Configuration Class.

                //  pNetworkAdapterConfigurationEnumInst contains a pointer to the instance returned.

                hRes = ExecWQLQuery(&pNetworkAdapterConfigurationEnumInst,bstrNetworkAdapterConfigurationQueryString);
                if (FAILED(hRes))
                {
                    //  Query failed!! Cannot Copy Values.
                }
                else
                {
                    // Query Succeeded. Get the Instance Object
                    if (WBEM_S_NO_ERROR == pNetworkAdapterConfigurationEnumInst->Next(WBEM_INFINITE, 1, &pNetworkAdapterConfigurationObj, &ulNetworkAdapterConfigurationRetVal))
                    {
                        //  Copy the following properties from win32_NetworkAdapterConfiguration 
                        //  class Instance TO PCH_NetworkAdapter class Instance.

                        /*

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              SERVICENAME                                                                //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"ServiceName", pPCHNetworkAdapterInstance, pServiceName);

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              IPADDRESS                                                                  //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"IPAddress", pPCHNetworkAdapterInstance, pIPAddress);

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              IPSUBNET                                                                   //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"IPSubnet", pPCHNetworkAdapterInstance, pIPSubnet);

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DEFAULTIPGATEWAY                                                           //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"DefaultIPGateway", pPCHNetworkAdapterInstance, pDefaultIPGateway);

                        */

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DHCPENABLED                                                                //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"DHCPEnabled", pPCHNetworkAdapterInstance, pDHCPEnabled);

                        /*

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              MACADDRESS                                                                //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        CopyProperty(pNetworkAdapterConfigurationObj, L"MACAddress", pPCHNetworkAdapterInstance, pMACAddress);

                        */

                        
                    } //end of if pNetworkAdapterConfigurationEnumInst....


                } // end of else query succeeded

                
            } // end of else got the index

        } // end of else got the index

        

        //  Get the resources from Win32_AllocatedResource

        //  Update the Query String with the Device ID Property.
        bstrAllocatedResourceQueryString = bstrAllocatedResourceQuery;

        hRes = pNetworkAdapterObj->Get(bstrDeviceID, 0, &varDeviceID, NULL, NULL);

        if (FAILED(hRes))
        {
            //  Current Instance object no longer required.
            //  hRes = pNetworkAdapterObj->Release();
            if (FAILED(hRes))
            {
                //  Unable to realease the Object
                ErrorTrace(TRACE_ID, "GetVariant on DeviceID Field while calculating IRQ and PORT Resource failed!");
            }

            //                Cannot get DeviceID
            ErrorTrace(TRACE_ID, "GetVariant on DeviceID Field while calculating IRQ and PORT Resource failed!");

        } // end of cannot get the DeviceId 
        else 
        {

            //  Current Instance object no longer required.
            //  hRes = pNetworkAdapterObj->Release();
            if (FAILED(hRes))
            {
                //  Unable to realease the Object
                ErrorTrace(TRACE_ID, "GetVariant on DeviceID Field while calculating IRQ and PORT Resource failed!");
            }

            //  Got the DeviceID

            //  Convert the DeviceID to type VT_BSTR
            hRes = varDeviceID.ChangeType(VT_BSTR, NULL);
            if FAILED(hRes)
            {
                //  Cannot get the DeviceID value. So there is no way to get the Corresponding 
                //  IRQ and PORT Resources.
            } // end of FAILED hRes , Cannot get the DeviceID Value
            else
            {
                //  Got the DeviceID value.  Update the Query string with this value.
                _ASSERT(varDeviceID.vt == VT_BSTR);
                bstrAllocatedResourceQueryString.Append(V_BSTR(&varDeviceID));

                //  Append "///" to the QueryString.
                bstrAllocatedResourceQueryString.Append("\\\"\"");

                //  The Query string is formed, get the antecedent instances
                //  Added the following line because you need to clear the CComPtr before you query the second time.
                pAllocatedResourceEnumInst = NULL;
                hRes = ExecWQLQuery(&pAllocatedResourceEnumInst, bstrAllocatedResourceQueryString); 
                if (FAILED(hRes))
                {
                    //  Query failed!! Cannot get the Resources.
                    //  Continue anyway
                }
                else
                {
                    //  Get the "antecedent" value.  

                    //  Query Succeeded. Get the Instance Object
                    //  Get all the instances of Win32_AllocatedResource applicable
                    while(WBEM_S_NO_ERROR == pAllocatedResourceEnumInst->Next(WBEM_INFINITE, 1, &pAllocatedResourceObj, &ulAllocatedResourceRetVal))
                    {
                        hRes = pAllocatedResourceObj->Get(bstrPropertyAntecedent, 0, &varAntecedent, NULL, NULL);
                        if (FAILED(hRes))
                        {
                            //  Could not get the antecedent
                            ErrorTrace(TRACE_ID, "GetVariant on Win32_AllocatedResource:Antecedent Field failed.");
                        } //end of if FAILED(pAllocatedResourceObj->Get..antecedent
                        else
                        {
                            //  Got the antecedent

                            // varAntecedent set to antecedent. Copy this to bstrResult
                            varAntecedent.ChangeType(VT_BSTR, NULL);

                            {
                                USES_CONVERSION;
                                strSource = OLE2A(varAntecedent.bstrVal);
                            }

                            //  Check if it is IRQ Resource by comparing with the known pattern of IRQ Resource
                            pDest = strstr(strSource,strIRQPattern);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              IRQ Number                                                                 //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            if(pDest != NULL)
                            {

                                //  This is IRQ Resource instance
                                //  Can get the IRQ Number

                                //  Advance the pointer to the end of the pattern so the pointer is 
                                //  positioned at IRQ Number
                                pDest += lstrlen(strIRQPattern);

                                // First verify that the given string is a valid integer.
                                nIRQLen = lstrlen(pDest);
                                fValidInt = TRUE;

                                for(nIter = 0; nIter <nIRQLen; nIter++)
                                {
                                    if (_istdigit(pDest[nIter]) == 0)
                                    {
                                        fValidInt = FALSE;
                                        break;
                                    }
                                }

                                if(fValidInt)
                                {
                                    // Convert the IRQ Number that you get as string to a long

                                    varIRQNumber = atol(pDest);

                                    //  Set the IRQ Number as a variant
                                    hRes = pPCHNetworkAdapterInstance->SetVariant(pIRQNumber, varIRQNumber);
                                    if (!hRes)
                                    {
                                        ErrorTrace(TRACE_ID, "SetVariant on win32_AllocatedResource.IRQ Number Failed!");
                                        //  Proceed Anyway
                                    }
                                }
                            } // end of if pDest != NULL
                            else
                            {
                                //                                    This is not IRQ Resource
                            }  // end of else pDest != NULL

                            //  Check if it is PORT Resource
                            pDest = strstr(strSource,strPortPattern);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              PORTRESOURCE                                                               //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            if(pDest != NULL)
                            {
                                //  This is PORT Resource instance
                                //  Can get the PORT Resource Starting Address

                                //  Advance the pointer to the end of the pattern so the pointer is 
                                //  positioned at "Win32_PortResource...." Portion
                                pDest += lstrlen(strPortPattern2);

                                //  Formulate the Query String
                                bstrPortResourceQueryString =  bstrPortResourceQuery;
                                bstrPortResourceQueryString.Append(pDest);

                                // At this point the WQL Query can be used to get the win32_portResource Instance.
                                hRes = ExecWQLQuery(&pPortResourceEnumInst, bstrPortResourceQueryString);
                                if (FAILED(hRes))
                                {
                                    //  Query failed!! Cannot get the PORT Resources.
                                    //  Continue anyway!
                                }
                                else
                                {
                                    //  Query Succeeded. Get the Instance Object
                                    if(WBEM_S_NO_ERROR == pPortResourceEnumInst->Next(WBEM_INFINITE, 1, &pPortResourceObj, &ulPortResourceRetVal))
                                    {

                                        //  Get the Name 

                                        hRes = pPortResourceObj->Get(bstrPropertyName, 0, &varName, NULL, NULL);
                                        if (FAILED(hRes))
                                        {
                                            //  Could not get the Name
                                            ErrorTrace(TRACE_ID, "GetVariant on Win32_PortResource: Field failed.");
                                        } //end of if FAILED(pPortResourceObj->Get..Name
                                        else
                                        {
                                            //  Got the Name
                                            //  This is the PORT Address. Set the Value
                                            if (!pPCHNetworkAdapterInstance->SetVariant(pIOPort, varName))
                                            {
                                                ErrorTrace(TRACE_ID, "SetVariant on win32_AllocatedResource.PortAddress Failed!");
                                            }
                                            else
                                            {
                                                //  Port Address is set.
                                            }
                                        } // end of else FAILED(pPortResourceObj->Get..Name

                                        //  Got the Name. Nothing more to do.  
                                        
                                    } //end of if WBEM_S_NO_ERROR
                                    else
                                    {
                                        //  Cannot get the Instance Object
                                        //  Cannot get the PORT Adresses.
                                    } //end of else WBEM_S_NO_ERROR

                                    
                                } //end of else FAILED(hRes)

                            } //end of if pDest!= NULL
                            else
                            {
                                //  Not a PORT Resource Instance
                            } //end of else pDest!= NULL

                        } ////end of else FAILED(pAllocatedResourceObj->Get..antecedent 

                        
                    }// end of while pAllocatedResourceEnumInst....

                } // end of else FAILED(hRes) got the Antecedent Value

                
            } // end of else FAILED(hRes) , got the DeviceID Value

        } // end of else got the DeviceID

        //  Get the resources from Win32_AllocatedResource END 

        //  All the properties in pPCHNetworkAdapterInstance are set

        hRes = pPCHNetworkAdapterInstance->Commit();
        if (FAILED(hRes))
        {
            //  Cannot commit the Instance
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        } // end of if FAILED(hRes)

    } //end of while pEnumInst....

END :
      TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_module.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Module.CPP

Abstract:
	WBEM provider class implementation for PCH_Module class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

    Jim Martin          (a-jammar) 05/20/99
        - Populated data fields.

********************************************************************/

#include "pchealth.h"
#include "PCH_Module.h"
#include <tlhelp32.h>

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_MODULE

CPCH_Module MyPCH_ModuleSet (PROVIDER_NAME_PCH_MODULE, PCH_NAMESPACE) ;

// Property names
//===============

const static WCHAR * pAddress = L"Address" ;
const static WCHAR * pTimeStamp = L"TimeStamp" ;
const static WCHAR * pChange = L"Change" ;
const static WCHAR * pDate = L"Date" ;
const static WCHAR * pDescription = L"Description" ;
const static WCHAR * pManufacturer = L"Manufacturer" ;
const static WCHAR * pName = L"Name" ;
const static WCHAR * pPartOf = L"PartOf" ;
const static WCHAR * pPath = L"Path" ;
const static WCHAR * pSize = L"Size" ;
const static WCHAR * pType = L"Type" ;
const static WCHAR * pVersion = L"Version" ;

//-----------------------------------------------------------------------------
// The CModuleCollection class is used to gather all of the running modules.
// They can be found from the CIM_ProcessExecutable class, as the Antecedent
// property, with the following caveat: this enumeration will include 
// duplicate entries of the same file (it will have a copy of a DLL for each
// time it's been loaded). This class will remove the duplicates, and save
// a list of filenames which can then be queried.
//-----------------------------------------------------------------------------

class CModuleCollection
{
public:
    CModuleCollection();
    ~CModuleCollection();

    HRESULT Create(IEnumWbemClassObject * pEnum);
    BOOL    GetInstance(DWORD dwIndex, LPWSTR * pszFile);

private:
    struct SModule
    {
        LPWSTR      m_szFilename;
        SModule *   m_pNext;

        SModule(LPWSTR szFilename, SModule * pNext) : m_pNext(pNext) { m_szFilename = szFilename; }
        ~SModule() { delete m_szFilename; }
    };

    SModule * m_pList;
    SModule * m_pLastQueriedItem;
    DWORD     m_dwLastQueriedIndex;
};

//-----------------------------------------------------------------------------
// The constructor and destructor are simple.
//-----------------------------------------------------------------------------

CModuleCollection::CModuleCollection() 
: m_pList(NULL), 
  m_pLastQueriedItem(NULL), 
  m_dwLastQueriedIndex(0)
{}

CModuleCollection::~CModuleCollection()
{
    TraceFunctEnter("CModuleCollection::~CModuleCollection");

    while (m_pList)
    {
        SModule * pNext = m_pList->m_pNext;
        delete m_pList;
        m_pList = pNext;
    }

    TraceFunctLeave();
}

//-----------------------------------------------------------------------------
// The Create method creates the list of module names based on the enumerator
// passed in (which is assumed to enumerate Antecedents in 
// CIM_ProcessExecutable).
//-----------------------------------------------------------------------------

HRESULT CModuleCollection::Create(IEnumWbemClassObject * pEnum)
{
    TraceFunctEnter("CModuleCollection::Create");
   
    HRESULT             hRes = S_OK;
    IWbemClassObjectPtr pObj;
    ULONG               ulRetVal;
    CComVariant         varValue;
    CComBSTR            bstrFile("Antecedent");

    while (WBEM_S_NO_ERROR == pEnum->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        if (FAILED(pObj->Get(bstrFile, 0, &varValue, NULL, NULL)))
            ErrorTrace(TRACE_ID, "Get on Antecedent field failed.");
        else
        {
            // We need to convert the string from a BSTR to a LPCTSTR,
            // and to only include the file part (without the WMI part).
            // So we need to scan through the string until an '=' is
            // found, then use the rest (minus enclosing quote marks)
            // as the file path.

            CComBSTR ccombstrValue(V_BSTR(&varValue));
            UINT     i = 0, uLen = SysStringLen(ccombstrValue);

            // Scan to the '='.

            while (i < uLen && ccombstrValue[i] != L'=')
                i++;

            // Skip over the '=' and any quotes.

            while (i < uLen && (ccombstrValue[i] == L'=' || ccombstrValue[i] == L'"'))
                i++;

            // Allocate a character buffer and copy the string, converting it to
            // lower case (to make comparisons faster later on).

            LPWSTR szFilename = new WCHAR[uLen - i + 1];
            if (!szFilename)
            {
                ErrorTrace(TRACE_ID, "CModuleCollection::Create out of memory");
                throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
            }

            for (int j = 0; i < uLen; j++, i++)
                szFilename[j] = towlower(ccombstrValue[i]);

            // Terminate the string - if it ends with a quote, overwrite that with a 
            // null character.

            if (j && szFilename[j - 1] == L'"')
                j -= 1;
            szFilename[j] = L'\0';

            // Check to see if this module is already in the list of strings.

            SModule * pScan = m_pList;
            while (pScan)
            {
                if (wcscmp(szFilename, pScan->m_szFilename) == 0)
                    break;
                pScan = pScan->m_pNext;
            }

            if (pScan == NULL)
            {
                // We reached the end of the list without finding a duplicate.
                // Add the new string to the list of modules, which will be responsible for
                // deallocating the string.

                SModule * pNew = new SModule(szFilename, m_pList);
                if (!pNew)
                {
                    delete [] szFilename;
                    ErrorTrace(TRACE_ID, "CModuleCollection::Create out of memory");
                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                }

                m_pList = pNew;
            }
            else
                delete [] szFilename;
        }
    }

    // Set the queried item pointer to the start of the list.

    m_pLastQueriedItem = m_pList;
    m_dwLastQueriedIndex = 0;
    
    TraceFunctLeave();
    return hRes;
}

//-----------------------------------------------------------------------------
// Get the instance of module string referenced by the index. This is stored
// internally as a linked list, but we'll cache a pointer for the last
// referenced dwIndex to improve performance if the dwIndex is iterated
// sequentially. Return TRUE and set pszFile to point to the string if
// it exists, otherwise return FALSE.
//-----------------------------------------------------------------------------

BOOL CModuleCollection::GetInstance(DWORD dwIndex, LPWSTR * pszFile)
{
    TraceFunctEnter("CModuleCollection::GetInstance");

    // If the call is for an index less than the last queried index (which
    // should be rare), we need to scan from the start of the list.

    if (dwIndex < m_dwLastQueriedIndex)
    {
        m_dwLastQueriedIndex = 0;
        m_pLastQueriedItem = m_pList;
    }

    // Scan through the list by (dwIndex - m_dwLastQueriedIndex) items.

    while (dwIndex > m_dwLastQueriedIndex && m_pLastQueriedItem)
    {
        m_pLastQueriedItem = m_pLastQueriedItem->m_pNext;
        m_dwLastQueriedIndex += 1;
    }

    BOOL fResult = FALSE;
    if (m_pLastQueriedItem)
    {
        *pszFile = m_pLastQueriedItem->m_szFilename;
        fResult = TRUE;
    }

    TraceFunctLeave();
    return fResult;
}


/*****************************************************************************
*
*  FUNCTION    :    CPCH_Module::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/

typedef HANDLE (*CTH32)(DWORD, DWORD);

HRESULT CPCH_Module::EnumerateInstances(MethodContext * pMethodContext, long lFlags)
{
    TraceFunctEnter("CPCH_Module::EnumerateInstances");
    HRESULT hRes = WBEM_S_NO_ERROR;

    // Get the date and time

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // Create a toolhelp snapshot to get process information. We need to dynamically
    // link to the function, because it might not be present on all platforms.


    // The CModuleCollection class gathers a list of module names (which can then
    // be used to retrieve information about each file). 

    CFileVersionInfo  fileversioninfo;
    CModuleCollection moduleinfo;
    LPWSTR            szFile;
    DWORD             dwIndex;

    CComPtr<IEnumWbemClassObject> pEnum;
    hRes = ExecWQLQuery(&pEnum, CComBSTR("SELECT Antecedent FROM CIM_ProcessExecutable"));
    if (FAILED(hRes))
        goto END;

    hRes = moduleinfo.Create(pEnum);
    if (FAILED(hRes))
        goto END;

    // Iterate through all of the module instances.

    for (dwIndex = 0; moduleinfo.GetInstance(dwIndex, &szFile); dwIndex++)
    {
        if (!szFile)
            continue;

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        // Set the change and timestamp fields to "Snapshot" and the current time.

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change field failed.");

        // Using the filename, get the CIM_DataFile object.

        CComPtr<IWbemClassObject>   pFileObj;
        CComBSTR                    ccombstrValue(szFile);
        if (SUCCEEDED(GetCIMDataFile(ccombstrValue, &pFileObj, TRUE)))
        {
            // Using the CIM_DataFile object, copy over the appropriate properties.

            CopyProperty(pFileObj, L"Version", pInstance, pVersion);
            CopyProperty(pFileObj, L"FileSize", pInstance, pSize);
            CopyProperty(pFileObj, L"CreationDate", pInstance, pDate);
            CopyProperty(pFileObj, L"Name", pInstance, pPath);
            CopyProperty(pFileObj, L"EightDotThreeFileName", pInstance, pName);
            CopyProperty(pFileObj, L"Manufacturer", pInstance, pManufacturer);
        }

		else
		{
			CComBSTR	bstr;
			VARIANT		var;
			WCHAR		*pwsz;
			
			// parse the file path to get the name out of it... 
			//  the name should obviously be the last thing on the path, so 
			//  search back from the end until we find a '\'.  At that point, 
			//  we've got the filename...
			pwsz = ccombstrValue.m_str + SysStringLen(ccombstrValue.m_str) - 1;
			while(pwsz >= ccombstrValue.m_str)
			{
				if (*pwsz == L'\\')
				{
					pwsz++;
					break;
				}
				pwsz--;
			}

			bstr = pwsz;

			VariantInit(&var);
			V_VT(&var)   = VT_BSTR;
			V_BSTR(&var) = bstr.m_str;
			if (pInstance->SetVariant(pName, var) == FALSE)
				ErrorTrace(TRACE_ID, "SetVariant on name field failed.");
		}

        if (SUCCEEDED(fileversioninfo.QueryFile(szFile, TRUE)))
        {
            if (!pInstance->SetCHString(pDescription, fileversioninfo.GetDescription()))
                ErrorTrace(TRACE_ID, "SetCHString on description field failed.");

            if (!pInstance->SetCHString(pPartOf, fileversioninfo.GetProduct()))
                ErrorTrace(TRACE_ID, "SetCHString on partof field failed.");
        }


    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
    }

END:
    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_driver.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Driver.H

Abstract:
	WBEM provider class definition for PCH_Driver class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Driver_H_
#define _PCH_Driver_H_

#define PROVIDER_NAME_PCH_DRIVER "PCH_Driver"

#include <list>

// Property name externs -- defined in PCH_Driver.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pLoadedFrom ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pPartOf ;
extern const WCHAR* pPath ;
extern const WCHAR* pSize ;
extern const WCHAR* pType ;
extern const WCHAR* pVersion ;

typedef struct _DRIVER_KERNEL
{
    TCHAR   strDriver[MAX_PATH];
    TCHAR   strVersion[MAX_PATH];
    TCHAR   strManufacturer[MAX_PATH];
    TCHAR   strDescription[MAX_PATH];
    TCHAR   strLikelyPath[MAX_PATH];
    TCHAR   strLoadedFrom[MAX_PATH];
    TCHAR   strType[MAX_PATH];
    TCHAR   strPartOf[MAX_PATH];
    struct _DRIVER_KERNEL *next;
} DRIVER_KERNEL;

typedef struct _DRIVER_MS_DOS
{
    TCHAR   strName[MAX_PATH];
    TCHAR   strType[MAX_PATH];
    WORD    seg;
} DRIVER_MS_DOS;

typedef struct _DRIVER_USER_MODE
{
    TCHAR   strDriver[MAX_PATH];
    TCHAR   strVersion[MAX_PATH];
    TCHAR   strManufacturer[MAX_PATH];
    TCHAR   strDescription[MAX_PATH];
    TCHAR   strPath[MAX_PATH];
    TCHAR   strType[MAX_PATH];
    TCHAR   strPartOf[MAX_PATH];
} DRIVER_USER_MODE;

class CPCH_Driver : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

        CPCH_Driver(const CHString& chsClassName, LPCWSTR lpszNameSpace) : 
                Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Driver() {};


	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_programgroup.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_ProgramGroup.CPP

Abstract:
    WBEM provider class implementation for PCH_ProgramGroup class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Ghim-Sim Chua       (gschua)   05/02/99
        - Modified code to use CopyProperty function
        - Use CComBSTR instead of USES_CONVERSION

********************************************************************/

#include "pchealth.h"
#include "PCH_ProgramGroup.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PROGRAMGROUP

CPCH_ProgramGroup MyPCH_ProgramGroupSet (PROVIDER_NAME_PCH_PROGRAMGROUP, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pGroupName = L"GroupName" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pUsername = L"Username" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ProgramGroup::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here.
*                       If there are no instances,  WBEM_S_NO_ERROR is returned.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ProgramGroup::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ProgramGroup::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;
    CComPtr<IEnumWbemClassObject>       pEnumInst;
    IWbemClassObjectPtr                 pObj;
    ULONG                               ulRetVal;

    // Get the date and time

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // Execute the query

    hRes = ExecWQLQuery(&pEnumInst, CComBSTR("select GroupName, Name, UserName from Win32_ProgramGroup"));
    if (FAILED(hRes))
        goto END;

    // enumerate the instances from win32_CodecFile

    while (WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        // Create a new instance based on the passed-in MethodContext. If this fails,
        // we don't need to check for a null pointer because it throws an exception.

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        CComVariant  varValue;

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        (void)CopyProperty(pObj, L"GroupName", pInstance, pGroupName);
        (void)CopyProperty(pObj, L"Name", pInstance, pName);
        (void)CopyProperty(pObj, L"UserName", pInstance, pUsername);

    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
    }

END:
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_printjob.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_PrintJob.H

Abstract:
	WBEM provider class definition for PCH_PrintJob class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_PrintJob_H_
#define _PCH_PrintJob_H_

#define PROVIDER_NAME_PCH_PRINTJOB "PCH_PrintJob"

// Property name externs -- defined in PCH_PrintJob.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pName ;
extern const WCHAR* pPagesPrinted ;
extern const WCHAR* pSize ;
extern const WCHAR* pStatus ;
extern const WCHAR* pTimeSubmitted ;

class CPCH_PrintJob : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_PrintJob(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_PrintJob() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_programgroup.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ProgramGroup.H

Abstract:
	WBEM provider class definition for PCH_ProgramGroup class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ProgramGroup_H_
#define _PCH_ProgramGroup_H_

#define PROVIDER_NAME_PCH_PROGRAMGROUP "PCH_ProgramGroup"

// Property name externs -- defined in PCH_ProgramGroup.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pGroupName ;
extern const WCHAR* pName ;
extern const WCHAR* pUsername ;

class CPCH_ProgramGroup : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ProgramGroup(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ProgramGroup() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_fileupload.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_FileUpload.CPP

Abstract:
	WBEM provider class implementation for PCH_FileUpload class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/
#include "pchealth.h"
#include "PCH_FileUpload.h"
#include "mpc_utils.h"

// MAX_FILE_SIZE is the limit set on the maximum file size of text files that will be collected.
// If the Filesize is larger than 262144 then the data property is not populated. 
// This Number is arrived at by the PM.
#define     MAX_FILE_SIZE                   262144

#define     READONLY                        "READONLY  "  
#define     HIDDEN                          "HIDDEN  "
#define     SYSTEM                          "SYSTEM  "
#define     DIRECTORY                       "DIRECTORY  "
#define     ARCHIVE                         "ARCHIVE  "
#define     NORMAL                          "NORMAL  "
#define     TEMPORARY                       "TEMPORARY  "
#define     REPARSEPOINT                    "REPARSEPOINT  "
#define     SPARSEFILE                      "SPARSEFILE  "
#define     COMPRESSED                      "COMPRESSED  "
#define     OFFLINE                         "OFFLINE  "
#define     ENCRYPTED                       "ENCRYPTED  "

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_FILEUPLOAD

CPCH_FileUpload MyPCH_FileUploadSet (PROVIDER_NAME_PCH_FILEUPLOAD, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pData = L"Data" ;
const static WCHAR* pDateAccessed = L"DateAccessed" ;
const static WCHAR* pDateCreated = L"DateCreated" ;
const static WCHAR* pDateModified = L"DateModified" ;
const static WCHAR* pFileAttributes = L"FileAttributes" ;
const static WCHAR* pPath = L"Path" ;
const static WCHAR* pSize = L"Size" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_FileUpload::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  WinMgmt will post - 
*                   filter the query for you, so you may return more instances 
*                   or more properties than are requested and WinMgmt 
*                   will filter out any that do not apply.
*
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.
*
*****************************************************************************/

HRESULT CPCH_FileUpload::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{

    TraceFunctEnter("CPCH_FileUpLoad::ExecQuery");

    HRESULT                             hRes;
    HANDLE                              hFile;

    CHStringArray                       chstrFiles;

    TCHAR                               tchFileName[MAX_PATH];
    TCHAR                               tchRootDir[MAX_PATH];
    TCHAR                               tchWindowsDir[MAX_PATH];

    WIN32_FIND_DATA                     FindFileData;
    // CInstance                           *pPCHFileUploadInstance;
    SYSTEMTIME                          stUTCTime;

    BOOL                                fTimeStamp;
    BOOL                                fChange;
    BOOL                                fData;
    BOOL                                fDateAccessed;
    BOOL                                fDateCreated;
    BOOL                                fDateModified;
    BOOL                                fFileAttributes;
    BOOL                                fSize;
    BOOL                                fCommit;
    BOOL                                fFileRead           = FALSE;
    BOOL                                fFileFound          = FALSE;
    BOOL                                fNoData             = TRUE;

    CComVariant                         varAttributes;
    CComVariant                         varSize;
    CComVariant                         varRequestedFileName;
    CComVariant                         varSnapshot         = "SnapShot";
    CComVariant                         varData;

    ULARGE_INTEGER                      ulnFileSize;
    WBEMINT64                           wbemulnFileSize;

    char                                *pbBuffer;
    WCHAR                               *pwcBuffer;
    
    DWORD                               dwDesiredAccess     = GENERIC_READ;
    DWORD                               dwNumBytesRead;
    DWORD                               dwAttributes;

    BSTR                                bstrData;

    CComBSTR                            bstrFileName;
    CComBSTR                            bstrFileNameWithPath;
    CComBSTR                            bstrKey             = L"Path";

    int                                 nBufferSize;
    int                                 nFilesRequested             = 0;
    int                                 nIndex;
    int                                 nFileSize;
    int                                 nRetChars;

    TCHAR                               tchAttributes[MAX_PATH];

    //  
    std::tstring                        szEnv;

    //  End Declarations
    GetSystemTime(&stUTCTime);

    hRes = WBEM_S_NO_ERROR;
    hRes = Query.GetValuesForProp(bstrKey, chstrFiles);
    if(FAILED(hRes))
    {
        goto END;
    }
    else
    {
        fTimeStamp      = Query.IsPropertyRequired(pTimeStamp);
        fChange         = Query.IsPropertyRequired(pChange);
        fData           = Query.IsPropertyRequired(pData);
        fDateAccessed   = Query.IsPropertyRequired(pDateAccessed);
        fDateCreated    = Query.IsPropertyRequired(pDateCreated);
        fDateModified   = Query.IsPropertyRequired(pDateModified);
        fFileAttributes = Query.IsPropertyRequired(pFileAttributes);
        fSize           = Query.IsPropertyRequired(pSize);

        nFilesRequested = chstrFiles.GetSize();
        for (nIndex = 0; nIndex < nFilesRequested; nIndex++)
        {
            USES_CONVERSION;
            varRequestedFileName = chstrFiles[nIndex];
            bstrFileName = chstrFiles[nIndex];
            szEnv = W2T(chstrFiles[nIndex]);
            hRes = MPC::SubstituteEnvVariables(szEnv);
            if(SUCCEEDED(hRes))
            {
                //  Found the file
                _tcscpy(tchFileName, szEnv.c_str());
                hFile = FindFirstFile(tchFileName, &FindFileData); 
                if(hFile != INVALID_HANDLE_VALUE)
                {
                    //  Close the File Handle
                    FindClose(hFile);
                
                    //  Create the Fileupload Instance
                    //  Create an instance of PCH_Startup 
                    CInstancePtr pPCHFileUploadInstance(CreateNewInstance(pMethodContext), false);
                                        

                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    //                              PATH                                                                       //
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                    hRes = pPCHFileUploadInstance->SetVariant(pPath, varRequestedFileName);
                    if(SUCCEEDED(hRes))
                    {
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              SIZE                                                                       //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
                        ulnFileSize.LowPart = FindFileData.nFileSizeLow;
                        ulnFileSize.HighPart = FindFileData.nFileSizeHigh;
                        if(ulnFileSize.HighPart > 0)
                        {
                            //  File Size too large don't populate the Data field.
                            fNoData = TRUE;
                        }
                        else if(ulnFileSize.LowPart > MAX_FILE_SIZE)
                        {
                            //   File Size Exceeds the set limit
                            fNoData = TRUE;
                        }
                        else
                        {
                            fNoData = FALSE;
                            nFileSize = ulnFileSize.LowPart;
                        }
                        if(fSize)
                        {
                            hRes = pPCHFileUploadInstance->SetWBEMINT64(pSize,ulnFileSize.QuadPart);
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Time Stamp
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetVariant on Size Field failed.");
                            }
                        }

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DATA                                                                       //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        if(fData)
                        {
                            if(!fNoData)
                            {
                                hFile = CreateFile(tchFileName, GENERIC_READ, 0, 0, OPEN_EXISTING,  0, NULL);
                                if(hFile != INVALID_HANDLE_VALUE)
                                {
                                    //  Allocate the memory for the buffer
                                    pbBuffer        = new char[nFileSize];
                                    if (pbBuffer != NULL)
                                    {
                                        try
                                        {
                                            fFileRead = ReadFile(hFile, pbBuffer, nFileSize,  &dwNumBytesRead, NULL);
                                            if(fFileRead)
                                            {
                                                pwcBuffer    = new WCHAR[nFileSize];
                                                if (pwcBuffer != NULL)
                                                {
                                                    try
                                                    {
                                                        nRetChars =  MultiByteToWideChar(CP_ACP, 0, (const char *)pbBuffer, nFileSize, pwcBuffer, nFileSize);
                                                        if(nRetChars != 0)
                                                        {
                                                            //  MultiByteToWideChar succeeds
                                                            //  Copy the byte buffer into BSTR
                                                            bstrData = SysAllocStringLen(pwcBuffer, nFileSize);  
                                                            varData = bstrData;
                                                            SysFreeString(bstrData);
                                                            hRes = pPCHFileUploadInstance->SetVariant(pData,varData);
                                                            if(FAILED(hRes))
                                                            {
                                                                //  Could not Set the Time Stamp
                                                                //  Continue anyway
                                                                ErrorTrace(TRACE_ID, "SetVariant on Data Field failed.");
                                                            }
                                                        }
                                                    }
                                                    catch(...)
                                                    {
                                                        delete [] pwcBuffer;
                                                        throw;
                                                    }
                                                    delete [] pwcBuffer;
                                                }
                                                else
                                                {
                                                    //  Cannot allocate pwcBuffer
                                                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                                                }
                                            }
                                        }
                                        catch(...)
                                        {
                                            CloseHandle(hFile);
                                            delete [] pbBuffer;
                                            throw;
                                        }
                                    }
                                    else
                                    {
                                        //  Cannot allocate pwcBuffer
                                        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                                    }
                                    CloseHandle(hFile);
                                }
                            }
                        }


                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              TIMESTAMP                                                                  //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        if(fTimeStamp)
                        {
                            hRes = pPCHFileUploadInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Time Stamp
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
                            }
                        }

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              CHANGE                                                                     //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        if(fChange)
                        {
                            hRes = pPCHFileUploadInstance->SetVariant(pChange, varSnapshot);
                            if (FAILED(hRes))
                            {
                                //Could not Set the CHANGE property
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "Set Variant on SnapShot Field failed.");
                            }
                        }

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DATEACCESSED                                                               //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //   ftLastAccessTime gives the last access time for the file.
                        if(fDateAccessed)
                        {
                            hRes = pPCHFileUploadInstance->SetDateTime(pDateAccessed, WBEMTime(FindFileData.ftLastAccessTime));
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Date Accessed
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetDateTime on DATEACCESSED Field failed.");
                            }
                        }

                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DATECREATED                                                                //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        if(fDateCreated)
                        {
                            hRes = pPCHFileUploadInstance->SetDateTime(pDateCreated, WBEMTime(FindFileData.ftCreationTime));
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Date Created
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetDateTime on DATECREATED Field failed.");
                            }
                        }


                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              DATEMODIFIED                                                               //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        
                        if(fDateModified)
                        {
                            hRes = pPCHFileUploadInstance->SetDateTime(pDateModified, WBEMTime(FindFileData.ftLastWriteTime));
                            if (FAILED(hRes))
                            {
                                //  Could not Set the Date Modified
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetDateTime on DateModified Field failed.");
                            }
                        }


                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        //                              FILEATTRIBUTES                                                             //
                        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                        if(fFileAttributes)
                        {
                            dwAttributes = FindFileData.dwFileAttributes;
                            tchAttributes[0] = 0;
                            //  Get the attributes as a string
                            if(dwAttributes & FILE_ATTRIBUTE_READONLY)
                            {
                                _tcscat(tchAttributes, READONLY);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_HIDDEN)
                            {
                                _tcscat(tchAttributes, HIDDEN);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_SYSTEM)
                            {
                                _tcscat(tchAttributes, SYSTEM);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
                            {
                                _tcscat(tchAttributes, DIRECTORY);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_ARCHIVE)
                            {
                                _tcscat(tchAttributes, ARCHIVE);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_NORMAL)
                            {
                                _tcscat(tchAttributes, NORMAL);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_TEMPORARY)
                            {
                                _tcscat(tchAttributes, TEMPORARY);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_COMPRESSED)
                            {
                                _tcscat(tchAttributes, COMPRESSED);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_ENCRYPTED)
                            {
                                _tcscat(tchAttributes, ENCRYPTED);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_OFFLINE)
                            {
                                _tcscat(tchAttributes, OFFLINE);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
                            {
                                _tcscat(tchAttributes, REPARSEPOINT);
                            }
                            if(dwAttributes & FILE_ATTRIBUTE_SPARSE_FILE)
                            {
                                _tcscat(tchAttributes, SPARSEFILE);
                            }
                            varAttributes = tchAttributes;

                            //  hRes = varAttributes.ChangeType(VT_BSTR, NULL);
                            //  if(SUCCEEDED(hRes))
                            //  {
                            hRes = pPCHFileUploadInstance->SetVariant(pFileAttributes, varAttributes);
                            if (FAILED(hRes))
                            {
                                //  Could not Set the File Attributes
                                //  Continue anyway
                                ErrorTrace(TRACE_ID, "SetVariant on FileAttributes Field failed.");
                            // }
                            }
                        }
                    
                        hRes = pPCHFileUploadInstance->Commit();
                        if(FAILED(hRes))
                        {
                            //  Could not Commit the instance
                            ErrorTrace(TRACE_ID, "Commit on PCHFileUploadInstance Failed");
                        }
                    }

                }
                            
            }
            
        }

    }
END:TraceFunctLeave();
    return (hRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_resourcedma.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceDMA.H

Abstract:
	WBEM provider class definition for PCH_ResourceDMA class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ResourceDMA_H_
#define _PCH_ResourceDMA_H_

#define PROVIDER_NAME_PCH_RESOURCEDMA "PCH_ResourceDMA"

// Property name externs -- defined in PCH_ResourceDMA.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pChannel ;
extern const WCHAR* pMask ;
extern const WCHAR* pName ;

class CPCH_ResourceDMA : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ResourceDMA(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ResourceDMA() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_resourceiorange.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceIORange.H

Abstract:
	WBEM provider class definition for PCH_ResourceIORange class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ResourceIORange_H_
#define _PCH_ResourceIORange_H_

#define PROVIDER_NAME_PCH_RESOURCEIORANGE "PCH_ResourceIORange"

// Property name externs -- defined in PCH_ResourceIORange.cpp
//=================================================

extern const WCHAR* pAlias ;
extern const WCHAR* pBase ;
extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDecode ;
extern const WCHAR* pEnd ;
extern const WCHAR* pMax ;
extern const WCHAR* pMin ;
extern const WCHAR* pName ;

class CPCH_ResourceIORange : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ResourceIORange(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ResourceIORange() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_oleregistration.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_OLERegistration.CPP

Abstract:
    WBEM provider class implementation for PCH_OLERegistration class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Jim Martin          (a-jammar) 05/14/99
        - Gathering data.

********************************************************************/

#include "pchealth.h"
#include "PCH_OLERegistration.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_OLEREGISTRATION

CPCH_OLERegistration MyPCH_OLERegistrationSet (PROVIDER_NAME_PCH_OLEREGISTRATION, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR * pCategory = L"Category" ;
const static WCHAR * pTimeStamp = L"TimeStamp" ;
const static WCHAR * pChange = L"Change" ;
const static WCHAR * pDate = L"Date" ;
const static WCHAR * pDescription = L"Description" ;
const static WCHAR * pObject = L"Object" ;
const static WCHAR * pProgramFile = L"ProgramFile" ;
const static WCHAR * pSize = L"Size" ;
const static WCHAR * pVersion = L"Version" ;

//-----------------------------------------------------------------------------
// The COLERegItem class encapsulates a single OLE Registration item, and is
// used to build a linked list of items. Note that the constructor is private,
// since the only way one of these is created is by the friend class
// COLEItemCollection.
//-----------------------------------------------------------------------------

#define CATEGORY_LEN        9
#define DESCRIPTION_LEN     128
#define OBJECT_LEN          128
#define PROGRAM_LEN         MAX_PATH

class COLEItemCollection;
class COLERegItem
{
    friend class COLEItemCollection;
private:
    TCHAR   m_szCategory[CATEGORY_LEN];
    TCHAR   m_szDescription[DESCRIPTION_LEN];
    TCHAR   m_szObject[OBJECT_LEN];
    TCHAR   m_szProgramFile[PROGRAM_LEN];

public:
    LPCTSTR GetCategory()       { return m_szCategory; };
    LPCTSTR GetDescription()    { return m_szDescription; };
    LPCTSTR GetObject()         { return m_szObject; };
    LPCTSTR GetProgramFile()    { return m_szProgramFile; };

private:
    COLERegItem();

    COLERegItem * m_pNext;
};

COLERegItem::COLERegItem()
{
    m_szCategory[0]     = _T('\0');
    m_szDescription[0]  = _T('\0');
    m_szObject[0]       = _T('\0');
    m_szProgramFile[0]  = _T('\0');
    m_pNext             = NULL;
}

//-----------------------------------------------------------------------------
// The COLEItemCollection class is used to gather all of the OLE Registration
// items (from the registry and INI file) when the object is constructed. The
// object is then used to iterate all of the items, returning COLERegItem
// pointers for each item found.
//-----------------------------------------------------------------------------

class COLEItemCollection
{
public:
    COLEItemCollection();
    ~COLEItemCollection();

    BOOL GetInstance(DWORD dwIndex, COLERegItem ** ppoleitem);

private:
    BOOL UpdateFromRegistry();
    BOOL UpdateFromINIFile();
    BOOL AddOLERegItem(LPCSTR szCategory, LPCSTR szDescription, LPCSTR szObject, LPCSTR szProgramFile);

    COLERegItem * m_pItemList;
    COLERegItem * m_pLastQueriedItem;
    DWORD         m_dwLastQueriedIndex;
};

//-----------------------------------------------------------------------------
// Build the internal list of OLE registration items. This is done by looking
// in the registry and in the INI file. Also set the m_pLastQueriedItem pointer
// to the first item in the list (this cached pointer is used to improve
// indexed lookup speed for iterated indices).
//
// The destructor just deletes the list.
//-----------------------------------------------------------------------------

COLEItemCollection::COLEItemCollection() : m_pItemList(NULL), m_dwLastQueriedIndex(0)
{
    TraceFunctEnter("COLEItemCollection::COLEItemCollection");

    // If UpdateFromRegistry fails, it would be because there isn't enough memory
    // to create more list items, so don't bother calling UpdateFromINIFile.

    if (UpdateFromRegistry())
        UpdateFromINIFile();

    m_pLastQueriedItem = m_pItemList;

    TraceFunctLeave();
}

COLEItemCollection::~COLEItemCollection()
{
    TraceFunctEnter("COLEItemCollection::~COLEItemCollection");

    while (m_pItemList)
    {
        COLERegItem * pNext = m_pItemList->m_pNext;
        delete m_pItemList;
        m_pItemList = pNext;
    }
    
    TraceFunctLeave();
}

//-----------------------------------------------------------------------------
// Get the instance of COLERegItem referenced by the index. This is stored
// internally as a linked list, but we'll cache a pointer for the last
// referenced dwIndex to improve performance if the dwIndex is iterated
// sequentially. Return TRUE and set ppoleitem to point to the instance if
// it exists, otherwise return FALSE.
//-----------------------------------------------------------------------------

BOOL COLEItemCollection::GetInstance(DWORD dwIndex, COLERegItem ** ppoleitem)
{
    TraceFunctEnter("COLEItemCollection::GetInstance");

    // If the call is for an index less than the last queried index (which
    // should be rare), we need to scan from the start of the list.

    if (dwIndex < m_dwLastQueriedIndex)
    {
        m_dwLastQueriedIndex = 0;
        m_pLastQueriedItem = m_pItemList;
    }

    // Scan through the list by (dwIndex - m_dwLastQueriedIndex) items.

    while (dwIndex > m_dwLastQueriedIndex && m_pLastQueriedItem)
    {
        m_pLastQueriedItem = m_pLastQueriedItem->m_pNext;
        m_dwLastQueriedIndex += 1;
    }

    BOOL fResult = FALSE;
    if (m_pLastQueriedItem)
    {
        *ppoleitem = m_pLastQueriedItem;
        fResult = TRUE;
    }

    TraceFunctLeave();
    return fResult;
}

//-----------------------------------------------------------------------------
// Insert a new item in the COLERegItem linked list.
//-----------------------------------------------------------------------------

BOOL COLEItemCollection::AddOLERegItem(LPCSTR szCategory, LPCSTR szDescription, LPCSTR szObject, LPCSTR szProgramFile)
{
    TraceFunctEnter("COLEItemCollection::AddOLERegItem");

    BOOL            fReturn = FALSE;
    COLERegItem *   pNewNode = new COLERegItem;

    if (pNewNode)
    {
        _tcsncpy(pNewNode->m_szCategory, szCategory, CATEGORY_LEN);
        _tcsncpy(pNewNode->m_szDescription, szDescription, DESCRIPTION_LEN);
        _tcsncpy(pNewNode->m_szObject, szObject, OBJECT_LEN);
        _tcsncpy(pNewNode->m_szProgramFile, szProgramFile, PROGRAM_LEN);

        pNewNode->m_pNext = m_pItemList;
        m_pItemList = pNewNode;
        fReturn = TRUE;
    }
    else
    {
        ErrorTrace(TRACE_ID, "COLEItemCollection::AddOLERegItem out of memory.");
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    }

    TraceFunctLeave();
    return fReturn;
}

//-----------------------------------------------------------------------------
// This method retrieves OLE object information from the registry and adds
// it to the list of objects. Note - this code is essentially lifted from the
// source code for the OLE Registration OCX in MSInfo 4.10.
//
// Changes were made to remove MFC dependencies.
//-----------------------------------------------------------------------------

BOOL COLEItemCollection::UpdateFromRegistry()
{
    TraceFunctEnter("COLEItemCollection::UpdateFromRegistry");
    BOOL fReturn = TRUE;

    // Fill in the information for the array of items. We do this by
    // looking in the registry under the HKEY_CLASSES_ROOT key and
    // enumerating all of the subkeys there.

    TCHAR     szCLSID[MAX_PATH];
    TCHAR     szObjectKey[OBJECT_LEN];
    TCHAR     szServer[PROGRAM_LEN];
    TCHAR     szTemp[MAX_PATH];
    TCHAR     szDescription[DESCRIPTION_LEN];
    DWORD     dwSize, dwType;
    FILETIME  filetime;
    HKEY      hkeyObject, hkeyServer, hkeyTest, hkeyCLSID, hkeySearch;
    BOOL      bInsertInList;

    for (DWORD dwIndex = 0; TRUE; dwIndex++)
    {
        dwSize = OBJECT_LEN;
        if (RegEnumKeyEx(HKEY_CLASSES_ROOT, dwIndex, szObjectKey, &dwSize, NULL, NULL, NULL, &filetime) != ERROR_SUCCESS)
            break;

        // Open the key for this object (we'll be using it a lot).

        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CLASSES_ROOT, szObjectKey, 0, KEY_READ, &hkeyObject))
            continue;

        // Now we need to figure out if this subkey refers to an OLE object which
        // we want to put into the list. Our first test is to see if there is
        // a "NotInsertable" key under it. If there is, we skip this object.

        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyObject, _T("NotInsertable"), 0, KEY_READ, &hkeyTest))
        {
            RegCloseKey(hkeyTest);
            continue;
        }

        // The next test is to look for a CLSID. If there isn't one, then we
        // will skip this object.

        if (ERROR_SUCCESS != RegOpenKeyEx(hkeyObject, _T("CLSID"), 0, KEY_READ, &hkeyCLSID))
        {
            RegCloseKey(hkeyObject);
            continue;
        }

        dwSize = MAX_PATH * sizeof(TCHAR);
        if (ERROR_SUCCESS != RegQueryValueEx(hkeyCLSID, _T(""), NULL, &dwType, (LPBYTE) szCLSID, &dwSize))
        {
            RegCloseKey(hkeyObject);
            RegCloseKey(hkeyCLSID);
            continue;
        }
        RegCloseKey(hkeyCLSID);

        // The next check is for a subkey called "protocol\StdFileEditing\server".
        // If it is present, then this object should be inserted into the list.

        bInsertInList = FALSE;
        strcpy(szTemp, szObjectKey);
        strcat(szTemp, "\\protocol\\StdFileEditing\\server");
        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szTemp, 0, KEY_READ, &hkeyServer) == ERROR_SUCCESS)
        {
            // Get the name of the server.

            dwSize = MAX_PATH * sizeof(TCHAR);
            if (RegQueryValueEx(hkeyServer, "", NULL, &dwType, (LPBYTE) szServer, &dwSize) != ERROR_SUCCESS || szServer[0] == '\0')
            {
                RegCloseKey(hkeyObject);
                RegCloseKey(hkeyServer);
                continue;
            }

            bInsertInList = TRUE;
            RegCloseKey(hkeyServer);
        }

        // There's still another chance for this little fella to make it into the
        // list. If the object is insertable (i.e. it has an "Insertable" key) and
        // it a server can be found under HKEY_CLASSES_ROOT\CLSID\<clsid> key, then
        // it makes it into the list.

        if (!bInsertInList)
        {
            // First, make sure the object is insertable.

            if (RegOpenKeyEx(hkeyObject, "Insertable", 0, KEY_READ, &hkeyTest) == ERROR_SUCCESS)
            {
                // There are four places to look for a server. We'll check for 32-bit
                // servers first. When we've found one, use that server name and
                // stop the search.

                TCHAR * aszServerKeys[] = { _T("LocalServer32"), _T("InProcServer32"), _T("LocalServer"), _T("InProcServer"), _T("")};
                for (int iServer = 0; *aszServerKeys[iServer] && !bInsertInList; iServer++)
                {
                    _tcscpy(szTemp, _T("CLSID\\"));
                    _tcscat(szTemp, szCLSID);
                    _tcscat(szTemp, _T("\\"));
                    _tcscat(szTemp, aszServerKeys[iServer]);

                    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szTemp, 0, KEY_READ, &hkeySearch) == ERROR_SUCCESS)
                    {
                        dwSize = PROGRAM_LEN * sizeof(TCHAR);
                        if (RegQueryValueEx(hkeySearch, _T(""), NULL, &dwType, (LPBYTE) szServer, &dwSize) == ERROR_SUCCESS && szServer[0] != '\0')
                            bInsertInList = TRUE;
                        RegCloseKey(hkeySearch);
                    }
                }
            }
            RegCloseKey(hkeyTest);
        }

        if (bInsertInList)
        {
            // Get the description of the object. This can be found under the
            // objects key as the default value.

            dwSize = DESCRIPTION_LEN * sizeof(TCHAR);
            if (ERROR_SUCCESS != RegQueryValueEx(hkeyObject, "", NULL, &dwType, (LPBYTE) szDescription, &dwSize))
                szDescription[0] = _T('\0');

            // Create a new OLE registration item entry. This might throw a memory exception,
            // so close the hkeyObject handle first.

            RegCloseKey(hkeyObject);
            if (!AddOLERegItem(_T("REGISTRY"), szDescription, szObjectKey, szServer))
            {
                fReturn = FALSE;
                goto END;
            }
        }
        else
            RegCloseKey(hkeyObject);
    }

END:
    TraceFunctLeave();
    return fReturn;
}

//-----------------------------------------------------------------------------
// This method retrieves OLE object information from the INI file(s) and adds
// it to the list of objects. Note - this code is essentially lifted from the
// source code for the OLE Registration OCX in MSInfo 4.10.
//
// Changes were made to remove MFC dependencies.
//-----------------------------------------------------------------------------

BOOL COLEItemCollection::UpdateFromINIFile()
{
    TraceFunctEnter("COLEItemCollection::UpdateFromINIFile");

    TCHAR   szProgram[PROGRAM_LEN];
    TCHAR   szDescription[DESCRIPTION_LEN];
    LPTSTR  szBuffer;
    LPTSTR  szEntry;
    LPTSTR  szScan;
    TCHAR   szData[MAX_PATH * 2];
    BOOL    fReturn = TRUE;
    int     i;

    szBuffer = new TCHAR[2048];
    if (szBuffer == NULL)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    if (GetProfileString(_T("embedding"), NULL, _T("\0\0"), szBuffer, 2048) <= 2)
    {
        fReturn = FALSE;
        goto END;
    }

    szEntry = szBuffer;
    while (*szEntry != 0)
    {
        if (GetProfileString(_T("embedding"), szEntry, _T("\0\0"), szData, MAX_PATH * 2) > 1)
        {
            // Parse out the components of the string we retrieved. The string
            // should be formed as "primary desc, registry desc, program, format".

            szScan = szData;

            i = _tcscspn(szScan, _T(","));
            _tcsncpy(szDescription, szScan, (i < DESCRIPTION_LEN - 1) ? i : DESCRIPTION_LEN - 1);
            szDescription[(i < DESCRIPTION_LEN - 1) ? i : DESCRIPTION_LEN - 1] = _T('\0');
            szScan += i + 1;

            szScan += _tcscspn(szScan, _T(",")) + 1;     // skip registry

            i = _tcscspn(szScan, _T(","));
            _tcsncpy(szProgram, szScan, (i < PROGRAM_LEN - 1) ? i : PROGRAM_LEN - 1);
            szProgram[(i < PROGRAM_LEN - 1) ? i : PROGRAM_LEN - 1] = _T('\0');
            szScan += i + 1;

            // Create a new OLE registration item entry. This might throw an exception.

			try
			{				
                if (!AddOLERegItem(_T("INIFILE"), szDescription, szEntry, szProgram))
                {
                    fReturn = FALSE;
                    goto END;
                }
			}
			catch (...)
			{
                if (szBuffer)
                    delete [] szBuffer;
                throw;
			}
        }
        szEntry += lstrlen(szEntry) + 1;
    }

END:
    if (szBuffer)
        delete [] szBuffer;
    TraceFunctLeave();
    return fReturn;
}

/*****************************************************************************
*
*  FUNCTION    :    CPCH_OLERegistration::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/

HRESULT CPCH_OLERegistration::EnumerateInstances(MethodContext * pMethodContext, long lFlags)
{
    TraceFunctEnter("CPCH_OLERegistration::EnumerateInstances");

    HRESULT hRes = WBEM_S_NO_ERROR;
   
    // Get the date and time

    SYSTEMTIME stUTCTime;
    GetSystemTime(&stUTCTime);

    // The COLEItemCollection class gathers data about the OLE registration objects when it's
    // constructed. We can get info for each individual object using it's GetInstance
    // pointer, which gives us a pointer to a COLERegItem object.

    COLEItemCollection olereginfo;
    COLERegItem * poleitem;

    for (DWORD dwIndex = 0;  olereginfo.GetInstance(dwIndex, &poleitem); dwIndex++)
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        // Set the change and timestamp fields to "Snapshot" and the current time.

        if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change field failed.");

        // Set each of the other fields to the values we found when we retrieved
        // the OLE objects from the registry and INI files.

        if (!pInstance->SetCHString(pCategory, poleitem->GetCategory()))
            ErrorTrace(TRACE_ID, "SetCHString on Category field failed.");

        if (!pInstance->SetCHString(pDescription, poleitem->GetDescription()))
            ErrorTrace(TRACE_ID, "SetCHString on Description field failed.");

        if (!pInstance->SetCHString(pProgramFile, poleitem->GetProgramFile()))
            ErrorTrace(TRACE_ID, "SetCHString on ProgramFile field failed.");

        if (!pInstance->SetCHString(pObject, poleitem->GetObject()))
            ErrorTrace(TRACE_ID, "SetCHString on Object field failed.");

        LPCSTR szFile = poleitem->GetProgramFile();
        if (szFile && szFile[0])
        {
            CComPtr<IWbemClassObject>   pFileObj;
            CComBSTR                    ccombstrValue(szFile);
            if (SUCCEEDED(GetCIMDataFile(ccombstrValue, &pFileObj)))
            {
                // Using the CIM_DataFile object, copy over the appropriate properties.

                CopyProperty(pFileObj, L"Version", pInstance, pVersion);
                CopyProperty(pFileObj, L"FileSize", pInstance, pSize);
                CopyProperty(pFileObj, L"CreationDate", pInstance, pDate);
            }
        }

    	hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
    }

    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_printer.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
PCH_Printer.CPP

Abstract:
WBEM provider class implementation for PCH_Printer class

Revision History:

Ghim-Sim Chua       (gschua)   04/27/99
- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_Printer.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTER


#define                 MAX_STRING_LEN      1024

CPCH_Printer MyPCH_PrinterSet (PROVIDER_NAME_PCH_PRINTER, PCH_NAMESPACE) ;



///////////////////////////////////////////////////////////////////////////////
//....Properties of PCHPrinter Class
//

const static WCHAR* pTimeStamp           = L"TimeStamp" ;
const static WCHAR* pChange              = L"Change" ;
const static WCHAR* pDefaultPrinter      = L"DefaultPrinter" ;
const static WCHAR* pGenDrv              = L"GenDrv" ;
const static WCHAR* pName                = L"Name" ;
const static WCHAR* pPath                = L"Path" ;
const static WCHAR* pUniDrv              = L"UniDrv" ;
const static WCHAR* pUsePrintMgrSpooling = L"UsePrintMgrSpooling" ;

//*****************************************************************************
//
// Function Name     : CPCH_Printer::EnumerateInstances
//
// Input Parameters  : pMethodContext : Pointer to the MethodContext for 
//                                      communication with WinMgmt.
//                
//                     lFlags :         Long that contains the flags described 
//                                      in IWbemServices::CreateInstanceEnumAsync
//                                      Note that the following flags are handled 
//                                      by (and filtered out by) WinMgmt:
//                                      WBEM_FLAG_DEEP
//                                      WBEM_FLAG_SHALLOW
//                                      WBEM_FLAG_RETURN_IMMEDIATELY
//                                      WBEM_FLAG_FORWARD_ONLY
//                                      WBEM_FLAG_BIDIRECTIONAL
// Output Parameters  : None
//
// Returns            : WBEM_S_NO_ERROR 
//                      
//
// Synopsis           : There is a single instance of this class on the machine 
//                      and this is returned..
//                      If there is no instances returns WBEM_S_NO_ERROR.
//                      It is not an error to have no instances.
//
//*****************************************************************************

HRESULT CPCH_Printer::EnumerateInstances(MethodContext* pMethodContext,
                                                long lFlags)
{
    TraceFunctEnter("CPCH_Printer::EnumerateInstances");

    //  Begin Declarations...................................................

    HRESULT                                 hRes = WBEM_S_NO_ERROR;

    //  Instances
    CComPtr<IEnumWbemClassObject>           pPrinterEnumInst;

    //  Objects
    IWbemClassObjectPtr                     pFileObj;
    IWbemClassObjectPtr                     pPrinterObj;                   // BUGBUG : WMI asserts if we use CComPtr
    
    //  SystemTime
    SYSTEMTIME                              stUTCTime;

    //  Variants
    CComVariant                             varValue;
    CComVariant                             varAttributes;
    CComVariant                             varSnapshot             = "Snapshot";
    CComVariant                             varNotAvail             = "Not Available";

    //   Strings
    CComBSTR                                bstrUniDriverWithPath; 
    CComBSTR                                bstrGenDriverWithPath;
    CComBSTR                                bstrUnidriverDetails;
    CComBSTR                                bstrGenDriverDetails;
    CComBSTR                                bstrAttributes          =   "attributes";
    CComBSTR                                bstrPrinterQueryString;
    CComBSTR                                bstrVersion             = "Version";
    CComBSTR                                bstrFileSize            = "FileSize";
    CComBSTR                                bstrModifiedDate        = "LastModified";

    LPCTSTR                                 lpctstrUniDriver        = _T("unidrv.dll");
    LPCTSTR                                 lpctstrGenDriver        = _T("gendrv.dll");
    LPCTSTR                                 lpctstrSpace            = _T("  "); 
    LPCTSTR                                 lpctstrPrinterQuery     = _T("Select DeviceID, DriverName, Attributes FROM win32_printer WHERE DriverName =\"");
    LPCTSTR                                 lpctstrWindows          = _T("Windows");   
    LPCTSTR                                 lpctstrDevice           = _T("Device");  
    LPCTSTR                                 lpctstrComma            = _T(",");
    LPCTSTR                                 lpctstrSlash            = _T("\"");
    LPCTSTR                                 lpctstrNoUniDrv         = _T("(unidrv.dll) = NotInstalled");
    LPCTSTR                                 lpctstrNoGenDrv         = _T("(gendrv.dll) = NotInstalled");
    LPCTSTR                                 lpctstrPrintersHive     = _T("System\\CurrentControlSet\\Control\\Print\\Printers");
    LPCTSTR                                 lpctstrYes              = _T("yes");
    LPCTSTR                                 lpctstrAttributes       = _T("Attributes");
    LPCTSTR                                 lpctstrSpooler          = _T("Spooler");

    TCHAR                                   tchBuffer[MAX_STRING_LEN];
    TCHAR                                   tchPrinterKeyName[MAX_STRING_LEN];
    TCHAR                                   tchAttributesValue[MAX_PATH];
    TCHAR                                   *ptchToken;

    //  Booleans
    BOOL                                    fDriverFound;
    BOOL                                    fCommit                 = FALSE;
    BOOL                                    fAttribFound            = FALSE;

    //  DWORDs
    DWORD                                   dwSize;
    DWORD                                   dwIndex;
    DWORD                                   dwType;
    DWORD                                   dwAttributes;
     
    //  Return Values;
    ULONG                                   ulPrinterRetVal         = 0;
    ULONG                                   ulPrinterAttribs;

    LONG                                    lRegRetVal;

    struct tm                               tm;

    WBEMTime                                wbemtimeUnidriver;
    WBEMTime                                wbemtimeGendriver;

    HKEY                                    hkeyPrinter;
    HKEY                                    hkeyPrinters;

    PFILETIME                               pFileTime               = NULL;
  

    //  End Declarations...................................................

    //  Create a new instance of PCH_Printer Class based on the passed-in MethodContext
    CInstancePtr pPCHPrinterInstance(CreateNewInstance(pMethodContext), false);

    //  Created a New Instance of PCH_PrinterInstance Successfully.

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              TIME STAMP                                                                 //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);

    hRes = pPCHPrinterInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
    if (FAILED(hRes))
    {
        //  Could not Set the Time Stamp
        //  Continue anyway
        ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CHANGE                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHPrinterInstance->SetVariant(pChange, varSnapshot);
    if(FAILED(hRes))
    {
        //  Could not Set the Change Property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on Change Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              DEFAULTPRINTER                                                             //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    //  In "win.ini" file under "Windows" section "Device" represents the default printer
    if(GetProfileString(lpctstrWindows, lpctstrDevice, "\0", tchBuffer, MAX_PATH) > 1)
    {
        // If Found the Default Printer set the value to TRUE
        varValue = VARIANT_TRUE;
        hRes = pPCHPrinterInstance->SetVariant(pDefaultPrinter, varValue);
        if(FAILED(hRes))
        {
            //  Could not Set the Default Printer to TRUE
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on DefaultPrinter Field failed.");
        }

        //  The Above GetProfileString returns "printerName", "PrinterDriver" and "PrinterPath" 
        //  seperated by commas. Ignore "PrinterDriver" and use the other two to set the properties.
        ptchToken = _tcstok(tchBuffer,lpctstrComma);
        if(ptchToken != NULL)
        {
            // Got the first Token i.e. name. Set this.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              NAME                                                                       //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            varValue = ptchToken;
            hRes = pPCHPrinterInstance->SetVariant(pName, varValue);
            if(FAILED(hRes))
            {
                //  Could not Set the Name
                //  Continue anyway
                ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
            }
                        
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //                              PATH                                                                       //
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

            // continue to get the next token and ignore
          
            ptchToken = _tcstok(NULL,lpctstrComma);
            if(ptchToken != NULL)
            {
                //  If ptchToken is not equal to NULL, then continue to get the third token and set it to PATH Name Field
                ptchToken = _tcstok(NULL,lpctstrComma);
                if(ptchToken != NULL)
                {
                    // Got the third token i.e. PATH Set this.
                    varValue = ptchToken;
                    hRes = pPCHPrinterInstance->SetVariant(pPath, varValue);
                    if (FAILED(hRes))
                    {
                        //  Could not Set the Path property
                        //  Continue anyway
                        ErrorTrace(TRACE_ID, "Set Variant on PathName Field failed.");
                    }
                }
            }
        }
    }
    else
    {
        //  Could not get the default printer details.

        //  Set the Name to "Not Available"
        hRes = pPCHPrinterInstance->SetVariant(pName, varNotAvail);
        if(FAILED(hRes))
        {
            //  Could not Set the Name
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
        }
        //  Set the default printer to false
        varValue = VARIANT_FALSE;
        hRes = pPCHPrinterInstance->SetVariant(pDefaultPrinter, varValue);
        if(FAILED(hRes))
        {
            //  Could not Set the Default Printer to FALSE
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on DefaultPrinter Field failed.");
        }
        //  Proceed anyway!
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              USEPRINTMANAGERSPOOLING                                                    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //  First try to get the Spooling  information from the registry. This is available in registry if there are 
    //  any installed printers.
    // This info. is present under HKLM\system\CCS\Control\Print\Printers

    lRegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrPrintersHive, 0, KEY_READ, &hkeyPrinters);
    if(lRegRetVal == ERROR_SUCCESS)
	{
		// Opened the Registry key.
        // Enumerate the keys under this hive.
        dwIndex = 0;
        dwSize = MAX_PATH;
        lRegRetVal = RegEnumKeyEx(hkeyPrinters, dwIndex,  tchPrinterKeyName, &dwSize, NULL, NULL, NULL, pFileTime);
        if(lRegRetVal == ERROR_SUCCESS)
        {
            //  There is atleast one printer installed.
            lRegRetVal = RegOpenKeyEx(hkeyPrinters,  tchPrinterKeyName, 0, KEY_READ, &hkeyPrinter);
            if(lRegRetVal == ERROR_SUCCESS)
            {
                //  Opened the first printer key
                //  Query for , regname "Attributes"
                dwSize = MAX_PATH;
                lRegRetVal = RegQueryValueEx(hkeyPrinter, lpctstrAttributes , NULL, &dwType, (LPBYTE)&dwAttributes, &dwSize);
                if(lRegRetVal == ERROR_SUCCESS)
                {
                    //  Got the attributes

                    //  Check the type of the reg Value
                    if(dwType == REG_DWORD)
                    {
                    /*
                    //  tchAttributesValue set to Attributes. Copy this to ulPrinterAttribs
                    ulPrinterAttribs = atol(tchAttributesValue);
                    if (ulPrinterAttribs > 0)
                    {
                        // From ulPrinterAttribs determine if spooling is present or not.
                        // AND it with PRINTER_ATTRIBUTE_DIRECT
                        if((ulPrinterAttribs & PRINTER_ATTRIBUTE_DIRECT) != 0)
                        {
                            // No spooling
                            varValue = VARIANT_FALSE;
                        }
                        else
                        {
                            // Spooling : YES
                            varValue = VARIANT_TRUE;
                        }

                        //  Attribute Found
                        fAttribFound = TRUE;
                    }
                    */
                        if((dwAttributes & PRINTER_ATTRIBUTE_DIRECT) != 0)
                        {
                            // No spooling
                            varValue = VARIANT_FALSE;
                        }
                        else
                        {
                            // Spooling : YES
                            varValue = VARIANT_TRUE;
                        }

                        //  Attribute Found
                        fAttribFound = TRUE;
                    }
                }
            }
                     
        }
    }              
    if(!fAttribFound)
    {
        //  If not get the "spooler" key value from the win.ini file.  If the entry is not present default to "yes".
        if(GetProfileString(lpctstrWindows, lpctstrSpooler, "yes", tchBuffer, MAX_PATH) > 1)
        {
            //  Got the spooler Details
            if(_tcsicmp(tchBuffer, lpctstrYes) == 0)
            {
                // Spooling : YES
                varValue = VARIANT_TRUE;
            }
            else
            {
                // No spooling
                varValue = VARIANT_FALSE;
            }
        }

    }

    //  Set the Spooling Property.
    hRes =  pPCHPrinterInstance->SetVariant(pUsePrintMgrSpooling, varValue);
    if(FAILED(hRes))
    {
        //  Could not Set the USEPRINTMANAGERSPOOLING
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on usePrintManagerSpooling Field failed.");
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              UNIDRV                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    pFileObj = NULL;
    //  Get the complete path for unidrv.dll
    fDriverFound =  getCompletePath(lpctstrUniDriver, bstrUniDriverWithPath);
    if(fDriverFound)
    {
        //  Unidrv.dll present. Pass the File with PathName to
        //  GetCIMDataFile function to get the file properties.
        if (SUCCEEDED(GetCIMDataFile(bstrUniDriverWithPath, &pFileObj)))
        {
            // From the CIM_DataFile Object get the properties and append them 
            //  Get the Version 
            varValue.Clear();
            hRes = pFileObj->Get(bstrVersion, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                //  Got the Version. Append it to the bstrUnidriverDetails String
                if(varValue.vt == VT_BSTR)
                {
                    bstrUnidriverDetails.Append(varValue.bstrVal);
                    //  Append Space 
                    bstrUnidriverDetails.Append(lpctstrSpace);
                }
            }

            //  Get the FileSize
            varValue.Clear();
            hRes = pFileObj->Get(bstrFileSize, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                //  Got the FileSize. Append it to the bstrUnidriverDetails String
                if(varValue.vt == VT_BSTR)
                {
                    bstrUnidriverDetails.Append(varValue.bstrVal);
                    //  Append Space 
                    bstrUnidriverDetails.Append(lpctstrSpace);
                }
            }

            //  Get the Date&Time
            varValue.Clear();
            hRes = pFileObj->Get(bstrModifiedDate, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                if(varValue.vt == VT_BSTR)
                {
                    wbemtimeUnidriver = varValue.bstrVal;
                    if(wbemtimeUnidriver.GetStructtm(&tm))
                    {
                        //  Got the time in tm Struct format
                        //  Convert it into a string
                        varValue = asctime(&tm);
                        //Append it to the bstrUnidriverDetails String
                        bstrUnidriverDetails.Append(varValue.bstrVal);
                    }
                }
                
            }
            // Copy the string into the varValue
            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrUnidriverDetails.Detach();
        }// end of if succeeded CIM_DataFile
    } // end of if driver Found
    else 
    {
        //  unidrv.dll not present
        varValue.Clear();
        varValue = lpctstrNoUniDrv;
    }
    hRes = pPCHPrinterInstance->SetVariant(pUniDrv, varValue);
    if(FAILED(hRes))
    {
        //  Could not Set the Unidriver property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on Uni Driver Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              GENDRV                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    pFileObj = NULL;
    
    //  Get the complete path for gendrv.dll
    fDriverFound =  getCompletePath(lpctstrGenDriver, bstrGenDriverWithPath);
    if(fDriverFound)
    {
        //  Gendrv.dll present. Pass the File with PathName to
        //  GetCIMDataFile function to get the file properties.
        if(SUCCEEDED(GetCIMDataFile(bstrGenDriverWithPath, &pFileObj)))
        {
            // From the CIM_DataFile Object get the properties and append them 
            // Get the Version 
            varValue.Clear();
            hRes = pFileObj->Get(bstrVersion, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                //  Got the Version. Append it to the bstrUnidriverDetails String
                if(varValue.vt == VT_BSTR)
                {
                    bstrGenDriverDetails.Append(varValue.bstrVal);
                    //  Append Space 
                    bstrGenDriverDetails.Append(lpctstrSpace);
                }
            }
            //  Get the FileSize
            varValue.Clear();
            hRes = pFileObj->Get(bstrFileSize, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                if(varValue.vt == VT_BSTR)
                {
                    //  Got the FileSize. Append it to the bstrUnidriverDetails String
                    bstrGenDriverDetails.Append(varValue.bstrVal);
                    //  Append Space 
                    bstrGenDriverDetails.Append(lpctstrSpace);
                }
            }
            //  Get the Date&Time
            varValue.Clear();
            hRes = pFileObj->Get(bstrModifiedDate, 0, &varValue, NULL, NULL);
            if(SUCCEEDED(hRes))
            {
                if(varValue.vt == VT_BSTR)
                {
                    wbemtimeGendriver = varValue.bstrVal;
                    if(wbemtimeGendriver.GetStructtm(&tm))
                    {
                        //  Got the time in tm Struct format
                        //  Convert it into a string
                        varValue = asctime(&tm);
                        bstrGenDriverDetails.Append(varValue.bstrVal);
                    }
                }
                
            }
            // Copy the string into the varValue
            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrGenDriverDetails.Detach();
        }// end of if succeeded CIM_DataFile
    } // end of if driver Found
    else 
    {
        //  gendrv.dll not present
        varValue.Clear();
        varValue = lpctstrNoGenDrv;
    }
    hRes =   pPCHPrinterInstance->SetVariant(pGenDrv, varValue);
    if(FAILED(hRes))
    {
        //  Could not Set the GenDrv Field
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on GenDrv Field failed.");
    }

    //  All the properties are set.
    hRes = pPCHPrinterInstance->Commit();
    if(FAILED(hRes))
    {
        //  Could not Set the GenDrv Field
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Error on commiting!");
    }
    
    TraceFunctLeave();
    return hRes ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_resourceirq.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceIRQ.H

Abstract:
	WBEM provider class definition for PCH_ResourceIRQ class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ResourceIRQ_H_
#define _PCH_ResourceIRQ_H_

#define PROVIDER_NAME_PCH_RESOURCEIRQ "PCH_ResourceIRQ"

// Property name externs -- defined in PCH_ResourceIRQ.cpp
//=================================================

extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pMask ;
extern const WCHAR* pName ;
extern const WCHAR* pValue ;

class CPCH_ResourceIRQ : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ResourceIRQ(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ResourceIRQ() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_printerdriver.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_PrinterDriver.CPP

Abstract:
    WBEM provider class implementation for PCH_PrinterDriver class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Kalyani Narlanka    (kalyanin) 05/11/99
        - Added Code to get all the properties for this class

********************************************************************/

#include "pchealth.h"
#include "PCH_PrinterDriver.h"


/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_PRINTERDRIVER

CPCH_PrinterDriver MyPCH_PrinterDriverSet (PROVIDER_NAME_PCH_PRINTERDRIVER, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp       = L"TimeStamp" ;
const static WCHAR* pChange          = L"Change" ;
const static WCHAR* pDate            = L"Date" ;
const static WCHAR* pFilename        = L"Filename" ;
const static WCHAR* pManufacturer    = L"Manufacturer" ;
const static WCHAR* pName            = L"Name" ;
const static WCHAR* pSize            = L"Size" ;
const static WCHAR* pVersion         = L"Version" ;
const static WCHAR* pPath            = L"Path" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_PrinterDriver::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_PrinterDriver::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{

    TraceFunctEnter("CPCH_PrinterDriver::EnumerateInstances");

    //  Begin Declarations

    HRESULT                         hRes                = WBEM_S_NO_ERROR;

    //  Query String
    CComBSTR                        bstrPrinterQuery    = L"Select DeviceID, PortName FROM win32_printer";

    // Instances
    CComPtr<IEnumWbemClassObject>   pPrinterEnumInst;
    CInstance                       *pPCHPrinterDriverInstance;

    //  SystemTime
    SYSTEMTIME                      stUTCTime;

     //  Objects
    IWbemClassObjectPtr            pPrinterObj;                   
    IWbemClassObjectPtr            pFileObj;

    //  Unsigned Longs....
    ULONG                           ulPrinterRetVal     = 0;
    ULONG                           uiReturn            = 0;

    //  File Status structure
    struct _stat                    filestat;

    //  Strings
    CComBSTR                        bstrPrinterDriverWithPath;
    CComBSTR                        bstrPrinterDriver;
    CComBSTR                        bstrProperty;
    CComBSTR                        bstrDeviceID                = L"DeviceID";

    LPCWSTR                         lpctstrPortName             = L"PortName";
    LPCWSTR                         lpctstrFileSize             = L"FileSize";
    LPCWSTR                         lpctstrLastModified         = L"LastModified";
    LPCWSTR                         lpctstrManufacturer         = L"Manufacturer";
    LPCWSTR                         lpctstrVersion              = L"Version";
    LPCTSTR                         lpctstrComma                = _T(",");
    LPCTSTR                         lpctstrDrvExtension         = _T(".drv");
    LPCTSTR                         lpctstrDevices              = _T("Devices");
    LPCWSTR                         lpctstrDeviceID             = L"DeviceID";

    TCHAR                           tchDeviceID[MAX_PATH];

    TCHAR                           tchBuffer[MAX_PATH];
    TCHAR                           *ptchToken;

    CComVariant                     varValue;
    CComVariant                     varSnapshot                 = "Snapshot";
    
    BOOL                            fDriverFound;

    BOOL                            fCommit                     = FALSE;

    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);

    //  Execute the query to get DeviceID, PORTName FROM Win32_Printer
    //  Class.
    //  pPrinterEnumInst contains a pointer to the list of instances returned.

    tchDeviceID[0] = 0;

    hRes = ExecWQLQuery(&pPrinterEnumInst, bstrPrinterQuery);
    if (FAILED(hRes))
    {
        //  Cannot get any properties.
        goto END;
    }
    //  Query Succeeded!
    //  Enumerate the instances from pPrinterEnumInstance
    //  Get the next instance into pPrinterObj object.
    while(WBEM_S_NO_ERROR == pPrinterEnumInst->Next(WBEM_INFINITE, 1, &pPrinterObj, &ulPrinterRetVal))
    {
        //  Create a new instance of PCH_PrinterDriver Class based on the passed-in MethodContext
        CInstancePtr   pPCHPrinterDriverInstance(CreateNewInstance(pMethodContext),false);

        //  Created a New Instance of PCH_PrinterDriver Successfully.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              TIME STAMP                                                                 //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = pPCHPrinterDriverInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
        if (FAILED(hRes))
        {
            //  Could not Set the Time Stamp
            //  Continue anyway
                ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              CHANGE                                                                     //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = pPCHPrinterDriverInstance->SetVariant(pChange, varSnapshot);
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              NAME                                                                     //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        hRes = CopyProperty(pPrinterObj, lpctstrDeviceID, pPCHPrinterDriverInstance, pName);
        if(SUCCEEDED(hRes))
        {
            fCommit = TRUE;
        }

       
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              PATH                                                                        //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        CopyProperty(pPrinterObj, lpctstrPortName, pPCHPrinterDriverInstance, pPath);
        
      
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              FILENAME                                                                     //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // Get the File Name i.e.driver from the INI file.
        // Use the DeviceID of win32_printer class to get the PCH_Printer.FileName

        // Get the device ID  and use it to pick up the driver from win.ini File
        hRes = pPrinterObj->Get(bstrDeviceID, 0, &varValue, NULL, NULL);
        if(SUCCEEDED(hRes))
        {
            //  Got the DeviceID
            //  Now call GetProfileString to get the Driver
            USES_CONVERSION;
            _tcscpy(tchDeviceID,W2T(varValue.bstrVal));
            if (GetProfileString(lpctstrDevices, tchDeviceID, "\0", tchBuffer, MAX_PATH) > 1)
            {
                //  tchBuffer contains a string of two tokens, first the driver, second the PathName
                //  Get the driver
                ptchToken = _tcstok(tchBuffer,lpctstrComma);
                if(ptchToken != NULL)
                {
                    // Got the Driver Name
                    bstrPrinterDriver = ptchToken;
                    varValue = ptchToken;
                
                    //  Use this to set the FileName
                    hRes = pPCHPrinterDriverInstance->SetVariant(pFilename, varValue);
                    if (FAILED(hRes))
                    {
                        //  Could not Set the FileName Property
                        //  Continue anyway
                        ErrorTrace(TRACE_ID, "Set Variant on Change Field failed.");
                    }

                    // Now get the properties of the File
                    // Concatenate ".drv" to get the driver's actual Name
                    bstrPrinterDriver.Append(lpctstrDrvExtension);

                    //  Get the Complete Path of the File 
                    fDriverFound =  getCompletePath(bstrPrinterDriver, bstrPrinterDriverWithPath);
                    if (fDriverFound)
                    {
                        //  Got the complete Path  Call GetCIMDataFile Function to get 
                        //  properties  of this file.

                        if (SUCCEEDED(GetCIMDataFile(bstrPrinterDriverWithPath, &pFileObj)))
                        {

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              VERSION                                                                    //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            CopyProperty(pFileObj, lpctstrVersion, pPCHPrinterDriverInstance, pVersion);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              FILESIZE                                                                   //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            CopyProperty(pFileObj, lpctstrFileSize, pPCHPrinterDriverInstance, pSize);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              DATE                                                                     //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            CopyProperty(pFileObj, lpctstrLastModified, pPCHPrinterDriverInstance, pDate);

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //                              MANUFACTURER                                                                     //
                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            CopyProperty(pFileObj, lpctstrManufacturer, pPCHPrinterDriverInstance, pManufacturer);

                            
                        } //end of SUCCEEDED...
                    } // end of if fDriverFound
                
                }  // end of if (ptchToken != NULL)

            } // end of GetProfileString...
                        
        }// end of got the DeviceID

        //  All the properties are set. Commit the instance
        hRes = pPCHPrinterDriverInstance->Commit();
        if(FAILED(hRes))
        {
            //  Could not Commit the instance
            ErrorTrace(TRACE_ID, "Could not commit the instance");
        }

    } // end of While

END:    TraceFunctLeave();
        return hRes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_runningtask.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_RunningTask.H

Abstract:
	WBEM provider class definition for PCH_RunningTask class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_RunningTask_H_
#define _PCH_RunningTask_H_

#define PROVIDER_NAME_PCH_RUNNINGTASK "PCH_RunningTask"

// Property name externs -- defined in PCH_RunningTask.cpp
//=================================================

extern const WCHAR* pAddress ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDate ;
extern const WCHAR* pDescription ;
extern const WCHAR* pManufacturer ;
extern const WCHAR* pName ;
extern const WCHAR* pPartOf ;
extern const WCHAR* pPath ;
extern const WCHAR* pSize ;
extern const WCHAR* pType ;
extern const WCHAR* pVersion ;

class CPCH_RunningTask : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_RunningTask(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_RunningTask() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_resourcememrange.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceMemRange.H

Abstract:
	WBEM provider class definition for PCH_ResourceMemRange class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_ResourceMemRange_H_
#define _PCH_ResourceMemRange_H_

#define PROVIDER_NAME_PCH_RESOURCEMEMRANGE "PCH_ResourceMemRange"

// Property name externs -- defined in PCH_ResourceMemRange.cpp
//=================================================

extern const WCHAR* pBase ;
extern const WCHAR* pCategory ;
extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pEnd ;
extern const WCHAR* pMax ;
extern const WCHAR* pMin ;
extern const WCHAR* pName ;

class CPCH_ResourceMemRange : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_ResourceMemRange(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_ResourceMemRange() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_startup.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_StartUp.H

Abstract:
	WBEM provider class definition for PCH_StartUp class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_StartUp_H_
#define _PCH_StartUp_H_

#define PROVIDER_NAME_PCH_STARTUP "PCH_StartUp"

// Property name externs -- defined in PCH_StartUp.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pCommand ;
extern const WCHAR* pLoadedFrom ;
extern const WCHAR* pName ;

class CPCH_StartUp : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_StartUp(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_StartUp() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
    private:
        virtual HRESULT UpdateRegistryInstance(
                        HKEY             hkeyRoot,                // [in]  Name of the Startup Instance
                        LPCTSTR          lpctstrRegistryHive,         // [in]  Registry/StartupGroup
                        CComVariant      varLoadedFrom,          // [in]  Command of the startup Instance
                        SYSTEMTIME       stUTCTime,              // [in]  
                        MethodContext*   pMethodContext          // [in] 
                        );

        virtual HRESULT UpdateStartupGroupInstance(
                        int              nFolder,                 // [in]  Registry hive to look for startup entries
                        SYSTEMTIME       stUTCTime,               // [in]  
                        MethodContext*   pMethodContext           // [in]  Instance is created by the caller.
                        );
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_sysinfo.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_Sysinfo.H

Abstract:
	WBEM provider class definition for PCH_Sysinfo class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_Sysinfo_H_
#define _PCH_Sysinfo_H_

#define PROVIDER_NAME_PCH_SYSINFO "PCH_Sysinfo"

// Property name externs -- defined in PCH_Sysinfo.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pIEVersion ;
extern const WCHAR* pInstall ;
extern const WCHAR* pMode ;
extern const WCHAR* pOSName ;
extern const WCHAR* pOSVersion ;
extern const WCHAR* pProcessor ;
extern const WCHAR* pClockSpeed ;
extern const WCHAR* pRAM ;
extern const WCHAR* pSwapFile ;
extern const WCHAR* pSystemID ;
extern const WCHAR* pUptime ;
extern const WCHAR* pOSLanguage;
extern const WCHAR* pManufacturer;
extern const WCHAR* pModel;
extern const WCHAR* pOSBuildNumber;

class CPCH_Sysinfo : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_Sysinfo(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_Sysinfo() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_resourcedma.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceDMA.CPP

Abstract:
	WBEM provider class implementation for PCH_ResourceDMA class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_ResourceDMA.h"
//#include "confgmgr.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RESOURCEDMA

CPCH_ResourceDMA MyPCH_ResourceDMASet (PROVIDER_NAME_PCH_RESOURCEDMA, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pChannel = L"Channel" ;
const static WCHAR* pMask = L"Mask" ;
const static WCHAR* pName = L"Name" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ResourceDMA::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ResourceDMA::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ResourceDMA::EnumerateInstances");

    
    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;

    //  Instances
    CComPtr<IEnumWbemClassObject>       pWin32AllocatedResourceEnumInst;

    //  Objects
    IWbemClassObjectPtr                 pWin32AllocatedResourceObj;

    // Variants
    CComVariant                         varAntecedent;
    CComVariant                         varDependent;
    CComVariant                         varPNPEntity;
    CComVariant                         varDMANumber;

     //  Query Strings
    CComBSTR                            bstrWin32AllocatedResourceQuery             = L"Select Antecedent, Dependent FROM win32_Allocatedresource";

    //  Return Values;
    ULONG                               ulWin32AllocatedResourceRetVal              = 0;

    //  Integers 
    int                                 i;
    int                                 nDMALen;
    int                                 nIter;

    //  Pattern Strings
    LPCSTR                              strDMAPattern                 = "Win32_DMAChannel.DMAChannel=";
    LPCSTR                              strPNPEntityPattern           = "Win32_PnPEntity.DeviceID=";
    
    //  Chars
    LPSTR                               strSource;
    LPSTR                               pDest;

    BOOL                                fValidInt;

    CComBSTR                            bstrPropertyAntecedent=L"Antecedent";
    CComBSTR                            bstrPropertyDependent=L"Dependent";

       
    // Enumerate the instances of Win32_PNPAllocatedResource
    hRes = ExecWQLQuery(&pWin32AllocatedResourceEnumInst, bstrWin32AllocatedResourceQuery);
    if (FAILED(hRes))
    {
        //  Cannot get any properties.
        goto END;
    }

    // Query Succeeded
    while(WBEM_S_NO_ERROR == pWin32AllocatedResourceEnumInst->Next(WBEM_INFINITE, 1, &pWin32AllocatedResourceObj, &ulWin32AllocatedResourceRetVal))
    {

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              DMA Value                                                                  //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Get the Antecedent Value
        hRes = pWin32AllocatedResourceObj->Get(bstrPropertyAntecedent, 0, &varAntecedent, NULL, NULL);
        if (FAILED(hRes))
        {
            //  Could not get the antecedent
            ErrorTrace(TRACE_ID, "GetVariant on Win32_AllocatedResource:Antecedent Field failed.");
        } 
        else
        {
            // Got the Antecedent. Search its value to see if it is a IRQ Resource.
            // varAntecedent set to antecedent. Copy this to bstrResult
            varAntecedent.ChangeType(VT_BSTR, NULL);
            {
                USES_CONVERSION;
                strSource = OLE2A(varAntecedent.bstrVal);
            }

            //  Check if it is DMA Resource by comparing with the known pattern of DMA Resource.
            pDest = strstr(strSource,strDMAPattern);

            if(pDest != NULL)
            {
                //  This is DMA Resource instance
                //  Can get the DMA ChannelNumber

                //  Advance the pointer to the end of the pattern so the pointer is 
                //  positioned at DMA Channel Number
                pDest += lstrlen(strDMAPattern);

                // First verify that the given string is a valid integer.
                nDMALen = lstrlen(pDest);
                fValidInt = TRUE;

                for(nIter = 0; nIter <nDMALen; nIter++)
                {
                    if (_istdigit(pDest[nIter]) == 0)
                    {
                        fValidInt = FALSE;
                        break;
                    }
                }
                if(fValidInt)
                {
                    // Convert the DMA Channel Number that you get as string to a long
                    varDMANumber = atol(pDest);

                    //  Create a new instance of PCH_ResourceDMA Class based on the passed-in MethodContext
                    CInstancePtr pPCHResourceDMAInstance(CreateNewInstance(pMethodContext), false);

                    //  Created a New Instance of PCH_ResourceDMA Successfully.
                    //  Set the DMA Channel Number as a variant
                    hRes = pPCHResourceDMAInstance->SetVariant(pChannel, varDMANumber);
                    if (FAILED(hRes))
                    {
                        ErrorTrace(TRACE_ID, "SetVariant on PCH_ResourceDMA.Channel Failed!");
                        //  Proceed Anyway
                    }
      
                    //  Copy the following properties from win32_AllocatedResource class Instance 
                    //  TO PCH_ResourceDMA class Instance.

                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    //                              Name                                                                       //
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // CopyProperty(pWin32AllocatedResourceObj, L"Dependent", pPCHResourceDMAInstance, pName);

                    // Get the Dependent Value
                    hRes = pWin32AllocatedResourceObj->Get(bstrPropertyDependent, 0, &varDependent, NULL, NULL);
                    if (FAILED(hRes))
                    {
                        //  Could not get the Dependent
                        ErrorTrace(TRACE_ID, "GetVariant on Win32_AllocatedResource:Dependent Field failed.");
                    } 
                    else
                    {
                        // Got the Dependent. Search its value to point to PNPEntity.
                        // varDependent set to Dependent. Copy this to bstrResult
                        varDependent.ChangeType(VT_BSTR, NULL);
                        {
                            USES_CONVERSION;
                            strSource = OLE2A(varDependent.bstrVal);
                        }

                        //  Search for Win32_PNPEntity Pattern.
                        pDest = strstr(strSource,strPNPEntityPattern);

                        if(pDest)
                        {
                            // Advance the pointer to point to the PNPEntity Name
                            pDest += lstrlen(strPNPEntityPattern);

                            // Copy the PNPEntity Name.....
                            varPNPEntity = pDest;

                            //  Set the Name 
                            hRes = pPCHResourceDMAInstance->SetVariant(pName, varPNPEntity);
                            if (FAILED(hRes))
                            {
                                ErrorTrace(TRACE_ID, "SetVariant on win32_AllocatedResource.IRQ Number Failed!");
                                //  Proceed Anyway
                            }
                        }
                    }


                    //  All the properties in pPCHResourceDMAInstance are set
                    hRes = pPCHResourceDMAInstance->Commit();
                    if (FAILED(hRes))
                    {
                        //  Cannot commit the Instance
                        ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                    } // end of if FAILED(hRes)
                    
                 }
              } // end of if pDest != NULL
              else
              {
                 //  This is not DMA Resource
              }  //  end of else pDest != NULL
        } // end of else got the antecedent
    }  //end of Allocated Resource Instances.

END:    
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_resourceiorange.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceIORange.CPP

Abstract:
	WBEM provider class implementation for PCH_ResourceIORange class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_ResourceIORange.h"
// #include "confgmgr.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RESOURCEIORANGE

CPCH_ResourceIORange MyPCH_ResourceIORangeSet (PROVIDER_NAME_PCH_RESOURCEIORANGE, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pAlias = L"Alias" ;
const static WCHAR* pBase = L"Base" ;
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pDecode = L"Decode" ;
const static WCHAR* pEnd = L"End" ;
const static WCHAR* pMax = L"Max" ;
const static WCHAR* pMin = L"Min" ;
const static WCHAR* pName = L"Name" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ResourceIORange::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ResourceIORange::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ResourceIORange::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;

    //  Instances
    CComPtr<IEnumWbemClassObject>       pPortResourceEnumInst;
    CComPtr<IEnumWbemClassObject>       pWin32AllocatedResourceEnumInst;

    //  Objects
    IWbemClassObjectPtr                 pWin32AllocatedResourceObj;
    IWbemClassObjectPtr                 pPortResourceObj;


    // Variants
    CComVariant                         varAntecedent;
    CComVariant                         varDependent;
    CComVariant                         varPNPEntity;
    CComVariant                         varStartingAddress;

     //  Query Strings
    CComBSTR                            bstrWin32AllocatedResourceQuery             = L"Select Antecedent, Dependent FROM win32_Allocatedresource";
    CComBSTR                            bstrPortResourceQuery                       = L"Select StartingAddress, Name, Alias FROM Win32_PortResource WHERE StartingAddress = ";
    CComBSTR                            bstrPortResourceQueryString;

    //  Return Values;
    ULONG                               ulWin32AllocatedResourceRetVal              = 0;
    ULONG                               ulPortResourceRetVal                        = 0;

    //  Integers 
    int                                 i;
    int                                 nStAddren;
    int                                 nIter;

    //  Pattern Strings
    LPCSTR                              strPortPattern                              = "Win32_PortResource.StartingAddress=";
    LPCSTR                              strPNPEntityPattern                         = "Win32_PnPEntity.DeviceID=";
    
    //  Chars
    LPSTR                               strSource;
    LPSTR                               pDest;

    BOOL                                fValidInt;

    CComBSTR                            bstrPropertyAntecedent=L"Antecedent";
    CComBSTR                            bstrPropertyDependent=L"Dependent";

    
       
    // Enumerate the instances of Win32_PNPAllocatedResource
    hRes = ExecWQLQuery(&pWin32AllocatedResourceEnumInst, bstrWin32AllocatedResourceQuery);
    if (FAILED(hRes))
    {
        //  Cannot get any properties.
        goto END;
    }

    // Query Succeeded
    while(WBEM_S_NO_ERROR == pWin32AllocatedResourceEnumInst->Next(WBEM_INFINITE, 1, &pWin32AllocatedResourceObj, &ulWin32AllocatedResourceRetVal))
    {

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              Starting Address                                                                  //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Get the Antecedent Value
        hRes = pWin32AllocatedResourceObj->Get(bstrPropertyAntecedent, 0, &varAntecedent, NULL, NULL);
        if (FAILED(hRes))
        {
            //  Could not get the antecedent
            ErrorTrace(TRACE_ID, "GetVariant on Win32_AllocatedResource:Antecedent Field failed.");
        } 
        else
        {
            // Got the Antecedent. Search its value to see if it is a IRQ Resource.
            // varAntecedent set to antecedent. Copy this to bstrResult
            varAntecedent.ChangeType(VT_BSTR, NULL);
            {
                USES_CONVERSION;
                strSource = OLE2A(varAntecedent.bstrVal);
            }

            //  Check if it is Port Resource by comparing with the known pattern of Port Resource.
            pDest = strstr(strSource,strPortPattern);

            if(pDest != NULL)
            {
                //  This is Port Resource instance
                //  Can get the Port Starting Address

                //  Advance the pointer to the end of the pattern so the pointer is 
                //  positioned at Starting Address
                pDest += lstrlen(strPortPattern);

                //  Formulate the Query String
                bstrPortResourceQueryString =  bstrPortResourceQuery;
                bstrPortResourceQueryString.Append(pDest);

                // At this point the WQL Query can be used to get the win32_portResource Instance.
                //  Added the following line because you need to clear the CComPtr before you query the second time.
                pPortResourceEnumInst = NULL;
                hRes = ExecWQLQuery(&pPortResourceEnumInst, bstrPortResourceQueryString);
                if (SUCCEEDED(hRes))
                {
                     //  Query Succeeded. Get the Instance Object
                     if(WBEM_S_NO_ERROR == pPortResourceEnumInst->Next(WBEM_INFINITE, 1, &pPortResourceObj, &ulPortResourceRetVal))
                     {

                         //  Create a new instance of PCH_ResourceIORange Class based on the passed-in MethodContext
                         CInstancePtr pPCHResourceIORangeInstance(CreateNewInstance(pMethodContext), false);

                         //  Created a New Instance of PCH_ResourceIORange Successfully.

                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         //                              StartingAddress                                                                       //
                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         CopyProperty(pPortResourceObj, L"StartingAddress", pPCHResourceIORangeInstance, pBase);

                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         //                              EndingAddress                                                                       //
                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         CopyProperty(pPortResourceObj, L"EndingAddress", pPCHResourceIORangeInstance, pEnd);

                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         //                              Alias                                                                       //
                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         CopyProperty(pPortResourceObj, L"Alias", pPCHResourceIORangeInstance, pAlias);

                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         //                              Name                                                                       //
                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         // CopyProperty(pWin32AllocatedResourceObj, L"Dependent", pPCHResourceIORangeInstance, pName);

                         // Get the Dependent Value
                         hRes = pWin32AllocatedResourceObj->Get(bstrPropertyDependent, 0, &varDependent, NULL, NULL);
                         if (FAILED(hRes))
                         {
                            //  Could not get the Dependent
                            ErrorTrace(TRACE_ID, "GetVariant on Win32_AllocatedResource:Dependent Field failed.");
                         } 
                         else
                         {
                             // Got the Dependent. Search its value to point to PNPEntity.
                             // varDependent set to Dependent. Copy this to bstrResult
                             varDependent.ChangeType(VT_BSTR, NULL);
                             {
                                USES_CONVERSION;
                                strSource = OLE2A(varDependent.bstrVal);
                             }

                             //  Search for Win32_PNPEntity Pattern.
                             pDest = strstr(strSource,strPNPEntityPattern);

                             if(pDest)
                             {
                                 // Advance the pointer to point to the PNPEntity Name
                                 pDest += lstrlen(strPNPEntityPattern);

                                 // Copy the PNPEntity Name.....
                                 varPNPEntity = pDest;

                                 //  Set the Name 
                                 hRes = pPCHResourceIORangeInstance->SetVariant(pName, varPNPEntity);
                                 if (FAILED(hRes))
                                 {
                                     ErrorTrace(TRACE_ID, "SetVariant on win32_AllocatedResource.IRQ Number Failed!");
                                     //  Proceed Anyway
                                 }
                             }
                         }


                         //  All the properties in pPCHResourceIORange are set
                         hRes = pPCHResourceIORangeInstance->Commit();
                         if (FAILED(hRes))
                         {
                            //  Cannot commit the Instance
                            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                         } // end of if FAILED(hRes)
                    
                     }
                } // end of Query Succeeded.
            } // end of if pDest != NULL
        } // end of else got the antecedent
    }  //end of Allocated Resource Instances.


END:


   
    
    TraceFunctLeave();
    return hRes ;

  

//            Missing data 
//            WMI does not give us min and max so we are not populating these in our class.
//
//            pInstance->SetVariant(pMax, <Property Value>);
//            pInstance->SetVariant(pMin, <Property Value>);

  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_winsock.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_WINSOCK.H

Abstract:
	WBEM provider class definition for PCH_WINSOCK class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

// Property set identification
//============================

#ifndef _PCH_WINSOCK_H_
#define _PCH_WINSOCK_H_

#define PROVIDER_NAME_PCH_WINSOCK "PCH_WINSOCK"

// Property name externs -- defined in PCH_WINSOCK.cpp
//=================================================

extern const WCHAR* pTimeStamp ;
extern const WCHAR* pChange ;
extern const WCHAR* pDescription ;
extern const WCHAR* pMaxSockets ;
extern const WCHAR* pMaxUDP ;
extern const WCHAR* pName ;
extern const WCHAR* pSize ;
extern const WCHAR* pSystemStatus ;
extern const WCHAR* pVersion ;

class CPCH_WINSOCK : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CPCH_WINSOCK(const CHString& chsClassName, LPCWSTR lpszNameSpace) : Provider(chsClassName, lpszNameSpace) {};
		virtual ~CPCH_WINSOCK() {};

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L ) { return (WBEM_E_PROVIDER_NOT_CAPABLE); };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_runningtask.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_RunningTask.CPP

Abstract:
    WBEM provider class implementation for PCH_RunningTask class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Jim Martin          (a-jammar) 04/30/99
        - Updated to retrieve file info from CIM_DataFile

********************************************************************/

#include "pchealth.h"
#include "PCH_RunningTask.h"
#include <tlhelp32.h>

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RUNNINGTASK

CPCH_RunningTask MyPCH_RunningTaskSet (PROVIDER_NAME_PCH_RUNNINGTASK, PCH_NAMESPACE) ;

// Property names
//===============

const static WCHAR * pAddress = L"Address" ;
const static WCHAR * pTimeStamp = L"TimeStamp" ;
const static WCHAR * pChange = L"Change" ;
const static WCHAR * pDate = L"Date" ;
const static WCHAR * pDescription = L"Description" ;
const static WCHAR * pManufacturer = L"Manufacturer" ;
const static WCHAR * pName = L"Name" ;
const static WCHAR * pPartOf = L"PartOf" ;
const static WCHAR * pPath = L"Path" ;
const static WCHAR * pSize = L"Size" ;
const static WCHAR * pType = L"Type" ;
const static WCHAR * pVersion = L"Version" ;

//-----------------------------------------------------------------------------
// The EnumerateInstances member function is responsible for reporting each
// instance of the PCH_RunningTask class. This is done by performing a query
// against CIMV2 for all of the Win32_Process instances. Each process instance
// corresponds to a running task, and is used to find a CIM_DataFile instance
// to report file information for each running task.
//-----------------------------------------------------------------------------

typedef HANDLE (*CTH32)(DWORD, DWORD);

HRESULT CPCH_RunningTask::EnumerateInstances(MethodContext* pMethodContext, long lFlags)
{
    USES_CONVERSION;
    TraceFunctEnter("CPCH_RunningTask::EnumerateInstances");

    CComPtr<IEnumWbemClassObject>   pEnumInst;
    IWbemClassObjectPtr             pObj;
    CFileVersionInfo                fileversioninfo;
    SYSTEMTIME                      stUTCTime;
    CComBSTR                        bstrQuery("SELECT Caption, ExecutablePath FROM Win32_Process");
    HRESULT                         hRes = WBEM_S_NO_ERROR;
    LPSTR                           szFile;
    ULONG                           ulRetVal;

    // Get the date and time for the time stamp.

    GetSystemTime(&stUTCTime);

    // Execute the query against the Win32_Process class. This will give us the
    // list of processes running - then we'll get file information for each of
    // the processes.


    hRes = ExecWQLQuery(&pEnumInst, bstrQuery);
    if (FAILED(hRes))
        goto END;

    // Enumerate each instance of the Win32_Process query.


    // CODEWORK: this shouldn't really use WBEM_INFINITE

    while (WBEM_S_NO_ERROR == pEnumInst->Next(WBEM_INFINITE, 1, &pObj, &ulRetVal))
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

        // Use the system time to set the timestamp property, and set
        // the "Change" field to "Snapshot".

		if (!pInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime)))
            ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");

        if (!pInstance->SetCHString(pChange, L"Snapshot"))
            ErrorTrace(TRACE_ID, "SetCHString on Change Field failed.");

        // Copy each property which transfers directly from the source
        // class object to the destination CInstance object.

        CopyProperty(pObj, L"Caption", pInstance, pName);
        CopyProperty(pObj, L"ExecutablePath", pInstance, pPath);

        // Get the "ExecutablePath" property, which we'll use to find the
        // appropriate CIM_DataFile object.

        CComVariant varValue;
        CComBSTR    bstrExecutablePath("ExecutablePath");

		if (FAILED(pObj->Get(bstrExecutablePath, 0, &varValue, NULL, NULL)))
            ErrorTrace(TRACE_ID, "GetVariant on ExecutablePath field failed.");
        else
        {
            CComPtr<IWbemClassObject>	pFileObj;
			CComBSTR					ccombstrValue(V_BSTR(&varValue));
            if (SUCCEEDED(GetCIMDataFile(ccombstrValue, &pFileObj)))
            {
                // Using the CIM_DataFile object, copy over the appropriate properties.

                CopyProperty(pFileObj, L"Version", pInstance, pVersion);
                CopyProperty(pFileObj, L"FileSize", pInstance, pSize);
                CopyProperty(pFileObj, L"CreationDate", pInstance, pDate);
                CopyProperty(pFileObj, L"Manufacturer", pInstance, pManufacturer);
            }

            // Use the CFileVersionInfo object to get version attributes.

            if (SUCCEEDED(fileversioninfo.QueryFile(ccombstrValue)))
            {
                if (!pInstance->SetCHString(pDescription, fileversioninfo.GetDescription()))
                    ErrorTrace(TRACE_ID, "SetCHString on description field failed.");

                if (!pInstance->SetCHString(pPartOf, fileversioninfo.GetProduct()))
                    ErrorTrace(TRACE_ID, "SetCHString on partof field failed.");
            }

        }

        // After all the properties are set, release the instance of the
        // class we're getting data from, and commit the new instance.

   	    hRes = pInstance->Commit();
        if (FAILED(hRes))
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
    }

END:
    TraceFunctLeave();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_resourceirq.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    PCH_ResourceIRQ.CPP

Abstract:
    WBEM provider class implementation for PCH_ResourceIRQ class

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

********************************************************************/

#include "pchealth.h"
#include "PCH_ResourceIRQ.h"
//#include "confgmgr.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RESOURCEIRQ

CPCH_ResourceIRQ MyPCH_ResourceIRQSet (PROVIDER_NAME_PCH_RESOURCEIRQ, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pMask = L"Mask" ;
const static WCHAR* pName = L"Name" ;
const static WCHAR* pValue = L"Value" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ResourceIRQ::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ResourceIRQ::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ResourceIRQ::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;

    //  Instances
    CComPtr<IEnumWbemClassObject>       pWin32AllocatedResourceEnumInst;

    //  Objects
    IWbemClassObjectPtr                 pWin32AllocatedResourceObj;

    // Variants
    CComVariant                         varAntecedent;
    CComVariant                         varDependent;
    CComVariant                         varPNPEntity;
    CComVariant                         varIRQNumber;

     //  Query Strings
    CComBSTR                            bstrWin32AllocatedResourceQuery             = L"Select Antecedent, Dependent FROM win32_Allocatedresource";

    //  Return Values;
    ULONG                               ulWin32AllocatedResourceRetVal              = 0;

    //  Integers 
    int                                 i;
    int                                 nIRQLen;
    int                                 nIter;

    //  Pattern Strings
    LPCSTR                              strIRQPattern                 = "Win32_IRQResource.IRQNumber=";
    LPCSTR                              strPNPEntityPattern           = "Win32_PnPEntity.DeviceID=";
    
    //  Chars
    LPSTR                               strSource;
    LPSTR                               pDest;

    BOOL                                fValidInt;

    CComBSTR                            bstrPropertyAntecedent=L"Antecedent";
    CComBSTR                            bstrPropertyDependent=L"Dependent";
       
    // Enumerate the instances of Win32_PNPAllocatedResource
    hRes = ExecWQLQuery(&pWin32AllocatedResourceEnumInst, bstrWin32AllocatedResourceQuery);
    if (FAILED(hRes))
    {
        //  Cannot get any properties.
        goto END;
    }

    // Query Succeeded
    while(WBEM_S_NO_ERROR == pWin32AllocatedResourceEnumInst->Next(WBEM_INFINITE, 1, &pWin32AllocatedResourceObj, &ulWin32AllocatedResourceRetVal))
    {

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              IRQ Value                                                                  //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Get the Antecedent Value
        hRes = pWin32AllocatedResourceObj->Get(bstrPropertyAntecedent, 0, &varAntecedent, NULL, NULL);
        if (FAILED(hRes))
        {
            //  Could not get the antecedent
            ErrorTrace(TRACE_ID, "GetVariant on Win32_AllocatedResource:Antecedent Field failed.");
        } 
        else
        {
            // Got the Antecedent. Search its value to see if it is a IRQ Resource.
            // varAntecedent set to antecedent. Copy this to bstrResult
            varAntecedent.ChangeType(VT_BSTR, NULL);
            {
                USES_CONVERSION;
                strSource = OLE2A(varAntecedent.bstrVal);
            }

            //  Check if it is IRQ Resource by comparing with the known pattern of IRQ Resource.
            pDest = strstr(strSource,strIRQPattern);

            if(pDest != NULL)
            {
                //  This is IRQ Resource instance
                //  Can get the IRQ Number

                //  Advance the pointer to the end of the pattern so the pointer is 
                //  positioned at IRQ Number
                pDest += lstrlen(strIRQPattern);

                // First verify that the given string is a valid integer.
                nIRQLen = lstrlen(pDest);
                fValidInt = TRUE;

                for(nIter = 0; nIter <nIRQLen; nIter++)
                {
                    if (_istdigit(pDest[nIter]) == 0)
                    {
                        fValidInt = FALSE;
                        break;
                    }
                }
                if(fValidInt)
                {
                    // Convert the IRQ Number that you get as string to a long
                    varIRQNumber = atol(pDest);

                    //  Create a new instance of PCH_ResourceIRQ Class based on the passed-in MethodContext
                    CInstancePtr pPCHResourceIRQInstance(CreateNewInstance(pMethodContext), false);

                    //  Created a New Instance of PCH_ResourceIRQ Successfully.
                    //  Set the IRQ Number as a variant
                    hRes = pPCHResourceIRQInstance->SetVariant(pValue, varIRQNumber);
                    if (FAILED(hRes))
                    {
                        ErrorTrace(TRACE_ID, "SetVariant on PCH_ResourceIRQ.Value Failed!");
                        //  Proceed Anyway
                    }
      
                    //  Copy the following properties from win32_AllocatedResource class Instance 
                    //  TO PCH_ResourceIRQ class Instance.

                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    //                              Name                                                                       //
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // CopyProperty(pWin32AllocatedResourceObj, L"Dependent", pPCHResourceIRQInstance, pName);

                    

                    // Get the Dependent Value
                    hRes = pWin32AllocatedResourceObj->Get(bstrPropertyDependent, 0, &varDependent, NULL, NULL);
                    if (FAILED(hRes))
                    {
                        //  Could not get the Dependent
                        ErrorTrace(TRACE_ID, "GetVariant on Win32_AllocatedResource:Dependent Field failed.");
                    } 
                    else
                    {
                        // Got the Dependent. Search its value to point to PNPEntity.
                        // varDependent set to Dependent. Copy this to bstrResult
                        varDependent.ChangeType(VT_BSTR, NULL);
                        {
                            USES_CONVERSION;
                            strSource = OLE2A(varDependent.bstrVal);
                        }
                        
                        //  Search for Win32_PNPEntity Pattern.
                        pDest = strstr(strSource,strPNPEntityPattern);
                        
                        if(pDest)
                        {
                            // Advance the pointer to point to the PNPEntity Name
                            pDest += lstrlen(strPNPEntityPattern);
                            
                            // Copy the PNPEntity Name.....
                            varPNPEntity = pDest;
                            
                            //  Set the Name 
                            hRes = pPCHResourceIRQInstance->SetVariant(pName, varPNPEntity);
                            if (FAILED(hRes))
                            {
                                ErrorTrace(TRACE_ID, "SetVariant on win32_AllocatedResource.IRQ Number Failed!");
                                //  Proceed Anyway
                            }
                        }
                    }


                    //  All the properties in pPCHNetworkAdapterInstance are set

                    hRes = pPCHResourceIRQInstance->Commit();
                    if (FAILED(hRes))
                    {
                        //  Cannot commit the Instance
                        ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                    } // end of if FAILED(hRes)
                    
                 }
              } // end of if pDest != NULL
              else
              {
                 //  This is not IRQ Resource
              }  //  end of else pDest != NULL
        } // end of else got the antecedent
    }  //end of Allocated Resource Instances.

END :
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_resourcememrange.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_ResourceMemRange.CPP

Abstract:
	WBEM provider class implementation for PCH_ResourceMemRange class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_ResourceMemRange.h"
// #include "confgmgr.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_RESOURCEMEMRANGE

CPCH_ResourceMemRange MyPCH_ResourceMemRangeSet (PROVIDER_NAME_PCH_RESOURCEMEMRANGE, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pBase = L"Base" ;
const static WCHAR* pCategory = L"Category" ;
const static WCHAR* pTimeStamp = L"TimeStamp" ;
const static WCHAR* pChange = L"Change" ;
const static WCHAR* pEnd = L"End" ;
const static WCHAR* pMax = L"Max" ;
const static WCHAR* pMin = L"Min" ;
const static WCHAR* pName = L"Name" ;

/*****************************************************************************
*
*  FUNCTION    :    CPCH_ResourceMemRange::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_ResourceMemRange::EnumerateInstances(
    MethodContext* pMethodContext,
    long lFlags
    )
{
    TraceFunctEnter("CPCH_ResourceIRQ::EnumerateInstances");

    HRESULT                             hRes = WBEM_S_NO_ERROR;
    REFPTRCOLLECTION_POSITION           posList;

    //  Instances
    CComPtr<IEnumWbemClassObject>       pDeviceMemAddressEnumInst;
    CComPtr<IEnumWbemClassObject>       pWin32AllocatedResourceEnumInst;

    //  Objects
    IWbemClassObjectPtr                 pWin32AllocatedResourceObj;
    IWbemClassObjectPtr                 pDeviceMemAddressObj;


    // Variants
    CComVariant                         varAntecedent;
    CComVariant                         varDependent;
    CComVariant                         varStartingAddress;
    CComVariant                         varPNPEntity;

     //  Query Strings
    CComBSTR                            bstrWin32AllocatedResourceQuery             = L"Select Antecedent, Dependent FROM win32_Allocatedresource";
    CComBSTR                            bstrDeviceMemAddressQuery                   = L"Select StartingAddress, EndingAddress FROM Win32_DeviceMemoryAddress WHERE StartingAddress = ";
    CComBSTR                            bstrDeviceMemAddressQueryString;

    //  Return Values;
    ULONG                               ulWin32AllocatedResourceRetVal              = 0;
    ULONG                               ulDeviceMemAddressRetVal                    = 0;

    //  Integers 
    int                                 i;
    int                                 nStAddren;
    int                                 nIter;

    //  Pattern Strings
    LPCSTR                              strDeviceMemAddressPattern                 = "Win32_DeviceMemoryAddress.StartingAddress=";
    LPCSTR                              strPNPEntityPattern                        = "Win32_PnPEntity.DeviceID=";
    
    //  Chars
    LPSTR                               strSource;
    LPSTR                               pDest;

    BOOL                                fValidInt;

    CComBSTR                            bstrPropertyAntecedent=L"Antecedent";
    CComBSTR                            bstrPropertyDependent=L"Dependent";

    
       
    // Enumerate the instances of Win32_PNPAllocatedResource
    hRes = ExecWQLQuery(&pWin32AllocatedResourceEnumInst, bstrWin32AllocatedResourceQuery);
    if (FAILED(hRes))
    {
        //  Cannot get any properties.
        goto END;
    }

    // Query Succeeded
    while(WBEM_S_NO_ERROR == pWin32AllocatedResourceEnumInst->Next(WBEM_INFINITE, 1, &pWin32AllocatedResourceObj, &ulWin32AllocatedResourceRetVal))
    {

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              Starting Address                                                                  //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Get the Antecedent Value
        hRes = pWin32AllocatedResourceObj->Get(bstrPropertyAntecedent, 0, &varAntecedent, NULL, NULL);
        if (FAILED(hRes))
        {
            //  Could not get the antecedent
            ErrorTrace(TRACE_ID, "GetVariant on Win32_AllocatedResource:Antecedent Field failed.");
        } 
        else
        {
            // Got the Antecedent. Search its value to see if it is a DeviceMemAddress.
            // varAntecedent set to antecedent. Copy this to bstrResult
            varAntecedent.ChangeType(VT_BSTR, NULL);
            {
                USES_CONVERSION;
                strSource = OLE2A(varAntecedent.bstrVal);
            }

            //  Check if it is DeviceMemoryAddress by comparing with the known pattern of DeviceMemoryAddress.
            pDest = strstr(strSource,strDeviceMemAddressPattern);

            if(pDest != NULL)
            {
                //  This is DeviceMemoryAddress Resource instance
                //  Can get the Device Memory Starting Address

                //  Advance the pointer to the end of the pattern so the pointer is 
                //  positioned at Starting Address
                pDest += lstrlen(strDeviceMemAddressPattern);

                //  Formulate the Query String
                bstrDeviceMemAddressQueryString =  bstrDeviceMemAddressQuery;
                bstrDeviceMemAddressQueryString.Append(pDest);

                // At this point the WQL Query can be used to get the win32_DeviceMemoryAddress Instance.
                //  Added the following line because you need to clear the CComPtr before you query the second time.
                pDeviceMemAddressEnumInst = NULL;
                hRes = ExecWQLQuery(&pDeviceMemAddressEnumInst, bstrDeviceMemAddressQueryString);
                if (SUCCEEDED(hRes))
                {
                     //  Query Succeeded. Get the Instance Object
                     if(WBEM_S_NO_ERROR == pDeviceMemAddressEnumInst->Next(WBEM_INFINITE, 1, &pDeviceMemAddressObj, &ulDeviceMemAddressRetVal))
                     {

                         //  Create a new instance of PCH_ResourceMemRange Class based on the passed-in MethodContext
                         CInstancePtr pPCHResourceMemRangeInstance(CreateNewInstance(pMethodContext), false);

                         //  Created a New Instance of PCH_ResourceMemRange Successfully.

                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         //                              StartingAddress                                                                       //
                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         CopyProperty(pDeviceMemAddressObj, L"StartingAddress", pPCHResourceMemRangeInstance, pBase);

                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         //                              EndingAddress                                                                       //
                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         CopyProperty(pDeviceMemAddressObj, L"EndingAddress", pPCHResourceMemRangeInstance, pEnd);

                         
                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         //                              Name                                                                       //
                         /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                         // CopyProperty(pWin32AllocatedResourceObj, L"Dependent", pPCHResourceMemRangeInstance, pName);

                         // Get the Dependent Value
                         hRes = pWin32AllocatedResourceObj->Get(bstrPropertyDependent, 0, &varDependent, NULL, NULL);
                         if (FAILED(hRes))
                         {
                            //  Could not get the Dependent
                            ErrorTrace(TRACE_ID, "GetVariant on Win32_AllocatedResource:Dependent Field failed.");
                         } 
                         else
                         {
                             // Got the Dependent. Search its value to point to PNPEntity.
                             // varDependent set to Dependent. Copy this to bstrResult
                             varDependent.ChangeType(VT_BSTR, NULL);
                             {
                                USES_CONVERSION;
                                strSource = OLE2A(varDependent.bstrVal);
                             }

                             //  Search for Win32_PNPEntity Pattern.
                             pDest = strstr(strSource,strPNPEntityPattern);

                             if(pDest)
                             {
                                 // Advance the pointer to point to the PNPEntity Name
                                 pDest += lstrlen(strPNPEntityPattern);

                                 // Copy the PNPEntity Name.....
                                 varPNPEntity = pDest;

                                 //  Set the Name 
                                 hRes = pPCHResourceMemRangeInstance->SetVariant(pName, varPNPEntity);
                                 if (FAILED(hRes))
                                 {
                                     ErrorTrace(TRACE_ID, "SetVariant on win32_AllocatedResource.IRQ Number Failed!");
                                     //  Proceed Anyway
                                 }
                             }
                         }

                         //  All the properties in pPCHResourceMemRange are set
                         hRes = pPCHResourceMemRangeInstance->Commit();
                         if (FAILED(hRes))
                         {
                            //  Cannot commit the Instance
                            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
                         } // end of if FAILED(hRes)
                    
                     }
                } // end of Query Succeeded.
            } // end of if pDest != NULL
        } // end of else got the antecedent
    }  //end of Allocated Resource Instances.


END:

    TraceFunctLeave();
    return hRes ;

//            pInstance->SetVariant(pBase, <Property Value>);
//            pInstance->SetVariant(pCategory, <Property Value>);
//			  pInstance->SetVariant(pTimeStamp, <Property Value>);
//            pInstance->SetVariant(pChange, <Property Value>);
//            pInstance->SetVariant(pEnd, <Property Value>);
//            pInstance->SetVariant(pMax, <Property Value>);
//            pInstance->SetVariant(pMin, <Property Value>);
//            pInstance->SetVariant(pName, <Property Value>);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_startup.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	PCH_StartUp.CPP

Abstract:
	WBEM provider class implementation for PCH_StartUp class

Revision History:

	Ghim-Sim Chua       (gschua)   04/27/99
		- Created

********************************************************************/

#include "pchealth.h"
#include "PCH_StartUp.h"
#include "shlobj.h"

/////////////////////////////////////////////////////////////////////////////
//  tracing stuff

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_STARTUP

CPCH_StartUp MyPCH_StartUpSet (PROVIDER_NAME_PCH_STARTUP, PCH_NAMESPACE) ;

// Property names
//===============
const static WCHAR* pTimeStamp   = L"TimeStamp" ;
const static WCHAR* pChange      = L"Change" ;
const static WCHAR* pCommand     = L"Command" ;
const static WCHAR* pLoadedFrom  = L"LoadedFrom" ;
const static WCHAR* pName        = L"Name" ;


//**************************************************************************************
//
//  ResolveLink  :  Given the link file with complete Path, this function  resolves it 
//                  to  get its command line.
//**************************************************************************************

HRESULT ResolveLink(CComBSTR bstrLinkFile,   // [in] link filename
                CComBSTR &bstrCommand        // [out] cmd line of program
                                             // needs to be MAX_PATH*2 bytes long
               )
{ 
    //  Begin Declarations

    HRESULT                             hRes; 
    IShellLink                          *pShellLink                   = NULL;
    IPersistFile                        *pPersistFile;
    TCHAR                               tchGotPath[MAX_PATH]; 
    TCHAR                               tchArgs[MAX_PATH];
    WIN32_FIND_DATA                     wfdFileData;  

    //   End Declarations

    // Get a pointer to the IShellLink interface. 
    hRes = CoCreateInstance(CLSID_ShellLink, NULL, 
                            CLSCTX_INPROC_SERVER,
                            IID_IShellLink, 
                            (LPVOID *) &pShellLink); 

    if(SUCCEEDED(hRes)) 
    { 
        // Get a pointer to the IPersistFile interface. 
        hRes = pShellLink->QueryInterface(IID_IPersistFile, (void **)&pPersistFile);
        if (SUCCEEDED(hRes))
        {
            // Load the shortcut. 
            hRes = pPersistFile->Load(bstrLinkFile, STGM_READ);
            if(SUCCEEDED(hRes)) 
            { 
                try
                {
                    // Resolve the link. 
                    hRes = pShellLink->Resolve(NULL, 
                                    SLR_NOTRACK|SLR_NOSEARCH|SLR_NO_UI|SLR_NOUPDATE); 
                    if (SUCCEEDED(hRes))
                    {  
                        // Get the path to the link target. 
                        hRes = pShellLink->GetPath(tchGotPath, 
                                        MAX_PATH,
                                        (WIN32_FIND_DATA *)&wfdFileData, 
                                        SLGP_UNCPRIORITY );                     
                        if(SUCCEEDED(hRes))
                        {
                            // bstrPath = tchGotPath;
                            bstrCommand = tchGotPath;
                            // Get cmd line arguments
                            hRes = pShellLink->GetArguments(tchArgs, MAX_PATH);
                            if(SUCCEEDED(hRes))
                            {   
                                bstrCommand.Append(tchArgs);
                            }
                        }
                    }
                }
                catch(...)
                {
                    pPersistFile->Release();
                    pShellLink->Release();
                    throw;
                }
            }        

            // Release the pointer to the IPersistFile interface. 
            pPersistFile->Release(); 
        }
         
        // Release the pointer to the IShellLink interface.     
        pShellLink->Release(); 
    } 
    return hRes;
}

//**************************************************************************************
//
//  UpdateInstance  :  Given all the properties for the instance this function copies 
//                     them to the instance.
//
//**************************************************************************************

HRESULT         UpdateInstance(
                               CComVariant      varName,                // [in]  Name of the Startup Instance
                               CComVariant      varLoadedFrom,          // [in]  Registry/StartupGroup
                               CComVariant      varCommand,             // [in]  Command of the startup Instance
                               SYSTEMTIME       stUTCTime,              // [in]  
                               CInstancePtr     pPCHStartupInstance,     // [in/out] Instance is created by the caller.
                               BOOL*            fCommit
                               )
{
    TraceFunctEnter("::updateInstance");

    HRESULT                     hRes;
    CComVariant                 varSnapshot             = "SnapShot";
    
    hRes = pPCHStartupInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
    if (FAILED(hRes))
    {
         //  Could not Set the Time Stamp
         //  Continue anyway
         ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CHANGE                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHStartupInstance->SetVariant(pChange, varSnapshot);
    if (FAILED(hRes))
    {
        //  Could not Set the CHANGE property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on SnapShot Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              NAME                                                                       //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////


    hRes = pPCHStartupInstance->SetVariant(pName, varName);
    if (FAILED(hRes))
    {
        //  Could not Set the NAME property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "SetVariant on Name Field failed.");
    }
    else
    {
        *fCommit = TRUE;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              LOADEDFROM                                                                 //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////


    hRes = pPCHStartupInstance->SetVariant(pLoadedFrom, varLoadedFrom);
    if (FAILED(hRes))
    {
        //  Could not Set the LOADEDFROM property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set variant on LOADEDFROM Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              COMMAND                                                                    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHStartupInstance->SetVariant(pCommand, varCommand);
    if (FAILED(hRes))
    {
        //  Could not Set the COMMAND property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on COMMAND Field failed.");
    }
                
    
    TraceFunctLeave();
    return(hRes);

}

//**************************************************************************************
//
//  UpdateRegistryInstance  :  Given the Registry Root and the Hive this function creates 
//                             as many instances of PCH_StartUp Class as there are 
//                             entries in the particular hive.
//
//**************************************************************************************

HRESULT         CPCH_StartUp::UpdateRegistryInstance(
                               HKEY             hkeyRoot,                   // [in]  For now this is either HKLM or HKCU
                               LPCTSTR          lpctstrRegistryHive,        // [in]  Registry hive to look for startup entries
                               CComVariant      varLoadedFrom,              // [in]  Constant string to fill the property "Loaded From"
                               SYSTEMTIME       stUTCTime,                  // [in]  To fill up the "Timestamp" Field
                               MethodContext*   pMethodContext              // [in]  Required to create Instances.
                               )
{
    TraceFunctEnter("::UpdateRegistryInstance");

    //  Begin Declarations

    HRESULT                             hRes;

    HKEY                                hkeyRun;

    DWORD                               dwIndex;
    DWORD                               dwType;
    DWORD                               dwNameSize;
    DWORD                               dwValueSize;

    TCHAR                               tchRunKeyName[MAX_PATH];
    TCHAR                               tchRunKeyValue[MAX_PATH];
  

    CComVariant                         varSnapshot                         = "SnapShot";
    CComVariant                         varCommand;
    CComVariant                         varName;

    LONG                                lregRetValue;

    BOOL                                fCommit                             = FALSE;

    

    //  End Declarations
    //  Initializations
    varCommand.Clear();
    varName.Clear();

    //  Get the startup progrmas from  the given registry Hive
   
    lregRetValue = RegOpenKeyEx(hkeyRoot, lpctstrRegistryHive, 0, KEY_QUERY_VALUE, &hkeyRun);
    if(lregRetValue == ERROR_SUCCESS)
	{
		//  Opened the Registry key.
        //  Enumerate the Name, Value pairs under this hive. 
        //  Initialize dwIndex, dwNameSize, dwValueSize

        dwIndex = 0;
        dwNameSize = MAX_PATH;
        dwValueSize = MAX_PATH;
        lregRetValue = RegEnumValue(hkeyRun, dwIndex, tchRunKeyName, &dwNameSize, NULL, NULL,(LPBYTE)tchRunKeyValue, &dwValueSize);
        while(lregRetValue == ERROR_SUCCESS)
        {
            //  Got the Name and Value i.e "NAME" and "COMMAND"
            varName = tchRunKeyName;
            varCommand = tchRunKeyValue;
            
            //  Create an instance of PCH_Startup 
            //  Create a new instance of PCH_StartupInstance Class based on the passed-in MethodContext
            CInstancePtr pPCHStartupInstance(CreateNewInstance(pMethodContext), false);

            //  Call updateInstance now.
            try
            {
                hRes = UpdateInstance(varName, varLoadedFrom, varCommand,  stUTCTime, pPCHStartupInstance, &fCommit);
            }
            catch(...)
            {
                lregRetValue = RegCloseKey(hkeyRun);
                if(lregRetValue != ERROR_SUCCESS)
                {
                    //  Could not Close the Key
                    ErrorTrace(TRACE_ID, "Reg Close Key failed.");
                }
                throw;
            }
            if(fCommit)
            {
                hRes = pPCHStartupInstance->Commit();
                if(FAILED(hRes))
                {
                    //  Could not Commit the instance
                    ErrorTrace(TRACE_ID, "Commit on PCHStartupInstance Failed");
                }
            }

            //  Reinitialize dwNameSize and dwValueSize

            dwIndex++;
            dwNameSize = MAX_PATH;
            dwValueSize = MAX_PATH;
            lregRetValue = RegEnumValue(hkeyRun, dwIndex, tchRunKeyName, &dwNameSize, NULL, NULL,(LPBYTE)tchRunKeyValue, &dwValueSize);

        } // while Enum
        lregRetValue = RegCloseKey(hkeyRun);
        if(lregRetValue != ERROR_SUCCESS)
        {
            //  Could not Close the Key
            ErrorTrace(TRACE_ID, "Reg Close Key failed.");
        }
    }  // if SUCCEEDED 

    TraceFunctLeave();
    return(hRes);

}
//**************************************************************************************
//
//  UpdateStartupGroupInstance  :  Given the Startup Folder this function gets all the 
//                                 link files in the folder and Calls the Function 
//                                 ResolveLink to get the command Line of the Link File.
//                                 This also creates a PCH_Startup Class Instance  for
//                                 each link file.
//
//**************************************************************************************

HRESULT         CPCH_StartUp::UpdateStartupGroupInstance(
                               int              nFolder,                 // [in]  Special Folder to look for startup entries
                               SYSTEMTIME       stUTCTime,               // [in]  
                               MethodContext*   pMethodContext           // [in]  Instance is created by the caller.
                               )
{
    TraceFunctEnter("::UpdateStartupGroup Instance");

    //  Begin Declarations

    HRESULT                             hRes;

    LPCTSTR                             lpctstrLinkExtension        = _T("\\*.lnk");

    CComBSTR                            bstrPath;
    CComBSTR                            bstrSlash                   = "\\";
    CComBSTR                            bstrCommand;
    CComBSTR                            bstrPath1;
    
    TCHAR                               tchLinkFile[MAX_PATH];
    TCHAR                               tchProgramName[2*MAX_PATH];
    TCHAR                               tchPath[MAX_PATH];
    TCHAR                               tchFileName[MAX_PATH];
    LPCTSTR                             lpctstrCouldNot             = "Could Not Resolve the File";

    CComVariant                         varCommand;
    CComVariant                         varName;
    CComVariant                         varLoadedFrom               = "Startup Group";

    HANDLE                              hLinkFile;

    WIN32_FIND_DATA                     FindFileData;

    HWND                                hwndOwner                   = NULL;

    BOOL                                fCreate                     = FALSE;
    BOOL                                fShouldClose                = FALSE;
    BOOL                                fContinue                   = FALSE;
    BOOL                                fCommit                     = FALSE;

    int                                 nFileNameLen;
    int                                 nExtLen                     = 4;

    //  End Declarations



    //  Get the Path to the passed in Special Folder nFolder
    if (SHGetSpecialFolderPath(hwndOwner,tchPath,nFolder,fCreate))
    {
        //  Got the Startup Folder
        bstrPath1 = tchPath;
        bstrPath1.Append(bstrSlash);

        _tcscat(tchPath, lpctstrLinkExtension);
        
        hLinkFile = FindFirstFile(tchPath, &FindFileData);  // data returned  
        if(hLinkFile != INVALID_HANDLE_VALUE)
        {
            fContinue = TRUE;
            fShouldClose = TRUE;
        }
        else
        {
            fContinue = FALSE;
            fShouldClose = FALSE;
        }
        while(fContinue)
        {
            //  Got the Link 
            bstrPath = bstrPath1;
            bstrPath.Append(FindFileData.cFileName);

            // Take out the ".lnk" extension
            nFileNameLen = _tcslen(FindFileData.cFileName);
            nFileNameLen -= nExtLen;
            _tcsncpy(tchFileName, FindFileData.cFileName, nFileNameLen);
            tchFileName[nFileNameLen]='\0';
            varName = tchFileName;
            hRes = ResolveLink(bstrPath, bstrCommand);
            if(SUCCEEDED(hRes))
            {
                // Resolved the File Name
                varCommand = bstrCommand;
            }
            else
            {
                //  Could not resolve the File
                varCommand = lpctstrCouldNot;
            }
            
            //  Create an instance of PCH_Startup 
            CInstancePtr pPCHStartupInstance(CreateNewInstance(pMethodContext), false);

            //  Call updateInstance now.
            try
            {
                hRes = UpdateInstance(varName, varLoadedFrom, varCommand, stUTCTime, pPCHStartupInstance, &fCommit);
            }
            catch(...)
            {
                if (!FindClose(hLinkFile))
                {
                    //  Could not close the handle
                    ErrorTrace(TRACE_ID, "Could not close the File Handle");
                }
                throw;
            }
            if(fCommit)
            {
                hRes = Commit(pPCHStartupInstance);
                if(FAILED(hRes))
                {
                    //  Could not Commit the instance
                    ErrorTrace(TRACE_ID, "Commit on PCHStartupInstance Failed");
                }
            }
            if(!FindNextFile(hLinkFile, &FindFileData))
            {
                fContinue = FALSE;
            }
        }
        
        //  Close the Find File Handle.

        if(fShouldClose)
        {
            if (!FindClose(hLinkFile))
            {
                //  Could not close the handle
                ErrorTrace(TRACE_ID, "Could not close the File Handle");
            }
        }
                                 
    }
    return(hRes);
    TraceFunctLeave();
}
                

/*****************************************************************************
*
*  FUNCTION    :    CPCH_StartUp::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here.
*                       If there are no instances, return WBEM_S_NO_ERROR.
*                       It is not an error to have no instances.
*
*****************************************************************************/
HRESULT CPCH_StartUp::EnumerateInstances(
                                        MethodContext*              pMethodContext,
                                        long                        lFlags
                                        )
{
    TraceFunctEnter("CPCH_StartUp::EnumerateInstances");
    
    //  Begin Declarations...................................................

    HRESULT                             hRes                        = WBEM_S_NO_ERROR;

    SYSTEMTIME                          stUTCTime;

    //  Registry Hives of interest
    LPCTSTR                             lpctstrRunHive              = _T("software\\microsoft\\windows\\currentversion\\run");
    LPCTSTR                             lpctstrRunServicesHive      = _T("software\\microsoft\\windows\\currentversion\\runservices");

    int                                 nFolder;
    int                                 nIndex;

    CComVariant                         varMachineRun               = "Registry (Machine Run)";
    CComVariant                         varMachineService           = "Registry (Machine Service)";
    CComVariant                         varPerUserRun               = "Registry (Per User Run)";
    CComVariant                         varPerUserService           = "Registry (Per User Service)";


    //  End Declarations...................................................

    GetSystemTime(&stUTCTime);

    //  Get the StartUp Programs From HKLM\software\microsoft\windows\currentversion\run
    hRes = UpdateRegistryInstance(HKEY_LOCAL_MACHINE, lpctstrRunHive, varMachineRun, stUTCTime, pMethodContext);
    if(hRes == WBEM_E_OUT_OF_MEMORY)
    {
        goto END;
    }

    //  Get the StartUp Programs From HKLM\software\microsoft\windows\currentversion\runservices
    hRes = UpdateRegistryInstance(HKEY_LOCAL_MACHINE, lpctstrRunServicesHive, varMachineService, stUTCTime, pMethodContext);
    if(hRes == WBEM_E_OUT_OF_MEMORY)
    {
        goto END;
    }


    //  Get the StartUp Programs From HKCU\software\microsoft\windows\currentversion\run
    hRes = UpdateRegistryInstance(HKEY_CURRENT_USER, lpctstrRunHive, varPerUserRun, stUTCTime, pMethodContext);
    if(hRes == WBEM_E_OUT_OF_MEMORY)
    {
        goto END;
    }


    //  Get the StartUp Programs From HKCU\software\microsoft\windows\currentversion\runservices
    hRes = UpdateRegistryInstance(HKEY_CURRENT_USER, lpctstrRunServicesHive, varPerUserService, stUTCTime, pMethodContext);
    if(hRes == WBEM_E_OUT_OF_MEMORY)
    {
        goto END;
    }


    //  Get the rest of the instances of startup programs from the Startup Group.
    //  The two directories to look for are : Startup and common\startup

	//  CSIDL_STARTUP (current user)
    hRes = UpdateStartupGroupInstance(CSIDL_STARTUP, stUTCTime, pMethodContext);
    if(hRes == WBEM_E_OUT_OF_MEMORY)
    {
        goto END;
    }

    //  CSIDL_COMMON_STARTUP (all users)
    hRes = UpdateStartupGroupInstance(CSIDL_COMMON_STARTUP, stUTCTime, pMethodContext);

END:    TraceFunctLeave();
     return WBEM_S_NO_ERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_winsock.cpp ===
/*****************************************************************************

  Copyright (c) 1999 Microsoft Corporation
  
    Module Name:
        PCH_Winsock.CPP

    Abstract:
        WBEM provider class implementation for PCH_Winsock class.
        This class does not use any existing Win32 Class 

    Revision History:
        Kalyani Narlanka        (kalyanin)                  04/27/99
            - Created

        Kalyani Narlanka        (kalyanin)                  05/10/99
            - Added   Name, Size, Version, Description, SystemStatus, MaxUDP, MAXSockets,
              Change, Timestamp                             


*******************************************************************************/

//  #includes
#include "pchealth.h"
#include "PCH_WINSOCK.h"

//  #defines
//  nMajorVersion represents the Major Version as seen in OSVERSIONINFO
#define             nMajorVersion               4  
//  nMinorVersion represents the Minor Version as seen in OSVERSIONINFO
#define             nMinorVersion               10

///////////////////////////////////////////////////////////////////////////////
//    Begin Tracing stuff
//
#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_WINSOCK
//
//    End Tracing stuff
///////////////////////////////////////////////////////////////////////////////


CPCH_WINSOCK MyPCH_WINSOCKSet (PROVIDER_NAME_PCH_WINSOCK, PCH_NAMESPACE) ;

///////////////////////////////////////////////////////////////////////////////
//....Properties of PCHWinsock Class
//

const static WCHAR* pTimeStamp           = L"TimeStamp" ;
const static WCHAR* pChange              = L"Change" ;
const static WCHAR* pDescription         = L"Description" ;
const static WCHAR* pMaxSockets          = L"MaxSockets" ;
const static WCHAR* pMaxUDP              = L"MaxUDP" ;
const static WCHAR* pName                = L"Name" ;
const static WCHAR* pSize                = L"Size" ;
const static WCHAR* pSystemStatus        = L"SystemStatus" ;
const static WCHAR* pVersion             = L"Version" ;


//*****************************************************************************
//
// Function Name     : CPCH_WINSOCK::EnumerateInstances
//
// Input Parameters  : pMethodContext : Pointer to the MethodContext for 
//                                      communication with WinMgmt.
//                
//                     lFlags :         Long that contains the flags described 
//                                      in IWbemServices::CreateInstanceEnumAsync
//                                      Note that the following flags are handled 
//                                      by (and filtered out by) WinMgmt:
//                                      WBEM_FLAG_DEEP
//                                      WBEM_FLAG_SHALLOW
//                                      WBEM_FLAG_RETURN_IMMEDIATELY
//                                      WBEM_FLAG_FORWARD_ONLY
//                                      WBEM_FLAG_BIDIRECTIONAL
// Output Parameters  : None
//
// Returns            : WBEM_S_NO_ERROR 
//                      
//
// Synopsis           : There is a single instance of this class on the machine 
//                      and this is returned..
//                      If there is no instances returns WBEM_S_NO_ERROR.
//                      It is not an error to have no instances.
//
//*****************************************************************************

HRESULT CPCH_WINSOCK::EnumerateInstances(MethodContext* pMethodContext,
                                                long lFlags)
{
    TraceFunctEnter("CPCH_Winsock::EnumerateInstances");

    //  Begin Declarations...................................................

    HRESULT                                 hRes = WBEM_S_NO_ERROR;

    //  PCH_WinSock Class instance 
    //  CInstance                               *pPCHWinsockInstance;

    //  Strings
    TCHAR                                   tchBuf[MAX_PATH];
    TCHAR                                   tchTemp[MAX_PATH];
    TCHAR                                   szDirectory[MAX_PATH];
    TCHAR                                   tchWinsockDll[MAX_PATH];

    LPCTSTR                                 lpctstrWS2_32Dll                    = _T("ws2_32.dll");
    LPCTSTR                                 lpctstrWSock32Dll                   = _T("wsock32.dll");
    LPCWSTR                                 lpctstrFileSize                     = L"FileSize";
    LPCTSTR                                 lpctstrWSAStartup                   = _T("WSAStartup");
    LPCTSTR                                 lpctstrWSACleanup                   = _T("WSACleanup");

    //  WORDs
    WORD                                    wVersionRequested;

    //  WSAData
    WSADATA                                 wsaData;

    // CComVariants
    CComVariant                             varValue;
    CComVariant                             varSnapshot                         = "Snapshot";

    //  ints
    int                                     nError;

    //  HINSTANCE 
    HINSTANCE                               hModule; 

    //  OSVersion
    OSVERSIONINFO                           osVersionInfo;

    //  SystemTime
    SYSTEMTIME                              stUTCTime;

    //  Strings
    CComBSTR                                bstrWinsockDllWithPath;

    BOOL                                    fWinsockDllFound                  = FALSE;

    struct _stat                            filestat;

    ULONG                                   uiReturn;

    IWbemClassObjectPtr                     pWinsockDllObj;

    LPFN_WSASTARTUP                         WSAStartup;
    LPFN_WSACLEANUP                         WSACleanup;

    BOOL                                    fCommit                         = FALSE;

//  END  Declarations


    //  There is only one instance of PCH_Winsock class

    //  Create a new instance of PCH_Winsock Class based on the passed-in MethodContext
    CInstancePtr pPCHWinsockInstance(CreateNewInstance(pMethodContext), false);

    // Get the date and time to update the TimeStamp Field
    GetSystemTime(&stUTCTime);


    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              TIME STAMP                                                                 //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHWinsockInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
    if (FAILED(hRes))
    {
        //  Could not Set the Time Stamp
        //  Continue anyway
        ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CHANGE                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHWinsockInstance->SetVariant(pChange, varSnapshot);
    if (FAILED(hRes))
    {
        //  Could not Set the Change Property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on Change Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              NAME                                                                       //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //  Before callling GetVersionEx set dwOSVersionInfoSize to the foll.
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
   
    if (GetVersionEx(&osVersionInfo) != 0)
    {
        if (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        {
            if ((osVersionInfo.dwMajorVersion == nMajorVersion) && (osVersionInfo.dwMinorVersion >= nMinorVersion))
            {
                _tcscpy(tchWinsockDll, lpctstrWS2_32Dll);
            }
            else if (osVersionInfo.dwMajorVersion > nMajorVersion) 
            {
                _tcscpy(tchWinsockDll, lpctstrWS2_32Dll);
            }
            else 
            {
                _tcscpy(tchWinsockDll, lpctstrWSock32Dll);
            }
        } //end of osVersionInfo.... if
        else if (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            _tcscpy(tchWinsockDll, lpctstrWS2_32Dll);
        }
        else 
        {
            _tcscpy(tchWinsockDll, lpctstrWS2_32Dll);
        }
    } //end of if GetVersionEx
    else
    {
        _tcscpy(tchWinsockDll, lpctstrWS2_32Dll);
    }

    //  Got the right winsock DLL Name
    //  Load the Library
    varValue = tchWinsockDll;
    hModule = LoadLibrary(tchWinsockDll);
    if (hModule == NULL)
    {
        goto END;
    }
    else
    {
        fCommit = TRUE;
    }
    try
    {
        hRes = pPCHWinsockInstance->SetVariant(pName, varValue);
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Name Field failed.");
        }
    }
    catch(...)
    {
        FreeLibrary(hModule);
        throw;
    }
    
    if ((WSAStartup = (LPFN_WSASTARTUP) GetProcAddress(hModule, lpctstrWSAStartup)) == NULL)
    {
        FreeLibrary(hModule);
        goto END;
    }
    if ((WSACleanup = (LPFN_WSACLEANUP) GetProcAddress(hModule, lpctstrWSACleanup)) == NULL)
    {
        FreeLibrary(hModule);
        goto END;       
    }

    try
    {
        wVersionRequested = MAKEWORD( 2, 0 );
        nError = (*WSAStartup)( wVersionRequested, &wsaData );
        if (nError != 0)
        {
            // Cannot get any winsock values
            goto END;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              SIZE                                                                //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        fWinsockDllFound =  getCompletePath(tchWinsockDll, bstrWinsockDllWithPath);
        if(fWinsockDllFound)
        {
            // Got the complete Path , use this to get the filesize.
            if(SUCCEEDED(GetCIMDataFile(bstrWinsockDllWithPath, &pWinsockDllObj)))
            {
                // From the CIM_DataFile Object get the size property

                CopyProperty(pWinsockDllObj, lpctstrFileSize, pPCHWinsockInstance, pSize);
        
            }
        }
    
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              VERSION                                                                    //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        _stprintf(tchBuf, "%d.%d", LOBYTE(wsaData.wHighVersion), HIBYTE(wsaData.wHighVersion));
        varValue = tchBuf;
        hRes = pPCHWinsockInstance->SetVariant(pVersion, varValue);
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Version Field failed.");
        }
        
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              DESCRIPTION                                                                //                                                                              KAYANI                                                                                                                                                                  -9++***************************---------------------------------------------------------+++
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        if (_tcslen(wsaData.szDescription) < sizeof(tchBuf))
        {
            _tcscpy(tchBuf, wsaData.szDescription);
        }
        else
        {
            _tcsncpy(tchBuf, wsaData.szDescription, sizeof(tchBuf)-1);
            tchBuf[sizeof(tchBuf)] = 0;
        }

        varValue = tchBuf;
        hRes =  pPCHWinsockInstance->SetVariant(pDescription,  varValue);
        if(FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on Description Field failed.");
        }
   

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              SYSTEMSTATUS                                                               //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
        if (_tcslen(wsaData.szSystemStatus) < sizeof(tchBuf))
        _tcscpy(tchBuf, wsaData.szSystemStatus);
        else
        {
            _tcsncpy(tchBuf, wsaData.szSystemStatus, sizeof(tchBuf)-1);
            tchBuf[sizeof(tchBuf)] = 0;
        }
       
        varValue = tchBuf;
        hRes =  pPCHWinsockInstance->SetVariant(pSystemStatus, varValue);
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on SystemStatus Field failed.");
        }
   

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              MAXUDP                                                               //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////

        if (LOBYTE(wsaData.wHighVersion) >= 2)
        {
           varValue = 0;
        }
        else
        {
            varValue = wsaData.iMaxUdpDg;
        }
        hRes = pPCHWinsockInstance->SetVariant(pMaxUDP, varValue);
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on MAXUDP Field failed.");
        }
    

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //                              MAXSOCKETS                                                                 //
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        if (LOBYTE(wsaData.wHighVersion) >= 2)
        {
            varValue = 0;
        }
        else
        {
            varValue = wsaData.iMaxSockets;
        }
        hRes =  pPCHWinsockInstance->SetVariant(pMaxSockets, varValue);
        if (FAILED(hRes))
        {
            //  Could not Set the Change Property
            //  Continue anyway
            ErrorTrace(TRACE_ID, "Set Variant on MaxSockets Field failed.");
        }
        if(fCommit)
        {
            hRes = pPCHWinsockInstance->Commit();
            if (FAILED(hRes))
            {   
                //  Could not Commit
                //  Continue anyway
                ErrorTrace(TRACE_ID, "Commit failed.");
            }
        }

        if(0 != (*WSACleanup)())
        {
             //  Could not Cleanup
            //  Continue anyway
            ErrorTrace(TRACE_ID, "WSACleanup failed.");
        }
        
        FreeLibrary(hModule);
    }
    catch(...)
    {
        if(0 != (*WSACleanup)())
        {
             //  Could not Cleanup
            //  Continue anyway
            ErrorTrace(TRACE_ID, "WSACleanup failed.");
        }
        
        FreeLibrary(hModule);
        throw;
    }

END:    TraceFunctLeave();
        return hRes ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\pch_sysinfo.cpp ===
/*****************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
   .PCH_SysInfo.CPP

Abstract:
    WBEM provider class implementation for PCH_SysInfo class.
    1. This class gets the foll. properties from Win32_OperatingSystem Class:
       "OSName", "Version" 
       and sets "PCH_SysInfo.OsName" property.
    2. Gets the foll. properties from Win32_Processor Class:
       "Manufacturer", "Description"
       and sets "PCH_SysInfo.Processor" property.
    3. Gets the foll. properties from Win32_LogicalMemoryConfiguration Class:
       "TotalPhysicalMemory"
       and sets "PCH_SysInfo.RAM" property.
    4. Gets the foll. properties from Win32_PageFile Class:
       "Name", "FreeSpace", "FSName"
        and sets PCH_SysInfo.SwapFile Property.
    5. Sets the "Change" property to "Snapshot" always
 
Revision History:

    Ghim Sim Chua          (gschua )    04/27/99
     - Created
    Kalyani Narlanka       (kalyanin)   05/03/99
     - Added  properties

*******************************************************************************/

#include "pchealth.h"
#include "PCH_Sysinfo.h"

///////////////////////////////////////////////////////////////////////////////
//    Begin Tracing stuff
//

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile
#define TRACE_ID    DCID_SYSINFO
//
//    End Tracing stuff
///////////////////////////////////////////////////////////////////////////////

CPCH_Sysinfo MyPCH_SysinfoSet (PROVIDER_NAME_PCH_SYSINFO, PCH_NAMESPACE) ;

///////////////////////////////////////////////////////////////////////////////

//     Different types of Installation

#define         IDS_SKU_NET                     "network"
#define         IDS_SKU_CD_UPGRADE              "CD"
#define         IDS_SKU_FLOPPY_UPGRADE          "Floppy"
#define         IDS_SKU_FLOPPY_FULL             "Full Floppy"
#define         IDS_SKU_SELECT_FLOPPY           "floppy"
#define         IDS_SKU_SELECT_CD               "Select CD"
#define         IDS_SKU_OEM_DISKMAKER           "OEM"
#define         IDS_SKU_OEM_FLOPPY              "OEM floppy"
#define         IDS_SKU_OEM_CD                  "OEM CD"
#define         IDS_SKU_MS_INTERNAL             "Microsoft Internal"
#define         IDS_SKU_CD_FULL                 "Full CD"
#define         IDS_SKU_WEB                     "Web"
#define         IDS_SKU_MSDN_CD                 "MSDN CD"
#define         IDS_SKU_OEM_CD_FULL             "Full OEM CD"
#define         IDS_SKU_OEM_PREINST_KIT         "OEM Preinstall Kit"
#define         MAX_LEN                         20
#define         ONEK                            1024
#define         HALFK                           512


//....Properties of PCHSysInfo Class
//
const static WCHAR* pOSLanguage          = L"OSLanguage";
const static WCHAR* pManufacturer        = L"Manufacturer";
const static WCHAR* pModel               = L"Model";
const static WCHAR* pTimeStamp           = L"TimeStamp" ;  
const static WCHAR* pChange              = L"Change" ;     
const static WCHAR* pIEVersion           = L"IEVersion" ;  
const static WCHAR* pInstall             = L"Install" ;
const static WCHAR* pMode                = L"Mode" ;
const static WCHAR* pOSName              = L"OSName" ;
const static WCHAR* pOSVersion           = L"OSVersion";
const static WCHAR* pProcessor           = L"Processor" ;
const static WCHAR* pClockSpeed          = L"ClockSpeed" ;
const static WCHAR* pRAM                 = L"RAM" ;
const static WCHAR* pSwapFile            = L"SwapFile" ;
const static WCHAR* pSystemID            = L"SystemID" ;
const static WCHAR* pUptime              = L"Uptime" ;
const static WCHAR* pOSBuildNumber       = L"OSBuildNumber";


//*****************************************************************************
//
// Function Name     : CPCH_SysInfo::EnumerateInstances
//
// Input Parameters  : pMethodContext : Pointer to the MethodContext for 
//                                      communication with WinMgmt.
//                
//                     lFlags :         Long that contains the flags described 
//                                      in IWbemServices::CreateInstanceEnumAsync
//                                      Note that the following flags are handled 
//                                      by (and filtered out by) WinMgmt:
//                                      WBEM_FLAG_DEEP
//                                      WBEM_FLAG_SHALLOW
//                                      WBEM_FLAG_RETURN_IMMEDIATELY
//                                      WBEM_FLAG_FORWARD_ONLY
//                                      WBEM_FLAG_BIDIRECTIONAL
// Output Parameters  : None
//
// Returns            : WBEM_S_NO_ERROR 
//                      
//
// Synopsis           : All instances of this class on the machine are returned.
//                      If there are no instances returns WBEM_S_NO_ERROR.
//                      It is not an error to have no instances.
//                 
//
//*****************************************************************************

HRESULT CPCH_Sysinfo::EnumerateInstances(MethodContext* pMethodContext,
                                                long lFlags)
{
    TraceFunctEnter("CPCH_Sysinfo::EnumerateInstances");

//  Begin Declarations...................................................
//                                                                 
    HRESULT                             hRes = WBEM_S_NO_ERROR;

    //  Instances
    CComPtr<IEnumWbemClassObject>       pOperatingSystemEnumInst;
    CComPtr<IEnumWbemClassObject>       pProcessorEnumInst;
    CComPtr<IEnumWbemClassObject>       pLogicalMemConfigEnumInst;
    CComPtr<IEnumWbemClassObject>       pPageFileEnumInst;
    CComPtr<IEnumWbemClassObject>       pComputerSystemEnumInst;

    //  CInstance                           *pPCHSysInfoInstance;

    //  WBEM Objects
    IWbemClassObjectPtr                 pOperatingSystemObj;           // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr                 pProcessorObj;                 // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr                 pLogicalMemConfigObj;          // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr                 pPageFileObj;                  // BUGBUG : WMI asserts if we use CComPtr
    IWbemClassObjectPtr                 pComputerSystemObj;            // BUGBUG : WMI asserts if we use CComPtr

   
    //  Variants
    CComVariant                         varValue;
    CComVariant                         varCaption;
    CComVariant                         varVersion;
    CComVariant                         varSnapshot                     = "Snapshot";
    CComVariant                         varRam;
    CComVariant                         varPhysicalMem;

    //  Return Values
    ULONG                               ulOperatingSystemRetVal;
    ULONG                               ulProcessorRetVal;
    ULONG                               ulLogicalMemConfigRetVal;
    ULONG                               ulPageFileRetVal;
    ULONG                               ulComputerSystemRetVal;

    LONG                                lRegKeyRet;
    LONG                                lSystemID;

    //  Query Strings
    CComBSTR                            bstrOperatingSystemQuery        = L"Select Caption, Version, Name, OSLanguage, BuildNumber FROM Win32_OperatingSystem";
    CComBSTR                            bstrProcessorQuery              = L"Select DeviceID, Name, Manufacturer, CurrentClockSpeed FROM Win32_Processor";
    CComBSTR                            bstrLogicalMemConfigQuery       = L"Select Name, TotalPhysicalMemory FROM Win32_LogicalMemoryConfiguration";
    CComBSTR                            bstrPageFileQuery               = L"Select Name, FreeSpace, FSName FROM Win32_PageFile";
    CComBSTR                            bstrComputerSystemQuery         = L"Select Name, BootupState, Manufacturer, Model FROM Win32_ComputerSystem";
    CComBSTR                            bstrQueryString;

    CComBSTR                            bstrProperty;
    CComBSTR                            bstrVersion                     = L"Version";
    CComBSTR                            bstrCaption                     = L"Caption";
    CComBSTR                            bstrManufacturer                = L"Manufacturer";
    CComBSTR                            bstrModel                       = L"Model";
    CComBSTR                            bstrOSLanguage                  = L"OSLanguage";
    CComBSTR                            bstrName                        = L"Name";
    CComBSTR                            bstrFreeSpace                   = L"FreeSpace";
    CComBSTR                            bstrFSName                      = L"FSName";
    CComBSTR                            bstrBuildNumber                 = L"BuildNumber";
    CComBSTR                            bstrSemiColon                   = L" ; ";
        
    LPCTSTR                             lpctstrSpaces                   = "  ";
    LPCTSTR                             lpctstrCleanInstall             = _T("Clean Install Using");
    LPCTSTR                             lpctstrUpgradeInstall           = _T("Upgrade Using");

    CComBSTR                            bstrProcessor;
    CComBSTR                            bstrOSName;
    CComBSTR                            bstrSwapFile;

     //  Registry Hive where IE info is stored
    LPCTSTR                             lpctstrIEHive                   = _T("Software\\Microsoft\\windows\\currentversion");
    LPCTSTR                             lpctstrSystemIDHive             = _T("Software\\Microsoft\\PCHealth\\MachineInfo");

    LPCTSTR                             lpctstrUpgrade                  = _T("Upgrade");
    LPCTSTR                             lpctstrProductType              = _T("ProductType");
    LPCTSTR                             lpctstrCommandLine              = _T("CommandLine");
    LPCTSTR                             lpctstrIEVersion                = _T("Plus! VersionNumber");
    LPCWSTR                             lpctstrVersion                  = L"Version";
    LPCWSTR                             lpctstrBootupState              = L"BootupState";
    LPCWSTR                             lpctstrTotalPhysicalMemory      = L"TotalPhysicalMemory";
    LPCTSTR                             lpctstrComputerName             = _T("ComputerName");
    LPCTSTR                             lpctstrCurrentUser              = _T("Current User");
    LPCTSTR                             lpctstrMBFree                   = _T(" MB Free ");
    LPCWSTR                             lpctstrClockSpeed               = L"CurrentClockSpeed";
    LPCWSTR                             lpctstrCaption                  = L"Name";
    
    //  Format Strings
    LPCTSTR                             lpctstrSystemIDFormat           = _T("On \"%s\" as \"%s\"");
    LPCTSTR                             lpctstrOSNameFormat             = _T("%s  %s");
    LPCTSTR                             lpctstrInstallFormat            = _T("%s %s %s");
    LPCTSTR                             lpctstrUptimeFormat             = _T("%d:%02d:%02d:%02d");

    LPCSTR                              lpctstrInstallHive              = "Software\\Microsoft\\Windows\\CurrentVersion\\Setup";
    LPCSTR                              lpctstrCurrentVersionHive       = "Software\\Microsoft\\Windows\\CurrentVersion";
    LPCSTR                              lpctstrControlHive              = "System\\CurrentControlSet\\Control";
    LPCTSTR                             lpctstrPID                      = _T("PID");
    LPCTSTR                             lpctstrNoSystemID               = _T("NoSystemID");

    //  Other Strings
    TCHAR                               tchIEVersionValue[MAX_LEN];

    TCHAR                               tchCommandLineValue[MAX_PATH];
    TCHAR                               tchProductTypeValue[MAX_LEN];
    TCHAR                               tchCurrentUserValue[MAX_PATH];
    TCHAR                               tchComputerNameValue[MAX_PATH];
    TCHAR                               tchSystemID[MAX_PATH];
    TCHAR                               tchOSName[MAX_PATH];
    TCHAR                               tchInstallStr[3*MAX_PATH];
    TCHAR                               tchUptimeStr[MAX_PATH];
    TCHAR                               tchInstall[MAX_PATH];

    TCHAR                               tchProductType[MAX_PATH];

    //  Time
    SYSTEMTIME                          stUTCTime;

    // DWORD
    DWORD                               dwSize                          = MAX_PATH;
    DWORD                               dwType;
    
    //  Key
    HKEY                                hkeyIEKey;
    HKEY                                hkeyInstallKey;
    HKEY                                hkeyCurrentVersionKey;
    HKEY                                hkeyComputerKey;
    HKEY                                hkeyComputerSubKey;
    HKEY                                hkeyControlKey;
    HKEY                                hkeySystemIDKey;

    BYTE                                bUpgradeValue;
    
    int                                 nProductTypeValue;
    int                                 nStrLen;
    int                                 nDays, nHours, nMins, nSecs;
    int                                 nRam, nRem;

    float                               dRam;

    BOOL                                fCommit                         = FALSE;
                                                                      
//  End  Declarations...................................................

    //  Initializations
    tchIEVersionValue[0]    = 0;
    tchCommandLineValue[0]  = 0;
    tchProductTypeValue[0]  = 0;
    tchProductType[0]       = 0;
    tchCurrentUserValue[0]  = 0;
    tchComputerNameValue[0] = 0;
    tchSystemID[0]          = 0;
    tchInstallStr[0]        = 0;

    varValue.Clear();
    varCaption.Clear();
    varVersion.Clear();
    
    //
    // Get the date and time  This is required for the TimeStamp field
    GetSystemTime(&stUTCTime);

    // Create a new instance of PCH_SysInfo Class based on the 
    // passed-in MethodContext

    CInstancePtr pPCHSysInfoInstance(CreateNewInstance(pMethodContext), false);

    //  Created a New Instance of PCH_SysInfo Successfully.

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              TIME STAMP                                                                 //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHSysInfoInstance->SetDateTime(pTimeStamp, WBEMTime(stUTCTime));
    if (FAILED(hRes))
    {
      //  Could not Set the Time Stamp
      //  Continue anyway
      ErrorTrace(TRACE_ID, "SetDateTime on Timestamp Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              CHANGE                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    hRes = pPCHSysInfoInstance->SetVariant(pChange, varSnapshot);
    if (FAILED(hRes))
    {
        //  Could not Set the Change Property
        //  Continue anyway
        ErrorTrace(TRACE_ID, "Set Variant on Change Field failed.");
    }


    //  To fix the Bug : 100158 : the system ID property should not contain any privacy info. 
    //  In its place we generate some random number;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              SYSTEMID                                                                   //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        
    //  The SystemID can be obtained from HKLM\SYSTEM\CURRENTCONTROLSET\CONTROL\COMPUTERNAME\COMPUTERNAME
    //  The username can be obtained from HKLM\SYSTEM\CURRENTCONTROLSET\CONTROL\CURRENTUSER
    // 

    /*
    
    lRegKeyRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrControlHive, 0, KEY_READ, &hkeyControlKey);
	if(lRegKeyRet == ERROR_SUCCESS)
	{
        //  Opened the Control Key
        //  Open the Computer System sub key under hkeyControlKey
        lRegKeyRet = RegOpenKeyEx(hkeyControlKey, lpctstrComputerName, 0, KEY_READ, &hkeyComputerKey);
        if(lRegKeyRet == ERROR_SUCCESS)
	    {
            //  Opened the ComputerNameSub Key
            //  Open the 
            //  Open the CompterNameSubSubKey key under ComputerNameSub Key
            lRegKeyRet = RegOpenKeyEx(hkeyComputerKey, lpctstrComputerName, 0, KEY_READ, &hkeyComputerSubKey);
            if(lRegKeyRet == ERROR_SUCCESS)
	        {
                //  Read the ComputerName Value
                dwSize = MAX_PATH;
		        lRegKeyRet = RegQueryValueEx(hkeyComputerSubKey, lpctstrComputerName, NULL, &dwType, (LPBYTE)tchComputerNameValue, &dwSize);
		        if (lRegKeyRet != ERROR_SUCCESS)
                {
                    // Could not get the ComputerName
                    ErrorTrace(TRACE_ID, "Cannot get the ComputerName");
                }
                
                //  Close the ComputerName Sub Sub Key 
                lRegKeyRet = RegCloseKey(hkeyComputerSubKey);
                if(lRegKeyRet != ERROR_SUCCESS)
	            {
                    //  Could not close the key.
                    ErrorTrace(TRACE_ID, "Cannot Close the Key");
                }
            }
            //  Close the ComputerName Sub Key 
            lRegKeyRet = RegCloseKey(hkeyComputerKey);
            if(lRegKeyRet != ERROR_SUCCESS)
	        {
                //  Could not close the key.
                ErrorTrace(TRACE_ID, "Cannot Close the Key");
            }
        }

        //  Read the CurrentUser Value
        dwSize = MAX_PATH;
		lRegKeyRet = RegQueryValueEx(hkeyControlKey, lpctstrCurrentUser, NULL, &dwType, (LPBYTE)tchCurrentUserValue, &dwSize);
		if (lRegKeyRet != ERROR_SUCCESS)
        {
            // Could not get the UserName
            ErrorTrace(TRACE_ID, "Cannot get the UserName");
        }
        
        //  Close the  Control Key
        lRegKeyRet = RegCloseKey(hkeyControlKey);
        if(lRegKeyRet != ERROR_SUCCESS)
	    {
            //  Could not close the key.
            ErrorTrace(TRACE_ID, "Cannot Close the Key");
        }

        // Got the ComputerName and CurrentUser, Format the string for systemID.

        nStrLen = wsprintf(tchSystemID,lpctstrSystemIDFormat, tchComputerNameValue, tchCurrentUserValue);

        lSystemID = long(GetTickCount());
        _ltot(lSystemID, tchSystemID, 10);
           
        //  Set the SystemID Property
        varValue = tchSystemID;
        if (FAILED(pPCHSysInfoInstance->SetVariant(pSystemID, varValue)))
        {
            // Set SystemID  Field Failed.
            // Proceed anyway
            ErrorTrace(TRACE_ID, "SetVariant on OSName Field failed.");
        }
        else
        {
            fCommit = TRUE;
        }
    }

    */


    /*
    lSystemID = long(GetTickCount());
    _ltot(lSystemID, tchSystemID, 10);
    */

    //  To fix Bug 100268 , get the system ID from the Registry.
    //  The Registry key to read is :
    //  HKLM\SW\MS\PCHealth\MachineInfo\PID

    lRegKeyRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrSystemIDHive, 0, KEY_READ, &hkeySystemIDKey);
	if(lRegKeyRet == ERROR_SUCCESS)
	{
        //  Opened the SystemID Hive
        //  Read the PID Value
        dwSize = MAX_PATH;
		lRegKeyRet = RegQueryValueEx(hkeySystemIDKey, lpctstrPID, NULL, &dwType, (LPBYTE)tchSystemID, &dwSize);
		if (lRegKeyRet != ERROR_SUCCESS)
        {
            _tcscpy(tchSystemID,lpctstrNoSystemID);
            // Could not get the PID
            ErrorTrace(TRACE_ID, "Cannot get the PID");
        }
        //  Close the SystemID Key 
        lRegKeyRet = RegCloseKey(hkeySystemIDKey);
        if(lRegKeyRet != ERROR_SUCCESS)
        {
            //  Could not close the key.
            ErrorTrace(TRACE_ID, "Cannot Close the Key");
        }
    
    }   
    //  Set the SystemID Property
    varValue = tchSystemID;
    if (FAILED(pPCHSysInfoInstance->SetVariant(pSystemID, varValue)))
    {
        // Set SystemID  Field Failed.
        // Proceed anyway
        ErrorTrace(TRACE_ID, "SetVariant on OSName Field failed.");
    }
    else
    {
        fCommit = TRUE;
    }
  
        
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              OSNAME                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Execute the query to get "Caption", "Version", "Name" from Win32_OperatingSystem Class.
    // Although "Name" is not required to set PCH_SysInfo.OSName property
    // we need to query for it as its the "Key" property of the class.

    // pOperatingSystemEnumInst contains a pointer to the list of instances returned.
    //
    hRes = ExecWQLQuery(&pOperatingSystemEnumInst, bstrOperatingSystemQuery);
    if (SUCCEEDED(hRes))
    {
        // Query on Win32_OperatingSystem Class Succeeded
        // Enumerate the instances of Win32_OperatingSystem Class
        // from pOperatingSystemEnumInst.

        // Get the next instance into pOperatingSystemObj object.
        hRes = pOperatingSystemEnumInst->Next(WBEM_INFINITE, 1, &pOperatingSystemObj, &ulOperatingSystemRetVal);
        if(hRes == WBEM_S_NO_ERROR)
        {
            //  Copy property "caption" to "OSName"
            CopyProperty(pOperatingSystemObj, lpctstrCaption, pPCHSysInfoInstance, pOSName);

            //  Copy property "Version" to "Version"
            CopyProperty(pOperatingSystemObj, lpctstrVersion, pPCHSysInfoInstance, pOSVersion);

            //  Copy property "OSLangauge" to "OSLangauge"
            CopyProperty(pOperatingSystemObj, bstrOSLanguage, pPCHSysInfoInstance, pOSLanguage);

            //  Copy property "BuildNumber" to "BuildNumber"
            CopyProperty(pOperatingSystemObj, bstrBuildNumber, pPCHSysInfoInstance, pOSBuildNumber);

            
        } //end of if WBEM_S_NO_ERROR

    } // end of if SUCCEEDED(hRes)
    else
    {
        //  Operating system Query did not succeed.
        ErrorTrace(TRACE_ID, "Query on win32_OperatingSystem Field failed.");
    }


    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              UPTIME                                                                     //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //  Get uptime using GetTickCount()
    dwSize = GetTickCount();

    /* There is a bug in the server side because of the fix and so this needs to be reverted again.

    //  GetTickCount returns uptime in milliseconds. Divide this by 1000 to get seconds.

    dwSize = dwSize/1000.0;

    // To fix the bug of inconsistent time formats, change the seconds to days::hours::mins::secs.

    // Get the number of days.
    nDays = dwSize/(60*60*24);
    dwSize = dwSize%(60*60*24);

    // Get the Number of hours.
    nHours = dwSize/(60*60);
    dwSize = dwSize%(60*60);

    //Get the Number of Mins.
    nMins = dwSize/(60);

    //Get the Number of Secs.
    nSecs = dwSize%60;

    nStrLen = wsprintf(tchUptimeStr,lpctstrUptimeFormat, nDays, nHours, nMins, nSecs);
    varValue = tchUptimeStr;

    */

    
    // varValue = (long)dwSize;
    varValue.vt = VT_I4;
    varValue.lVal = (long)dwSize;
    

    //  Set the UpTime Property
    if (FAILED(pPCHSysInfoInstance->SetVariant(pUptime, varValue)))
    {
        // Set UpTime Failed.
        // Proceed anyway
        ErrorTrace(TRACE_ID, "SetVariant on UpTime Field failed.");
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              INSTALL                                                                    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //  The Install info is obtained from the Registry

    // Get "Upgrade" regvalue from HKLM\Software\Microsoft\Windows\CurrentVersion\Setup
    // if Upgrade == 0, then it is "Clean Install" otherwise its a "Upgrade"

    dwSize = MAX_PATH;
    lRegKeyRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrInstallHive, 0, KEY_READ, &hkeyInstallKey);
	if(lRegKeyRet == ERROR_SUCCESS)
	{
        //  Opened the Install Key
        //  Read the upgrade Value
         dwSize = 1;
		lRegKeyRet = RegQueryValueEx(hkeyInstallKey, lpctstrUpgrade, NULL, &dwType, &bUpgradeValue, &dwSize);
		if (lRegKeyRet == ERROR_SUCCESS)
		{
            //  Compare Install Value with "00"
            if (bUpgradeValue == 0)
            {
                // Clean Install
                _tcscpy(tchInstall, lpctstrCleanInstall);
            }
            else
            {
                _tcscpy(tchInstall, lpctstrUpgradeInstall);
            }
           
        }
        
        // Read the CommandLine Value
        dwSize = MAX_PATH;
		lRegKeyRet = RegQueryValueEx(hkeyInstallKey, lpctstrCommandLine, NULL, &dwType, (LPBYTE)tchCommandLineValue, &dwSize);
		lRegKeyRet = RegCloseKey(hkeyInstallKey);
        if(lRegKeyRet != ERROR_SUCCESS)
	    {
            //  Could not close the key.
            ErrorTrace(TRACE_ID, "Cannot Close the Key");
        }
    }

    // Get "ProductType" regvalue from HKLM\Software\Microsoft\Windows\CurrentVersion   

    dwSize = MAX_PATH;
    lRegKeyRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrCurrentVersionHive, 0, KEY_READ, &hkeyCurrentVersionKey);
	if(lRegKeyRet == ERROR_SUCCESS)
	{
        // Opened the CurrentVersion Key
        // Read the ProductType Value
		lRegKeyRet = RegQueryValueEx(hkeyCurrentVersionKey, lpctstrProductType, NULL, &dwType, (LPBYTE)tchProductTypeValue, &dwSize);
		if (lRegKeyRet == ERROR_SUCCESS)
		{
            //  Compare ProductType Value with known codes
            //  Convert the productType value to an int

            nProductTypeValue = atoi(tchProductTypeValue);

            switch(nProductTypeValue)
            {
            case 100:
                {
                    _tcscpy(tchProductType, IDS_SKU_MS_INTERNAL);
                    break;
                }
            case 101:
                {
                     _tcscpy(tchProductType, IDS_SKU_CD_FULL);
                    break;
                }
            case 102:
                {
                     _tcscpy(tchProductType, IDS_SKU_CD_UPGRADE);
                    break;
                }
            case 103:
                {
                     _tcscpy(tchProductType,IDS_SKU_FLOPPY_FULL);
                    break;
                }
            case 104:
                {
                      _tcscpy(tchProductType,IDS_SKU_FLOPPY_UPGRADE);
                    break;
                }
            case 105:
                {
                     _tcscpy(tchProductType,IDS_SKU_WEB);
                    break;
                }
            case 110:
                {
                     _tcscpy(tchProductType, IDS_SKU_SELECT_CD);
                    break;
                }
            case 111:
                {
                     _tcscpy(tchProductType, IDS_SKU_MSDN_CD);
                    break;
                }
            case 115:
                {
                      _tcscpy(tchProductType, IDS_SKU_OEM_CD_FULL);
                    break;
                }
            case 116:
                {
                    _tcscpy(tchProductType,IDS_SKU_OEM_CD);
                    break;
                }
            case 120:
                {
                    _tcscpy(tchProductType, IDS_SKU_OEM_PREINST_KIT);
                    break;
                }
            case 1:
                {
                    _tcscpy(tchProductType, IDS_SKU_NET);
                    break;
                }
            case 5:
                {
                    _tcscpy(tchProductType, IDS_SKU_SELECT_FLOPPY);
                    break;
                }
            case 7:
                {
                    _tcscpy(tchProductType, IDS_SKU_OEM_DISKMAKER);
                    break;
                }
            case 8:
                {
                    _tcscpy(tchProductType, IDS_SKU_OEM_FLOPPY);
                    break;
                }
            default:
                {
                    //  Cannot figure out the type of installation
                }
            }

        }
    
        //  RegCloseKey(hkeyCurrentVersionKey);
        lRegKeyRet = RegCloseKey(hkeyCurrentVersionKey);
        if(lRegKeyRet != ERROR_SUCCESS)
	    {
            //  Could not close the key.
            ErrorTrace(TRACE_ID, "Cannot Close the Key");
        }
    }

    nStrLen = wsprintf(tchInstallStr,lpctstrInstallFormat, tchInstall, tchProductType, tchCommandLineValue);
    varValue = tchInstallStr;
    
    // Set the Install Property
    if (FAILED(pPCHSysInfoInstance->SetVariant(pInstall, varValue)))
    {
        // Set Install Failed.
        // Proceed anyway
        ErrorTrace(TRACE_ID, "SetVariant on OSName Field failed.");
    }

   
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              IEVERSION                                                                  //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// IE Version can be obtained from the Registry under the following hive.
	// HKLM\Software\Microsoft\Windows\Current Version
	// Version is available in the field "Plus!VersionNumber"
	// "Internet Explorer" Key is  in  "hkeyIEKey"

    lRegKeyRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpctstrIEHive, 0, KEY_READ, &hkeyIEKey);
	if(lRegKeyRet == ERROR_SUCCESS)
	{
        // Opened the Internet Explorer key.
        // Read the Version Value
        dwSize = MAX_PATH;
		lRegKeyRet = RegQueryValueEx(hkeyIEKey, lpctstrIEVersion, NULL, &dwType, (LPBYTE) tchIEVersionValue, &dwSize);
		if (lRegKeyRet == ERROR_SUCCESS)
		{
		    try
            {
                // Got the version as a string.
			    // Update the IE Version Property
                varValue = tchIEVersionValue;
           
                // Set the IEVersion Property
		        hRes = pPCHSysInfoInstance->SetVariant(pIEVersion, varValue);
                if (hRes == ERROR_SUCCESS)
                {
                    // Set IEVersion Failed.
                    // Proceed anyway
                    ErrorTrace(TRACE_ID, "SetVariant on IEVersion Field failed.");
                }
            }
            catch(...)
            {
                lRegKeyRet = RegCloseKey(hkeyIEKey);
                if(lRegKeyRet != ERROR_SUCCESS)
	            {
                    //  Could not close the key.
                    ErrorTrace(TRACE_ID, "Cannot Close the Key");
                }
                throw;
            }
	    } // end of if RegQueryValueEx == ERROR_SUCCESS

        lRegKeyRet = RegCloseKey(hkeyIEKey);
        if(lRegKeyRet != ERROR_SUCCESS)
	    {
            //  Could not close the key.
            ErrorTrace(TRACE_ID, "Cannot Close the Key");
        }
        
    } // end of if RegOpenKeyEx == ERROR_SUCCESS
        
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              MODE                                                                       //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //  Execute the query to get Name, BootUpstate FROM Win32_ComputerSystem
    //  Class.

    //  pComputerSystemEnumInst contains a pointer to the instance returned.

    hRes = ExecWQLQuery(&pComputerSystemEnumInst, bstrComputerSystemQuery);
    if (SUCCEEDED(hRes))
    {
        //  Query Succeeded!
        
        //  Get the instance Object.
        if((pComputerSystemEnumInst->Next(WBEM_INFINITE, 1, &pComputerSystemObj, &ulComputerSystemRetVal)) == WBEM_S_NO_ERROR)
        {

            //  Get the BootupState
            CopyProperty(pComputerSystemObj, lpctstrBootupState, pPCHSysInfoInstance, pMode);

            //  Get the Manufacturer
            CopyProperty(pComputerSystemObj, bstrManufacturer, pPCHSysInfoInstance, pManufacturer);

            //  Get the Model
            CopyProperty(pComputerSystemObj, bstrModel, pPCHSysInfoInstance, pModel);
           
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              PROCESSOR                                                                  //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Execute the query to get "DeviceID", "Manufacturer", "Name", "CurrentClockSpeed"
    // from Win32_Processor Class.
    // Although "DeviceID" is not required to set PCH_SysInfo.Processor property
    // we need to query for it as its the "Key" property of the class.
    // pProcessorEnumInst contains a pointer to the list of instances returned.
  
    //
    hRes = ExecWQLQuery(&pProcessorEnumInst, bstrProcessorQuery);
    if (SUCCEEDED(hRes))
    {
        
        // Query on Win32_Processor Class Succeeded
        // Enumerate the instances of Win32_Processor Class
        // from pProcessorEnumInst.

        // Get the instance into pProcessorObj object.
   
        if(WBEM_S_NO_ERROR == pProcessorEnumInst->Next(WBEM_INFINITE, 1, &pProcessorObj, &ulProcessorRetVal))
        {
            //Get the Manufacturer
            if (FAILED(pProcessorObj->Get(bstrManufacturer, 0, &varValue, NULL, NULL)))
            {
                // Could not get the Manufacturer
                ErrorTrace(TRACE_ID, "GetVariant on Win32_Processor:Manufacturer Field failed.");
            }
            else
            {
                // Got the Manufacturer
                // varValue set to Manufacturer. Copy this to bstrResult
                hRes = varValue.ChangeType(VT_BSTR, NULL);
                if(SUCCEEDED(hRes))
                {
                    bstrProcessor.Append(V_BSTR(&varValue));

                    // Put some spaces before appending the string.
                    bstrProcessor.Append(lpctstrSpaces);
                }

            }

            // Get the Name
            if (FAILED(pProcessorObj->Get(bstrName, 0, &varValue, NULL, NULL)))
            {
                    // Could not get the Name
                    ErrorTrace(TRACE_ID, "GetVariant on Win32_Processor:Name Field failed.");
            } 
            else
            {
                // Got the Name
                // varValue set to Name. Append this to bstrResult
                hRes = varValue.ChangeType(VT_BSTR, NULL);
                if(SUCCEEDED(hRes))
                {
                    bstrProcessor.Append(V_BSTR(&varValue));

                    // Put some spaces before appending the string.
                    bstrProcessor.Append(lpctstrSpaces);
                }
            }

            // Set the Processor Property
            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrProcessor.Detach();
            hRes = pPCHSysInfoInstance->SetVariant(pProcessor, varValue);
            if (FAILED(hRes))
            {
                // Set Processor Failed.
                // Proceed anyway
                ErrorTrace(TRACE_ID, "SetVariant on Processor Field failed.");
            }

            //  Copy Property Clock speed
            CopyProperty(pProcessorObj, lpctstrClockSpeed, pPCHSysInfoInstance, pClockSpeed);

        } //end of if WBEM_S_NO_ERROR
        

    } // end of if SUCCEEDED(hRes))        

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              RAM                                                                        //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Execute the query to get "Name", "TotalPhysicalMemory"
    // from Win32_LogicalMemoryConfiguration Class.
    // Although "Name" is not required to set PCH_SysInfo.RAM property
    // we need to query for it as its the "Key" property of the class.
    // pLogicalMemConfigEnumInst contains a pointer to the list of instances returned.
    //
    hRes = ExecWQLQuery(&pLogicalMemConfigEnumInst, bstrLogicalMemConfigQuery);
    if (SUCCEEDED(hRes))
    {
        // Query on Win32_LogicalMemoryConfiguration Class Succeeded
        // Enumerate the instances of Win32_LogicalMemoryConfiguration Class
        // from pEnumInst.
        // Get the next instance into pLogicalMemConfigObj object.
        //
        if(WBEM_S_NO_ERROR == pLogicalMemConfigEnumInst->Next(WBEM_INFINITE, 1, &pLogicalMemConfigObj, &ulLogicalMemConfigRetVal))
        {
            //Get the TotalPhysicalMemory
            if (FAILED(pLogicalMemConfigObj->Get(lpctstrTotalPhysicalMemory, 0, &varPhysicalMem, NULL, NULL)))
            {
                 // Could not get the RAM
                 ErrorTrace(TRACE_ID, "GetVariant on Win32_LogicalMemoryConfiguration:TotalPhysicalMemory Field failed.");
            } 
            else
            {
                // Got the TotalPhysicalMemory
                // varRAM set to TotalPhysicalMemory. Copy this to bstrResult
                nRam = varPhysicalMem.lVal;
                nRem = nRam % ONEK;
                nRam = nRam/ONEK;
                if (nRem > HALFK)
                {
                    nRam++;
                }
                varRam = nRam;
                hRes = pPCHSysInfoInstance->SetVariant(pRAM, varRam);
                {
                    // Set RAM Failed.
                    // Proceed anyway
                    ErrorTrace(TRACE_ID, "SetVariant on RAM Field failed.");
                }
            }

        }
    } // end of else FAILED(hRes)

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //                              SWAPFILE                                                                   //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        
    // Execute the query to get "Name", "FreeSpace", "FSName"
    // from Win32_PageFile.
    // pPageFileEnumInst contains a pointer to the list of instances returned.
    //
    hRes = ExecWQLQuery(&pPageFileEnumInst, bstrPageFileQuery);
    if (SUCCEEDED(hRes))
    {
        // Query on Win32_PageFile Class Succeeded
        // Enumerate the instances of Win32_PageFile Class
        // from pEnumInst.
        // Get the next instance into pObj object.
        //
        // Initialize bstrResult to NULL;
        
        if(WBEM_S_NO_ERROR == pPageFileEnumInst->Next(WBEM_INFINITE, 1, &pPageFileObj, &ulPageFileRetVal))
        {
            //Get the Name
            if (FAILED(pPageFileObj->Get(bstrName, 0, &varValue, NULL, NULL)))
            {
                 // Could not get the Name
                 ErrorTrace(TRACE_ID, "GetVariant on Win32_PageFile:Name Field failed.");
            } 
            else
            {
                // Got the Name.
                // varValue set to Name. Copy this to bstrResult
                hRes = varValue.ChangeType(VT_BSTR, NULL);
                if(SUCCEEDED(hRes))
                {
                    bstrSwapFile.Append(V_BSTR(&varValue));

                    // Put some spaces in between the two strings.
                    bstrSwapFile.Append(lpctstrSpaces);
                }
            }

            // Get the FreeSpace
            if (FAILED(pPageFileObj->Get(bstrFreeSpace, 0, &varValue, NULL, NULL)))
            {
                // Could not get the FreeSpace
                ErrorTrace(TRACE_ID, "GetVariant on Win32_PageFile:FreeSpace Field failed.");
            } 
            else
            {
                // Got the FreeSpace
                // varValue set to FreeSpace. Append this to bstrResult
                hRes = varValue.ChangeType(VT_BSTR, NULL);
                if(SUCCEEDED(hRes))
                {
                    bstrSwapFile.Append(V_BSTR(&varValue));

                    // Put some spaces in between the two strings.
                    bstrSwapFile.Append(lpctstrSpaces);

                    bstrSwapFile.Append(lpctstrMBFree);

                }
            }

            
            // Get the FSName
            if (FAILED(pPageFileObj->Get(bstrFSName, 0, &varValue, NULL, NULL)))
            {
                // Could not get the FSName
                ErrorTrace(TRACE_ID, "GetVariant on Win32_PageFile:FSName Field failed.");
            } 
            else
            {
                // Got the FSName
                // varValue set to FSName. Append this to bstrResult
                hRes = varValue.ChangeType(VT_BSTR, NULL);
                if(SUCCEEDED(hRes))
                {
                    bstrSwapFile.Append(V_BSTR(&varValue));
                }
            }

            // Set the SwapFile Property
            // varValue = bstrSwapFile;

            varValue.vt = VT_BSTR;
            varValue.bstrVal = bstrSwapFile.Detach();

            hRes = pPCHSysInfoInstance->SetVariant(pSwapFile, varValue);
            {
                // Set SwapFile Failed.
                // Proceed anyway
                ErrorTrace(TRACE_ID, "SetVariant on SwapFile Field failed.");
            }
            
            
        } //end of if WBEM_S_NO_ERROR

    } // end of else FAILED(hRes)        

    // All the properties are set.

    if(fCommit)
    {
        hRes = pPCHSysInfoInstance->Commit();
        if (FAILED(hRes))
        {
            ErrorTrace(TRACE_ID, "Commit on Instance failed.");
        } 
    }
        
    TraceFunctLeave();
    return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\smartptr.h ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  SmartPtr.h
//
//  Purpose: Declare smartpointer typedefs
//
//***************************************************************************

#pragma once
#include <io.h>

_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet, __uuidof(IWbemQualifierSet));
_COM_SMARTPTR_TYPEDEF(IWbemObjectAccess, __uuidof(IWbemObjectAccess));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemContext, __uuidof(IWbemContext));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IUnsecuredApartment, __uuidof(IUnsecuredApartment));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));
//_COM_SMARTPTR_TYPEDEF(IWbemBackupRestore, __uuidof(IWbemBackupRestore));
_COM_SMARTPTR_TYPEDEF(IWbemRefresher, __uuidof(IWbemRefresher));
_COM_SMARTPTR_TYPEDEF(IWbemHiPerfEnum, __uuidof(IWbemHiPerfEnum));
_COM_SMARTPTR_TYPEDEF(IWbemConfigureRefresher, __uuidof(IWbemConfigureRefresher));
_COM_SMARTPTR_TYPEDEF(IMofCompiler, __uuidof(IMofCompiler));
_COM_SMARTPTR_TYPEDEF(ExternalMethodContext, __uuidof(ExternalMethodContext));
_COM_SMARTPTR_TYPEDEF(InternalMethodContext, __uuidof(InternalMethodContext));
_COM_SMARTPTR_TYPEDEF(InternalMethodContextAsynch, __uuidof(InternalMethodContextAsynch));
_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

class SmartCloseHandle
{

private:
	HANDLE m_h;

public:
	SmartCloseHandle():m_h(INVALID_HANDLE_VALUE){}
	SmartCloseHandle(HANDLE h):m_h(h){}
   ~SmartCloseHandle(){if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

class Smart_findclose
{

private:
	long m_h;

public:
	Smart_findclose():m_h(0){}
	Smart_findclose(long h):m_h(h){}
   ~Smart_findclose(){if (m_h!=0) _findclose(m_h);}
	long operator =(long h) {if (m_h) _findclose(m_h); m_h=h; return h;}
	operator long() const {return m_h;}
	long* operator &() {if (m_h) _findclose(m_h); m_h = 0; return &m_h;}
};

class SmartFindClose
{

private:
	HANDLE m_h;

public:
	SmartFindClose():m_h(INVALID_HANDLE_VALUE){}
	SmartFindClose(HANDLE h):m_h(h){}
   ~SmartFindClose(){if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

class SmartCloseServiceHandle
{

private:
	SC_HANDLE m_h;

public:
	SmartCloseServiceHandle():m_h(NULL){}
	SmartCloseServiceHandle(SC_HANDLE h):m_h(h){}
   ~SmartCloseServiceHandle(){if (m_h!=NULL) CloseServiceHandle(m_h);}
	SC_HANDLE operator =(SC_HANDLE h) {if (m_h!=NULL) CloseServiceHandle(m_h); m_h=h; return h;}
	operator SC_HANDLE() const {return m_h;}
	SC_HANDLE* operator &() {if (m_h!=NULL) CloseServiceHandle(m_h); m_h = NULL; return &m_h;}
};

class CSmartCreatedDC
{
public:
    CSmartCreatedDC(HDC hdc) { m_hdc = hdc;}
	operator HDC() const {return m_hdc;}
    ~CSmartCreatedDC() 
    { 
        if (m_hdc)
            DeleteDC(m_hdc); 
    }

protected:
    HDC m_hdc;
};

class CSmartBuffer
{
private:
	LPBYTE m_pBuffer;

public:
	CSmartBuffer() : m_pBuffer(NULL) {}
	CSmartBuffer(LPBYTE pBuffer) : m_pBuffer(pBuffer) {}
    CSmartBuffer(DWORD dwSize)
    {
        m_pBuffer = new BYTE[dwSize];
        if (m_pBuffer == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    ~CSmartBuffer()
    {
        Free();
    }

	LPBYTE operator =(LPBYTE pBuffer) 
    {
        Free();
            
        m_pBuffer = pBuffer; 
        
        return m_pBuffer;
    }
	
    operator LPBYTE() const { return m_pBuffer; }
	
    LPBYTE* operator &()
    {
        Free();

        m_pBuffer = NULL;
        
        return &m_pBuffer;
    }

protected:
    void Free()
    {
        if (m_pBuffer != NULL) 
        {
            delete [] m_pBuffer;
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\util.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    util.CPP

Abstract:
    File containing utility classes

Revision History:

    Ghim-Sim Chua       (gschua)   04/27/99
        - Created

    Jim Martin          (a-jammar) 04/30/99
        - Changed to use global IWbemServices pointer, and added
          GetWbemServices, CopyProperty, and GetCIMDataFile

    Ghim-Sim Chua       (gschua)   05/01/99
        - Modified GetWbemServices, GetCIMDataFile

    Kalyani Narlanka    (kalyanin)  05/11/99
        - Added the function GetCompletePath

********************************************************************/

#include "pchealth.h"

#define TRACE_ID    DCID_UTIL

//-----------------------------------------------------------------------------
// Returns an IWbemServices pointer. The caller is responsible for releasing
// the object.
//-----------------------------------------------------------------------------
HRESULT GetWbemServices(IWbemServices **ppServices)
{
    TraceFunctEnter("::GetWbemServices");

    HRESULT hRes = S_OK;
    CComPtr<IWbemLocator> pWbemLocator;

    // If global variable already initialized, use it
    if (g_pWbemServices)
    {
        *ppServices = g_pWbemServices;
        (*ppServices)->AddRef();
        goto End;
    }

    // First we have the get the IWbemLocator object with a CoCreateInstance.
    hRes = CoCreateInstance(CLSID_WbemAdministrativeLocator, NULL, 
                            CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                            IID_IUnknown, (void **)&pWbemLocator);
    if (FAILED(hRes))
    {
        ErrorTrace(TRACE_ID, "CoCreateInstance failed to create IWbemAdministrativeLocator.");
        goto End;
    }

    // Then we connect to the WMI server for the local CIMV2 namespace.
    hRes = pWbemLocator->ConnectServer(CComBSTR(CIM_NAMESPACE), NULL, NULL, NULL, 0, NULL, NULL, ppServices);
    if (FAILED(hRes))
    {
        ErrorTrace(TRACE_ID, "ConnectServer failed to connect to cimv2 namespace.");
        goto End;
    }

    // Store it in the global variable

    g_pWbemServices = *ppServices;
    (*ppServices)->AddRef(); // CODEWORK: check out why this stops fault on NET STOP WINMGMT

End :
    TraceFunctLeave();
    return hRes;
}

//-----------------------------------------------------------------------------
// Executes the WQL query and returns the enumerated list
//-----------------------------------------------------------------------------

HRESULT ExecWQLQuery(IEnumWbemClassObject **ppEnumInst, BSTR bstrQuery)
{
    TraceFunctEnter("::ExecWQLQuery");

    HRESULT                     hRes;
    CComPtr<IWbemServices>      pWbemServices;

    // Get pointer to WbemServices
    hRes = GetWbemServices(&pWbemServices);
    if (FAILED(hRes))
        goto End;

    // execute the query
    hRes = pWbemServices->ExecQuery(
        CComBSTR("WQL"),
        bstrQuery,
        WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
        NULL,
        ppEnumInst);

    if (FAILED(hRes))
    {
        ErrorTrace(TRACE_ID, "ExecQuery failed.");
        goto End;
    }

End:
    TraceFunctLeave();
    return hRes;
}

//-----------------------------------------------------------------------------
// Copies the property named szFrom from pFrom to the property named szTo in
// to CInstance object pTo.
//-----------------------------------------------------------------------------

HRESULT CopyProperty(IWbemClassObject *pFrom, LPCWSTR szFrom, CInstance *pTo, LPCWSTR szTo)
{
    TraceFunctEnter("::CopyProperty");

    _ASSERT(pFrom && szFrom && pTo && szTo);

    HRESULT     hRes = S_OK;
    CComVariant varValue;
    CComBSTR    bstrFrom(szFrom);

    // First, get the property (as a variant) from the source class object.

    hRes = pFrom->Get(bstrFrom, 0, &varValue, NULL, NULL);
    if (FAILED(hRes))
        ErrorTrace(TRACE_ID, "GetVariant on %s field failed.", szFrom);
    else
    {
        // Then set the variant for the target CInstance object.

        if (!pTo->SetVariant(szTo, varValue))
        {
            ErrorTrace(TRACE_ID, "SetVariant on %s field failed.", szTo);
            hRes = WBEM_E_FAILED;
        }
    }

    TraceFunctLeave();
    return hRes;
}

//-----------------------------------------------------------------------------
// Returns an IWbemClassObject pointer for the CIM_DataFile object represented
// by the bstrFile parameter. The bstrFile parameter should contain the full
// path to the file. If the pServices parameter is non-null, it is used to
// retrieve the file info, otherwise a new (and temporary) services pointer is
// created.
//-----------------------------------------------------------------------------

HRESULT GetCIMDataFile(BSTR bstrFile, IWbemClassObject ** ppFileObject, BOOL fHasDoubleSlashes)
{
    TraceFunctEnter("::GetCIMDataFile");

    HRESULT     hRes = S_OK;
    CComBSTR    bstrObjectPath("\\\\.\\root\\cimv2:CIM_DataFile.Name=\"");
    wchar_t *   pwch;
    UINT        uLen;

    CComPtr<IWbemServices> pWbemServices;
    hRes = GetWbemServices(&pWbemServices);
    if (FAILED(hRes))
        goto END;

    if (bstrFile == NULL || ppFileObject == NULL)
    {
        ErrorTrace(TRACE_ID, "Parameter pointer is null.");
        hRes = WBEM_E_INVALID_PARAMETER;
        goto END;
    }

    // Construct the path for the file we are trying to get. Note, the path needs
    // the have double backslashes for the GetObject call to work. We scan through
    // the string and do this manually here.
    //
    // CODEWORK: there has to be a faster way to do this, although the Append is
    // probably not too expensive, since the BSTR length can be found without
    // scanning the string. Unless it's reallocating more memory as it goes.

    pwch = bstrFile;
    if (fHasDoubleSlashes)
        bstrObjectPath.Append(pwch, SysStringLen(bstrFile));
    else
        for (uLen = SysStringLen(bstrFile); uLen > 0; uLen--)
        {
            if (*pwch == L'\\')
                bstrObjectPath.Append("\\");
            bstrObjectPath.Append(pwch, 1);
            pwch++;
        }
    bstrObjectPath.Append("\"");

    // Make the call to get the CIM_DataFile object.

    hRes = pWbemServices->GetObject(bstrObjectPath, 0, NULL, ppFileObject, NULL);
    if (FAILED(hRes))
        ErrorTrace(TRACE_ID, "GetObject on CIM_DataFile failed.");

END:
    TraceFunctLeave();
    return hRes;
}


//*****************************************************************************
//
// Function Name        :   getCompletePath
//
// Input Parameters     :   bstrFileName
//                              CComBSTR  which represents the file
//                              whose complete path is required. 
// Output Parameters    :   bstrFileWithPathName
//                              CComBSTR  which represents the file
//                              with the Path    
//  Returns             :   BOOL 
//                              TRUE      if bstrFileWithPathName can be set.
//                              FALSE     if bstrFileWithPathName cannot be set.
//                      
//
//  Synopsis            :   Given a file name (bstrFileName) this function
//                          searches the "System" directory for the existence
//                          of the file. 
//
//                          If it finds the file it pre appends the directory 
//                          path to the input file and  copies into the output
//                          file (bstrFileWithPathName).
//                          
//                          If it doesnot find the file in "System" directory
//                          searches for the file in "Windows" Directoy and does
//                          the same as above.
//
//*****************************************************************************



BOOL getCompletePath(CComBSTR bstrFileName, CComBSTR &bstrFileWithPathName)
{

    //  Return
    BOOL                            bFoundFile              =   FALSE;

    ULONG                           uiReturn;

    TCHAR                           szDirectory[MAX_PATH];
    TCHAR                           temp[MAX_PATH];
    TCHAR                           lpstrTemp[MAX_PATH];

    struct _stat                    filestat;

    CComVariant                     varValue                =    NULL;

    CComBSTR                        bstrDirectory;


    //  Check for the File in the System Directory
    uiReturn = GetSystemDirectory(szDirectory, MAX_PATH);
    if (uiReturn != 0 && uiReturn < MAX_PATH)
    {
        bstrDirectory = szDirectory;
        bstrDirectory.Append("\\");
        bstrDirectory.Append(bstrFileName);

        USES_CONVERSION;
        int Result = _tstat(W2T(bstrDirectory), &filestat) ;
        if (Result == 0)
        {
            bstrFileWithPathName = bstrDirectory;
            bFoundFile = TRUE;
        }
    }

    // If not there, then check in the windows directory.
    if (!bFoundFile)
    {
        uiReturn = GetWindowsDirectory(szDirectory, MAX_PATH);
        if (uiReturn != 0 && uiReturn < MAX_PATH)
        {
            bstrDirectory = szDirectory;
            bstrDirectory.Append("\\");
            bstrDirectory.Append(bstrFileName);

            USES_CONVERSION;
            int Result = _tstat(W2T(bstrDirectory), &filestat) ;
            if (Result == 0)
            {
                bstrFileWithPathName = bstrDirectory;
                bFoundFile = TRUE;
            }
        }
    } 
    return(bFoundFile);
}

// Used by GetCim32NetDll and FreeCim32NetDll.
CCritSec g_csCim32Net;
HINSTANCE s_Handle = NULL;

// There is a problem with loading Cim32Net.dll over and over, so this code
// makes sure we only load it once, then unloads it at exit.
// these are used with GetCim32NetHandle

void FreeCim32NetHandle()
{
    if (s_Handle)
    {
        FreeLibrary(s_Handle);
        s_Handle = NULL;
    }
}

HINSTANCE GetCim32NetHandle()
{
    // Have we ever loaded it before?
    if (s_Handle == NULL)
    {
        // Avoid contention on static
        g_csCim32Net.Enter();

        // Check for race condition
        if (s_Handle == NULL)
        {
            s_Handle = LoadLibrary(_T("Cim32Net.dll"));

            // Register to free the handle at exit
            // NO! bad....badddd juju... call from FlushAll instead (o.w., when
            // cimwin32.dll unloads this pointer is invalid, but atexit gets
            // called when framedyn.dll unloads)
            // atexit(FreeCim32NetHandle);
        }
        g_csCim32Net.Leave();
    }

    // By re-opening the handle, we ensure proper refcounting on the handle,
    // and facilitate leak checking.
    HINSTANCE hHandle = LoadLibrary(_T("Cim32Net.dll"));

    return hHandle;
}

//
// Given a delimited string, convert tokens into strings and store them into an array
// returns the number of tokens parsed. Caller is responsible for freeing up the memory
// allocated using delete
//
#ifndef UNICODE
int DelimitedStringToArray(LPWSTR strString, LPTSTR strDelimiter, LPTSTR apstrArray[], int iMaxArraySize)
{
    USES_CONVERSION;
    LPTSTR szString = W2A(strString);
    return DelimitedStringToArray(szString, strDelimiter, apstrArray, iMaxArraySize);
}
#endif

int DelimitedStringToArray(LPTSTR strString, LPTSTR strDelimiter, LPTSTR apstrArray[], int iMaxArraySize)
{
    // make a copy of the string to begin parsing
    LPTSTR strDelimitedString = (TCHAR *) new TCHAR [_tcslen(strString) + 1];

    // if out of memory, just return error value -1
    if (!strDelimitedString)
        return -1;
        
    // copy the token into the new allocated string
    _tcscpy(strDelimitedString, strString);
    
    // initialize _tcstok
    LPTSTR strTok = _tcstok(strDelimitedString, strDelimiter);
    int iCount = 0;

    // loop through all tokens parsed
    while ((strTok) && (iCount < iMaxArraySize))
    {
        LPTSTR strNewTok = (TCHAR *) new TCHAR[_tcslen(strTok) + 1];

        // if out of memory, just return error value -1
        if (!strNewTok)
            return -1;
        
        // copy the token into the new allocated string
        _tcscpy(strNewTok, strTok);

        // save it in the array
        apstrArray[iCount] = strNewTok;

        // increment the index
        iCount++;

        // get the next token
        strTok = _tcstok(NULL, strDelimiter);
    }

    // free up the memory used
    delete [] strDelimitedString;

    return iCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\datacoll\wmiprovn\version.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
	version.CPP

Abstract:
	Implementation of class to provide version information about
    a file using functions pulled from the Dr. Watson source.

Revision History:

    Jim Martin          (a-jammar) 05/22/99
        - Created.

********************************************************************/

#include "pchealth.h"
#include <winver.h>

#define TRACE_ID DCID_VERSION

//-----------------------------------------------------------------------------
// Local structures and macros used to retrieve the file version information.
// These are necessary to use to the Dr. Watson codebase without too much
// modification.
//-----------------------------------------------------------------------------

struct VERSIONSTATE 
{
    PVOID  pvData;
    TCHAR  tszLang[9];
    TCHAR  tszLang2[9];
};

struct FILEVERSION 
{
    TCHAR   tszFileVersion[32];         /* File version */
    TCHAR   tszDesc[MAX_PATH];          /* File description */
    TCHAR   tszCompany[MAX_PATH];       /* Manufacturer */
    TCHAR   tszProduct[MAX_PATH];       /* Enclosing product */
};

typedef VERSIONSTATE * PVERSIONSTATE;
typedef FILEVERSION * PFILEVERSION;

BOOL _GetVersionString(PVERSIONSTATE pvs, LPCTSTR ptszKey, LPTSTR ptszBuf);
BOOL __GetVersionString(PVOID pvData, LPCTSTR ptszLang, LPCTSTR ptszKey, LPTSTR ptszBuf);
void GetFileVersion(LPTSTR ptszFile, FILEVERSION * pfv);

#define pvSubPvCb(pv, cb) ((PVOID)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PVOID)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))
#define cbX(X) sizeof(X)
#define cA(a) (cbX(a)/cbX(a[0]))

char c_szStringFileInfo[] = "StringFileInfo";

//-----------------------------------------------------------------------------
// The constructor and destructor don't have too much to do.
//-----------------------------------------------------------------------------

CFileVersionInfo::CFileVersionInfo() : m_pfv(NULL)
{
}

CFileVersionInfo::~CFileVersionInfo()
{
    delete m_pfv;
}

//-----------------------------------------------------------------------------
// The Get functions are also really simple.
//-----------------------------------------------------------------------------

LPCTSTR CFileVersionInfo::GetVersion()
{
    return (m_pfv) ? (m_pfv->tszFileVersion) : NULL;
}

LPCTSTR CFileVersionInfo::GetDescription()
{
    return (m_pfv) ? (m_pfv->tszDesc) : NULL;
}

LPCTSTR CFileVersionInfo::GetCompany()
{
    return (m_pfv) ? (m_pfv->tszCompany) : NULL;
}

LPCTSTR CFileVersionInfo::GetProduct()
{
    return (m_pfv) ? (m_pfv->tszProduct) : NULL;
}

//-----------------------------------------------------------------------------
// QueryFile get information about the requested file. If necessary, it will
// convert a path with double backslashes to single backslashes before calling
// the helper function GetFileVersion from Dr. Watson code.
//-----------------------------------------------------------------------------

HRESULT CFileVersionInfo::QueryFile(LPCSTR szFile, BOOL fHasDoubleBackslashes)
{
    TraceFunctEnter("CFileVersionInfo::QueryFile");

    HRESULT hRes = S_OK;
    LPSTR   szWorking;
    
    if (!m_pfv)
        m_pfv = new FILEVERSION;

    if (!m_pfv)
    {
        hRes = E_OUTOFMEMORY;
        goto END;
    }

    szWorking = (LPSTR) szFile;
    if (fHasDoubleBackslashes)
    {
        szWorking = new char[strlen(szFile)];
        if (!szWorking)
        {
            hRes = E_OUTOFMEMORY;
            goto END;
        }

        // Scan through the passed string, converting double backslashes to single
        // backslashes.

        int i = 0, j = 0;
        while (szFile[i])
        {
            if (szFile[i] == '\\' && szFile[i + 1] == '\\')
                i += 1;
            szWorking[j++] = szFile[i++];
        }
        szWorking[j] = '\0';
    }

    GetFileVersion(szWorking, m_pfv);

    if (fHasDoubleBackslashes)
        delete [] szWorking;

END:
    TraceFunctLeave();
    return hRes;
}

//-----------------------------------------------------------------------------
// An alternate version of the previous function which takes a UNICODE string.
//-----------------------------------------------------------------------------

HRESULT CFileVersionInfo::QueryFile(LPCWSTR szFile, BOOL fHasDoubleBackslashes)
{
    TraceFunctEnter("CFileVersionInfo::QueryFile");

    // Convert the string from UNICODE to ANSI.

    USES_CONVERSION;
    LPSTR szConvertedFile = W2A(szFile); 

    HRESULT hRes = this->QueryFile(szConvertedFile, fHasDoubleBackslashes);

    TraceFunctLeave();
    return hRes;
}


//-----------------------------------------------------------------------------
// Gets the version information for the file ptszFile, and fillsin the pfv
// FILEVERSION structure.
//-----------------------------------------------------------------------------

void GetFileVersion(LPTSTR ptszFile, FILEVERSION * pfv)
{
    TraceFunctEnter("GetFileVersion");

    // Open the file and take out the description.

    DWORD cbScratch, cbRc;

    memset(pfv, 0, sizeof(FILEVERSION));

    cbRc = GetFileVersionInfoSize(ptszFile, &cbScratch);
    if (cbRc) 
    {
        VERSIONSTATE vs;
        memset(&vs, 0, sizeof(VERSIONSTATE));

        vs.pvData = new unsigned char[cbRc]; // BUGBUG
        if (vs.pvData) 
        {
            if (GetFileVersionInfo(ptszFile, cbScratch, cbRc, vs.pvData)) 
            {
                UINT    uiRc;
                LPDWORD pdwLang;

                if (VerQueryValue(vs.pvData, TEXT("VarFileInfo\\Translation"), (PVOID *) &pdwLang, &uiRc) && uiRc >= 4)
                {
                    wsprintf(vs.tszLang, TEXT("%04x%04x"), LOWORD(*pdwLang), HIWORD(*pdwLang));

                    if (cbRc > 0x70 && ((LPBYTE)pvAddPvCb(vs.pvData, 0x4C))[14] == 0 &&
                        lstrcmpi(c_szStringFileInfo, (LPCTSTR) pvAddPvCb(vs.pvData, 0x4C)) == 0)
                    {
                        lstrcpyn(vs.tszLang2, (LPCTSTR) pvAddPvCb(vs.pvData, 0x60), cA(vs.tszLang2));
                    } 
                    else 
                    {
                        vs.tszLang2[0] = 0;
                    }
                }

                if (vs.tszLang[0] == 0)
                {
#ifdef UNICODE
                    // Try English Unicode

                    lstrcpy(vs.tszLang, TEXT("040904B0"));
                    if (!_GetVersionString(&vs, TEXT("FileVersion"), pfv->tszFileVersion))
                    {
#endif
                    // Try English

                    lstrcpy(vs.tszLang, TEXT("040904E4"));
                    if (!_GetVersionString(&vs, TEXT("FileVersion"), pfv->tszFileVersion))
                    {
                        // Try English null codepage

                        lstrcpy(vs.tszLang, TEXT("04090000"));
                        if (!_GetVersionString(&vs, TEXT("FileVersion"), pfv->tszFileVersion))
                            goto LNoVersion;
                    }
#ifdef UNICODE
                    }
#endif
                }
                else
                    _GetVersionString(&vs, TEXT("FileVersion"), pfv->tszFileVersion);

                _GetVersionString(&vs, TEXT("FileDescription"), pfv->tszDesc);
                _GetVersionString(&vs, TEXT("CompanyName"), pfv->tszCompany);
                _GetVersionString(&vs, TEXT("ProductName"), pfv->tszProduct);
            }

LNoVersion:
            delete [] vs.pvData;
        }
    }
    TraceFunctLeave();
}

//-----------------------------------------------------------------------------
// Using the version state, retrieve the version string specified by ptszKey
// and put it in the ptszBuf. This just calls another internal function, trying
// both possible languages.
//-----------------------------------------------------------------------------

BOOL _GetVersionString(PVERSIONSTATE pvs, LPCTSTR ptszKey, LPTSTR ptszBuf)
{
    TraceFunctEnter("_GetVersionString");

    BOOL fRc;

    fRc = __GetVersionString(pvs->pvData, pvs->tszLang, ptszKey, ptszBuf);

    if (!fRc)
        fRc = __GetVersionString(pvs->pvData, pvs->tszLang2, ptszKey, ptszBuf);

    TraceFunctLeave();
    return fRc;
}

//-----------------------------------------------------------------------------
// An internal function to try to get the data specified by the ptszKey, using
// the ptszLang language and codepage.
//-----------------------------------------------------------------------------

BOOL __GetVersionString(PVOID pvData, LPCTSTR ptszLang, LPCTSTR ptszKey, LPTSTR ptszBuf)
{
    TraceFunctEnter("__GetVersionString");

    TCHAR   tszBuf[128];
    LPCTSTR ptszResult;
    UINT    uiRc;
    BOOL    fRc;

    wsprintf(tszBuf, TEXT("\\%s\\%s\\%s"), c_szStringFileInfo, ptszLang, ptszKey);

    if (VerQueryValue(pvData, tszBuf, (PVOID *)&ptszResult, &uiRc))
        fRc = (NULL != lstrcpyn(ptszBuf, ptszResult, MAX_PATH));
    else
        fRc = FALSE;

    TraceFunctLeave();
    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\dumprep\dumprep.cpp ===
/****************************************************************************
Copyright (c) 2000 Microsoft Corporation

Module Name:
    dumprep.cpp

Abstract:
    hang manager intermediate app
    *** IMPORTANT NOTE: this links with the single threaded CRT static lib.  If
                        it is changed to be multithreaded for some odd reason,
                        then the sources file must be modified to link to
                        libcmt.lib.

Revision History:

    DerekM      created     08/16/00

****************************************************************************/

#include "stdafx.h"
#include "malloc.h"
#include "faultrep.h"
#include "pfrcfg.h"

enum EOp
{
    eopNone = 0,
    eopHang,
    eopDump,
    eopEvent
};

enum ECheckType
{
    ctNone = -1,
    ctKernel = 0,
    ctUser,
    ctShutdown,
    ctNumChecks
};

struct SCheckData
{
    LPCWSTR wszRegPath;
    LPCWSTR wszRunVal;
    LPCWSTR wszEventName;
    LPCSTR  szFnName;
    BOOL    fUseData;
    BOOL    fDelDump;
};


//////////////////////////////////////////////////////////////////////////////
// constants

const char  c_szKSFnName[]    = "ReportEREventDW";
const char  c_szUserFnName[]  = "ReportFaultFromQueue";

SCheckData g_scd[ctNumChecks] =
{
    { c_wszRKKrnl, c_wszRVKFC, c_wszMutKrnlName, c_szKSFnName,   FALSE, FALSE },
    { c_wszRKUser, c_wszRVUFC, c_wszMutUserName, c_szUserFnName, TRUE,  TRUE  },
    { c_wszRKShut, c_wszRVSEC, c_wszMutShutName, c_szKSFnName,   FALSE, FALSE },
};

#define EV_ACCESS_ALL GENERIC_ALL | STANDARD_RIGHTS_ALL
#define EV_ACCESS_RS  GENERIC_READ | SYNCHRONIZE

#define pfn_VALONLY pfn_REPORTEREVENTDW
#define pfn_VALDATA pfn_REPORTFAULTFROMQ


//////////////////////////////////////////////////////////////////////////////
// globals

BOOL    g_fDeleteReg = TRUE;


//////////////////////////////////////////////////////////////////////////////
// misc

// **************************************************************************
LONG __stdcall ExceptionTrap(_EXCEPTION_POINTERS *ExceptionInfo)
{
    return EXCEPTION_EXECUTE_HANDLER;
}

#ifdef MANIFEST_HEAP
BOOL
DeleteFullAndTriageMiniDumps(
    LPCWSTR wszPath
    )
//
// We create a FullMinidump file along with triage minidump in the same dir
// This routine cleans up both those files
//
{
    LPWSTR  wszFullMinidump = NULL;
    DWORD   cch;
    BOOL    fRet;

    fRet = DeleteFileW(wszPath);
    cch = wcslen(wszPath) + sizeofSTRW(c_wszHeapDumpSuffix);
    __try { wszFullMinidump = (WCHAR *)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszFullMinidump = NULL; }
    if (wszFullMinidump)
    {
        LPWSTR wszFileExt = NULL;

        // Build Dump-with-heap path
        wcsncpy(wszFullMinidump, wszPath, cch);
        wszFileExt = wszFullMinidump + wcslen(wszFullMinidump) - sizeofSTRW(c_wszDumpSuffix) + 1;
        if (!wcscmp(wszFileExt, c_wszDumpSuffix))
        {
            *wszFileExt = L'\0';
        }
        wcsncat(wszFullMinidump, c_wszHeapDumpSuffix, cch);


        fRet = DeleteFileW(wszFullMinidump);

    } else
    {
        fRet = FALSE;
    }
    return fRet;
}
#endif  // MANIFEST_HEAP

// **************************************************************************
void DeleteQueuedEvents(HKEY hkey, LPWSTR wszVal, DWORD cchMaxVal,
                          ECheckType ct)
{
    DWORD   cchVal, dw;
    HKEY    hkeyRun = NULL;
    HRESULT hr = NOERROR;

    USE_TRACING("DeleteQueuedEvents");

    VALIDATEPARM(hr, (hkey == NULL || wszVal == NULL));

    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    for(;;)
    {
        cchVal = cchMaxVal;
        dw = RegEnumValueW(hkey, 0, wszVal, &cchVal, NULL, NULL,
                           NULL, NULL);
        if (dw != ERROR_SUCCESS && dw != ERROR_NO_MORE_ITEMS)
        {
            SetLastError(dw);
            goto done;
        }

        if (dw == ERROR_NO_MORE_ITEMS)
            break;

        RegDeleteValueW(hkey, wszVal);
        if (ct == ctUser)
        {
#ifdef MANIFEST_HEAP
            DeleteFullAndTriageMiniDumps(wszVal);
#else
            DeleteFileW(wszVal);
#endif  // !MANIFEST_HEAP
        }
    }

    // gotta delete our value out of the Run key so we don't run
    //  unnecessarily again...
    dw = RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRKRun, 0,
                       KEY_ALL_ACCESS, &hkeyRun);
    if (dw != ERROR_SUCCESS)
        goto done;

    RegDeleteValueW(hkeyRun, g_scd[ct].wszRunVal);

done:
    if (hkeyRun != NULL)
        RegCloseKey(hkeyRun);

    return;
}

// **************************************************************************
void ReportEvents(HMODULE hmod, ECheckType ct)
{
    EFaultRepRetVal     frrv;
    pfn_VALONLY         pfnVO = NULL;
    pfn_VALDATA         pfnVD = NULL;
    EEventType          eet = eetKernelFault;
    HRESULT             hr = NOERROR;
    HANDLE              hmut = NULL;
    LPWSTR              wszVal = NULL;
    LPBYTE              pbData = NULL, pbDataToUse = NULL;
    EEnDis              eedReport, eedUI;
    DWORD               cchVal = 0, cchMaxVal = 0, cbMaxData = 0, cVals = 0;
    DWORD               dw, cbData = 0, *pcbData = NULL;
    DWORD               dwType;
    HKEY                hkey = NULL;

    USE_TRACING("ReportEvents");

    VALIDATEPARM(hr, ((ct <= ctNone && ct >= ctNumChecks) || hmod == NULL));

    if (FAILED(hr))
        return;

    // assume hmod is valid cuz we do a check in wWinMain to make sure it is
    //  before calling this fn
    if (g_scd[ct].fUseData)
        pfnVD = (pfn_VALDATA)GetProcAddress(hmod, g_scd[ct].szFnName);
    else
        pfnVO = (pfn_VALONLY)GetProcAddress(hmod, g_scd[ct].szFnName);
    if (pfnVD == NULL && pfnVO == NULL)
        return;

    dw = RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRPCfg, 0, KEY_READ, &hkey);
    if (dw != ERROR_SUCCESS)
        return;

    cbData = sizeof(eedUI);
    dw = RegQueryValueExW(hkey, c_wszRVShowUI, 0, NULL, (PBYTE)&eedUI,
                          &cbData);
    if (dw != ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
        return;
    }

    cbData = sizeof(eedReport);
    dw = RegQueryValueExW(hkey, c_wszRVDoReport, 0, NULL, (PBYTE)&eedReport,
                          &cbData);
    RegCloseKey(hkey);
    hkey = NULL;
    if (dw != ERROR_SUCCESS)
        return;

    if (eedUI != eedEnabled && eedUI != eedDisabled &&
        eedUI != eedEnabledNoCheck)
        eedUI = eedEnabled;

    if (eedReport != eedEnabled && eedReport != eedDisabled)
        eedReport = eedEnabled;

    // only want one user at a time going thru this
    hmut = OpenMutexW(SYNCHRONIZE, FALSE, g_scd[ct].wszEventName);
    VALIDATEPARM(hr, (hmut == NULL));
    if (FAILED(hr))
        return;

    // the default value above is eetKernelFault, so only need to change if
    //  it's a shutdown
    if (ct == ctShutdown)
        eet = eetShutdown;

    __try
    {
        __try
        {
            // give this wait five minutes.  If the code doesn't complete by
            //  then, then we're either held up by DW (which means an admin
            //  aleady passed thru here) or something has barfed and is holding
            //  the mutex.
            dw = WaitForSingleObject(hmut, 300000);
            if (dw != WAIT_OBJECT_0 && dw != WAIT_ABANDONED)
                __leave;

            dw = RegOpenKeyExW(HKEY_LOCAL_MACHINE, g_scd[ct].wszRegPath, 0,
                               KEY_ALL_ACCESS, &hkey);
            if (dw != ERROR_SUCCESS)
                __leave;

            // determine how big the valuename is & allocate a buffer for it
            dw = RegQueryInfoKeyW(hkey, NULL, NULL, NULL, NULL, NULL, NULL,
                                  &cVals, &cchMaxVal, &cbMaxData, NULL, NULL);
            if (dw != ERROR_SUCCESS || cVals == 0 || cchMaxVal == 0)
                __leave;

            cchMaxVal++;

            // get us some buffers to hold the data bits we're interested in...
            wszVal = (LPWSTR)MyAlloc(cchMaxVal * sizeof(WCHAR));
            if (wszVal == NULL)
                __leave;

            // if we're completely disabled, then nuke all the queued stuff
            //  and bail
            if (eedUI == eedDisabled && eedReport == eedDisabled)
            {
                DeleteQueuedEvents(hkey, wszVal, cchMaxVal, ct);
                __leave;
            }

            if (g_scd[ct].fUseData)
            {
                pbData = (LPBYTE) MyAlloc(cbMaxData);
                if (pbData == NULL)
                    __leave;

                pbDataToUse = pbData;
                pcbData     = &cbData;
            }

            do
            {
                cchVal = cchMaxVal;
                cbData = cbMaxData;
                dw = RegEnumValueW(hkey, 0, wszVal, &cchVal, NULL, &dwType,
                                   pbDataToUse, pcbData);
                if (dw != ERROR_SUCCESS && dw != ERROR_NO_MORE_ITEMS)
                    __leave;

                if (dw == ERROR_NO_MORE_ITEMS)
                    break;

                if (g_scd[ct].fUseData)
                {
                    // if the type isn't REG_BINARY, then someone wrote an
                    //  invalid blob to the registry.  We have to ignore it.
                    if (dwType == REG_BINARY)
                        frrv = (*pfnVD)(wszVal, pbData, cbData);
                    else
                    {
                        SetLastError(ERROR_INVALID_PARAMETER);
                        frrv = frrvOk;
                    }
                }
                else
                {
                    frrv = (*pfnVO)(eet, wszVal, NULL);
                }

                // if the call succeeds (or the data we fed to it was invalid)
                //  then nuke the reg key & dump file
                if (GetLastError() == ERROR_INVALID_PARAMETER ||
                    (g_fDeleteReg && frrv == frrvOk))
                {
                    dw = RegDeleteValueW(hkey, wszVal);
                    if (dw != ERROR_SUCCESS && dw != ERROR_FILE_NOT_FOUND &&
                        dw != ERROR_PATH_NOT_FOUND)
                        __leave;

                    if (g_scd[ct].fDelDump && g_fDeleteReg)
                    {
#ifdef MANIFEST_HEAP
                        DeleteFullAndTriageMiniDumps(wszVal);
#else
                        DeleteFileW(wszVal);
#endif  // !MANIFEST_HEAP
                    }
                }
                else
                {
                    // don't delete the Run key if we got an error and didn't
                    //  delete the fault key
                    if (frrv != frrvOk)
                        __leave;
                }
            }
            while(1);

            RegCloseKey(hkey);
            hkey = NULL;

            // gotta delete our value out of the Run key so we don't run
            //  unnecessarily again...
            dw = RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRKRun, 0,
                               KEY_ALL_ACCESS, &hkey);
            if (dw != ERROR_SUCCESS)
                __leave;

            RegDeleteValueW(hkey, g_scd[ct].wszRunVal);
        }

        __finally
        {
        }
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    if (hmut != NULL)
    {
        ReleaseMutex(hmut);
        CloseHandle(hmut);
    }
    if (hkey != NULL)
        RegCloseKey(hkey);
    if (pbData != NULL)
        MyFree(pbData);
    if (wszVal != NULL)
        MyFree(wszVal);
}


//////////////////////////////////////////////////////////////////////////////
// wmain

// **************************************************************************
int __cdecl wmain(int argc, WCHAR **argv)
{
    EFaultRepRetVal frrv = frrvErrNoDW;
    SMDumpOptions   smdo, *psmdo = &smdo;
    ECheckType      ct = ctNone;
    HMODULE         hmod = NULL;
    HANDLE          hevNotify = NULL, hproc = NULL, hmem = NULL;
    LPWSTR          wszDump = NULL;
    WCHAR           wszMod[MAX_PATH];
    DWORD           dwpid, dwtid;
    BOOL            f64bit = FALSE;
    int             i;
    EOp             eop = eopNone;
    HRESULT         hr = NOERROR;

    // we don't want to have any faults get trapped anywhere.
    SetErrorMode(SEM_NOGPFAULTERRORBOX | SEM_NOALIGNMENTFAULTEXCEPT |
                 SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
    SetUnhandledExceptionFilter(ExceptionTrap);

    INIT_TRACING

    USE_TRACING("DumpRep.wmain");

    VALIDATEPARM(hr, (argc < 2 || argc > 8));

    if (FAILED(hr))
        goto done;

    dwpid = _wtol(argv[1]);

    ZeroMemory(&smdo, sizeof(smdo));

    for (i = 2; i < argc; i++)
    {
        if (argv[i][0] != L'-')
            continue;

        switch(argv[i][1])
        {
            // debug flag to prevent deletion of reg entries
            case L'E':
            case L'e':
#if defined(NO_WAY_DEBUG) || defined(NO_WAY__DEBUG)
                g_fDeleteReg = FALSE;
#endif
                break;

            // user or kernel faults or shutdowns
            case L'K':
            case L'k':
            case L'U':
            case L'u':
            case L'S':
            case L's':
                if (eop != eopNone)
                    goto done;

                eop = eopEvent;

                // to workaround the desktop hanging while all Run processes
                //  do their thing, we spawn a another copy of ourselves and
                //  immediately exit.
                if (argv[i][2] != L'G' && argv[i][2] != L'g')
                {
                    PROCESS_INFORMATION pi;
                    STARTUPINFOW        si;

                    GetModuleFileNameW(NULL, wszMod, sizeofSTRW(wszMod));
                    if (argv[i][1] == L'K' || argv[i][1] == L'k')
                        wcscat(wszMod, L" 0 -KG");
                    else if (argv[i][1] == L'U' || argv[i][1] == L'u')
                        wcscat(wszMod, L" 0 -UG");
                    else
                        wcscat(wszMod, L" 0 -SG");

                    ZeroMemory(&si, sizeof(si));
                    si.cb = sizeof(si);

                    if (CreateProcessW(NULL, wszMod, NULL, NULL, FALSE, 0, NULL,
                                       NULL, &si, &pi))
                    {
                        CloseHandle(pi.hThread);
                        CloseHandle(pi.hProcess);
                    }

                    goto done;
                }

                else
                {
                    if (argv[i][1] == L'K' || argv[i][1] == L'k')
                        ct = ctKernel;
                    else if (argv[i][1] == L'U' || argv[i][1] == L'u')
                        ct = ctUser;
                    else
                        ct = ctShutdown;
                }
                break;

            // hangs
            case L'H':
            case L'h':
                if (i + 1 >= argc || eop != eopNone)
                    goto done;

                eop = eopHang;

#ifdef _WIN64
                if (argv[i][2] == L'6')
                    f64bit = TRUE;
#endif
                dwtid = _wtol(argv[++i]);

                if (argc > i + 1)
                {
                    hevNotify = OpenEventW(EVENT_MODIFY_STATE | SYNCHRONIZE,
                                           FALSE, argv[++i]);
                }
                break;

            // dumps
            case L'D':
            case L'd':
                if (i + 3 >= argc || wszDump != NULL || eop != eopNone)
                    goto done;

                eop = eopDump;

                ZeroMemory(&smdo, sizeof(smdo));
                smdo.ulMod    = _wtol(argv[++i]);
                smdo.ulThread = _wtol(argv[++i]);
                wszDump       = argv[++i];

                if (argv[i - 3][2] == L'T' || argv[i - 3][2] == L't')
                {
                    if (i + 1 >= argc)
                        goto done;

                    smdo.dwThreadID = _wtol(argv[++i]);
                    smdo.dfOptions  = dfFilterThread;
                }
                else if (argv[i - 3][2] == L'S' || argv[i - 3][2] == L's')
                {
                    if (i + 2 >= argc)
                        goto done;

                    smdo.dwThreadID = _wtol(argv[++i]);
                    smdo.ulThreadEx = _wtol(argv[++i]);
                    smdo.dfOptions  = dfFilterThreadEx;
                }
                else if (argv[i - 3][2] == L'M' || argv[i - 3][2] == L'm')
                {
                    HANDLE  hmemRemote = NULL;
                    LPVOID  pvMem = NULL;

                    if (i + 1 >= argc)
                        goto done;

                    hproc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwpid);
                    if (hproc == NULL)
                        goto done;
#ifdef _WIN64
                    hmemRemote = (HANDLE)_wtoi64(argv[++i]);
#else
                    hmemRemote = (HANDLE)_wtol(argv[++i]);
#endif
                    VALIDATEPARM(hr, (hmemRemote == NULL));
                    if (FAILED(hr))
                        goto done;

                    if (DuplicateHandle(hproc, hmemRemote, GetCurrentProcess(),
                                        &hmem, 0, FALSE,
                                        DUPLICATE_SAME_ACCESS) == FALSE)
                        goto done;

                    pvMem = MapViewOfFile(hmem, FILE_MAP_WRITE | FILE_MAP_WRITE,
                                          0, 0, 0);
                    if (pvMem == NULL)
                        goto done;

                    psmdo = (SMDumpOptions *)pvMem;
                }

                break;

            default:
                goto done;
        }
    }

    // if we didn't get an operation, no point in doing anything else...
    if (eop == eopNone)
        goto done;

    GetSystemDirectoryW(wszMod, sizeofSTRW(wszMod));
    wcscat(wszMod, L"\\faultrep.dll");

    hmod = LoadLibraryExW(wszMod, NULL, 0);

    VALIDATEPARM(hr, (hmod == NULL));
    if (FAILED(hr))
        goto done;

    switch(eop)
    {
        // user or kernel faults:
        case eopEvent:
            ReportEvents(hmod, ct);
            break;

        // dumps
        case eopDump:
        {
            pfn_CREATEMINIDUMPW pfnCM;

            VALIDATEPARM(hr,(wszDump == NULL));
            if (FAILED(hr))
                goto done;

            pfnCM = (pfn_CREATEMINIDUMPW)GetProcAddress(hmod,
                                                        "CreateMinidumpW");
            VALIDATEPARM(hr, (pfnCM == NULL));
            if (SUCCEEDED(hr))
                frrv = (*pfnCM)(dwpid, wszDump, psmdo) ? frrvOk : frrvErr;

            break;
        }

        // hangs
        case eopHang:
        {
            pfn_REPORTHANG  pfnRH;

            pfnRH = (pfn_REPORTHANG)GetProcAddress(hmod, "ReportHang");
            VALIDATEPARM(hr, (pfnRH == NULL));

            if (SUCCEEDED(hr))
                 frrv = (*pfnRH)(dwpid, dwtid, f64bit, hevNotify);

            break;
        }

        // err, shouldn't get here
        default:
            break;
    }

done:
    if (hmod != NULL)
        FreeLibrary(hmod);
    if (hproc != NULL)
        CloseHandle(hproc);
    if (hmem != NULL)
        CloseHandle(hmem);
    if (hevNotify != NULL)
        CloseHandle(hevNotify);
    if (psmdo != NULL && psmdo != &smdo)
        UnmapViewOfFile((LPVOID)psmdo);

    TERM_TRACING;

    return frrv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\ersvc\ers.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    dllmain.cpp

Revision History:
    derekm  02/28/2001    created

******************************************************************************/

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////////////
// globals

struct SServiceOps
{
    SERVICE_STATUS_HANDLE   hss;
    SERVICE_STATUS          ss;
    HANDLE                  hev;
    HANDLE                  hwait;
    HANDLE                  hevStartDone;
};


CRITICAL_SECTION    g_csReqs;
HANDLE              g_hevSvcStop = NULL;
HINSTANCE           g_hInstance = NULL;


//////////////////////////////////////////////////////////////////////////////
// DllMain

// ***************************************************************************
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
    BOOL    fRet = TRUE;

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = hInstance;
            DisableThreadLibraryCalls(hInstance);
            __try { InitializeCriticalSection(&g_csReqs); }
            __except (EXCEPTION_EXECUTE_HANDLER) { fRet = FALSE; }
            InitializeSvcDataStructs();
            break;

        case DLL_PROCESS_DETACH:
            DeleteCriticalSection(&g_csReqs);
            break;
    }

    return fRet;
}


//////////////////////////////////////////////////////////////////////////////
// Service functions

// ***************************************************************************
DWORD WINAPI HandlerEx(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData,
                       LPVOID lpContext)
{
    HANDLE  hevShutdown = (HANDLE)lpContext;

    switch(dwControl)
    {
        case SERVICE_CONTROL_STOP:
            if (g_hevSvcStop != NULL)
                SetEvent(g_hevSvcStop);
            break;

        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        case SERVICE_CONTROL_INTERROGATE:
            break;

        case SERVICE_CONTROL_SHUTDOWN:
            if (g_hevSvcStop != NULL)
                SetEvent(g_hevSvcStop);
            break;

        default:
            return ERROR_CALL_NOT_IMPLEMENTED;
    }

    return NOERROR;
}

// ***************************************************************************
void WINAPI ServiceMain(DWORD dwArgc, LPWSTR *lpszArgv)
{
    SERVICE_STATUS_HANDLE   hss;
    SERVICE_STATUS          ss;
    CAutoUnlockCS           aucs(&g_csReqs);
    SRequest                *rgReqs = NULL;
    HANDLE                  hevShutdown = NULL;
    WCHAR                   wszMod[MAX_PATH];
    DWORD                   dw, cReqs;
    BOOL                    fRet;

    INIT_TRACING;

    // if lpszArgv is NULL or the ER service is not the one to be started
    //  then bail...
    if (lpszArgv == NULL || _wcsicmp(lpszArgv[0], L"ersvc") != 0)
        return;

    g_hevSvcStop = CreateEventW(NULL, TRUE, FALSE, NULL);
    if (g_hevSvcStop == NULL)
        return;

    hss = RegisterServiceCtrlHandlerExW(c_wszERSvc, HandlerEx, 
                                        (LPVOID)&g_hevSvcStop);    

    // set up the status structure & set the initial status
    ss.dwControlsAccepted        = SERVICE_ACCEPT_SHUTDOWN | SERVICE_ACCEPT_STOP;
    ss.dwCurrentState            = SERVICE_START_PENDING;
    ss.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    ss.dwServiceSpecificExitCode = 0;
    ss.dwWin32ExitCode           = 0;
    ss.dwCheckPoint              = 0;
    ss.dwWaitHint                = 1000;
    SetServiceStatus(hss, &ss);

    // start up the waits
    fRet = StartERSvc(hss, ss, &rgReqs, &cReqs);
    if (fRet == FALSE)
        goto done;

     // yay!  we're all happily running now...
    ss.dwCurrentState = SERVICE_RUNNING;
    ss.dwCheckPoint++;
    SetServiceStatus(hss, &ss);

    fRet = ProcessRequests(rgReqs, cReqs);
    
    // set ourselves as in the process of stopping
    ss.dwCurrentState = SERVICE_STOP_PENDING;
    ss.dwCheckPoint   = 0;
    SetServiceStatus(hss, &ss);

    // stop all the waits
    __try { StopERSvc(hss, ss, rgReqs, cReqs); }
    __except(EXCEPTION_EXECUTE_HANDLER) { }

    SetLastError(0);


done:
    if (g_hevSvcStop != NULL)
        CloseHandle(g_hevSvcStop);
    if (rgReqs != NULL)
        MyFree(rgReqs);
    
    ss.dwWin32ExitCode = GetLastError();
    ss.dwCurrentState  = SERVICE_STOPPED;
    SetServiceStatus(hss, &ss);

    TERM_TRACING;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\dumprep\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DD_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DD_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define PFCLICFG_LITE 1
#ifndef DEBUG
#define NOTRACE 1
#endif

#include <windows.h>
#include "util.h"
#include "faultrep.h"
#include "ercommon.h"
#include "wchar.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__A9DB83DD_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\ersvc\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    PCH

Revision History:
    derekm   02/28/2001     created

******************************************************************************/

#ifndef STDAFX_ERS_H
#define STDAFX_ERS_H

#ifndef DEBUG
#define NOTRACE 1
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsta.h>
#include <userenv.h>
#include <aclapi.h>

#include <malloc.h>

#include <pchrexec.h>
#include <faultrep.h>
#include <util.h>
#include <ercommon.h>

#include "ers.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\ersvc\erswait.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    erswait.cpp

Abstract:
    Implementation of DLL Exports.

Revision History:
    derekm  02/28/2001    created

******************************************************************************/


#include "stdafx.h"

#include "stdio.h"
#include "pfrcfg.h"


//////////////////////////////////////////////////////////////////////////////
// Globals

SECURITY_DESCRIPTOR g_rgsd[ertiCount];
SRequestEventType   g_rgEvents[ertiCount];

HANDLE              g_hmutUser = NULL;
HANDLE              g_hmutKrnl = NULL;
HANDLE              g_hmutShut = NULL;


//////////////////////////////////////////////////////////////////////////////
// misc stuff

// ***************************************************************************
void InitializeSvcDataStructs(void)
{
    ZeroMemory(g_rgsd, ertiCount * sizeof(SECURITY_DESCRIPTOR));
    ZeroMemory(g_rgEvents, ertiCount * sizeof(SRequestEventType));

    g_rgEvents[ertiHang].pfn             = ProcessHangRequest;
    g_rgEvents[ertiHang].wszPipeName     = c_wszHangPipe;
    g_rgEvents[ertiHang].wszRVPipeCount  = c_wszRVNumHangPipe;
    g_rgEvents[ertiHang].cPipes          = c_cMinPipes;
    g_rgEvents[ertiHang].fAllowNonLS     = FALSE;

    g_rgEvents[ertiFault].pfn            = ProcessFaultRequest;
    g_rgEvents[ertiFault].wszPipeName    = c_wszFaultPipe;
    g_rgEvents[ertiFault].wszRVPipeCount = c_wszRVNumFaultPipe;
    g_rgEvents[ertiFault].cPipes         = c_cMinPipes;
    g_rgEvents[ertiFault].fAllowNonLS    = TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// pipe manager

// ***************************************************************************
BOOL ExecServer(SRequest *pReq)
{
    OVERLAPPED  ol;
    HANDLE      rghWait[2] = { NULL, NULL };
    HANDLE      hPipe = INVALID_HANDLE_VALUE;
    DWORD       cbBuf, cb, dw;
    BOOL        fRet, fShutdown = FALSE;
    BYTE        Buf[ERRORREP_PIPE_BUF_SIZE];

    rghWait[0] = g_hevSvcStop;
    hPipe      = pReq->hPipe;

    if (hPipe == INVALID_HANDLE_VALUE || rghWait[0] == NULL ||
        pReq->pret->pfn == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // need another event for waiting on the pipe read
    rghWait[1] = CreateEventW(NULL, TRUE, FALSE, NULL);
    if (rghWait[1] == NULL)
        goto done;

    // setup the overlapped structure
    ZeroMemory(&ol, sizeof(ol));
    ol.hEvent = rghWait[1];

    // read the request
    ResetEvent(ol.hEvent);
    fRet = ReadFile(hPipe, Buf, sizeof(Buf), &cb, &ol);
    if (fRet == FALSE && GetLastError() == ERROR_IO_PENDING)
    {
        // give the client 60s to write the data to us.
        // WAIT_OBJECT_0 is the shutdown event
        // WAIT_OBJECT_0 + 1 is the overlapped event
        dw = WaitForMultipleObjects(2, rghWait, FALSE, 60000);
        if (dw == WAIT_OBJECT_0)
            fShutdown = TRUE;
        else if (dw != WAIT_OBJECT_0 + 1)
            goto done;

        fRet = TRUE;
    }

    if (fRet)
        fRet = GetOverlappedResult(hPipe, &ol, &cbBuf, FALSE);

    // if we got an error, the client might still be waiting for a 
    //  reply, so construct a default one.
    // ProcessExecRequest() will always construct a reply and store it
    //  in Buf, so no special handling is needed if it fails.
    if (fShutdown == FALSE && fRet)
    {
        cbBuf = sizeof(Buf);
        fRet = (*(pReq->pret->pfn))(hPipe, Buf, &cbBuf);
    }
    else
    {
        SPCHExecServGenericReply    esrep;
        
        ZeroMemory(&esrep, sizeof(esrep));
        esrep.cb    = sizeof(esrep);
        esrep.ess   = essErr;
        esrep.dwErr = GetLastError();

        RtlCopyMemory(Buf, &esrep, sizeof(esrep));
        cbBuf = sizeof(esrep);
    }

    // write the reply to the message
    ResetEvent(ol.hEvent);
    fRet = WriteFile(hPipe, Buf, cbBuf, &cb, &ol);
    if (fRet == FALSE && GetLastError() == ERROR_IO_PENDING)
    {
        // give ourselves 60s to write the data to the pipe.
        // WAIT_OBJECT_0 is the shutdown event
        // WAIT_OBJECT_0 + 1 is the overlapped event
        dw = WaitForMultipleObjects(2, rghWait, FALSE, 60000);
        if (dw == WAIT_OBJECT_0)
            fShutdown = TRUE;
        else if (dw != WAIT_OBJECT_0 + 1)
            goto done;

        fRet = TRUE;
    }

    // wait for the client to read the buffer- note that we could use 
    //  FlushFileBuffers() to do this, but that is blocking with no
    //  timeout, so we try to do a read on the pipe & wait to get an 
    //  error indicating that the client closed it.
    // Yup, this is a hack, but this is apparently the way to do this
    //  when using async pipe communication.  Sigh...
    if (fShutdown == FALSE && fRet)
    {
        ResetEvent(ol.hEvent);
        fRet = ReadFile(hPipe, Buf, sizeof(Buf), &cb, &ol);
        if (fRet == FALSE && GetLastError() == ERROR_IO_PENDING)
        {
            // give ourselves 60s to read the data from the pipe. 
            //  Except for the shutdown notification, don't really
            //  care what this routine returns cuz we're just using
            //  it to wait on the read to finish
            // WAIT_OBJECT_0 is the shutdown event
            // WAIT_OBJECT_0 + 1 is the overlapped event
            dw = WaitForMultipleObjects(2, rghWait, FALSE, 60000);
            if (dw == WAIT_OBJECT_0)
                fShutdown = TRUE;
        }
    }

    SetLastError(0);

done:
    dw = GetLastError();
    
    if (hPipe != INVALID_HANDLE_VALUE)
        DisconnectNamedPipe(hPipe);
    if (rghWait[1] != NULL)
        CloseHandle(rghWait[1]);

    SetLastError(dw);

    return fShutdown;
}

// ***************************************************************************
DWORD WINAPI threadExecServer(PVOID pvContext)
{
    SRequest        *pReq = (SRequest *)pvContext;

    if (pReq == NULL)
        return ERROR_INVALID_PARAMETER;
    
    // this acquires the request CS and holds it until the function exits
    CAutoUnlockCS   aucs(&pReq->csReq, TRUE);

    // make sure we aren't shutting down
    if (WaitForSingleObject(g_hevSvcStop, 0) != WAIT_TIMEOUT)
    {
        SetLastError( ERROR_SUCCESS );
        goto done;
    }
    
    __try { ExecServer(pReq); }
    __except(SetLastError(GetExceptionCode()), EXCEPTION_EXECUTE_HANDLER) { }
done:
    if (pReq->hModErsvc) FreeLibrary(pReq->hModErsvc);
    return GetLastError();
}


//////////////////////////////////////////////////////////////////////////////
// object manager

// ***************************************************************************
void NukeRequestObj(SRequest *pReq, BOOL fFreeEvent)
{
    if (pReq == NULL)
        return;

    // this acquires the request CS and holds it until the function exits
    CAutoUnlockCS   aucs(&pReq->csReq, TRUE);
    
    // free the pipe
    if (pReq->hPipe != INVALID_HANDLE_VALUE)
    {
        DisconnectNamedPipe(pReq->hPipe);
        CloseHandle(pReq->hPipe);
        pReq->hPipe = INVALID_HANDLE_VALUE;
    }

    if (fFreeEvent && pReq->ol.hEvent != NULL)
    {
        CloseHandle(pReq->ol.hEvent);
        ZeroMemory(&pReq->ol, sizeof(pReq->ol));
    }

    if (pReq->hth != NULL)
    {
        CloseHandle(pReq->hth);
        pReq->hth = NULL;
    }

    pReq->ers = ersEmpty;
}

// ***************************************************************************
BOOL BuildRequestObj(SRequest *pReq, SRequestEventType *pret)
{
    SECURITY_ATTRIBUTES sa;
    HANDLE              hev = NULL;
    HANDLE              hPipe = INVALID_HANDLE_VALUE;
    BOOL                fRet = FALSE;

    if (pReq == NULL || pret == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // if this is empty, then we're building a fresh object, so create an 
    //  event for waiting on the pipe listen
    if (pReq->ol.hEvent == NULL)
    {
        // need an 
        hev = CreateEventW(NULL, FALSE, FALSE, NULL);
        if (hev == NULL)
            goto done;
    }

    // otherwise, store away the existing event
    else
    {
        hev = pReq->ol.hEvent;
        ResetEvent(hev);
    }

    // don't want to nuke the critical section!
    ZeroMemory(((PBYTE)pReq + sizeof(pReq->csReq)), 
               sizeof(SRequest) - sizeof(pReq->csReq));

    sa.nLength              = sizeof(sa);
    sa.bInheritHandle       = FALSE;
    sa.lpSecurityDescriptor = pret->psd;

    // obviously gotta have a pipe
    hPipe = CreateNamedPipeW(pret->wszPipeName, 
                             PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                             PIPE_WAIT | PIPE_READMODE_MESSAGE | PIPE_TYPE_MESSAGE,
                             c_cMaxPipes, ERRORREP_PIPE_BUF_SIZE, 
                             ERRORREP_PIPE_BUF_SIZE, 0, &sa);
    if (hPipe == INVALID_HANDLE_VALUE)
        goto done;

    // make sure we aren't shutting down
    if (WaitForSingleObject(g_hevSvcStop, 0) != WAIT_TIMEOUT)
        goto done;

    pReq->ol.hEvent = hev;
        
    // start waiting on the pipe
    fRet = ConnectNamedPipe(hPipe, &pReq->ol);
    if (fRet == FALSE && GetLastError() != ERROR_IO_PENDING)
    {
        // if the pipe is already connected, just set the event cuz 
        //  ConnectNamedPipe doesn't
        if (GetLastError() == ERROR_PIPE_CONNECTED)
        {
            SetEvent(pReq->ol.hEvent);
        }
        else
        {
            pReq->ol.hEvent = NULL;
            goto done;
        }
    }

    // yay!  save off everything.
    pReq->ers       = ersWaiting;
    pReq->pret      = pret;
    pReq->hPipe     = hPipe;
    hev             = NULL;
    hPipe           = INVALID_HANDLE_VALUE;
    fRet            = TRUE;

done:
    if (hev != NULL)
        CloseHandle(hev);
    if (hPipe != INVALID_HANDLE_VALUE)
    {
        DisconnectNamedPipe(hPipe);
        CloseHandle(hPipe);
    }

    return fRet;
}

// ***************************************************************************
BOOL ResetRequestObj(SRequest *pReq)
{
    BOOL    fRet = FALSE;

    if (pReq == NULL || pReq->ers != ersProcessing)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // clean up the thread handle.
    if (pReq->hth != NULL)
    {
        CloseHandle(pReq->hth);
        pReq->hth = NULL;
    }

    // check and make sure that our object is valid.  If it ain't, nuke it
    //  and rebuild it.
    if (pReq->hPipe != NULL && pReq->ol.hEvent != NULL && 
        pReq->pret != NULL)
    {
        // start waiting on the pipe
        fRet = ConnectNamedPipe(pReq->hPipe, &pReq->ol);
        if (fRet == FALSE)
        {
            switch(GetLastError())
            {
                case ERROR_IO_PENDING:
                    fRet = TRUE;
                    break;

                case ERROR_PIPE_CONNECTED:
                    SetEvent(pReq->ol.hEvent);
                    fRet = TRUE;
                    break;

                default:
                    break;
            }
        }
    }

    if (fRet == FALSE)
    {
        NukeRequestObj(pReq, FALSE);
        fRet = BuildRequestObj(pReq, pReq->pret);
        if (fRet == FALSE)
            goto done;
    }
    else
    {
        pReq->ers = ersWaiting;
    }

done:
    return fRet;
}

// ***************************************************************************
BOOL ProcessRequestObj(SRequest *pReq)
{
    HANDLE  hth = NULL;

    // should do a LoadLibrary on ersvc.dll before entering the thread.  
    // Then, at the end of the thread, do a FreeLibraryAndExitThread() call.  
    // This eliminates a very very small chance of a race condition (leading to an AV)
    // when shutting the service down.
    if (!pReq)
    {
        return FALSE;
    }
    pReq->hModErsvc = LoadLibraryExW(L"ersvc.dll", NULL, 0);
    if (pReq->hModErsvc == NULL)
    {
        return FALSE;
    }
    hth = CreateThread(NULL, 0, threadExecServer, pReq, 0, NULL);
    if (hth == NULL) 
    {
        FreeLibrary(pReq->hModErsvc);
        return FALSE;
    }

    pReq->ers = ersProcessing;
    pReq->hth = hth;
    hth       = NULL;

    return TRUE;
}

// ***************************************************************************
BOOL ProcessRequests(SRequest *rgReqs, DWORD cReqs)
{
    HANDLE  *rghWait = NULL;
    DWORD   iReq, cErrs = 0, dw;
    BOOL    fRet = FALSE;

    if (rgReqs == NULL || cReqs == NULL || cReqs > MAXIMUM_WAIT_OBJECTS)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    rghWait = (HANDLE *)MyAlloc((cReqs + 1) * sizeof(HANDLE));
    if (rghWait == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    // initially, populate all the entries in the wait array with the handles
    //  to the overlapped events
    rghWait[0] = g_hevSvcStop;
    for(iReq = 0; iReq < cReqs; iReq++)
    {
        if (rgReqs[iReq].ol.hEvent != NULL)
            rghWait[iReq + 1] = rgReqs[iReq].ol.hEvent;
        else
            goto done;
    }

    for(;;)
    {
        dw = WaitForMultipleObjects(cReqs + 1, rghWait, FALSE, INFINITE);

        // if it's the first wait handle, then we're shutting down, so just return
        //  TRUE
        if (dw == WAIT_OBJECT_0)
        {
            fRet = TRUE;
            goto done;
        }

        // yippy!  It's one of the pipes.
        else if (dw >= WAIT_OBJECT_0 + 1 && dw <= WAIT_OBJECT_0 + cReqs)
        {
            SRequest *pReq;

            cErrs = 0;
            iReq  = (dw - WAIT_OBJECT_0) - 1;
            pReq  = &rgReqs[iReq];
            
            // check first to make sure we aren't shutting down.  If we are, just
            //  bail
            if (WaitForSingleObject(g_hevSvcStop, 0) != WAIT_TIMEOUT)
            {
                fRet = TRUE;
                goto done;
            }

            if (pReq->ers == ersWaiting)
            {
                fRet = ProcessRequestObj(pReq);

                // if we succeeded, then wait for the thread to complete instead
                //  of the named pipe connect event
                if (fRet)
                {
                    rghWait[iReq + 1] = pReq->hth;
                    continue;
                }
                else
                {
                    // set this so that we fall thru to the next case & get
                    //  everything cleaned up...
                    pReq->ers = ersProcessing;
                }
            }

            if (pReq->ers == ersProcessing)
            {
                fRet = ResetRequestObj(pReq);
                if (fRet == FALSE)
                {
                    if (iReq < cReqs - 1)
                    {
                        SRequest oReq;
                        HANDLE  hWait;

                        CopyMemory(&oReq, pReq, sizeof(oReq));
                        MoveMemory(&rgReqs[iReq], &rgReqs[iReq + 1], 
                                   (cReqs - iReq - 1) * sizeof(SRequest));
                        CopyMemory(&rgReqs[cReqs - 1], &oReq, sizeof(oReq));

                        // rearrange the rghWait array as well.  Otherwise it's out of sync with the object array
                        hWait = rghWait[iReq + 1];
                        MoveMemory(&rghWait[iReq + 1], &rghWait[iReq + 2], 
                                   (cReqs - iReq - 1));
                        rghWait[cReqs] = hWait;
                    }

                    cReqs--;
                }

                // ok, time to start waiting on the event to signal that a pipe
                //  has been connected to...
                else
                {
                    rghWait[iReq + 1] = pReq->ol.hEvent;

                }
            }
        }

        // um, this is bad.
        else
        {
            if (cErrs > 8)
            {
                ASSERT(FALSE);
                break;
            }
            cErrs++;
        }
    }
    

done:
    if (rghWait != NULL)
        MyFree(rghWait);
    return fRet;
}


//////////////////////////////////////////////////////////////////////////////
// startup & shutdown

// ***************************************************************************
BOOL StartERSvc(SERVICE_STATUS_HANDLE hss, SERVICE_STATUS &ss, 
                SRequest **prgReqs, DWORD *pcReqs)
{
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    SRequest            *rgReqs = NULL;
    HANDLE              hth, hmut = NULL;
    DWORD               dw, i, iPipe, dwType, cb, cReqs, iReqs;
    BOOL                fRet = FALSE;
    HKEY                hkey = NULL;

    ZeroMemory(&sa, sizeof(sa));

    if (hss == NULL || prgReqs == NULL || pcReqs == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    *prgReqs = NULL;
    *pcReqs  = NULL;

    if (AllocSD(&sd, ACCESS_ALL, ACCESS_ALL, 0) == FALSE)
        goto done;

    sa.nLength              = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle       = FALSE;

    // these two mutexes will intentionally not be free'd even if we stop the
    //  exec server threads...  These need to exist for kernel fault reporting
    //  to work.  Don't want to completely bail if we fail since we could just
    //  have restarted the server & we don't actually need these for the 
    //  service to work.
    hmut = CreateMutexW(&sa, FALSE, c_wszMutKrnlName);
    if (hmut != NULL)
    {
        if (GetLastError() != ERROR_ALREADY_EXISTS)
            g_hmutKrnl = hmut;
        else
            CloseHandle(hmut);
        hmut = NULL;
    }
    hmut = CreateMutexW(&sa, FALSE, c_wszMutUserName);
    if (hmut != NULL)
    {
        if (GetLastError() != ERROR_ALREADY_EXISTS)
            g_hmutKrnl = hmut;
        else
            CloseHandle(hmut);
        hmut = NULL;
    }
    hmut = CreateMutexW(&sa, FALSE, c_wszMutShutName);
    if (hmut != NULL)
    {
        if (GetLastError() != ERROR_ALREADY_EXISTS)
            g_hmutShut = hmut;
        else
            CloseHandle(hmut);
        hmut = NULL;
    }

    dw = RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRPCfg, 0, KEY_READ, &hkey);
    if (dw != ERROR_SUCCESS)
        hkey = NULL;

    // find out how many pipes we're gonna create
    cReqs = 0;
    for(i = 0; i < ertiCount; i++)
    {
        if (hkey != NULL)
        {
            cb = sizeof(g_rgEvents[i].cPipes);
            dw = RegQueryValueExW(hkey, g_rgEvents[i].wszRVPipeCount, 0, 
                                  &dwType, (LPBYTE)&g_rgEvents[i].cPipes, &cb);
            if (dwType != REG_DWORD || g_rgEvents[i].cPipes < c_cMinPipes)
                g_rgEvents[i].cPipes = c_cMinPipes;
            else if (g_rgEvents[i].cPipes > c_cMaxPipes)
                g_rgEvents[i].cPipes = c_cMaxPipes;
        }

        cReqs += g_rgEvents[i].cPipes;
        
        ss.dwCheckPoint++;
        SetServiceStatus(hss, &ss);
    }

    if (cReqs >= MAXIMUM_WAIT_OBJECTS)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // allocate the array that will hold the request info
    rgReqs = (SRequest *)MyAlloc(cReqs * sizeof(SRequest));
    if (rgReqs == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    // build our array of request objects
    fRet  = TRUE;
    iReqs = 0;
    for (i = 0; i < ertiCount; i++)
    {
        dw = (g_rgEvents[i].fAllowNonLS) ? ACCESS_RW : 0;
        fRet = AllocSD(&g_rgsd[i], ACCESS_ALL, dw, dw);
        if (fRet == FALSE)
            break;
        
        g_rgEvents[i].psd = &g_rgsd[i];

        // allocate request objects
        for (iPipe = 0; iPipe < g_rgEvents[i].cPipes; iPipe++)
        {
            rgReqs[iReqs].hPipe = INVALID_HANDLE_VALUE;

            InitializeCriticalSection(&rgReqs[iReqs].csReq);
            
            fRet = BuildRequestObj(&rgReqs[iReqs], &g_rgEvents[i]);
            if (fRet == FALSE)
                break;

            iReqs++;
        }
        if (fRet == FALSE)
            break;

        // need to update service status
        ss.dwCheckPoint++;
        SetServiceStatus(hss, &ss);
    }

    if (fRet == FALSE)
    {
        ss.dwCheckPoint++;
        ss.dwCurrentState = SERVICE_STOP_PENDING;
        SetServiceStatus(hss, &ss);
        StopERSvc(hss, ss, rgReqs, cReqs);
    }
    else
    {
        *prgReqs = rgReqs;
        *pcReqs  = cReqs;

        rgReqs   = NULL;
        cReqs    = 0;
    }

done:
    if (sa.lpSecurityDescriptor != NULL)
        FreeSD((SECURITY_DESCRIPTOR *)sa.lpSecurityDescriptor);
    if (rgReqs != NULL)
        MyFree(rgReqs);
    if (hkey != NULL)
        RegCloseKey(hkey);

    return fRet;
}

// ***************************************************************************
BOOL StopERSvc(SERVICE_STATUS_HANDLE hss, SERVICE_STATUS &ss, 
               SRequest *rgReqs, DWORD cReqs)
{
    DWORD i;

    if (hss == NULL || rgReqs == NULL || cReqs == 0)
	{
	    SetLastError(ERROR_INVALID_PARAMETER);
	    return FALSE;
	}

    if (g_hevSvcStop == NULL)
        goto done;

    SetEvent(g_hevSvcStop);

    // update service status
    ss.dwCheckPoint++;
    SetServiceStatus(hss, &ss);

    for (i = 0; i < cReqs; i++)
    {
        NukeRequestObj(&rgReqs[i], TRUE);
        DeleteCriticalSection(&rgReqs[i].csReq);
    }

    for (i = 0; i < ertiCount; i++)
    {
        if (g_rgEvents[i].psd != NULL)
            FreeSD(g_rgEvents[i].psd);
    }

    // update service status
    ss.dwCheckPoint++;
    SetServiceStatus(hss, &ss);

done:
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\faultrep\faultrep.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    faultrep.cpp

Abstract:
    Implements misc fault reporting functions

Revision History:
    created     derekm      07/07/00

******************************************************************************/

#include "stdafx.h"
#include "wchar.h"

///////////////////////////////////////////////////////////////////////////////
// Global stuff

HINSTANCE g_hInstance = NULL;
BOOL      g_fAlreadyReportingFault = FALSE;
#ifdef DEBUG
BOOL    g_fAlreadySpewing = FALSE;
#endif



///////////////////////////////////////////////////////////////////////////////
// DllMain

// **************************************************************************
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = hInstance;
            DisableThreadLibraryCalls(hInstance);
#ifdef DEBUG
            if (!g_fAlreadySpewing)
            {
                INIT_TRACING;
                g_fAlreadySpewing = TRUE;
            }
#endif
            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// exported functions

// **************************************************************************
BOOL APIENTRY CreateMinidumpW(DWORD dwpid, LPCWSTR wszPath, 
                              SMDumpOptions *psmdo)
{
    USE_TRACING("CreateMinidumpW");

    SMDumpOptions   smdo;
    HANDLE          hProc;
    BOOL            fRet, f64bit;

    if (dwpid == 0 || wszPath == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hProc = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE,
                        dwpid);
    if (hProc == NULL)
        return FALSE;

#ifdef _WIN64
    ULONG_PTR                   Wow64Info = 0;
    NTSTATUS                    Status;

        // Do something here to decide if this is a 32 or 64 bit app...
    // need to determine if we're a Wow64 process so we can build the appropriate
    //  signatures...
    Status = NtQueryInformationProcess(hProc, ProcessWow64Information,
                                       &Wow64Info, sizeof(Wow64Info), NULL);
    if (NT_SUCCESS(Status) == FALSE) {
                // assume that this is 64 bit if we fail
                f64bit = TRUE;
    } else {
                // use the value returned from ntdll
            f64bit = (Wow64Info == 0);
        }

#else
        f64bit=FALSE;
#endif

    // if we want to collect a signature, by default the module needs to
    //  be set to 'unknown'
    if (psmdo && (psmdo->dfOptions & dfCollectSig) != 0)
        wcscpy(psmdo->wszMod, L"unknown");

#ifndef MANIFEST_HEAP
    fRet = InternalGenerateMinidump(hProc, dwpid, wszPath, psmdo);
#else
    fRet = InternalGenerateMinidump(hProc, dwpid, wszPath, psmdo, f64bit);
#endif
    CloseHandle(hProc);

    return fRet;
}

// **************************************************************************
BOOL APIENTRY CreateMinidumpA(DWORD dwpid, LPCSTR szPath, SMDumpOptions *psmdo)
{
    USE_TRACING("CreateMinidumpA");

    LPWSTR  wszPath = NULL;
    DWORD   cch;

    if (szPath == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    cch = MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, 0);
    __try { wszPath = (LPWSTR)_alloca(cch * sizeof(WCHAR)); } 
    __except(EXCEPTION_STACK_OVERFLOW) { wszPath = NULL; }
    if (wszPath == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    if (MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, cch) == 0)
        return FALSE;

    return CreateMinidumpW(dwpid, wszPath, psmdo);
}

// **************************************************************************
BOOL AddERExcludedApplicationW(LPCWSTR wszApplication)
{
    USE_TRACING("AddERExcludedApplicationW");

    LPCWSTR pwszApp;
    DWORD   dw, dwData;
    HKEY    hkey = NULL;

    if (wszApplication == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // make sure the user didn't give us a full path (ie, one containing 
    //  backslashes).  If he did, only use the part of the string after the
    //  last backslash
    for (pwszApp = wszApplication + wcslen(wszApplication);
         *pwszApp != L'\\' && pwszApp > wszApplication;
         pwszApp--);
    if (*pwszApp == L'\\')
        pwszApp++;

    if (*pwszApp == L'\0')
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // gotta open the reg key
    dw = RegCreateKeyExW(HKEY_LOCAL_MACHINE, c_wszRPCfgCPLExList, 0, NULL, 0,
                         KEY_ALL_ACCESS | KEY_WOW64_64KEY, NULL, &hkey, NULL);
    if (dw != ERROR_SUCCESS)
    {
        SetLastError(dw);
        return FALSE;
    }

    // set the value
    dwData = 1;
    dw = RegSetValueExW(hkey, pwszApp, NULL, REG_DWORD, (PBYTE)&dwData, 
                        sizeof(dwData));
    RegCloseKey(hkey);
    if (dw != ERROR_SUCCESS)
    {
        SetLastError(dw);
        return FALSE;
    }

    return TRUE;
}

// **************************************************************************
BOOL AddERExcludedApplicationA(LPCSTR szApplication)
{
    USE_TRACING("AddERExcludedApplicationA");

    LPWSTR  wszApp = NULL;
    DWORD   cch;

    if (szApplication == NULL || szApplication[0] == '\0')
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    cch = MultiByteToWideChar(CP_ACP, 0, szApplication, -1, wszApp, 0);
    __try { wszApp = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszApp = NULL; }
    if (wszApp == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    if (MultiByteToWideChar(CP_ACP, 0, szApplication, -1, wszApp, cch) == 0)
        return FALSE;

    return AddERExcludedApplicationW(wszApp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\ersvc\ers.h ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    ers.h

Revision History:
    derekm  02/28/2001    created

******************************************************************************/


#ifndef ERS_H
#define ERS_H


//////////////////////////////////////////////////////////////////////////////
// structs, enums, & types

struct SRequest;
typedef BOOL (*REQUEST_FN)(HANDLE, PBYTE, DWORD *);

enum ERequestThreadId
{
    ertiHang = 0,
    ertiFault,
    ertiCount,
};

enum ERequestStatus
{
    ersEmpty = 0,
    ersWaiting,
    ersProcessing,
};

struct SRequestEventType
{
    SECURITY_DESCRIPTOR *psd;
    REQUEST_FN          pfn;
    LPCWSTR             wszPipeName;
    LPCWSTR             wszRVPipeCount;
    DWORD               cPipes;
    BOOL                fAllowNonLS;
};

// the critical section member MUST be the first member in the structure.
//  BuildRequestObj assumes that it is.
struct SRequest
{
    CRITICAL_SECTION    csReq;
    SRequestEventType   *pret;
    ERequestStatus      ers;
    OVERLAPPED          ol;
    HANDLE              hPipe;
    HANDLE              hth;
    HMODULE             hModErsvc;
};


//////////////////////////////////////////////////////////////////////////////
// defines  & constants

#define DIR_ACCESS_ALL     GENERIC_ALL | DELETE | READ_CONTROL | SYNCHRONIZE | SPECIFIC_RIGHTS_ALL
#define ACCESS_ALL     GENERIC_READ | GENERIC_WRITE | DELETE | READ_CONTROL | SYNCHRONIZE | SPECIFIC_RIGHTS_ALL
#define ACCESS_RW      GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE

const WCHAR c_wszQSubdir[]      = L"PCHealth\\ErrorRep\\UserDumps";
const WCHAR c_wszDWMCmdLine64[] = L"\"%ls\\dumprep.exe\" %ld -H%c %ld \"%ls\"";
const WCHAR c_wszDWMCmdLine32[] = L"\"%ls\\dumprep.exe\" %ld -H %ld \"%ls\"";
const WCHAR c_wszERSvc[]        = L"ersvc";
const WCHAR c_wszFaultPipe[]    = ERRORREP_FAULT_PIPENAME;
const WCHAR c_wszHangPipe[]     = ERRORREP_HANG_PIPENAME;


//////////////////////////////////////////////////////////////////////////////
// globals

extern CRITICAL_SECTION g_csReqs;
extern HINSTANCE        g_hInstance;
extern HANDLE           g_hevSvcStop;


//////////////////////////////////////////////////////////////////////////////
// prototypes

// utility prototypes
BOOL StartERSvc(SERVICE_STATUS_HANDLE hss, SERVICE_STATUS &ss,
                SRequest **prgReqs, DWORD *pcReqs);
BOOL StopERSvc(SERVICE_STATUS_HANDLE hss, SERVICE_STATUS &ss, 
               SRequest *rgReqs, DWORD cReqs);
BOOL ProcessRequests(SRequest *rgReqs, DWORD cReqs);

// pipe function prototypes
BOOL ProcessFaultRequest(HANDLE hPipe, PBYTE pBuf, DWORD *pcbBuf);
BOOL ProcessHangRequest(HANDLE hPipe, PBYTE pBuf, DWORD *pcbBuf);

//misc
void InitializeSvcDataStructs(void);


//////////////////////////////////////////////////////////////////////////////
// macros


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\ersvc\ersfunc.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    erwait.cpp

Revision History:
    derekm  02/28/2001    created

******************************************************************************/

#include "stdafx.h"

#include <stdio.h>
#include <pfrcfg.h>

// this is a private NT function that doesn't appear to be defined anywhere
//  public, so I'm including it here
extern "C" 
{
    HANDLE GetCurrentUserTokenW(  WCHAR Winsta[], DWORD DesiredAccess);
}

//////////////////////////////////////////////////////////////////////////////
// utility functions

// ***************************************************************************
BOOL CreateQueueDir(void)
{
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    WCHAR               wszDir[MAX_PATH], *pwszDir = NULL;
    DWORD               dw, cchNeed, cch;
    BOOL                fRet = FALSE;

    USE_TRACING("CreateQueueDir");

    ZeroMemory(&sa, sizeof(sa));
    ZeroMemory(&sd, sizeof(sd));

    if (AllocSD(&sd, DIR_ACCESS_ALL, DIR_ACCESS_ALL, 0) == FALSE)
    {
        DBG_MSG("AllocSD dies");
        goto done;
    }

    sa.nLength              = sizeof(sa);
    sa.bInheritHandle       = FALSE;
    sa.lpSecurityDescriptor = &sd;

    cch = GetSystemWindowsDirectoryW(wszDir, sizeofSTRW(wszDir));
    if (cch == 0)
    {
        DBG_MSG("GetSystemWindowsDirectoryW died");
        goto done;
    }

    cchNeed = cch + sizeofSTRW(c_wszQSubdir) + 2;
    if (cchNeed > sizeofSTRW(wszDir))
    {
        __try { pwszDir = (WCHAR *)_alloca(cchNeed * sizeof(WCHAR)); }
        __except(EXCEPTION_STACK_OVERFLOW) { pwszDir = NULL; }
        if (pwszDir == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }

        if (cch > sizeofSTRW(wszDir))
            cch = GetSystemWindowsDirectoryW(pwszDir, cchNeed);
        else
            wcscpy(pwszDir, wszDir);
    }
    else
    {
        pwszDir = wszDir;
    }

    // if the length of the system directory is 3, then %windir% is in the form
    //  of X:\, so clip off the backslash so we don't have to special case
    //  it below...
    if (cch == 3)
        *(pwszDir + 2) = L'\0';

    wcscat(pwszDir, L"\\PCHealth");

    if (CreateDirectoryW(pwszDir, NULL) == FALSE && 
        GetLastError() != ERROR_ALREADY_EXISTS)
    {
        DBG_MSG("Can't make dir1");
        goto done;
    }
        
    wcscat(pwszDir, L"\\ErrorRep");

    if (CreateDirectoryW(pwszDir, NULL) == FALSE && 
        GetLastError() != ERROR_ALREADY_EXISTS)
    {
        DBG_MSG("Can't make dir2");
        goto done;
    }
        

    wcscat(pwszDir, L"\\UserDumps");

    if (CreateDirectoryW(pwszDir, &sa) == FALSE &&
        GetLastError() != ERROR_ALREADY_EXISTS)
    {
        DBG_MSG("Can't make dir3");
        goto done;
    }
        

    // if the directory exists, then we need to write the security
    //  descriptor to it cuz we want to make sure that no inappropriate
    //  people can access it.
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        SID_IDENTIFIER_AUTHORITY    siaNT = SECURITY_NT_AUTHORITY;
        PACL                        pacl = NULL;
        PSID                        psidLS = NULL;
        BOOL                        fDef, fACL;

        if (GetSecurityDescriptorDacl(&sd, &fACL, &pacl, &fDef) == FALSE)
            goto done;

        if (AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 
                                     0, 0, 0, 0, 0, 0, &psidLS) == FALSE)
            goto done;
        
        dw = SetNamedSecurityInfoW(pwszDir, SE_FILE_OBJECT, 
                                   DACL_SECURITY_INFORMATION |
                                   OWNER_SECURITY_INFORMATION | 
                                   PROTECTED_DACL_SECURITY_INFORMATION, 
                                   psidLS, NULL, pacl, NULL);
        FreeSid(psidLS);
        if (dw != ERROR_SUCCESS)
        {
            SetLastError(dw);
            goto done;
        }                          
    }

    fRet = TRUE;

done:
    dw = GetLastError();

    if (sa.lpSecurityDescriptor != NULL)
        FreeSD((SECURITY_DESCRIPTOR *)sa.lpSecurityDescriptor);
    
    SetLastError(dw);

    DBG_MSG(fRet ? "OK" : "failed");

    return fRet;
}

// ***************************************************************************
HMODULE LoadERDll(void)
{
    HMODULE hmod = NULL;
    WCHAR   wszMod[MAX_PATH], *pwszMod;
    DWORD   cch, cchNeed;

    cch = GetSystemDirectoryW(wszMod, sizeofSTRW(wszMod));
    if (cch == 0)
        goto done;

    // the '14' is for the 
    cchNeed = cch + 14;

    if (cchNeed > sizeofSTRW(wszMod))
    {
        __try { pwszMod = (WCHAR *)_alloca(cchNeed * sizeof(WCHAR)); }
        __except(EXCEPTION_STACK_OVERFLOW) { pwszMod = NULL; }
        if (pwszMod == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }

        if (cch > sizeofSTRW(wszMod))
            cch = GetSystemDirectoryW(pwszMod, cchNeed);
        else
            wcscpy(pwszMod, wszMod);
    }
    else
    {
        pwszMod = wszMod;
    }

    // if the length of the system directory is 3, then %windir% is in the form
    //  of X:\, so clip off the backslash so we don't have to special case
    //  it below...
    if (cch == 3)
        *(pwszMod + 2) = L'\0';

    wcscat(pwszMod, L"\\faultrep.dll");

    hmod = LoadLibraryExW(wszMod, NULL, 0);

done:
    return hmod;
}

// **************************************************************************
BOOL FindAdminSession(DWORD *pdwSession, HANDLE *phToken)
{
    USE_TRACING("FindAdminSession");

    WINSTATIONUSERTOKEN wsut;
    LOGONIDW            *rgSesn = NULL;
    DWORD               i, cSesn, cb, dw;
    BOOL                fRet = FALSE;
    HRESULT             hr = NOERROR;

    ZeroMemory(&wsut, sizeof(wsut));

    VALIDATEPARM(hr, (pdwSession == NULL || phToken == NULL));

    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    *pdwSession = (DWORD)-1;
    *phToken    = NULL;

    fRet = WinStationEnumerateW(SERVERNAME_CURRENT, &rgSesn, &cSesn);
    if (fRet == FALSE)
        goto done;
    
    wsut.ProcessId = LongToHandle(GetCurrentProcessId());
    wsut.ThreadId  = LongToHandle(GetCurrentThreadId());

    for(i = 0; i < cSesn; i++)
    {
        if (rgSesn[i].State != State_Active)
            continue;

        fRet = WinStationQueryInformationW(SERVERNAME_CURRENT, 
                                           rgSesn[i].SessionId,
                                           WinStationUserToken, &wsut,
                                           sizeof(wsut), &cb);
        if (fRet == FALSE)
            continue;

        if (wsut.UserToken != NULL)
        {
            if (IsUserAnAdmin(wsut.UserToken))
                break;
                
            CloseHandle(wsut.UserToken);
            wsut.UserToken = NULL;
        }
    }

    if (i < cSesn)
    {
        fRet = TRUE;
        *pdwSession = rgSesn[i].SessionId;
        *phToken    = wsut.UserToken;
    }
    else
    {
        fRet = FALSE;
    }
    
done:
    dw = GetLastError();
    if (rgSesn != NULL)
        WinStationFreeMemory(rgSesn);
    SetLastError(dw);
    
    return fRet;
}

// ***************************************************************************
BOOL GetInteractiveUsersToken(HANDLE *phTokenUser)
{
    HWINSTA hwinsta = NULL;
    DWORD   cbNeed;
    BOOL    fRet = FALSE;
    PSID    psid = NULL;
    HRESULT hr = NOERROR;

    USE_TRACING("GetInteractiveUsersToken");

    VALIDATEPARM(hr, (phTokenUser == NULL));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    *phTokenUser = NULL;

    hwinsta = OpenWindowStationW(L"WinSta0", FALSE, MAXIMUM_ALLOWED);
    if (hwinsta == NULL)
        goto done;

    // if this function returns 0 for cbNeed, there is no one logged in.  Also, 
    //  it should never return TRUE with these parameters.  If it does,
    //  something's wrong... 
    fRet = GetUserObjectInformationW(hwinsta, UOI_USER_SID, NULL, 0, &cbNeed);
    if (fRet || cbNeed == 0)
    {
        fRet = FALSE;
        goto done;
    }

    *phTokenUser = GetCurrentUserTokenW(L"WinSta0", TOKEN_ALL_ACCESS);
    fRet = (*phTokenUser != NULL);
 
done:
    if (hwinsta != NULL)
        CloseWindowStation(hwinsta);
    
    return fRet;
}

// ***************************************************************************
BOOL ValidateUserAccessToProcess(HANDLE hPipe, HANDLE hProcRemote)
{
    PSECURITY_DESCRIPTOR    psd = NULL;
    GENERIC_MAPPING         gm;
    HRESULT                 hr = NOERROR;
    PRIVILEGE_SET           *pPS;
    ACCESS_MASK             amReq;
    HANDLE                  hTokenImp = NULL;
    DWORD                   dwErr = 0, cbPS, dwGranted;
    PACL                    pDACL = NULL;
    PACL                    pSACL = NULL;
    PSID                    psidOwner = NULL;
    PSID                    psidGroup = NULL;
    BYTE                    rgBuf[sizeof(PRIVILEGE_SET) + 3 * sizeof(LUID_AND_ATTRIBUTES)];
    BOOL                    fRet = FALSE, fStatus = FALSE;

    USE_TRACING("ValidateUserAccessToProcess");

    VALIDATEPARM(hr, (hPipe == NULL || hProcRemote == NULL));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    ZeroMemory(&gm, sizeof(gm));
    gm.GenericAll     = GENERIC_ALL;
    gm.GenericExecute = GENERIC_EXECUTE;
    gm.GenericRead    = GENERIC_READ;
    gm.GenericWrite   = GENERIC_WRITE;
    pPS               = (PRIVILEGE_SET *)rgBuf;
    cbPS              = sizeof(rgBuf);
        
    // get the SD for the remote process
    dwErr = GetSecurityInfo(hProcRemote, SE_KERNEL_OBJECT, 
                            DACL_SECURITY_INFORMATION | 
                            GROUP_SECURITY_INFORMATION |
                            OWNER_SECURITY_INFORMATION |
                            SACL_SECURITY_INFORMATION, &psidOwner, &psidGroup,
                            &pDACL, &pSACL, &psd);
    if (dwErr != ERROR_SUCCESS)
    {
        DBG_MSG("Failed to get security info");
        SetLastError(dwErr);
        goto done;
    }

    // get the client's token
    fRet = ImpersonateNamedPipeClient(hPipe);
    if (fRet == FALSE)
    {
        DBG_MSG("Impersonate pipe failed");
        goto done;
    }

    fRet = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hTokenImp);

    // don't need to be the other user anymore, so go back to being LocalSystem
    RevertToSelf();
    
    if (fRet == FALSE)
    {
        DBG_MSG("OpenThreadToken failed");
        goto done;
    }
    
    amReq = PROCESS_QUERY_INFORMATION | PROCESS_VM_READ;
    fRet = AccessCheck(psd, hTokenImp, amReq, &gm, pPS, &cbPS, &dwGranted, 
                       &fStatus);
    if (fRet == FALSE)
    {
        DBG_MSG("AccessCheck died");
        goto done;
    }

    if (fStatus == FALSE || (dwGranted & amReq) != amReq)
    {
        DBG_MSG("Bogus state");
        fRet = FALSE;
        SetLastError(ERROR_ACCESS_DENIED);
        goto done;
    }

    fRet = TRUE;    

done:
    if (hTokenImp != NULL)
        CloseHandle(hTokenImp);
    if (psd != NULL)
        LocalFree(psd);

    DBG_MSG(fRet ? "validated" : "NOT VALIDATED");
    return fRet;
}

//////////////////////////////////////////////////////////////////////////////
// remote execution functions

// ***************************************************************************
BOOL ProcessFaultRequest(HANDLE hPipe, PBYTE pBuf, DWORD *pcbBuf)
{
    SPCHExecServFaultRequest    *pesreq = (SPCHExecServFaultRequest *)pBuf;
    SPCHExecServFaultReply      esrep, *pesrep;
    OSVERSIONINFOEXW            osvi;
    SFaultRepManifest           frm;
    EFaultRepRetVal             frrv = frrvErrNoDW;
    HMODULE                     hmodFR = NULL;
    LPWSTR                      wszTempDir = NULL, wszDumpFileName = NULL;
    HANDLE                      hprocRemote = NULL;
    HANDLE                      hTokenUser = NULL;
    LPVOID                      pvEnv = NULL;
    WCHAR                       *pwszDump = NULL;
    WCHAR                       wszTemp[MAX_PATH];
    DWORD                       cb, dw, dwSessionId;
    WCHAR                       wch = L'\0', *pwch, *pwszFile;
    BOOL                        fRet = FALSE, fUseManifest = FALSE;
    BOOL                        fQueue = FALSE, fTS = FALSE;
    HRESULT                     hr = NOERROR;

    USE_TRACING("ProcessFaultRequest");

    ZeroMemory(&esrep, sizeof(esrep));
    ZeroMemory(&frm, sizeof(frm));

    pwszDump = &wch;

    SetLastError(ERROR_INVALID_PARAMETER);
    esrep.cb   = sizeof(esrep);
    esrep.ess  = essErr;

    // validate parameters
    VALIDATEPARM(hr, (pesreq->cbTotal > *pcbBuf || 
        pesreq->cbTotal < sizeof(SPCHExecServFaultRequest) || 
        pesreq->cbESR != sizeof(SPCHExecServFaultRequest) ||
        pesreq->thidFault == 0 ||
        pesreq->wszExe == 0 || 
        pesreq->wszExe >= *pcbBuf));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // check and make sure that there is a NULL terminator between the 
    //  start of the string & the end of the buffer
    pwszFile = (LPWSTR)(pBuf + *pcbBuf);
    frm.wszExe = (LPWSTR)(pBuf + (DWORD)pesreq->wszExe);
    for (pwch = frm.wszExe; pwch < pwszFile && *pwch != L'\0'; pwch++);
    VALIDATEPARM(hr, (pwch >= pwszFile));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // need the filename for comparison later...
    for (pwszFile = pwch; 
         pwszFile > frm.wszExe && *pwszFile != L'\\'; 
         pwszFile--);
    if (*pwszFile == L'\\')
        pwszFile++;

    frm.pidReqProcess = pesreq->pidReqProcess;
    frm.pvFaultAddr   = pesreq->pvFaultAddr;
    frm.thidFault     = pesreq->thidFault;
    frm.fIs64bit      = pesreq->fIs64bit;
    frm.pEP           = pesreq->pEP;

    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize  = sizeof(osvi);

    GetVersionExW((LPOSVERSIONINFOW)&osvi);
    if ((osvi.wSuiteMask & (VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS)) != 0)
        fTS = TRUE;

    // if it's one of these processes, then we need to ALWAYS go queued.
    if (_wcsicmp(pwszFile, L"lsass.exe") == 0 ||
        _wcsicmp(pwszFile, L"winlogon.exe") == 0 ||
        _wcsicmp(pwszFile, L"csrss.exe") == 0 ||
        _wcsicmp(pwszFile, L"smss.exe") == 0)
    {
        fQueue       = TRUE;
        fUseManifest = FALSE;
    }

    if (fQueue == FALSE)
    {
        // need the session id for the process
        fRet = ProcessIdToSessionId(pesreq->pidReqProcess, &dwSessionId);

        if (fTS && fRet)
        {
            WINSTATIONINFORMATIONW  wsi;         
            WINSTATIONUSERTOKEN     wsut;
        
            ZeroMemory(&wsi, sizeof(wsi));
            fRet = WinStationQueryInformationW(SERVERNAME_CURRENT, 
                                               dwSessionId,
                                               WinStationInformation,
                                               &wsi, sizeof(wsi), &cb);
            if (fRet == FALSE)
            {
                DBG_MSG("WinStaQI failed");
                goto doneTSTokenFetch;
            }

            // so the session isn't active.  Determine what our session is cuz
            //  if the faulting process and the ERSvc are in the same session,
            //  then our session is obviously not active either.  So it's not
            //  useful to obtain the user token for it.
            if (wsi.ConnectState != State_Active)
            {
                DBG_MSG("TS session not active");
                fRet = FALSE;
                goto doneTokenFetch;
            }

            // get the token of the user we want to pop up the display to.  
            //  If this fn returns FALSE, assume there is no one logged 
            //  into our session & just go to delayed fault reporting
            ZeroMemory(&wsut, sizeof(wsut));
            wsut.ProcessId = LongToHandle(GetCurrentProcessId());
            wsut.ThreadId  = LongToHandle(GetCurrentThreadId());
            fRet = WinStationQueryInformationW(SERVERNAME_CURRENT, 
                                               dwSessionId,
                                               WinStationUserToken, &wsut,
                                               sizeof(wsut), &cb);
            if (fRet == FALSE)
            {
                DBG_MSG("nobody logged in");
                goto doneTSTokenFetch;
            }

            hTokenUser = wsut.UserToken;
        }
        else
        {
            fRet = FALSE;
        }

doneTSTokenFetch:
        if (fRet == FALSE)
            fRet = GetInteractiveUsersToken(&hTokenUser);

        // if the above call succeeded, check if the user is an admin or not...
        //  If he is, we can just display DW directly.  Otherwise, we go into 
        //  delayed reporting mode.
        if (fRet && hTokenUser != NULL)
            fUseManifest = IsUserAnAdmin(hTokenUser);
    }


doneTokenFetch:
    // if we are going to go into manifest mode, then check to see if we really
    //  need to go into Q mode
    if (!fQueue)
    {
        EEnDis  eedReport;
        HKEY    hkey = NULL;
        
        // first check the policy key
        dw = RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRPCfgPolicy, 0, KEY_READ, 
                           &hkey);
        if (dw == ERROR_SUCCESS)
        {
            // ok, if that succeeded then check and see if the DoReport value
            //  is here...
            cb = sizeof(eedReport);
            dw = RegQueryValueExW(hkey, c_wszRVDoReport, 0, NULL, 
                                  (LPBYTE)&eedReport, &cb);
            if (dw == ERROR_SUCCESS)
            {
                cb = sizeof(fQueue);
                dw = RegQueryValueExW(hkey, c_wszRVForceQueue, 0, NULL, 
                                      (LPBYTE)&fQueue, &cb);

                // if it's not a valid value, then pretend we got an error
                if (dw == ERROR_SUCCESS && fQueue != TRUE && fQueue != FALSE)
                    dw = ERROR_INVALID_PARAMETER;
            }
            else
            {
                RegCloseKey(hkey);
                hkey = NULL;                
            }
            DBG_MSG(fQueue ? "Q=1 in cpl" : "Q = 0 in policy");
        }

        // if we didn't find a policy key or we were not able to read the 
        //  'DoReport' value from it, then try the CPL key
        if (dw != ERROR_SUCCESS && hkey == NULL)
        {
            dw = RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRPCfg, 0, KEY_READ, 
                               &hkey);
            if (dw == ERROR_SUCCESS)
            {
                cb = sizeof(eedReport);
                dw = RegQueryValueExW(hkey, c_wszRVDoReport, 0, NULL, 
                                      (LPBYTE)&eedReport, &cb);
                if (dw == ERROR_SUCCESS /*&& eedReport != eedDisabled*/)
                {
                    cb = sizeof(fQueue);
                    dw = RegQueryValueExW(hkey, c_wszRVForceQueue, 0, NULL, 
                                          (LPBYTE)&fQueue, &cb);

                    // if it's not a valid value, then pretend we got an error
                    if (dw == ERROR_SUCCESS && fQueue != TRUE && 
                        fQueue != FALSE)
                        dw = ERROR_INVALID_PARAMETER;
                }
            }
            DBG_MSG(fQueue ? "Q=1 in cpl" : "Q = 0 in cpl");
        }


        // ok, if we still haven't got an ERROR_SUCCESS value back, then 
        //  determine what the default should be.
        if (dw != ERROR_SUCCESS)
            fQueue = (osvi.wProductType == VER_NT_SERVER);

        if (hkey != NULL)
            RegCloseKey(hkey);

        if (fQueue)
            fUseManifest = FALSE;
        
    }

    DBG_MSG(fQueue ? "Q=1" : "Q = 0");
    // ok, so if we're not in forced queue mode & we're not in manifest mode
    //  then go hunt and see if any other session on the machine has an admin
    //  logged into it.
    if (fQueue == FALSE && fUseManifest == FALSE && fTS)
    {
        if (hTokenUser != NULL)
        {
            CloseHandle(hTokenUser);
            hTokenUser = NULL;
        }
        
        fUseManifest = FindAdminSession(&dwSessionId, &hTokenUser);
    }

    hmodFR = LoadERDll();
    if (hmodFR == NULL)
    {
        DBG_MSG("LoadERDll failed");
        goto done;
    }

    // need a handle to the process to verify that the user has access to it.
    hprocRemote = OpenProcess(PROCESS_DUP_HANDLE | 
                              PROCESS_QUERY_INFORMATION | 
                              PROCESS_VM_READ | 
                              READ_CONTROL |
                              ACCESS_SYSTEM_SECURITY,
                              FALSE, pesreq->pidReqProcess);
    if (hprocRemote == NULL)
    {
        DBG_MSG("OpenProc failed");
        goto done;
    }

    fRet = ValidateUserAccessToProcess(hPipe, hprocRemote);
    if (fRet == FALSE)
    {
        DBG_MSG("not validated");
        goto done;
    }

    if (fUseManifest)
    {   
        PROCESS_INFORMATION pi;
        pfn_REPORTFAULTDWM  pfn;
        DWORD               cch;

        DBG_MSG("manifest");

        ZeroMemory(&pi, sizeof(pi));

        pfn = (pfn_REPORTFAULTDWM)GetProcAddress(hmodFR, "ReportFaultDWM");
        if (pfn == NULL)
        {
            DBG_MSG("getProcAddr died");
            goto done;
        }

        // need to figure out the temp path for the logged on user...
        wszTemp[0] = L'\0';
        fRet = ExpandEnvironmentStringsForUserW(hTokenUser, L"%TMP%", 
                                                wszTemp, sizeofSTRW(wszTemp));
        if (fRet == FALSE || wszTemp[0] == L'\0')
        {
            fRet = ExpandEnvironmentStringsForUserW(hTokenUser, L"%TEMP%", 
                                                    wszTemp, sizeofSTRW(wszTemp));
            if (fRet == FALSE || wszTemp[0] == L'\0')
            {
                fRet = ExpandEnvironmentStringsForUserW(hTokenUser, L"%USERPROFILE%", 
                                                        wszTemp, sizeofSTRW(wszTemp));
                if (fRet == FALSE || wszTemp[0] == L'\0')
                    GetTempPathW(sizeofSTRW(wszTemp), wszTemp);
            }
        }

        // determine what the name of the dump file will be
        cch = wcslen(pwszFile) + sizeofSTRW(c_wszDumpSuffix) + 1;

        __try { wszDumpFileName = (WCHAR *)_alloca(cch * sizeof(WCHAR)); }
        __except(EXCEPTION_STACK_OVERFLOW) { wszDumpFileName = NULL; }
        if (wszDumpFileName == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }
        
        wcscpy(wszDumpFileName, pwszFile);
        wcscat(wszDumpFileName, c_wszDumpSuffix);

        // get a dir where we'll put all our temp files
        if (CreateTempDirAndFile(wszTemp, NULL, &wszTempDir) == 0)
            goto done;


        // need an environment block for the target user to properly launch DW
        if (CreateEnvironmentBlock(&pvEnv, hTokenUser, FALSE) == FALSE)
            pvEnv = NULL;

        // do the real work.
        frrv = (*pfn)(&frm, wszTempDir, hTokenUser, pvEnv, &pi, 
                          wszDumpFileName);

        // if we don't get this error code back, then we didn't launch the 
        //  process, or it died for some reason. Now we will try to queue it
        if (frrv != frrvOk)
        {
            fUseManifest = FALSE;
            goto try_queue;
        }

        // we only need to duplicate the hProcess back to the requesting process
        //  cuz it doesn't use any of the other values in the PROCESSINFORMATION 
        //  structure.
        if (pi.hThread != NULL)
            CloseHandle(pi.hThread);

        if (hprocRemote != NULL)
        {
            fRet = DuplicateHandle(GetCurrentProcess(), pi.hProcess,  
                                   hprocRemote, &esrep.hProcess, 0, FALSE, 
                                   DUPLICATE_SAME_ACCESS);
            if (fRet == FALSE)
                esrep.hProcess = NULL;
        }

        if (pi.hProcess != NULL)
            CloseHandle(pi.hProcess);
        
        esrep.ess = essOk;
    }
    // since the user is NOT an admin, we have to queue it for later viewing
    //  the next time an admin logs on
    else
    {
        pfn_REPORTFAULTTOQ pfn;
try_queue:
        DBG_MSG("queue mode");

        pfn = (pfn_REPORTFAULTTOQ)GetProcAddress(hmodFR, "ReportFaultToQueue");
        if (pfn == NULL)
        {
            DBG_MSG("GetProcAddr died");
            goto done;
        }

        if (CreateQueueDir() == FALSE)
        {
            DBG_MSG("CreateQdir died");
            goto done;
        }

        frrv = (*pfn)(&frm);

        // want to be local system again...
        dw = GetLastError();
        RevertToSelf();
        SetLastError(dw);
        
        if (frrv != frrvOk)
            goto done;

        esrep.ess = essOkQueued;
    }

    SetLastError(0);
    fRet = TRUE;

done:
    esrep.dwErr = GetLastError();

    // build the reply packet with the handle valid in the context
    //  of the requesting process
    pesrep = (SPCHExecServFaultReply *)pBuf;
    RtlCopyMemory(pesrep, &esrep, sizeof(esrep));
    *pcbBuf = sizeof(esrep) + sizeof(esrep) % sizeof(WCHAR);
    
    if (fUseManifest)
    {
        pBuf += *pcbBuf;

        if (wszTempDir != NULL)
        {
            cb = (wcslen(wszTempDir) + 1) * sizeof(WCHAR);
            RtlCopyMemory(pBuf, wszTempDir, cb);
        }
        else
        {
            cb = sizeof(WCHAR);
            *pBuf = L'\0';
        }
        *pcbBuf += cb;
        pesrep->wszDir = (UINT64)pBuf - (UINT64)pesrep;

        pBuf += cb;
        if (wszDumpFileName != NULL)
        {
            cb = (wcslen(wszDumpFileName) + 1) * sizeof(WCHAR);
            RtlCopyMemory(pBuf, wszDumpFileName, cb);
        }
        else
        {
            cb = sizeof(WCHAR);
            *pBuf = L'\0';
        }
        
        *pcbBuf += cb;
        pesrep->wszDumpName = (UINT64)pBuf - (UINT64)pesrep;
    }

    if (wszTempDir != NULL)
        MyFree(wszTempDir);
    if (pvEnv != NULL)
        DestroyEnvironmentBlock(pvEnv);
    if (hprocRemote != NULL)
        CloseHandle(hprocRemote);
    if (hTokenUser != NULL)
        CloseHandle(hTokenUser);
    if (hmodFR != NULL)
        FreeLibrary(hmodFR);

    return fRet;
}


// ***************************************************************************
// Note that the pipe that this thread services is secured such that only 
//  local system has access to it.  Thus, we do not need to impersonate the 
//  pipe client in it.
BOOL ProcessHangRequest(HANDLE hPipe, PBYTE pBuf, DWORD *pcbBuf)
{
    SPCHExecServHangRequest *pesreq = (SPCHExecServHangRequest *)pBuf;
    SPCHExecServHangReply   esrep;
    PROCESS_INFORMATION     pi;
    WINSTATIONUSERTOKEN     wsut;
    OSVERSIONINFOEXW        osvi;
    STARTUPINFOW            si;
    HANDLE                  hprocRemote = NULL, hTokenUser = NULL;
    LPVOID                  pvEnv = NULL;
    LPWSTR                  wszEventName;
    DWORD                   cbWrote, dwErr, cch, cchNeed;
    WCHAR                   wszSysDir[MAX_PATH], *pwszSysDir = NULL;
    WCHAR                   *pwszCmdLine = NULL, *pwszEnd = NULL;
    WCHAR                   *pwch;
    BOOL                    fRet = FALSE;
    HRESULT                 hr;

    USE_TRACING("ProcessHangRequest");

    ZeroMemory(&pi, sizeof(pi));
    ZeroMemory(&wsut, sizeof(wsut));
    
    ZeroMemory(&esrep, sizeof(esrep));
    SetLastError(ERROR_INVALID_PARAMETER);
    esrep.cb   = sizeof(esrep);
    esrep.ess  = essErr;

    // validate parameters
    VALIDATEPARM(hr, (*pcbBuf < sizeof(SPCHExecServHangRequest) || 
        pesreq->cbESR != sizeof(SPCHExecServHangRequest) ||
        pesreq->wszEventName == 0 ||
        pesreq->wszEventName >= *pcbBuf ||
        pesreq->dwpidHung == 0 ||
        pesreq->dwtidHung == 0));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // check and make sure that there is a NULL terminator between the 
    //  start of the string & the end of the buffer
    pwszEnd = (LPWSTR)(pBuf + *pcbBuf);
    wszEventName = (LPWSTR)(pBuf + (DWORD)pesreq->wszEventName);
    for (pwch = wszEventName; pwch < pwszEnd && *pwch != L'\0'; pwch++);
    if (pwch >= pwszEnd)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DBG_MSG("Bad event name");
        goto done;
    }

    // Get the handle to remote process
    hprocRemote = OpenProcess(PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION,
                              FALSE, pesreq->pidReqProcess);
    if (hprocRemote == NULL)
    {
        DBG_MSG("Can't get handle to process");
        goto done;
    }

    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize  = sizeof(osvi);

    GetVersionExW((LPOSVERSIONINFOW)&osvi);
    if ((osvi.wSuiteMask &  (VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS)) != 0)
    {
        WINSTATIONINFORMATIONW  wsi;         
        DWORD                   cb;
    
        ZeroMemory(&wsi, sizeof(wsi));
        fRet = WinStationQueryInformationW(SERVERNAME_CURRENT, 
                                           pesreq->ulSessionId,
                                           WinStationInformation,
                                           &wsi, sizeof(wsi), &cb);
        if (fRet == FALSE)
        {
            DBG_MSG("WinStationQI failed");
            goto doneTSTokenFetch;
        }

        // if the session where the hang was terminated isn't active (which
        //  would be an odd state to be in- perhaps it is closing down?) 
        //  then just bail cuz we don't want to put up UI in it
        if (wsi.ConnectState != State_Active)
        {
            DBG_MSG("No Active Session found!");
            SetLastError(0);
            goto done;
        }
         
        // fetch the token associated with the sessions user
	    wsut.ProcessId = LongToHandle(GetCurrentProcessId());
	    wsut.ThreadId  = LongToHandle(GetCurrentThreadId());
        fRet = WinStationQueryInformationW(SERVERNAME_CURRENT, 
                                           pesreq->ulSessionId,
                                           WinStationUserToken, &wsut, 
                                           sizeof(wsut), &cbWrote);

        if (fRet)
        {
            if (wsut.UserToken != NULL)
                hTokenUser = wsut.UserToken;
            else
            {
                DBG_MSG("no token found");
                fRet = FALSE;
            }
        }
    }
    else
    {
        DBG_MSG("WTS not found");
        fRet = FALSE;
    }

doneTSTokenFetch:
    if (fRet == FALSE)
    {
        DWORD   dwERSvcSession = (DWORD)-1;

        // make sure the hung app is in our session before using this API and
        //  if it's not, just bail.
        fRet = ProcessIdToSessionId(GetCurrentProcessId(), &dwERSvcSession);
        if (fRet == FALSE)
        {
            DBG_MSG("Failed in ProcessIdToSessionId");
            goto done;
        }
        if (dwERSvcSession != pesreq->ulSessionId)
        {
            DBG_MSG("Session IDs do not match");
            goto done;
        }

        fRet = GetInteractiveUsersToken(&hTokenUser);
        if (fRet == FALSE)
        {
            DBG_MSG("Failure in GetInteractiveUsersToken");
            goto done;
        }
    }

    // create the default environment for the user token- note that we 
    //  have to set the CREATE_UNICODE_ENVIRONMENT flag...
    fRet = CreateEnvironmentBlock(&pvEnv, hTokenUser, FALSE);
    if (fRet == FALSE)
        pvEnv = NULL;

    // note that we do not allow inheritance of handles cuz they would be 
    //  inherited from this process and not the real parent, making it sorta
    //  pointless.
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
#ifdef _WIN64
    if (pesreq->fIs64bit == FALSE)
        cch = GetSystemWow64DirectoryW(wszSysDir, sizeofSTRW(wszSysDir));
    else
#endif
        cch = GetSystemDirectoryW(wszSysDir, sizeofSTRW(wszSysDir));
    if (cch == 0)
        goto done;

    cchNeed = cch + sizeofSTRW(c_wszQSubdir) + 2;
    if (cchNeed > sizeofSTRW(wszSysDir))
    {
        __try { pwszSysDir = (WCHAR *)_alloca(cchNeed * sizeof(WCHAR)); }
        __except(EXCEPTION_STACK_OVERFLOW) { pwszSysDir = NULL; }
        if (pwszSysDir == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }

        if (cch > sizeofSTRW(wszSysDir))
        {
#ifdef _WIN64
            if (pesreq->fIs64bit == FALSE)
                cch = GetSystemWow64DirectoryW(pwszSysDir, cchNeed);
            else
#endif
                cch = GetSystemDirectoryW(pwszSysDir, cchNeed);
        }
        else
        {
            wcscpy(pwszSysDir, wszSysDir);
        }
    }
    else
    {
        pwszSysDir = wszSysDir;
    }

    // if the length of the system directory is 3, then %windir% is in the form
    //  of X:\, so clip off the backslash so we don't have to special case
    //  it below...
    if (cch == 3)
        *(pwszSysDir + 2) = L'\0';

    // compute the size of the buffer to hold the command line.  14 is for
    //  the max # of characters in a DWORD
    cchNeed = 12 + cch + wcslen((LPWSTR)wszEventName) + 
              sizeofSTRW(c_wszDWMCmdLine64); 

    __try { pwszCmdLine = (WCHAR *)_alloca(cchNeed * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { pwszCmdLine = NULL; }
    if (pwszCmdLine == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

#ifdef _WIN64    
    swprintf(pwszCmdLine, c_wszDWMCmdLine64, pwszSysDir, pesreq->dwpidHung, 
             ((pesreq->fIs64bit) ? L'6' : L' '), pesreq->dwtidHung, 
             wszEventName);
             
#else
    swprintf(pwszCmdLine, c_wszDWMCmdLine32, pwszSysDir, pesreq->dwpidHung, 
             pesreq->dwtidHung, wszEventName);
#endif

    TESTBOOL(hr, CreateProcessAsUserW(hTokenUser, NULL, pwszCmdLine, NULL, NULL,
                                FALSE, CREATE_DEFAULT_ERROR_MODE |
                                CREATE_UNICODE_ENVIRONMENT |
                                NORMAL_PRIORITY_CLASS, pvEnv, pwszSysDir, 
                                &si, &pi));
    if (FAILED(hr))
    {
        DBG_MSG("CreateProcessAsUser failed");
        fRet = FALSE;
        goto done;
    }

    // duplicate the process & thread handles back into the remote process
    fRet = DuplicateHandle(GetCurrentProcess(), pi.hProcess, hprocRemote,
                           &esrep.hProcess, 0, FALSE, DUPLICATE_SAME_ACCESS);
    if (fRet == FALSE)
        esrep.hProcess = NULL;

    // get rid of any errors we might have encountered
    SetLastError(0);
    fRet = TRUE;

    esrep.ess = essOk;

done:
    esrep.dwErr = GetLastError();

    // build the reply packet with the handle valid in the context
    //  of the requesting process
    RtlCopyMemory(pBuf, &esrep, sizeof(esrep));
    *pcbBuf = sizeof(esrep);

    // close our versions of the handles. The requestors references
    //  are now the main ones
    if (hTokenUser != NULL)
        CloseHandle(hTokenUser);
    if (pvEnv != NULL)
        DestroyEnvironmentBlock(pvEnv);
    if (pi.hProcess != NULL)
        CloseHandle(pi.hProcess);
    if (pi.hThread != NULL)
        CloseHandle(pi.hThread);
    if (hprocRemote != NULL)
        CloseHandle(hprocRemote);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\faultrep\frhang.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    frhang.cpp

Abstract:
    Implements hang reporting

Revision History:
    created     derekm      07/07/00

******************************************************************************/

#include "stdafx.h"
#include "dbghelp.h"


///////////////////////////////////////////////////////////////////////////////
// exported functions

// **************************************************************************
EFaultRepRetVal APIENTRY ReportHang(DWORD dwpid, DWORD dwtid, BOOL f64bit,
                                     HANDLE hNotify)
{
    USE_TRACING("ReportHang");

    EXCEPTION_POINTERS  ep;
    CPFFaultClientCfg   oCfg;
    EXCEPTION_RECORD    er;
    EFaultRepRetVal     frrvRet = frrvErrNoDW;
    SDWManifestBlob     dwmb;
    SSuspendThreads     st;
    SMDumpOptions       smdo;
    CONTEXT             cxt;
    HRESULT             hr = NOERROR;
    HANDLE              hProc = NULL, hth = NULL;
    LPWSTR              wszStage1, wszStage2, wszCorpPath, wszHdr;
    LPWSTR              wszFiles = NULL, wszDir = NULL, wszManifest = NULL;
    LPWSTR              pwszAppCompat = NULL;
    WCHAR               wszExe[MAX_PATH], wszAppName[MAX_PATH];
    WCHAR               wszAppVer[MAX_PATH];
    WCHAR               *pwszApp, *pwsz;
    WCHAR               wszBuffer[512];
    DWORD               dw, cch, cchDir, cchSep;
    BOOL                fMSApp = FALSE, fThreadsHeld = FALSE;
    BYTE                *pbBuf = NULL;

    ZeroMemory(&st, sizeof(st));

    VALIDATEPARM(hr, (dwpid == 0 || dwtid == 0));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    TESTHR(hr, oCfg.Read(eroPolicyRO));
    if (FAILED(hr))
        goto done;

    if (oCfg.get_TextLog() == eedEnabled)
    {
        HANDLE  hFaultLog = INVALID_HANDLE_VALUE;

        // assume system is on a local drive with a base path of "X:\"
        GetSystemDirectoryW(wszBuffer, sizeofSTRW(wszBuffer));
        wszBuffer[3] = L'\0';
        wcscat(wszBuffer, c_wszLogFileName);
        hFaultLog = CreateFileW(wszBuffer, GENERIC_WRITE,
                                FILE_SHARE_WRITE | FILE_SHARE_READ,
                                NULL, OPEN_ALWAYS, 0, NULL);
        if (hFaultLog != INVALID_HANDLE_VALUE)
        {
            SYSTEMTIME  sst;
            DWORD       cb, cbWritten;
            char        szMsg[512];

            GetSystemTime(&sst);
            GetModuleFileNameW(NULL, wszExe, sizeofSTRW(wszExe));
            cb = wsprintf(szMsg,
                         "%02d-%02d-%04d %02d:%02d:%02d Hang fault for %ls\r\n",
                          sst.wDay, sst.wMonth, sst.wYear, sst.wHour, sst.wMinute,
                          sst.wSecond, wszExe);
            SetFilePointer(hFaultLog, 0, NULL, FILE_END);
            WriteFile(hFaultLog, szMsg, cb, &cbWritten, NULL);
            CloseHandle(hFaultLog);
        }

        wszBuffer[0] = L'\0';
    }

    // see if we're disabled.  We do not allow notify only mode.  It's really
    //  pointless to do so, given that the user explicitly wanted the app
    //  terminated and the 'Do you really want to kill this app' dialog that
    //  had to have popped up told him we thot it was hung.
    if (oCfg.get_DoReport() == eedDisabled)
    {
        DBG_MSG("DoReport disabled");
        goto done;
    }

    if (oCfg.get_ShowUI() == eedDisabled)
    {
        LPCWSTR wszULPath = oCfg.get_DumpPath(NULL, 0);

        // check and make sure that we have a corporate path specified.  If we
        //  don't, bail
        if (wszULPath == NULL || *wszULPath == L'\0')
        {
            DBG_MSG("ShowUI disabled and no CER path");
            goto done;
        }
    }

    // find out what the exe path is
    hProc = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE,
                        dwpid);
    if (hProc == NULL)
    {
        if (ERROR_ACCESS_DENIED == GetLastError())
        {
            DBG_MSG("Could not open process: ACCESS_DENIED");
        }
        else
            DBG_MSG("Could not open process");
        goto done;
    }

    TESTHR(hr, GetExePath(hProc, wszExe, sizeofSTRW(wszExe)));
    if (FAILED(hr))
        goto done;

    // check to see if the hung thread is DW or other part of our reporting chain
    // if so, no point in reporting it...
    for(pwsz = wszExe + wcslen(wszExe);
        pwsz >= wszExe && *pwsz != L'\\';
        pwsz--);
    if (*pwsz == L'\\')
        pwsz++;
    if (_wcsicmp(pwsz, L"dwwin.exe") == 0 ||
        _wcsicmp(pwsz, L"dumprep.exe") == 0)
    {
        DBG_MSG("We are hung- BAIL OUT!!");
        goto done;
    }

    if (FreezeAllThreads(dwpid, 0, &st) == FALSE)
    {
        DBG_MSG("Could not freeze all threads");
        goto done;
    }
    fThreadsHeld = TRUE;

    // if we can't collect info on this puppy, then we'd just be notifying & I
    //  went over that case above.
    if (oCfg.ShouldCollect(wszExe, &fMSApp) == FALSE)
        goto done;

    if (CreateTempDirAndFile(NULL, NULL, &wszDir) == 0)
        goto done;

    for (pwszApp = wszExe + wcslen(wszExe);
         *pwszApp != L'\\' && pwszApp > wszExe;
         pwszApp--);
    if (*pwszApp == L'\\')
        pwszApp++;

    cchDir = wcslen(wszDir);
    cch = cchDir + sizeofSTRW(c_wszManFileName) + 4;
    __try { wszManifest = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszManifest = NULL; }
    if (wszManifest == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    wcscpy(wszManifest, wszDir);
    wszManifest[cchDir]     = L'\\';
    wszManifest[cchDir + 1] = L'\0';
    wcscat(wszManifest, c_wszManFileName);

    cchDir = wcslen(wszDir);
    cch = 2 * cchDir + wcslen(pwszApp) + sizeofSTRW(c_wszACFileName) +
          sizeofSTRW(c_wszDumpSuffix) + 4;
    __try { wszFiles = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszFiles = NULL; }
    if (wszFiles == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    wcscpy(wszFiles, wszDir);
    wszFiles[cchDir]     = L'\\';
    wszFiles[cchDir + 1] = L'\0';
    wcscat(wszFiles, pwszApp);
    wcscat(wszFiles, c_wszDumpSuffix);

    // build a exception context...
    hth = OpenThread(THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE,
                     dwtid);
    if (hth == NULL)
        goto done;

    ZeroMemory(&cxt, sizeof(cxt));
    cxt.ContextFlags = CONTEXT_CONTROL;
    TESTBOOL(hr, GetThreadContext(hth, &cxt));
    if (FAILED(hr))
        goto done;

    ZeroMemory(&er, sizeof(er));
    er.ExceptionCode    = 0xcfffffff;
#ifdef _X86_
    // this cast is ok to do cuz we know we're on an x86 machine
    er.ExceptionAddress = (PVOID)cxt.Eip;

#elif _IA64_
    // this cast is ok to do cuz we know we're on an ia64 machine
    er.ExceptionAddress = (PVOID)cxt.StIIP;
#endif

    ep.ExceptionRecord = &er;
    ep.ContextRecord   = &cxt;

    // generate the minidump
    ZeroMemory(&smdo, sizeof(smdo));
    smdo.cbSMDO = sizeof(smdo);
#ifdef MANIFEST_HEAP
    smdo.ulThread    = c_ulThreadWriteDefault;
    smdo.ulThreadEx  = c_ulThreadWriteDefault;
    smdo.ulMod       = c_ulModuleWriteDefault;
#else
    smdo.ulThread    = ThreadWriteThread | ThreadWriteContext | ThreadWriteStack;
    smdo.ulMod       = ModuleWriteModule | ModuleWriteMiscRecord | ModuleWriteDataSeg;
#endif
    smdo.dwThreadID  = dwtid;
    smdo.dfOptions   = dfCollectSig;
    smdo.pvFaultAddr = (UINT64)er.ExceptionAddress;
#if defined(_X86_) || defined(_IA64_)
    smdo.pEP         = (UINT64)&ep;
    smdo.fEPClient   = FALSE;
#endif
    smdo.wszModFullPath[0] = L'\0';
    wcscpy(smdo.wszAppFullPath, wszExe);
    wcscpy(smdo.wszMod, L"hungapp");
#ifdef MANIFEST_HEAP
    if (InternalGenFullAndTriageMinidumps(hProc, dwpid, wszFiles,
                                          NULL, &smdo, f64bit) == FALSE)
#else
    if (InternalGenerateMinidump(hProc, dwpid, wszFiles, &smdo) == FALSE)
#endif
        goto done;

    ThawAllThreads(&st);
    fThreadsHeld = FALSE;

    // if the app requested it, notify it of that we're done fetching the
    //  dump
    if (hNotify != NULL)
        SetEvent(hNotify);

    // log an event- don't care if it fails or not.
    TESTHR(hr, LogHang(smdo.wszApp, smdo.rgAppVer, smdo.wszMod, smdo.rgModVer,
                       smdo.pvOffset, f64bit));

    // generate all the URLs & file paths we'll need for reporting
    TESTHR(hr, BuildManifestURLs(smdo.wszApp, smdo.wszMod, smdo.rgAppVer,
                                 smdo.rgModVer, smdo.pvOffset,
                                 f64bit, &wszStage1, &wszStage2,
                                 &wszCorpPath, &pbBuf));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, GetVerName(smdo.wszAppFullPath, wszAppName,
                          sizeofSTRW(wszAppName)));
    if (FAILED(hr))
        goto done;

    wszAppName[sizeofSTRW(wszAppName) - 1] = L'\0';

    // we created the wszDump buffer above big enuf to hold both the
    //  dumpfile path as well as the app compat filename.  So make
    //  use of that right now.
    cchSep = wcslen(wszFiles);
    pwszAppCompat = wszFiles + cchSep + 1;
    wcscpy(pwszAppCompat, wszDir);
    pwszAppCompat[cchDir]     = L'\\';
    pwszAppCompat[cchDir + 1] = L'\0';
    wcscat(pwszAppCompat, c_wszACFileName);

    // if we succeed, turn the NULL following the dump file path into
    //  the DW separator character
    TESTBOOL(hr, GetAppCompatData(wszExe, smdo.wszModFullPath, pwszAppCompat));
    if (SUCCEEDED(hr))
        wszFiles[cchSep] = DW_FILESEP;

    // get the header text
    dw = LoadStringW(g_hInstance, IDS_HHDRTXT, wszBuffer,
                     sizeofSTRW(wszBuffer));
    if (dw == 0)
        goto done;

    cch = dw + wcslen(wszAppName) + 1;
    __try { wszHdr = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszHdr = NULL; }
    if (wszHdr == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    swprintf(wszHdr, wszBuffer, wszAppName);

    ZeroMemory(&dwmb, sizeof(dwmb));
    dwmb.wszTitle      = wszAppName;
    dwmb.wszHdr        = wszHdr;
    dwmb.nidErrMsg     = IDS_HERRMSG;
    dwmb.wszStage1     = wszStage1;
    dwmb.wszStage2     = wszStage2;
    dwmb.wszBrand      = c_wszDWBrand;
    dwmb.wszFileList   = wszFiles;
    dwmb.fIsMSApp      = fMSApp;
    dwmb.wszCorpPath   = wszCorpPath;
    dwmb.wszEventSrc   = c_wszHangEventSrc;

    // check and see if the system is shutting down.  If so, CreateProcess is
    //  gonna pop up some annoying UI that we can't get rid of, so we don't
    //  want to call it if we know it's gonna happen.
    if (GetSystemMetrics(SM_SHUTTINGDOWN))
        goto done;

    frrvRet = StartDWManifest(oCfg, dwmb, wszManifest);

done:
    // preserve the error code so that the following calls don't overwrite it
    dw = GetLastError();

    if (fThreadsHeld)
        ThawAllThreads(&st);

    if (hProc != NULL)
        CloseHandle(hProc);
    if (hth != NULL)
        CloseHandle(hth);
    if (wszFiles != NULL)
    {
        if (pwszAppCompat != NULL)
        {
            wszFiles[cchSep] = L'\0';
            DeleteFileW(pwszAppCompat);
        }
#ifdef MANIFEST_HEAP
        DeleteFullAndTriageMiniDumps(wszFiles);
#else
        DeleteFileW(wszFiles);
#endif
    }
    if (wszManifest != NULL)
        DeleteFileW(wszManifest);
    if (wszDir != NULL)
    {
        DeleteTempDirAndFile(wszDir, FALSE);
        MyFree(wszDir);
    }

    if (pbBuf != NULL)
        MyFree(pbBuf);

    SetLastError(dw);

    return frrvRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\faultrep\frkrnl.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    faultrep.cpp

Abstract:
    Implements kernel fault reporting

Revision History:
    created     derekm      07/07/00

******************************************************************************/

#include "stdafx.h"
#include "ntiodump.h"
#include "userenv.h"
#include <setupapi.h>


///////////////////////////////////////////////////////////////////////////////
// utilities

#define ARRAYSIZE(sz)   (sizeof(sz)/sizeof(sz[0]))

#define WRITE_CWSZ(hr, hFile, wsz, cb) \
    TESTBOOL(hr, WriteFile(hFile, wsz, sizeof(wsz) - sizeof(WCHAR), \
                           &(cb), NULL)); \
    if (FAILED(hr)) goto done; else 0

// **************************************************************************
#ifndef _WIN64
HRESULT ExtractBCInfo(LPCWSTR wszMiniDump, ULONG *pulBCCode, ULONG *pulBCP1, 
                      ULONG *pulBCP2, ULONG *pulBCP3, ULONG *pulBCP4)
#else
HRESULT ExtractBCInfo(LPCWSTR wszMiniDump, ULONG *pulBCCode, ULONG64 *pulBCP1, 
                      ULONG64 *pulBCP2, ULONG64 *pulBCP3, ULONG64 *pulBCP4)
#endif
{
    USE_TRACING("ExtractBCInfo");
    
#ifndef _WIN64
    DUMP_HEADER32   *pdmp = NULL;
#else
    DUMP_HEADER64   *pdmp = NULL;
#endif
    HRESULT         hr = NOERROR;
    DWORD           dw;

    VALIDATEPARM(hr, (wszMiniDump == NULL || pulBCCode == NULL || 
                      pulBCP1 == NULL || pulBCP2 == NULL || pulBCP3 == NULL || 
                      pulBCP4 == NULL));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    TESTHR(hr, OpenFileMapped((LPWSTR)wszMiniDump, (LPVOID *)&pdmp, &dw));
    if (FAILED(hr))
        goto done;

    // make sure the file is at least the appropriate # of bytes for a dump
    //  header.
    // Then make sure it's the appropriate type of minidump cuz the code below
    //  will only handle dumps for the platform it's compiled for (ia64 vs x86)
#ifndef _WIN64
    if (dw < sizeof(DUMP_HEADER32) || 
        pdmp->Signature != DUMP_SIGNATURE32 ||
        pdmp->ValidDump != DUMP_VALID_DUMP32 || 
#else
    if (dw < sizeof(DUMP_HEADER64) || 
        pdmp->Signature != DUMP_SIGNATURE64 ||
        pdmp->ValidDump != DUMP_VALID_DUMP64 ||
#endif
        pdmp->DumpType != DUMP_TYPE_TRIAGE)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        hr = Err2HR(ERROR_INVALID_PARAMETER);
        goto done;
    }

    *pulBCCode = pdmp->BugCheckCode;
    *pulBCP1   = pdmp->BugCheckParameter1;
    *pulBCP2   = pdmp->BugCheckParameter2;
    *pulBCP3   = pdmp->BugCheckParameter3;
    *pulBCP4   = pdmp->BugCheckParameter4;
    
done:
    dw = GetLastError();

    if (pdmp != NULL)
        UnmapViewOfFile(pdmp);

    SetLastError(dw);

    return hr;
}

// **************************************************************************
DWORD XMLEncodeString(LPCWSTR wszSrc, LPWSTR wszDest, DWORD cchDest)
{
    WCHAR   *pwch = (WCHAR *)wszSrc;
    WCHAR   *pwchDest = wszDest;
    DWORD   cch = 0, cchNeed = 0;

    // determine how much space we need & if the buffer supports it
    for(; *pwch != L'\0'; pwch++)
    {
        switch(*pwch)
        {
            case L'&':  cchNeed += 5; break;
            case L'>':  // fall thru
            case L'<':  cchNeed += 4; break;
            case L'\'': // fall thru
            case L'\"': cchNeed += 6; break;
            default:    cchNeed += 1;
        }
    }

    if (cchNeed >= cchDest || cchNeed == 0)
        return 0;

    // do the conversion
    for(pwch = (WCHAR *)wszSrc; *pwch != L'\0'; pwch++)
    {
        switch(*pwch)
        {
            case L'&':  wcscpy(pwchDest, L"&amp;");  pwchDest += 5; break;
            case L'>':  wcscpy(pwchDest, L"&gt;");   pwchDest += 4; break;
            case L'<':  wcscpy(pwchDest, L"&lt;");   pwchDest += 4; break;
            case L'\'': wcscpy(pwchDest, L"&apos;"); pwchDest += 6; break;
            case L'\"': wcscpy(pwchDest, L"&quot;"); pwchDest += 6; break;
            default:    *pwchDest = *pwch;           pwchDest += 1; break;
        }
    }

    *pwchDest = L'\0';

    return cchNeed;
}

// **************************************************************************
HRESULT GetDevicePropertyW(HDEVINFO hDevInfo,
                           PSP_DEVINFO_DATA pDevInfoData,
                           ULONG ulProperty,
                           ULONG ulRequiredType,
                           PBYTE pData,
                           ULONG ulDataSize)
{
    ULONG ulPropType;

    USE_TRACING("GetDeviceProperty");

    // The data returned is often string data so leave some
    // extra room for forced termination.
    if (SetupDiGetDeviceRegistryPropertyW(hDevInfo,
                                          pDevInfoData,
                                          ulProperty,
                                          &ulPropType,
                                          pData,
                                          ulDataSize - 2 * sizeof(WCHAR),
                                          &ulDataSize))
    {
        // Got the data, verify the type.
        if (ulPropType != ulRequiredType)
        {
            return E_INVALIDARG;
        }

        // Force a double terminator at the end to make sure
        // that all strings and multistrings are terminated.
        ZeroMemory(pData + ulDataSize, 2 * sizeof(WCHAR));
        return S_OK;
    }
    else
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
}

// **************************************************************************

struct DEVICE_DATA_STRINGS
{
    //
    // The device description and service names have fixed
    // maximum lengths.  The hardware ID data can be arbitrarily
    // large, however in practice it is rarely more than
    // a few hundred characters.  We just make
    // a single allocation with nice roomy buffers and
    // use that for every device rather than doing allocations
    // per device.
    //

    WCHAR wszDeviceDesc[LINE_LEN];
    WCHAR wszHardwareId[8192];
    WCHAR wszService[MAX_SERVICE_NAME_LEN];
    WCHAR wszServiceImage[MAX_PATH];
    // We only need the first string of the hardware ID multi-sz
    // so this translation temporary buffer doesn't need
    // to be as large as the whole multi-sz.
    WCHAR wszXml[1024];
};
    
HRESULT GetDeviceData(HANDLE hFile)
{
    HRESULT hr;
    HDEVINFO hDevInfo;
    DEVICE_DATA_STRINGS* pStrings = NULL;
    SC_HANDLE hSCManager = NULL;

    USE_TRACING("GetDeviceData");

    hDevInfo = SetupDiGetClassDevsW(NULL, NULL, NULL, DIGCF_ALLCLASSES);
    if (hDevInfo == INVALID_HANDLE_VALUE)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    pStrings = (DEVICE_DATA_STRINGS*)MyAlloc(sizeof(*pStrings));
    if (!pStrings)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    SP_DEVINFO_DATA DevInfoData;
    ULONG ulDevIndex;

    ulDevIndex = 0;
    DevInfoData.cbSize = sizeof(DevInfoData);
    while (SetupDiEnumDeviceInfo(hDevInfo, ulDevIndex, &DevInfoData))
    {
        ULONG cb;

        //
        // If we can't get a required property for this device
        // we skip the device and continue on and try to
        // get as much device data as possible.
        //

        if (GetDevicePropertyW(hDevInfo, &DevInfoData,
                               SPDRP_DEVICEDESC, REG_SZ,
                               (PBYTE)pStrings->wszDeviceDesc,
                               sizeof(pStrings->wszDeviceDesc)) == S_OK &&
            GetDevicePropertyW(hDevInfo, &DevInfoData,
                               SPDRP_HARDWAREID, REG_MULTI_SZ,
                               (PBYTE)pStrings->wszHardwareId,
                               sizeof(pStrings->wszHardwareId)) == S_OK)
        {
            PWSTR pwszStr;
            ULONG cbOut;

            // Default to no service image name.
            pStrings->wszServiceImage[0] = 0;
            
            // The Service property is optional.
            if (GetDevicePropertyW(hDevInfo, &DevInfoData,
                                   SPDRP_SERVICE, REG_SZ,
                                   (PBYTE)pStrings->wszService,
                                   sizeof(pStrings->wszService)) != S_OK)
            {
                pStrings->wszService[0] = 0;
            }
            else
            {
                SC_HANDLE hService;
                LPQUERY_SERVICE_CONFIGW lpqscBuf;
                DWORD dwBytes;
                
                //
                // If we found the service, open it, and retrieve the image
                // name so we can map to the drivers list in the XML.
                //

                if (hSCManager == NULL)
                {
                    hSCManager = OpenSCManagerW(NULL, NULL,
                                                SC_MANAGER_ENUMERATE_SERVICE);
                }
                
                if (hSCManager != NULL)
                {
                    hService = OpenServiceW(hSCManager, pStrings->wszService,
                                            SERVICE_QUERY_CONFIG);
                    if (hService != NULL)
                    {
#define SERVICE_CONFIG_QUERY_SIZE 8192
                        lpqscBuf = (LPQUERY_SERVICE_CONFIGW)
                            MyAlloc(SERVICE_CONFIG_QUERY_SIZE); 
                        if (lpqscBuf != NULL)
                        {
                            if (QueryServiceConfigW(hService, lpqscBuf,
                                                    SERVICE_CONFIG_QUERY_SIZE,
                                                    &dwBytes))
                            {
                                WCHAR *wcpBuf;
                                
                                //
                                // Remove the path information and just store
                                // the image name.
                                //
                                wcpBuf =
                                    wcsrchr(lpqscBuf->lpBinaryPathName, '\\');
                                if (wcpBuf)
                                {
                                    wcscpy(pStrings->wszServiceImage,
                                           wcpBuf + 1);
                                }
                                else
                                {
                                    wcscpy(pStrings->wszServiceImage,
                                           lpqscBuf->lpBinaryPathName);
                                }
                            }
                            
                            MyFree(lpqscBuf);
                        }

                        CloseServiceHandle(hService);
                    }
                }
            }
            
            WRITE_CWSZ(hr, hFile, c_wszXMLOpenDevice, cb);

            WRITE_CWSZ(hr, hFile, c_wszXMLOpenDevDesc, cb);
                
            cbOut = XMLEncodeString(pStrings->wszDeviceDesc,
                                    pStrings->wszXml,
                                    sizeofSTRW(pStrings->wszXml));
            cbOut *= sizeof(WCHAR);
            TESTBOOL(hr, WriteFile(hFile, pStrings->wszXml, cbOut, &cb, NULL));
            if (FAILED(hr))
            {
                goto done;
            }
            
            WRITE_CWSZ(hr, hFile, c_wszXMLCloseDevDesc, cb);

            //
            // The hardware ID is a multistring but we
            // only need the first string.
            //

            WRITE_CWSZ(hr, hFile, c_wszXMLOpenDevHwId, cb);

            cbOut = XMLEncodeString(pStrings->wszHardwareId,
                                    pStrings->wszXml,
                                    sizeofSTRW(pStrings->wszXml));
            cbOut *= sizeof(WCHAR);
            TESTBOOL(hr, WriteFile(hFile, pStrings->wszXml, cbOut, &cb, NULL));
            if (FAILED(hr))
            {
                goto done;
            }
            
            WRITE_CWSZ(hr, hFile, c_wszXMLCloseDevHwId, cb);

            if (pStrings->wszService[0])
            {
                WRITE_CWSZ(hr, hFile, c_wszXMLOpenDevService, cb);

                cbOut = XMLEncodeString(pStrings->wszService,
                                        pStrings->wszXml,
                                        sizeofSTRW(pStrings->wszXml));
                cbOut *= sizeof(WCHAR);
                TESTBOOL(hr, WriteFile(hFile, pStrings->wszXml, cbOut,
                                       &cb, NULL));
                if (FAILED(hr))
                {
                    goto done;
                }
            
                WRITE_CWSZ(hr, hFile, c_wszXMLCloseDevService, cb);
            }
            
            if (pStrings->wszServiceImage[0])
            {
                WRITE_CWSZ(hr, hFile, c_wszXMLOpenDevImage, cb);

                cbOut = XMLEncodeString(pStrings->wszServiceImage,
                                        pStrings->wszXml,
                                        sizeofSTRW(pStrings->wszXml));
                cbOut *= sizeof(WCHAR);
                TESTBOOL(hr, WriteFile(hFile, pStrings->wszXml, cbOut,
                                       &cb, NULL));
                if (FAILED(hr))
                {
                    goto done;
                }
            
                WRITE_CWSZ(hr, hFile, c_wszXMLCloseDevImage, cb);
            }
            
            WRITE_CWSZ(hr, hFile, c_wszXMLCloseDevice, cb);
        }
        
        ulDevIndex++;
    }

    hr = S_OK;
    
 done:
    SetupDiDestroyDeviceInfoList(hDevInfo);
    if (pStrings)
    {
        MyFree(pStrings);
    }
    if (hSCManager)
    {
        CloseServiceHandle(hSCManager);
    }
    return hr;
}
 
// **************************************************************************
HRESULT WriteDriverRecord(HANDLE hFile, LPWSTR wszFile)
{
    WIN32_FILE_ATTRIBUTE_DATA   w32fad;
    SYSTEMTIME                  st;
    HRESULT                     hr = NOERROR;
    LPWSTR                      pwszFileName;
    DWORD                       cb, cbOut;
    WCHAR                       wsz[1025], wszVer[MAX_PATH], wszCompany[MAX_PATH];
    WCHAR                       wszName[MAX_PATH];

    USE_TRACING("WriteDriverRecord");
    TESTBOOL(hr, GetFileAttributesExW(wszFile, GetFileExInfoStandard, 
                                      (LPVOID *)&w32fad));
    if (FAILED(hr))
        goto done;

    // <DRIVER>
    //     <FILENAME>...
    TESTBOOL(hr, WriteFile(hFile, c_wszXMLDriver1, 
                           sizeof(c_wszXMLDriver1) - sizeof(WCHAR), &cb, NULL));
    if (FAILED(hr))
        goto done;

    // ...[filename data]...
    for(pwszFileName = wszFile + wcslen(wszFile);
        *pwszFileName != L'\\' && pwszFileName > wszFile;
        pwszFileName--);
    if (*pwszFileName == L'\\')
        pwszFileName++;
    
    wsz[0] = L'\0';
    cbOut = XMLEncodeString(pwszFileName, wsz, sizeofSTRW(wsz));
    cbOut *= sizeof(WCHAR);
    TESTBOOL(hr, WriteFile(hFile, wsz, cbOut, &cb, NULL));
    if (FAILED(hr))
        goto done;

    //     ...</FILENAME>
    //     <FILESIZE>[file size data]</FILESIZE>
    //     <CREATIONDATE>MM-DD-YYYY HH:MM:SS</CREATIONDATE>
    //     <VERSION>...
    FileTimeToSystemTime(&w32fad.ftCreationTime, &st);
    cbOut = swprintf(wsz, c_wszXMLDriver2, w32fad.nFileSizeLow, st.wMonth, 
                     st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
    cbOut *= sizeof(WCHAR);
    TESTBOOL(hr, WriteFile(hFile, wsz, cbOut, &cb, NULL));
    if (FAILED(hr))
        goto done;

    wsz[0] = L'\0';
    TESTHR(hr, GetVerName(wszFile, wszName, sizeofSTRW(wszName), 
                          wszVer, sizeofSTRW(wszVer), 
                          wszCompany, sizeofSTRW(wszCompany), TRUE, TRUE));
    if (FAILED(hr))
        goto done;

    wszCompany[sizeofSTRW(wszCompany) - 1] = L'\0';
    wszName[sizeofSTRW(wszName) - 1]       = L'\0';
    wszVer[sizeofSTRW(wszVer) - 1]         = L'\0';


    // ...[version data]...
    wsz[0] = L'\0';
    cbOut = XMLEncodeString(wszVer, wsz, sizeofSTRW(wsz));
    cbOut *= sizeof(WCHAR);
    TESTBOOL(hr, WriteFile(hFile, wsz, cbOut, &cb, NULL));
    if (FAILED(hr))
        goto done;

    //     ...</VERSION>
    //     <MANUFACTURER>...
    TESTBOOL(hr, WriteFile(hFile, c_wszXMLDriver3, 
                           sizeof(c_wszXMLDriver3) - sizeof(WCHAR), &cb, NULL));
    if (FAILED(hr))
        goto done;

    // ...[manufacturer data]...
    wsz[0] = L'\0';
    cbOut = XMLEncodeString(wszCompany, wsz, sizeofSTRW(wsz));
    cbOut *= sizeof(WCHAR);
    TESTBOOL(hr, WriteFile(hFile, wsz, cbOut, &cb, NULL));
    if (FAILED(hr))
        goto done;

    //     ...</MANUFACTURER>
    //     <PRODUCTNAME>...
    TESTBOOL(hr, WriteFile(hFile, c_wszXMLDriver4, 
                           sizeof(c_wszXMLDriver4) - sizeof(WCHAR), &cb, NULL));
    if (FAILED(hr))
        goto done;

    // ...[product name data]...
    wsz[0] = L'\0';
    cbOut = XMLEncodeString(wszName, wsz, sizeofSTRW(wsz));
    cbOut *= sizeof(WCHAR);
    TESTBOOL(hr, WriteFile(hFile, wsz, cbOut, &cb, NULL));
    if (FAILED(hr))
        goto done;

    //     ...</PRODUCTNAME>
    // <DRIVER>
    TESTBOOL(hr, WriteFile(hFile, c_wszXMLDriver5, 
                           sizeof(c_wszXMLDriver5) - sizeof(WCHAR), &cb, NULL));
    if (FAILED(hr))
        goto done;

done:
    return hr;
}

// **************************************************************************
void GrovelDriverDir(HANDLE hFile, LPWSTR wszDrivers)
{
    WIN32_FIND_DATAW    wfd;
    HRESULT             hr = NOERROR;
    HANDLE              hFind = INVALID_HANDLE_VALUE;
    WCHAR               *wszFind, *pwszFind;
    DWORD               cchNeed;

    USE_TRACING("GrovelDriverDir");
    if (hFile == NULL || hFile == INVALID_HANDLE_VALUE || wszDrivers == NULL)
        return;

    cchNeed = wcslen(wszDrivers) + MAX_PATH + 2;

    __try { wszFind = (LPWSTR)_alloca(cchNeed * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszFind = NULL; }
    if (wszFind == NULL)
        goto done;

    wcscpy(wszFind, wszDrivers);
    wcscat(wszFind, L"\\*");

    pwszFind = wszFind + wcslen(wszFind) - 1;

    // add the driver info to the file
    ZeroMemory(&wfd, sizeof(wfd));
    hFind = FindFirstFileW(wszFind, &wfd);
    if (hFind != NULL)
    {
        do
        {
            if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 &&
                wcslen(wfd.cFileName) < MAX_PATH)
            {
                wcscpy(pwszFind, wfd.cFileName);
                TESTHR(hr, WriteDriverRecord(hFile, wszFind));
                if (FAILED(hr))
                    goto done;
            }
        }
        while(FindNextFileW(hFind, &wfd));
    }

done:
    if (hFind != INVALID_HANDLE_VALUE)
        FindClose(hFind);
    
}

// **************************************************************************
HRESULT GetDriverData(HANDLE hFile)
{
    FILETIME    ft;
    HRESULT     hr = NOERROR;
    LPWSTR      wszKey = NULL;
    DWORD       iKey, dw, cchKeyMax, dwSvcType, cb, cchNeed, cchSysDir, cch;
    WCHAR       wszSvcPath[1024], *pwszSysDir, *pwszFile;
    HKEY        hkeySvc = NULL, hkey = NULL;

    USE_TRACING("GetDriverData");
    VALIDATEPARM(hr, (hFile == NULL));
    if (FAILED(hr))
        goto done;

    cchNeed = GetSystemDirectoryW(NULL, 0);
    if (cchNeed == 0)
        goto done;

    // according to MSDN, a service name can not be longer than 256 chars
    cchNeed += 32;
    __try { pwszSysDir = (LPWSTR)_alloca(cchNeed * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { pwszSysDir = NULL; }
    if (pwszSysDir == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    cchSysDir = GetSystemDirectoryW(pwszSysDir, cchNeed);
    if (cchSysDir == 0)
        goto done;

    if (pwszSysDir[cchSysDir - 1] != L'\\')
    {
        pwszSysDir[cchSysDir++] = L'\\';
        pwszSysDir[cchSysDir]   = L'\0';
    }

    wcscpy(&pwszSysDir[cchSysDir], L"drivers");
    cchSysDir += sizeofSTRW(L"drivers");

    // get all the drivers that live in the default drivers directory
    GrovelDriverDir(hFile, pwszSysDir);

    // start grovelling the registry
    TESTERR(hr, RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRPSvc, 0, KEY_READ,
                              &hkeySvc));
    if (FAILED(hr))
        goto done;

    TESTERR(hr, RegQueryInfoKey(hkeySvc, NULL, NULL, NULL, NULL, &cchKeyMax, 
                                NULL, NULL, NULL, NULL, NULL, NULL));
    if (FAILED(hr) || cchKeyMax == 0)
        goto done;

    cchKeyMax += 8;
    __try { wszKey = (LPWSTR)_alloca(cchKeyMax * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszKey = NULL; }
    if (wszKey == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // loop thru the services reg key & extract out all the driver entries
    for(iKey = 0; ; iKey++)
    {
        cch = cchKeyMax;
        TESTERR(hr, RegEnumKeyExW(hkeySvc, iKey, wszKey, &cch, NULL, NULL, 
                                  NULL, &ft));
        if (FAILED(hr))
        {
            if (hr == Err2HR(ERROR_NO_MORE_ITEMS))
                break;
            else if (hr == Err2HR(ERROR_MORE_DATA))
                continue;
            else 
                goto done;
        }

        TESTERR(hr, RegOpenKeyExW(hkeySvc, wszKey, 0, KEY_READ, &hkey));
        if (FAILED(hr))
            continue;

        cb = sizeof(dwSvcType);
        TESTERR(hr, RegQueryValueExW(hkey, c_wszRVSvcType, NULL, NULL, 
                                     (LPBYTE)&dwSvcType, &cb));
        if (FAILED(hr))
            goto doneLoop;

        // only care about drivers
        if ((dwSvcType & SERVICE_DRIVER) == 0)
            goto doneLoop;

        // get the ImagePath to the driver.  If none is present, then create
        //  the following path: "%windir%\system32\drivers\<name>.sys" because
        //  that's what the OS does if no ImagePath field is present.
        cb = sizeof(wszSvcPath);
        dw = RegQueryValueExW(hkey, c_wszRVSvcPath, NULL, NULL, 
                              (LPBYTE)wszSvcPath, &cb);
        if (dw != ERROR_SUCCESS)
        {
            hr = Err2HR(dw);
            goto doneLoop;
        }

        // don't want to gather the info if we already did above, so check if
        //  the file lives in the drivers directory
        for(pwszFile = wszSvcPath + wcslen(wszSvcPath);
            *pwszFile != L'\\' && pwszFile > wszSvcPath;
            pwszFile--);
        if (*pwszFile != L'\\')
            goto doneLoop;

        *pwszFile = L'\0';
        if (_wcsicmp(pwszSysDir, wszSvcPath) == 0)
            goto doneLoop;

        // make sure we have a full path
        if ((wszSvcPath[0] != L'\\' || wszSvcPath[1] != L'\\') &&
            (wszSvcPath[1] != L':'  || wszSvcPath[2] != L'\\'))
            goto doneLoop;

        *pwszFile = L'\\';

        // do the actual writing of the info.
        TESTHR(hr, WriteDriverRecord(hFile, wszSvcPath));
        if (FAILED(hr))
            goto done;

doneLoop:
        if (hkey != NULL)
        {
            RegCloseKey(hkey);
            hkey = NULL;
        }
    }

    hr = NOERROR;

done:
    if (hkeySvc != NULL)
        RegCloseKey(hkeySvc);
    if (hkey != NULL)
        RegCloseKey(hkey);

    return hr;
}

// **************************************************************************
HRESULT GetExtraReportInfo(LPCWSTR wszFile, OSVERSIONINFOEXW &osvi)
{
    WIN32_FIND_DATAW    wfd;
    HRESULT             hr = NOERROR;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    WCHAR               wszFind[MAX_PATH], *pwszFind, *pwsz;
    WCHAR               wszBuf[1025], *pwszProd;
    WCHAR               wszSku[200];
    WCHAR               cchEmpty = L'\0';
    DWORD               cb, cbOut, cch, cchNeed;
    HKEY                hkey = NULL;

    USE_TRACING("GetExtraReportInfo");
    VALIDATEPARM(hr, (wszFile == NULL));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // create the file
    hFile = CreateFileW(wszFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 
                        NULL);
    TESTBOOL(hr, (hFile != INVALID_HANDLE_VALUE));
    if (FAILED(hr))
        goto done;

    // determine the SKU
    wszSku[0]=0;
    // we could have an embedded srv or wks installation here...
    if ((osvi.wSuiteMask & VER_SUITE_EMBEDDEDNT) != 0)
        wcscat(wszSku, L"Embedded ");


    if (osvi.wProductType == VER_NT_WORKSTATION)
    {
        if ((osvi.wSuiteMask & VER_SUITE_PERSONAL) != 0)
            wcscat(wszSku, L"Home Edition");
        else
            wcscat(wszSku, L"Professional");
    }
    else
    {
        if ((osvi.wSuiteMask & VER_SUITE_DATACENTER) != 0)
            wcscat(wszSku, L"DataCenter Server");

        else if ((osvi.wSuiteMask & VER_SUITE_ENTERPRISE) != 0)
            wcscat(wszSku, L"Advanced Server");

        else if ((osvi.wSuiteMask & VER_SUITE_BLADE) != 0)
            wcscat(wszSku, L"Web Server");

        else if ((osvi.wSuiteMask & VER_SUITE_BACKOFFICE) != 0)
            wcscat(wszSku, L"Back Office Server");

        else if ((osvi.wSuiteMask & VER_SUITE_SMALLBUSINESS) != 0)
            wcscat(wszSku, L"Small Business Server");

        else if ((osvi.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED) != 0)
            wcscat(wszSku, L"Small Business Server (restricted)");

        else if ((osvi.wSuiteMask & VER_SUITE_COMMUNICATIONS) != 0)
            wcscat(wszSku, L"Communications Server");

        else
            wcscat(wszSku, L"Server");
    }

    // fetch the product ID from the registry
    pwszProd = &cchEmpty;
    TESTHR(hr, OpenRegKey(HKEY_LOCAL_MACHINE, c_wszRKWNTCurVer, FALSE, &hkey));
    if (SUCCEEDED(hr))
    {
        cb = sizeofSTRW(wszBuf);
        TESTHR(hr, ReadRegEntry(hkey, c_wszRVProdName, NULL, (LPBYTE)wszBuf, 
                                &cb, NULL, 0));
        if (SUCCEEDED(hr))
        {
            cb = wcslen(wszBuf) * sizeof(WCHAR) * 6 + sizeof(WCHAR);
            __try { pwszProd = (WCHAR *)_alloca(cb); }
            __except(EXCEPTION_STACK_OVERFLOW) { pwszProd = NULL; }
            if (pwszProd == NULL)
                goto done;

            XMLEncodeString(wszBuf, pwszProd, cb / sizeof(WCHAR));
        }
        else
        {
            pwszProd = &cchEmpty;
        }

        RegCloseKey(hkey);
        hkey = NULL;
    }


    // <SYSTEMINFO>
    // <SYSTEM>
    //     <OSNAME>[os product name] [os sku name]</OSNAME>
    //     <OSVER>[major.minor.build SPmajor.SPminor]</OSVER>
    //     <OSLANGUAGE>[system LCID]</OSLANGUAGE>
    wszBuf[0] = 0xfeff;
    cbOut = swprintf(wszBuf + 1, c_wszXMLHeader, pwszProd, wszSku, 
                     osvi.dwMajorVersion, osvi.dwMinorVersion, 
                     osvi.dwBuildNumber, osvi.wServicePackMajor, 
                     osvi.wServicePackMinor, GetSystemDefaultLangID());
    cbOut *= sizeof(WCHAR);

    TESTBOOL(hr, WriteFile(hFile, wszBuf, cbOut, &cb, NULL));
    if (FAILED(hr))
        goto done;

    WRITE_CWSZ(hr, hFile, c_wszXMLCloseSystem, cb);
    WRITE_CWSZ(hr, hFile, c_wszXMLOpenDevices, cb);

    TESTHR(hr, GetDeviceData(hFile));
    
    WRITE_CWSZ(hr, hFile, c_wszXMLCloseDevices, cb);
    WRITE_CWSZ(hr, hFile, c_wszXMLOpenDrivers, cb);

    TESTHR(hr, GetDriverData(hFile));

    // </DRIVERS>
    // </SYSTEMINFO>
    WRITE_CWSZ(hr, hFile, c_wszXMLFooter, cb);

done:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (hkey != NULL)
        RegCloseKey(hkey);

    return hr;
}

// **************************************************************************
BOOL DoImmediateEventReport(HANDLE hToken, EEventType eet)
{
    USE_TRACING("DoImmediateEventReport");

    PROCESS_INFORMATION pi = { NULL, NULL, 0, 0 };
    STARTUPINFOW        si;
    LPWSTR              pwszSysDir, pwszCmdLine;
    LPVOID              pvEnv = NULL;
    DWORD               cch, cchNeed;
    BOOL                fRet = FALSE;

    if (hToken == NULL || 
        (eet != eetKernelFault && eet != eetShutdown))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // get the system directory
    cch = GetSystemDirectoryW(NULL, 0);
    if (cch == 0)
        goto done;

    cch++;
    __try { pwszSysDir = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { pwszSysDir = NULL; }
    if (pwszSysDir == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    cch = GetSystemDirectoryW(pwszSysDir, cch);
    if (cch == 0)
        goto done;

    if (*(pwszSysDir + cch - 1) == L'\\')
        *(pwszSysDir + cch - 1) = L'\0';

    // create the full command line
    cchNeed = cch + sizeofSTRW(c_wszKrnlCmdLine) + 1;
    __try { pwszCmdLine = (LPWSTR)_alloca(cchNeed * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { pwszCmdLine = NULL; }
    if (pwszCmdLine == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    wcscpy(pwszCmdLine, pwszSysDir);
    if (eet == eetKernelFault)
        wcscat(pwszCmdLine, c_wszKrnlCmdLine);
    else
        wcscat(pwszCmdLine, c_wszShutCmdLine);

    // get the environment block for the user
    fRet = CreateEnvironmentBlock(&pvEnv, hToken, FALSE);
    if (fRet == FALSE)
        pvEnv = NULL;    

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    fRet = CreateProcessAsUserW(hToken, NULL, pwszCmdLine, NULL, NULL, FALSE,
                                CREATE_UNICODE_ENVIRONMENT, pvEnv, pwszSysDir, 
                                &si, &pi);
    if (fRet)
    {
        if (pi.hProcess != NULL)
            CloseHandle(pi.hProcess);
        if (pi.hThread != NULL)
            CloseHandle(pi.hThread);
    }
    
done:
    if (pvEnv != NULL)
        DestroyEnvironmentBlock(pvEnv);
    
    return fRet;
}


///////////////////////////////////////////////////////////////////////////////
// exported functions

// **************************************************************************
EFaultRepRetVal APIENTRY ReportEREvent(EEventType eet, LPCWSTR wszDump,
                                        SEventInfoW *pei)
{
    USE_TRACING("ReportEREvent");

    CPFFaultClientCfg   oCfg;
    EFaultRepRetVal     frrvRet = frrvErrNoDW;
    HANDLE              hFaultLog = INVALID_HANDLE_VALUE;
    DWORD               dw;
    WCHAR               wszDir[MAX_PATH];
    HKEY                hkey = NULL;

    if ((eet != eetKernelFault && eet != eetShutdown && eet != eetUseEventInfo) ||
        (eet == eetUseEventInfo && 
         (pei == NULL || pei->wszTitle == NULL || pei->wszStage2 == NULL || 
          pei->wszEventName == NULL)) ||
        ((eet == eetKernelFault || eet == eetShutdown) && wszDump == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    if (FAILED(oCfg.Read(eroPolicyRO)))
        goto done;

    if (oCfg.get_TextLog() == eedEnabled)
    {
        // assume system is on a local drive with a base path of "X:\"
        GetSystemDirectoryW(wszDir, sizeofSTRW(wszDir));
        wszDir[3] = L'\0';
        wcscat(wszDir, c_wszLogFileName);
        hFaultLog = CreateFileW(wszDir, GENERIC_WRITE, 
                                FILE_SHARE_WRITE | FILE_SHARE_READ, 
                                NULL, OPEN_ALWAYS, 0, NULL);
        if (hFaultLog != INVALID_HANDLE_VALUE)
        {
            SYSTEMTIME  st;
            LPCWSTR     wszEvent = NULL;
            DWORD       cb, cbWritten;
            char        szMsg[512];

            if (eet == eetUseEventInfo)
                wszEvent = pei->wszEventName;

            if (wszEvent == NULL)
                wszEvent = c_rgwszEvents[eet];

            if (wcslen(wszEvent) > MAX_PATH)
                wszEvent = c_wszUnknown;

            GetSystemTime(&st);
            cb = wsprintf(szMsg, "%02d-%02d-%04d %02d:%02d:%02d (notifying) %ls\r\n", 
                          st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, 
                          st.wSecond, wszEvent);
            SetFilePointer(hFaultLog, 0, NULL, FILE_END);
            WriteFile(hFaultLog, szMsg, cb, &cbWritten, NULL);
            CloseHandle(hFaultLog);
        }

        wszDir[0] = L'\0';
    }

    // if we are in silent mode or are not reporting one of the two special 
    //  case items (kernel fault & unplanned shutdown), then just go ahead and 
    //  report directly
    if ((oCfg.get_ShowUI() == eedDisabled && 
         oCfg.get_DoReport() == eedEnabled) ||
         (eet != eetKernelFault && eet != eetShutdown))
    {
        frrvRet = ReportEREventDW(eet, wszDump, pei);
    }
    
    else
    {
        LPCWSTR wszRK = ((eet == eetShutdown) ? c_wszRKShut : c_wszRKKrnl);
        HANDLE  hToken = NULL;
        DWORD   dwSession;
        BOOL    fFoundAdmin = FALSE;
        
        // create the fault key (if it isn't there) and add this one to the list
        dw = RegCreateKeyExW(HKEY_LOCAL_MACHINE, wszRK, 0, NULL, 0, 
                             KEY_WRITE, NULL, &hkey, NULL);
        if (dw == ERROR_SUCCESS)
        {   
            DWORD cbData;
            DWORD dwData;

            cbData = sizeof(dwData);
            dwData = 0;
            RegSetValueExW(hkey, wszDump, 0, REG_DWORD, (LPBYTE)&dwData, 
                           cbData);
            RegCloseKey(hkey);
            hkey = NULL;
            
            // no point in going on if we aren't priviledged cuz we won't be 
            //  able to launch processes or fetch the user token...
            if (AmIPrivileged(TRUE))
                fFoundAdmin = FindAdminSession(&dwSession, &hToken);
            
            if (fFoundAdmin)
                fFoundAdmin = DoImmediateEventReport(hToken, eet);

            // there is no admin logged on, so add the value to the run key
            if (fFoundAdmin == FALSE)
            {
                // create our value in the RunOnce key so that we can report the
                //  next time someone logs in.
                dw = RegCreateKeyExW(HKEY_LOCAL_MACHINE, c_wszRKRun, 0, NULL, 0, 
                                     KEY_WRITE, NULL, &hkey, NULL);
                if (dw == ERROR_SUCCESS)
                {
                    LPCWSTR wszRV  = NULL;
                    LPCWSTR wszRVD = NULL;
                    DWORD   cbRVD  = NULL;

                    if (eet == eetShutdown)
                    {
                        wszRV  = c_wszRVSEC;
                        wszRVD = c_wszRVVSEC;
                        cbRVD  = sizeof(c_wszRVVSEC) - sizeof(WCHAR);
                    }

                    else
                    {
                        wszRV  = c_wszRVKFC;
                        wszRVD = c_wszRVVKFC;
                        cbRVD  = sizeof(c_wszRVVKFC) - sizeof(WCHAR);
                    }
                    
                    RegSetValueExW(hkey, wszRV, 0, REG_EXPAND_SZ, 
                                   (LPBYTE)wszRVD, cbRVD);
                    RegCloseKey(hkey);
                }
            }
        }

        frrvRet = frrvOk;
    }

done:
    return frrvRet;
}

// **************************************************************************
EFaultRepRetVal APIENTRY ReportEREventDW(EEventType eet, LPCWSTR wszDump, 
                                          SEventInfoW *pei)
{
    USE_TRACING("ReportEREventDW");

    CPFFaultClientCfg   oCfg;
    OSVERSIONINFOEXW    ovi;
    EFaultRepRetVal     frrvRet = frrvErrNoDW;
    SDWManifestBlob     dwmb;
    HRESULT             hr = NOERROR;
    LPWSTR              wszFiles = NULL, pwszExtra = NULL, wszDir = NULL;
    LPWSTR              wszManifest = NULL;
    DWORD               dw, cch, cchDir, cchSep;
    WCHAR               wszBuffer[1025];
    ULONG               ulBCCode;
    BOOL                fAllowSend = TRUE;
    HKEY                hkey = NULL;
#ifndef _WIN64
    ULONG               ulBCP1, ulBCP2, ulBCP3, ulBCP4;
#else
    ULONG64             ulBCP1, ulBCP2, ulBCP3, ulBCP4;
#endif

    VALIDATEPARM(hr, ((eet != eetKernelFault && eet != eetShutdown && eet != eetUseEventInfo) ||
        (eet == eetUseEventInfo && 
         (pei == NULL || pei->wszTitle == NULL || pei->wszStage2 == NULL || 0 == wcslen(pei->wszStage2) ||
          pei->wszEventName == NULL || pei->cbSEI != sizeof(SEventInfoW))) ||
        ((eet == eetKernelFault || eet == eetShutdown) && wszDump == NULL)));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    TESTHR(hr, oCfg.Read(eroPolicyRO));
    if (FAILED(hr))
        goto done;

    if (oCfg.get_TextLog() == eedEnabled)
    {
        HANDLE hFaultLog = INVALID_HANDLE_VALUE;

        // assume system is on a local drive with a base path of "X:\"
        GetSystemDirectoryW(wszBuffer, sizeofSTRW(wszBuffer));
        wszBuffer[3] = L'\0';
        wcscat(wszBuffer, c_wszLogFileName);
        hFaultLog = CreateFileW(wszBuffer, GENERIC_WRITE, 
                                FILE_SHARE_WRITE | FILE_SHARE_READ, 
                                NULL, OPEN_ALWAYS, 0, NULL);
        if (hFaultLog != INVALID_HANDLE_VALUE)
        {
            SYSTEMTIME  st;
            LPCWSTR     wszEvent = NULL;
            DWORD       cb, cbWritten;
            char        szMsg[512];

            if (eet == eetUseEventInfo)
                wszEvent = pei->wszEventName;

            if (wszEvent == NULL)
                wszEvent = c_rgwszEvents[eet];

            if (wcslen(wszEvent) > MAX_PATH)
                wszEvent = c_wszUnknown;

            GetSystemTime(&st);
            cb = wsprintf(szMsg, "%02d-%02d-%04d %02d:%02d:%02d (reporting) %ls\r\n", 
                          st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, 
                          st.wSecond, wszEvent);
            SetFilePointer(hFaultLog, 0, NULL, FILE_END);
            WriteFile(hFaultLog, szMsg, cb, &cbWritten, NULL);
            CloseHandle(hFaultLog);
        }
        wszBuffer[0] = L'\0';
    }

    // if setup is in progress, we want to just bail cuz we don't want to hang
    //  setup.  Also, the network isn't setup so we can't really report anyway.
    //  At some point, might want to cache this info & report on first launch.
    dw = RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRKSetup, 0, KEY_READ, &hkey);
    if (dw == ERROR_SUCCESS)
    {   
        DWORD cbData;
        DWORD dwData;

        cbData = sizeof(dwData);
        dwData = 0;
        dw = RegQueryValueExW(hkey, c_wszRVSetupNow, NULL, NULL, 
                              (LPBYTE)&dwData, &cbData);
        RegCloseKey(hkey);
        if (dw == ERROR_SUCCESS && dwData != 0)
        {
            DBG_MSG("Setup in progress");
            goto done;
        }
    }

    if (oCfg.get_ShowUI() == eedDisabled)
    {
        LPCWSTR  wszULPath = oCfg.get_DumpPath(NULL, 0);

        DBG_MSG("ShowUI disabled");

        // if we're disabled, then don't do anything at all.  Still return the 
        //  frrvErrNoDW so that the calling app can perform whatever default
        //  actions it wants to...
        if (oCfg.get_DoReport() == eedDisabled)
        {
            DBG_MSG("DoReport disabled");
            goto done;
        }

        // check and make sure that we have a corporate path specified.  If we
        //  don't, bail
        if (wszULPath == NULL || *wszULPath == L'\0')
        {
            DBG_MSG("no CER path found");
            goto done;
        }
#ifdef REAL_CER_FOR_CLIENT
        //
        // When kernel faults are reported by savedump at machine
        // boot time it is possible that the full net infrastructure
        // hasn't quite started by the time savedump calls to report.
        // UNC path references can fail, causing spurious failures
        // when in CER mode.  Do a quick retry loop to check for
        // such failures and allow time for the net code to start.
        //

        if (wszULPath[0] == L'\\' && wszULPath[1] == L'\\')
        {
            ULONG ulUncRetry = 30;

            while (ulUncRetry-- > 0)
            {
                // Try to limit the errors for which we'll wait
                // to the minimum set so that a plain bad path
                // won't cause a delay.
                if (GetFileAttributesW(wszULPath) != -1 ||
                    (GetLastError() != ERROR_NETWORK_UNREACHABLE &&
                     GetLastError() != ERROR_BAD_NETPATH))
                {
                    break;
                }

                Sleep(1000);
            }

            // We do not panic and fail here if the path
            // was inaccessible.  Instead we let the normal
            // failure path take care of things.
        }
#endif REAL_CER_FOR_CLIENT
    }

    // if kernel reporting or general reporting is disabled, don't show the 
    //  send button
    if (oCfg.get_DoReport() == eedDisabled ||
        (eet == eetKernelFault && oCfg.get_IncKernel() == eedDisabled) || 
        (eet == eetShutdown && oCfg.get_IncShutdown() == eedDisabled)) 
        fAllowSend = FALSE;

    if (CreateTempDirAndFile(NULL, NULL, &wszDir) == 0)
        goto done;

    cchDir = wcslen(wszDir);
    cch = cchDir + sizeofSTRW(c_wszManFileName) + 4;
    __try { wszManifest = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszManifest = NULL; }
    if (wszManifest == NULL)
    {
        DBG_MSG("Out of stack");
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    wcscpy(wszManifest, wszDir);
    wszManifest[cchDir]     = L'\\';
    wszManifest[cchDir + 1] = L'\0';
    wcscat(wszManifest, c_wszManFileName);

    ZeroMemory(&dwmb, sizeof(dwmb));
    if (eet != eetUseEventInfo)
    {
        ZeroMemory(&ovi, sizeof(ovi));
        ovi.dwOSVersionInfoSize = sizeof(ovi);
        GetVersionExW((LPOSVERSIONINFOW)&ovi);

        cch = 2 * cchDir + wcslen(wszDump) + sizeofSTRW(c_wszEventData) + 4;
        __try { wszFiles = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
        __except(EXCEPTION_STACK_OVERFLOW) { wszFiles = NULL; }
        if (wszFiles == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }

        wcscpy(wszFiles, wszDump);
        cchSep = wcslen(wszFiles);
        pwszExtra = wszFiles + cchSep + 1;
        wcscpy(pwszExtra, wszDir);
        pwszExtra[cchDir]     = L'\\';
        pwszExtra[cchDir + 1] = L'\0';
        wcscat(pwszExtra, c_wszEventData);

        TESTHR(hr, GetExtraReportInfo(pwszExtra, ovi));
        if (SUCCEEDED(hr))
            wszFiles[cchSep] = L'|';
            
        // since AndreVa has promised us that savedump will ALWAYS hand us a 
        //  minidump, we don't have to do any conversions.  But this fn will make
        //  sure it's a kernel minidump anyway and fail if it isn't
        if (eet == eetKernelFault)
        {
            TESTHR(hr, ExtractBCInfo(wszDump, &ulBCCode, &ulBCP1, &ulBCP2, 
                                     &ulBCP3, &ulBCP4));
            if (FAILED(hr))
                goto done;

            // log an event- don't care if it fails or not.
            TESTHR(hr, LogKrnl(ulBCCode, ulBCP1, ulBCP2, ulBCP3, ulBCP4));
            
            swprintf(wszBuffer, c_wszManKS2, ulBCCode, ulBCP1, ulBCP2, ulBCP3, 
                     ulBCP4, ovi.dwMajorVersion, ovi.dwMinorVersion, 
                     ovi.dwBuildNumber, ovi.wServicePackMajor, 
                     ovi.wServicePackMinor, ovi.wSuiteMask, ovi.wProductType);
            
            dwmb.nidTitle      = IDS_KTITLE;
            dwmb.nidErrMsg     = IDS_KERRMSG;
            dwmb.nidHdr        = IDS_KHDRTXT;
            dwmb.wszStage2     = wszBuffer;
            dwmb.wszBrand      = c_wszDWBrand;
            dwmb.wszFileList   = wszFiles;
            dwmb.wszCorpPath   = c_wszManKCorpPath;
            dwmb.fIsMSApp      = TRUE;
            dwmb.dwOptions     = emoSupressBucketLogs | emoNoDefCabLimit;
        }

        else if (eet == eetShutdown)
        {
            swprintf(wszBuffer, c_wszManSS2, ovi.dwMajorVersion, 
                     ovi.dwMinorVersion, ovi.dwBuildNumber, 
                     ovi.wServicePackMajor, ovi.wServicePackMinor, 
                     ovi.wSuiteMask, ovi.wProductType);

            dwmb.nidTitle      = IDS_STITLE;
            dwmb.nidErrMsg     = IDS_SERRMSG;
            dwmb.nidHdr        = IDS_SHDRTXT;
            dwmb.wszStage2     = wszBuffer;
            dwmb.wszBrand      = c_wszDWBrand;
            dwmb.wszFileList   = wszFiles;
            dwmb.wszCorpPath   = c_wszManSCorpPath;
            dwmb.fIsMSApp      = TRUE;
            dwmb.dwOptions     = emoSupressBucketLogs | emoNoDefCabLimit;
        }
    }
    else
    {
        dwmb.wszTitle      = pei->wszTitle;
        dwmb.wszErrMsg     = pei->wszErrMsg;
        dwmb.wszHdr        = pei->wszHdr;
        dwmb.wszPlea       = pei->wszPlea;
        dwmb.fIsMSApp      = (pei->fUseLitePlea == FALSE);
        dwmb.wszStage1     = pei->wszStage1;
        dwmb.wszStage2     = pei->wszStage2;
        dwmb.wszCorpPath   = pei->wszCorpPath;
        dwmb.wszEventSrc   = pei->wszEventSrc;
        dwmb.wszSendBtn    = pei->wszSendBtn;
        dwmb.wszNoSendBtn  = pei->wszNoSendBtn;
        dwmb.wszFileList   = pei->wszFileList;
        dwmb.dwOptions     = 0;
        if (pei->fUseIEForURLs)
            dwmb.dwOptions |= emoUseIEforURLs;
        if (pei->fNoBucketLogs)
            dwmb.dwOptions |= emoSupressBucketLogs;
        if (pei->fNoDefCabLimit)
            dwmb.dwOptions |= emoNoDefCabLimit;
    }

    // check and see if the system is shutting down.  If so, CreateProcess is 
    //  gonna pop up some annoying UI that we can't get rid of, so we don't 
    //  want to call it if we know it's gonna happen.
    if (GetSystemMetrics(SM_SHUTTINGDOWN))
        goto done;

    frrvRet = StartDWManifest(oCfg, dwmb, wszManifest, fAllowSend);

done:
    dw = GetLastError();

    if (frrvRet != frrvErrTimeout)
    {
        if (wszManifest != NULL)
            DeleteFileW(wszManifest);
        if (wszFiles != NULL)
        {
            if (pwszExtra != NULL)
            {
                wszFiles[cchSep] = L'\0';
                DeleteFileW(pwszExtra);
            }

        }
        if (wszDir != NULL)
        {
            DeleteTempDirAndFile(wszDir, FALSE);
            MyFree(wszDir);
        }
    }

    SetLastError(dw);

    return frrvRet;
}
// **************************************************************************
EFaultRepRetVal APIENTRY ReportKernelFaultA(LPCSTR szDump)
{
#if 0
    USE_TRACING("ReportEventA");

    EFaultRepRetVal frrv = frrvErrNoDW;
    LPWSTR          wszDump = NULL;
    DWORD           cch;

    if (szDump == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    cch = strlen(szDump) + 1;
    __try
    {
        wszDump = (LPWSTR)_alloca(cch * sizeof(WCHAR));
    }
    __except(EXCEPTION_STACK_OVERFLOW)
    {
        wszDump = NULL;
    }
    if (wszDump == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    if (MultiByteToWideChar(CP_ACP, 0, szDump, -1, wszDump, cch) == 0)
        goto done;

    frrv = ReportEREvent(eetKernelFault, wszDump, NULL);
    
done:
    return frrv;
#else
    return frrvErrNoDW;
#endif
}

// **************************************************************************
EFaultRepRetVal APIENTRY ReportKernelFaultW(LPCWSTR wszDump)
{
//     return ReportEREvent(eetKernelFault, wszDump, NULL);
    return frrvErrNoDW;
}

// **************************************************************************
EFaultRepRetVal APIENTRY ReportKernelFaultDWW(LPCWSTR wszDump)
{
    return ReportEREventDW(eetKernelFault, wszDump, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\faultrep\fruser.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    fruser.cpp

Abstract:
    Implements user fault reporting for unhandled exceptions

Revision History:
    created     derekm      07/07/00

******************************************************************************/

#include "stdafx.h"
#include "dbghelp.h"
#include "wtsapi32.h"
#include "pchrexec.h"
#include "frmc.h"
#include "Tlhelp32.h"


// the size of the following buffer must be evenly divisible by 2 or an
//  alignment fault could occur on ia64.
struct SQueuedFaultBlob
{
    DWORD       cbTotal;
    DWORD       cbFB;
    DWORD_PTR   dwpAppPath;
    DWORD_PTR   dwpModPath;
    UINT64      pvOffset;
    WORD        rgAppVer[4];
    WORD        rgModVer[4];
    BOOL        fIs64bit;
    SYSTEMTIME  stFault;
};

struct SQueuePruneData
{
    LPWSTR      wszVal;
    FILETIME    ftFault;
};

///////////////////////////////////////////////////////////////////////////////
// utility functions

// **************************************************************************
BOOL GetFaultingModuleFilename(LPVOID pvFaultAddr, LPWSTR wszMod,
                                  DWORD cchMod)
{
    USE_TRACING("GetFaultingModuleFilename");

    MODULEENTRY32W  mod;
    HRESULT         hr = NOERROR;
    HANDLE          hSnap = INVALID_HANDLE_VALUE;
    LPVOID          pvEnd;
    DWORD           dwFlags = 0, iMod,cch;
    BOOL            fRet = FALSE;

    VALIDATEPARM(hr, (pvFaultAddr == 0 || wszMod == NULL || cchMod == 0));
    if (FAILED(hr))
        goto done;

    *wszMod = L'\0';

    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());
    TESTBOOL(hr, (hSnap != NULL));
    if (FAILED(hr))
        goto done;

    ZeroMemory(&mod, sizeof(mod));
    mod.dwSize = sizeof(mod);
    TESTBOOL(hr, Module32FirstW(hSnap, &mod));
    if (FAILED(hr))
        goto done;

    do
    {
        pvEnd = mod.modBaseAddr + mod.modBaseSize;
        if (pvFaultAddr >= mod.modBaseAddr && pvFaultAddr < pvEnd)
        {
            if (cchMod > wcslen(mod.szExePath))
            {
                wcscpy(wszMod, mod.szExePath);
                fRet = TRUE;
            }
            else
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                fRet = FALSE;
            }
            break;
        }
    }
    while(Module32NextW(hSnap, &mod));

done:
    if (hSnap != NULL)
        CloseHandle(hSnap);

    return fRet;
}

// **************************************************************************
EFaultRepRetVal StartDWException(LPEXCEPTION_POINTERS pep, DWORD dwOpt,
                                 DWORD dwFlags, LPCSTR szServer,
                                 DWORD dwTimeToWait)
{
    USE_TRACING("StartDWException");

    SECURITY_ATTRIBUTES sa;
    PROCESS_INFORMATION pi;
    EFaultRepRetVal     frrvRet = frrvErrNoDW;
    DWSharedMem15       *pdwsm = NULL;
    STARTUPINFOW        si;
    HRESULT             hr = NOERROR;
    HANDLE              hevDone = NULL, hevAlive = NULL, hmut = NULL;
    HANDLE              hfmShared = NULL, hProc = NULL;
    HANDLE              rghWait[2];
    LPWSTR              wszAppCompat = NULL;
    WCHAR               *pwszCmdLine, wszDir[MAX_PATH];
    WCHAR               wszAppName[MAX_PATH];
    DWORD               dw, dwStart, cch, cchNeed;
    BOOL                fDWRunning = TRUE;

    ZeroMemory(&pi, sizeof(pi));

    VALIDATEPARM(hr, (pep == NULL));
    if (FAILED(hr))
        goto done;

    dwFlags |= (fDwWhistler | fDwUseHKLM | fDwAllowSuspend | fDwMiniDumpWithUnloadedModules);

    // we need the following things to be inheritable, so create a SD that
    //  says it can be.
    ZeroMemory(&sa, sizeof(sa));
    sa.nLength        = sizeof(sa);
    sa.bInheritHandle = TRUE;

    // create the necessary events & mutexes
    hevDone = CreateEvent(&sa, FALSE, FALSE, NULL);
    TESTBOOL(hr, (hevDone != NULL));
    if (FAILED(hr))
        goto done;

    hevAlive = CreateEvent(&sa, FALSE, FALSE, NULL);
    TESTBOOL(hr, (hevAlive != NULL));
    if (FAILED(hr))
        goto done;

    hmut = CreateMutex(&sa, FALSE, NULL);
    TESTBOOL(hr, (hmut != NULL));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(),
                                 GetCurrentProcess(), &hProc,
                                 PROCESS_ALL_ACCESS, TRUE, 0));
    if (FAILED(hr))
        goto done;


    // create the shared memory region & map it
    hfmShared = CreateFileMapping(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE, 0,
                                  sizeof(DWSharedMem), NULL);
    TESTBOOL(hr, (hfmShared != NULL));
    if (FAILED(hr))
        goto done;

    pdwsm = (DWSharedMem *)MapViewOfFile(hfmShared,
                                         FILE_MAP_READ | FILE_MAP_WRITE, 0, 0,
                                         0);
    TESTBOOL(hr, (pdwsm != NULL));
    if (FAILED(hr))
        goto done;


    // populate all the stuff that DW needs
    ZeroMemory(pdwsm, sizeof(DWSharedMem15));

    pdwsm->dwSize            = sizeof(DWSharedMem15);
    pdwsm->pid               = GetCurrentProcessId();
    pdwsm->tid               = GetCurrentThreadId();
    pdwsm->eip               = (DWORD_PTR)pep->ExceptionRecord->ExceptionAddress;
    pdwsm->pep               = pep;
    pdwsm->hEventDone        = hevDone;
    pdwsm->hEventNotifyDone  = NULL;
    pdwsm->hEventAlive       = hevAlive;
    pdwsm->hMutex            = hmut;
    pdwsm->hProc             = hProc;
    pdwsm->bfDWBehaviorFlags = dwFlags;
    pdwsm->msoctdsResult     = msoctdsNull;
    pdwsm->fReportProblem    = FALSE;
    pdwsm->bfmsoctdsOffer    = msoctdsQuit;
    pdwsm->bfmsoctdsNotify   = 0;
    if (dwOpt == 1)
        pdwsm->bfmsoctdsOffer |= msoctdsDebug;
    pdwsm->bfmsoctdsLetRun   = pdwsm->bfmsoctdsOffer;
    pdwsm->iPingCurrent      = 0;
    pdwsm->iPingEnd          = 0;
    pdwsm->lcidUI            = GetUserDefaultUILanguage();

    strcpy(pdwsm->szServer, szServer);
    strcpy(pdwsm->szRegSubPath, c_szDWRegSubPath);
    strcpy(pdwsm->szBrand, c_szDWBrand);
    strcpy(pdwsm->szPIDRegKey, c_szRKVDigPid);
    GetModuleFileNameW(NULL, pdwsm->wzModuleFileName, DW_MAX_PATH);

    TESTHR(hr, GetVerName(pdwsm->wzModuleFileName, wszAppName,
                          sizeofSTRW(wszAppName)));
    if (FAILED(hr))
        goto done;

    cch = CreateTempDirAndFile(NULL, c_wszACFileName, &wszAppCompat);
    TESTBOOL(hr, (cch != 0));
    if (SUCCEEDED(hr))
    {
        WCHAR wszMod[MAX_PATH], *pwszMod = NULL;

        TESTBOOL(hr, GetFaultingModuleFilename(pep->ExceptionRecord->ExceptionAddress,
                                               wszMod, sizeofSTRW(wszMod)));
        if (SUCCEEDED(hr))
            pwszMod = wszMod;

        TESTBOOL(hr, GetAppCompatData(pdwsm->wzModuleFileName, pwszMod,
                                      wszAppCompat));
        if (SUCCEEDED(hr) && wszAppCompat != NULL &&
            wcslen(wszAppCompat) < sizeofSTRW(pdwsm->wzAdditionalFile))
        wcscpy(pdwsm->wzAdditionalFile, wszAppCompat);
    }

    wszAppName[sizeofSTRW(wszAppName) - 1] = L'\0';

    wcsncpy(pdwsm->wzFormalAppName, wszAppName, DW_APPNAME_LENGTH);

//    pdwsm->wzDotDataDlls[0]=0;

    cch = GetSystemDirectoryW(wszDir, sizeofSTRW(wszDir));
    if (cch == 0 || cch > sizeofSTRW(wszDir))
    {
        DBG_MSG("Bad GetSystemDirectoryW call");
        goto done;
    }

    // the +12 is for the max size of an integer in decimal
    cchNeed = cch + wcslen(wszDir) + sizeofSTRW(c_wszDWCmdLineU) + 12;
    __try { pwszCmdLine = (WCHAR *)_alloca(cchNeed * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { pwszCmdLine = NULL; }
    if (pwszCmdLine == NULL)
    {
        DBG_MSG("Out of memory");
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    swprintf(pwszCmdLine, c_wszDWCmdLineU, wszDir, hfmShared);

    // create the process
    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));

    // always want to launch this in the interactive workstation
    si.cb        = sizeof(si);
    si.lpDesktop = L"Winsta0\\Default";

    ErrorTrace(0, "launching [%S]", pwszCmdLine);

    TESTBOOL(hr, CreateProcessW(NULL, pwszCmdLine, NULL, NULL, TRUE,
                                CREATE_DEFAULT_ERROR_MODE | NORMAL_PRIORITY_CLASS,
                                NULL, wszDir, &si, &pi));
    if (FAILED(hr))
        goto done;

    // don't need the thread handle & we gotta close it, so close it now
    CloseHandle(pi.hThread);

    // assume we succeed from here on...
    if ((dwFlags & fDwHeadless) == fDwHeadless)
        frrvRet = frrvOkHeadless;
    else
        frrvRet = frrvOk;

    rghWait[0] = hevAlive;
    rghWait[1] = pi.hProcess;

    dwStart = GetTickCount();
    while(fDWRunning)
    {
        // gotta periodically get the Alive signal from DW.
        switch(WaitForMultipleObjects(2, rghWait, FALSE, 300000))
        {
            case WAIT_OBJECT_0:
                DBG_MSG("hevAlive signalled");

                if (WaitForSingleObject(hevDone, 0) == WAIT_OBJECT_0)
                {
                    DBG_MSG("hevDone signalled");
                    fDWRunning = FALSE;
                }

                if (dwTimeToWait != (DWORD)-1 &&
                    RolloverSubtract(GetTickCount(), dwStart) > dwTimeToWait)
                {
                    frrvRet = frrvErrTimeout;
                    fDWRunning = FALSE;
                }

                continue;

            case WAIT_OBJECT_0 + 1:
                DBG_MSG("DW died");
                fDWRunning = FALSE;
                continue;
        }

        switch(WaitForSingleObject(hmut, DW_TIMEOUT_VALUE))
        {
            // yay!  we got the mutex.  Try to detemine if DW finally responded
            //  while we were grabbing the mutex.
            case WAIT_OBJECT_0:
                DBG_MSG("got hmut");
                switch(WaitForMultipleObjects(2, rghWait, FALSE, 0))
                {
                    // If it hasn't responded, tell it to go away & fall thru
                    //  into the 'it died' case.
                    case WAIT_TIMEOUT:
                        DBG_MSG("wait timed out");
                        SetEvent(hevDone);

                    // It died.  Clean up.
                    case WAIT_OBJECT_0 + 1:
                        DBG_MSG("wait died");
                        fDWRunning = FALSE;
                        frrvRet = frrvErrNoDW;
                        continue;
                }

                // ok, it responded.  Is it done?
                if (WaitForSingleObject(hevDone, 0) == WAIT_OBJECT_0)
                    fDWRunning = FALSE;

                ReleaseMutex(hmut);
                break;

            // if the wait was abandoned, it means DW has gone to the great bit
            //  bucket in the sky without cleaning up.  So release the mutex and
            //  fall into the default case
            case WAIT_ABANDONED:
                DBG_MSG("hmut timed out");
                ReleaseMutex(hmut);

            // if we timed out or otherwise failed, just die.
            default:
                DBG_MSG("hmut died");
                frrvRet    = frrvErrNoDW;
                fDWRunning = FALSE;
                break;
        }
    }
    if (frrvRet != frrvOk)
    {
        DBG_MSG("not OK");
        goto done;
    }

    // if user told us to debug, return that back to the
    if (pdwsm->msoctdsResult == msoctdsDebug)
        frrvRet = frrvLaunchDebugger;

    // if we're going to launch Dr. Watson, wait for the DW process to die.
    //  Give it 5 minutes.  If the user doesn't hit close by then, just return
    //  anyway...
    if (dwOpt == (DWORD)-1)
    {
        if (WaitForSingleObject(pi.hProcess, 300000) == WAIT_TIMEOUT)
            frrvRet = frrvErrTimeout;
    }

done:
    // preserve the error code so that the following calls don't overwrite it
    dw = GetLastError();

    if (wszAppCompat != NULL)
    {
        if (pi.hProcess)
            WaitForSingleObject(pi.hProcess, 300000);
        DeleteTempDirAndFile(wszAppCompat, TRUE);
        MyFree(wszAppCompat);
    }
    if (pi.hProcess)
        CloseHandle(pi.hProcess);

    if (pdwsm != NULL)
        UnmapViewOfFile(pdwsm);
    if (hfmShared != NULL)
        CloseHandle(hfmShared);
    if (hevDone != NULL)
        CloseHandle(hevDone);
    if (hevAlive != NULL)
        CloseHandle(hevAlive);
    if (hmut != NULL)
        CloseHandle(hmut);
    if (hProc != NULL)
        CloseHandle(hProc);

    SetLastError(dw);

    return frrvRet;
}

// **************************************************************************
EFaultRepRetVal StartManifestReport(LPEXCEPTION_POINTERS pep, LPWSTR wszExe,
                                    DWORD dwOpt, DWORD dwTimeToWait)
{
    USE_TRACING("StartManifestReport");

    SPCHExecServFaultRequest    *pesdwreq = NULL;
    SPCHExecServFaultReply      *pesrep = NULL;
    EFaultRepRetVal             frrvRet = frrvErrNoDW;
    HRESULT                     hr = NOERROR;
    DWORD                       cbReq, cbRead;
    WCHAR                       wszName[MAX_PATH];
    BYTE                        Buf[ERRORREP_PIPE_BUF_SIZE], *pBuf;
    BYTE                        BufRep[ERRORREP_PIPE_BUF_SIZE];

    VALIDATEPARM(hr, (wszExe == NULL));
    if (FAILED(hr))
        goto done;

    ZeroMemory(Buf, sizeof(Buf));
    pesdwreq = (SPCHExecServFaultRequest *)Buf;

    // the following calculation ensures that pBuf is always aligned on a
    //  sizeof(WCHAR) boundry...
    cbReq = sizeof(SPCHExecServFaultRequest) +
            sizeof(SPCHExecServFaultRequest) % sizeof(WCHAR);
    pBuf = Buf + cbReq;

    pesdwreq->cbESR         = sizeof(SPCHExecServFaultRequest);
    pesdwreq->pidReqProcess = GetCurrentProcessId();
    pesdwreq->thidFault     = GetCurrentThreadId();
    pesdwreq->pvFaultAddr   = (UINT64)pep->ExceptionRecord->ExceptionAddress;
    pesdwreq->pEP           = (UINT64)pep;
#ifdef _WIN64
    pesdwreq->fIs64bit      = TRUE;
#else
    pesdwreq->fIs64bit      = FALSE;
#endif

    // marshal in the strings
    pesdwreq->wszExe = (UINT64)MarshallString(wszExe, Buf, sizeof(Buf), &pBuf,
                                              &cbReq);
    if (pesdwreq->wszExe == 0)
        goto done;

    pesdwreq->cbTotal = cbReq;

    // check and see if the system is shutting down.  If so, CreateProcess is
    //  gonna pop up some annoying UI that we can't get rid of, so we don't
    //  want to call it if we know it's gonna happen.
    if (GetSystemMetrics(SM_SHUTTINGDOWN))
        goto done;

    // Send the buffer out to the server- wait at most 2m for this to
    //  succeed.  If it times out, bail.  BTW, need to zero out BufRep here
    //  cuz the call to the named pipe CAN fail & we don't want to start
    //  processing garbage results...
    ZeroMemory(BufRep, sizeof(BufRep));
    wcscpy(wszName, ERRORREP_FAULT_PIPENAME);
    TESTHR(hr, MyCallNamedPipe(wszName, Buf, cbReq, BufRep, sizeof(BufRep),
                               &cbRead, 120000, 120000));
    if (FAILED(hr))
    {
        // determine the error code that indicates whether we've timed out so
        //  we can set the return code appropriately.
        goto done;
    }

    pesrep = (SPCHExecServFaultReply *)BufRep;

    // did the call succeed?
    VALIDATEEXPR(hr, (pesrep->ess == essErr), Err2HR(pesrep->dwErr));
    if (FAILED(hr))
    {
        SetLastError(pesrep->dwErr);
        goto done;
    }

    // this is only necessary if we actually launched DW.  If we just queued
    //  the fault for later, then we obviously can't wait on DW.
    if (pesrep->ess == essOk)
    {
        DWORD   dwExitCode = msoctdsNull;

        // gotta wait for DW to be done before we nuke the manifest file, but
        //  if it hasn't parsed it in 5 minutes, something's wrong with it.
        if (pesrep->hProcess != NULL)
        {
            DWORD dwTimeout;

            // so, if we're going to pop up the JIT debugger dialog if we timeout,
            //  then maybe we should just not bother timeing out...
            dwTimeout = (dwOpt == froDebug) ? INFINITE : 300000;

            if (WaitForSingleObject(pesrep->hProcess, dwTimeout) == WAIT_TIMEOUT)
                frrvRet = frrvErrTimeout;

            // see if we need to debug the process
            else if (GetExitCodeProcess(pesrep->hProcess, &dwExitCode) == FALSE)
                dwExitCode = msoctdsNull;

            CloseHandle(pesrep->hProcess);
            pesrep->hProcess = NULL;
        }

        // we're only going to delete the files if DW has finished with them.
        //  Yes this means we can leave stray files in the temp dir, but this
        //  is better than having DW randomly fail while sending...
        if (frrvRet != frrvErrTimeout)
        {
            LPWSTR  pwsz, pwszEnd;

            if (pesrep->wszDir != 0)
            {
                if (pesrep->wszDir < cbRead &&
                    pesrep->wszDir >= sizeof(SPCHExecServFaultReply))
                    pesrep->wszDir += (UINT64)pesrep;
                else
                    pesrep->wszDir = 0;
            }

            if (pesrep->wszDumpName != 0)
            {
                if (pesrep->wszDumpName < cbRead &&
                    pesrep->wszDumpName >= sizeof(SPCHExecServFaultReply))
                    pesrep->wszDumpName += (UINT64)pesrep;
                else
                    pesrep->wszDumpName = 0;
            }

            // make sure that there is a NULL terminator for each string
            //  before the end of the buffer...
            pwszEnd = (LPWSTR)((BYTE *)pesrep + cbRead);
            if (pesrep->wszDumpName != 0)
            {
                for (pwsz = (LPWSTR)pesrep->wszDumpName;
                     pwsz < pwszEnd && *pwsz != L'\0';
                     pwsz++);
                if (*pwsz != L'\0')
                    pesrep->wszDumpName = 0;
            }

            if (pesrep->wszDir != 0)
            {
                for (pwsz = (LPWSTR)pesrep->wszDir;
                     pwsz < pwszEnd && *pwsz != L'\0';
                     pwsz++);
                if (*pwsz != L'\0')
                    pesrep->wszDir = 0;
            }

        }

        frrvRet = (dwExitCode == msoctdsDebug) ? frrvLaunchDebugger :
                                                 frrvOkManifest;
    }

    // if we queued it, set the appropriate return code (duh)
    else if (pesrep->ess == essOkQueued)
    {
        frrvRet = frrvOkQueued;
    }

    SetLastError(0);

done:
    if ((frrvRet == frrvOkManifest || frrvRet == frrvLaunchDebugger) &&
        pesrep != NULL && pesrep->wszDir != 0)
    {
        LPWSTR  wszToDel = NULL;
        DWORD   cchDir = 0, cchFile = 0;

        cchDir = wcslen((LPWSTR)pesrep->wszDir);
        if (pesrep->wszDumpName != 0)
            cchFile =  wcslen((LPWSTR)pesrep->wszDumpName);

        if (cchFile < sizeofSTRW(c_wszACFileName))
            cchFile = sizeofSTRW(c_wszACFileName);

        if (cchFile < sizeofSTRW(c_wszManFileName))
            cchFile = sizeofSTRW(c_wszManFileName);

        __try { wszToDel = (LPWSTR)_alloca((cchFile + cchDir + 4) * sizeof(WCHAR)); }
        __except(EXCEPTION_STACK_OVERFLOW) { wszToDel = NULL; }
        if (wszToDel != NULL)
        {
            LPWSTR pwszToDel;
            wcscpy(wszToDel, (LPWSTR)pesrep->wszDir);

            pwszToDel = wszToDel + cchDir;
            *pwszToDel++ = L'\\';

            if (pesrep->wszDumpName != 0)
            {
                wcscpy(pwszToDel, (LPWSTR)pesrep->wszDumpName);
#ifdef MANIFEST_HEAP
                DeleteFullAndTriageMiniDumps(wszToDel);
#else
                DeleteFileW(wszToDel);
#endif
            }
            wcscpy(pwszToDel, c_wszACFileName);
            DeleteFileW(wszToDel);
            wcscpy(pwszToDel, c_wszManFileName);
            DeleteFileW(wszToDel);
        }

        DeleteTempDirAndFile((LPWSTR)pesrep->wszDir, FALSE);
    }

    return frrvRet;
}

// **************************************************************************
HRESULT PruneQ(HKEY hkeyQ, DWORD cQSize, DWORD cMaxQSize, DWORD cchMaxVal,
               DWORD cbMaxData)
{
    USE_TRACING("PruneQ");

    SQueuedFaultBlob    *psqfb = NULL;
    SQueuePruneData     *pqpd = NULL;
    FILETIME            ft;
    HRESULT             hr = NOERROR;
    LPWSTR              pwsz, pwszCurrent = NULL;
    DWORD               cchVal, cbData, dwType, cToDel = 0, cInDelList = 0;
    DWORD               i, iEntry, dw, cValid = 0;

    VALIDATEPARM(hr, (hkeyQ == NULL));
    if (FAILED(hr))
        goto done;

    if (cMaxQSize > cQSize)
        goto done;

    cToDel = cQSize - cMaxQSize + 1;

    // alloc the various buffers that we'll need:
    //  the delete list
    //  the current file we're working with
    //  the data blob associated with the current file
    cbData      = (sizeof(SQueuePruneData) + (cchMaxVal * sizeof(WCHAR))) * cToDel;
    pwszCurrent = (LPWSTR)MyAlloc(cchMaxVal * sizeof(WCHAR));
    psqfb       = (SQueuedFaultBlob *)MyAlloc(cbMaxData);
    pqpd        = (SQueuePruneData *)MyAlloc(cbData);
    if (psqfb == NULL || pwszCurrent == NULL || pqpd == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // intiailize all the string pointers in the delete list
    pwsz = (LPWSTR)((BYTE *)pqpd + (sizeof(SQueuePruneData) * cToDel));
    for (i = 0; i < cToDel; i++)
    {
        pqpd[i].ftFault.dwHighDateTime = 0;
        pqpd[i].ftFault.dwLowDateTime  = 0;
        pqpd[i].wszVal                 = pwsz;
        pqpd[i].wszVal[0]              = L'\0';
        pwsz                           += cchMaxVal;
    }


    // ok, get a list of all the valid items and build an array in sorted order
    //  so that we can easily pick off the top n items
    for(iEntry = 0; iEntry < cQSize; iEntry++)
    {
        cchVal = cchMaxVal;
        cbData = cbMaxData;
        dw = RegEnumValueW(hkeyQ, iEntry, pwszCurrent, &cchVal, 0, &dwType,
                           (PBYTE)psqfb, &cbData);
        if (dw == ERROR_NO_MORE_ITEMS)
            break;
        else if (dw != ERROR_SUCCESS)
            continue;
        else if (cbData < sizeof(SQueuedFaultBlob) ||
                 psqfb->cbFB != sizeof(SQueuedFaultBlob) ||
                 psqfb->cbTotal != cbData)
        {
            RegDeleteValueW(hkeyQ, pwszCurrent);
            DeleteFileW(pwszCurrent);
            continue;
        }

        SystemTimeToFileTime(&psqfb->stFault, &ft);

        for (i = 0; i < cInDelList; i++)
        {
            if ((ft.dwHighDateTime < pqpd[i].ftFault.dwHighDateTime) ||
                (ft.dwHighDateTime == pqpd[i].ftFault.dwHighDateTime &&
                 ft.dwLowDateTime < pqpd[i].ftFault.dwLowDateTime))
                 break;
        }

        // if it's in the middle of the current list, then we gotta move
        //  stuff around
        if (cInDelList > 0 && i < cInDelList - 1)
        {
            LPWSTR pwszTemp = pqpd[cInDelList - 1].wszVal;

            MoveMemory(&pqpd[i], &pqpd[i + 1],
                       (cInDelList - i) * sizeof(SQueuePruneData));

            pqpd[i].wszVal = pwszTemp;
        }

        if (i < cToDel)
        {
            // note that this copy is safe cuz each string slot is the same
            //  size as the buffer pointed to by pwszCurrent and that buffer is
            //  protected from overflow by the size we pass into
            //  RegEnumValueW()
            wcscpy(pqpd[i].wszVal, pwszCurrent);
            pqpd[i].ftFault = ft;

            if (cInDelList < cToDel)
                cInDelList++;
        }

        cValid++;
    }

    // if there aren't enuf valid entries to warrant a purge, then don't purge
    if (cValid < cMaxQSize)
        goto done;

    cToDel = MyMin(cToDel, cValid - cMaxQSize + 1);

    // purge enuf entries that we go down to 1 below our max (since we have to
    //  be adding 1 to get here- don't want that 1 to drive us over the limit
    for(i = 0; i < cToDel; i++)
    {
        if (pqpd[i].wszVal != NULL)
        {
            DeleteFileW(pqpd[i].wszVal);
            RegDeleteValueW(hkeyQ, pqpd[i].wszVal);
        }
    }

done:
    if (pqpd != NULL)
        MyFree(pqpd);
    if (psqfb != NULL)
        MyFree(psqfb);
    if (pwszCurrent != NULL)
        MyFree(pwszCurrent);

    return hr;
}

// **************************************************************************
HRESULT CheckQSizeAndPrune(HKEY hkeyQ)
{
    USE_TRACING("CheckQueueSizeAndPrune");

    HRESULT hr = NOERROR;
    HANDLE  hmut = NULL;
    DWORD   cMaxQSize = 0, cDefMaxQSize = 10;
    DWORD   cQSize, cchMaxVal, cbMaxData;
    DWORD   cb, dw;
    HKEY    hkey = NULL;

    VALIDATEPARM(hr, (hkeyQ == NULL));
    if (FAILED(hr))
        goto done;

    // find out the max Q size
    TESTHR(hr, OpenRegKey(HKEY_LOCAL_MACHINE, c_wszRPCfg, 0, &hkey));
    if (FAILED(hr))
        goto done;

    cb = sizeof(cMaxQSize);
    TESTHR(hr, ReadRegEntry(hkey, c_wszRVMaxQueueSize, NULL, (PBYTE)&cMaxQSize,
                            &cb, (PBYTE)&cDefMaxQSize, sizeof(cDefMaxQSize)));
    RegCloseKey(hkey);
    hkey = NULL;
    if (FAILED(hr))
        goto done;

    // if the Q size is 0, then we are effectively disabled for Qing faults.
    //  Return S_FALSE to indicate this
    if (cMaxQSize == 0)
    {
        hr = S_FALSE;
        goto done;
    }

    // -1 means there is no limit
    else if (cMaxQSize == (DWORD)-1)
    {
        hr = NOERROR;
        goto done;
    }

    else if (cMaxQSize > c_cMaxQueue)
        cMaxQSize = c_cMaxQueue;

    hmut = OpenMutexW(SYNCHRONIZE, FALSE, c_wszMutUserName);
    TESTBOOL(hr, (hmut != NULL));
    if (FAILED(hr))
        goto done;

    // wait for 5s for the mutex to become available- this should be enuf time
    //  for anyone else to add something to the queue dir.  It could take longer
    //  if someone is processing the dir, but then items are being removed
    //  anyway...
    dw = WaitForSingleObject(hmut, 5000);
    if (dw != WAIT_OBJECT_0)
    {
        // if the wait timed out, then someone is already going thru the faults
        //  so it's likely to be reduced sometime soon
        if (dw == WAIT_TIMEOUT)
            hr = NOERROR;
        else
            hr = Err2HR(GetLastError());
        goto done;
    }

    __try
    {
        // determine what the Q size is.
        TESTERR(hr, RegQueryInfoKey(hkeyQ, NULL, NULL, NULL, NULL, NULL, NULL,
                                    &cQSize, &cchMaxVal, &cbMaxData, NULL, NULL));
        if (SUCCEEDED(hr) && (cQSize >= cMaxQSize))
        {
            cchMaxVal++;
            TESTHR(hr, PruneQ(hkeyQ, cQSize, cMaxQSize, cchMaxVal, cbMaxData));
        }
        else
        {
            hr = NOERROR;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

done:
    if (hmut != NULL)
    {
        ReleaseMutex(hmut);
        CloseHandle(hmut);
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// exported functions

// **************************************************************************
EFaultRepRetVal APIENTRY ReportFaultFromQueue(LPWSTR wszDump, BYTE *pbData,
                                              DWORD cbData)
{
    USE_TRACING("ReportFaultFromQueue");

    CPFFaultClientCfg   oCfg;
    SQueuedFaultBlob    *pqfb = (SQueuedFaultBlob *)pbData;
    EFaultRepRetVal     frrvRet = frrvErrNoDW;
    SDWManifestBlob     dwmb;
    SYSTEMTIME          stLocal;
    FILETIME            ft, ftLocal;
    HRESULT             hr = NOERROR;
    LPWSTR              wszAppPath, wszModPath;
    LPWSTR              wszModName, wszAppName, pwszApp, pwszEnd;
    LPWSTR              wszStage1, wszStage2, wszCorpPath, wszHdr, wszErrMsg;
    LPWSTR              wszNewDump = NULL, wszDir = NULL;
    LPWSTR              wszManifest = NULL, pwszAppCompat = NULL;
    WCHAR               wszDate[128], wszTime[128], *pwsz;
    WCHAR               *pwch;
    WCHAR               wszAppFriendlyName[MAX_PATH];
    WCHAR               wszBuffer[160];
    WCHAR               wszUnknown[] = L"unknown";
    DWORD               dw, cchTotal, cchSep = 0, cch, cchDir;
    BYTE                *pbBuf = NULL;
    BOOL                fMSApp = FALSE, fAllowSend = TRUE, fOkCopy = FALSE;

    VALIDATEPARM(hr, (wszDump == NULL || pbData == NULL) ||
                      cbData < sizeof(SQueuedFaultBlob) ||
                      pqfb->cbFB != sizeof(SQueuedFaultBlob) ||
                      pqfb->cbTotal != cbData ||
                      pqfb->dwpAppPath >= cbData ||
                      pqfb->dwpModPath >= cbData);
    if (FAILED(hr))
        goto done;

    wszAppPath  = (LPWSTR)(pqfb->dwpAppPath + pbData);
    wszModPath  = (LPWSTR)(pqfb->dwpModPath + pbData);
    pwszEnd     = (LPWSTR)(pbData + cbData);

    // make sure there's a NULL terminator on the ModPath string before the end
    //  of the buffer...
    for (pwch = wszModPath; pwch < pwszEnd && *pwch != L'\0'; pwch++);
    if (pwch >= pwszEnd)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // convieniently, pwch is now at the end of ModPath string, so we can
    //  parse back to find the first backslash & get the module name
    for(pwch -= 1; pwch >= wszModPath && *pwch != L'\\'; pwch--);
    if (*pwch == L'\\')
        wszModName = pwch + 1;
    else
        wszModName = wszModPath;
    if (*wszModName == L'\0')
        wszModName = wszUnknown;

    // make sure there's a NULL terminator on the AppPath string before the end
    //  of the buffer...
    for (pwch = wszAppPath; pwch < wszModPath && *pwch != L'\0'; pwch++);
    if (pwch >= wszModPath)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // convieniently, pwch is now at the end of AppPath string, so we can
    //  parse back to find the first backslash & get the module name
    for(pwch -= 1; pwch >= wszAppPath && *pwch != L'\\'; pwch--);
    if (*pwch == L'\\')
        wszAppName = pwch + 1;
    else
        wszAppName = wszAppPath;

    // get the config info
    TESTHR(hr, oCfg.Read(eroPolicyRO));
    if (FAILED(hr))
        goto done;

    if (oCfg.get_ShowUI() == eedDisabled && oCfg.get_DoReport() == eedDisabled)
        goto done;

    // figure out how we're reporting / notifying the user
    if (oCfg.get_DoReport() == eedDisabled ||
        oCfg.ShouldCollect(wszAppPath, &fMSApp) == FALSE)
        fAllowSend = FALSE;

    if (oCfg.get_ShowUI() == eedDisabled)
    {
        LPCWSTR  wszULPath = oCfg.get_DumpPath(NULL, 0);

        // check and make sure that we have a corporate path specified.  If we
        //  don't, bail
        if (wszULPath == NULL || *wszULPath == L'\0')
            goto done;
    }

    // log an event- don't care if it fails or not.
    TESTHR(hr, LogUser(wszAppName, pqfb->rgAppVer, wszModName, pqfb->rgModVer,
                       pqfb->pvOffset, pqfb->fIs64bit, ER_QUEUEREPORT_LOG));


    if (CreateTempDirAndFile(NULL, NULL, &wszDir) == 0)
        goto done;

    cchDir = wcslen(wszDir);
    cch = cchDir + sizeofSTRW(c_wszManFileName) + 4;
    __try { wszManifest = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszManifest = NULL; }
    if (wszManifest == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    wcscpy(wszManifest, wszDir);
    wszManifest[cchDir]     = L'\\';
    wszManifest[cchDir + 1] = L'\0';
    wcscat(wszManifest, c_wszManFileName);


    cchDir = wcslen(wszDir);
    cch = 2 * cchDir + wcslen(wszDump) + sizeofSTRW(c_wszACFileName) + 4;
    __try { wszNewDump = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszNewDump = NULL; }
    if (wszNewDump == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    wcscpy(wszNewDump, wszDir);
    wszNewDump[cchDir]     = L'\\';
    wszNewDump[cchDir + 1] = L'\0';

    fOkCopy = FALSE;
    for (pwsz = wszDump + wcslen(wszDump);
         *pwsz != L'\\' && pwsz > wszDump;
         pwsz--);
    if (*pwsz == L'\\')
    {
        pwsz++;
        wcscat(wszNewDump, pwsz);
        for (pwsz = wszNewDump + wcslen(wszNewDump);
             *pwsz != L'.' && pwsz > wszNewDump;
             pwsz--);
        if (*pwsz == L'.' && pwsz > wszNewDump &&
            _wcsicmp(pwsz, c_wszDumpSuffix) == 0)
        {
            pwsz--;
            for(;
                *pwsz != L'.' && pwsz > wszNewDump;
                pwsz--);
            if (*pwsz == L'.' && pwsz > wszNewDump)
            {
                wcscpy(pwsz, c_wszDumpSuffix);
#ifdef MANIFEST_HEAP
                fOkCopy = CopyFullAndTriageMiniDumps(wszDump, wszNewDump);
#else
                fOkCopy = CopyFileW(wszDump, wszNewDump, FALSE);
#endif
            }
        }
    }
    if (fOkCopy == FALSE)
        wcscpy(wszNewDump, wszDump);

    // generate all the URLs / filepaths that we need...
    TESTHR(hr, BuildManifestURLs(wszAppName, wszModName, pqfb->rgAppVer,
                                 pqfb->rgModVer, pqfb->pvOffset,
                                 pqfb->fIs64bit, &wszStage1, &wszStage2,
                                 &wszCorpPath, &pbBuf));
    if (FAILED(hr))
        goto done;

    // get the friendly name for the app
    TESTHR(hr, GetVerName(wszAppPath, wszAppFriendlyName,
                          sizeofSTRW(wszAppFriendlyName)));
    if (FAILED(hr))
        goto done;

    wszAppFriendlyName[sizeofSTRW(wszAppFriendlyName) - 1] = L'\0';

    // build the header string
    dw = LoadStringW(g_hInstance, IDS_FQHDRTXT, wszBuffer,
                     sizeofSTRW(wszBuffer));
    if (dw == 0)
        goto done;

    cchTotal = dw + wcslen(wszAppFriendlyName) + 1;
    __try { wszHdr = (LPWSTR)_alloca(cchTotal * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszHdr = NULL; }
    if (wszHdr == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    swprintf(wszHdr, wszBuffer, wszAppFriendlyName);

    // need to convert the time of the fault to a local time (cuz
    //  GetSystemTime() returns a UTC time), but unfortunately, only filetimes
    //  can be converted back and forth between UTC & local, so we have to do
    //  all of this stuff...
    SystemTimeToFileTime(&pqfb->stFault, &ft);
    FileTimeToLocalFileTime(&ft, &ftLocal);
    FileTimeToSystemTime(&ftLocal, &stLocal);

    // build the error message string
    dw = LoadStringW(g_hInstance, IDS_FQERRMSG, wszBuffer,
                     sizeofSTRW(wszBuffer));
    if (dw == 0)
        goto done;

    cchTotal = dw;

    dw = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &stLocal,
                        NULL, wszDate, sizeofSTRW(wszDate));
    if (dw == 0)
        goto done;

    cchTotal += dw;

    dw = GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &stLocal, NULL, wszTime,
                        sizeofSTRW(wszTime));
    if (dw == 0)
        goto done;

    cchTotal += dw;

    cchTotal++;
    __try { wszErrMsg = (LPWSTR)_alloca(cchTotal * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszErrMsg = NULL; }
    if (wszErrMsg == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    swprintf(wszErrMsg, wszBuffer, wszDate, wszTime);

    // we created the wszDump buffer above big enuf to hold both the
    //  dumpfile path as well as the app compat filename.  So make
    //  use of that right now.
    cchSep = wcslen(wszNewDump);
    pwszAppCompat = wszNewDump + cchSep + 1;
    wcscpy(pwszAppCompat, wszDir);
    pwszAppCompat[cchDir]     = L'\\';
    pwszAppCompat[cchDir + 1] = L'\0';
    wcscat(pwszAppCompat, c_wszACFileName);

    // if we succeed, turn the NULL following the dump file path into
    //  the DW separator character
    TESTBOOL(hr, GetAppCompatData(wszAppPath, wszModPath, pwszAppCompat));
    if (SUCCEEDED(hr))
        wszNewDump[cchSep] = DW_FILESEP;

    ZeroMemory(&dwmb, sizeof(dwmb));
    dwmb.wszTitle      = wszAppFriendlyName;
    dwmb.wszErrMsg     = wszErrMsg;
    dwmb.wszHdr        = wszHdr;
    dwmb.wszStage1     = wszStage1;
    dwmb.wszStage2     = wszStage2;
    dwmb.wszBrand      = c_wszDWBrand;
    dwmb.wszFileList   = wszNewDump;
    dwmb.fIsMSApp      = fMSApp;
    dwmb.wszCorpPath   = wszCorpPath;

    // check and see if the system is shutting down.  If so, CreateProcess is
    //  gonna pop up some annoying UI that we can't get rid of, so we don't
    //  want to call it if we know it's gonna happen.
    if (GetSystemMetrics(SM_SHUTTINGDOWN))
        goto done;

    // we get back the name of the manifest file here.
    frrvRet = StartDWManifest(oCfg, dwmb, wszManifest, fAllowSend);

done:
    dw = GetLastError();

    if (pbBuf != NULL)
        MyFree(pbBuf);

    if (frrvRet != frrvErrTimeout)
    {
        if (wszNewDump != NULL)
        {
            if (pwszAppCompat != NULL)
            {
                wszNewDump[cchSep] = L'\0';
                DeleteFileW(pwszAppCompat);
            }
#ifdef MANIFEST_HEAP
            DeleteFullAndTriageMiniDumps(wszNewDump);
#else
            DeleteFileW(wszNewDump);
#endif
        }

        if (wszManifest != NULL)
            DeleteFileW(wszManifest);
        if (wszDir != NULL)
        {
            DeleteTempDirAndFile(wszDir, FALSE);
            MyFree(wszDir);
        }
    }

    SetLastError(dw);

    return frrvRet;
}

// **************************************************************************
#define ER_ALL_RIGHTS GENERIC_ALL | STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL
EFaultRepRetVal APIENTRY ReportFaultToQueue(SFaultRepManifest *pfrm)
{
    USE_TRACING("ReportFaultToQueue");

    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    SQueuedFaultBlob    *pqfb;
    EFaultRepRetVal     frrvRet = frrvErrNoDW;
    SMDumpOptions       smdo;
    SYSTEMTIME          st;
    HRESULT             hr = NOERROR;
    LPWSTR              pwsz, pwszAppName = NULL, pwszDump = NULL;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    HANDLE              hProc = NULL;
    USHORT              usCompress;
    DWORD               cch, cchNeed, cb, dw;
    WCHAR               wszDump[MAX_PATH];
    HKEY                hkeyQ = NULL, hkeyRun = NULL;
    WORD                iFile = 0;

    ZeroMemory(&sa, sizeof(sa));
    wszDump[0] = L'\0';

    VALIDATEPARM(hr, (pfrm == NULL || pfrm->wszExe == NULL ||
                      pfrm->pidReqProcess == 0));
    if (FAILED(hr))
        goto done;

    // get the SD for the file we need to create
    TESTBOOL(hr, AllocSD(&sd, ER_ALL_RIGHTS, ER_ALL_RIGHTS, 0));
    if (FAILED(hr))
        goto done;

    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle       = FALSE;

    // get the name of the faulting application
    for (pwszAppName = pfrm->wszExe + wcslen(pfrm->wszExe) - 1;
         *pwszAppName != L'\\' && pwszAppName >= pfrm->wszExe;
         pwszAppName--);
    if (*pwszAppName == L'\\')
        pwszAppName++;

    // generate the filename
    cch = GetSystemWindowsDirectoryW(wszDump, sizeofSTRW(wszDump));
    if (cch == 0)
        goto done;

    // compute minimum required buffer size needed (the '5 * 6' at the end is
    //  to allow for the 6 WORD values that will be inserted)
    cchNeed = cch + wcslen(pwszAppName) + 5 * 6 + sizeofSTRW(c_wszQFileName);
    if (cchNeed > sizeofSTRW(wszDump))
    {
        __try { pwszDump = (LPWSTR)_alloca(cchNeed * sizeof(WCHAR)); }
        __except(EXCEPTION_STACK_OVERFLOW) { pwszDump = NULL; }
        if (pwszDump == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }

        if (cch > sizeofSTRW(wszDump))
            cch = GetSystemWindowsDirectoryW(wszDump, cchNeed);
        else
            wcscpy(pwszDump, wszDump);
    }
    else
    {
        pwszDump = wszDump;
    }


    pwsz = pwszDump + cch - 1;
    if (*pwsz != L'\\')
    {
        *(++pwsz) = L'\\';
        *(++pwsz) = L'\0';
    }

    wcscpy(pwsz, c_wszQSubdir);
    pwsz += (sizeofSTRW(c_wszQSubdir) - 1);

    GetSystemTime(&st);
    swprintf(pwsz, c_wszQFileName, pwszAppName, st.wYear, st.wMonth, st.wDay,
             st.wHour, st.wMinute, st.wSecond);

    // set pwsz to point to the 00 at the end of the above string...
    pwsz += (wcslen(pwsz) - 7);

    // do this in this section to make sure we can open these keys
    TESTHR(hr, OpenRegKey(HKEY_LOCAL_MACHINE, c_wszRKUser, orkWantWrite,
                          &hkeyQ));
    if (FAILED(hr))
        goto done;

    TESTHR(hr, OpenRegKey(HKEY_LOCAL_MACHINE, c_wszRKRun, orkWantWrite,
                          &hkeyRun));
    if (FAILED(hr))
        goto done;

    // check the size of the file Q and purge it if necessary
    TESTHR(hr, CheckQSizeAndPrune(hkeyQ));
    if (FAILED(hr) || hr == S_FALSE)
        goto done;

    for(iFile = 1; iFile <= 100; iFile++)
    {
        hFile = CreateFileW(pwszDump, GENERIC_WRITE | GENERIC_READ, 0, &sa,
                            CREATE_NEW, 0, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
            break;

        if (hFile == INVALID_HANDLE_VALUE &&
            GetLastError() != ERROR_FILE_EXISTS)
            break;

        *pwsz       = L'0' + (WCHAR)(iFile / 10);
        *(pwsz + 1) = L'0' + (WCHAR)(iFile % 10);
    }

    if (hFile == INVALID_HANDLE_VALUE)
        goto done;

    // get a handle to the target process
    hProc = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE,
                        pfrm->pidReqProcess);
    if (hProc == NULL)
        goto done;

    // generate the minidump
    ZeroMemory(&smdo, sizeof(smdo));
#ifdef MANIFEST_HEAP
    smdo.ulThread    = c_ulThreadWriteDefault;
    smdo.ulMod       = c_ulModuleWriteDefault;
#else
    smdo.ulThread    = ThreadWriteThread | ThreadWriteContext | ThreadWriteStack;
    smdo.ulMod       = ModuleWriteModule | ModuleWriteMiscRecord | ModuleWriteDataSeg;
#endif
    smdo.dwThreadID  = pfrm->thidFault;
    smdo.dfOptions   = dfCollectSig;
    smdo.pvFaultAddr = pfrm->pvFaultAddr;
    smdo.pEP         = pfrm->pEP;
    smdo.fEPClient   = TRUE;
    smdo.wszModFullPath[0] = L'\0';
    wcscpy(smdo.wszAppFullPath, pfrm->wszExe);
    wcscpy(smdo.wszMod, L"unknown");
#ifdef MANIFEST_HEAP
    TESTBOOL(hr, InternalGenFullAndTriageMinidumps(hProc, pfrm->pidReqProcess,
                                                   pwszDump, hFile, &smdo, pfrm->fIs64bit));
#else
    TESTBOOL(hr, InternalGenerateMinidump(hProc, pfrm->pidReqProcess, hFile,
                                                   &smdo, pwszDump));
#endif

    if (FAILED(hr))
        goto done;

    // set the file to use NTFS compression- it is ok if this fails.
    usCompress = COMPRESSION_FORMAT_DEFAULT;
    TESTBOOL(hr, DeviceIoControl(hFile, FSCTL_SET_COMPRESSION, &usCompress,
                                 sizeof(usCompress), NULL, 0, &cb, NULL));

    // log an event- don't care if it fails or not.
    TESTHR(hr, LogUser(smdo.wszApp, smdo.rgAppVer, smdo.wszMod, smdo.rgModVer,
                       smdo.pvOffset, pfrm->fIs64bit, ER_USERCRASH_LOG));

    // build the blob we'll store with the filename in the registry
    cch = wcslen(smdo.wszAppFullPath) + 1;
    cb = sizeof(SQueuedFaultBlob) +
         (cch + wcslen(smdo.wszModFullPath) + 2) * sizeof(WCHAR);
    __try { pqfb = (SQueuedFaultBlob *)_alloca(cb); }
    __except(EXCEPTION_STACK_OVERFLOW) { pqfb = NULL; }
    if (pqfb == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    CopyMemory(&pqfb->rgAppVer, &smdo.rgAppVer, 4 * sizeof(DWORD));
    CopyMemory(&pqfb->rgModVer, &smdo.rgModVer, 4 * sizeof(DWORD));
    CopyMemory(&pqfb->stFault, &st, sizeof(st));
    pqfb->cbFB     = sizeof(SQueuedFaultBlob);
    pqfb->cbTotal  = cb;
    pqfb->fIs64bit = pfrm->fIs64bit;
    pqfb->pvOffset = smdo.pvOffset;

    pwsz = (WCHAR *)((BYTE *)pqfb + sizeof(SQueuedFaultBlob));

    pqfb->dwpAppPath = sizeof(SQueuedFaultBlob);
    pqfb->dwpModPath = sizeof(SQueuedFaultBlob) + cch * sizeof(WCHAR);

    CopyMemory(pwsz, smdo.wszAppFullPath, cch * sizeof(WCHAR));

    pwsz += cch;
    wcscpy(pwsz, smdo.wszModFullPath);

    // write out the value to our 'queue' in the registry.
    TESTERR(hr, RegSetValueExW(hkeyQ, pwszDump, 0, REG_BINARY, (LPBYTE)pqfb,
                               cb));
    if (FAILED(hr))
        goto done;

    // write out our app to the 'run' key so that the next admin to log
    //  in will see that a fault has occurred.
    TESTERR(hr, RegSetValueExW(hkeyRun, c_wszRVUFC, 0, REG_EXPAND_SZ,
                               (LPBYTE)c_wszRVVUFC, sizeof(c_wszRVVUFC)));
    if (FAILED(hr))
    {
        RegDeleteValueW(hkeyQ, pwszDump);
        goto done;
    }

    frrvRet = frrvOk;

done:
    dw = GetLastError();

    // if we failed, then clean everything up.
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (frrvRet != frrvOk && iFile <= 100 && pwszDump != NULL)
        DeleteFileW(pwszDump);
    if (sa.lpSecurityDescriptor != NULL)
        FreeSD((SECURITY_DESCRIPTOR *)sa.lpSecurityDescriptor);
    if (hkeyQ != NULL)
        RegCloseKey(hkeyQ);
    if (hkeyRun != NULL)
        RegCloseKey(hkeyRun);
    if (hProc != NULL)
        CloseHandle(hProc);

    SetLastError(dw);

    return frrvRet;
}

// **************************************************************************
EFaultRepRetVal APIENTRY ReportFaultDWM(SFaultRepManifest *pfrm,
                                        LPCWSTR wszDir, HANDLE hToken,
                                        LPVOID pvEnv, PROCESS_INFORMATION *ppi,
                                        LPWSTR wszDumpFile)
{
    USE_TRACING("ReportFaultDWM");

    CPFFaultClientCfg   oCfg;
    EFaultRepRetVal     frrvRet = frrvErrNoDW;
    SDWManifestBlob     dwmb;
    SMDumpOptions       smdo;
    HRESULT             hr = NOERROR;
    HANDLE              hProc = NULL;
#ifndef MANIFEST_HEAP
    HANDLE              hFile = INVALID_HANDLE_VALUE;
#endif
    LPWSTR              wszStage1, wszStage2, wszCorpPath;
    LPWSTR              wszManifest = NULL, wszDump = NULL, pwszAppCompat = NULL;
    DWORD               dw, cch, cchDir, cchSep = 0;
    WCHAR               wszAppName[MAX_PATH];
    HKEY                hkeyDebug = NULL;
    BOOL                fAllowSend = TRUE, fMSApp = FALSE, fShowDebug = FALSE;
    BYTE                *pbBuf = NULL;

    VALIDATEPARM(hr, (pfrm == NULL || pfrm->wszExe == NULL || ppi == NULL ||
                      wszDir == NULL || hToken == NULL || wszDumpFile == NULL ||
                      wszDir[0] == L'\0'));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // get the config info
    TESTHR(hr, oCfg.Read(eroPolicyRO));
    if (FAILED(hr))
        goto done;

    if (oCfg.get_ShowUI() == eedDisabled && oCfg.get_DoReport() == eedDisabled)
        goto done;

    // figure out how we're reporting / notifying the user
    if (oCfg.get_DoReport() == eedDisabled ||
        oCfg.ShouldCollect(pfrm->wszExe, &fMSApp) == FALSE)
        fAllowSend = FALSE;

    if (oCfg.get_ShowUI() == eedDisabled)
    {
        LPCWSTR  wszULPath = oCfg.get_DumpPath(NULL, 0);

        // check and make sure that we have a corporate path specified.  If we
        //  don't, bail
        if (wszULPath == NULL || *wszULPath == L'\0')
            goto done;
    }

    cchDir = wcslen(wszDir);
    cch = cchDir + sizeofSTRW(c_wszManFileName) + 4;
    __try { wszManifest = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszManifest = NULL; }
    if (wszManifest == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    wcscpy(wszManifest, wszDir);
    wszManifest[cchDir]     = L'\\';
    wszManifest[cchDir + 1] = L'\0';
    wcscat(wszManifest, c_wszManFileName);


    cchDir = wcslen(wszDir);
    cch = 2 * cchDir + wcslen(wszDumpFile) + sizeofSTRW(c_wszACFileName) + 4;
    __try { wszDump = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszDump = NULL; }
    if (wszDump == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    wcscpy(wszDump, wszDir);
    wszDump[cchDir]     = L'\\';
    wszDump[cchDir + 1] = L'\0';
    wcscat(wszDump, wszDumpFile);

    // checlk and see if we need to put a debug button on the DW dialog
    dw = RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRKAeDebug, 0, KEY_READ,
                       &hkeyDebug);
    if (dw == ERROR_SUCCESS)
    {
        LPWSTR  wszDebugger;
        WCHAR   wszAuto[32];
        DWORD   dwType, cbNeed;

        cbNeed = sizeof(wszAuto);
        dw = RegQueryValueExW(hkeyDebug, c_wszRVAuto, NULL, &dwType,
                              (LPBYTE)wszAuto, &cbNeed);
        if (dw != ERROR_SUCCESS || cbNeed == 0 || dwType != REG_SZ)
            goto doneDebugCheck;

        // only way to get here if Auto == 1 is if drwtsn32 is the JIT debugger
        if (wszAuto[0] == L'1')
            goto doneDebugCheck;

        cbNeed = 0;
        dw = RegQueryValueExW(hkeyDebug, c_wszRVDebugger, NULL, &dwType, NULL,
                              &cbNeed);
        if (dw != ERROR_SUCCESS || cbNeed == 0 || dwType != REG_SZ)
            goto doneDebugCheck;

        cbNeed += sizeof(WCHAR);
        __try { wszDebugger = (LPWSTR)_alloca(cbNeed); }
        __except(EXCEPTION_STACK_OVERFLOW) { wszDebugger = NULL; }
        if (wszDebugger == NULL)
            goto doneDebugCheck;

        dw = RegQueryValueExW(hkeyDebug, c_wszRVDebugger, NULL, NULL,
                              (LPBYTE)wszDebugger, &cbNeed);
        if (dw != ERROR_SUCCESS)
            goto doneDebugCheck;

        if (wszDebugger[0] != L'\0')
            fShowDebug = TRUE;

doneDebugCheck:
        RegCloseKey(hkeyDebug);
        hkeyDebug = NULL;
    }

#ifndef MANIFEST_HEAP
    hFile = CreateFileW(wszDump, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        SetLastError(dw);
        goto done;
    }
#endif  // !MANIFEST_HEAP

    // get a handle to the target process
    hProc = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE,
                        pfrm->pidReqProcess);
    if (hProc == NULL)
        goto done;

    // generate the minidump
    ZeroMemory(&smdo, sizeof(smdo));
#ifdef MANIFEST_HEAP
    smdo.ulThread    = c_ulThreadWriteDefault;
    smdo.ulMod       = c_ulModuleWriteDefault;
#else
    smdo.ulThread    = ThreadWriteThread | ThreadWriteContext | ThreadWriteStack;
    smdo.ulMod       = ModuleWriteModule | ModuleWriteMiscRecord | ModuleWriteDataSeg;
#endif
    smdo.dwThreadID  = pfrm->thidFault;
    smdo.dfOptions   = dfCollectSig;
    smdo.pvFaultAddr = pfrm->pvFaultAddr;
    smdo.pEP         = pfrm->pEP;
    smdo.fEPClient   = TRUE;
    smdo.wszModFullPath[0] = L'\0';
    wcscpy(smdo.wszAppFullPath, pfrm->wszExe);
    wcscpy(smdo.wszMod, L"unknown");
#ifdef MANIFEST_HEAP
    TESTBOOL(hr, InternalGenFullAndTriageMinidumps(hProc, pfrm->pidReqProcess,
                                                   wszDump, NULL, &smdo, pfrm->fIs64bit));
#else
    TESTBOOL(hr, InternalGenerateMinidump(hProc, pfrm->pidReqProcess, hFile,
                                            &smdo, wszDump));
#endif
    if (FAILED(hr))
        goto done;

    // log an event- don't care if it fails or not.
    TESTHR(hr, LogUser(smdo.wszApp, smdo.rgAppVer, smdo.wszMod, smdo.rgModVer,
                       smdo.pvOffset, pfrm->fIs64bit, ER_USERCRASH_LOG));


    // generate all the URLs & file paths we'll need for reporting
    TESTHR(hr, BuildManifestURLs(smdo.wszApp, smdo.wszMod, smdo.rgAppVer,
                                 smdo.rgModVer, smdo.pvOffset,
                                 pfrm->fIs64bit, &wszStage1, &wszStage2,
                                 &wszCorpPath, &pbBuf));
    if (FAILED(hr))
        goto done;


    TESTHR(hr, GetVerName(smdo.wszAppFullPath, wszAppName,
                          sizeofSTRW(wszAppName)));
    if (FAILED(hr))
        goto done;

    wszAppName[sizeofSTRW(wszAppName) - 1] = L'\0';

    // we created the wszDump buffer above big enuf to hold both the
    //  dumpfile path as well as the app compat filename.  So make
    //  use of that right now.
    cchSep = wcslen(wszDump);
    pwszAppCompat = wszDump + cchSep + 1;
    wcscpy(pwszAppCompat, wszDir);
    pwszAppCompat[cchDir]     = L'\\';
    pwszAppCompat[cchDir + 1] = L'\0';
    wcscat(pwszAppCompat, c_wszACFileName);

    // if we succeed, turn the NULL following the dump file path into
    //  the DW separator character
    TESTBOOL(hr, GetAppCompatData(smdo.wszAppFullPath, smdo.wszAppFullPath,
                                  pwszAppCompat));
    if (SUCCEEDED(hr))
        wszDump[cchSep] = DW_FILESEP;

    ZeroMemory(&dwmb, sizeof(dwmb));
    dwmb.wszTitle    = wszAppName;
    dwmb.nidErrMsg   = IDS_FERRMSG;
    dwmb.wszStage1   = wszStage1;
    dwmb.wszStage2   = wszStage2;
    dwmb.wszBrand    = c_wszDWBrand;
    dwmb.wszFileList = wszDump;
    dwmb.hToken      = hToken;
    dwmb.pvEnv       = pvEnv;
    dwmb.fIsMSApp    = fMSApp;
    dwmb.wszCorpPath = wszCorpPath;
    if (fShowDebug)
        dwmb.dwOptions = emoShowDebugButton;

    // check and see if the system is shutting down.  If so, CreateProcess is
    //  gonna pop up some annoying UI that we can't get rid of, so we don't
    //  want to call it if we know it's gonna happen.
    if (GetSystemMetrics(SM_SHUTTINGDOWN))
        goto done;

    // we get back the name of the manifest file here.  it will be up to the client to
    //  delete it.
    frrvRet = StartDWManifest(oCfg, dwmb, wszManifest, fAllowSend);

    CopyMemory(ppi, &dwmb.pi, sizeof(PROCESS_INFORMATION));

done:
    dw = GetLastError();

    if (pbBuf != NULL)
        MyFree(pbBuf);
    if (hProc != NULL)
        CloseHandle(hProc);
#ifndef MANIFEST_HEAP
    if (hFile != NULL)
        CloseHandle(hFile);
#endif
    if (frrvRet != frrvOk)
    {
        if (wszDump != NULL)
        {
            if (pwszAppCompat != NULL)
            {
                wszDump[cchSep] = L'\0';
                DeleteFileW(pwszAppCompat);
            }
#ifdef MANIFEST_HEAP
            DeleteFullAndTriageMiniDumps(wszDump);
#else
            DeleteFileW(wszDump);
#endif
        }
        if (wszManifest != NULL)
            DeleteFileW(wszManifest);
    }

    SetLastError(dw);

    return frrvRet;
}

// **************************************************************************
EFaultRepRetVal APIENTRY ReportFault(LPEXCEPTION_POINTERS pep, DWORD dwOpt)
{
    USE_TRACING("ReportFault");

    CPFFaultClientCfg   oCfg;
    EFaultRepRetVal     frrvRet = frrvErrNoDW;
    HRESULT             hr = NOERROR;
    WCHAR               wszFile[MAX_PATH], *pwsz;
    DWORD               dwFlags = 0;
    HKEY                hkey = NULL;
    BOOL                fUseExceptionMode = TRUE, fMSApp = FALSE;

    __try
    {
        VALIDATEPARM(hr, (pep == NULL));
        if (FAILED(hr))
            goto done;

        // get the config info
        TESTHR(hr, oCfg.Read(eroPolicyRO));
        if (FAILED(hr))
            goto done;

        // assume system is on a local drive with a base path of "X:\"
        if (oCfg.get_TextLog() == eedEnabled)
        {
            HANDLE hFaultLog = INVALID_HANDLE_VALUE;

            GetSystemDirectoryW(wszFile, sizeofSTRW(wszFile));
            wszFile[3] = L'\0';
            wcscat(wszFile, c_wszLogFileName);
            hFaultLog = CreateFileW(wszFile, GENERIC_WRITE,
                                    FILE_SHARE_WRITE | FILE_SHARE_READ,
                                    NULL, OPEN_ALWAYS, 0, NULL);
            if (hFaultLog != INVALID_HANDLE_VALUE)
            {
                SYSTEMTIME  st;
                DWORD       cb, cbWritten;
                char        szMsg[512];

                GetSystemTime(&st);
                GetModuleFileNameW(NULL, wszFile, sizeofSTRW(wszFile));
                cb = wsprintf(szMsg,
                              "%02d-%02d-%04d %02d:%02d:%02d User fault %08x in %ls\r\n",
                              st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute,
                              st.wSecond, pep->ExceptionRecord->ExceptionCode,
                              wszFile);
                SetFilePointer(hFaultLog, 0, NULL, FILE_END);
                WriteFile(hFaultLog, szMsg, cb, &cbWritten, NULL);
                CloseHandle(hFaultLog);
            }

            wszFile[0] = L'\0';
        }

        // if reporting and notification are both disabled, then there's nothing of
        //  great value that we're gonna do here, so bail.
        // Return frrvErrNoDW to indicate that we didn't do squat
        if (oCfg.get_ShowUI() == eedDisabled && oCfg.get_DoReport() == eedDisabled)
            goto done;

        // if setup is in progress, we want to just bail cuz we don't want to hang
        //  setup.  Also, the network isn't setup so we can't really report anyway.
        //  At some point, might want to cache this info & report on first launch.
        TESTERR(hr, RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRKSetup, 0, KEY_READ,
                                  &hkey));
        if (SUCCEEDED(hr))
        {
            DWORD cbData;
            DWORD dwData;

            cbData = sizeof(dwData);
            dwData = 0;
            TESTERR(hr, RegQueryValueExW(hkey, c_wszRVSetupNow, NULL, NULL,
                                         (LPBYTE)&dwData, &cbData));
            RegCloseKey(hkey);
            if (SUCCEEDED(hr) && dwData != 0)
                goto done;
        }

        if (oCfg.get_ShowUI() == eedDisabled)
        {
            LPCWSTR  wszULPath = oCfg.get_DumpPath(NULL, 0);

            fUseExceptionMode = TRUE;
            dwFlags |= fDwHeadless;

            // check and make sure that we have a corporate path specified.  If
            // we don't, bail
            if (wszULPath == NULL || *wszULPath == L'\0')
                goto done;
        }

        // don't want to go into this if we're already in the middle of reporting
        if (g_fAlreadyReportingFault)
            goto done;

        g_fAlreadyReportingFault = TRUE;

        // make sure we're not trying to report for DW or dumprep-
        GetModuleFileNameW(NULL, wszFile, sizeofSTRW(wszFile));
        for(pwsz = wszFile + wcslen(wszFile);
            pwsz >= wszFile && *pwsz != L'\\';
            pwsz--);
        if (*pwsz == L'\\')
            pwsz++;
        if (_wcsicmp(pwsz, L"dwwin.exe") == 0 ||
            _wcsicmp(pwsz, L"dumprep.exe") == 0)
            goto done;

        // figure out how we're reporting / notifying the user
        if (oCfg.get_DoReport() == eedDisabled ||
            oCfg.ShouldCollect(wszFile, &fMSApp) == FALSE)
            dwFlags |= fDwNoReporting;

        // if it's a MS app, set the flag that says we can have 'please help
        //  Microsoft' text in DW.
        if (fMSApp == FALSE)
            dwFlags |= fDwUseLitePlea;

        // if we're not headless, then we have to see if we have the correct
        //  security context to launch DW directly.  The correct security context
        //  is defined as the current process having the same security context as
        //  the user currently logged on interactively to the current session
        if (oCfg.get_ShowUI() != eedDisabled)
        {
            if (oCfg.get_ForceQueueMode())
            {
                fUseExceptionMode = FALSE;
            }
            else
            {
                fUseExceptionMode = DoUserContextsMatch();
                if (fUseExceptionMode == FALSE)
                    fUseExceptionMode = DoWinstaDesktopMatch() &&
                                        (AmIPrivileged(FALSE) == FALSE);
            }
        }

        // if we can use exception mode, then just go ahead and use the normal
        //  reporting mechanism (shared memory block, etc)
        if (fUseExceptionMode)
        {
            LPCWSTR pwszServer = oCfg.get_DefaultServer(NULL, 0);
            LPCSTR  szServer;
            char    szBuf[MAX_PATH];

            // determine what server we're going to send the data to.
            szBuf[0] = '\0';
            if (pwszServer != NULL && *pwszServer != L'\0')
                WideCharToMultiByte(CP_ACP, 0, pwszServer, -1, szBuf,
                                    sizeof(szBuf), NULL, NULL);

            if (szBuf[0] != '\0')
                szServer = szBuf;
            else
                szServer = (oCfg.get_UseInternal() == 1) ? c_szDWDefServerI :
                                                           c_szDWDefServerE;

            frrvRet = StartDWException(pep, dwOpt, dwFlags, szServer, -1);
        }

        // otherwise, have to use manifest, which of course means generating the
        //  minidump ourselves, parsing it for the signature, and everything else
        //  that DW does automatically for us...   Sigh...
        else
        {
            frrvRet = StartManifestReport(pep, wszFile, dwOpt, -1);
        }
    }
    __except(SetLastError(GetExceptionCode()), EXCEPTION_EXECUTE_HANDLER)
    {
    }

done:
    g_fAlreadyReportingFault = FALSE;
    return frrvRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\faultrep\frutil.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    faultrep.cpp

Abstract:
    Implements utility functions for fault reporting

Revision History:
    created     derekm      07/07/00

******************************************************************************/

#include "stdafx.h"
#include "dbghelp.h"
#include "wtsapi32.h"
#include "userenv.h"
#include "frmc.h"
#include "tlhelp32.h"
#include "shimdb.h"

///////////////////////////////////////////////////////////////////////////////
// typedefs

typedef BOOL (STDAPICALLTYPE *DUMPWRITE_FN)(HANDLE, DWORD, HANDLE,
                                            MINIDUMP_TYPE,
                                            PMINIDUMP_EXCEPTION_INFORMATION,
                                            PMINIDUMP_USER_STREAM_INFORMATION,
                                            PMINIDUMP_CALLBACK_INFORMATION);
typedef DWORD   (WINAPI *pfn_GETMODULEFILENAMEEXW)(HANDLE, HMODULE, LPWSTR, DWORD);


///////////////////////////////////////////////////////////////////////////////
// globals



///////////////////////////////////////////////////////////////////////////////
// useful structs

struct SLangCodepage
{
    WORD wLanguage;
    WORD wCodePage;
};


///////////////////////////////////////////////////////////////////////////////
// misc utility functions

// **************************************************************************
HMODULE MySafeLoadLibrary(LPCWSTR wszModule)
{
    HMODULE hmod = NULL;
    PVOID   pvLdrLockCookie = NULL;
    ULONG   ulLockState = 0;

    // make sure that no one else owns the loader lock because we
    //  could otherwise deadlock
    LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY, &ulLockState,
                      &pvLdrLockCookie);
    if (ulLockState == LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED)
    {
        __try { hmod = LoadLibraryExW(wszModule, NULL, 0); }
        __except(EXCEPTION_EXECUTE_HANDLER) { hmod = NULL; }
        LdrUnlockLoaderLock(0, pvLdrLockCookie);
    }

    return hmod;
}

// **************************************************************************
static inline WCHAR itox(DWORD dw)
{
    dw &= 0xf;
    return (WCHAR)((dw < 10) ? (L'0' + dw) : (L'A' + (dw - 10)));
}

// **************************************************************************
BOOL IsASCII(LPCWSTR wszSrc)
{
    const WCHAR *pwsz;

    // check and see if we need to hexify the string.  This is determined
    //  by whether the string contains all ASCII characters or not.  Since
    //  an ASCII character is defined as being in the range of 00 -> 7f, just
    //  'and' the wchar's value with ~0x7f and see if the result is 0.  If it
    //  is, then the whcar is an ASCII value.
    for (pwsz = wszSrc; *pwsz != L'\0'; pwsz++)
    {
        if ((*pwsz & ~0x7f) != 0)
            return FALSE;
    }

    return TRUE;
}

// **************************************************************************
BOOL IsValidField(LPWSTR wsz)
{
    WCHAR *pwsz;

    if (wsz == NULL)
        return FALSE;

    for(pwsz = wsz; *pwsz != L'\0'; pwsz++)
    {
        if (iswspace(*pwsz) == FALSE)
            return TRUE;
    }

    return FALSE;
}


// **************************************************************************
BOOL TransformForWire(LPCWSTR wszSrc, LPWSTR wszDest, DWORD cchDest)
{
    HRESULT     hr = NOERROR;
    DWORD       cch;

    USE_TRACING("TransformForWire");
    VALIDATEPARM(hr, (wszSrc == NULL || wszDest == NULL || cchDest < 5));
    if (FAILED(hr))
        goto done;

    if (cchDest > 5)
    {
        // darn!  Gotta convert every character to a 4 char hex value cuz this
        //  is what DW does and we have to match them
        for (cch = 0; *wszSrc != L'\0' && cch + 4 < cchDest; cch += 4, wszSrc++)
        {
            *wszDest++ = itox((*wszSrc & 0xf000) > 12);
            *wszDest++ = itox((*wszSrc & 0x0f00) > 8);
            *wszDest++ = itox((*wszSrc & 0x00f0) > 4);
            *wszDest++ = itox((*wszSrc & 0x000f));
        }

        // if we don't see this, then we've got too small of a buffer
        if (*wszSrc != L'\0' || cch >= cchDest)
        {
            hr = E_FAIL;
            goto done;
        }

        *wszDest = L'\0';
    }

    else
    {
        hr = E_FAIL;
    }

done:
    return (SUCCEEDED(hr));
}

// ***************************************************************************
LPWSTR MarshallString(LPCWSTR wszSrc, PBYTE pBase, ULONG cbMaxBuf,
                      PBYTE *ppToWrite, DWORD *pcbWritten)
{
    DWORD cb;
    PBYTE pwszNormalized;

    cb = (wcslen(wszSrc) + 1) * sizeof(WCHAR);

    if ((*pcbWritten + cb) > cbMaxBuf)
        return NULL;

    RtlMoveMemory(*ppToWrite, wszSrc, cb);

    // the normalized ptr is the current count
    pwszNormalized = (PBYTE)(*ppToWrite - pBase);

    // cb is always a mutliple of sizeof(WHCAR) so the pointer addition below
    //  always produces a result that is 2byte aligned (assuming the input was
    //  2byte aligned of course)
    *ppToWrite  += cb;
    *pcbWritten += cb;

    return (LPWSTR)pwszNormalized;
}

// **************************************************************************
HRESULT GetVerName(LPWSTR wszModule, LPWSTR wszName, DWORD cchName,
                   LPWSTR wszVer, DWORD cchVer,
                   LPWSTR wszCompany, DWORD cchCompany,
                   BOOL fAcceptUnicodeCP, BOOL fWantActualName)
{
    USE_TRACING("GetVerName");

    VS_FIXEDFILEINFO    *pffi;
    SLangCodepage       *plc;
    HRESULT             hr = NOERROR;
    WCHAR               wszQuery[128], *pwszProp = NULL;
    WCHAR               *pwszPropVal;
    DWORD               cbFVI, dwJunk, dwMSWin = 0;
    PBYTE               pbFVI = NULL;
    UINT                cb, cbVerInfo, i;

    SLangCodepage   rglc[] = { { 0,     0     },    // UI language if one exists
                               { 0x409, 0x4B0 },    // unicode English
                               { 0x409, 0x4E4 },    // English
                               { 0x409, 0     },    // English, null codepage
                               { 0    , 0x4E4 } };  // language neutral.

    VALIDATEPARM(hr, (wszModule == NULL || wszName == NULL || cchName == 0));
    if (FAILED(hr))
        goto done;

    if (wszCompany != NULL)
        *wszCompany = L'\0';
    if (wszVer != NULL)
        wcsncpy(wszVer, L"0.0.0.0", cchVer);

    if (fWantActualName)
    {
        *wszName = L'\0';
    }
    else
    {
        for(pwszPropVal = wszModule + wcslen(wszModule);
            pwszPropVal >= wszModule && *pwszPropVal != L'\\';
            pwszPropVal--);
        if (*pwszPropVal == L'\\')
            pwszPropVal++;
        wcsncpy(wszName, pwszPropVal, cchName);
        wszName[cchName - 1] = L'\0';
    }

    // dwJunk is a useful parameter. Gotta pass it in so the function call
    //  set it to 0.  Gee this would make a great (tho non-efficient)
    //  way to set DWORDs to 0.  Much better than saying dwJunk = 0 by itself.
    cbFVI = GetFileVersionInfoSizeW(wszModule, &dwJunk);
    TESTBOOL(hr, (cbFVI != 0));
    if (FAILED(hr))
    {
        // if it fails, assume the file doesn't have any version info &
        //  return S_FALSE
        hr = S_FALSE;
        goto done;
    }

    // alloca only throws exceptions so gotta catch 'em here...
    __try
    {
        __try{ pbFVI = (PBYTE)_alloca(cbFVI); }
        __except(EXCEPTION_STACK_OVERFLOW) { pbFVI = NULL; }

        _ASSERT(pbFVI != NULL);
        hr = NOERROR;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        pbFVI = NULL;
    }
    VALIDATEEXPR(hr, (pbFVI == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    cb = cbFVI;
    TESTBOOL(hr, GetFileVersionInfoW(wszModule, 0, cbFVI, (LPVOID *)pbFVI));
    if (FAILED(hr))
    {
        // if it fails, assume the file doesn't have any version info &
        //  return S_FALSE
        hr = S_FALSE;
        goto done;
    }

    // determine if it's a MS app or windows componenet
    dwMSWin = IsMicrosoftApp(NULL, pbFVI, cbFVI);

    // get the real version info- apparently, the string can occasionally
    //  be out of sync (so says the explorer.exe code that extracts ver info)
    if (wszVer != NULL &&
        VerQueryValueW(pbFVI, L"\\", (LPVOID *)&pffi, &cb) && cb != 0)
    {
        WCHAR wszVerTemp[64];
        swprintf(wszVerTemp, L"%d.%d.%d.%d", HIWORD(pffi->dwFileVersionMS),
                 LOWORD(pffi->dwFileVersionMS), HIWORD(pffi->dwFileVersionLS),
                 LOWORD(pffi->dwFileVersionLS));
        wcsncpy(wszVer, wszVerTemp, cchVer);
        wszVer[cchVer - 1] = L'\0';
    }

    // try to figure out what the appropriate langage...
    TESTBOOL(hr, VerQueryValueW(pbFVI, L"\\VarFileInfo\\Translation",
                                (LPVOID *)&plc, &cbVerInfo));
    if (SUCCEEDED(hr))
    {
        LANGID  langid;
        DWORD   cLangs, iUni = (DWORD)-1;
        UINT    uiACP;

        langid = GetUserDefaultUILanguage();
        cLangs = cbVerInfo / sizeof(SLangCodepage);
        uiACP  = GetACP();

        // see if there's a language that matches the default
        for(i = 0; i < cLangs; i++)
        {
            // not sure what to do if there are multiple code pages for a
            //  particular language.  Just take the first, I guess...
            if (langid == plc[i].wLanguage && uiACP == plc[i].wCodePage)
                break;

            // if we can accept the unicode code page & we encounter a
            //  launguage with it, then remember it.  Note that we only
            //  remember the first such instance we see or one that matches
            //  the target language
            if (fAcceptUnicodeCP && plc[i].wCodePage == 1200 &&
                (iUni == (DWORD)-1 || langid == plc[i].wLanguage))
                iUni = i;
        }

        if (i >= cLangs && iUni != (DWORD)-1)
            i = iUni;

        if (i < cLangs)
        {
            rglc[0].wLanguage = plc[i].wLanguage;
            rglc[0].wCodePage = plc[i].wCodePage;
        }
    }

    for(i = 0; i < 5; i++)
    {
        if (rglc[i].wLanguage == 0 && rglc[i].wCodePage == 0)
            continue;

        swprintf(wszQuery, L"\\StringFileInfo\\%04x%04x\\FileVersion",
                 rglc[i].wLanguage, rglc[i].wCodePage);

        // Retrieve file description for language and code page 'i'.
        TESTBOOL(hr, VerQueryValueW(pbFVI, wszQuery,
                                    (LPVOID *)&pwszPropVal, &cb));
        if (SUCCEEDED(hr) && cb != 0)
        {
            // want to get size of a normal char string & not a unicode
            //  string cuz we'd have to / sizeof(WCHAR) otherwise
            pwszProp = wszQuery + sizeof("\\StringFileInfo\\%04x%04x\\") - 1;
            break;
        }
    }

    // if we still didn't find anything, then assume there's no version
    //  resource.  We've already set the defaults above, so we can bail...
    if (pwszProp == NULL)
    {
        hr = NOERROR;
        goto done;
    }

    if (wszCompany != NULL)
    {
        wcscpy(pwszProp, L"CompanyName");
        TESTBOOL(hr, VerQueryValueW(pbFVI, wszQuery, (LPVOID *)&pwszPropVal,
                                    &cb));
        if (SUCCEEDED(hr) && cb != 0)
        {
            wcsncpy(wszCompany, pwszPropVal, cchCompany);
            wszCompany[cchCompany - 1] = L'\0';
        }
    }

    // So to fix the case where Windows components did not properly update
    //  the product strings, we have to look for the FileDescription first.
    //  But since the OCA folks want only the description (convieniently
    //  when the fWantActualName field is set) then we need to only read
    //  the ProductName field.
    if (fWantActualName)
    {
        wcscpy(pwszProp, L"ProductName");
        TESTBOOL(hr, VerQueryValueW(pbFVI, wszQuery, (LPVOID *)&pwszPropVal,
                                    &cb));
        if (SUCCEEDED(hr) && cb != 0 && IsValidField(pwszPropVal))
        {
            wcsncpy(wszName, pwszPropVal, cchName);
            wszName[cchName - 1] = L'\0';
            goto done;
        }
    }

    else
    {
        wcscpy(pwszProp, L"FileDescription");
        TESTBOOL(hr, VerQueryValueW(pbFVI, wszQuery, (LPVOID *)&pwszPropVal,
                                    &cb));
        if (SUCCEEDED(hr) && cb != 0 && IsValidField(pwszPropVal))
        {
            wcsncpy(wszName, pwszPropVal, cchName);
            wszName[cchName - 1] = L'\0';
            goto done;
        }

        if ((dwMSWin & APP_WINCOMP) == 0)
        {
            wcscpy(pwszProp, L"ProductName");
            TESTBOOL(hr, VerQueryValueW(pbFVI, wszQuery,
                                        (LPVOID *)&pwszPropVal, &cb));
            if (SUCCEEDED(hr) && cb != 0 && IsValidField(pwszPropVal))
            {
                wcsncpy(wszName, pwszPropVal, cchName);
                wszName[cchName - 1] = L'\0';
                goto done;
            }
        }

        wcscpy(pwszProp, L"InternalName");
        TESTBOOL(hr, VerQueryValueW(pbFVI, wszQuery,
                                    (LPVOID *)&pwszPropVal, &cb));
        if (SUCCEEDED(hr) && cb != 0 && IsValidField(pwszPropVal))
        {
            wcsncpy(wszName, pwszPropVal, cchName);
            wszName[cchName - 1] = L'\0';
            goto done;
        }
    }

    // We didn't find a name string but we've defaulted
    // the name and we may have other valid data, so
    // return success.
    hr = S_OK;
    
done:
    return hr;
}

// **************************************************************************
HRESULT BuildManifestURLs(LPWSTR wszAppName, LPWSTR wszModName,
                          WORD rgAppVer[4], WORD rgModVer[4], UINT64 pvOffset,
                          BOOL f64Bit, LPWSTR *ppwszS1, LPWSTR *ppwszS2,
                          LPWSTR *ppwszCP, BYTE **ppb)
{
    HRESULT hr = NOERROR;
    LPWSTR  pwszApp, pwszMod;
    LPWSTR  wszStage1, wszStage2, wszCorpPath;
    DWORD   cbNeeded, cch;
    WCHAR   *pwsz;
    BYTE    *pbBuf = NULL;

    USE_TRACING("BuildManifestURLs");
    VALIDATEPARM(hr, (wszAppName == NULL || wszModName == NULL ||
                      ppwszS1 == NULL || ppwszS2 == NULL || ppwszCP == NULL ||
                      ppb == NULL));
    if (FAILED(hr))
        goto done;

    *ppb     = NULL;
    *ppwszS1 = NULL;
    *ppwszS2 = NULL;
    *ppwszCP = NULL;

    // hexify the app name if necessary
    if (IsASCII(wszAppName))
    {
        pwszApp = wszAppName;
    }
    else
    {
        cch = (4 * wcslen(wszAppName) + 1);
        __try { pwszApp = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
        __except(EXCEPTION_STACK_OVERFLOW) { pwszApp = NULL; }
        if (pwszApp != NULL)
        {
            if (TransformForWire(wszAppName, pwszApp, cch) == FALSE)
                *pwszApp = L'\0';
        }
        else
        {
            pwszApp = wszAppName;
        }
    }

    // hexify the module name if necessary
    if (IsASCII(wszModName))
    {
        pwszMod = wszModName;
    }
    else
    {
        cch = (4 * wcslen(wszModName) + 1);
        __try { pwszMod = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
        __except(EXCEPTION_STACK_OVERFLOW) { pwszMod = NULL; }
        if (pwszMod != NULL)
        {
            if (TransformForWire(wszModName, pwszMod, cch) == FALSE)
                *pwszMod = L'\0';
        }
        else
        {
            pwszMod = wszModName;
        }
    }

    // determine how big of a buffer we need & alloc it
#ifdef _WIN64
    if (f64Bit)
        cbNeeded = c_cbFaultBlob64 + 3 * (wcslen(pwszMod) + wcslen(pwszApp)) * sizeof(WCHAR);
    else
#endif
        cbNeeded = c_cbFaultBlob32 + 3 * (wcslen(pwszMod) + wcslen(pwszApp)) * sizeof(WCHAR);

    pbBuf = (BYTE *)MyAlloc(cbNeeded);
    VALIDATEEXPR(hr, (pbBuf == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
        goto done;

    // write out the actual strings
#ifdef _WIN64
    if (f64Bit)
    {
        wszStage1 = (WCHAR *)pbBuf;
        cch = swprintf(wszStage1, c_wszManFS164,
                       pwszApp,
                       rgAppVer[0], rgAppVer[1], rgAppVer[2], rgAppVer[3],
                       pwszMod,
                       rgModVer[0], rgModVer[1], rgModVer[2], rgModVer[3],
                       pvOffset);

        wszStage2 = wszStage1 + cch + 1;
        cch = swprintf(wszStage2, c_wszManFS264,
                       pwszApp,
                       rgAppVer[0], rgAppVer[1], rgAppVer[2], rgAppVer[3],
                       pwszMod,
                       rgModVer[0], rgModVer[1], rgModVer[2], rgModVer[3],
                       pvOffset);

        wszCorpPath = wszStage2 + cch + 1;
        cch = swprintf(wszCorpPath, c_wszManFCP64,
                       pwszApp,
                       rgAppVer[0], rgAppVer[1], rgAppVer[2], rgAppVer[3],
                       pwszMod,
                       rgModVer[0], rgModVer[1], rgModVer[2], rgModVer[3],
                       pvOffset);
    }
    else
#endif
    {
        wszStage1 = (WCHAR *)pbBuf;
        cch = swprintf(wszStage1, c_wszManFS132,
                       pwszApp,
                       rgAppVer[0], rgAppVer[1], rgAppVer[2], rgAppVer[3],
                       pwszMod,
                       rgModVer[0], rgModVer[1], rgModVer[2], rgModVer[3],
                       (LPVOID)pvOffset);

        wszStage2 = wszStage1 + cch + 1;
        cch = swprintf(wszStage2, c_wszManFS232,
                       pwszApp,
                       rgAppVer[0], rgAppVer[1], rgAppVer[2], rgAppVer[3],
                       pwszMod,
                       rgModVer[0], rgModVer[1], rgModVer[2], rgModVer[3],
                       (LPVOID)pvOffset);

        wszCorpPath = wszStage2 + cch + 1;
        cch = swprintf(wszCorpPath, c_wszManFCP32,
                       pwszApp,
                       rgAppVer[0], rgAppVer[1], rgAppVer[2], rgAppVer[3],
                       pwszMod,
                       rgModVer[0], rgModVer[1], rgModVer[2], rgModVer[3],
                       (LPVOID)pvOffset);
    }

    // need to convert all '.'s to '_'s cuz URLs don't like dots.
    for (pwsz = wszStage1; *pwsz != L'\0'; pwsz++)
    {
        if (*pwsz == L'.')
            *pwsz = L'_';
    }

    // ok, on the end of the stage 1 URL is a .htm, and we really don't want to
    //  convert that '.' to a '_', so back up and reconvert it back to a '.'
    pwsz -= 4;
    if (*pwsz == L'_')
        *pwsz = L'.';

    *ppwszS1 = wszStage1;
    *ppwszS2 = wszStage2;
    *ppwszCP = wszCorpPath;
    *ppb     = pbBuf;

    pbBuf    = NULL;

done:
    if (pbBuf != NULL)
        MyFree(pbBuf);

    return hr;
}



// **************************************************************************
HRESULT GetExePath(HANDLE hProc, LPWSTR wszPath, DWORD cchPath)
{
    USE_TRACING("GetExePath");

    pfn_GETMODULEFILENAMEEXW    pfn;
    HRESULT                     hr = NOERROR;
    HMODULE                     hmod = NULL;
    DWORD                       dw;

    VALIDATEPARM(hr, (wszPath == NULL || hProc == NULL || cchPath < MAX_PATH));
    if (FAILED(hr))
        goto done;

    hmod = MySafeLoadLibrary(L"psapi.dll");
    TESTBOOL(hr, (hmod != NULL));
    if (FAILED(hr))
        goto done;

    pfn = (pfn_GETMODULEFILENAMEEXW)GetProcAddress(hmod, "GetModuleFileNameExW");
    TESTBOOL(hr, (pfn != NULL));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, ((*pfn)(hProc, NULL, wszPath, cchPath) != 0));
    if (FAILED(hr))
        goto done;

done:
    dw = GetLastError();

    if (hmod != NULL)
        FreeLibrary(hmod);

    SetLastError(dw);

    return hr;
}

// ***************************************************************************
DWORD GetAppCompatFlag(LPCWSTR wszPath, LPCWSTR wszSysDir, LPWSTR wszBuffer)
{
    LPWSTR  pwszFile, wszSysDirLocal = NULL, pwszDir = NULL;
    DWORD   dwOpt = (DWORD)-1;
    DWORD   cchPath, cch;
    UINT    uiDrive;

    if (wszPath == NULL || wszBuffer == NULL || wszSysDir == NULL)
        goto done;

    // can't be a valid path if it's less than 3 characters long
    cchPath = wcslen(wszPath);
    if (cchPath < 3)
        goto done;

    // do we have a UNC path?
    if (wszPath[0] == L'\\' && wszPath[1] == L'\\')
    {
        dwOpt = GRABMI_FILTER_THISFILEONLY;
        goto done;
    }

    // ok, maybe a remote mapped path or system32?
    wcscpy(wszBuffer, wszPath);
    for(pwszFile = wszBuffer + cchPath;
        *pwszFile != L'\\' && pwszFile > wszBuffer;
        pwszFile--);
    if (*pwszFile == L'\\')
        *pwszFile = L'\0';
    else
        goto done;

    cch = wcslen(wszSysDir) + 1;
    __try { wszSysDirLocal = (LPWSTR)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_EXECUTE_HANDLER) { wszSysDirLocal = NULL; }
    if (wszSysDirLocal == NULL)
        goto done;

    // see if it's in system32 or in any parent folder of it.
    wcscpy(wszSysDirLocal, wszSysDir);
    pwszDir = wszSysDirLocal + cch;
    do
    {
        if (_wcsicmp(wszBuffer, wszSysDirLocal) == 0)
        {
            dwOpt = GRABMI_FILTER_SYSTEM;
            goto done;
        }

        for(;
            *pwszDir != L'\\' && pwszDir > wszSysDirLocal;
            pwszDir--);
        if (*pwszDir == L'\\')
            *pwszDir = L'\0';

    }
    while (pwszDir > wszSysDirLocal);

    // is the file sitting in the root of a drive?
    if (pwszFile <= &wszBuffer[3])
    {
        dwOpt = GRABMI_FILTER_THISFILEONLY;
        goto done;
    }


    // well, if we've gotten this far, then the path is in the form of
    //  X:\<something>, so cut off the <something> and find out if we're on
    //  a mapped drive or not
    *pwszFile    = L'\\';
    wszBuffer[3] = L'\0';
    switch(GetDriveTypeW(wszBuffer))
    {
        case DRIVE_UNKNOWN:
        case DRIVE_NO_ROOT_DIR:
            goto done;

        case DRIVE_REMOTE:
            dwOpt = GRABMI_FILTER_THISFILEONLY;
            goto done;
    }

    dwOpt = GRABMI_FILTER_PRIVACY;

done:
    return dwOpt;
}

// ***************************************************************************
typedef BOOL (APIENTRY *pfn_SDBGRABMATCHINGINFOW)(LPCWSTR, DWORD, LPCWSTR);
BOOL GetAppCompatData(LPCWSTR wszAppPath, LPCWSTR wszModPath, LPCWSTR wszFile)
{
    pfn_SDBGRABMATCHINGINFOW    pfn = NULL;
    HMODULE                     hmod = NULL;
    LPWSTR                      pwszPath = NULL, pwszFile = NULL;
    WCHAR                       *pwsz;
    DWORD                       cchSysDir, cchNeed, cchApp = 0, cchMod = 0;
    DWORD                       dwModOpt = (DWORD)-1, dwAppOpt = (DWORD)-1;
    DWORD                       dwOpt;
    BOOL                        fRet = FALSE;
    HRESULT                     hr;

    USE_TRACING("GetAppCompatData");

    VALIDATEPARM(hr, (wszAppPath == NULL || wszFile == NULL || 
        wszAppPath[0] == L'\0' || wszFile[0] == L'\0'));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // load the apphelp dll.
    cchNeed = GetSystemDirectoryW(NULL, 0);
    if (cchNeed == 0)
        goto done;

    if (sizeofSTRW(L"\\apphelp.dll") > sizeofSTRW(L"\\kernel32.dll"))
        cchNeed += (sizeofSTRW(L"\\apphelp.dll") + 8);
    else
        cchNeed += (sizeofSTRW(L"\\kernel32.dll") + 8);
    __try { pwszPath = (WCHAR *)_alloca(cchNeed * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { pwszPath = NULL; }
    if (pwszPath == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    cchSysDir = GetSystemDirectoryW(pwszPath, cchNeed);
    if (cchSysDir == 0)
        goto done;

    cchApp = wcslen(wszAppPath);
    if (wszModPath != NULL)
        cchMod = wcslen(wszModPath);
    cchNeed = MyMax(cchApp, cchMod) + 8;
    __try { pwszFile = (WCHAR *)_alloca(cchNeed * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { pwszFile = NULL; }
    if (pwszFile == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    // find out the app & module option flag
    dwAppOpt = GetAppCompatFlag(wszAppPath, pwszPath, pwszFile);
    if (wszModPath != NULL && wszModPath[0] != L'\0' &&
        _wcsicmp(wszModPath, wszAppPath) != 0)
    {
#if 0
        dwModOpt = GetAppCompatFlag(wszModPath, pwszPath, pwszFile);
        // no need to grab system data twice.  If we're already grabbing
        //  it for the app, don't grab it for the module.  Yes, we may end
        //  up grabbing the mod twice if it happens to be one of the system
        //  modules, but that's ok.
        if (dwModOpt == GRABMI_FILTER_SYSTEM &&
            dwAppOpt == GRABMI_FILTER_SYSTEM)
            dwModOpt = GRABMI_FILTER_THISFILEONLY;
#else
        dwModOpt = GRABMI_FILTER_THISFILEONLY;
#endif
    }

    // load the libarary
    wcscpy(&pwszPath[cchSysDir], L"\\apphelp.dll");
    hmod = MySafeLoadLibrary(pwszPath);
    if (hmod == NULL)
        goto done;

    // if we don't find the function, then just bail...
    pfn = (pfn_SDBGRABMATCHINGINFOW)GetProcAddress(hmod, "SdbGrabMatchingInfo");
    if (pfn == NULL)
        goto done;

    // call the function to get the app data
    if (dwAppOpt != (DWORD)-1)
    {
        dwOpt = dwAppOpt;
        if (dwModOpt != (DWORD)-1 ||
            (dwModOpt != GRABMI_FILTER_SYSTEM &&
             dwAppOpt != GRABMI_FILTER_SYSTEM))
            dwOpt |= GRABMI_FILTER_NOCLOSE;

        __try { fRet = (*pfn)(wszAppPath, dwOpt, wszFile); }
        __except(EXCEPTION_EXECUTE_HANDLER) { fRet = FALSE; DBG_MSG("GrabAppData crashed");}
        if (fRet == FALSE)
            goto done;
    }

    // call the function to get the mod data
    if (dwModOpt != (DWORD)-1)
    {
        dwOpt = dwModOpt;
        if (dwAppOpt != (DWORD)-1)
            dwOpt |= GRABMI_FILTER_APPEND;
        if (dwAppOpt != GRABMI_FILTER_SYSTEM &&
            dwModOpt != GRABMI_FILTER_SYSTEM)
            dwOpt |= GRABMI_FILTER_NOCLOSE;

        __try { fRet = (*pfn)(wszModPath, dwOpt, wszFile); }
        __except(EXCEPTION_EXECUTE_HANDLER) { fRet = FALSE;  DBG_MSG("GrabModData crashed");}
        if (fRet == FALSE)
            goto done;
    }

    // call the function to get the data for kernel32
    if (dwModOpt != GRABMI_FILTER_SYSTEM &&
        dwAppOpt != GRABMI_FILTER_SYSTEM)
    {
        wcscpy(&pwszPath[cchSysDir], L"\\kernel32.dll");

        dwOpt = GRABMI_FILTER_THISFILEONLY;
        if (dwModOpt != (DWORD)-1 || dwAppOpt != (DWORD)-1)
            dwOpt |= GRABMI_FILTER_APPEND;

        __try { fRet = (*pfn)(pwszPath, dwOpt, wszFile); }
        __except(EXCEPTION_EXECUTE_HANDLER) { fRet = FALSE;  DBG_MSG("GrabKrnlData crashed");}
        if (fRet == FALSE)
            goto done;
    }

done:
    if (fRet == FALSE)
        DeleteFileW(wszFile);
    if (hmod != NULL)
    {
        __try { FreeLibrary(hmod); }
        __except(EXCEPTION_EXECUTE_HANDLER) { }
    }

    return fRet;
}

//////////////////////////////////////////////////////////////////////////////
//  ThreadStuff

// ***************************************************************************
BOOL FreezeAllThreads(DWORD dwpid, DWORD dwtidFilter, SSuspendThreads *pst)
{
    THREADENTRY32   te;
    HANDLE          hTokenImp = NULL;
    HANDLE          hsnap = (HANDLE)-1, hth = NULL;
    HANDLE          *rgh = NULL;
    DWORD           dwtid = GetCurrentThreadId();
    DWORD           cThreads = 0, cSlots = 0, dw;
    BOOL            fContinue = FALSE, fRet = FALSE;

    if (pst == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    pst->rghThreads = NULL;
    pst->cThreads   = 0;

    // if we have an impersonation token on this thread, revert it back to
    //  full access cuz otherwise we could fail in the OpenThread API below.
    // Even if we fail, we'll still try all the rest of the stuff below.
    if (OpenThreadToken(GetCurrentThread(), TOKEN_READ | TOKEN_IMPERSONATE,
                        TRUE, &hTokenImp))
        RevertToSelf();

    hsnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, dwpid);
    if (hsnap == (HANDLE)-1)
        goto done;

    ZeroMemory(&te, sizeof(te));
    te.dwSize = sizeof(te);

    fContinue = Thread32First(hsnap, &te);
    while(fContinue)
    {
        // only want to freeze threads in my process (not including the
        //  currently executing one, of course, since that would bring
        //  everything to a grinding halt.)
        if (te.th32OwnerProcessID == dwpid && te.th32ThreadID != dwtidFilter)
        {
            hth = OpenThread(THREAD_SUSPEND_RESUME, FALSE, te.th32ThreadID);
            if (hth != NULL)
            {
                if (cSlots == cThreads)
                {
                    HANDLE  *rghNew = NULL;
                    DWORD   cNew = (cSlots == 0) ? 8 : cSlots * 2;

                    rghNew = (HANDLE *)MyAlloc(cNew * sizeof(HANDLE));
                    if (rghNew == NULL)
                    {
                        SetLastError(ERROR_OUTOFMEMORY);
                        goto done;
                    }

                    if (rgh != NULL)
                        CopyMemory(rghNew, rgh, cSlots * sizeof(HANDLE));

                    MyFree(rgh);
                    rgh    = rghNew;
                    cSlots = cNew;
                }

                // if the suspend fails, then just don't add it to the
                //  list...
                if (SuspendThread(hth) == (DWORD)-1)
                    CloseHandle(hth);
                else
                    rgh[cThreads++] = hth;

                hth = NULL;
            }
        }

        fContinue = Thread32Next(hsnap, &te);
    }

    pst->rghThreads = rgh;
    pst->cThreads   = cThreads;


    SetLastError(0);
    fRet = TRUE;

done:
    dw = GetLastError();

    if (hTokenImp != NULL)
    {
        SetThreadToken(NULL, hTokenImp);
        CloseHandle(hTokenImp);
    }

    if (fRet == FALSE && rgh != NULL)
    {
        DWORD i;
        for (i = 0; i < cThreads; i++)
        {
            if (rgh[i] != NULL)
            {
                ResumeThread(rgh[i]);
                CloseHandle(rgh[i]);
            }
        }

        MyFree(rgh);
    }

    // MSDN says to use CloseToolhelp32Snapshot() to close the snapshot.
    //  the tlhelp32.h header file says to use CloseHandle & doens't provide
    //   a CloseToolhelp32Snapshot() function.  Hence, I'm using CloseHandle
    //   for now.
    if (hsnap != (HANDLE)-1)
        CloseHandle(hsnap);

    SetLastError(dw);

    return fRet;
}

// ***************************************************************************
BOOL ThawAllThreads(SSuspendThreads *pst)
{
    DWORD   i;

    if (pst == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (pst->rghThreads == NULL)
        return TRUE;

    for (i = 0; i < pst->cThreads; i++)
    {
        if (pst->rghThreads[i] != NULL)
        {
            ResumeThread(pst->rghThreads[i]);
            CloseHandle(pst->rghThreads[i]);
        }
    }

    MyFree(pst->rghThreads);

    pst->rghThreads = NULL;
    pst->cThreads   = 0;

    SetLastError(0);
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
//  Minidump

// ***************************************************************************
BOOL WINAPI MDCallback(void *pvCallbackParam,
                       CONST PMINIDUMP_CALLBACK_INPUT pCallbackInput,
                       PMINIDUMP_CALLBACK_OUTPUT pCallbackOutput)
{
//    USE_TRACING("MDCallback");

    SMDumpOptions   *psmdo = (SMDumpOptions *)pvCallbackParam;

    if (pCallbackInput == NULL || pCallbackOutput == NULL || psmdo == NULL)
        return TRUE;

    // what did we get called back for?
    switch(pCallbackInput->CallbackType)
    {
        case ModuleCallback:
            pCallbackOutput->ModuleWriteFlags = psmdo->ulMod;

            // only need to do this extra work if we're getting a minidump
            if ((psmdo->dfOptions & dfCollectSig) != 0)
            {
                MINIDUMP_MODULE_CALLBACK    *pmmc = &pCallbackInput->Module;
                LPWSTR                      pwsz = NULL;

                // err, if we don't have a path, can't do squat, so skip it
                if (pmmc->FullPath != NULL && pmmc->FullPath[0] != L'\0')
                {
                    // is it the app?
                    if (_wcsicmp(pmmc->FullPath, psmdo->wszAppFullPath) == 0)
                    {
                        pCallbackOutput->ModuleWriteFlags |= ModuleWriteDataSeg;
                        psmdo->rgAppVer[0] = HIWORD(pmmc->VersionInfo.dwFileVersionMS);
                        psmdo->rgAppVer[1] = LOWORD(pmmc->VersionInfo.dwFileVersionMS);
                        psmdo->rgAppVer[2] = HIWORD(pmmc->VersionInfo.dwFileVersionLS);
                        psmdo->rgAppVer[3] = LOWORD(pmmc->VersionInfo.dwFileVersionLS);

                        // get a pointer to the end of the modulename string
                        for(pwsz = pmmc->FullPath + wcslen(pmmc->FullPath);
                            *pwsz != L'\\' && pwsz > pmmc->FullPath;
                            pwsz--);
                        if (*pwsz == L'\\')
                            pwsz++;

                        // get the app name, if we can make it fit
                        if (wcslen(pwsz) < sizeofSTRW(psmdo->wszApp))
                            wcscpy(psmdo->wszApp, pwsz);
                        else
                            wcscpy(psmdo->wszApp, L"unknown");
                    }
                }

                // is it the module?
                if (psmdo->pvFaultAddr >= pmmc->BaseOfImage &&
                    psmdo->pvFaultAddr <= pmmc->BaseOfImage + pmmc->SizeOfImage)
                {
                    pCallbackOutput->ModuleWriteFlags |= ModuleWriteDataSeg;
                    psmdo->rgModVer[0] = HIWORD(pmmc->VersionInfo.dwFileVersionMS);
                    psmdo->rgModVer[1] = LOWORD(pmmc->VersionInfo.dwFileVersionMS);
                    psmdo->rgModVer[2] = HIWORD(pmmc->VersionInfo.dwFileVersionLS);
                    psmdo->rgModVer[3] = LOWORD(pmmc->VersionInfo.dwFileVersionLS);

                    if (pwsz == NULL)
                    {
                        // get a pointer to the end of the modulename string
                        for(pwsz = pmmc->FullPath + wcslen(pmmc->FullPath);
                            *pwsz != L'\\' && pwsz > pmmc->FullPath;
                            pwsz--);
                        if (*pwsz == L'\\')
                            pwsz++;
                    }

                    if (pwsz != NULL && wcslen(pwsz) < sizeofSTRW(psmdo->wszMod))
                    {
                        // get the full path if we can make it fit
                        if (wcslen(pmmc->FullPath) < sizeofSTRW(psmdo->wszModFullPath))
                            wcscpy(psmdo->wszModFullPath, pmmc->FullPath);
                        else
                            psmdo->wszModFullPath[0] = L'\0';

                        // get the module name, if we can make it fit
                        if (wcslen(pwsz) < sizeofSTRW(psmdo->wszMod))
                            wcscpy(psmdo->wszMod, pwsz);
                        else
                            wcscpy(psmdo->wszMod, L"unknown");

                        psmdo->pvOffset = psmdo->pvFaultAddr - pmmc->BaseOfImage;
                    }
                }
            }
            break;

        case ThreadCallback:
            // are we collecting info for a single thread only?
            if ((psmdo->dfOptions & dfFilterThread) != 0)
            {
                if (psmdo->dwThreadID == pCallbackInput->Thread.ThreadId)
                    pCallbackOutput->ThreadWriteFlags = psmdo->ulThread;
                else
                    pCallbackOutput->ThreadWriteFlags = 0;
            }

            // or are we collecting special info for a single thread?
            else if ((psmdo->dfOptions & dfFilterThreadEx) != 0)
            {
                if (psmdo->dwThreadID == pCallbackInput->Thread.ThreadId)
                    pCallbackOutput->ThreadWriteFlags = psmdo->ulThreadEx;
                else
                    pCallbackOutput->ThreadWriteFlags = psmdo->ulThread;
            }

            // or maybe we're just getting a generic ol' minidump...
            else
            {
                pCallbackOutput->ThreadWriteFlags = psmdo->ulThread;
            }

            break;

        default:
            break;
    }

    return TRUE;
}

// **************************************************************************
#ifndef MANIFEST_HEAP
BOOL InternalGenerateMinidump(HANDLE hProc, DWORD dwpid, HANDLE hFile,
                                SMDumpOptions *psmdo, LPCWSTR wszPath)
#else
BOOL InternalGenerateMinidumpEx(HANDLE hProc, DWORD dwpid, HANDLE hFile,
                                SMDumpOptions *psmdo, LPCWSTR wszPath, BOOL f64bit)
#endif  // MANIFEST_HEAP
{
#ifdef _WIN64
    USE_TRACING("InternalGenerateMinidumpEx64(handle)");
#else
    USE_TRACING("InternalGenerateMinidumpEx(handle)");
#endif
    SMDumpOptions   smdo;
    HRESULT         hr = NULL;
    LPWSTR          wszMod = NULL;
    DWORD           cch, cchNeed;
    BOOL            fRet = FALSE;

    VALIDATEPARM(hr, (hProc == NULL || hFile == NULL ||
                      hFile == INVALID_HANDLE_VALUE));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    cchNeed = GetSystemDirectoryW(NULL, 0);
    if (cchNeed == 0)
        return FALSE;

    cchNeed += (sizeofSTRW(c_wszDbgHelpDll) + 8);
    __try { wszMod = (LPWSTR)_alloca(cchNeed * sizeof(WCHAR)); }
    __except(EXCEPTION_EXECUTE_HANDLER) { wszMod = NULL; }
    if (wszMod == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    cch = GetSystemDirectoryW(wszMod, cchNeed);
    if (cch == 0)
        return FALSE;

    if (*(wszMod + cch - 1) == L'\\')
        *(wszMod + cch - 1) = L'\0';

    // default is to write everything for everything
    if (psmdo == NULL)
    {
        ZeroMemory(&smdo, sizeof(smdo));
        smdo.ulThread = ThreadWriteThread | ThreadWriteStack | ThreadWriteContext;
        smdo.ulMod    = ModuleWriteModule | ModuleWriteMiscRecord | ModuleWriteDataSeg;
        psmdo         = &smdo;
    }

    // if we're in the same process, we can't call the minidump APIs directly
    //  cuz we'll hang the process.
    if (dwpid == GetCurrentProcessId())
    {
        PROCESS_INFORMATION pi;
        STARTUPINFOW        si;
        LPWSTR              wszCmdLine = NULL;
        HANDLE              hmem = NULL;
        LPVOID              pvmem = NULL;
        DWORD               dw;

        if (wszPath == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto done;
        }

        // 32 is the max size of a 64 bit decimal # & a 32 bit decimal #
        cchNeed = sizeofSTRW(c_wszDRCmdLineMD) + cch + wcslen(wszPath) + 32;
        __try { wszCmdLine = (LPWSTR)_alloca(cchNeed * sizeof(WCHAR)); }
        __except(EXCEPTION_STACK_OVERFLOW) { wszCmdLine = NULL; }
        TESTBOOL(hr, wszCmdLine != NULL);
        if (FAILED(hr))
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }

        hmem = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
                                 0, sizeof(smdo), NULL);
        TESTBOOL(hr, hmem != NULL);
        if (FAILED(hr))
            goto done;

        ZeroMemory(&pi, sizeof(pi));
        ZeroMemory(&si, sizeof(si));

        pvmem = MapViewOfFile(hmem, FILE_MAP_WRITE | FILE_MAP_READ, 0, 0, 0);
        TESTBOOL(hr, pvmem != NULL);

        if (FAILED(hr))
            goto doneProcSpawn;

        si.cb        = sizeof(si);
        swprintf(wszCmdLine, c_wszDRCmdLineMD, wszMod, dwpid, wszPath, hmem);
        if (CreateProcessW(NULL, wszCmdLine, NULL, NULL, TRUE, 0, NULL,
                           wszMod, &si, &pi))
        {
            if (pi.hThread != NULL)
                CloseHandle(pi.hThread);
            if (!pi.hProcess)
            {
                DWORD dwAwShit = GetLastError();
                ErrorTrace(0, "Spawned process died: \'%S\', err=0x%x", wszCmdLine, dwAwShit);
                SetLastError(dwAwShit);
            }

            // wait 2m for the dump to be complete
            if (pi.hProcess != NULL &&
                WaitForSingleObject(pi.hProcess, 120000) == WAIT_OBJECT_0)
                fRet = TRUE;
        }

doneProcSpawn:
        dw = GetLastError();
        if (pvmem != NULL)
            UnmapViewOfFile(pvmem);
        if (hmem != NULL)
            CloseHandle(hmem);
        if (pi.hProcess != NULL)
            CloseHandle(pi.hProcess);
        SetLastError(dw);
    }
    else
    {
        MINIDUMP_EXCEPTION_INFORMATION  mei, *pmei = NULL;
        MINIDUMP_CALLBACK_INFORMATION   mci;
        DUMPWRITE_FN                    pfn;
        HMODULE                         hmod = NULL;

        ZeroMemory(&mci, sizeof(mci));
        mci.CallbackRoutine = MDCallback;
        mci.CallbackParam   = psmdo;

        // if we got exception paramters in the blob, use 'em...
        if (psmdo->pEP != NULL)
        {
            ZeroMemory(&mei, sizeof(mei));
            mei.ExceptionPointers = (PEXCEPTION_POINTERS)(DWORD_PTR)psmdo->pEP;
            mei.ClientPointers    = psmdo->fEPClient;
            mei.ThreadId          = psmdo->dwThreadID;

            pmei = &mei;
        }

        wcscat(wszMod, c_wszDbgHelpDll);

        hmod = MySafeLoadLibrary(wszMod);
        if (hmod != NULL)
        {

            pfn = (DUMPWRITE_FN)GetProcAddress(hmod, "MiniDumpWriteDump");
            if (pfn != NULL)
            {
                DWORD dwEC;
                MINIDUMP_TYPE MiniDumpType = MiniDumpNormal;
#ifdef MANIFEST_HEAP
                if (psmdo->fIncludeHeap)
                {
                    MiniDumpType = (MINIDUMP_TYPE) (MiniDumpWithDataSegs |
                                                    MiniDumpWithProcessThreadData |
                                                    MiniDumpWithHandleData |
                                                    MiniDumpWithPrivateReadWriteMemory |
                                                    MiniDumpWithUnloadedModules);
                } else
                {
                    MiniDumpType = (MINIDUMP_TYPE) (MiniDumpWithDataSegs |
                                                    MiniDumpWithUnloadedModules);
                }
#endif  // MANIFEST_HEAP

                fRet = (pfn)(hProc, dwpid, hFile, MiniDumpType,
                                                 pmei, NULL, &mci);
                if (!fRet)
                {
                    ErrorTrace(0, "MiniDumpWriteDump failed: DumpType=0x%x, err=0x%x", MiniDumpType, GetLastError());
                    fRet = FALSE;
                }
            }

            FreeLibrary(hmod);

        }
    }

done:
    return fRet;
}

// **************************************************************************
#ifndef MANIFEST_HEAP
BOOL InternalGenerateMinidump(HANDLE hProc, DWORD dwpid, LPCWSTR wszPath,
                              SMDumpOptions *psmdo)
#else
BOOL InternalGenerateMinidump(HANDLE hProc, DWORD dwpid, LPCWSTR wszPath,
                              SMDumpOptions *psmdo, BOOL f64bit)
#endif
{
#ifdef _WIN64
    USE_TRACING("InternalGenerateMinidump64(path)");
#else
    USE_TRACING("InternalGenerateMinidump(path)");
#endif

    HRESULT hr = NOERROR;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    BOOL    fRet = FALSE;



    VALIDATEPARM(hr, (hProc == NULL || wszPath == NULL));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hFile = CreateFileW(wszPath, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, 0,
                        NULL);
    TESTBOOL(hr, (hFile != INVALID_HANDLE_VALUE));
    if (FAILED(hr))
        return FALSE;

#ifdef MANIFEST_HEAP
    fRet = InternalGenerateMinidumpEx(hProc, dwpid, hFile, psmdo, wszPath, f64bit);
#else
    fRet = InternalGenerateMinidump(hProc, dwpid, hFile, psmdo, wszPath);
#endif
    CloseHandle(hFile);
    return fRet;
}

#ifdef MANIFEST_HEAP
// This generates a triage minidump on the given wszPath and then generates a
// full minidump on wszPath with c_wszHeapDumpSuffix
BOOL
InternalGenFullAndTriageMinidumps(HANDLE hProc, DWORD dwpid, LPCWSTR wszPath,
                                  HANDLE hFile, SMDumpOptions *psmdo, BOOL f64bit)
{
#ifdef _WIN64
    USE_TRACING("InternalGenFullAndTriageMinidumps(path)");
#else
    USE_TRACING("InternalGenFullAndTriageMinidumps(path)");
#endif

    HRESULT hr = NOERROR;
    BOOL    fRet = FALSE;
    LPWSTR  wszFullMinidump = NULL;
    DWORD   cch;
    SMDumpOptions smdoFullMini;

    VALIDATEPARM(hr, (hProc == NULL || wszPath == NULL));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (hFile)
    {
        fRet = InternalGenerateMinidumpEx(hProc, dwpid, hFile, psmdo, wszPath, f64bit);
    } else
    {
        fRet = InternalGenerateMinidump(hProc, dwpid, wszPath, psmdo, f64bit);
    }
    if (!fRet)
    {
        return fRet;
    }

    cch = wcslen(wszPath) + sizeofSTRW(c_wszHeapDumpSuffix);
    __try { wszFullMinidump = (WCHAR *)_alloca(cch * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszFullMinidump = NULL; }
    if (wszFullMinidump)
    {
        LPWSTR wszFileExt = NULL;

        ZeroMemory(&smdoFullMini, sizeof(SMDumpOptions));
        memcpy(&smdoFullMini, psmdo, sizeof(SMDumpOptions));

        // Build Dump-with-heap path
        wcsncpy(wszFullMinidump, wszPath, cch);
        wszFileExt = wszFullMinidump + wcslen(wszFullMinidump) - sizeofSTRW(c_wszDumpSuffix) + 1;
        if (!wcscmp(wszFileExt, c_wszDumpSuffix))
        {
            *wszFileExt = L'\0';
        }
        wcsncat(wszFullMinidump, c_wszHeapDumpSuffix, cch);

        smdoFullMini.fIncludeHeap = TRUE;
        fRet = InternalGenerateMinidump(hProc, dwpid, wszFullMinidump, &smdoFullMini, f64bit);
    }
    return fRet;
}

BOOL
CopyFullAndTriageMiniDumps(
    LPWSTR pwszTriageDumpFrom,
    LPWSTR pwszTriageDumpTo
    )
{
    BOOL fRet;
    LPWSTR  wszFullMinidumpFrom = NULL, wszFullMinidumpTo = NULL;
    DWORD   cch;

    fRet = CopyFileW(pwszTriageDumpFrom, pwszTriageDumpTo, FALSE);

    if (fRet)
    {
        LPWSTR wszFileExt;

        cch = wcslen(pwszTriageDumpFrom) + sizeofSTRW(c_wszHeapDumpSuffix);
        __try { wszFullMinidumpFrom = (WCHAR *)_alloca(cch * sizeof(WCHAR)); }
        __except(EXCEPTION_STACK_OVERFLOW) { wszFullMinidumpFrom = NULL; }

        if (wszFullMinidumpFrom)
        {
            wcsncpy(wszFullMinidumpFrom, pwszTriageDumpFrom, cch);
            wszFileExt = wszFullMinidumpFrom + wcslen(wszFullMinidumpFrom) -
                sizeofSTRW(c_wszDumpSuffix) + 1;
            if (!wcscmp(wszFileExt, c_wszDumpSuffix))
            {
                *wszFileExt = L'\0';
            }
            wcsncat(wszFullMinidumpFrom, c_wszHeapDumpSuffix, cch);
        }


        cch = wcslen(pwszTriageDumpTo) + sizeofSTRW(c_wszHeapDumpSuffix);
        __try { wszFullMinidumpTo = (WCHAR *)_alloca(cch * sizeof(WCHAR)); }
        __except(EXCEPTION_STACK_OVERFLOW) { wszFullMinidumpTo = NULL; }
        if (wszFullMinidumpTo)
        {
            wcsncpy(wszFullMinidumpTo, pwszTriageDumpTo, cch);
            wszFileExt = wszFullMinidumpTo + wcslen(wszFullMinidumpTo) -
                sizeofSTRW(c_wszDumpSuffix) + 1;
            if (!wcscmp(wszFileExt, c_wszDumpSuffix))
            {
                *wszFileExt = L'\0';
            }
            wcsncat(wszFullMinidumpTo, c_wszHeapDumpSuffix, cch);
            if (wszFullMinidumpFrom)
            {
                fRet = CopyFileW(wszFullMinidumpFrom, wszFullMinidumpTo, FALSE);
            }

        }

    }
    return fRet;
}


HRESULT
FindFullMinidump(
    LPWSTR pwszDumpFileList,
    LPWSTR pwszFullMiniDump,
    ULONG cchwszFullMiniDump
    )
//
// This Grabs dump file name from pwszDumpFileList and then derives the fullminidump name.
// The full dump is returned in pwszFullMiniDump.
//
{
    LPWSTR wszSrch, wszFiles;
    LPWSTR wszOriginalDump = NULL;
    DWORD cchOriginalDump = 0;
    DWORD cchFile, cch;
    HRESULT Hr, hr;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    USE_TRACING("FindFullMinidump");

    VALIDATEPARM(hr, (pwszFullMiniDump == NULL || 
                      pwszDumpFileList == NULL || 
                      !cchwszFullMiniDump));
    if (FAILED(hr))
    {
        return E_INVALIDARG;
    }

    pwszFullMiniDump[0] = L'\0';
    // Look through file list to find minidump file
    wszFiles = pwszDumpFileList;
    while (wszFiles && *wszFiles)
    {
        wszSrch = wcschr(wszFiles, DW_FILESEP);
        if (!wszSrch)
        {
            wszSrch = wszFiles + wcslen(wszFiles);
        }

        // wszSrch now points after end of first file in wszFiles
        if (!wcsncmp(wszSrch - sizeofSTRW(c_wszDumpSuffix) + 1,
                     c_wszDumpSuffix,  sizeofSTRW(c_wszDumpSuffix) - 1))
        {
            // its the dump file
            cchOriginalDump = (DWORD) wcslen(wszFiles) - wcslen(wszSrch);

            __try { wszOriginalDump = (WCHAR *)_alloca((cchOriginalDump+1) * sizeof(WCHAR)); }
            __except(EXCEPTION_STACK_OVERFLOW) { wszOriginalDump = NULL; DBG_MSG("out of stack");}

            if (wszOriginalDump)
                wcsncpy(wszOriginalDump, wszFiles, cchOriginalDump);

            break;
        }
        wszFiles = wszSrch;
        if (*wszFiles == L'\0')
        {
            break;
        }
        wszFiles++;
    }

    VALIDATEPARM(hr, ((wszOriginalDump == NULL) || (cchOriginalDump == 0)));
    if (FAILED(hr))
    {
        return E_INVALIDARG;
    }

    // Now build the full dump file name
    wcscpy(pwszFullMiniDump, wszOriginalDump);
    pwszFullMiniDump[cchOriginalDump - sizeofSTRW(c_wszDumpSuffix) + 1] = L'\0';
    wcscat(pwszFullMiniDump, c_wszHeapDumpSuffix);

    // check if the dump exists. although we cannot do much if dump doesn't
    // exist.
    hFile = CreateFileW(pwszFullMiniDump, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0,
                    NULL);
    VALIDATEPARM(hr,  (hFile != INVALID_HANDLE_VALUE));
    if (FAILED(hr))
    {
        Hr = S_OK;
        CloseHandle( hFile );
        hFile = NULL;
    } else
    {
        ErrorTrace(0, "Could not open \'%S\'", pwszFullMiniDump);
        Hr = E_FAIL;
    }

    return Hr;
}
#endif  // MANIFEST_HEAP

//////////////////////////////////////////////////////////////////////////////
//  DW manifest mode utils

// **************************************************************************
EFaultRepRetVal StartDWManifest(CPFFaultClientCfg &oCfg, SDWManifestBlob &dwmb,
                                LPWSTR wszManifestIn, BOOL fAllowSend,
                                DWORD dwTimeout)
{
    USE_TRACING("StartDWManifest");

    OSVERSIONINFOEXW    ovi;
    EFaultRepRetVal     frrvRet = frrvErrNoDW;
    STARTUPINFOW        si;
    HRESULT             hr = NOERROR;
    LPCWSTR             pwszServer, pwszCorpPath;
    LPCWSTR             wszBrand;
    HANDLE              hManifest = INVALID_HANDLE_VALUE;
    WCHAR               wszManifestTU[MAX_PATH+16], wszDir[MAX_PATH];
    WCHAR               wszBuffer[1025];
#ifdef MANIFEST_HEAP
    LPWSTR              pwszMiniDump = NULL;
#endif
    DWORD               cbToWrite, dw, dwFlags;

    VALIDATEPARM(hr, (dwmb.wszStage2 == NULL ||
                      (dwmb.nidTitle == 0 && dwmb.wszTitle == NULL)));
    if (FAILED(hr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // if we get passed a manifest file & we can use it, then do so.
    if (wszManifestIn != NULL && wszManifestIn[0] != L'\0' &&
        wcslen(wszManifestIn) < sizeofSTRW(wszManifestTU))
    {
        wcscpy(wszManifestTU, wszManifestIn);
    }

    // ok, figure out the temp dir & then generate the filename
    else
    {
        GetTempPathW(sizeofSTRW(wszDir), wszDir);
        GetTempFileNameW(wszDir, L"DWM", 0, wszManifestTU);
    }

    hManifest = CreateFileW(wszManifestTU, GENERIC_WRITE, FILE_SHARE_READ,
                            NULL, CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL);
    TESTBOOL(hr, (hManifest != INVALID_HANDLE_VALUE));
    if (FAILED(hr))
        goto done;

    // write the leading 0xFFFE out to the file
    wszBuffer[0] = 0xFEFF;
    TESTBOOL(hr, WriteFile(hManifest, wszBuffer, sizeof(wszBuffer[0]), &dw,
             NULL));
    if (FAILED(hr))
        goto done;


    // write out the server, LCID, Brand, Flags, & title
    //  Server=<server>
    //  UI LCID=GetSystemDefaultLCID()
    //  Flags=fDWWhister + fDWUserHKLM + headless if necessary
    //  Brand=<Brand>  ("WINDOWS" by default)
    //  TitleName=<title>

    wszBrand = (dwmb.wszBrand != NULL) ? dwmb.wszBrand : c_wszDWBrand;

    // determine what server we're going to send the data to.
    pwszServer = oCfg.get_DefaultServer(NULL, 0);
    if (pwszServer == NULL || *pwszServer == L'\0')
    {
        pwszServer = (oCfg.get_UseInternal() == 1) ? c_wszDWDefServerI :
                                                     c_wszDWDefServerE;
    }

    if (oCfg.get_ShowUI() == eedDisabled)
    {
        DBG_MSG("Headless mode");
        dwFlags = fDwWhistler | fDwHeadless | fDwUseHKLM | fDwAllowSuspend | fDwMiniDumpWithUnloadedModules;
    }
    else
        dwFlags = fDwWhistler | fDwUseHKLM | fDwAllowSuspend | fDwMiniDumpWithUnloadedModules;

    if (fAllowSend == FALSE)
        dwFlags |= fDwNoReporting;

    // if it's a MS app, set the flag that says we can have 'please help Microsoft'
    //  text in DW.
    if (dwmb.fIsMSApp == FALSE)
        dwFlags |= fDwUseLitePlea;

    if ((dwmb.dwOptions & emoUseIEforURLs) == emoUseIEforURLs)
        dwFlags |= fDwUseIE;

    if ((dwmb.dwOptions & emoSupressBucketLogs) == emoSupressBucketLogs)
        dwFlags |= fDwSkipBucketLog;

    if ((dwmb.dwOptions & emoNoDefCabLimit) == emoNoDefCabLimit)
        dwFlags |= fDwNoDefaultCabLimit;

    if ((dwmb.dwOptions & emoShowDebugButton) == emoShowDebugButton)
        dwFlags |= fDwManifestDebug;


    cbToWrite = swprintf(wszBuffer, c_wszManMisc, pwszServer,
                         GetUserDefaultUILanguage(), dwFlags, wszBrand);
    cbToWrite *= sizeof(WCHAR);
    TESTBOOL(hr, WriteFile(hManifest, wszBuffer, cbToWrite, &dw, NULL));
    if (FAILED(hr))
        goto done;

    // write out the title text
    {
        LPCWSTR  wszOut;

        if (dwmb.wszTitle != NULL)
        {
            wszOut    = dwmb.wszTitle;
            cbToWrite = wcslen(wszOut);
        }
        else
        {
            wszOut = wszBuffer;
            cbToWrite = LoadStringW(g_hInstance, dwmb.nidTitle, wszBuffer,
                                    sizeofSTRW(wszBuffer));
            if (cbToWrite == 0)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto done;
            }
        }

        cbToWrite *= sizeof(WCHAR);
        TESTBOOL(hr, WriteFile(hManifest, wszOut, cbToWrite, &dw, NULL));
        if (FAILED(hr))
            goto done;
    }

    // write out dig PID path
    //  DigPidRegPath=HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\DigitalProductId

    TESTBOOL(hr, WriteFile(hManifest, c_wszManPID,
                           sizeof(c_wszManPID) - sizeof(WCHAR), &dw,
                           NULL));
    if (FAILED(hr))
        goto done;

    // write out the registry subpath for policy info
    //  RegSubPath==Microsoft\\PCHealth\\ErrorReporting\\DW

    TESTBOOL(hr, WriteFile(hManifest, c_wszManSubPath,
                           sizeof(c_wszManSubPath) - sizeof(WCHAR), &dw,
                           NULL));
    if (FAILED(hr))
        goto done;


    // write out the error message if we have one
    //  ErrorText=<error text read from resource>

    if (dwmb.wszErrMsg != NULL || dwmb.nidErrMsg != 0)
    {
        LPCWSTR wszOut;

        TESTBOOL(hr, WriteFile(hManifest, c_wszManErrText,
                               sizeof(c_wszManErrText) - sizeof(WCHAR), &dw,
                               NULL));
        if (FAILED(hr))
            goto done;

        if (dwmb.wszErrMsg != NULL)
        {
            wszOut    = dwmb.wszErrMsg;
            cbToWrite = wcslen(wszOut);
        }
        else
        {
            wszOut = wszBuffer;
            cbToWrite = LoadStringW(g_hInstance, dwmb.nidErrMsg, wszBuffer,
                                    sizeofSTRW(wszBuffer));
            if (cbToWrite == 0)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto done;
            }
        }

        cbToWrite *= sizeof(WCHAR);
        TESTBOOL(hr, WriteFile(hManifest, wszOut, cbToWrite, &dw, NULL));
        if (FAILED(hr))
            goto done;
    }

    // write out the header text if we have one
    //  HeaderText=<header text read from resource>

    if (dwmb.wszHdr != NULL || dwmb.nidHdr != 0)
    {
        LPCWSTR  wszOut;

        TESTBOOL(hr, WriteFile(hManifest, c_wszManHdrText,
                               sizeof(c_wszManHdrText) - sizeof(WCHAR), &dw,
                               NULL));
        if (FAILED(hr))
            goto done;

        if (dwmb.wszHdr != NULL)
        {
            wszOut    = dwmb.wszHdr;
            cbToWrite = wcslen(wszOut);
        }
        else
        {
            wszOut = wszBuffer;
            cbToWrite = LoadStringW(g_hInstance, dwmb.nidHdr, wszBuffer,
                                    sizeofSTRW(wszBuffer));
            if (cbToWrite == 0)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto done;
            }
        }

        cbToWrite *= sizeof(WCHAR);
        TESTBOOL(hr, WriteFile(hManifest, wszOut, cbToWrite, &dw, NULL));
        if (FAILED(hr))
            goto done;
    }


    // write out the plea text if we have one
    //  Plea=<plea text>

    if (dwmb.wszPlea != NULL)
    {
        TESTBOOL(hr, WriteFile(hManifest, c_wszManPleaText,
                               sizeof(c_wszManPleaText) - sizeof(WCHAR), &dw,
                               NULL));
        if (FAILED(hr))
            goto done;

        cbToWrite = wcslen(dwmb.wszPlea) * sizeof(WCHAR);
        TESTBOOL(hr, WriteFile(hManifest, dwmb.wszPlea, cbToWrite, &dw, NULL));
        if (FAILED(hr))
            goto done;
    }


    // write out the plea text if we have one
    //  ReportButton=<button text>

    if (dwmb.wszSendBtn != NULL && dwmb.wszSendBtn[0] != L'\0')
    {
        TESTBOOL(hr, WriteFile(hManifest, c_wszManSendText,
                               sizeof(c_wszManSendText) - sizeof(WCHAR), &dw,
                               NULL));
        if (FAILED(hr))
            goto done;

        cbToWrite = wcslen(dwmb.wszSendBtn) * sizeof(WCHAR);
        TESTBOOL(hr, WriteFile(hManifest, dwmb.wszSendBtn, cbToWrite, &dw, NULL));
        if (FAILED(hr))
            goto done;
    }

    // write out the plea text if we have one
    //  NoReportButton=<button text>

    if (dwmb.wszNoSendBtn != NULL && dwmb.wszNoSendBtn[0] != L'\0')
    {
        TESTBOOL(hr, WriteFile(hManifest, c_wszManNSendText,
                               sizeof(c_wszManNSendText) - sizeof(WCHAR), &dw,
                               NULL));
        if (FAILED(hr))
            goto done;

        cbToWrite = wcslen(dwmb.wszNoSendBtn) * sizeof(WCHAR);
        TESTBOOL(hr, WriteFile(hManifest, dwmb.wszNoSendBtn, cbToWrite, &dw, NULL));
        if (FAILED(hr))
            goto done;
    }

    // write out the plea text if we have one
    //  EventLogSource=<button text>

    if (dwmb.wszEventSrc != NULL && dwmb.wszEventSrc[0] != L'\0')
    {
        TESTBOOL(hr, WriteFile(hManifest, c_wszManEventSrc,
                               sizeof(c_wszManEventSrc) - sizeof(WCHAR), &dw,
                               NULL));
        if (FAILED(hr))
            goto done;

        cbToWrite = wcslen(dwmb.wszEventSrc) * sizeof(WCHAR);
        TESTBOOL(hr, WriteFile(hManifest, dwmb.wszEventSrc, cbToWrite, &dw, NULL));
        if (FAILED(hr))
            goto done;
    }


    // write out the stage 1 URL if there is one
    //  Stage1URL=<stage 1 URL>

    if (dwmb.wszStage1 != NULL && dwmb.wszStage1[0] != L'\0')
    {
        TESTBOOL(hr, WriteFile(hManifest, c_wszManStageOne,
                               sizeof(c_wszManStageOne) - sizeof(WCHAR), &dw,
                               NULL));
        if (FAILED(hr))
            goto done;

        cbToWrite = wcslen(dwmb.wszStage1) * sizeof(WCHAR);
        TESTBOOL(hr, WriteFile(hManifest, dwmb.wszStage1, cbToWrite, &dw, NULL));
        if (FAILED(hr))
            goto done;
    }


    // write out the stage 2 URL
    //  Stage2URL=<stage 2 URL>

    TESTBOOL(hr, WriteFile(hManifest, c_wszManStageTwo,
                           sizeof(c_wszManStageTwo) - sizeof(WCHAR), &dw,
                           NULL));
    if (FAILED(hr))
        goto done;

    cbToWrite = wcslen(dwmb.wszStage2) * sizeof(WCHAR);
    TESTBOOL(hr, WriteFile(hManifest, dwmb.wszStage2, cbToWrite, &dw, NULL));
    if (FAILED(hr))
        goto done;

    // write out files to collect if we have any
    //  DataFiles=<list of files to include in cab>

    if (dwmb.wszFileList != NULL && dwmb.wszFileList[0] != L'\0')
    {
        TESTBOOL(hr, WriteFile(hManifest, c_wszManFiles,
                               sizeof(c_wszManFiles) - sizeof(WCHAR), &dw,
                               NULL));
        if (FAILED(hr))
            goto done;

        cbToWrite = wcslen(dwmb.wszFileList) * sizeof(WCHAR);
        TESTBOOL(hr, WriteFile(hManifest, dwmb.wszFileList, cbToWrite, &dw, NULL));
        if (FAILED(hr))
            goto done;
    }
#ifdef MANIFEST_HEAP
    // write out dump file with heap info if we have any
    //  Heap=<dump file which has heap info>
    __try { pwszMiniDump = (LPWSTR)_alloca((wcslen(dwmb.wszFileList) + 1) * sizeof(WCHAR)); }
    __except(EXCEPTION_STACK_OVERFLOW) { pwszMiniDump = NULL; DBG_MSG("Out of stack");}

    if (pwszMiniDump)
    {
        TESTHR(hr, FindFullMinidump((LPWSTR)dwmb.wszFileList, pwszMiniDump,
                             wcslen(dwmb.wszFileList) + 1));
        if (SUCCEEDED(hr))
        {
            if (pwszMiniDump != NULL && pwszMiniDump[0] != L'\0')
            {
                TESTBOOL(hr, WriteFile(hManifest, c_wszManHeapDump,
                                       sizeof(c_wszManHeapDump) - sizeof(WCHAR), &dw,
                                       NULL));
                if (FAILED(hr))
                    goto done;

                cbToWrite = wcslen(pwszMiniDump) * sizeof(WCHAR);
                TESTBOOL(hr, WriteFile(hManifest, pwszMiniDump, cbToWrite, &dw, NULL));
                if (FAILED(hr))
                    goto done;
            }
        }
    }
#endif  // MANIFEST_HEAP

    // write out corporate mode subpath
    //  ErrorSubPath=<subpath for the error signature>

    pwszCorpPath = oCfg.get_DumpPath(NULL, 0);
    if (pwszCorpPath != NULL && pwszCorpPath != L'\0' &&
        dwmb.wszCorpPath != NULL && dwmb.wszCorpPath[0] != L'\0')
    {
        TESTBOOL(hr, WriteFile(hManifest, c_wszManCorpPath,
                               sizeof(c_wszManCorpPath) - sizeof(WCHAR), &dw,
                               NULL));
        if (FAILED(hr))
            goto done;

        cbToWrite = wcslen(dwmb.wszCorpPath) * sizeof(WCHAR);
        TESTBOOL(hr, WriteFile(hManifest, dwmb.wszCorpPath, cbToWrite, &dw, NULL));
        if (FAILED(hr))
            goto done;

    }



    // write out the final "\r\n"

    wszBuffer[0] = L'\r';
    wszBuffer[1] = L'\n';
    TESTBOOL(hr, WriteFile(hManifest, wszBuffer, 2 * sizeof(wszBuffer[0]), &dw,
                           NULL));
    if (FAILED(hr))
        goto done;

    CloseHandle(hManifest);
    hManifest = INVALID_HANDLE_VALUE;

    // create the process
    GetSystemDirectoryW(wszDir, sizeofSTRW(wszDir));
    swprintf(wszBuffer, c_wszDWCmdLineKH, wszDir, wszManifestTU);

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    // check and see if the system is shutting down.  If so, CreateProcess is
    //  gonna pop up some annoying UI that we can't get rid of, so we don't
    //  want to call it if we know it's gonna happen.
    if (GetSystemMetrics(SM_SHUTTINGDOWN))
    {
        DBG_MSG("shutting down");
        goto done;
    }

    // we're creating the process in the same user context that we're in
    if (dwmb.hToken == NULL)
    {

        ErrorTrace(0, "starting CreateProcessW(\'%S\')", wszBuffer);

        si.lpDesktop = L"Winsta0\\Default";
        TESTBOOL(hr, CreateProcessW(NULL, wszBuffer, NULL, NULL, TRUE,
                                    CREATE_DEFAULT_ERROR_MODE |
                                    NORMAL_PRIORITY_CLASS,
                                    NULL, wszDir, &si, &dwmb.pi));
        if (FAILED(hr))
            goto done;

        // don't need the thread handle & we gotta close it, so close it now
        CloseHandle(dwmb.pi.hThread);

        // wait 5 minutes for DW to close.  If it doesn't close by then, just
        //  return.
        dw = WaitForSingleObject(dwmb.pi.hProcess, dwTimeout);
        CloseHandle(dwmb.pi.hProcess);

        switch (dw)
        {
        case WAIT_FAILED:
            ErrorTrace(0, "Wait error: 0x%x", GetLastError());
            break;
        case WAIT_TIMEOUT:
            DBG_MSG("wait timeout");
            frrvRet = frrvErrTimeout;
            goto done;
            break;
        case WAIT_OBJECT_0:
            DBG_MSG("DW finished OK");
            GetExitCodeProcess(dwmb.pi.hProcess, &dw);
            ErrorTrace(0, "DW finished OK, exit code=0x%x", dw);
            break;
        default:
            ErrorTrace(0, "Something bad happened, lasterr=0x%x", GetLastError());
            break;
        }
    }
    else
    {
        // we're creating DW in a different user context.  Note that we pretty
        //  much have to be running as local system for this to work.
        // Note that the access check that CreateProcessAsUser makes appears to
        //  use the process token, so we do not need to remove any impersonation
        //  tokens at this point.

        ErrorTrace(0, "starting CreateProcessAsUserW(\'%S\')", wszBuffer);
        TESTBOOL(hr, CreateProcessAsUserW(dwmb.hToken, NULL, wszBuffer, NULL,
                                          NULL, FALSE, NORMAL_PRIORITY_CLASS |
                                          CREATE_UNICODE_ENVIRONMENT |
                                          CREATE_DEFAULT_ERROR_MODE,
                                          dwmb.pvEnv, wszDir, &si, &dwmb.pi));
        if (FAILED(hr))
            goto done;
    }

    frrvRet = frrvOk;

done:
    // preserve the error code so that the following calls don't overwrite it
    dw = GetLastError();

    if (hManifest != INVALID_HANDLE_VALUE)
        CloseHandle(hManifest);

    if (FAILED(hr) || wszManifestIn == NULL)
        DeleteFileW(wszManifestTU);

    SetLastError(dw);

    ErrorTrace(0, "LastError=0x%x", GetLastError());

    return frrvRet;
}


//////////////////////////////////////////////////////////////////////////////
//  Security

// **************************************************************************
#define ER_WINSTA_ALL WINSTA_ACCESSCLIPBOARD | WINSTA_ACCESSGLOBALATOMS | \
                      WINSTA_CREATEDESKTOP | WINSTA_ENUMDESKTOPS |        \
                      WINSTA_ENUMERATE | WINSTA_EXITWINDOWS |             \
                      WINSTA_READATTRIBUTES | WINSTA_READSCREEN |         \
                      WINSTA_WRITEATTRIBUTES
BOOL CheckAccessToWinSta0(void)
{
    HWINSTA hwinsta;

    // attempt to open winsta0

    hwinsta = OpenWindowStationW(L"winsta0", FALSE, ER_WINSTA_ALL);
    if (hwinsta == NULL)
        return FALSE;

    CloseWindowStation(hwinsta);
    return TRUE;
}


// **************************************************************************
BOOL DoUserContextsMatch(void)
{
    SID_NAME_USE    snu;
    TOKEN_USER      *ptuProc = NULL;
    HRESULT         hr = NOERROR;
    LPWSTR          wszName = NULL, wszDom = NULL;
    HANDLE          hTokenProc = NULL, hTokenImp = NULL;
    WCHAR           wszFullName[MAX_PATH], wszSidDom[MAX_PATH];
    DWORD           cb, cchDom;
    PSID            psidUser = NULL;

    USE_TRACING("DoUserContextsMatch");

    // always get the following info in the context of the process & not
    //  the context of the thread.  Also, if we don't do this, then we
    //  could fail later on when we try to open the process token.
    TESTBOOL(hr, OpenThreadToken(GetCurrentThread(),
                                 TOKEN_READ | TOKEN_IMPERSONATE, TRUE,
                                 &hTokenImp));
    if (FAILED(hr) && GetLastError() != ERROR_NO_TOKEN)
        goto done;

    RevertToSelf();

    // get the name of the currently logged on user to this session.  If this
    //  fails, then we just assume that we can't report in this context
    TESTBOOL(hr, WTSQuerySessionInformationW(WTS_CURRENT_SERVER_HANDLE,
                                             WTS_CURRENT_SESSION, WTSUserName,
                                             &wszName, &cb));
    if (FAILED(hr))
        goto done;

    VALIDATEEXPR(hr, (wszName == NULL || *wszName == L'\0'),
                 Err2HR(ERROR_ACCESS_DENIED));
    if (FAILED(hr))
    {
        SetLastError(ERROR_ACCESS_DENIED);
        goto done;
    }

    // get the domain of the currently logged on user to this session.  If this
    //  fails, then we just assume that we can't report in this context
    TESTBOOL(hr, WTSQuerySessionInformationW(WTS_CURRENT_SERVER_HANDLE,
                                             WTS_CURRENT_SESSION, WTSDomainName,
                                             &wszDom, &cb));
    if (FAILED(hr))
        goto done;

    VALIDATEEXPR(hr, (wszDom == NULL || *wszDom == L'\0'),
                 Err2HR(ERROR_ACCESS_DENIED));
    if (FAILED(hr))
    {
        SetLastError(ERROR_ACCESS_DENIED);
        goto done;
    }

    wcscpy(wszFullName, wszDom);
    wcscat(wszFullName, L"\\");
    wcscat(wszFullName, wszName);

    // since a SID is a variable length structure, query for the # of bytes
    //  we need to store it.
    cchDom = sizeofSTRW(wszSidDom);
    cb     = 0;
    LookupAccountNameW(NULL, wszFullName, NULL, &cb, wszSidDom, &cchDom, &snu);
    __try { psidUser = (PSID)_alloca(cb); }
    __except(EXCEPTION_EXECUTE_HANDLER) { psidUser = NULL; }
    VALIDATEEXPR(hr, (psidUser == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    // get the SID for the user
    TESTBOOL(hr, LookupAccountNameW(NULL, wszFullName, psidUser, &cb, wszSidDom,
                                    &cchDom, &snu));
    if (FAILED(hr))
        goto done;

    // fetch the token for the current process
    TESTBOOL(hr, OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hTokenProc));
    if (FAILED(hr))
        goto done;

    // fetch the sid for the user of the current process
    GetTokenInformation(hTokenProc, TokenUser, NULL, 0, &cb);
    __try { ptuProc = (TOKEN_USER *)_alloca(cb); }
    __except(EXCEPTION_STACK_OVERFLOW) { ptuProc = NULL; }
    VALIDATEEXPR(hr, (ptuProc == NULL), E_OUTOFMEMORY);
    if (FAILED(hr))
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    TESTBOOL(hr, GetTokenInformation(hTokenProc, TokenUser, (LPVOID)ptuProc,
                                     cb, &cb));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, IsValidSid(ptuProc->User.Sid));
    if (FAILED(hr))
        goto done;

    // are they equal?
    VALIDATEEXPR(hr, (EqualSid(ptuProc->User.Sid, psidUser) == FALSE),
                 Err2HR(ERROR_ACCESS_DENIED));
    if (FAILED(hr))
    {
        SetLastError(ERROR_ACCESS_DENIED);
        goto done;
    }

    // ok, so if the SIDs matched, then determine if this process has access
    //  to winsta0 (cuz otherwise it won't be able to launch DW in it)
    VALIDATEEXPR(hr, (CheckAccessToWinSta0() == FALSE),
                 Err2HR(ERROR_ACCESS_DENIED));
    if (FAILED(hr))
    {
        SetLastError(ERROR_ACCESS_DENIED);
        goto done;
    }

done:
    if (hTokenImp != NULL)
    {
        SetThreadToken(NULL, hTokenImp);
        CloseHandle(hTokenImp);
    }
    if (wszName != NULL)
        WTSFreeMemory(wszName);
    if (wszDom != NULL)
        WTSFreeMemory(wszDom);
    if (hTokenProc != NULL)
        CloseHandle(hTokenProc);

    return SUCCEEDED(hr);
}

// ***************************************************************************
BOOL DoWinstaDesktopMatch(void)
{
    HWINSTA hwinsta = NULL;
    HRESULT hr = NOERROR;
    LPWSTR  wszWinsta = NULL;
    DWORD   cbNeed = 0, cbGot;
    BOOL    fRet = FALSE;

    USE_TRACING("DoWinstaDesktopMatch");
    hwinsta = GetProcessWindowStation();
    TESTBOOL(hr, (hwinsta != NULL));
    if (FAILED(hr))
        goto done;

    fRet = GetUserObjectInformationW(hwinsta, UOI_NAME, NULL, 0, &cbNeed);
    TESTBOOL(hr, (cbNeed != 0));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto done;
    }

    cbNeed += sizeof(WCHAR);

    __try { wszWinsta = (LPWSTR)_alloca(cbNeed); }
    __except(EXCEPTION_STACK_OVERFLOW) { wszWinsta = NULL; }
    TESTBOOL(hr, (wszWinsta != NULL));
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto done;
    }

    cbGot = 0;
    fRet = GetUserObjectInformationW(hwinsta, UOI_NAME, wszWinsta, cbNeed,
                                     &cbGot);
    TESTBOOL(hr, (fRet != FALSE));
    if (FAILED(hr))
        goto done;

    ErrorTrace(0, "WinSta = %S", wszWinsta);

    // 'Winsta0' should be the interactive window station for a given session
    fRet = (_wcsicmp(wszWinsta, L"WinSta0") == 0);

done:
    return fRet;
}

// ***************************************************************************
BOOL AmIPrivileged(BOOL fOnlyCheckLS)
{
    SID_IDENTIFIER_AUTHORITY    siaNT = SECURITY_NT_AUTHORITY;
    TOKEN_USER                  *ptu = NULL, *ptuImp = NULL;
    HANDLE                      hToken = NULL, hTokenImp = NULL;
    DWORD                       cb, cbGot, i;
    PSID                        psid = NULL;
    BOOL                        fRet = FALSE, fThread;

    // local system has to be the first RID in this array.  Otherwise, the
    //  loop logic below needs to be changed.
    DWORD                       rgRIDs[3] = { SECURITY_LOCAL_SYSTEM_RID,
                                              SECURITY_LOCAL_SERVICE_RID,
                                              SECURITY_NETWORK_SERVICE_RID };

    // gotta have a token to get the SID
    fThread = OpenThreadToken(GetCurrentThread(),
                              TOKEN_READ | TOKEN_IMPERSONATE, TRUE,
                              &hTokenImp);
    if (fThread == FALSE && GetLastError() != ERROR_NO_TOKEN)
        goto done;

    // revert back to base user acct so we can fetch the process token &
    //  extract all the nifty stuff out of it.
    RevertToSelf();

    fRet = OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken);
    if (fRet == FALSE)
        goto done;

    // figure out the SID
    fRet = GetTokenInformation(hToken, TokenUser, NULL, 0, &cb);
    if (fRet != FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        fRet = FALSE;
        goto done;
    }
    __try { ptu = (TOKEN_USER *)_alloca(cb); }
    __except(EXCEPTION_STACK_OVERFLOW) { ptu = NULL; }
    if (ptu == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fRet = FALSE;
        goto done;
    }

    fRet = GetTokenInformation(hToken, TokenUser, (LPVOID)ptu, cb, &cbGot);
    if (fRet == FALSE)
        goto done;

    fRet = IsValidSid(ptu->User.Sid);
    if (fRet == FALSE)
        goto done;

    if (fThread)
    {
        // figure out the SID
        fRet = GetTokenInformation(hTokenImp, TokenUser, NULL, 0, &cb);
        if (fRet != FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            fRet = FALSE;
            goto done;
        }
        __try { ptuImp = (TOKEN_USER *)_alloca(cb); }
        __except(EXCEPTION_STACK_OVERFLOW) { ptuImp = NULL; }
        if (ptuImp == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            fRet = FALSE;
            goto done;
        }

        fRet = GetTokenInformation(hTokenImp, TokenUser, (LPVOID)ptuImp, cb,
                                   &cbGot);
        if (fRet == FALSE)
            goto done;

        fRet = IsValidSid(ptuImp->User.Sid);
        if (fRet == FALSE)
            goto done;
    }

    // loop thru & check against the SIDs we are interested in
    for (i = 0; i < 3; i++)
    {
        fRet = AllocateAndInitializeSid(&siaNT, 1, rgRIDs[i], 0, 0, 0, 0, 0, 0,
                                        0, &psid);
        if (fRet == FALSE)
            goto done;

        fRet = IsValidSid(psid);
        if (fRet == FALSE)
            goto done;

        fRet = EqualSid(psid, ptu->User.Sid);
        if (fRet)
        {
            // set this to false so that the code below will correctly change
            //  it to TRUE
            fRet = FALSE;
            goto done;
        }

        if (fThread)
        {
            fRet = EqualSid(psid, ptuImp->User.Sid);
            if (fRet)
            {
                // set this to false so that the code below will correctly
                //  change it to TRUE
                fRet = FALSE;
                goto done;
            }
        }

        FreeSid(psid);
        psid = NULL;

        // if we only need to check for local system, can bail now (we've
        //  already done it if we've gone thru this loop once)
        if (fOnlyCheckLS)
            break;
    }

    // only way to get here is to fail all the SID checks above.  So set the
    //  result to TRUE so the code below correclty changes it to FALSE
    fRet = TRUE;

done:
    if (fThread && hTokenImp != NULL)
    {
        if (SetThreadToken(NULL, hTokenImp) == FALSE)
            fRet = FALSE;
    }

    // if anything failed above, we want to return TRUE (cuz this puts us
    //  down the most secure code path), so need to negate the result.  Since
    //  we set the fallthru case to TRUE, we'll correctly negate it to FALSE
    //  here.
    fRet = !fRet;

    // if we had an impersonation token on the thread, put it back in place.
    if (hToken != NULL)
        CloseHandle(hToken);
    if (hTokenImp != NULL)
        CloseHandle(hTokenImp);
    if (fRet == TRUE && GetLastError() == ERROR_SUCCESS)
        SetLastError(ERROR_ACCESS_DENIED);
    if (psid != NULL)
        FreeSid(psid);

    return fRet;
}

// **************************************************************************
BOOL FindAdminSession(DWORD *pdwSession, HANDLE *phToken)
{
    USE_TRACING("FindAdminSession");

    WINSTATIONUSERTOKEN wsut;
    LOGONIDW            *rgSesn = NULL;
    HRESULT             hr = NOERROR;
    DWORD               i, cSesn, cb;

    ZeroMemory(&wsut, sizeof(wsut));

    VALIDATEPARM(hr, (pdwSession == NULL || phToken == NULL));
    if (FAILED(hr))
        goto done;

    *pdwSession = (DWORD)-1;
    *phToken    = NULL;

    TESTBOOL(hr, WinStationEnumerateW(SERVERNAME_CURRENT, &rgSesn, &cSesn));
    if (FAILED(hr))
        goto done;

    wsut.ProcessId = LongToHandle(GetCurrentProcessId());
    wsut.ThreadId  = LongToHandle(GetCurrentThreadId());

    for(i = 0; i < cSesn; i++)
    {
        if (rgSesn[i].State != State_Active)
            continue;

        TESTBOOL(hr, WinStationQueryInformationW(SERVERNAME_CURRENT,
                                                 rgSesn[i].SessionId,
                                                 WinStationUserToken,
                                                 &wsut, sizeof(wsut), &cb));
        if (FAILED(hr))
            continue;

        if (wsut.UserToken != NULL)
        {
            if (IsUserAnAdmin(wsut.UserToken))
                break;

            CloseHandle(wsut.UserToken);
            wsut.UserToken = NULL;
        }
    }

    if (i < cSesn)
    {
        hr = NOERROR;
        *pdwSession = rgSesn[i].SessionId;
        *phToken    = wsut.UserToken;
    }
    else
    {
        hr = E_FAIL;
    }

done:
    if (rgSesn != NULL)
        WinStationFreeMemory(rgSesn);

    return SUCCEEDED(hr);
}

//////////////////////////////////////////////////////////////////////////////
//  Logging

// **************************************************************************
HRESULT LogEvent(LPCWSTR wszSrc, WORD wCat, DWORD dwEventID, WORD cStrs,
                 DWORD cbBlob, LPCWSTR *rgwszStrs, LPVOID pvBlob)
{
    USE_TRACING("LogEvent");

    HRESULT hr = NOERROR;
    HANDLE  hLog = NULL;

    VALIDATEPARM(hr, (wszSrc == NULL));
    if (FAILED(hr))
        goto done;

    hLog = RegisterEventSourceW(NULL, wszSrc);
    TESTBOOL(hr, (hLog != NULL));
    if (FAILED(hr))
        goto done;

    TESTBOOL(hr, ReportEventW(hLog, EVENTLOG_ERROR_TYPE, wCat, dwEventID,
                              NULL, cStrs, cbBlob, rgwszStrs, pvBlob));
    if (FAILED(hr))
        goto done;

done:
    if (hLog != NULL)
        DeregisterEventSource(hLog);

    return hr;
}

// **************************************************************************
HRESULT LogHang(LPCWSTR wszApp, WORD *rgAppVer, LPCWSTR wszMod, WORD *rgModVer,
                ULONG64 ulOffset, BOOL f64bit)
{
    USE_TRACING("LogHang");

    HRESULT hr = NOERROR;
    LPCWSTR rgwsz[5];
    WCHAR   wszAppVer[32], wszModVer[32], wszOffset[32];
    char    szBlobLog[1024];


    VALIDATEPARM(hr, (wszApp == NULL || rgAppVer == NULL || wszMod == NULL ||
                      rgModVer == NULL));
    if (FAILED(hr))
        return hr;

    swprintf(wszAppVer, L"%d.%d.%d.%d", rgAppVer[0], rgAppVer[1], rgAppVer[2], rgAppVer[3]);
    swprintf(wszModVer, L"%d.%d.%d.%d", rgModVer[0], rgModVer[1], rgModVer[2], rgModVer[3]);

    if (f64bit)
        swprintf(wszOffset, L"%016I64x", ulOffset);
    else
        swprintf(wszOffset, L"%08x", (DWORD)ulOffset);

    sprintf(szBlobLog, "Application Hang  %S %S in %S %S at offset %S",
            wszApp, wszAppVer, wszMod, wszModVer, wszOffset);

    rgwsz[0] = wszApp;
    rgwsz[1] = wszAppVer;
    rgwsz[2] = wszMod;
    rgwsz[3] = wszModVer;
    rgwsz[4] = wszOffset;

    return LogEvent(c_wszHangEventSrc, ER_HANG_CATEGORY, ER_HANG_LOG, 5,
                    strlen(szBlobLog), rgwsz, szBlobLog);
}

// **************************************************************************
HRESULT LogUser(LPCWSTR wszApp, WORD *rgAppVer, LPCWSTR wszMod, WORD *rgModVer,
                ULONG64 ulOffset, BOOL f64bit, DWORD dwEventID)
{
    USE_TRACING("LogUser");

    HRESULT hr = NOERROR;
    LPCWSTR rgwsz[5];
    WCHAR   wszAppVer[32], wszModVer[32], wszOffset[32];
    char    szBlobLog[1024];


    VALIDATEPARM(hr, (wszApp == NULL || rgAppVer == NULL || wszMod == NULL ||
                      rgModVer == NULL));
    if (FAILED(hr))
        return hr;

    swprintf(wszAppVer, L"%d.%d.%d.%d", rgAppVer[0], rgAppVer[1], rgAppVer[2], rgAppVer[3]);
    swprintf(wszModVer, L"%d.%d.%d.%d", rgModVer[0], rgModVer[1], rgModVer[2], rgModVer[3]);

    if (f64bit)
        swprintf(wszOffset, L"%016I64x", ulOffset);
    else
        swprintf(wszOffset, L"%08x", (DWORD)ulOffset);

    sprintf(szBlobLog, "Application Failure  %S %S in %S %S at offset %S",
            wszApp, wszAppVer, wszMod, wszModVer, wszOffset);

    rgwsz[0] = wszApp;
    rgwsz[1] = wszAppVer;
    rgwsz[2] = wszMod;
    rgwsz[3] = wszModVer;
    rgwsz[4] = wszOffset;

    return LogEvent(c_wszUserEventSrc, ER_USERFAULT_CATEGORY, dwEventID,
                    5, strlen(szBlobLog), rgwsz, szBlobLog);
}

// **************************************************************************
#ifndef _WIN64
HRESULT LogKrnl(ULONG ulBCCode, ULONG ulBCP1, ULONG ulBCP2, ULONG ulBCP3,
                ULONG ulBCP4)
#else
HRESULT LogKrnl(ULONG ulBCCode, ULONG64 ulBCP1, ULONG64 ulBCP2, ULONG64 ulBCP3,
                ULONG64 ulBCP4)
#endif
{
    USE_TRACING("LogKrnl");

    HRESULT hr = NOERROR;
    LPCWSTR rgwsz[5];
    WCHAR   wszBCC[32], wszBCP1[32], wszBCP2[32], wszBCP3[32], wszBCP4[32];
    char    szBlobLog[1024];

#ifndef _WIN64
    swprintf(wszBCC,  L"%08x", ulBCCode);
    swprintf(wszBCP1, L"%08x", ulBCP1);
    swprintf(wszBCP2, L"%08x", ulBCP2);
    swprintf(wszBCP3, L"%08x", ulBCP3);
    swprintf(wszBCP4, L"%08x", ulBCP4);
#else
    swprintf(wszBCC,  L"%016I64x", ulBCCode);
    swprintf(wszBCP1, L"%016I64x", ulBCP1);
    swprintf(wszBCP2, L"%016I64x", ulBCP2);
    swprintf(wszBCP3, L"%016I64x", ulBCP3);
    swprintf(wszBCP4, L"%016I64x", ulBCP4);
#endif

    sprintf(szBlobLog, "System Error  Error code %S  Parameters %S, %S, %S, %S",
            wszBCC, wszBCP1, wszBCP2, wszBCP3, wszBCP4);

    rgwsz[0] = wszBCC;
    rgwsz[1] = wszBCP1;
    rgwsz[2] = wszBCP2;
    rgwsz[3] = wszBCP3;
    rgwsz[4] = wszBCP4;

    return LogEvent(c_wszKrnlEventSrc, ER_KRNLFAULT_CATEGORY, ER_KRNLCRASH_LOG,
                    5, strlen(szBlobLog), rgwsz, szBlobLog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\faultrep\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//

// Do NOT define any strings to have ID 0
#define IDS_KTITLE                      1
#define IDS_KERRMSG                     2
#define IDS_HERRMSG                     3
#define IDS_KHDRTXT                     4
#define IDS_HHDRTXT                     5
#define IDS_FERRMSG                     6
#define IDS_FQERRMSG                    7
#define IDS_FQHDRTXT                    8
#define IDS_STITLE	                    9
#define IDS_SERRMSG                     10
#define IDS_SHDRTXT                     11

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\faultrep\msodw.h ===
#pragma once

/****************************************************************************
	MsoDW.h

	Owner: MRuhlen
	Copyright (c) 1999 Microsoft Corporation

	This files contains the handshake structure with which apps will launch
	DW (aka OfficeWatson, aka whatever the marketroids call it)
****************************************************************************/

#ifndef MSODW_H
#define MSODW_H
#pragma pack(push, msodw_h)
#pragma pack(4)

#define DW_TIMEOUT_VALUE	20000
#define DW_MUTEX_TIMEOUT    DW_TIMEOUT_VALUE / 2
#define DW_NOTIFY_TIMEOUT   120000 // 2 minutes
#define DW_MAX_ASSERT_CCH   1024
#define DW_MAX_PATH         260
#define DW_APPNAME_LENGTH	56
#define DW_MAX_SERVERNAME   DW_MAX_PATH
#define DW_MAX_ERROR_CWC    260 // must be at least max_path
#define DW_MAX_REGSUBPATH   200
#define DW_CMDLINE_RESPONSE "DwResponse="
#define DW_CMDLINE_REPORT   "DwReportResponse="

#define DW_ALLMODULES              L"*\0"
#define DW_WHISTLER_EVENTLOG_SOURCE L"Application Error"

// the following are the fields that can be specified in a manifest file to 
// launch DW in a file based reporting mode

// these are required

#define DW_MANIFEST_TITLENAME    L"TitleName="  
#define DW_MANIFEST_ERRORTEXT    L"ErrorText="
#define DW_MANIFEST_HDRTEXT      L"HeaderText="
#define DW_MANIFEST_ERRORSIG     L"ErrorSig="
#define DW_MANIFEST_ERRORDETAIL  L"ErrorDetail="
#define DW_MANIFEST_SERVERNAME   L"Server="
#define DW_MANIFEST_URL2         L"Stage2URL="
#define DW_MANIFEST_LCID         L"UI LCID="
#define DW_MANIFEST_DATAFILES    L"DataFiles="

// the following are optional, DW has default behavior for all of these

#define DW_MANIFEST_FLAGS        L"Flags="
#define DW_MANIFEST_BRAND        L"Brand="
#define DW_MANIFEST_EVENTSOURCE  L"EventLogSource="
#define DW_MANIFEST_EVENTID      L"EventID="
#define DW_MANIFEST_URL1         L"Stage1URL="
#define DW_MANIFEST_ERRORSUBPATH L"ErrorSubPath="
#define DW_MANIFEST_REGSUBPATH   L"RegSubPath="
#define DW_MANIFEST_DIGPIDPATH   L"DigPidRegPath="    
#define DW_MANIFEST_ICONFILE     L"IconFile="
#define DW_MANIFEST_CAPTION      L"Caption="
#define DW_MANIFEST_REPORTEE     L"Reportee="
#define DW_MANIFEST_PLEA         L"Plea="
#define DW_MANIFEST_REPORTBTN    L"ReportButton="
#define DW_MANIFEST_NOREPORTBTN  L"NoReportButton="

// Seperator for file lists (Manifest DataFiles and Exception Additional Files
#define DW_FILESEPA              '|'
#define DW_FILESEP_X(X)          L##X
#define DW_FILESEP_Y(X)          DW_FILESEP_X(X)
#define DW_FILESEP               DW_FILESEP_Y(DW_FILESEPA)

#ifdef DEBUG
enum // AssertActionCodes
{
	DwAssertActionFail = 0,
	DwAssertActionDebug,
	DwAssertActionIgnore,
	DwAssertActionAlwaysIgnore,
	DwAssertActionIgnoreAll,
	DwAssertActionQuit,
};	
#endif

//  Caller is the app that has experienced an exception and launches DW

enum // ECrashTimeDialogStates	// msoctds
{
	msoctdsNull          = 0x00000000,
	msoctdsQuit          = 0x00000001,
	msoctdsRestart       = 0x00000002,
	msoctdsRecover       = 0x00000004,
	msoctdsUnused        = 0x00000008,
	msoctdsDebug         = 0x00000010,
};

#define MSODWRECOVERQUIT (msoctdsRecover | msoctdsQuit)
#define MSODWRESTARTQUIT (msoctdsRestart | msoctdsQuit)
#define MSODWRESPONSES (msoctdsQuit | msoctdsRestart | msoctdsRecover)

// THIS IS PHASED OUT -- DON'T USE
enum  // EMsoCrashHandlerFlags  // msochf
{
	msochfNull                = 0x00000000,

	msochfUnused              = msoctdsUnused,  // THESE MUST BE THE SAME
	msochfCanRecoverDocuments = msoctdsRecover,
	
	msochfObsoleteCanDebug    = 0x00010001,  // not used anymore
	msochfCannotSneakyDebug   = 0x00010002,  // The "hidden" debug feature won't work
	msochfDefaultDontReport   = 0x00010004,
	msochReportingDisabled    = 0x00010008,  // User cannot change default reporting choice
};


// 
enum  // EMsoCrashHandlerResults  // msochr
{
	msochrNotHandled        = msoctdsNull,
	msochrUnused            = msoctdsUnused,
	msochrDebug             = msoctdsDebug,
	msochrRecoverDocuments  = msoctdsRecover,
	msochrRestart           = msoctdsRestart,
	msochrQuit              = msoctdsQuit,
};

enum  // EDwBehaviorFlags
{
	fDwOfficeApp            = 0x00000001,
	fDwNoReporting          = 0x00000002,   // don't report
	fDwCheckSig             = 0x00000004,   // checks the signatures of the App/Mod list
	fDwGiveAppResponse      = 0x00000008,   // hands szResponse to app on command line
	fDwWhistler             = 0x00000010,   // Whistler's exception handler is caller
	fDwUseIE                = 0x00000020,   // always launch w/ IE
	fDwDeleteFiles          = 0x00000040,   // delete the additional files after use.
	fDwHeadless             = 0x00000080,   // DW will auto-report. policy required to enable
	fDwUseHKLM              = 0x00000100,   // DW reg from HKLM instead of HKCU
	fDwUseLitePlea          = 0x00000200,   // DW won't suggest product change in report plea
	fDwUsePrivacyHTA        = 0x00000400,   // DW won't suggest product change in report plea
	fDwManifestDebug        = 0x00000800,   // DW will provide a debug button in manifset mode
	fDwReportChoice         = 0x00001000,   // DW will tack on the command line of the user
	fDwSkipBucketLog      = 0x00002000, // DW won't log at bucket-time
	fDwNoDefaultCabLimit = 0x00004000, // DW under CER won't use 5 as the fallback but unlimited instead (policy still overrides)
	fDwAllowSuspend      = 0x00008000, // DW will allow powersave mode to suspend it, as long as we're not in reporting phase
   fDwMiniDumpWithUnloadedModules = 0x00010000, // DW will pass MiniDumpWithUnloadedModules to the minidump API
};


typedef struct _DWSharedMem10
{
	DWORD dwSize;               // should be set to size of DWSharedMem
	DWORD pid;                  // Process Id of caller
	DWORD tid;                  // Id of excepting thread
	DWORD_PTR eip;              // EIP of the excepting instruction
	PEXCEPTION_POINTERS pep;    // Exception pointers given to the callee's
	                            // exception handler
	HANDLE hEventDone;          // event DW signals when done
	                            // caller will also signal this if it things
								// DW has hung and restarts itself 
	HANDLE hEventNotifyDone;    // App sets when it's done w/ notifcation phase
	HANDLE hEventAlive;         // heartbeat event DW signals per EVENT_TIMEOUT
	HANDLE hMutex;              // to protect the signaling of EventDone  
	HANDLE hProc;               // handle to the calling process (! in Assert)
	
	DWORD bfDWBehaviorFlags;    // controls caller-specific behaviors
	
	DWORD msoctdsResult;      // result from crash-time dialog
	BOOL fReportProblem;      // did user approve reporting?
	DWORD bfmsoctdsOffer;     // bitfield of user choices to offer
	                          // note that you must specify two of:
							  // Quit, Restart, Recover, Ignore
							  // The Debug choice is independent
	DWORD bfmsoctdsNotify;    // bitfield of user choices for which the
	                          // app wants control back instead of simply being
							  // terminated by DW.  The app will then be
							  // responsible for pinging DW (if desired) with
							  // hEventAlive and for notify DW it's ok to
							  // terminate the app w/ hEventDone       

	DWORD bfmsoctdsLetRun;    // bitfield of user choices for which the
	                          // app wants control back instead of being
							  // terminated by DW.  DW can then safely ignore
							  // the app and exit.

	int iPingCurrent;         // current count for the recovery progress bar
	int iPingEnd;             // index for the end of the recovery progress bar
	
	char szFormalAppName[DW_APPNAME_LENGTH];   // the app name for display to user (ie "Microsoft Word")
	char szInformalAppName[DW_APPNAME_LENGTH]; // the app name for display to user (ie "Word")
	char szModuleFileName[DW_MAX_PATH];        // The result of GetModuleFileNameA(NULL)
	WCHAR wzErrorMessage[DW_MAX_ERROR_CWC];    // Error message to show user.
	
	char szServer[DW_MAX_SERVERNAME];  // name of server to try by default
	char szLCIDKeyValue[DW_MAX_PATH];  // name of key value DWORD containing the
	                                   // PlugUI LCID, if this string fails to
									   // be a valid key-value, DW will use the
									   // system LCID, and if it can't find
									   // an intl dll for that, will fall
									   // back on US English (1033)
	char szPIDRegKey[DW_MAX_PATH];     // name of the key that holds the PID
	                                   // can be used by the Server for
									   // spoof-detection
	
	char szRegSubPath[DW_MAX_REGSUBPATH]; // path to the key to contian the DW
	                                      // registry hive from both
									      // HKCU\Software and
									      // HKCU\Software\Policies (for policy)
	
	WCHAR wzDotDataDlls[DW_MAX_PATH];  // contains the list of DLLs, terminated
	                                   // by '\0' characters, that DW will
									   // collect the .data sections into the
									   // full minidump version
									   // e.g. "mso9.dll\0outllib.dll\0"
	WCHAR wzAdditionalFile[1024];      // File list, seperated by DW_FILESEP
	                                   // each of these files gets added to the
									   // cab at upload time

	char szBrand[DW_APPNAME_LENGTH];   // passed as a param to Privacy Policy link
#ifdef DEBUG
	// for Assert communication
	DWORD dwTag;                       // [in] AssertTag
	char szFile[DW_MAX_PATH];          // [in] File name of the assert
	int line;                          // [in] Line number of the assert
	char szAssert[DW_MAX_ASSERT_CCH];  // [in] Sz from the assert
	int AssertActionCode;              // [out] action code to take
#endif
} DWSharedMem10;

typedef struct _DWSharedMem15
{
	DWORD dwSize;               // should be set to size of DWSharedMem
	DWORD pid;                  // Process Id of caller
	DWORD tid;                  // Id of excepting thread
	DWORD_PTR eip;              // EIP of the excepting instruction
	PEXCEPTION_POINTERS pep;    // Exception pointers given to the callee's
	                            // exception handler
	HANDLE hEventDone;          // event DW signals when done
	                            // caller will also signal this if it things
								// DW has hung and restarts itself 
	HANDLE hEventNotifyDone;    // App sets when it's done w/ notifcation phase
	HANDLE hEventAlive;         // heartbeat event DW signals per EVENT_TIMEOUT
	HANDLE hMutex;              // to protect the signaling of EventDone  
	HANDLE hProc;               // handle to the calling process (! in Assert)
	
	DWORD bfDWBehaviorFlags;    // controls caller-specific behaviors
	
	DWORD msoctdsResult;      // result from crash-time dialog
	BOOL fReportProblem;      // did user approve reporting?
	DWORD bfmsoctdsOffer;     // bitfield of user choices to offer
	                          // note that you must specify two of:
							  // Quit, Restart, Recover, Ignore
							  // The Debug choice is independent
	DWORD bfmsoctdsNotify;    // bitfield of user choices for which the
	                          // app wants control back instead of simply being
							  // terminated by DW.  The app will then be
							  // responsible for pinging DW (if desired) with
							  // hEventAlive and for notify DW it's ok to
							  // terminate the app w/ hEventDone       

	DWORD bfmsoctdsLetRun;    // bitfield of user choices for which the
	                          // app wants control back instead of being
							  // terminated by DW.  DW can then safely ignore
							  // the app and exit.

	int iPingCurrent;         // current count for the recovery progress bar
	int iPingEnd;             // index for the end of the recovery progress bar
	
	WCHAR wzFormalAppName[DW_APPNAME_LENGTH];   // the app name for display to user (ie "Microsoft Word")
	WCHAR wzModuleFileName[DW_MAX_PATH];        // The result of GetModuleFileName(NULL)
	
	WCHAR wzErrorMessage[DW_MAX_ERROR_CWC]; // (optional) Error details message to show user.
	WCHAR wzErrorText[DW_MAX_ERROR_CWC];    // (optional) substitue error text (e.g. "you might have lost information")
	WCHAR wzCaption[DW_MAX_ERROR_CWC];      // (optional) substitue caption
	WCHAR wzHeader[DW_MAX_ERROR_CWC];       // (optional) substitue main dialog header text
	WCHAR wzReportee[DW_APPNAME_LENGTH];    // (optional) on whom's behalf we request the report
	WCHAR wzPlea[DW_MAX_ERROR_CWC];         // (optional) substitue report plea text
	WCHAR wzReportBtn[DW_APPNAME_LENGTH];   // (optional) substitue "Report Problem" text
	WCHAR wzNoReportBtn[DW_APPNAME_LENGTH]; // (optional) substitue "Don't Report" text
	
	char szServer[DW_MAX_SERVERNAME];  // name of server to try by default
	char szLCIDKeyValue[DW_MAX_PATH];  // name of key value DWORD containing the
	                                   // PlugUI LCID, if this string fails to
									   // be a valid key-value, DW will use the
									   // system LCID, and if it can't find
									   // an intl dll for that, will fall
									   // back on US English (1033)
	char szPIDRegKey[DW_MAX_PATH];     // name of the key that holds the PID
	                                   // can be used by the Server for
									   // spoof-detection
	
	LCID lcidUI;                       // will try this UI langauge if non-zero
	
	char szRegSubPath[DW_MAX_REGSUBPATH]; // path to the key to contian the DW
	                                      // registry hive from both
									      // HKCU\Software and
									      // HKCU\Software\Policies (for policy)
	
	WCHAR wzDotDataDlls[DW_MAX_PATH];  // contains the list of DLLs, terminated
	                                   // by '\0' characters, that DW will
									   // collect the .data sections into the
									   // full minidump version
									   // e.g. "mso9.dll\0outllib.dll\0"
	WCHAR wzAdditionalFile[1024];      // File list, seperated by DW_FILESEP
	                                   // each of these files gets added to the
									   // cab at upload time

	char szBrand[DW_APPNAME_LENGTH];   // passed as a param to Privacy Policy link
#ifdef DEBUG
	// for Assert communication
	DWORD dwTag;                       // [in] AssertTag
	char szFile[DW_MAX_PATH];          // [in] File name of the assert
	int line;                          // [in] Line number of the assert
	char szAssert[DW_MAX_ASSERT_CCH];  // [in] Sz from the assert
	int AssertActionCode;              // [out] action code to take
#endif
} DWSharedMem15, DWSharedMem;

#pragma pack(pop, msodw_h)
#endif // MSODW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\fhapi.h ===
/********************************************************************
Copyright (c) 2000 Microsoft Corporation

Module Name:
    fhmain.c

Abstract:
    core fault handler stuff

Revision History:

    DerekM      created     05/14/00

********************************************************************/

#ifndef FHAPI_H
#define FHAPI_H

HRESULT PCHPFNotifyFault(LPWSTR wszDumpPath, LPWSTR wszMainMod);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\ercommon.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    ercommon.h

Revision History:
    created     derekm      03/16/01

******************************************************************************/

#ifndef ERCOMMON_H
#define ERCOMMON_H

/////////////////////////////////////////////////////////////////////////////
// reg keys

const WCHAR c_wszRKRun[]       = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run";

const WCHAR c_wszRKKrnl[]      = L"SOFTWARE\\Microsoft\\PCHealth\\ErrorReporting\\KernelFaults";
const WCHAR c_wszRVKFC[]       = L"KernelFaultCheck";
const WCHAR c_wszMutKrnlName[] = L"Global\\0CADFD67AF62496dB34264F000F5624A";

const WCHAR c_wszRKShut[]      = L"SOFTWARE\\Microsoft\\PCHealth\\ErrorReporting\\ShutdownEvents";
const WCHAR c_wszRVSEC[]       = L"ShutdownEventCheck";
const WCHAR c_wszMutShutName[] = L"Global\\238FAD3109D3473aB4764B20B3731840";

const WCHAR c_wszRKUser[]      = L"SOFTWARE\\Microsoft\\PCHealth\\ErrorReporting\\UserFaults";
const WCHAR c_wszRVUFC[]       = L"UserFaultCheck";
const WCHAR c_wszMutUserName[] = L"Global\\4FCC0DEFE22C4f138FB9D5AF25FD9398";

const WCHAR c_wszDumpSuffix[]  = L".mdmp";
#ifdef MANIFEST_HEAP
const WCHAR c_wszHeapDumpSuffix[] = L".hdmp";
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\faultrep\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    PCH 

Revision History:
    created     derekm      07/07/00

******************************************************************************/

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define PFCLICFG_LITE 1
#ifndef DEBUG
#define NOTRACE 1
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsta.h>
#include <malloc.h>
#include <stdio.h>
#include <wchar.h>

#include <dbghelp.h>

#include <util.h>
#include <pfrcfg.h>
#include <faultrep.h>
#include <ercommon.h>

#include "resource.h"
#include "msodw.h"
#include "frutil.h"



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\fulpcall.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    fulpcall.h

Abstract:
    protocol info used by CFaultUpload & server component

Revision History:
    created     derekm      03/22/00

******************************************************************************/

#ifndef FULPCALL_H
#define FULPCALL_H


/////////////////////////////////////////////////////////////////////////////
// client ops

#define PCHFHO_YODUDE           0x0
#define PCHFHO_CHECKSIG         0x1
#define PCHFHO_DATA3            0x2
#define PCHFHO_DATA0            0x3
#define PCHFHO_OFFLINE0         0x4
#define PCHFHO_OFFLINE3         0x5

/////////////////////////////////////////////////////////////////////////////
// server responses

#define S_PCHFHR_YEAHMAN        0x0
#define S_PCHFHR_SENDDATA       0x1
#define S_PCHFHR_DONEDATA       0x2
#define S_PCHFHR_DONE           0x3
#define E_PCHFHR_BADPROVVER     0x80000000
#define E_PCHFHR_INVALIDOP      0x80000001
#define E_PCHFHR_INVALIDDATA    0x80000002
#define E_PCHFHR_BADBLOBSIZE    0x80000003


/////////////////////////////////////////////////////////////////////////////
// structs

#pragma pack(push, 8)

// this is the header that gets sent with each message
struct SPFFULHeader
{
    DWORD   dwVer;
    DWORD   dwOpRes;
    DWORD   cbBody;
};

// this is the 'table of contents' for a dataspec server response
struct SPFFULDataspecTOC
{
    DWORD   dwSigUsed;
    DWORD   dwIncID;
};

// this is the 'table of contents' for a signature upload 
struct SPFFULSigTOC
{
    DWORD   dwSigID;
};

// this is the 'table of contents' for a cab client upload 
struct SPFFULOnlineTOC
{
    DWORD   dwSigID;
    DWORD   dwCabOffset;
    DWORD   dwIncID;
};

// this is the 'table of contents' for an offline cab client upload 
struct SPFFULOfflineTOC
{
    DWORD   dwSigID;
    DWORD   dwCabOffset;
    DWORD   dwSigOffset;
};

#pragma pack(pop)

/////////////////////////////////////////////////////////////////////////////
// constants

const DWORD c_cbBlobHeader          = sizeof(SPFFULHeader);
const DWORD c_cbDataspecHeader      = sizeof(SPFFULDataspecTOC);
const DWORD c_cbSigHeader           = sizeof(SPFFULSigTOC);
const DWORD c_cbOnlineHeader        = sizeof(SPFFULOnlineTOC);
const DWORD c_cbOfflineHeader       = sizeof(SPFFULOfflineTOC);
const DWORD c_cbTotalDataspecHeader = c_cbBlobHeader + c_cbDataspecHeader;
const DWORD c_cbTotalSigHeader      = c_cbBlobHeader + c_cbSigHeader;
const DWORD c_cbTotalOnlineHeader   = c_cbBlobHeader + c_cbOnlineHeader;
const DWORD c_cbTotalOfflineHeader  = c_cbBlobHeader + c_cbOfflineHeader;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\faultrep\frutil.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    faultrep.cpp

Abstract:
    Constants & useful header type stuff for fault reporting

Revision History:
    created     derekm      07/07/00

******************************************************************************/


#ifndef FRUTIL_H
#define FRUTIL_H

///////////////////////////////////////////////////////////////////////////////
// Global stuff

// globals
extern HINSTANCE        g_hInstance;
extern BOOL             g_fAlreadyReportingFault;


///////////////////////////////////////////////////////////////////////////////
// Constants

// command lines
const WCHAR c_wszDWCmdLineU[]   = L"%ls\\dwwin.exe -x -s %lu";
const WCHAR c_wszDWCmdLineKH[]  = L"%ls\\dwwin.exe -d %ls";
const WCHAR c_wszDRCmdLineMD[]  = L"%ls\\dumprep.exe %ld -dm 7 7 %ls %I64d";

// manifest constants
const WCHAR c_wszManMisc[]      = L"\r\nServer=%ls\r\nUI LCID=%d\r\nFlags=%d\r\nBrand=%ls\r\nTitleName=";
const WCHAR c_wszManSubPath[]   = L"\r\nRegSubPath=Microsoft\\PCHealth\\ErrorReporting\\DW";
const WCHAR c_wszManPID[]       = L"\r\nDigPidRegPath=HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\DigitalProductId";
const WCHAR c_wszManCorpPath[]  = L"\r\nErrorSubPath=";
const WCHAR c_wszManFiles[]     = L"\r\nDataFiles=";
const WCHAR c_wszManHdrText[]   = L"\r\nHeaderText=";
const WCHAR c_wszManErrText[]   = L"\r\nErrorText=";
const WCHAR c_wszManPleaText[]  = L"\r\nPlea=";
const WCHAR c_wszManSendText[]  = L"\r\nReportButton=";
const WCHAR c_wszManNSendText[] = L"\r\nNoReportButton=";
const WCHAR c_wszManEventSrc[]  = L"\r\nEventLogSource=";
const WCHAR c_wszManStageOne[]  = L"\r\nStage1URL=";
const WCHAR c_wszManStageTwo[]  = L"\r\nStage2URL=";
const WCHAR c_wszManHeapDump[]  = L"\r\nHeap=";

const WCHAR c_wszManKS2[]       = L"\r\nStage2URL=/dw/bluetwo.asp?BCCode=%x&BCP1=%p&BCP2=%p&BCP3=%p&BCP4=%p&OSVer=%d_%d_%d&SP=%d_%d&Product=%d_%d";
const WCHAR c_wszManSS2[]       = L"\r\nStage2URL=/dw/ShutdownTwo.asp?OSVer=%d_%d_%d&SP=%d_%d&Product=%d_%d";
const WCHAR c_wszManFS164[]     = L"\r\nStage1URL=/StageOne/%ls/%d_%d_%d_%d/%ls/%d_%d_%d_%d/%016I64x.htm";
const WCHAR c_wszManFS264[]     = L"\r\nStage2URL=/dw/stagetwo64.asp?szAppName=%ls&szAppVer=%d.%d.%d.%d&szModName=%ls&szModVer=%d.%d.%d.%d&offset=%016I64x";
const WCHAR c_wszManFCP64[]     = L"%ls\\%d.%d.%d.%d\\%ls\\%d.%d.%d.%d\\%016I64x";
const WCHAR c_wszManHS164[]     = L"\r\nStage1URL=/StageOne/%ls/%ls/hangme.hng/0_0_0_0/ffffffffffffffff.htm";
const WCHAR c_wszManHS264[]     = L"\r\nStage2URL=/dw/stagetwo64.asp?szAppName=%ls&szAppVer=%ls&szModName=hangme.hng&szModVer=0.0.0.0&offset=ffffffffffffffff";
const WCHAR c_wszManHCP64[]     = L"%ls\\%ls\\hangme.hng\\0.0.0.0\\ffffffffffffffff";
const WCHAR c_wszManFS132[]     = L"\r\nStage1URL=/StageOne/%ls/%d_%d_%d_%d/%ls/%d_%d_%d_%d/%08x.htm";
const WCHAR c_wszManFS232[]     = L"\r\nStage2URL=/dw/stagetwo.asp?szAppName=%ls&szAppVer=%d.%d.%d.%d&szModName=%ls&szModVer=%d.%d.%d.%d&offset=%08x";
const WCHAR c_wszManFCP32[]     = L"%ls\\%d.%d.%d.%d\\%ls\\%d.%d.%d.%d\\%08x";
const WCHAR c_wszManHS132[]     = L"\r\nStage1URL=/StageOne/%ls/%ls/hangme.hng/0_0_0_0/ffffffff.htm";
const WCHAR c_wszManHS232[]     = L"\r\nStage2URL=/dw/stagetwo.asp?szAppName=%ls&szAppVer=%ls&szModName=hangme.hng&szModVer=0.0.0.0&offset=ffffffff";
const WCHAR c_wszManHCP32[]     = L"%ls\\%ls\\hangme.hng\\0.0.0.0\\ffffffff";
const WCHAR c_wszManKCorpPath[] = L"blue";
const WCHAR c_wszManSCorpPath[] = L"shutdown";

// note: 3 * size of (szAppName + szModName) still need to be added to this value
const DWORD c_cbFaultBlob32 = (sizeof(c_wszManFS132) + sizeof(c_wszManFS232) + sizeof(c_wszManFCP32)) + // initial strings
                              (8 * 3 * 5 * sizeof(WCHAR)) + // 3 strings * 8 version fields per string * upto 5 chars per field
                              8; // 8 chars for hex offset
const DWORD c_cbFaultBlob64 = (sizeof(c_wszManFS164) + sizeof(c_wszManFS264) + sizeof(c_wszManFCP64)) + // initial strings
                              (8 * 3 * 5 * sizeof(WCHAR)) + // 3 strings * 8 version fields per string * upto 5 chars per field
                              16; // 8 chars for hex offset

// note, 3 * size of (szAppName + szAppVer) still need to be added to this value
const DWORD c_cbHangBlob32  = (sizeof(c_wszManHS132) + sizeof(c_wszManHS232) + sizeof(c_wszManHCP32)); // initial strings
const DWORD c_cbHangBlob64  = (sizeof(c_wszManHS164) + sizeof(c_wszManHS264) + sizeof(c_wszManHCP64)); // initial strings


// misc DW constants
const WCHAR c_wszDWDefServerI[] = L"officewatson";
const WCHAR c_wszDWDefServerE[] = L"watson.microsoft.com";
const WCHAR c_wszDWBrand[]      = L"WINDOWS";
const WCHAR c_wszLogFileName[]  = L"errorlog.log";
const WCHAR c_wszFaultEvSrc[]   = L"Application Error";

// queue stuff
const WCHAR c_wszQSubdir[]      = L"PCHealth\\ErrorRep\\UserDumps\\";
const WCHAR c_wszQFileName[]    = L"%ls.%04d%02d%02d-%02d%02d%02d-00.mdmp";

// reg keys & values
const WCHAR c_wszRPSvc[]        = L"System\\CurrentControlSet\\Services";
const WCHAR c_wszRVSvcType[]    = L"Type";
const WCHAR c_wszRVSvcPath[]    = L"ImagePath";
const WCHAR c_wszRKSetup[]      = L"System\\Setup";
const WCHAR c_wszRVSetupNow[]   = L"SystemSetupInProgress";
const WCHAR c_wszRVVKFC[]       = L"%systemroot%\\system32\\dumprep 0 -k";
const WCHAR c_wszRVVUFC[]       = L"%systemroot%\\system32\\dumprep 0 -u";
const WCHAR c_wszRVVSEC[]       = L"%systemroot%\\system32\\dumprep 0 -s";
const WCHAR c_wszRKBiosInfo[]   = L"HARDWARE\\Description\\System";
const WCHAR c_wszRVBiosVer[]    = L"SystemBiosVersion";
const WCHAR c_wszRVBiosDate[]   = L"SystemBiosDate";
const WCHAR c_wszRKProcInfo[]   = L"HARDWARE\\Description\\System\\CentralProcessor\\0";
const WCHAR c_wszRKWNTCurVer[]  = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
const WCHAR c_wszRVProdName[]   = L"ProductName";
const WCHAR c_wszRVBuildLab[]   = L"BuildLab";
const WCHAR c_wszRKAeDebug[]    = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug";
const WCHAR c_wszRVDebugger[]   = L"Debugger";
const WCHAR c_wszRVAuto[]       = L"Auto";

// shared memory constants
const char  c_szDWRegSubPath[]  = "Microsoft\\PCHealth\\ErrorReporting\\DW";
const char  c_szDWDefServerI[]  = "officewatson";
const char  c_szDWDefServerE[]  = "watson.microsoft.com";
const char  c_szDWBrand[]       = "WINDOWS";
const char  c_szRKVDigPid[]     = "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\DigitalProductId";

// kernel fault extra info constants
const WCHAR c_wszXMLOpenDevices[]     = L"<DEVICES>\r\n";
const WCHAR c_wszXMLCloseDevices[]    = L"</DEVICES>\r\n";
const WCHAR c_wszXMLOpenDevice[]      = L"\t<DEVICE>\r\n";
const WCHAR c_wszXMLCloseDevice[]     = L"\t</DEVICE>\r\n";
const WCHAR c_wszXMLOpenDevDesc[]     = L"\t\t<DESCRIPTION>";
const WCHAR c_wszXMLCloseDevDesc[]    = L"</DESCRIPTION>\r\n";
const WCHAR c_wszXMLOpenDevHwId[]     = L"\t\t<HARDWAREID>";
const WCHAR c_wszXMLCloseDevHwId[]    = L"</HARDWAREID>\r\n";
const WCHAR c_wszXMLOpenDevService[]  = L"\t\t<SERVICE>";
const WCHAR c_wszXMLCloseDevService[] = L"</SERVICE>\r\n";
const WCHAR c_wszXMLOpenDevImage[]    = L"\t\t<DRIVER>";
const WCHAR c_wszXMLCloseDevImage[]   = L"</DRIVER>\r\n";

const WCHAR c_wszXMLHeader[]    = L"<?xml version=\"1.0\" encoding=\"Unicode\" ?>\r\n<SYSTEMINFO>\r\n<SYSTEM>\r\n\t<OSNAME>%ls %ls</OSNAME>\r\n\t<OSVER>%d.%d.%d %d.%d</OSVER>\r\n\t<OSLANGUAGE>%d</OSLANGUAGE>\r\n";
const WCHAR c_wszXMLCloseSystem[] = L"</SYSTEM>\r\n";
const WCHAR c_wszXMLOpenDrivers[] = L"<DRIVERS>\r\n";
const WCHAR c_wszXMLDriver1[]   = L"\t<DRIVER>\r\n\t\t<FILENAME>";
const WCHAR c_wszXMLDriver2[]   = L"</FILENAME>\r\n\t\t<FILESIZE>%d</FILESIZE>\r\n\t\t<CREATIONDATE>%02d-%02d-%04d %02d:%02d:%02d</CREATIONDATE>\r\n\t\t<VERSION>";
const WCHAR c_wszXMLDriver3[]   = L"</VERSION>\r\n\t\t<MANUFACTURER>";
const WCHAR c_wszXMLDriver4[]   = L"</MANUFACTURER>\r\n\t<PRODUCTNAME>\r\n";
const WCHAR c_wszXMLDriver5[]   = L"</PRODUCTNAME>\r\n\t</DRIVER>\r\n";
const WCHAR c_wszXMLFooter[]    = L"</DRIVERS>\r\n</SYSTEMINFO>\r\n";
const WCHAR c_wszDriversDir[]   = L"\\drivers\\*";
const WCHAR c_wszKrnlCmdLine[]  = L"\\dumprep 0 -kg";
const WCHAR c_wszShutCmdLine[]  = L"\\dumprep 0 -sg";

// event sources
const WCHAR c_wszHangEventSrc[] = L"Application Hang";
const WCHAR c_wszKrnlEventSrc[] = L"System Error";
const WCHAR c_wszUserEventSrc[] = L"Application Error";

// filename stuff
const WCHAR c_wszACFileName[]   = L"appcompat.txt";
const WCHAR c_wszManFileName[]  = L"manifest.txt";
const WCHAR c_wszEventData[]    = L"sysdata.xml";


// event types
const WCHAR c_wszKernel[]       = L"Kernel fault";
const WCHAR c_wszShutdown[]     = L"Unplanned shutdown";
const WCHAR c_wszUnknown[]      = L"Unknown event";
const LPCWSTR c_rgwszEvents[]   = { c_wszKernel, c_wszShutdown, c_wszUnknown };

#ifdef MANIFEST_HEAP
// minidump flags
const ULONG c_ulModuleWriteDefault =
    ModuleWriteModule | ModuleWriteMiscRecord | ModuleWriteCvRecord;
const ULONG c_ulThreadWriteDefault =
    ThreadWriteThread | ThreadWriteStack |
    ThreadWriteContext | ThreadWriteBackingStore |
    ThreadWriteInstructionWindow;
#endif  // MANIFEST_HEAP

// misc
const WCHAR c_wszDbgHelpDll[]   = L"\\dbghelp.dll";
const WCHAR c_wszAppHelpDll[]   = L"\\apphelp.dll";
const WCHAR c_wszKernel32Dll[]  = L"\\kernel32.dll";

#ifdef _WIN64
#define c_wszManFS1 c_wszManFS164
#define c_wszManFS2 c_wszManFS264
#define c_wszManHS1 c_wszManHS164
#define c_wszManHS2 c_wszManHS264
#else
#define c_wszManFS1 c_wszManFS132
#define c_wszManFS2 c_wszManFS232
#define c_wszManHS1 c_wszManHS132
#define c_wszManHS2 c_wszManHS232
#endif


///////////////////////////////////////////////////////////////////////////////
// internal structs

typedef enum tagEManifestOptions
{
    emoUseIEforURLs      = 0x1,
    emoSupressBucketLogs = 0x2,
    emoNoDefCabLimit     = 0x4,
    emoShowDebugButton   = 0x8,
} EManifestOptions;

typedef struct tagSDWManifestBlob
{
    LPCWSTR wszTitle;
    UINT    nidTitle;
    LPCWSTR wszErrMsg;
    UINT    nidErrMsg;
    LPCWSTR wszHdr;
    UINT    nidHdr;
    LPCWSTR wszStage1;
    LPCWSTR wszStage2;
    LPCWSTR wszBrand;
    LPCWSTR wszFileList;
    LPCWSTR wszEventSrc;
    LPCWSTR dwEventId;
    LPCWSTR wszCorpPath;
    LPCWSTR wszSendBtn;
    LPCWSTR wszNoSendBtn;
    LPWSTR  wszPlea;
    DWORD   dwOptions;

    // fault / hang reporting specific stuff
    PROCESS_INFORMATION pi;
    LPVOID              pvEnv;
    HANDLE              hToken;
    BOOL                fIsMSApp;
} SDWManifestBlob;

typedef struct tagSSuspendThreads
{
    HANDLE  *rghThreads;
    DWORD   cThreads;
} SSuspendThreads;



///////////////////////////////////////////////////////////////////////////////
// prototypes
void __cdecl TextLogOut(PCSTR pszFormat, ...);

#ifndef MANIFEST_HEAP
BOOL InternalGenerateMinidump(HANDLE hProc, DWORD dwpid, LPCWSTR wszPath,
                              SMDumpOptions *psmdo);
BOOL InternalGenerateMinidump(HANDLE hProc, DWORD dwpid, HANDLE hFile,
                              SMDumpOptions *psmdo, LPCWSTR wszPath);
#else
BOOL InternalGenerateMinidump(HANDLE hProc, DWORD dwpid, LPCWSTR wszPath,
                              SMDumpOptions *psmdo, BOOL f64bit);

BOOL InternalGenerateMinidumpEx(HANDLE hProc, DWORD dwpid, HANDLE hFile,
                                SMDumpOptions *psmdo, LPCWSTR wszPath, BOOL f64bit);
BOOL InternalGenFullAndTriageMinidumps(HANDLE hProc, DWORD dwpid, LPCWSTR wszPath,
                                  HANDLE hFile, SMDumpOptions *psmdo, BOOL f64bit);

BOOL CopyFullAndTriageMiniDumps(LPWSTR pwszTriageDumpFrom,LPWSTR pwszTriageDumpTo);
#endif  // MANIFEST_HEAP

HRESULT GetExePath(HANDLE hProc, LPWSTR wszPath, DWORD cchPath);
HRESULT GetVerName(LPWSTR wszModule, LPWSTR wszName, DWORD cchName,
                   LPWSTR wszVer = NULL, DWORD cchVer = 0,
                   LPWSTR wszCompany = NULL, DWORD cchCompany = 0,
                   BOOL fAcceptUnicodeCP = FALSE,
                   BOOL fWantActualName = FALSE);
HRESULT BuildManifestURLs(LPWSTR wszAppName, LPWSTR wszModName,
                          WORD rgAppVer[4], WORD rgModVer[4], UINT64 pvOffset,
                          BOOL f64Bit, LPWSTR *ppwszS1, LPWSTR *ppwszS2,
                          LPWSTR *ppwszCP, BYTE **ppb);
EFaultRepRetVal StartDWManifest(CPFFaultClientCfg &oCfg, SDWManifestBlob& dwmb,
                                LPWSTR wszManifestIn = NULL,
                                BOOL fAllowSend = TRUE,
                                DWORD dwTimeout = 300000);
BOOL TransformForWire(LPCWSTR wszSrc, LPWSTR wszDest, DWORD cchDest);
LPWSTR MarshallString(LPCWSTR wszSrc, PBYTE pBase, ULONG cbMaxBuf,
                      PBYTE *ppToWrite, DWORD *pcbWritten);
BOOL GetAppCompatData(LPCWSTR wszAppPath, LPCWSTR wszModPath, LPCWSTR wszFile);



BOOL IsASCII(LPCWSTR wszSrc);

void FreezeAllThreads(void);

BOOL DoUserContextsMatch(void);
BOOL DoWinstaDesktopMatch(void);
BOOL AmIPrivileged(BOOL fOnlyCheckLS);
BOOL FindAdminSession(DWORD *pdwSession, HANDLE *phToken);

BOOL FreezeAllThreads(DWORD dwpid, DWORD dwtidFilter, SSuspendThreads *pst);
BOOL ThawAllThreads(SSuspendThreads *pst);

HRESULT LogHang(LPCWSTR wszApp, WORD *rgAppVer, LPCWSTR wszMod, WORD *rgModVer,
                ULONG64 ulOffset, BOOL f64bit);
HRESULT LogUser(LPCWSTR wszApp, WORD *rgAppVer, LPCWSTR wszMod, WORD *rgModVer,
                ULONG64 ulOffset, BOOL f64bit, DWORD dwEventID);
#ifndef _WIN64
HRESULT LogKrnl(ULONG ulBCCode, ULONG ulBCP1, ULONG ulBCP2, ULONG ulBCP3,
                ULONG ulBCP4);
#else
HRESULT LogKrnl(ULONG ulBCCode, ULONG64 ulBCP1, ULONG64 ulBCP2, ULONG64 ulBCP3,
                ULONG64 ulBCP4);
#endif




///////////////////////////////////////////////////////////////////////////////
// inlines

// **************************************************************************
inline DWORD RolloverSubtract(DWORD dwA, DWORD dwB)
{
    return (dwA >= dwB) ? (dwA - dwB) : (dwA + ((DWORD)-1 - dwB));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\mdtosig.h ===
/****************************************************************************
Copyright (c) 2000 Microsoft Corporation

Module Name:
    mdtosig.h

Abstract:
    signature extraction library

Revision History:

    DerekM      created     04/04/00

****************************************************************************/

#ifndef MDTOSIG_H
#define MDTOSIG_H

#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// constants

const DWORD c_bAppUsed    = 0x01;
const DWORD c_bAppVerUsed = 0x02;
const DWORD c_bModUsed    = 0x04;
const DWORD c_bModVerUsed = 0x08;
const DWORD c_bOffsetUsed = 0x10;


/////////////////////////////////////////////////////////////////////////////
// CFaultSignature

class CFaultSignature : public CPFGenericClassBase
{
public:
    OSVERSIONINFOEXW    osv;
    CComBSTR            bstrApp;
    CComBSTR            bstrAppVer;
    CComBSTR            bstrMod;
    CComBSTR            bstrModVer;
    CComBSTR            bstrAppFullPath;
    DWORD               dwSigID;
    DWORD               dwIncID;
    DWORD               dwOffset;
    DWORD               dwUsed;

    CFaultSignature(void)
    {
        ZeroMemory(&this->osv, sizeof(this->osv));
        this->dwOffset   = 0;
        this->dwUsed     = 0;
        this->dwSigID    = 0;
        this->dwIncID    = 0;
    }

    void Clear(void)
    {
        ZeroMemory(&this->osv, sizeof(this->osv)); 
        this->bstrApp.Empty();
        this->bstrAppVer.Empty();
        this->bstrMod.Empty();
        this->bstrModVer.Empty();
        this->bstrAppFullPath.Empty();
        this->dwOffset   = 0;
        this->dwUsed     = 0;
        this->dwSigID    = 0;
        this->dwIncID    = 0;
    }

    HRESULT ExtractSigFromDump(LPWSTR wszDump, LPWSTR wszExec = NULL, 
                               BOOL *pfR0 = NULL);
    DWORD   GenerateSigID(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\ntevents.h ===
/********************************************************************

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:
    ntevents.h

Abstract:
    Defines a generic class that can register an NT
    event source and log NT events on that evens source.

Revision History:
    rsraghav  created   03/10/95
    DerekM    modified  04/06/99

********************************************************************/


#ifndef NTEVENTS_H
#define NTEVENTS_H
                
#include "util.h"
                 
//////////////////////////////////////////////////////////////////////
// CNTEvent - class definition

class CNTEvent : public CPFGenericClassBase
{
private:
    // member data
    HANDLE  m_hEventSource;

public:
    CNTEvent(void);
    ~CNTEvent(void);

    HRESULT InitEventLog(LPCWSTR wszEventSourceName);
    HRESULT TerminateEventLog(void);

    HRESULT LogEvent(WORD wEventType, DWORD dwEventID, 
                     LPCWSTR wszParam1 = NULL, LPCWSTR wszParam2 = NULL, 
                     LPCWSTR wszParam3 = NULL, LPCWSTR wszParam4 = NULL,
                     LPCWSTR wszParam5 = NULL, LPCWSTR wszParam6 = NULL,
                     LPCWSTR wszParam7 = NULL, LPCWSTR wszParam8 = NULL, 
                     LPCWSTR wszParam9 = NULL);

    HRESULT LogError(DWORD dwEventID, LPCWSTR wszParam1 = NULL, 
                     LPCWSTR wszParam2 = NULL, LPCWSTR wszParam3 = NULL, 
                     LPCWSTR wszParam4 = NULL, LPCWSTR wszParam5 = NULL,
                     LPCWSTR wszParam6 = NULL, LPCWSTR wszParam7 = NULL,
                     LPCWSTR wszParam8 = NULL, LPCWSTR wszParam9 = NULL)
    {
        return LogEvent(EVENTLOG_ERROR_TYPE, dwEventID, wszParam1, 
                        wszParam2, wszParam3, wszParam4, wszParam5, 
                        wszParam6, wszParam7, wszParam8, wszParam9);
    }

    HRESULT LogWarning(DWORD dwEventID, LPCWSTR wszParam1 = NULL, 
                    LPCWSTR wszParam2 = NULL, LPCWSTR wszParam3 = NULL, 
                    LPCWSTR wszParam4 = NULL, LPCWSTR wszParam5 = NULL,
                    LPCWSTR wszParam6 = NULL, LPCWSTR wszParam7 = NULL,
                    LPCWSTR wszParam8 = NULL, LPCWSTR wszParam9 = NULL)
    {
        return LogEvent(EVENTLOG_WARNING_TYPE, dwEventID, wszParam1,
                        wszParam2, wszParam3, wszParam4, wszParam5, 
                        wszParam6, wszParam7, wszParam8, wszParam9);
    }

    HRESULT LogInfo(DWORD dwEventID, LPCWSTR wszParam1 = NULL, 
                    LPCWSTR wszParam2 = NULL, LPCWSTR wszParam3 = NULL, 
                    LPCWSTR wszParam4 = NULL, LPCWSTR wszParam5 = NULL,
                    LPCWSTR wszParam6 = NULL, LPCWSTR wszParam7 = NULL,
                    LPCWSTR wszParam8 = NULL, LPCWSTR wszParam9 = NULL)
    {
        return LogEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, wszParam1,
                        wszParam2, wszParam3, wszParam4, wszParam5, 
                        wszParam6, wszParam7, wszParam8, wszParam9);
    }
};

//////////////////////////////////////////////////////////////////////
// useful for converting numbers to insert strings

#define USES_LOGEVENT_CONVERSIONS   LPWSTR __szLgEvTmp__;    // max size of DWORD string=12
#define USES_ERR_STR                LPWSTR __szErrStr__;
#define Str08x(dw)          (__szLgEvTmp__=(LPWSTR)_alloca(12  * sizeof(WCHAR)), wsprintfW(__szLgEvTmp__, L"0x%08x", dw), __szLgEvTmp__)
#define Str04x(dw)          (__szLgEvTmp__=(LPWSTR)_alloca(12  * sizeof(WCHAR)), wsprintfW(__szLgEvTmp__, L"0x%04x", dw), __szLgEvTmp__)
#define Strx(dw)            (__szLgEvTmp__=(LPWSTR)_alloca(12  * sizeof(WCHAR)), wsprintfW(__szLgEvTmp__, L"0x%x", dw)  , __szLgEvTmp__)
#define Strd(dw)            (__szLgEvTmp__=(LPWSTR)_alloca(12  * sizeof(WCHAR)), wsprintfW(__szLgEvTmp__, L"%d", dw)    , __szLgEvTmp__)
#define StrFromErr(dwErr)   (__szErrStr__ =(LPWSTR)_alloca(256 * sizeof(WCHAR)), FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | 80, NULL, dwErr, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), __szErrStr__, 256, NULL), __szErrStr__)

#endif // NTEVENTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\perfdata.h ===
/********************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    perfdata.h

Abstract:
    FTS performance data defines

Revision History:
    DerekM  created  04/01/00

********************************************************************/

#ifndef PERFDATA_H
#define PERFDATA_H

#include <tchar.h>

// structure to map the memory blob to.  There should be one item per
//  PERF_COUNTER_DEFINITION in datadefs.h.  Also, the ordering of the 
//  PERF_COUNTER_DEFINITIONs in datadefs.h MUST match the ordering of 
//  the corresponding data item below.
struct SPerfDataBlob
{
    DWORD   cFiles;
    DWORD   cFilesR0;
    DWORD   cFilesR3;
};

// exported methods out of the dll that we'll need to use from the app
extern "C" HRESULT APIENTRY AppInitPerfCtr(SPerfDataBlob **ppPtrs, DWORD cbExpected);
extern "C" HRESULT APIENTRY AppTerminatePerfCtr(void);

// reg stuff
const TCHAR   c_szRVPerfLib[]         = _T("Library");
const TCHAR   c_szRVPerfLibVal[]      = _T("ftsperf.dll");
const TCHAR   c_szRVPerfClose[]       = _T("Close");
const TCHAR   c_szRVperfCloseVal[]    = _T("PerfClose");
const TCHAR   c_szRVPerfOpen[]        = _T("Open");
const TCHAR   c_szRVPerfOpenVal[]     = _T("PerfOpen");
const TCHAR   c_szRVPerfCollect[]     = _T("Collect");
const TCHAR   c_szRVPerfCollectVal[]  = _T("PerfCollect");


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\pfarray.h ===
/********************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    PFArray.cpp

Abstract:
    dynamic array table definition.

Revision History:
    DerekM  created  03/14/00

********************************************************************/

#ifndef PFARRAY_H
#define PFARRAY_H

#include "util.h"

typedef void   (*pfnPFArrayDelete)(LPVOID pv);
typedef LPVOID (*pfnPFArrayAllocCopy)(LPVOID pv);

/////////////////////////////////////////////////////////////////////////////
// CPFArray definition

class CPFArrayBase : public CPFPrivHeapGenericClassBase
{
protected:
    // member data
    pfnPFArrayAllocCopy m_pfnAlloc;
    pfnPFArrayDelete    m_pfnDelete;
    LPVOID              *m_rgpv;
    DWORD               m_cSlots;
    DWORD               m_iHighest;

    // internal methods
    virtual void   DeleteItem(LPVOID pv)
    {
        if (m_pfnDelete != NULL && pv != NULL)
            (*m_pfnDelete)(pv);
    }

    virtual LPVOID AllocItemCopy(LPVOID pv)
    {
        return (m_pfnAlloc != NULL && pv != NULL) ? ((*m_pfnAlloc)(pv)) : NULL;
    }

    HRESULT CompressArray(DWORD iStart, DWORD iEnd);
    HRESULT Grow(DWORD iMinLast);
    HRESULT internalCopyFrom(CPFArrayBase *rg);

public:
    // construction
    CPFArrayBase(void);
    virtual ~CPFArrayBase(void);
    
    // exposed methods
    void SetDeleteMethod(pfnPFArrayDelete pfnDelete)  { m_pfnDelete = pfnDelete; }
    void SetAllocMethod(pfnPFArrayAllocCopy pfnAlloc) { m_pfnAlloc  = pfnAlloc;  }

    LPVOID  &operator [](DWORD index);

    HRESULT Init(DWORD cSlots);
    DWORD   get_Highest(void)  { return m_iHighest; }

    HRESULT Append(LPVOID pv);
    HRESULT Remove(DWORD iItem, LPVOID *ppvOld = NULL);
    HRESULT RemoveAll(void);
    HRESULT get_Item(DWORD iItem, LPVOID *ppv);
    HRESULT put_Item(DWORD iItem, LPVOID pv, LPVOID *ppvOld = NULL);
};


/////////////////////////////////////////////////////////////////////////////
// CPFArrayBSTR definition

class CPFArrayBSTR : public CPFArrayBase
{
private:
    void DeleteItem(LPVOID pv)
    {
        SysFreeString((BSTR)pv);
    }

    LPVOID AllocItemCopy(LPVOID pv)
    {
        return (pv != NULL) ? ((LPVOID)SysAllocString((BSTR)pv)) : NULL;
    }

public:
    HRESULT CopyFrom(CPFArrayBSTR *prg) 
    { 
        return internalCopyFrom(prg);
    }
};


/////////////////////////////////////////////////////////////////////////////
// CPFArrayUnk definition

class CPFArrayUnknown : public CPFArrayBase
{
private:
    void DeleteItem(LPVOID pv)
    {
        if (pv != NULL)
            ((LPUNKNOWN)pv)->Release();
    }

    LPVOID AllocItemCopy(LPVOID pv)
    {
        if (pv != NULL)
            ((LPUNKNOWN)pv)->AddRef();
        return pv;
    }

public:
    HRESULT CopyFrom(CPFArrayUnknown *prg) 
    { 
        return internalCopyFrom(prg);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\pfcrc.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    pfcrc.h

Abstract:
    This file contains the implementation of some utility functions for
    computing CRCs.  table & algo stolen from MPC_Common...

Revision History:
    derekm      created     04/25/00

******************************************************************************/

#ifndef PFCRC_H
#define PFCRC_H

DWORD ComputeCRC32(UCHAR *pb, DWORD cb);
DWORD ComputeCRC32(HANDLE hFile);
DWORD ComputeCRC32File(LPWSTR wszFile);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\pfcab.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    pfcab.h

Abstract:
    FDU main 

Revision History:
    created     derekm      02/23/00

******************************************************************************/

#ifndef PFCAB_H
#define PFCAB_H

#include "pfarray.h"

//////////////////////////////////////////////////////////////////////////////
//  global

HRESULT PFExtractFromCab(LPWSTR wszCab, LPWSTR wszDestFile, 
                         LPWSTR wszFileToFind);
HRESULT PFGetCabFileList(LPWSTR wszCabName, CPFArrayBSTR &rgFiles);
HRESULT PFCreateCab(LPCWSTR wszCabName, CPFArrayBSTR &rgFiles);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\pferrs.h ===
/********************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    pferrs.h

Abstract:
    errors used in product feedback

Revision History:
    DerekM    modified  04/06/99
    DerekM    modified  03/30/00

********************************************************************/

#ifndef PFERR_H
#define PFERR_H

// //////////////////////////////////////////////////////////////////////////
//  PCH server error codes

// used by the file manager to indicate that the thread should shutdown
#define E_PCH_SHUTDOWN                   _HRESULT_TYPEDEF_(0x80061001)

// used by the main thread to indicate a configuration error
#define E_PCH_CONFIGERR                  _HRESULT_TYPEDEF_(0x80061002)

// used to indicate that bad XML data has been encountered
#define E_PCH_BADXMLDATA                 _HRESULT_TYPEDEF_(0x80061003)

// used to indicate that a SQL error has occurred
#define E_PCH_SQLERRROR                  _HRESULT_TYPEDEF_(0x80061004)



// //////////////////////////////////////////////////////////////////////////
//  PCH client error codes

// the URL sent by the client is not trusted.
#define E_UNTRUSTED_URL                  _HRESULT_TYPEDEF_(0x80062001)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\pfstm.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    pfstm.h

Abstract:
    This file contains the definitions of various stream objects

Revision History:
    created     derekm      01/19/00

******************************************************************************/

#ifndef PFSTM_H
#define PFSTM_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "util.h"

//////////////////////////////////////////////////////////////////////////////
//  CStreamBase

class CPFStreamBase : 
    public IStream,
    public CPFGenericClassBase
{
private:
    DWORD   m_cRef;

public:
    CPFStreamBase(void) { m_cRef = 0; }
    virtual ~CPFStreamBase(void) {}

    // IUnknown Interface
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppv)
    {
        if (ppv == NULL)
            return E_INVALIDARG;

        *ppv = NULL;

        if (riid == IID_IUnknown)
            *ppv = (IUnknown *)this;
        else if (riid == IID_IStream)
            *ppv = (IStream *)this;
        else if (riid == IID_ISequentialStream)
            *ppv = (ISequentialStream *)this;
        else
            return E_NOINTERFACE;

        this->AddRef();
        return NOERROR;
    }

    STDMETHOD_(ULONG, AddRef)()
    {
        return InterlockedIncrement((LONG *)&m_cRef);
    }

    STDMETHOD_(ULONG, Release)()
    {
        if (InterlockedDecrement((LONG *)&m_cRef) == 0)
        {
            delete this;
            return 0;
        }

        return m_cRef;
    }

    // ISequentialStream Interface
    STDMETHOD(Read)(void *pv, ULONG cb, LONG *pcbRead) { return E_NOTIMPL; }
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten) { return E_NOTIMPL; }

    // IStream Interface
    STDMETHOD(Seek)(LARGE_INTEGER libMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition ) { return E_NOTIMPL; }
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize) { return E_NOTIMPL; }
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten ) { return E_NOTIMPL; }
    STDMETHOD(Commit)(DWORD grfCommitFlags) { return E_NOTIMPL; }
    STDMETHOD(Revert)(void) { return E_NOTIMPL; }
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType ) { return E_NOTIMPL; }
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType ) { return E_NOTIMPL; }
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag) { return E_NOTIMPL; }
    STDMETHOD(Clone)(IStream **ppstm) { return E_NOTIMPL; }
};


//////////////////////////////////////////////////////////////////////////////
//  CPFStreamFile

class CPFStreamFile : public CPFStreamBase
{
private:
    // member data
    HANDLE      m_hFile;
    DWORD       m_dwAccess;

public:
    CPFStreamFile(void);
    ~CPFStreamFile(void);

    static CPFStreamFile *CreateInstance(void) { return new CPFStreamFile; }

    HRESULT Open(LPCWSTR szFile, DWORD dwAccess, DWORD dwDisposition, 
                 DWORD dwSharing);
    HRESULT Open(HANDLE hFile, DWORD dwAccess);
    HRESULT Close(void);

    // ISequentialStream Interface
    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten);

    // IStream Interface
    STDMETHOD(Seek)(LARGE_INTEGER libMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream **ppstm);
};


//////////////////////////////////////////////////////////////////////////////
//  CStreamMem

class CPFStreamMem : public CPFStreamBase
{
    LPVOID  m_pvData;
    LPVOID  m_pvPtr;
    DWORD   m_cb;
    DWORD   m_cbRead;
    DWORD   m_cbWrite;
    DWORD   m_cbGrow;

public:
    CPFStreamMem(void);
    ~CPFStreamMem(void);

    static CPFStreamMem *CreateInstance(void) { return new CPFStreamMem; }

    HRESULT Init(DWORD cbStart = (DWORD)-1, DWORD cbGrowBy = (DWORD)-1);
    HRESULT InitBinBlob(LPVOID pv, DWORD cb, DWORD cbGrowBy = 0);
    HRESULT InitTextBlob(LPCWSTR wsz, DWORD cch, BOOL fConvertToANSI);
    HRESULT InitTextBlob(LPCSTR sz, DWORD cch, BOOL fConvertToWCHAR);
    HRESULT Clean(void);

    // ISequentialStream Interface
    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten);

    // IStream Interface
    STDMETHOD(Seek)(LARGE_INTEGER libMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream **ppstm);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\pfhash.h ===
/********************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    hashtbl.h

Abstract:
    contains the CPFHash def.  Note that this hash table is in NO
     WAY thread safe.

Revision History:
    DerekM  created  05/01/99
    DerekM  modified 03/06/00

********************************************************************/

#ifndef PFHASH_H
#define PFHASH_H

/*
#if defined(DEBUG) || defined(_DEBUG)
#include <stdio.h>
#endif
*/

#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// SPFHashEntry definition

struct SPFHashObj
{
    LPVOID      pvTag;
    LPVOID      pvData;
    SPFHashObj  *pNext;
};

typedef void (*pfnDeleteHash)(LPVOID pv);

/////////////////////////////////////////////////////////////////////////////
// CPFHashBase definition

class CPFHashBase : public CPFGenericClassBase
{
protected:
    // member data
    pfnDeleteHash   m_pfnDelete;
    SPFHashObj      **m_rgpMap;
    DWORD           m_cObjs;
    DWORD           m_cSlots;

    SPFHashObj      *m_pEnumNext;
    DWORD           m_iEnumSlot;


    // internal type specific methods
    virtual HRESULT AllocTag(LPVOID pvTag, LPVOID *ppvTagCopy) = 0;
    virtual DWORD   ComputeSlot(LPVOID pvTag) = 0;
    virtual void    DeleteTag(LPVOID pvTag) = 0;
    virtual INT_PTR CompareTag(LPVOID pvTag1, LPVOID pvTag2) = 0;

    // internal methods
    SPFHashObj  *FindInChain(LPVOID pvTag, DWORD iSlot, 
                             SPFHashObj ***pppObjStore = NULL);
    void        Cleanup(void);

public:
    // construction
    CPFHashBase(void);
    virtual ~CPFHashBase(void);

    void    SetDeleteMethod(pfnDeleteHash pfnDelete) { m_pfnDelete = pfnDelete; }

    // exposed methods
    HRESULT Init(DWORD cSlots = 31);

    HRESULT AddToMap(LPVOID pvTag, LPVOID pv, LPVOID *ppvOld = NULL);
    HRESULT RemoveFromMap(LPVOID pvTag, LPVOID *ppvOld = NULL);
    HRESULT FindInMap(LPVOID pvTag, LPVOID *ppv);
    HRESULT RemoveAll(void);

    HRESULT BeginEnum(void);
    HRESULT EnumNext(LPVOID *ppvTag, LPVOID *ppvData);
/*
#if defined(DEBUG) || defined(_DEBUG)
    virtual void PrintTag(FILE *pf, LPVOID pvTag) { fprintf(pf, "0x%08x, ", pvTag); }
    void DumpAll(FILE *pf);
    void DumpCount(FILE *pf);
#endif
*/
};


/////////////////////////////////////////////////////////////////////////////
// CPFHashWSTR definition

class CPFHashWSTR : public CPFHashBase
{
private:
    virtual HRESULT AllocTag(LPVOID pvTag, LPVOID *ppvTagCopy);
    virtual DWORD   ComputeSlot(LPVOID pvTag);
    virtual void    DeleteTag(LPVOID pvTag);
    virtual INT_PTR CompareTag(LPVOID pvTag1, LPVOID pvTag2);

public:
    CPFHashWSTR(void) {}
/*
#if defined(DEBUG) || defined(_DEBUG)
    virtual void PrintTag(FILE *pf, LPVOID pvTag) { fprintf(pf, "%ls, ", (WCHAR *)pvTag); }
#endif
*/
};


/////////////////////////////////////////////////////////////////////////////
// CPFHashDWORD definition

class CPFHashDWORD : public CPFHashBase
{
private:
    virtual HRESULT AllocTag(LPVOID pvTag, LPVOID *ppvTagCopy) 
    { 
        *ppvTagCopy = pvTag;
        return NOERROR;
    }

    virtual DWORD ComputeSlot(LPVOID pvTag)
    {
        return (DWORD)(((DWORD_PTR)pvTag) % (DWORD_PTR)m_cSlots);
    }

    virtual void DeleteTag(LPVOID pvTag)
    {
    };

    virtual INT_PTR CompareTag(LPVOID pvTag1, LPVOID pvTag2)
    {
        return (INT_PTR)pvTag1 - (INT_PTR)pvTag2;
    }

public:
    CPFHashDWORD(void) {}
/*
#if defined(DEBUG) || defined(_DEBUG)
    virtual void PrintTag(FILE *pf, LPVOID pvTag) { fprintf(pf, "%d, ", (DWORD)pvTag); }
#endif
*/
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\pfdb.h ===
/********************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    pfdb.h

Abstract:
    definition for the class that encapsulates all DB access

Revision History:
    DerekM  created  05/01/99
    DerekM  modified 02/24/00
    DerekM  modified 03/24/00

********************************************************************/

#ifndef PFDB_H
#define PFDB_H

#include "util.h"
#include "adoint.h"

/////////////////////////////////////////////////////////////////////////////
// constants

const DWORD     c_cInitialProps = 16;


/////////////////////////////////////////////////////////////////////////////
// CPFDB definition

class CPFDB : private CPFGenericClassBase,
              public IUnknown
{
private:
    // meber data
    CommandTypeEnum m_cte;
    ADOConnection   *m_pConn;
    ADOParameters   *m_pParams;
    ADORecordset    *m_pRS;
    ADOParameter    **m_rgpParams;
    ADOCommand      *m_pCmd;
    ADOFields       *m_pFields;
    CComBSTR        m_bstrCmd;
    CComBSTR        m_bstrConn;
    DWORD           m_cSlots;
    DWORD           m_iLastSlot;
    DWORD           m_cRef;
    BOOL            m_fNeedReset;
    
    // internal methods
    HRESULT GetData(VARIANT &varField, VARIANT *pvarData);
    HRESULT GetOutParam(VARIANT &varParam, VARIANT *pvarData, VARTYPE vt);
    HRESULT TestConnAndRefresh(void);
    HRESULT AddParameterObj(DWORD iPos);
    void    Cleanup(void);

public:
    CPFDB(void);
    ~CPFDB(void);

    static CPFDB *CreateInstance(void) { return new CPFDB(); }
    STDMETHOD(QueryInterface)(REFIID, LPVOID *) { return E_NOTIMPL; }
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    HRESULT Reset(void);
    HRESULT Init(LPCWSTR wszConn, DWORD dwTimeout = 300);
    HRESULT Init(ADOConnection *pConn, DWORD dwTimeout = 300, 
                 BSTR bstrConn = NULL);
    HRESULT Begin(LPCWSTR wszCmd, CommandTypeEnum cte = adCmdText);
    HRESULT AddInParam(VARIANT &varData, DataTypeEnum dtADO, DWORD iPos = -1);
    HRESULT AddOutParam(DataTypeEnum dtADO, DWORD iPos = -1, 
                        BOOL fSPRetVal = FALSE, DWORD cchSize = 0);
    HRESULT Execute(BOOL fWantRS = TRUE);

    HRESULT GetOutParam(BSTR bstrParam, VARIANT *pvarData, VARTYPE vt = VT_ILLEGAL);
    HRESULT GetOutParam(DWORD iParam, VARIANT *pvarData, VARTYPE vt = VT_ILLEGAL);
    HRESULT GetErrors(ADOErrors **ppErrs);

    HRESULT GetNextRow(void);
    HRESULT GetData(BSTR bstrField, VARIANT *pvarData);
    HRESULT GetData(DWORD iField, VARIANT *pvarData);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\pftn.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    pftn.h

Abstract:
    Thread neutral COM ptrs.  This is stolen from dmassare's MPC_COM.h file
    pretty much intact (with tracing & some stylistic changes added in)

Revision History:
    created     derekm      04/12/00

******************************************************************************/

#ifndef PFTN_H
#define PFTN_H

#include "util.h"

/////////////////////////////////////////////////////////////////////////////
//  global vars

class CPFModule;
extern CPFModule _PFModule;


/////////////////////////////////////////////////////////////////////////////
//  CComPtrThreadNeutral_GIT

// Class used to act as an hub for all the instances of CComPtrThreadNeutral<T>.
// It holds the Global Interface Table.
class CPFComPtrThreadNeutral_GIT
{
    // member data
    IGlobalInterfaceTable   *m_pGIT;
    CRITICAL_SECTION        m_cs;

    // private member fns
    HRESULT GetGIT(IGlobalInterfaceTable **ppGIT);
    void    Lock(void);
    void    Unlock(void);

public:
    CPFComPtrThreadNeutral_GIT(void);
    ~CPFComPtrThreadNeutral_GIT(void);

    HRESULT Init(void);
    HRESULT Term(void);

    HRESULT RegisterInterface(IUnknown *pUnk, REFIID riid, DWORD *pdwCookie);
    HRESULT RevokeInterface(DWORD dwCookie);
    HRESULT GetInterface(DWORD dwCookie, REFIID riid, LPVOID *ppv);
};


/////////////////////////////////////////////////////////////////////////////
//  CComPtrThreadNeutral

// This smart pointer template stores THREAD-INDEPEDENT pointers to COM objects.
// The best way to use it is to store an object reference into it and then assign
//  the object itself to a CComPtr<T>.
// This way the proper proxy is looked up and the smart pointer will keep it alive.

template <class T> class CPFComPtrThreadNeutral
{
private:
    // member data
    DWORD m_dwCookie;

    // private fns
    void InnerRegister(T *lp)
    {
        if (lp != NULL)
            _PFModule.m_GITHolder.RegisterInterface(lp, __uuidof(T), &m_dwCookie);
    }

public:
    typedef T _PtrClass;

    //////////////////////////////////////////////////////////////////////

    CPFComPtrThreadNeutral(void)
    {
        m_dwCookie = 0xFEFEFEFE;
    }

    CPFComPtrThreadNeutral(T *lp)
    {
        m_dwCookie = 0xFEFEFEFE;
        this->InnerRegister(lp);
    }

    ~CPFComPtrThreadNeutral(void)
    {
        this->Release();
    }

    //////////////////////////////////////////////////////////////////////

    operator CComPtr<T>() const
    {
        CComPtr<T> res;

        (void)this->Access(&res);
        return res;
    }

    CComPtr<T> operator=(T *lp)
    {
        this->Release();
        this->InnerRegister(lp);
        return (CComPtr<T>)(*this);
    }

    bool operator!() const
    {
        return (m_dwCookie == 0xFEFEFEFE);
    }

    //////////////////////////////////////////////////////////////////////

    void Release(void)
    {
        if (m_dwCookie != 0xFEFEFEFE)
        {
            _PFModule.m_GITHolder.RevokeInterface(m_dwCookie);
            m_dwCookie = 0xFEFEFEFE;
        }
    }

    void Attach(T *p)
    {
        *this = p;
        if (p != NULL) 
            p->Release();
    }

    T *Detach(void)
    {
        T *pt;
        (void)this->Access(&pt);
        this->Release();
        return pt;
    }

    HRESULT Access(T **ppt) const
    {
        HRESULT hr;

        if (ppt == NULL)
        {
            hr = E_POINTER;
        }
        else
        {
            *ppt = NULL;
            if (m_dwCookie != 0xFEFEFEFE)
                hr = _PFModule.m_GITHolder.GetInterface(m_dwCookie, 
                                                        __uuidof(T), 
                                                        (void**)ppt);
            else
                hr = S_FALSE;
        }

        return hr;
    }
};


/////////////////////////////////////////////////////////////////////////////
//  CPFCallItem

class CPFCallItem 
{
public:
    CPFComPtrThreadNeutral<IDispatch>   m_Dispatch;
    CPFComPtrThreadNeutral<IUnknown>    m_Unknown;
    CComVariant                         m_Other;
    VARTYPE                             m_vt;

    CPFCallItem(void);
    CPFCallItem& operator=(const CComVariant& var);
    operator CComVariant() const;
};


/////////////////////////////////////////////////////////////////////////////
//  CPFCallDesc

class CPFCallDesc
{
    CPFComPtrThreadNeutral<IDispatch>   m_dispTarget;
    CPFCallItem                         *m_rgciVars;
    DISPID                              m_dispidMethod;
    DWORD                               m_dwVars;

public:
    CPFCallDesc(void);
    ~CPFCallDesc(void);

    HRESULT Init(IDispatch *dispTarget, DISPID dispidMethod, 
                 const CComVariant *rgvVars, int dwVars);
    HRESULT Call(void);
};


/////////////////////////////////////////////////////////////////////////////
//  CPFModule

class CPFModule
{
public:
    CPFComPtrThreadNeutral_GIT  m_GITHolder;

    HRESULT Init(void);
    HRESULT Term(void);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\pfxml.h ===
/********************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    pfxml.h

Abstract:
    A simple XML parser & object model (for read only access to an XML
     file.  This is heavily (nearly stolen) based on WSmith's SimpleXML 
     stuff that he wrote for the Neptune comments button

Revision History:
    DerekM    created  03/15/00

********************************************************************/

#ifndef PFXML_H
#define PFXML_H

#include "util.h"
#include "pfarray.h"
#include "pfhash.h"

class CPFXMLParser;
class CPFXMLNode;

/////////////////////////////////////////////////////////////////////////////
// enumerations

enum EPFXMLNodeType
{
    xmlntUnknown = 0,
    xmlntElement,
    xmlntText,
};


/////////////////////////////////////////////////////////////////////////////
// CPFXMLDocument

class CPFXMLDocument : public CPFPrivHeapGenericClassBase
{
private:
    // member data
    CPFXMLNode  *m_ppfxmlRoot;

public:
    CPFXMLDocument(void);
    ~CPFXMLDocument(void);

    HRESULT get_RootNode(CPFXMLNode **pppfxmlRoot);
    HRESULT put_RootNode(CPFXMLNode *ppfxmlRoot);

    HRESULT ParseFile(LPWSTR wszFile);
    HRESULT ParseBlob(BYTE *pbBlob, DWORD cbBlob);
    HRESULT ParseStream(IStream *pStm, DWORD cbStm);
    HRESULT WriteFile(LPWSTR wszFile);
};

/////////////////////////////////////////////////////////////////////////////
// CPFArrayAttr definition

class CPFArrayAttr : public CPFArrayBase
{
private:
    void DeleteItem(LPVOID pv);
    LPVOID AllocItemCopy(LPVOID pv);

public:
    HRESULT CopyFrom(CPFArrayAttr *prg) 
    { 
        return internalCopyFrom(prg);
    }
};


/////////////////////////////////////////////////////////////////////////////
// CPFXMLDocument

class CPFXMLNode : private CPFPrivHeapGenericClassBase, public IUnknown
{
friend class CPFXMLDocument;

private:
    // memberdata
    CPFArrayUnknown m_rgChildren;
    EPFXMLNodeType  m_xmlnt;
    CPFArrayAttr    m_rgAttr;
    CComBSTR        m_bstrTagData;
    DWORD           m_cRef;

    // member functions
    CPFXMLNode(DWORD cRef);
    ~CPFXMLNode(void);

    HRESULT Write(HANDLE hFile);
    void    Cleanup(void);


public:
    static CPFXMLNode *CreateInstance(void);
    
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppv) { return E_NOTIMPL; }
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    EPFXMLNodeType get_NodeType(void)                 { return m_xmlnt; }
    void           put_NodeType(EPFXMLNodeType xmlnt) { m_xmlnt = xmlnt; }
        
    HRESULT get_Data(BSTR *pbstrData);
    HRESULT put_Data(LPCWSTR wszData, DWORD cch = (DWORD)-1);
    HRESULT append_Data(LPCWSTR wszData, DWORD cch = (DWORD)-1);

    DWORD   get_AttributeCount(void) { return m_rgAttr.get_Highest() + 1; }
    HRESULT add_Attribute(LPCWSTR wszName, LPCWSTR wszVal,
                          DWORD cchName = (DWORD)-1, DWORD cchVal = (DWORD)-1);
    HRESULT get_Attribute(LPCWSTR wszName, BSTR *pbstrVal);
    HRESULT get_Attribute(DWORD iAttr, BSTR *pbstrVal);

    DWORD   get_ChildCount(void) { return m_rgChildren.get_Highest() + 1; }
    HRESULT DeleteAllChildren(void);
    HRESULT append_Child(CPFXMLNode *ppfxml);
    HRESULT append_Children(CPFArrayUnknown &rgNodes);
    HRESULT get_Child(DWORD iChild, CPFXMLNode **pppfxml);
    HRESULT get_MatchingChildElements(LPCWSTR wszTag, CPFArrayUnknown &rgNodes);
    HRESULT get_ChildText(BSTR *pbstrText);

    HRESULT CloneNode(CPFXMLNode **pppfxml, BOOL fWantChildren = TRUE);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\util.h ===
/********************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    pfrutil.h

Abstract:
    PFR utility stuff

Revision History:
    DerekM  created  05/01/99

********************************************************************/

#ifndef PFRUTIL_H
#define PFRUTIL_H

// this turns on the manifest mode heap collection 
#define MANIFEST_HEAP

// make sure both _DEBUG & DEBUG are defined if one is defined.  Otherwise
//  the ASSERT macro never does anything
#if defined(_DEBUG) && !defined(DEBUG)
#define DEBUG 1
#endif
#if defined(DEBUG) && !defined(_DEBUG)
#define _DEBUG 1
#endif

#include "dbgtrace.h"

////////////////////////////////////////////////////////////////////////////
// tracing wrappers

// can't call HRESULT_FROM_WIN32 with a fn as a parameter cuz it is a macro
//  and evaluates the expression 3 times.  This is a particularlly bad thing
//  when u don't look at macros first to see what they do.
inline HRESULT ChangeErrToHR(DWORD dwErr) { return HRESULT_FROM_WIN32(dwErr); }

#if defined(NOTRACE)
    #define INIT_TRACING

    #define TERM_TRACING

    #define USE_TRACING(sz)

    #define DBG_MSG(sz)

    #define TESTHR(hr, fn)                                                  \
            hr = (fn);

    #define TESTBOOL(hr, fn)                                                \
            hr = ((fn) ? NOERROR : HRESULT_FROM_WIN32(GetLastError()));

    #define TESTERR(hr, fn)                                                 \
            SetLastError((fn));                                             \
            hr = HRESULT_FROM_WIN32(GetLastError());

    #define VALIDATEPARM(hr, expr)                                          \
            hr = ((expr) ? E_INVALIDARG : NOERROR);

    #define VALIDATEEXPR(hr, expr, hrErr)                                   \
            hr = ((expr) ? (hrErr) : NOERROR);

#else
    #define INIT_TRACING                                                    \
            InitAsyncTrace();

    #define TERM_TRACING                                                    \
            TermAsyncTrace();

    #define USE_TRACING(sz)                                                 \
            TraceQuietEnter(sz);                                            \
            TraceFunctEntry(sz);                                            \
            DWORD __dwtraceGLE = GetLastError();                            \

    #define DBG_MSG(sz)                                                     \
        ErrorTrace(0, sz)

    #define TESTHR(hr, fn)                                                  \
            if (FAILED(hr = (fn)))                                          \
            {                                                               \
                __dwtraceGLE = GetLastError();                              \
                ErrorTrace(0, "%s failed.  Err: 0x%08x", #fn, hr);          \
                SetLastError(__dwtraceGLE);                                 \
            }                                                               \

    #define TESTBOOL(hr, fn)                                                \
            hr = NOERROR;                                                   \
            if ((fn) == FALSE)                                              \
            {                                                               \
                __dwtraceGLE = GetLastError();                              \
                hr = HRESULT_FROM_WIN32(__dwtraceGLE);                      \
                ErrorTrace(0, "%s failed.  Err: 0x%08x", #fn, __dwtraceGLE);          \
                SetLastError(__dwtraceGLE);                                 \
            }

    #define TESTERR(hr, fn)                                                 \
            SetLastError((fn));                                             \
            if (FAILED(hr = HRESULT_FROM_WIN32(GetLastError())))            \
            {                                                               \
                __dwtraceGLE = GetLastError();                              \
                ErrorTrace(0, "%s failed.  Err: %d", #fn, __dwtraceGLE);              \
                SetLastError(__dwtraceGLE);                                 \
            }

    #define VALIDATEPARM(hr, expr)                                          \
            if (expr)                                                       \
            {                                                               \
                ErrorTrace(0, "Invalid parameters passed to %s",            \
                           ___pszFunctionName);                             \
                SetLastError(ERROR_INVALID_PARAMETER);                      \
                hr = E_INVALIDARG;                                          \
            }                                                               \
            else hr = NOERROR;

    #define VALIDATEEXPR(hr, expr, hrErr)                                   \
            if (expr)                                                       \
            {                                                               \
                ErrorTrace(0, "Expression failure %s", #expr);              \
                hr = (hrErr);                                               \
            }                                                               \
            else hr = NOERROR;

#endif


////////////////////////////////////////////////////////////////////////////
// Memory

#if defined(DEBUG) || defined(_DEBUG)

// this structure must ALWAYS be 8 byte aligned.  Add padding to the end if
//  it isn't.
struct SMyMemDebug
{
    __int64 hHeap;
    __int64 cb;
    DWORD   dwTag;
    DWORD   dwChk;
};
#endif


extern HANDLE g_hPFPrivateHeap;

// **************************************************************************
inline HANDLE MyHeapCreate(SIZE_T cbInitial = 8192, SIZE_T cbMax = 0)
{
    return HeapCreate(0, cbInitial, cbMax);
}

// **************************************************************************
inline BOOL MyHeapDestroy(HANDLE hHeap)
{
    return HeapDestroy(hHeap);
}

// **************************************************************************
inline LPVOID MyAlloc(SIZE_T cb, HANDLE hHeap = NULL, BOOL fZero = TRUE)
{
#if defined(DEBUG) || defined(_DEBUG)
    SMyMemDebug *psmmd;
    LPBYTE      pb;

    cb += (sizeof(SMyMemDebug) + 4);
    hHeap = (hHeap != NULL) ? hHeap : GetProcessHeap();
    pb = (LPBYTE)HeapAlloc(hHeap, ((fZero) ? HEAP_ZERO_MEMORY : 0), cb);
    if (pb != NULL)
    {
        psmmd = (SMyMemDebug *)pb;
        psmmd->hHeap = (__int64)hHeap;
        psmmd->cb    = (__int64)cb;
        psmmd->dwTag = 0xBCBCBCBC;
        psmmd->dwChk = 0xBCBCBCBC;

        // do this cuz it's easier than figuring out the alignment and
        //  manually converting it to a 4 byte aligned value
        *(pb + cb - 4) = 0xBC;
        *(pb + cb - 3) = 0xBC;
        *(pb + cb - 2) = 0xBC;
        *(pb + cb - 1) = 0xBC;

        pb = (PBYTE)pb + sizeof(SMyMemDebug);
    }
    return pb;

#else
    return HeapAlloc(((hHeap != NULL) ? hHeap : GetProcessHeap()),
                     ((fZero) ? HEAP_ZERO_MEMORY : 0), cb);
#endif
}

// **************************************************************************
inline LPVOID MyReAlloc(LPVOID pv, SIZE_T cb, HANDLE hHeap = NULL,
                        BOOL fZero = TRUE)
{
#if defined(DEBUG) || defined(_DEBUG)
    SMyMemDebug *psmmd;
    SIZE_T      cbOld;
    LPBYTE      pbNew;
    LPBYTE      pb = (LPBYTE)pv;

    // if this is NULL, force a call to HeapReAlloc so that it can set the
    //  proper error for GLE to fetch
    if (pv == NULL)
    {
        SetLastError(0);
        return NULL;
    }

    pb -= sizeof(SMyMemDebug);
    hHeap = (hHeap != NULL) ? hHeap : GetProcessHeap();

    // wrap this in a try block in case the memory was not allocated
    //  by us or is corrupted- in which case the following could
    //  cause an AV.
    __try
    {
        psmmd = (SMyMemDebug *)pb;
        cbOld = (SIZE_T)psmmd->cb;
        _ASSERT(psmmd->hHeap == (__int64)hHeap);
        _ASSERT(psmmd->dwTag == 0xBCBCBCBC);
        _ASSERT(psmmd->dwChk == 0xBCBCBCBC);

        // do this cuz it's easier than figuring out the alignment and
        //  manually converting it to a 4 byte aligned value
        _ASSERT(*(pb + cbOld - 4) == 0xBC);
        _ASSERT(*(pb + cbOld - 3) == 0xBC);
        _ASSERT(*(pb + cbOld - 2) == 0xBC);
        _ASSERT(*(pb + cbOld - 1) == 0xBC);

        if (psmmd->hHeap != (__int64)hHeap)
            hHeap = (HANDLE)(DWORD_PTR)psmmd->hHeap;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        _ASSERT(FALSE);
    }

    hHeap = *((HANDLE *)pb);

    cb += (sizeof(SMyMemDebug) + 4);
    pbNew = (LPBYTE)HeapReAlloc(hHeap, ((fZero) ? HEAP_ZERO_MEMORY : 0), pb, cb);
    if (pbNew != NULL)
    {
        psmmd = (SMyMemDebug *)pb;
        psmmd->hHeap = (__int64)hHeap;
        psmmd->cb    = (__int64)cb;
        psmmd->dwTag = 0xBCBCBCBC;
        psmmd->dwChk = 0xBCBCBCBC;

        // do this cuz it's easier than figuring out the alignment and
        //  manually converting it to a 4 byte aligned value
        *(pb + cb - 4) = 0xBC;
        *(pb + cb - 3) = 0xBC;
        *(pb + cb - 2) = 0xBC;
        *(pb + cb - 1) = 0xBC;

        pb = (PBYTE)pb + sizeof(SMyMemDebug);
    }

    return pv;

#else
    return HeapReAlloc(((hHeap != NULL) ? hHeap : GetProcessHeap()),
                       ((fZero) ? HEAP_ZERO_MEMORY : 0), pv, cb);
#endif
}

// **************************************************************************
inline BOOL MyFree(LPVOID pv, HANDLE hHeap = NULL)
{
#if defined(DEBUG) || defined(_DEBUG)
    SMyMemDebug *psmmd;
    SIZE_T      cbOld;
    HANDLE      hAllocHeap;
    LPBYTE      pb = (LPBYTE)pv;

    // if this is NULL, force a call to HeapFree so that it can set the
    //  proper error for GLE to fetch
    if (pv == NULL)
        return TRUE;

    pb -= sizeof(SMyMemDebug);
    hHeap = (hHeap != NULL) ? hHeap : GetProcessHeap();

    // wrap this in a try block in case the memory was not allocated
    //  by us or is corrupted- in which case the following could
    //  cause an AV.
    __try
    {
        psmmd = (SMyMemDebug *)pb;
        cbOld = (SIZE_T)psmmd->cb;
        _ASSERT(psmmd->hHeap == (__int64)hHeap);
        _ASSERT(psmmd->dwTag == 0xBCBCBCBC);
        _ASSERT(psmmd->dwChk == 0xBCBCBCBC);

        // do this cuz it's easier than figuring out the alignment and
        //  manually converting it to a 4 byte aligned value
        _ASSERT(*(pb + cbOld - 4) == 0xBC);
        _ASSERT(*(pb + cbOld - 3) == 0xBC);
        _ASSERT(*(pb + cbOld - 2) == 0xBC);
        _ASSERT(*(pb + cbOld - 1) == 0xBC);

        if (psmmd->hHeap != (__int64)hHeap)
            hHeap = (HANDLE)(DWORD_PTR)psmmd->hHeap;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        _ASSERT(FALSE);
    }

    FillMemory(pb, cbOld, 0xCB);

    return HeapFree(hHeap, 0, pb);

#else
    return HeapFree(((hHeap != NULL) ? hHeap : GetProcessHeap()), 0, pv);
#endif
}


////////////////////////////////////////////////////////////////////////////
// useful inlines / defines

// **************************************************************************
inline DWORD MyMax(DWORD a, DWORD b)
{
    return (a > b) ? a : b;
}

// **************************************************************************
inline DWORD MyMin(DWORD a, DWORD b)
{
    return (a <= b) ? a : b;
}

#define Err2HR(dwErr)   HRESULT_FROM_WIN32(dwErr)
#define sizeofSTRW(wsz) sizeof(wsz) / sizeof(WCHAR)


////////////////////////////////////////////////////////////////////////////
// Files

const WCHAR c_wszDirSuffix[]    = L".dir00";

HRESULT OpenFileMapped(LPWSTR wszFile, LPVOID *ppvFile, DWORD *pcbFile);
HRESULT DeleteTempFile(LPWSTR wszFile);
HRESULT MyCallNamedPipe(LPCWSTR wszPipe, LPVOID pvIn, DWORD cbIn,
                        LPVOID pvOut, DWORD cbOut, DWORD *pcbRead,
                        DWORD dwWaitPipe, DWORD dwWaitRead = INFINITE);
DWORD CreateTempDirAndFile(LPCWSTR wszTempDir, LPCWSTR wszName,
                             LPWSTR *pwszPath);
BOOL DeleteTempDirAndFile(LPCWSTR wszPath, BOOL fFilePresent);
#ifdef MANIFEST_HEAP
BOOL DeleteFullAndTriageMiniDumps(LPCWSTR wszPath);
#endif  // MANIFEST_HEAP

////////////////////////////////////////////////////////////////////////////
// Security

BOOL AllocSD(SECURITY_DESCRIPTOR *psd, DWORD dwOLs, DWORD dwAd, DWORD dwWA);
void FreeSD(SECURITY_DESCRIPTOR *psd);
BOOL IsUserAnAdmin(HANDLE hToken);


////////////////////////////////////////////////////////////////////////////
// Registry

enum EPFORK
{
    orkWantWrite = 0x1,
    orkUseWOW64  = 0x2,
};

HRESULT OpenRegKey(HKEY hkeyMain, LPCWSTR wszSubKey, DWORD dwOpt, HKEY *phkey);
HRESULT ReadRegEntry(HKEY hkey, LPCWSTR szValName, DWORD *pdwType,
                     PBYTE pbBuffer, DWORD *pcbBuffer, PBYTE pbDefault,
                     DWORD cbDefault);
HRESULT ReadRegEntry(HKEY *rghkey, DWORD cKeys, LPCWSTR wszValName,
                     DWORD *pdwType, PBYTE pbBuffer, DWORD *pcbBuffer,
                     PBYTE pbDefault, DWORD cbDefault, DWORD *piKey = NULL);


////////////////////////////////////////////////////////////////////////////
// version info

#define APP_WINCOMP 0x1
#define APP_MSAPP 0x2
DWORD IsMicrosoftApp(LPWSTR wszAppPath, PBYTE pbAppInfo, DWORD cbAppInfo);


////////////////////////////////////////////////////////////////////////////
// String

WCHAR *MyStrStrIW(const WCHAR *wcs1, const WCHAR *wcs2);
CHAR *MyStrStrIA(const CHAR *cs1, const CHAR *cs2);
HRESULT MyURLEncode(LPWSTR wszDest, DWORD cchDest, LPWSTR wszSrc);


////////////////////////////////////////////////////////////////////////////
// CPFGenericClassBase

class CPFGenericClassBase
{
public:
//    CPFGenericClassBase(void) {}
//    virtual ~CPFGenericClassBase(void) {}

    void *operator new(size_t size)
    {
        return MyAlloc(size, NULL, FALSE);
    }

    void operator delete(void *pvMem)
    {
        if (pvMem != NULL)
            MyFree(pvMem, NULL);
    }
};

class CPFPrivHeapGenericClassBase
{
public:
//    CPFGenericClassBase(void) {}
//    virtual ~CPFGenericClassBase(void) {}

    void *operator new(size_t size)
    {
        return MyAlloc(size, g_hPFPrivateHeap, FALSE);
    }

    void operator delete(void *pvMem)
    {
        if (pvMem != NULL)
            MyFree(pvMem, g_hPFPrivateHeap);
    }
};


////////////////////////////////////////////////////////////////////////////
// CAutoUnlockCS

// This class wrappers a critical section.  It will automatically unlock the
//  CS when the class destructs (assuming it is locked)

// NOTE: this object is intended to be used only as a local variable of a
//       function, not as a global variable or class member.
class CAutoUnlockCS
{
private:
#if defined(DEBUG) || defined(_DEBUG)
    DWORD               m_dwOwningThread;
#endif

    CRITICAL_SECTION    *m_pcs;
    DWORD               m_cLocks;

public:
    CAutoUnlockCS(CRITICAL_SECTION *pcs, BOOL fTakeLock = FALSE)
    {
        m_pcs            = pcs;
        m_cLocks         = 0;
#if defined(DEBUG) || defined(_DEBUG)
        m_dwOwningThread = 0;
#endif
        if (fTakeLock)
            this->Lock();
    }

    ~CAutoUnlockCS(void)
    {
        _ASSERT(m_cLocks <= 1);
        if (m_pcs != NULL)
        {
#if defined(DEBUG) || defined(_DEBUG)
            if (m_cLocks > 0)
               _ASSERT(m_dwOwningThread == GetCurrentThreadId());
#endif
            while(m_cLocks > 0)
            {
                LeaveCriticalSection(m_pcs);
                m_cLocks--;
            }
        }
    }

    void Lock(void)
    {
        if (m_pcs != NULL)
        {
            EnterCriticalSection(m_pcs);
            m_cLocks++;
#if defined(DEBUG) || defined(_DEBUG)
            m_dwOwningThread = GetCurrentThreadId();
#endif
        }
    }

    void Unlock(void)
    {
        _ASSERT(m_cLocks > 0);
        _ASSERT(m_dwOwningThread == GetCurrentThreadId());
        if (m_pcs != NULL && m_cLocks > 0)
        {
            m_cLocks--;
            LeaveCriticalSection(m_pcs);
        }
#if defined(DEBUG) || defined(_DEBUG)
        if (m_cLocks == 0)
            m_dwOwningThread = 0;
#endif

    }
};


////////////////////////////////////////////////////////////////////////////
// CAutoUnlockMutex

// This class wrappers a mutex.  It will automatically unlock the
//  mutex when the class destructs (assuming it is owned)

// NOTE: this object is intended to be used only as a local variable of a
//       function, not as a global variable or class member.
class CAutoUnlockMutex
{
private:
#if defined(DEBUG) || defined(_DEBUG)
    DWORD   m_dwOwningThread;
#endif
    HANDLE  m_hmut;
    DWORD   m_cLocks;

public:
    CAutoUnlockMutex(HANDLE hmut, BOOL fTakeLock = FALSE)
    {
        m_hmut           = hmut;
        m_cLocks         = 0;
#if defined(DEBUG) || defined(_DEBUG)
        m_dwOwningThread = 0;
#endif
        if (fTakeLock)
            this->Lock();
    }

    ~CAutoUnlockMutex(void)
    {
        _ASSERT(m_cLocks <= 1);
        if (m_hmut != NULL)
        {
#if defined(DEBUG) || defined(_DEBUG)
            if (m_cLocks > 0)
               _ASSERT(m_dwOwningThread == GetCurrentThreadId());
#endif
            while(m_cLocks > 0)
            {
                ReleaseMutex(m_hmut);
                m_cLocks--;
            }
        }
    }

    BOOL Lock(DWORD dwTimeout = INFINITE)
    {
        if (m_hmut != NULL)
        {
            if (WaitForSingleObject(m_hmut, dwTimeout) != WAIT_OBJECT_0)
                return FALSE;

            m_cLocks++;
#if defined(DEBUG) || defined(_DEBUG)
            m_dwOwningThread = GetCurrentThreadId();
#endif
        }
        return TRUE;
    }

    void Unlock(void)
    {
        _ASSERT(m_cLocks > 0);
        _ASSERT(m_dwOwningThread == GetCurrentThreadId());
        if (m_hmut != NULL && m_cLocks > 0)
        {
            m_cLocks--;
            ReleaseMutex(m_hmut);
        }
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\weblog.h ===
/********************************************************************

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:
    weblog.cpp

Abstract:
    Defines a generic class that can be used to log
    info from ISAPIs. This class allows its user to
    create application specific logfiles and
    automatically uses an intermediate file to log info and
    creates permanent log files at predefined intervals
    or after predefined number of records have been
    written to the intermediate file. 

Revision History:
    rsraghav  created   03/25/96
    DerekM    modified  04/06/99

********************************************************************/

#ifndef WEBLOG_H
#define WEBLOG_H

/////////////////////////////////////////////////////////////////////////////
// Constant definitions

const DWORD     c_cMaxAppNameLen            = 256;
const DWORD     c_cMaxTimeSuffixLen         = 18;   // format of the suffix:YYYYMMDDHHmmss.log
const DWORD     c_cMaxRecLen                = 2048;
const DWORD     c_dwMinToMS                 = 60000;
const DWORD     c_dwFTtoMS                  = 10000;

const LPCWSTR   c_szTempLogfileSuffix       = L".iwl";
const LPCWSTR   c_szPermLogfileSuffix       = L".log";


/////////////////////////////////////////////////////////////////////////////
// Registry keys, values, and defaults

const LPCWSTR c_szRPWeblogRootKey           = L"Software\\Microsoft\\WebLog";
const LPCWSTR c_szRVMaxRecords              = L"MaxTempRecs";
const LPCWSTR c_szRVCurrentRecs             = L"CurTempRecs";
const LPCWSTR c_szRVLastDumpTime            = L"LastDumpTime";
const LPCWSTR c_szRVDumpInterval            = L"DumpIntervalMin";
const LPCWSTR c_szRVLogFilePath             = L"LogFilePath";

const LPCWSTR c_szLogFilePathDefault        = L"\\";
const DWORD   c_dwMaxRecordsDefault         = 10000;
const DWORD   c_dwCurrentRecDefault         = 0;
const DWORD   c_dwDumpIntervalDefault       = 60;


/////////////////////////////////////////////////////////////////////////////
// structs

struct SAppLogInfo
{
    WCHAR       wszName[MAX_PATH];
    WCHAR       wszLogPath[MAX_PATH];
    DWORD       cDumpMins;
    DWORD       cMaxTempRecs;
};

struct SAppLogInfoExtra
{
    WCHAR       wszName[MAX_PATH];
    FILETIME    ftLastDump;
    DWORD       cCurTempRecs;
};



//////////////////////////////////////////////////////////////////////
// CWebLog definition

class CWeblog
{
private:
    // member data
    unsigned __int64 m_liDumpIntervalAsFT;
    CRITICAL_SECTION m_cs;
    WCHAR            m_szAppName[c_cMaxAppNameLen + 1];
    WCHAR            m_szFileName[MAX_PATH + 1];
    WCHAR            m_szFilePath[MAX_PATH + 1];
    DWORD            m_cMaxRecords;
    DWORD            m_dwDumpInterval;
    BOOL             m_fInit;

    DWORD            m_cRecords;
    HANDLE           m_hFile;
    FILETIME         m_ftLastDump;

    // internal methods
    void    Cleanup();

    void    Lock()      { EnterCriticalSection(&m_cs); }        
    void    Unlock()    { LeaveCriticalSection(&m_cs); }    

    HRESULT InitFromRegistry();
    HRESULT DumpLog();
    BOOL    IsDumpRequired();

public:
    CWeblog(void);
    ~CWeblog(void);

    HRESULT InitLogging(LPCWSTR szAppName);
    HRESULT TerminateLogging(void);
    HRESULT LogRecord(LPCWSTR szFormat, ... );  
};


//////////////////////////////////////////////////////////////////////
// weblog configuration stuff

HRESULT ReadALI(LPCWSTR wszName, SAppLogInfo *pali, 
                SAppLogInfoExtra *palie = NULL);
HRESULT WriteALI(SAppLogInfo *pali, SAppLogInfoExtra *palie = NULL);
HRESULT DeleteALI(LPCWSTR wszName);

#endif // WEBLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\include\xmltp.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    ful.h

Abstract:
    CFaultUpload class definition

Revision History:
    created     derekm      03/14/00

******************************************************************************/

#ifndef XMLTP_H
#define XMLTP_H

const WCHAR c_wszFileTag[]       = L"FILE";
const WCHAR c_wszHistTag[]       = L"WQLHIST";
const WCHAR c_wszWQLTag[]        = L"WQL";
const WCHAR c_wszSigTag[]        = L"SIG";
const WCHAR c_wszMinidumpTag[]   = L"MINIDUMP";
const WCHAR c_wszURLTag[]        = L"FINALURL";
const WCHAR c_wszSigMatchTag[]   = L"SIGMATCH";
const WCHAR c_wszPropTag[]       = L"PROP";
const WCHAR c_wszOSITag[]        = L"OSINFO";
const WCHAR c_wszHdrTag[]        = L"HEADER";

const WCHAR c_wszTypeAttr[]      = L"Type";
const WCHAR c_wszSendAttr[]      = L"Send";
const WCHAR c_wszAAttr[]         = L"AppName";
const WCHAR c_wszAVAttr[]        = L"AppVer";
const WCHAR c_wszMAttr[]         = L"ModName";
const WCHAR c_wszMVAttr[]        = L"ModVer";
const WCHAR c_wszOffAttr[]       = L"Offset";
const WCHAR c_wszNameAttr[]      = L"Name";
const WCHAR c_wszValueAttr[]     = L"Value";
const WCHAR c_wszOSVerAttr[]     = L"OSVer";
const WCHAR c_wszOSBuildAttr[]   = L"OSBuild";
const WCHAR c_wszOSPlatAttr[]    = L"OSPlatform";
const WCHAR c_wszOSSPStrAttr[]   = L"OSSPStr";
const WCHAR c_wszOSSPVerAttr[]   = L"OSSPVer";
const WCHAR c_wszOSSuiteAttr[]   = L"OSSuite";
const WCHAR c_wszOSTypeAttr[]    = L"OSType";

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\base64.cpp ===
// Base64Coder.cpp: implementation of the Base64Coder class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Base64.h"

// Digits...
static char	Base64Digits[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

BOOL Base64Coder::m_Init		= FALSE;
char Base64Coder::m_DecodeTable[256];

#ifndef PAGESIZE
#define PAGESIZE					4096
#endif

#ifndef ROUNDTOPAGE
#define ROUNDTOPAGE(a)			(((a/4096)+1)*4096)
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

Base64Coder::Base64Coder()
:	m_pDBuffer(NULL),
	m_pEBuffer(NULL),
	m_nDBufLen(0),
	m_nEBufLen(0)
{

}

Base64Coder::~Base64Coder()
{
	if(m_pDBuffer != NULL)
		delete [] m_pDBuffer;

	if(m_pEBuffer != NULL)
		delete [] m_pEBuffer;
}

LPCSTR Base64Coder::DecodedMessage() const 
{ 
	return (LPCSTR) m_pDBuffer;
}

LPCSTR Base64Coder::EncodedMessage() const
{ 
	return (LPCSTR) m_pEBuffer;
}

void Base64Coder::DecodedMessage(PBYTE* ppBuffer, DWORD* nBufLen) const
{
    *ppBuffer = m_pDBuffer;
    *nBufLen = m_nDDataLen;
}

void Base64Coder::AllocEncode(DWORD nSize)
{
	if(m_nEBufLen < nSize)
	{
		if(m_pEBuffer != NULL)
			delete [] m_pEBuffer;

		m_nEBufLen = ROUNDTOPAGE(nSize);
		m_pEBuffer = new BYTE[m_nEBufLen];
	}

	if (m_pEBuffer != NULL)
		::ZeroMemory(m_pEBuffer, m_nEBufLen);

	m_nEDataLen = 0;
}

void Base64Coder::AllocDecode(DWORD nSize)
{
	if(m_nDBufLen < nSize)
	{
		if(m_pDBuffer != NULL)
			delete [] m_pDBuffer;

		m_nDBufLen = ROUNDTOPAGE(nSize);
		m_pDBuffer = new BYTE[m_nDBufLen];
	}

	if (m_pDBuffer != NULL)
		::ZeroMemory(m_pDBuffer, m_nDBufLen);

	m_nDDataLen = 0;
}

void Base64Coder::SetEncodeBuffer(const PBYTE pBuffer, DWORD nBufLen)
{
	DWORD	i = 0;

	AllocEncode(nBufLen);
	while(i < nBufLen)
	{
		if(!_IsBadMimeChar(pBuffer[i]))
		{
			m_pEBuffer[m_nEDataLen] = pBuffer[i];
			m_nEDataLen++;
		}

		i++;
	}
}

void Base64Coder::SetDecodeBuffer(const PBYTE pBuffer, DWORD nBufLen)
{
	AllocDecode(nBufLen);
	::CopyMemory(m_pDBuffer, pBuffer, nBufLen);
	m_nDDataLen = nBufLen;
}

void Base64Coder::Encode(const PBYTE pBuffer, DWORD nBufLen)
{
	SetDecodeBuffer(pBuffer, nBufLen);
	AllocEncode(nBufLen * 2);

	TempBucket			Raw;
	DWORD					nIndex	= 0;

	while((nIndex + 3) <= nBufLen)
	{
		Raw.Clear();
		::CopyMemory(&Raw, m_pDBuffer + nIndex, 3);
		Raw.nSize = 3;
		_EncodeToBuffer(Raw, m_pEBuffer + m_nEDataLen);
		nIndex		+= 3;
		m_nEDataLen	+= 4;
	}

	if(nBufLen > nIndex)
	{
		Raw.Clear();
		Raw.nSize = (BYTE) (nBufLen - nIndex);
		::CopyMemory(&Raw, m_pDBuffer + nIndex, nBufLen - nIndex);
		_EncodeToBuffer(Raw, m_pEBuffer + m_nEDataLen);
		m_nEDataLen += 4;
	}
}

void Base64Coder::Encode(LPCSTR szMessage)
{
	if(szMessage != NULL)
		Base64Coder::Encode((const PBYTE)szMessage, lstrlenA(szMessage));
}

void Base64Coder::Decode(const PBYTE pBuffer, DWORD dwBufLen)
{
	if(!Base64Coder::m_Init)
		_Init();

	SetEncodeBuffer(pBuffer, dwBufLen);

	AllocDecode(dwBufLen);

	TempBucket			Raw;

	DWORD		nIndex = 0;

	while((nIndex + 4) <= m_nEDataLen)
	{
		Raw.Clear();
		Raw.nData[0] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex]];
		Raw.nData[1] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex + 1]];
		Raw.nData[2] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex + 2]];
		Raw.nData[3] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex + 3]];

		if(Raw.nData[2] == 255)
			Raw.nData[2] = 0;
		if(Raw.nData[3] == 255)
			Raw.nData[3] = 0;
		
		Raw.nSize = 4;
		_DecodeToBuffer(Raw, m_pDBuffer + m_nDDataLen);
		nIndex += 4;
		m_nDDataLen += 3;
	}
	
   // If nIndex < m_nEDataLen, then we got a decode message without padding.
   // We may want to throw some kind of warning here, but we are still required
   // to handle the decoding as if it was properly padded.
	if(nIndex < m_nEDataLen)
	{
		Raw.Clear();
		for(DWORD i = nIndex; i < m_nEDataLen; i++)
		{
			Raw.nData[i - nIndex] = Base64Coder::m_DecodeTable[m_pEBuffer[i]];
			Raw.nSize++;
			if(Raw.nData[i - nIndex] == 255)
				Raw.nData[i - nIndex] = 0;
		}

		_DecodeToBuffer(Raw, m_pDBuffer + m_nDDataLen);
		m_nDDataLen += (m_nEDataLen - nIndex);
	}
}

void Base64Coder::Decode(LPCSTR szMessage)
{
	if(szMessage != NULL)
		Base64Coder::Decode((const PBYTE)szMessage, lstrlenA(szMessage));
}

DWORD Base64Coder::_DecodeToBuffer(const TempBucket &Decode, PBYTE pBuffer)
{
	TempBucket	Data;
	DWORD			nCount = 0;

	_DecodeRaw(Data, Decode);

	for(int i = 0; i < 3; i++)
	{
		pBuffer[i] = Data.nData[i];
		if(pBuffer[i] != 255)
			nCount++;
	}

	return nCount;
}


void Base64Coder::_EncodeToBuffer(const TempBucket &Decode, PBYTE pBuffer)
{
	TempBucket	Data;

	_EncodeRaw(Data, Decode);

	for(int i = 0; i < 4; i++)
		pBuffer[i] = Base64Digits[Data.nData[i]];

	switch(Decode.nSize)
	{
	case 1:
		pBuffer[2] = '=';
	case 2:
		pBuffer[3] = '=';
	}
}

void Base64Coder::_DecodeRaw(TempBucket &Data, const TempBucket &Decode)
{
	BYTE		nTemp;

	Data.nData[0] = Decode.nData[0];
	Data.nData[0] <<= 2;

	nTemp = Decode.nData[1];
	nTemp >>= 4;
	nTemp &= 0x03;
	Data.nData[0] |= nTemp;

	Data.nData[1] = Decode.nData[1];
	Data.nData[1] <<= 4;

	nTemp = Decode.nData[2];
	nTemp >>= 2;
	nTemp &= 0x0F;
	Data.nData[1] |= nTemp;

	Data.nData[2] = Decode.nData[2];
	Data.nData[2] <<= 6;
	nTemp = Decode.nData[3];
	nTemp &= 0x3F;
	Data.nData[2] |= nTemp;
}

void Base64Coder::_EncodeRaw(TempBucket &Data, const TempBucket &Decode)
{
	BYTE		nTemp;

	Data.nData[0] = Decode.nData[0];
	Data.nData[0] >>= 2;
	
	Data.nData[1] = Decode.nData[0];
	Data.nData[1] <<= 4;
	nTemp = Decode.nData[1];
	nTemp >>= 4;
	Data.nData[1] |= nTemp;
	Data.nData[1] &= 0x3F;

	Data.nData[2] = Decode.nData[1];
	Data.nData[2] <<= 2;

	nTemp = Decode.nData[2];
	nTemp >>= 6;

	Data.nData[2] |= nTemp;
	Data.nData[2] &= 0x3F;

	Data.nData[3] = Decode.nData[2];
	Data.nData[3] &= 0x3F;
}

BOOL Base64Coder::_IsBadMimeChar(BYTE nData)
{
	switch(nData)
	{
		case '\r': case '\n': case '\t': case ' ' :
		case '\b': case '\a': case '\f': case '\v':
			return TRUE;
		default:
			return FALSE;
	}
}

void Base64Coder::_Init()
{  // Initialize Decoding table.

	int	i;

	for(i = 0; i < 256; i++)
		Base64Coder::m_DecodeTable[i] = -2;

	for(i = 0; i < 64; i++)
	{
		Base64Coder::m_DecodeTable[Base64Digits[i]]			= (char)i;
		Base64Coder::m_DecodeTable[Base64Digits[i]|0x80]	= (char)i;
	}

	Base64Coder::m_DecodeTable['=']				= -1;
	Base64Coder::m_DecodeTable['='|0x80]		= -1;

	Base64Coder::m_Init = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\common.h ===
/*
    Copyright 1999 Microsoft Corporation
    
    Common coding utilities

    Walter Smith (wsmith)
 */

#pragma once

#ifdef DBG
    #define _DEBUG 1
#endif
#include <crtdbg.h>

#ifdef _DEBUG
    #define _CONFIRM(exp) _ASSERT(exp)
#else
    #define _CONFIRM(exp) (exp)
#endif

#define ARRAYSIZE(a) (sizeof(a) / sizeof((a)[0]))

#define ASSERT_WRITE_PTR(p) _ASSERT(!IsBadWritePtr((p), sizeof(*(p))))
#define ASSERT_READ_PTR(p) _ASSERT(!IsBadReadPtr((p), sizeof(*(p))))

typedef std::basic_string<TCHAR> tstring;

// REVIEW: Make this out of line?

inline void ThrowLastError() {
    DWORD err = GetLastError();
    if (err == 0)
        throw E_FAIL;
    else
        throw HRESULT_FROM_WIN32(GetLastError());
}

inline void ThrowIfFail(HRESULT hr) {
    if (FAILED(hr))
        throw hr;
}

inline void ThrowIfNull(const void* pv) {
    if (pv == NULL)
        throw E_POINTER;
}

inline void ThrowIfNullHandle(HANDLE h) {
    if (h == NULL)
        ThrowLastError();
}

inline void ThrowIfZero(int i) {
    if (i == 0)
        ThrowLastError();
}

inline void ThrowIfTrue(bool b) {
    if (b)
        ThrowLastError();
}

inline void ThrowIfFalse(bool b) {
    ThrowIfTrue(!b);
}

inline void ThrowIfW32Fail(LONG l) {
    if (l != ERROR_SUCCESS)
        ThrowLastError();
}

inline void ThrowIfW32Error(LONG l) {
    if (l != ERROR_SUCCESS)
        throw HRESULT_FROM_WIN32(l);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\base64.h ===
// Base64Coder.h: interface for the Base64Coder class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BASE64CODER_H__B2E45717_0625_11D2_A80A_00C04FB6794C__INCLUDED_)
#define AFX_BASE64CODER_H__B2E45717_0625_11D2_A80A_00C04FB6794C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _AFXDLL
	#include <afx.h>
	typedef CString		String;
#else
	#include <windows.h>
	#include <string>
	typedef std::string	String;
#endif

class Base64Coder  
{
	// Internal bucket class.
	class TempBucket
	{
	public:
		BYTE		nData[4];
		BYTE		nSize;
		void		Clear() { ::ZeroMemory(nData, 4); nSize = 0; };
	};

	PBYTE					m_pDBuffer;
	PBYTE					m_pEBuffer;
	DWORD					m_nDBufLen;
	DWORD					m_nEBufLen;
	DWORD					m_nDDataLen;
	DWORD					m_nEDataLen;

public:
	Base64Coder();
	virtual ~Base64Coder();

public:
	virtual void		Encode(const PBYTE, DWORD);
	virtual void		Decode(const PBYTE, DWORD);
	virtual void		Encode(LPCSTR sMessage);
	virtual void		Decode(LPCSTR sMessage);

	virtual LPCSTR	DecodedMessage() const;
    virtual void DecodedMessage(PBYTE* ppBuffer, DWORD* nBufLen) const;
	virtual LPCSTR	EncodedMessage() const;

	virtual void		AllocEncode(DWORD);
	virtual void		AllocDecode(DWORD);
	virtual void		SetEncodeBuffer(const PBYTE pBuffer, DWORD nBufLen);
	virtual void		SetDecodeBuffer(const PBYTE pBuffer, DWORD nBufLen);

protected:
	virtual void		_EncodeToBuffer(const TempBucket &Decode, PBYTE pBuffer);
	virtual ULONG		_DecodeToBuffer(const TempBucket &Decode, PBYTE pBuffer);
	virtual void		_EncodeRaw(TempBucket &, const TempBucket &);
	virtual void		_DecodeRaw(TempBucket &, const TempBucket &);
	virtual BOOL		_IsBadMimeChar(BYTE);

	static  char		m_DecodeTable[256];
	static  BOOL		m_Init;
	void					_Init();
};

#endif // !defined(AFX_BASE64CODER_H__B2E45717_0625_11D2_A80A_00C04FB6794C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\dll\image.cpp ===
/*
    Copyright 1999 Microsoft Corporation

    Capture a window's screen bits in PNG format

    Walter Smith (wsmith)
    Rajesh Soy   (nsoy) - modified 05/08/2000
 */

#ifdef THIS_FILE
#undef THIS_FILE
#endif

static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

#include "stdafx.h"

#define NOTRACE

#include "png.h"
#include <dbgtrace.h>

HBITMAP CopyScreenRectToDIB(LPRECT lpRect, PVOID* ppvBits)
{
    TraceFunctEnter("CopyScreenRectToDIB");
    HDC         hScrDC = NULL, hMemDC = NULL;       // screen DC and memory DC
    HBITMAP     hBitmap = NULL, hOldBitmap = NULL;  // handles to deice-dependent bitmaps
    int         nX = 0, nY = 0, nX2 = 0, nY2 = 0;   // coordinates of rectangle to grab
    int         nWidth = 0, nHeight = 0;            // DIB width and height
    int         xScrn = 0, yScrn = 0;               // screen resolution
    BITMAPINFO* pbminfo = NULL;                     // BITMAPINFO for rectangle
    size_t      cbInfo = 0;                         // Size of *pbminfo in bytes

    // check for an empty rectangle

    if (IsRectEmpty(lpRect))
      return NULL;

    // create a DC for the screen and create
    // a memory DC compatible to screen DC

    if ((hScrDC = CreateDC(_T("DISPLAY"), NULL, NULL, NULL)) == NULL)
        goto Done;

    if ((hMemDC = CreateCompatibleDC(hScrDC)) == NULL)
        goto Done;

    // get points of rectangle to grab

    nX = lpRect->left;
    nY = lpRect->top;
    nX2 = lpRect->right;
    nY2 = lpRect->bottom;

    // get screen resolution

    xScrn = GetDeviceCaps(hScrDC, HORZRES);
    yScrn = GetDeviceCaps(hScrDC, VERTRES);

    //make sure bitmap rectangle is visible
    //
    // NTRAID#NTBUG9-154242-2000/08/13-jasonr
    //
    // I commented out this code because it prevented us from handling multimon
    // scenarios.  For multimon the virtual screen buffer extends beyond the
    // coordinates of the primary monitor.  For example if you attach a second
    // monitor to the left of the primary, it will have negative coordinates.
    //
    // The AV was occurring because this code caused us to allocate a buffer
    // that was smaller than the caller expected, ultimately causing the PNG
    // code to walk off the end of it.
    //
    // It may be that we need further changes to correctly support ALL multimon
    // scenarios.  For example, if a window straddles the boundary between two
    // monitors (parts of the window appear on both monitors), then I don't know
    // that the existing code will copy all of the window -- it might only copy
    // one of the two parts.  Since that is not a common scenario, I don't think
    // we have to fix it, but we'll see who complains about it.
    //

    /*
    if (nX < 0)
    {
        DebugTrace(0, "nX < 0");
        nX = 0;
        lpRect->left = 0;
    }

    if (nY < 0)
    {
        DebugTrace(0, "nY < 0");
        nY = 0;
        lpRect->top = 0;
    }

    if (nX2 > xScrn)
    {
        DebugTrace(0, "nX2 > xScrn");
        nX2 = xScrn;
        lpRect->right = xScrn;
    }

    if (nY2 > yScrn)
    {
        DebugTrace(0, "nY2 > yScrn");
        nY2 = yScrn;
        lpRect->bottom = yScrn;
    }
    */

    nWidth = nX2 - nX;
    nHeight = nY2 - nY;

    DebugTrace(0, "nWidth: %d", nWidth);
    DebugTrace(0, "nHeight: %d", nHeight);

    cbInfo = offsetof(BITMAPINFO, bmiColors[256]);
    pbminfo = (BITMAPINFO*) alloca(cbInfo);
    ZeroMemory(pbminfo, cbInfo);
    pbminfo->bmiHeader.biSize = sizeof(BITMAPINFO);
    pbminfo->bmiHeader.biWidth = nWidth;
    pbminfo->bmiHeader.biHeight = - nHeight;    // negative height = top-down bitmap
    pbminfo->bmiHeader.biPlanes = 1;
    pbminfo->bmiHeader.biBitCount = 8;
    pbminfo->bmiHeader.biCompression = BI_RGB;
    pbminfo->bmiHeader.biSizeImage = 0;
    pbminfo->bmiHeader.biXPelsPerMeter = 96;    // presumably this doesn't matter
    pbminfo->bmiHeader.biYPelsPerMeter = 96;    // or this either
    pbminfo->bmiHeader.biClrUsed = 256;
    pbminfo->bmiHeader.biClrImportant = 0;
    for (int i = 0; i < 256; i++) {
        pbminfo->bmiColors[i].rgbRed = (char)i;
        pbminfo->bmiColors[i].rgbGreen = (char)i;
        pbminfo->bmiColors[i].rgbBlue = (char)i;
    }

    if ((hBitmap = CreateDIBSection(hScrDC, pbminfo, DIB_RGB_COLORS, ppvBits, NULL, 0)) == NULL)
        goto Done;

    // select new bitmap into memory DC
    hOldBitmap = (HBITMAP) SelectObject(hMemDC, hBitmap);

    if ((hOldBitmap == NULL) || (hOldBitmap == (HBITMAP)(ULONG_PTR) GDI_ERROR))
        goto Done;

    // bitblt screen DC to memory DC
    BitBlt(hMemDC, 0, 0, nWidth, nHeight, hScrDC, nX, nY, SRCCOPY);

    // select old bitmap back into memory DC and get handle to
    // bitmap of the screen

    hBitmap = (HBITMAP) SelectObject(hMemDC, hOldBitmap);

    // clean up

Done:

    if (hScrDC != NULL)
        DeleteDC(hScrDC);

    if (hMemDC != NULL)
        DeleteDC(hMemDC);

    GdiFlush();

    // return handle to the bitmap

    return hBitmap;
}

class BitWriter {
public:
    BitWriter()
    {
        m_cbData = 0;
        m_pData = (BYTE*) malloc(4096);
        if (m_pData == NULL)
            m_maxData = 0;
        else
            m_maxData = 4096;
    }

    ~BitWriter()
    {
        if (m_pData != NULL)
            free(m_pData);
    }

    DWORD GetLength()
    {
        return m_cbData;
    }

    BYTE* GetData()
    {
        return m_pData;
    }

    BYTE* DetachData()
    {
        BYTE* pData = m_pData;
        m_pData = NULL;
        return pData;
    }

    bool IsBad()
    {
        return (m_pData == NULL);
    }

    void Write(BYTE* pNewData, DWORD cbNewData)
    {
        if (IsBad())
            return;

        if (m_cbData + cbNewData > m_maxData) {
            DWORD newMaxData = m_maxData + max(4096, m_maxData - m_cbData + cbNewData);
            BYTE* newPData = (BYTE*) realloc(m_pData, newMaxData);
            if (newPData == 0) {
                free(m_pData);
                m_pData = NULL;
                return;
            }
            m_maxData = newMaxData;
            m_pData = newPData;
        }

        memcpy(m_pData + m_cbData, pNewData, cbNewData);
        m_cbData += cbNewData;
    }

private:
    BYTE* m_pData;
    DWORD m_cbData;
    DWORD m_maxData;
};

void __stdcall PNGWriteDataCallback(png_structp pPNG, png_bytep pData, png_size_t cbData)
{
    BitWriter* pbw = (BitWriter*) png_get_io_ptr(pPNG);
    pbw->Write(pData, cbData);
}

void __stdcall PNGFlushDataCallback(png_structp pPNG)
{
}

void GetWindowImage(HWND hwnd, BYTE** ppData, DWORD* pcbData)
{
    TraceFunctEnter("GetWindowImage");
    ASSERT_WRITE_PTR(ppData);
    ASSERT_WRITE_PTR(pcbData);

    BitWriter bitWriter;

    DebugTrace(0, "Calling png_create_write_struct...");
    png_structp pPNG = png_create_write_struct(PNG_LIBPNG_VER_STRING, 0, 0, 0);
    ThrowIfNull(pPNG);

    DebugTrace(0, "Calling png_set_write_fn...");
    png_set_write_fn(pPNG, &bitWriter, PNGWriteDataCallback, PNGFlushDataCallback);

    DebugTrace(0, "Calling png_create_info_struct...");
    png_infop pInfo = png_create_info_struct(pPNG);
    ThrowIfNull(pInfo);

    RECT rWnd;

    DebugTrace(0, "Calling GetWindowRect...");
    ThrowIfZero(GetWindowRect(hwnd, &rWnd));

    PVOID pvBits;
    DebugTrace(0, "Calling CopyScreenRectToDIB...");
    HBITMAP hContents = CopyScreenRectToDIB(&rWnd, &pvBits);

    int width = rWnd.right - rWnd.left;
    int height = rWnd.bottom - rWnd.top;

    DebugTrace(0, "width: %d", width);
    DebugTrace(0, "height: %d", height);

    try {
        // The PNG library uses setjmp/longjmp to "throw" errors.
        // I'm uncertain of the interaction between setjmp and C++,
        // so keep the inside of the try block SIMPLE.

        DebugTrace(0, "Calling setjmp...");
        if (setjmp(pPNG->jmpbuf))
        {
            FatalTrace(0, "setjmp failed");
            throw E_FAIL;
        }

        DebugTrace(0, "Calling png_set_IHDR...");
        png_set_IHDR(pPNG, pInfo, width, height,
           2, PNG_COLOR_TYPE_GRAY, PNG_INTERLACE_NONE,
           PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);

        DebugTrace(0, "Calling png_write_info...");
        png_write_info(pPNG, pInfo);

        // DIBs round rows up to DWORD boundaries
        int rowBytes = ((width + 3) / 4) * 4;
        DebugTrace(0, "rowBytes: %d", rowBytes);

        DebugTrace(0, "Allocating memory for aRowPtrs...");
        png_byte** aRowPtrs = (png_byte**) alloca(height * sizeof(png_byte*));
        if(NULL == aRowPtrs)
        {
            FatalTrace(0, "aRowPtrs is NULL");
            throw E_OUTOFMEMORY;
        }

        DebugTrace(0, "Assigning aRowPtrs");
        for (int i = 0; i < height; i++)
        {
            aRowPtrs[i] = ((png_byte*) pvBits) + i*rowBytes;
        }

        // Round our pixels down to the right bit depth.
        // It seems as if the PNG lib would do this for us, but png_set_shift
        // makes it pack THEN shift, which takes the LEAST significant bits.

        DebugTrace(0, "Rounding pixels down to right depth...");

        for (int iRow = 0; iRow < height; iRow++) {
            png_byte* pRow = aRowPtrs[iRow];

            for (int iPixel = 0; iPixel < width; iPixel++) {
                int b = pRow[iPixel];
                b += 0x3F;
                if (b >= 0x100)
                    b = 0xFF;
                b >>= 6;
                pRow[iPixel] = (char)b;
            }
        }

        DebugTrace(0, "calling png_set_packing...");
        png_set_packing(pPNG);

        DebugTrace(0, "calling png_write_image...");
        png_write_image(pPNG, aRowPtrs);

        DebugTrace(0, "calling png_write_end...");
        png_write_end(pPNG, pInfo);

        DebugTrace(0, "We are done with PNG...");
    }
    catch (...) {
        png_destroy_write_struct(&pPNG, &pInfo);
        DeleteObject(hContents);
        throw;
    }

    DebugTrace(0, "Calling png_destroy_write_struct...");
    png_destroy_write_struct(&pPNG, &pInfo);

    DebugTrace(0, "Calling DeleteObject...");
    DeleteObject(hContents);

    DebugTrace(0, "Calling bitWriter.IsBad...");
    if (bitWriter.IsBad())
    {
        FatalTrace(0, "bitWriter IsBad");
        throw E_FAIL;
    }

    *ppData = bitWriter.DetachData();
    *pcbData = bitWriter.GetLength();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\simplexml.h ===
/*
    Copyright 1999 Microsoft Corporation
    
    Simplified XML "DOM"

    Walter Smith (wsmith)
 */

#pragma once

using namespace std;

struct wstring_less {
    bool operator()(const wstring& a, const wstring& b) const
    {
        return (lstrcmpW(a.c_str(), b.c_str()) < 0);
    }
};

struct SimpleXMLNode {
    wstring tag;
    wstring text;
        typedef map<wstring, wstring, wstring_less> attrs_t;
    attrs_t attrs;
        typedef vector< auto_ptr<SimpleXMLNode> > children_t;
    children_t children;

    void SetAttribute(wstring& name, wstring& value)
    {
        pair<attrs_t::iterator, bool> pair = attrs.insert(attrs_t::value_type(name, value));
        if (!pair.second)
            (*pair.first).second = value;
    }

    const wstring* GetAttribute(wstring& name) const
    {
        attrs_t::const_iterator it = attrs.find(name);
        if (it == attrs.end())
            return NULL;
        else
            return &(*it).second;
    }

    SimpleXMLNode* AppendChild(wstring& tag)
    {
        auto_ptr<SimpleXMLNode> pNode(new SimpleXMLNode);
        pNode->tag = tag;
        children.push_back(pNode);
        return pNode.get();
    }

    const SimpleXMLNode* GetChildByTag(wstring& tag) const
    {
        for (children_t::const_iterator it = children.begin();
                it != children.end();
                it++) {
            if (lstrcmpW((*it)->tag.c_str(), tag.c_str()) == 0)
                return (*it).get();
        }
        return NULL;
    }
};

class SimpleXMLDocument {
public:
    SimpleXMLDocument()
        : m_pTopNode(new SimpleXMLNode)
    {
    }

    ~SimpleXMLDocument()    { }

    void ParseFile(LPCTSTR szFilename);

    void SaveFile(LPCTSTR szFilename) const;
    
    SimpleXMLNode* GetTopNode() const
    {
        return m_pTopNode.get();
    }

private:
    auto_ptr<SimpleXMLNode> m_pTopNode;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\dll\lamebtn.cpp ===
/*
    Copyright 1999 Microsoft Corporation

    Logging for MessageBoxes and the comment button (aka the "lame" button).

    Walter Smith (wsmith)
    Rajesh Soy (nsoy) - cleaned up code. 5/5/2000
    Rajesh Soy (nsoy) - rearranged code, added messagebox text handling. 6/6/2000
 */

#ifdef THIS_FILE
#undef THIS_FILE
#endif

static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

#include "stdafx.h"

#define NOTRACE

#include "logging.h"
#include "resource.h"
#include <dbgtrace.h>
#include <objbase.h>
#include <atlcom.h>
#include <faultrep.h>

// MPC_Utils.h includes MPC_main.h, which apparently redefines ARRAYSIZE which
// causes a compiler warning.

#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif

#include <MPC_utils.h>

//
// Globals
//
HINSTANCE ghDllInst;
CComModule _Module;

//
// Routines Defined here
//
unsigned int __stdcall LogLameButtonThread(void* pvLogData);
VOID WINAPI CommentReport( HWND hwnd, PVOID pv);

//
// CSurveyDlg:  The Comments dialog implementation
//
class CSurveyDlg :
        public CAxDialogImpl<CSurveyDlg>
{
public:
    //
    // Constructor
    //
        CSurveyDlg()
        {
        ZeroMemory(&m_lldata, sizeof(m_lldata));
        m_hwndTarget = NULL;
        m_bShowHyperlink = FALSE;
        m_crAnchor = RGB(0, 0, 0);
        ZeroMemory(&m_szHyperlinkText, sizeof(m_szHyperlinkText));
        ZeroMemory(&m_szHyperlinkCmdLine, sizeof(m_szHyperlinkCmdLine));
        m_bHyperlinkHasFocus = FALSE;
        }

    //
    // Destructor
    //
        ~CSurveyDlg()
        {
        if (m_lldata.pbImage != NULL) {
            free(m_lldata.pbImage);
            m_lldata.pbImage = NULL;
        }
        }

        enum { IDD = IDD_SURVEYDLG };

private:
    LAMELOGDATA     m_lldata;                    // Data collected by LAMEBTN.dll
    HWND            m_hwndTarget;                // Window of dialog being commented on
    BOOL            m_bShowHyperlink;            // Set to TRUE if we should display the hyperlink on our dialog.
    COLORREF        m_crAnchor;                  // Color of a hyperlink (anchor).
    TCHAR           m_szHyperlinkText[256];      // Display string for the hyperlink.
    TCHAR           m_szHyperlinkCmdLine[2048];  // Command line (obtained from the registry) to execute when the user clicks the hyperlink.
    TCHAR           m_bHyperlinkHasFocus;        // Set to TRUE when the hyperlink button (IDC_BUTTON_HYPERLINK) has focus.

public:
BEGIN_MSG_MAP(CSurveyDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
        COMMAND_ID_HANDLER(IDC_BUTTON_HYPERLINK, HyperlinkCmdHandler)
        COMMAND_ID_HANDLER(IDOK, OnOK)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

    //
    // Init: Initializes the comment Dialog
    //
    void Init( HWND hwndTarget, PSTACKTRACEDATA pstdata);

    //
    // OnInitDialog: Fills up the Comment Dialog structures when the dialog is displayed
    //
        LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    //
    // OnDrawItem: Draws owner-drawn controls (we have only one: IDC_BUTTON_HYPERLINK)
    //
        LRESULT OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    //
    // OnSetCursor: Sets the cursor to the hand if the mouse is over IDC_BUTTON_HYPERLINK
    //
        LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    //
    // HyperlinkCmdHandler: Handles messages from the IDC_BUTTON_HYPERLINK button
    //
        LRESULT HyperlinkCmdHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // OnOK: Submits Comment
    //
        LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // OnCancel: Cancel the comment
    //
        LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);


private:

    //
    // CSurveyDlg::IsMessageBox: This routine returns TRUE if the hWnd passed is indeed
    //                           a message box
    //
    BOOL IsMessageBox();

    //
    // GetInfoAndLogLameButton: Gathers the comment and callstack information, formats into XML
    //                          and uploads to server
    void GetInfoAndLogLameButton();

};


//
// CSurveyDlg::Init: Initializes the comment Dialog
//
void CSurveyDlg::Init(
    HWND hwndTarget,            // [in] Window of dialog being commented on
    PSTACKTRACEDATA pstdata     // [in] Call Stack
)
{
    TraceFunctEnter("CSurveyDlg::Init");
    _ASSERT(hwndTarget != NULL);

    //
    // Save off the target window
    //
    m_hwndTarget = hwndTarget;

    //
    // Save off the call stack
    //
    m_lldata.pStackTrace = pstdata;

    //
    // Grab the image of the target window
    //
    DebugTrace(0, "Calling SetActiveWindow");
    ::SetActiveWindow(hwndTarget);

    try {
        BYTE* pImageData = NULL;

        DebugTrace(0, "Calling GetWindowImage");
        GetWindowImage(hwndTarget, &pImageData, &m_lldata.cbImage);
        m_lldata.pbImage = pImageData;
    }
    catch (HRESULT hr) {
        m_lldata.pbImage = NULL;
        m_lldata.cbImage = 0;
    }

    TraceFunctLeave();
}


//
// CSurveyDlg::OnInitDialog:    Executes when Comments dialog is created
//
LRESULT
CSurveyDlg::OnInitDialog(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL& bHandled
)
{
    DWORD idMessage;

    TraceFunctEnter("OnInitDialog");

    TCHAR szTitle[64];

    //
    // Obtain the Title of the Window being commented
    //
    if (::GetWindowText(m_hwndTarget, szTitle, ARRAYSIZE(szTitle)) != 0) {
        idMessage = IDS_INTRO_WITH_TITLE;
        if (lstrlen(szTitle) == ARRAYSIZE(szTitle) - 1) {
            // Truncate the title a little more nicely
            TCHAR* p = &szTitle[ARRAYSIZE(szTitle) - 4];
            *p++ = '.';
            *p++ = '.';
            *p++ = '.';
        }
    }
    else {
        idMessage = IDS_INTRO;
    }

    //
    // Load localized sting for Comment intro
    //
    TCHAR szTemplate[1024];
    LoadString(_Module.GetResourceInstance(),
               idMessage,
               szTemplate,
               ARRAYSIZE(szTemplate));

    TCHAR* fmArgs[] = { szTitle };
    TCHAR* szCommentIntro = NULL;
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_STRING |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  szTemplate,
                  0,
                  0,
                  (LPTSTR) &szCommentIntro,
                  1024,
                  (va_list*) &fmArgs);

    if (szCommentIntro != NULL) {
        SetDlgItemText(IDC_STATIC_INTRO, szCommentIntro);
        LocalFree(szCommentIntro);
    }

    //
    // Set the maximum limits on the edit controls.
    //

    SendDlgItemMessage(IDC_EDIT_EMAIL_ADDRESS, EM_LIMITTEXT, MAX_EMAIL_ADDRESS_SIZE, 0);
    SendDlgItemMessage(IDC_EDIT_BETA_ID, EM_LIMITTEXT, MAX_BETA_ID_SIZE, 0);
    SendDlgItemMessage(IDC_EDIT_COMMENT, EM_LIMITTEXT, COMMENT_TEXT_SIZE, 0);

    //
    // Prepopulate the email address and beta ID edit controls with whatever
    // the user typed in last time.  (We stored this in the registry the last
    // time they pressed the submit button.)
    //

    HKEY hKey;
    DWORD dwRet;

    if ((dwRet = RegOpenKeyEx(HKEY_CURRENT_USER,
                              _T("Software\\Microsoft\\PCHealth\\Clients\\Dialog Comments"),
                              0,
                              KEY_QUERY_VALUE,
                              &hKey)) != ERROR_SUCCESS) {

        DebugTrace(0, "No HKCU\\Software\\Microsoft\\PCHealth\\Clients\\Dialog Comments key in the registry (RegOpenKeyEx returned %ld)", dwRet);
    }
    else {
        DWORD dwDataSize = sizeof(m_lldata.szEmailAddress);

        if ((dwRet = RegQueryValueEx(hKey,
                                     _T("Email Address"),
                                     NULL,
                                     NULL,
                                     (LPBYTE) m_lldata.szEmailAddress,
                                     &dwDataSize)) != ERROR_SUCCESS) {

            DebugTrace(0, "No Email Address value in the HKCU\\Software\\Microsoft\\PCHealth\\Clients\\Dialog Comments registry key (RegQueryValueEx returned %ld)", dwRet);
            m_lldata.szEmailAddress[0] = 0;
        }
        else {
            DebugTrace(0, "Email address for this user in the registry: %s", m_lldata.szEmailAddress);
            SendDlgItemMessage(IDC_EDIT_EMAIL_ADDRESS, WM_SETTEXT, 0, (LPARAM) m_lldata.szEmailAddress);
        }

        dwDataSize = sizeof(m_lldata.szBetaID);

        if ((dwRet = RegQueryValueEx(hKey,
                                     _T("Beta ID"),
                                     NULL,
                                     NULL,
                                     (LPBYTE) m_lldata.szBetaID,
                                     &dwDataSize)) != ERROR_SUCCESS) {

            DebugTrace(0, "No Beta ID value in the HKCU\\Software\\Microsoft\\PCHealth\\Clients\\Dialog Comments registry key (RegQueryValueEx returned %ld)", dwRet);
            m_lldata.szBetaID[0] = 0;
        }
        else {
            DebugTrace(0, "Beta ID for this user in the registry: %s", m_lldata.szBetaID);
            SendDlgItemMessage(IDC_EDIT_BETA_ID, WM_SETTEXT, 0, (LPARAM) m_lldata.szBetaID);
        }

        RegCloseKey(hKey);
    }

    //
    // Populate the event category dropdown.
    //

    TCHAR szEventCategoryString[1024];

    LoadString(_Module.GetResourceInstance(), IDS_EVENT_CATEGORY_1, szEventCategoryString, ARRAYSIZE(szEventCategoryString));
    SendDlgItemMessage(IDC_COMBO_EVENT_CATEGORY, CB_ADDSTRING, 0, (LPARAM) szEventCategoryString);

    LoadString(_Module.GetResourceInstance(), IDS_EVENT_CATEGORY_2, szEventCategoryString, ARRAYSIZE(szEventCategoryString));
    SendDlgItemMessage(IDC_COMBO_EVENT_CATEGORY, CB_ADDSTRING, 0, (LPARAM) szEventCategoryString);

    LoadString(_Module.GetResourceInstance(), IDS_EVENT_CATEGORY_3, szEventCategoryString, ARRAYSIZE(szEventCategoryString));
    SendDlgItemMessage(IDC_COMBO_EVENT_CATEGORY, CB_ADDSTRING, 0, (LPARAM) szEventCategoryString);

    LoadString(_Module.GetResourceInstance(), IDS_EVENT_CATEGORY_4, szEventCategoryString, ARRAYSIZE(szEventCategoryString));
    SendDlgItemMessage(IDC_COMBO_EVENT_CATEGORY, CB_ADDSTRING, 0, (LPARAM) szEventCategoryString);

    LoadString(_Module.GetResourceInstance(), IDS_EVENT_CATEGORY_5, szEventCategoryString, ARRAYSIZE(szEventCategoryString));
    SendDlgItemMessage(IDC_COMBO_EVENT_CATEGORY, CB_ADDSTRING, 0, (LPARAM) szEventCategoryString);

    LoadString(_Module.GetResourceInstance(), IDS_EVENT_CATEGORY_6, szEventCategoryString, ARRAYSIZE(szEventCategoryString));
    SendDlgItemMessage(IDC_COMBO_EVENT_CATEGORY, CB_ADDSTRING, 0, (LPARAM) szEventCategoryString);

    //
    // Populate the severity dropdown.
    //

    TCHAR szSeverityString[1024];

    LoadString(_Module.GetResourceInstance(), IDS_SEVERITY_1, szSeverityString, ARRAYSIZE(szSeverityString));
    SendDlgItemMessage(IDC_COMBO_SEVERITY, CB_ADDSTRING, 0, (LPARAM) szSeverityString);

    LoadString(_Module.GetResourceInstance(), IDS_SEVERITY_2, szSeverityString, ARRAYSIZE(szSeverityString));
    SendDlgItemMessage(IDC_COMBO_SEVERITY, CB_ADDSTRING, 0, (LPARAM) szSeverityString);

    LoadString(_Module.GetResourceInstance(), IDS_SEVERITY_3, szSeverityString, ARRAYSIZE(szSeverityString));
    SendDlgItemMessage(IDC_COMBO_SEVERITY, CB_ADDSTRING, 0, (LPARAM) szSeverityString);

    LoadString(_Module.GetResourceInstance(), IDS_SEVERITY_4, szSeverityString, ARRAYSIZE(szSeverityString));
    SendDlgItemMessage(IDC_COMBO_SEVERITY, CB_ADDSTRING, 0, (LPARAM) szSeverityString);

    //
    // Initialize m_crAnchor.  Ideally we could read this from IE's registry,
    // but many other dialogs don't do that and we just don't have time now.
    // We'll default to pure blue, since that is the IE default.
    //

    m_crAnchor = RGB(0, 0, 255);

    //
    // Initialize m_szHyperlinkText from the IDS_HYPERLINK_TEXT string resource.
    //

    m_bShowHyperlink = TRUE;

    if (LoadString(_Module.GetResourceInstance(), IDS_HYPERLINK_TEXT, m_szHyperlinkText, ARRAYSIZE(m_szHyperlinkText)) == 0)
        m_bShowHyperlink = FALSE;

    //
    // Initialize m_szHyperlinkCmdLine from the registry.
    //

    if (m_bShowHyperlink)
        if ((dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                  _T("Software\\Microsoft\\PCHealth\\Clients\\Dialog Comments"),
                                  0,
                                  KEY_QUERY_VALUE,
                                  &hKey)) != ERROR_SUCCESS) {

            DebugTrace(0, "No HKCU\\Software\\Microsoft\\PCHealth\\Clients\\Dialog Comments key in the registry (RegOpenKeyEx returned %ld)", dwRet);
            m_bShowHyperlink = FALSE;
        }
        else {
            DWORD dwDataSize = sizeof(m_szHyperlinkCmdLine);

            if ((dwRet = RegQueryValueEx(hKey,
                                         _T("Hyperlink command line"),
                                         NULL,
                                         NULL,
                                         (LPBYTE) m_szHyperlinkCmdLine,
                                         &dwDataSize)) != ERROR_SUCCESS) {

                DebugTrace(0, "No Hyperlink command line value in the HKLM\\Software\\Microsoft\\PCHealth\\Clients\\Dialog Comments registry key (RegQueryValueEx returned %ld)", dwRet);
                m_szHyperlinkCmdLine[0] = 0;
                m_bShowHyperlink = FALSE;
            }
            else
                DebugTrace(0, "Hyperlink command line in the registry: %s", m_szHyperlinkCmdLine);

            RegCloseKey(hKey);
        }

    //
    // Disable the hyperlink-related controls if we cannot successfully display
    // and launch the hyperlink.
    //

    if (!m_bShowHyperlink) {
        ::SetWindowPos(GetDlgItem(IDC_STATIC_HELP_AND_SUPPORT_1), 0, 0, 0, 0, 0, SWP_HIDEWINDOW + SWP_NOMOVE + SWP_NOSIZE + SWP_NOZORDER);
        ::SetWindowPos(GetDlgItem(IDC_STATIC_HELP_AND_SUPPORT_2), 0, 0, 0, 0, 0, SWP_HIDEWINDOW + SWP_NOMOVE + SWP_NOSIZE + SWP_NOZORDER);
        ::SetWindowPos(GetDlgItem(IDC_BUTTON_HYPERLINK), 0, 0, 0, 0, 0, SWP_HIDEWINDOW + SWP_NOMOVE + SWP_NOSIZE + SWP_NOZORDER);
    }

    //
    // Set the focus to:
    //     Email address if the user hasn't entered it before.
    //     Otherwise beta ID if the user hasn't entered it before.
    //     Otherwise the event category dropdown.
    //

    if (SendDlgItemMessage(IDC_EDIT_EMAIL_ADDRESS, WM_GETTEXTLENGTH, 0, 0) == 0)
        GotoDlgCtrl(GetDlgItem(IDC_EDIT_EMAIL_ADDRESS));
    else if (SendDlgItemMessage(IDC_EDIT_BETA_ID, WM_GETTEXTLENGTH, 0, 0) == 0)
        GotoDlgCtrl(GetDlgItem(IDC_EDIT_BETA_ID));
    else
        GotoDlgCtrl(GetDlgItem(IDC_COMBO_EVENT_CATEGORY));

    m_bHyperlinkHasFocus = FALSE;

    TraceFunctLeave();
    bHandled = TRUE;
    return FALSE;    // We set the focus, return FALSE to prevent O/S from setting focus.
}


//
// CSurveyDlg::OnDrawItem: Draws owner-drawn controls (we have only one: IDC_BUTTON_HYPERLINK)
//
LRESULT
CSurveyDlg::OnDrawItem(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL& bHandled
)
{
    TraceFunctEnter("OnDrawItem");

    HWND hwndHyperlink = NULL;
    HDC hdcHyperlink = NULL;
    HFONT hfontHelpAndSupport2 = NULL;
    HFONT hfontHyperlinkOld = NULL;
    HFONT hfontHyperlinkNew = NULL;
    LOGFONT lfHyperlinkNew;
    RECT rectHyperlink;

    //
    // If we cannot successfully display and launch the hyperlink, return now.
    //

    if (wParam != IDC_BUTTON_HYPERLINK)
        goto Done;

    if (!m_bShowHyperlink)
        goto Done;

    //
    // Get the DC for IDC_BUTTON_HYPERLINK.
    //

    if ((hwndHyperlink = GetDlgItem(IDC_BUTTON_HYPERLINK)) == NULL)
        goto Done;

    if ((hdcHyperlink = ::GetDC(hwndHyperlink)) == NULL)
        goto Done;

    //
    // Get the font used to draw IDC_STATIC_HELP_AND_SUPPORT_2.  Create a new
    // font based on that one but with underline.
    //

    if ((hfontHelpAndSupport2 = (HFONT) SendDlgItemMessage(IDC_STATIC_HELP_AND_SUPPORT_2, WM_GETFONT, 0, 0)) == NULL)
        goto Done;

    if (!GetObject(hfontHelpAndSupport2, sizeof(LOGFONT), &lfHyperlinkNew))
        goto Done;

    lfHyperlinkNew.lfUnderline = TRUE;

    if ((hfontHyperlinkNew = CreateFontIndirect(&lfHyperlinkNew)) == NULL)
        goto Done;

    //
    // For IDC_BUTTON_HYPERLINK, select the new underline font but don't delete
    // the original font.
    //

    hfontHyperlinkOld = (HFONT) SelectObject(hdcHyperlink, hfontHyperlinkNew);

    if ((hfontHyperlinkOld == NULL) || (hfontHyperlinkOld == (HFONT) (ULONG_PTR)GDI_ERROR))
        goto Done;

    //
    // Draw the text using the IE anchor color.  Center the text horizontally in
    // the button.
    //

    SetTextColor(hdcHyperlink, m_crAnchor);
    SetTextAlign(hdcHyperlink, TA_CENTER | TA_TOP);
    SetBkMode(hdcHyperlink, TRANSPARENT);

    ::GetClientRect(hwndHyperlink, &rectHyperlink);

        ExtTextOut(hdcHyperlink, (rectHyperlink.right / 2) + 1, 0, 0, NULL, m_szHyperlinkText, _tcslen(m_szHyperlinkText), NULL);

    //
    // For IDC_BUTTON_HYPERLINK, select the original font.
    //

    SelectObject(hdcHyperlink, hfontHyperlinkOld);

    //
    // Clean up.
    //

Done:

    //
    // Delete the new font we created.
    //

    if (hfontHyperlinkNew != NULL)
        DeleteObject(hfontHyperlinkNew);

    //
    // Release the DC for IDC_BUTTON_HYPERLINK.
    //

    if (hdcHyperlink != NULL)
        ::ReleaseDC(hwndHyperlink, hdcHyperlink);

    //
    // Return.
    //

    TraceFunctLeave();
    bHandled = TRUE;
        return TRUE;
}


//
// CSurveyDlg::OnSetCursor: Sets the cursor to the hand if the mouse is over the hyperlink window
//
LRESULT
CSurveyDlg::OnSetCursor(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL& bHandled
)
{
    TraceFunctEnter("OnSetCursor");

    if (m_bShowHyperlink && ((HWND) wParam == GetDlgItem(IDC_BUTTON_HYPERLINK))) {
        HCURSOR hcursor = LoadCursor(NULL, IDC_HAND);

        SetCursor(hcursor);

        TraceFunctLeave();
        bHandled = TRUE;
            return TRUE;
    }

    TraceFunctLeave();
    bHandled = FALSE;
        return FALSE;
}


//
// HyperlinkCmdHandler: Handles messages from the IDC_BUTTON_HYPERLINK button
//
LRESULT
CSurveyDlg::HyperlinkCmdHandler(
    WORD wNotifyCode,
    WORD wID,
    HWND hWndCtl,
    BOOL& bHandled
)
{
    TraceFunctEnter("HyperlinkCmdHandler");

    //
    // If we gained or lost focus, update the focus rectangle.
    //

    if ((wNotifyCode == BN_SETFOCUS) || (wNotifyCode == BN_KILLFOCUS)) {
        HDC hdc;
        RECT rect;

        hdc = ::GetDC(hWndCtl);

        ::GetClientRect(hWndCtl, &rect);
        DrawFocusRect(hdc, &rect);

        ::ReleaseDC(hWndCtl, hdc);

        m_bHyperlinkHasFocus = (wNotifyCode == BN_SETFOCUS);
    }

    //
    // If we were clicked, launch the hyperlink program.
    //

    else if ((wNotifyCode = BN_CLICKED) || (wNotifyCode = BN_DOUBLECLICKED)) {
        DebugTrace(0, "User clicked IDC_BUTTON_HYPERLINK");

        TCHAR szCmdLine[2048];
        DWORD dwRet;

        dwRet = ExpandEnvironmentStrings(m_szHyperlinkCmdLine, szCmdLine, 2048);

        if ((dwRet == 0) || (dwRet > 2048)) {
            DebugTrace(0, "ExpandEnvironmentStrings() failed on cmdline \"%s\" with error %ld", m_szHyperlinkCmdLine, GetLastError());

            TCHAR szMsg[1024];
            TCHAR szTitle[1024];

            if ((LoadString(_Module.GetResourceInstance(), IDS_HYPERLINK_PROGRAM_FAILED, szMsg, ARRAYSIZE(szMsg)) != 0) &&
                (LoadString(_Module.GetResourceInstance(), IDS_HYPERLINK_PROGRAM_FAILED_TITLE, szTitle, ARRAYSIZE(szTitle)) != 0))

                MessageBox(szMsg, szTitle, MB_OK);
        }
        else {
            TCHAR szWindowsDir[MAX_PATH];
            STARTUPINFO si;
            PROCESS_INFORMATION pi;

            if (!GetSystemWindowsDirectory(szWindowsDir, MAX_PATH))
                szWindowsDir[0] = 0;

            ZeroMemory(&si, sizeof(si));
            si.cb = sizeof(si);

            if (CreateProcess(NULL, szCmdLine, NULL, NULL, FALSE, 0, NULL, szWindowsDir, &si, &pi)) {
                DebugTrace(0, "CreateProcess() succeeded on cmdline \"%s\" with PID %ld, TID %ld", szCmdLine, pi.dwProcessId, pi.dwThreadId);

                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }
            else {
                DebugTrace(0, "CreateProcess() failed cmdline \"%s\" with error %ld", szCmdLine, GetLastError());

                TCHAR szMsg[1024];
                TCHAR szTitle[1024];

                if ((LoadString(_Module.GetResourceInstance(), IDS_HYPERLINK_PROGRAM_FAILED, szMsg, ARRAYSIZE(szMsg)) != 0) &&
                    (LoadString(_Module.GetResourceInstance(), IDS_HYPERLINK_PROGRAM_FAILED_TITLE, szTitle, ARRAYSIZE(szTitle)) != 0))

                    MessageBox(szMsg, szTitle, MB_OK);
            }
        }
    }

    TraceFunctLeave();
    bHandled = TRUE;
        return 0;
}


//
// CSurveyDlg::OnOK: Executes when user has done typing the comment
//                   and has hit submit
LRESULT
CSurveyDlg::OnOK(
    WORD wNotifyCode,
    WORD wID,
    HWND hWndCtl,
    BOOL& bHandled
)
{
    TraceFunctEnter("OnOK");

    //
    // When IDC_BUTTON_HYPERLINK has focus and the user presses Enter, IDOK is
    // generated for some reason.  I think this is because IDC_BUTTON_HYPERLINK
    // is owner-drawn.  Anyway, if IDC_BUTTON_HYPERLINK currently has focus then
    // send BM_CLICK to that control and return immediately.
    //

    if (m_bHyperlinkHasFocus) {
        DebugTrace(0, "User clicked IDC_BUTTON_HYPERLINK, sending BM_CLICK to that control");

        SendDlgItemMessage(IDC_BUTTON_HYPERLINK, BM_CLICK, 0, 0);

        TraceFunctLeave();
        bHandled = TRUE;
        return 0;
    }

    //
    // verify that the user entered all required data.
    //

    if (SendDlgItemMessage(IDC_COMBO_EVENT_CATEGORY, CB_GETCURSEL, 0, 0) == CB_ERR) {
        DebugTrace(0, "User did not select an event category, calling MessageBox");

        TCHAR szMessageBoxTitle[1024];
        TCHAR szMessageBoxText[1024];

        LoadString(_Module.GetResourceInstance(), IDS_NEED_EVENT_CATEGORY, szMessageBoxText, ARRAYSIZE(szMessageBoxText));
        LoadString(_Module.GetResourceInstance(), IDS_NEED_EVENT_CATEGORY_TITLE, szMessageBoxTitle, ARRAYSIZE(szMessageBoxTitle));

        MessageBox(szMessageBoxText, szMessageBoxTitle, MB_OK);

        DebugTrace(0, "OnOK exiting but not calling EndDialog");
        TraceFunctLeave();
        bHandled = TRUE;
        return 0;
    }

    if (SendDlgItemMessage(IDC_COMBO_SEVERITY, CB_GETCURSEL, 0, 0) == CB_ERR) {
        DebugTrace(0, "User did not select a severity, calling MessageBox");

        TCHAR szMessageBoxTitle[1024];
        TCHAR szMessageBoxText[1024];

        LoadString(_Module.GetResourceInstance(), IDS_NEED_SEVERITY, szMessageBoxText, ARRAYSIZE(szMessageBoxText));
        LoadString(_Module.GetResourceInstance(), IDS_NEED_SEVERITY_TITLE, szMessageBoxTitle, ARRAYSIZE(szMessageBoxTitle));

        MessageBox(szMessageBoxText, szMessageBoxTitle, MB_OK);

        DebugTrace(0, "OnOK exiting but not calling EndDialog");
        TraceFunctLeave();
        bHandled = TRUE;
        return 0;
    }

    if (SendDlgItemMessage(IDC_EDIT_COMMENT, WM_GETTEXTLENGTH, 0, 0) == 0) {
        DebugTrace(0, "User did not type in a comment, calling MessageBox");

        TCHAR szMessageBoxTitle[1024];
        TCHAR szMessageBoxText[1024];

        LoadString(_Module.GetResourceInstance(), IDS_NEED_COMMENT, szMessageBoxText, ARRAYSIZE(szMessageBoxText));
        LoadString(_Module.GetResourceInstance(), IDS_NEED_COMMENT_TITLE, szMessageBoxTitle, ARRAYSIZE(szMessageBoxTitle));

        MessageBox(szMessageBoxText, szMessageBoxTitle, MB_OK);

        DebugTrace(0, "OnOK exiting but not calling EndDialog");
        TraceFunctLeave();
        bHandled = TRUE;
        return 0;
    }

    //
    // Write the email address and beta ID for this user to the registry.
    //

    SendDlgItemMessage(IDC_EDIT_EMAIL_ADDRESS, WM_GETTEXT, MAX_EMAIL_ADDRESS_SIZE + 1, (LPARAM) m_lldata.szEmailAddress);

    SendDlgItemMessage(IDC_EDIT_BETA_ID, WM_GETTEXT, MAX_BETA_ID_SIZE + 1, (LPARAM) m_lldata.szBetaID);

    HKEY hKey;
    DWORD dwRet;

    if ((dwRet = RegCreateKeyEx(HKEY_CURRENT_USER,
                                _T("Software\\Microsoft\\PCHealth\\Clients\\Dialog Comments"),
                                0,
                                _T(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ + KEY_SET_VALUE,
                                NULL,
                                &hKey,
                                NULL)) != ERROR_SUCCESS) {

        DebugTrace(0, "Could not create HKCU\\Software\\Microsoft\\PCHealth\\Clients\\Dialog Comments key in the registry (RegCreateKeyEx returned %ld)", dwRet);
    }
    else {
        if ((dwRet = RegSetValueEx(hKey,
                                   _T("Email Address"),
                                   NULL,
                                   REG_SZ,
                                   (LPBYTE) m_lldata.szEmailAddress,
                                   (_tcslen(m_lldata.szEmailAddress) + 1) * sizeof(TCHAR))) != ERROR_SUCCESS)

            DebugTrace(0, "Failed to write Email Address value to the HKCU\\Software\\Microsoft\\PCHealth\\Clients\\Dialog Comments registry key (RegSetValueEx returned %ld)", dwRet);
        else
            DebugTrace(0, "Wrote email address for this user to the registry: %s", m_lldata.szEmailAddress);

        if ((dwRet = RegSetValueEx(hKey,
                                   _T("Beta ID"),
                                   NULL,
                                   REG_SZ,
                                   (LPBYTE) m_lldata.szBetaID,
                                   (_tcslen(m_lldata.szBetaID) + 1) * sizeof(TCHAR))) != ERROR_SUCCESS)

            DebugTrace(0, "Failed to write Beta ID value to the HKCU\\Software\\Microsoft\\PCHealth\\Clients\\Dialog Comments registry key (RegSetValueEx returned %ld)", dwRet);
        else
            DebugTrace(0, "Wrote beta ID for this user to the registry: %s", m_lldata.szBetaID);

        RegCloseKey(hKey);
    }

    //
    // Call the routine to format data collected and transport
    // it to server
    DebugTrace(0, "Calling GetInfoAndLogLameButton");
    GetInfoAndLogLameButton();

    //
    // Kill the comment dialog
    //
    DebugTrace(0, "Calling EndDialog on wID: %ld", wID);
        EndDialog(wID);

    TraceFunctLeave();
    bHandled = TRUE;
        return 0;
}


//
// CSurveyDlg::OnCancel: This executes when user cancels the comment
//
LRESULT
CSurveyDlg::OnCancel(
    WORD wNotifyCode,
    WORD wID,
    HWND hWndCtl,
    BOOL& bHandled
)
{
    //
    // Kill the comment dialog
    //
        EndDialog(wID);
    bHandled = TRUE;
        return 0;
}


//
// CSurveyDlg::IsMessageBox: This routine returns TRUE if the m_hwndTarget is indeed
//                           a message box
//
BOOL
CSurveyDlg::IsMessageBox()
{
    TraceFunctEnter("CSurveyDlg::IsMessageBox");
    BOOL                fRetVal = FALSE;
    LPMSGBOXPARAMS      lpMsgData = NULL;
    UINT                cbSize = 0;

    if(NULL == m_hwndTarget)
    {
        FatalTrace(0, "m_hwndTarget is NULL");
        goto done;
    }

    //
    // Looking at msgbox.c, I realized that the MsgBoxParams are stored in the MessageBox
    // dialog itself using a SetWindowLongPtr. Hence GetWindowLongPtr should retrieve it for
    // messageboxes.
    //

    lpMsgData = (LPMSGBOXPARAMS)::GetWindowLongPtr(m_hwndTarget, GWLP_USERDATA);
    if(NULL == lpMsgData)
    {
        FatalTrace(0, "GetWindowLongPtr failed. Error: %ld", GetLastError());
        fRetVal = FALSE;
        goto done;
    }

    //
    // There are windows other than msgboxes that can have data set in WindowLongPtr
    // The following is a check to see if we have a message box or not. If this is not
    // a real message box, it will throw an exception when we try to read cbSize for
    // some cases.
    //
    DebugTrace(0, "Figuring if this is a msgbox. Addr: %ld", lpMsgData);
    __try
    {
        cbSize = lpMsgData->cbSize;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        FatalTrace(0, "Corrupt MSGBOXPARAMS");
        goto done;
    }

    DebugTrace(0, "cbSize: %ld", cbSize);

    //
    // Some more sanity checks
    //
    if((  cbSize > MSGBOX_TEXT_SIZE)||(  cbSize < sizeof(MSGBOXPARAMS)))
    {
        FatalTrace(0, "Invalid MSGBOXPARAMS");
        goto done;
    }
    else
    {
        //
        // We have a MessageBox
        //
        fRetVal = TRUE;

        //
        // Extract the message box text from the MSGBOXPARAMS
        //
        // NTRAID#NTBUG9-155100-2000/08/13-jasonr
        //
        // Before we determined the maximum number of characters to copy from
        // cbsize.  I have no idea why we were doing that.  Now the maximum is
        // based on the size of the m_lldata.szMsgBoxText buffer.  I wrapped the
        // copy within a __try __except block just to be safe.
        //
        ZeroMemory(m_lldata.szMsgBoxText, sizeof(m_lldata.szMsgBoxText));

        __try
        {
            _tcsncpy((_TCHAR *) m_lldata.szMsgBoxText, (const _TCHAR *) lpMsgData->lpszText, (sizeof(m_lldata.szMsgBoxText) / sizeof(_TCHAR)) - 1);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
        }

        DebugTrace(0,"MessageBox Text: %ls\n", m_lldata.szMsgBoxText);
    }


done:
    TraceFunctLeave();
    return fRetVal;
}


//
// CSurveyDlg::GetInfoAndLogLameButton: The routine that does most of the work to gather
//                                      and format the comment information and uploads
//                                      it to server
void
CSurveyDlg::GetInfoAndLogLameButton()
{
    TraceFunctEnter("GetInfoAndLogLameButton");
    m_lldata.versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    //
    // Get version of binary that launched the comments hook
    //
    GetVersionEx(&m_lldata.versionInfo);

    TCHAR szClass[CLASS_SIZE];
    TCHAR szTitle[TITLE_SIZE];
    TCHAR szComment[COMMENT_TEXT_SIZE + 1];
    TCHAR szText[1024];

    //
    // Clear out buffers First
    //
    ZeroMemory(m_lldata.szTitle, TITLE_SIZE);
    ZeroMemory(m_lldata.szClass, CLASS_SIZE);
    ZeroMemory(m_lldata.szMsgBoxText, MSGBOX_TEXT_SIZE);

    //
    // Gather the Title of the target window
    //
    if (::GetWindowText(m_hwndTarget, szTitle, TITLE_SIZE) == 0)
    {
        DebugTrace(0, "szTitle is NULL");
        ZeroMemory(m_lldata.szTitle, TITLE_SIZE);
    }
    else
    {
        _tcscpy(m_lldata.szTitle, szTitle);
    }

    DebugTrace(0, "m_lldata.szTitle: %ls", m_lldata.szTitle);

    //
    // Gather the class of the target Window
    //
    if (::RealGetWindowClass(m_hwndTarget, szClass,  CLASS_SIZE) == 0)
    {
        DebugTrace(0, "szClass is NULL");
        ZeroMemory(m_lldata.szClass, CLASS_SIZE);
    }
    else
    {
        _tcscpy(m_lldata.szClass, szClass);
    }

    DebugTrace(0, "m_lldata.szClass: %ls", m_lldata.szClass);

    //
    // Check if m_hwndTarget is a MessageBox.
    //
    if(TRUE == IsMessageBox())
    {
        //
        // We are dealing with a Message Box
        //
        DebugTrace(0, "We are dealing with a Message Box");

        //
        // The following disabled code is for reference reasons,
        // Earlier, we used to send a WM_COPY to obtain the message box text
        // Now, IsMessageBox does the trick
#ifdef _SEND_WM_COPY
        if(NULL != m_hwndTarget)
        {
            HANDLE  hMem = NULL;
            WCHAR   *pData = NULL;
            TCHAR   szTitleTmp [MSGBOX_TEXT_SIZE];
            INT     nChar = 0;
            INT     nChar1 = 0;

            //
            // Send WM_COPY to the message box. WM_COPY causes the MessageBox to write
            // it's message box text to the clipboard
            //
            DebugTrace(0, "Sending WM_COPY to m_hwndTarget");
            SendMessage( m_hwndTarget, WM_COPY, 0, 0 );

            //
            // Open the clipboard of the current task
            //
            DebugTrace(0, "OpenClipboard");
            if(FALSE == ::OpenClipboard( m_hwndTarget ))
            {
                FatalTrace(0, "OpenClipBoard failed. Error: %ld", GetLastError());
                goto done;
            }

            //
            // Get the Data written by the target Window to the Clipboard
            //
            DebugTrace(0, "GetClipboardData");
            hMem = GetClipboardData( CF_UNICODETEXT );
            if(NULL == hMem)
            {
                FatalTrace(0, "GetClipBoardData failed. Error: %ld\n", GetLastError());
                goto done;
            }

            //
            // Get the memory location for the data written to the clipboard
            //
            DebugTrace(0, "GlobalLock");
            pData = (LPWSTR) GlobalLock( hMem );
            if(NULL == pData)
            {
                FatalTrace(0, "GlobalLock failed. Error: %ld\n", GetLastError());
                goto done;
            }

            if(pData[0] == '\0')
            {
                FatalTrace(0, "Nothing in clipboard");
                goto done;
            }

            //
            // Advance past the first ---------------------------\r\n
            //
            DebugTrace(0, "Advancing past the first ---");
            for(nChar = 0; (nChar < _tcslen(pData))&&(!((pData[nChar] == '-')&&(pData[nChar+1] == '\r')&&(pData[nChar+2] == '\n'))); nChar++);

            //
            // Check to see if we have data in the right format.
            //
            if ( nChar == _tcslen(pData))
            {
                //
                // This check is necessary, because the check for messagebox based on the window class
                // is best effort and not 100% accurate. So, we may think that the target window is a
                // message box, where as it may not be. This check is therefore necessary.
                FatalTrace(0, "This is not a valid messagebox");
                goto done;
            }

            nChar += 3;
            DebugTrace(0, "nChar: %ld", nChar);

            //
            // Extract the Caption
            //
            DebugTrace(0, "Extracting the Caption");
            for(nChar1 = 0; !((pData[nChar] == '\r')&&(pData[nChar+1] == '\n')&&(pData[nChar+2] == '-')); nChar1++,nChar++)
            {
                szTitleTmp[ nChar1 ] = pData[nChar];
            }

            nChar += 2;
            DebugTrace(0, "nChar: %ld", nChar);

            szTitleTmp[ nChar1 + 1] = '\0';
            DebugTrace(0, "MessageBox Title: %ls", szTitleTmp);


            //
            // Advance past the second ---------------------------\r\n
            //
            DebugTrace(0, "Advancing past the second ---");
            for(; !((pData[nChar] == '-')&&(pData[nChar+1] == '\r')&&(pData[nChar+2] == '\n')); nChar++);
            nChar += 3;
            DebugTrace(0, "nChar: %ld", nChar);

            //
            // Extract the message box text
            //
            DebugTrace(0, "Extracting the MessageBox text");
            for(nChar1 = 0; !((pData[nChar] == '\r')&&(pData[nChar+1] == '\n')&&(pData[nChar+2] == '-')); nChar1++,nChar++)
            {
                m_lldata.szMsgBoxText[ nChar1 ] = pData[nChar];
            }

            m_lldata.szMsgBoxText[ nChar1 + 1] = '\0';

            DebugTrace(0,"MessageBox szText: %ls", m_lldata.szMsgBoxText);


            //
            // Clear out the clipboard
            //
            EmptyClipboard();

done:

            if(NULL != hMem)
            {
                if(FALSE == GlobalUnlock( hMem ))
                {
                    printf("GlobalUnlock failed. Error; %ld\n", GetLastError());
                }
            }

            CloseClipboard();
        }
#endif  // _SEND_WM_COPY
    }
    else
    {
        DebugTrace(0, "class: %s is not a MessageBox", szClass);
    }

    //
    // Obtain the Comment
    //
    if (GetDlgItemText(IDC_EDIT_COMMENT, szComment, COMMENT_TEXT_SIZE + 1) == 0)
    {
        DebugTrace(0, "Comment is NULL");
        ZeroMemory(m_lldata.szComment, COMMENT_TEXT_SIZE + 1);
    }
    else
    {
        _tcscpy(m_lldata.szComment, szComment);
    }

    DebugTrace(0, "sizeof Comment text: %ld", _tcslen( m_lldata.szComment ));

    //
    // Populate m_lldata.dwEventCategory from the selection in
    // IDC_COMBO_EVENT_CATEGORY.  Note that this is purposefully done with a
    // switch statement, rather than with an algorithmic calculation such as:
    //
    //     m_lldata.dwEventCategory = 1 + SendDlgItemMessage(IDC_COMBO_EVENT_CATEGORY, CB_GETCURSEL, 0, 0);
    //
    // If we ever change the possible selections in the future, the algorithm
    // might not be correct, so we don't use it.
    //

    LRESULT dwCurSel = SendDlgItemMessage(IDC_COMBO_EVENT_CATEGORY, CB_GETCURSEL, 0, 0);

    _ASSERT(dwCurSel == 0 || dwCurSel == 1 || dwCurSel == 2 || dwCurSel == 3 || dwCurSel == 4 || dwCurSel == 5);

    switch (dwCurSel) {
        case 0:
            m_lldata.dwEventCategory = 1;
            break;

        case 1:
            m_lldata.dwEventCategory = 2;
            break;

        case 2:
            m_lldata.dwEventCategory = 3;
            break;

        case 3:
            m_lldata.dwEventCategory = 4;
            break;

        case 4:
            m_lldata.dwEventCategory = 5;
            break;

        case 5:
            m_lldata.dwEventCategory = 6;
            break;
    }

    //
    // Populate m_lldata.dwSeverity from the selection in IDC_COMBO_SEVERITY.
    // Note that this is purposefully done with a switch statement, rather than
    // with an algorithmic calculation such as:
    //
    //     m_lldata.dwSeverity = 1 + SendDlgItemMessage(IDC_COMBO_SEVERITY, CB_GETCURSEL, 0, 0);
    //
    // If we ever change the possible selections in the future, the algorithm
    // might not be correct, so we don't use it.
    //

    dwCurSel = SendDlgItemMessage(IDC_COMBO_SEVERITY, CB_GETCURSEL, 0, 0);

    _ASSERT(dwCurSel == 0 || dwCurSel == 1 || dwCurSel == 2 || dwCurSel == 3);

    switch (dwCurSel) {
        case 0:
            m_lldata.dwSeverity = 1;
            break;

        case 1:
            m_lldata.dwSeverity = 2;
            break;

        case 2:
            m_lldata.dwSeverity = 3;
            break;

        case 3:
            m_lldata.dwSeverity = 4;
            break;
    }

    //
    // It doesn't seem like a good idea to initialize COM on somebody
    // else's thread, so we launch a new thread to do the reporting.
    //
    DebugTrace(0, "Creating Seperate thread to deal with COM");

    UINT uThreadId;  // dummy
    HANDLE hThread = (HANDLE)_beginthreadex(NULL, 0, LogLameButtonThread, &m_lldata, 0, &uThreadId);

    if (hThread != 0) {
        DWORD dwEvent = WaitForSingleObject(hThread, INFINITE);
        _ASSERT(dwEvent == WAIT_OBJECT_0);

        //
        // NTRAID#NTBUG9-154248-2000/08/08-jasonr
        // NTRAID#NTBUG9-152439-2000/08/08-jasonr
        //
        // We used to pop up the "Thank You" message box in the new thread.
        // Now we pop it up in the dialog box thread instead to fix these bugs.
        // The new thread now returns 0 to indicate success, 1 to indicate
        // failure.  We only pop up the dialog box on success.
        //
        DWORD dwExitCode;

        if (!GetExitCodeThread(hThread, &dwExitCode))
            dwExitCode = 1;

        CloseHandle(hThread);

        TCHAR szThankYouMessage[1024];
        TCHAR szThankYouMessageTitle[1024];

        LoadString(_Module.GetResourceInstance(),
                   IDS_THANK_YOU,
                   szThankYouMessage,
                   ARRAYSIZE(szThankYouMessage));

        LoadString(_Module.GetResourceInstance(),
                   IDS_THANK_YOU_TITLE,
                   szThankYouMessageTitle,
                   ARRAYSIZE(szThankYouMessageTitle));

        MessageBox(szThankYouMessage, szThankYouMessageTitle, MB_OK);
    }

    TraceFunctLeave();
}


//
// DllMain :    The DllMain for LAMEBTN.DLL
//
BOOL WINAPI DllMain
(
    HINSTANCE hInstance,
    DWORD     dwreason,
    LPVOID    reserved
)
{
    switch (dwreason) {
    case DLL_PROCESS_ATTACH:
        // _CrtSetBreakAlloc(275);
#ifndef NOTRACE
        InitAsyncTrace();
#endif

        ghDllInst = hInstance;

        DisableThreadLibraryCalls(hInstance);

        _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_WNDW);
        _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_DEBUG);
        _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_DEBUG);

        _Module.Init(NULL, hInstance);
        break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        break;

        case DLL_PROCESS_DETACH:
        _CrtDumpMemoryLeaks();

        _Module.Term();
        TermAsyncTrace();
                break;
    }

    return TRUE;
}


//
// LogLameButtonThread: This is the thread spawned by the comments dialog
//                      to format the data collected into XML and upload
//                      to server
unsigned int __stdcall
LogLameButtonThread(
    void* pvLogData
)
{
    TraceFunctEnter("LogLameButtonThread");

    //
    // NTRAID#NTBUG9-154248-2000/08/08-jasonr
    // NTRAID#NTBUG9-152439-2000/08/08-jasonr
    //
    // We used to pop up the "Thank You" message box in the new thread.
    // Now we pop it up in the dialog box thread instead to fix these bugs.
    // The new thread now returns 0 to indicate success, 1 to indicate
    // failure.  We only pop up the dialog box on success.
    //
    int iRet = 1;

    //
    // Initialize COM
    //
    DebugTrace(0, "Initializing COM");
    HRESULT hrCoInit = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    HRESULT             hr = S_OK;

    if (SUCCEEDED(hrCoInit)) {

        //
        // Create a temp file that will hold a minidump of the current process.
        //

        WCHAR szTempPath[MAX_PATH];

        if ((GetTempPathW(MAX_PATH, szTempPath) == 0) || (GetTempFileNameW(szTempPath, _T("EMI"), 0, ((LAMELOGDATA *) pvLogData)->szMiniDumpPath) == 0)) {
            DebugTrace(0, "GetTempPathW() or GetTempFileNameW() failed, minidump will not be created");
            ((LAMELOGDATA *) pvLogData)->szMiniDumpPath[0] = 0;
        }
        else {
            DebugTrace(0, "Minidump will be stored in temp file \"%s\"", ((LAMELOGDATA *) pvLogData)->szMiniDumpPath);

            //
            // Build a command line for executing DUMPREP.EXE.
            //

            WCHAR szWindowsDir[MAX_PATH+1];
            WCHAR szCmdLine[1024];

            ZeroMemory(szWindowsDir, sizeof(szWindowsDir));
            ZeroMemory(szCmdLine, sizeof(szCmdLine));

            GetSystemWindowsDirectoryW(szWindowsDir, MAX_PATH);

            wsprintf(szCmdLine, L"%s\\system32\\dumprep.exe %lu -d 7 7 \"%s\"", szWindowsDir, GetCurrentProcessId(), ((LAMELOGDATA *) pvLogData)->szMiniDumpPath);

            //
            // CreateProcess() on DUMPREP.EXE to create the minidump.
            //

            STARTUPINFO si;
            PROCESS_INFORMATION pi;

            ZeroMemory(&si, sizeof(si));
            si.cb = sizeof(si);

            if (!CreateProcessW(NULL, szCmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
                DebugTrace(0, "CreateProcess() failed cmdline \"%s\" with error %ld; minidump will not be created", szCmdLine, GetLastError());
                DeleteFileW(((LAMELOGDATA *) pvLogData)->szMiniDumpPath);
                ((LAMELOGDATA *) pvLogData)->szMiniDumpPath[0] = 0;
            }
            else {
                DebugTrace(0, "CreateProcess() succeeded on cmdline \"%s\" with PID %ld, TID %ld; waiting up to 60 seconds...", szCmdLine, pi.dwProcessId, pi.dwThreadId);

                //
                // Wait for DUMPREP.EXE to exit and interpret the exit code:
                // frrvOk (defined in faultrep.h) is success; anything else is
                // failure.  Wait for a maximum of 60 seconds.
                //

                DWORD dwRet;
                BOOL bSuccess = FALSE;

                switch (dwRet = WaitForSingleObject(pi.hProcess, 60000)) {

                    case WAIT_OBJECT_0:
                        DebugTrace(0, "The process handle is signalled");

                        if (!GetExitCodeProcess(pi.hProcess, &dwRet)) {
                            DebugTrace(0, "GetExitCodeProcess() failed; GetLastError() = %lu; minidump will not be created", GetLastError());
                            DeleteFileW(((LAMELOGDATA *) pvLogData)->szMiniDumpPath);
                            ((LAMELOGDATA *) pvLogData)->szMiniDumpPath[0] = 0;
                        }
                        else if (dwRet != frrvOk) {
                            DebugTrace(0, "The process failed with exit code %lu; minidump will not be created", dwRet);
                            DeleteFileW(((LAMELOGDATA *) pvLogData)->szMiniDumpPath);
                            ((LAMELOGDATA *) pvLogData)->szMiniDumpPath[0] = 0;
                        }
                        else {
                            DebugTrace(0, "The process exited and the minidump was created successfully");
                            bSuccess = TRUE;
                        }

                        break;

                    case WAIT_TIMEOUT:
                        DebugTrace(0, "WaitForSingleObject() returned WAIT_TIMEOUT after 60 seconds; minidump will not be created");
                        DeleteFileW(((LAMELOGDATA *) pvLogData)->szMiniDumpPath);
                        ((LAMELOGDATA *) pvLogData)->szMiniDumpPath[0] = 0;
                        break;

                    case WAIT_FAILED:
                        DebugTrace(0, "WaitForSingleObject() returned WAIT_FAILED, GetLastError() = %lu; minidump will not be created", GetLastError());
                        DeleteFileW(((LAMELOGDATA *) pvLogData)->szMiniDumpPath);
                        ((LAMELOGDATA *) pvLogData)->szMiniDumpPath[0] = 0;
                        break;

                    default:
                        DebugTrace(0, "WaitForSingleObject() returned unknown code %lu, GetLastError() = %lu; minidump will not be created", dwRet, GetLastError());
                        DeleteFileW(((LAMELOGDATA *) pvLogData)->szMiniDumpPath);
                        ((LAMELOGDATA *) pvLogData)->szMiniDumpPath[0] = 0;
                        break;
                }

                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);

                if (bSuccess) {

                    //
                    // Create a .CAB file
                    //

                    WCHAR szCABPath[MAX_PATH+1];

                    wcscpy(szCABPath, ((LAMELOGDATA *) pvLogData)->szMiniDumpPath);
                    wcscat(szCABPath, L".cab");

                    if (FAILED(MPC::CompressAsCabinet(((LAMELOGDATA *) pvLogData)->szMiniDumpPath, szCABPath, L"minidump.dmp")) ||
                        !MoveFileExW(szCABPath, ((LAMELOGDATA *) pvLogData)->szMiniDumpPath, MOVEFILE_REPLACE_EXISTING + MOVEFILE_WRITE_THROUGH)) {

                        DebugTrace(0, "MPC::CompressAsCabinet failed (more likely) or MoveFileExW failed (less likely); minidump will not be created");
                        DeleteFileW(((LAMELOGDATA *) pvLogData)->szMiniDumpPath);
                        DeleteFileW(szCABPath);
                        ((LAMELOGDATA *) pvLogData)->szMiniDumpPath[0] = 0;

                    }
                    else
                        DebugTrace(0, "The minidump was compressed successfully as a .CAB file");
                }
            }

        }

        //
        // Call the Routine that does the real work (defined in logging.cpp)
        //
        DebugTrace(0, "Calling LogLameBtn");
        iRet = LogLameButton((LAMELOGDATA*) (pvLogData));

        CoUninitialize();
    }
    else
    {
        FatalTrace(0, "Failed to initialize COM");
        goto done;
    }

done:
    TraceFunctLeave();
    return iRet;
}


//
// CommentReport: user calls into CommentReport passing in the hWnd and call stack when
//                the Comments? link is clicked (This is the routine called via the Comments hook)
VOID WINAPI
CommentReport(
    HWND hwnd,  // [in] Window of Dialog being commented on
    PVOID pv    // [in] Call stack
)
{
    TraceFunctEnter("CommentReport");

    //
    // Fix for bug 141367.  Walk up through the stack of windows examining the
    // module file name of each one.  Count the number of windows that are owned
    // by lamebtn.dll.  If we find two it means there are two lamebtn dialogs on
    // the screen already.  In that case, return immediately.  (We allow up to
    // two of them so the user can comment on the lamebtn dialog itself.)
    //

    HMODULE hThisModule = NULL;

    if ((hThisModule = GetModuleHandle(L"lamebtn.dll")) != NULL)
    {
        TCHAR szThisModule[MAX_PATH] = { 0 };

        if (GetModuleFileName(hThisModule, szThisModule, MAX_PATH) > 0)
        {
            HWND hWnd2 = hwnd;
            TCHAR szWndModule[MAX_PATH] = { 0 };
            DWORD dwLamebtnDLLWindows = 0;

            while (hWnd2 != NULL)
            {
                if ((GetWindowModuleFileName(hWnd2, szWndModule, MAX_PATH) > 0) &&
                    (_wcsicmp(szThisModule, szWndModule) == 0))
                {
                    dwLamebtnDLLWindows++;

                    if (dwLamebtnDLLWindows >= 2) {
                        DebugTrace(0, "Two lamebtn dialogs are already up, therefore we won't bring up another one");
                        return;
                    }
                }

                hWnd2 = GetParent(hWnd2);
            }
        }
    }

#ifdef _GENERATE_STACK_AT_CLIENT
    TCHAR szWindowText[MAX_BUF_SIZE + 1];
    TCHAR szBigBuff[2 * MAX_BUF_SIZE + 1];
    TCHAR tmpbuf[128 + 1];

    //
    // Obtain the WindowText
    //
    GetWindowText(hwnd, szWindowText, MAX_BUF_SIZE);

    //
    // pvStackTrace can be NULL
    //
    if(pv)
    {
                wsprintf(tmpbuf, TEXT("\t(%x) = %x\n\t(%x) = %x\n\t(%x) = %x\n\t(%x) = %x"), ((int*)pv+12), (int)*((int*)pv+12), ((int*)pv+8),(int)*((int*)pv+8), ((int*)pv+4), (int)*((int*)pv+4),((int*)pv), (int)*((int*)pv));
    }
    else
    {
        //
        // Generating a stack walk at the client is not really a good idea. Since it will work only
        // on x86. Absence of call stack in the uploaded comment report should be handled at the server
        // The following code though disabled is still kept here for reference.
        //
        RtlWalkFrameChain_t fnRtlWalkFrameChain =
            (RtlWalkFrameChain_t) GetProcAddress(GetModuleHandle(_T("NTDLL.DLL")), "RtlWalkFrameChain");
        STACKTRACEDATA* pstd = (STACKTRACEDATA*) _alloca(offsetof(STACKTRACEDATA, callers[64]));
        pstd->nCallers = fnRtlWalkFrameChain(pstd->callers, 64, 0);

        pv = (PVOID)pstd;
        if(NULL != pv)
        {
            DebugTrace(0, "Generated a new stacktrace");
            wsprintf(tmpbuf, TEXT("\t(%x) = %x\n\t(%x) = %x\n\t(%x) = %x\n\t(%x) = %x"), ((int*)pv+12), (int)*((int*)pv+12), ((int*)pv+8),(int)*((int*)pv+8), ((int*)pv+4), (int)*((int*)pv+4),((int*)pv), (int)*((int*)pv));
        }
        else
        {
            FatalTrace(0, "StackTrace not available...");
            wsprintf(tmpbuf, TEXT("StackTrace not available..."));
        }

        FatalTrace(0, "StackTrace not available...");
        wsprintf(tmpbuf, TEXT("StackTrace not available..."));
    }

    DebugTrace(0, "Got comment from window '%ls'", szWindowText, tmpbuf);
    DebugTrace(0, "StackTrace: '%ls'", tmpbuf);
#endif

    //
    // Create the Comment dialog
    //
    CSurveyDlg dlg;

    //
    // Initialize the comment dialog
    //
    DebugTrace(0, "Calling dlg.Init");
    dlg.Init(hwnd, (PSTACKTRACEDATA) pv);

    //
    // Launch the comment dialog
    //
    DebugTrace(0, "Calling DoModal");
    dlg.DoModal(hwnd, NULL);

    TraceFunctLeave();
}


//
// nsoy sayz: The following code is used by the MessageBox hook(which for some
//            mysterious reason disappeared when Neptune code was moved to Whistler)
//            Hence, the code used by the MessageBox hook is henceforth
//            not maintained.
//
// UploadInstrumentationCollectionData: Dunno why this is present. Walter must have
//                                      had some use for this.
VOID WINAPI UploadInstrumentationCollectionData()
{
    //bugbug: do something meaningful
    ;
}

//
// LogMessageBoxThread: MessageBox hook data collection thread.
//                      - present for historical reasons. Not needed for Whistler
//
unsigned int __stdcall LogMessageBoxThread(void* pvLogData)
{
    HRESULT hrCoInit = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hrCoInit)) {
        LogMessageBox((MSGBOXLOGDATA*) pvLogData);

        CoUninitialize();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by lamebtn.rc
//
#define IDC_STATIC_INTRO                5000
#define IDC_STATIC_BETA_ID              5001
#define IDC_STATIC_EMAIL_ADDRESS        5002
#define IDC_STATIC_EVENT_CATEGORY       5003
#define IDC_STATIC_SEVERITY             5004
#define IDC_STATIC_COMMENT              5006
#define IDC_STATIC_HELP_AND_SUPPORT_1   5007
#define IDC_STATIC_HELP_AND_SUPPORT_2   5008
#define IDC_STATIC_HELP_AND_SUPPORT_3   5009
#define IDC_EDIT_EMAIL_ADDRESS          5010
#define IDC_EDIT_BETA_ID                5011
#define IDC_COMBO_EVENT_CATEGORY        5012
#define IDC_COMBO_SEVERITY              5013
#define IDC_EDIT_COMMENT                5014
#define IDC_BUTTON_HYPERLINK            5015
#define IDD_SURVEYDLG                   10000
#define IDS_INTRO                       10001
#define IDS_INTRO_WITH_TITLE            10002
#define IDS_THANK_YOU                   10003
#define IDS_THANK_YOU_TITLE             10004
#define IDS_EVENT_CATEGORY_0            10005
#define IDS_EVENT_CATEGORY_1            10006
#define IDS_EVENT_CATEGORY_2            10007
#define IDS_EVENT_CATEGORY_3            10008
#define IDS_EVENT_CATEGORY_4            10009
#define IDS_EVENT_CATEGORY_5            10010
#define IDS_EVENT_CATEGORY_6            10011
#define IDS_SEVERITY_0                  10012
#define IDS_SEVERITY_1                  10013
#define IDS_SEVERITY_2                  10014
#define IDS_SEVERITY_3                  10015
#define IDS_SEVERITY_4                  10016
#define IDS_NEED_EVENT_CATEGORY         10017
#define IDS_NEED_EVENT_CATEGORY_TITLE   10018
#define IDS_NEED_SEVERITY               10019
#define IDS_NEED_SEVERITY_TITLE         10020
#define IDS_NEED_COMMENT                10021
#define IDS_NEED_COMMENT_TITLE          10022
#define IDS_HYPERLINK_TEXT              10023
#define IDS_HYPERLINK_PROGRAM_FAILED    10024
#define IDS_HYPERLINK_PROGRAM_FAILED_TITLE 10025

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        10024
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         5016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\dll\logging.h ===
/*
    Copyright 1999 Microsoft Corporation
    
    Logging for MessageBoxes and the comment button (aka the "lame" button).

    Walter Smith (wsmith)
*/

#pragma once

#include "simplexml.h"

// Stack trace passed by USER to our hook

struct STACKTRACEDATA {
    ULONG   nCallers;
    PVOID   callers[1];
};
typedef STACKTRACEDATA* PSTACKTRACEDATA;

// Data we log for MessageBoxes

struct MSGBOXLOGDATA {
    OSVERSIONINFO versionInfo;        // OS version
    LPCTSTR     szOwnerClass;           // Owner window class (from RealGetWindowClass)
    LPCTSTR     szOwnerTitle;           // Owner window title
    PSTACKTRACEDATA pStackTrace;        // Stack trace of creation site
    DWORD       dwResult;               // Return value of MessageBox (IDxxx)

    // The rest are as defined in MSGBOXPARAMS
    LPCTSTR     szText;
    LPCTSTR     szCaption;
    DWORD       dwStyle;
    DWORD       dwContextHelpId;
};
typedef MSGBOXLOGDATA* PMSGBOXLOGDATA;

// Data we log for comments

#define MSGBOX_TEXT_SIZE       512
#define COMMENT_TEXT_SIZE      2000
#define CLASS_SIZE             64
#define TITLE_SIZE             64
#define MAX_BUF_SIZE           512
#define MAX_EMAIL_ADDRESS_SIZE 255
#define MAX_BETA_ID_SIZE       6

#define MSGBOX_CLASS    _T("#32770")

struct LAMELOGDATA {
    DWORD           dwSeverity;                                 // User's severity selection
    DWORD           dwEventCategory;                            // User's event category selection
    PBYTE           pbImage;                                    // GIF image of the window
    DWORD           cbImage;                                    // Size of pbImage data in bytes
    PSTACKTRACEDATA pStackTrace;                                // Stack trace of creation site
    OSVERSIONINFO   versionInfo;                                // OS version
    TCHAR           szClass[CLASS_SIZE];                        // Window class (from RealGetWindowClass)
    TCHAR           szTitle[TITLE_SIZE];                        // Window title
    TCHAR           szComment[COMMENT_TEXT_SIZE + 1];           // User's comment
    TCHAR           szMsgBoxText[MSGBOX_TEXT_SIZE];             // Message Box text
    TCHAR           szEmailAddress[MAX_EMAIL_ADDRESS_SIZE + 1]; // User's email address
    TCHAR           szBetaID[MAX_BETA_ID_SIZE + 1];             // User's beta ID
    WCHAR           szMiniDumpPath[MAX_PATH+1];                 // Path to a file containing a minidump to upload.
};
typedef LAMELOGDATA* PLAMELOGDATA;

void LogMessageBox(PMSGBOXLOGDATA pData);

int LogLameButton(PLAMELOGDATA pData);

// XML helpers

void GetISO8601DateTime(LPTSTR buf);

wstring Hexify(DWORD dwValue);

wstring Decimalify(DWORD dwValue);

// stack.cpp

void GenerateXMLStackTrace(PSTACKTRACEDATA pstd,
                           SimpleXMLNode* pTopElt);

// upload.cpp

enum ENUM_UPLOAD_TYPES { UPLOAD_MESSAGEBOX, UPLOAD_LAMEBUTTON };
int QueueXMLDocumentUpload(ENUM_UPLOAD_TYPES type, SimpleXMLDocument& doc);

typedef TCHAR GUIDSTR[39];
void GetMachineSignature(GUIDSTR szGUID);

// image.cpp

void GetWindowImage(HWND hwnd, BYTE** ppData, DWORD* pcbData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\dll\lamebtn.h ===
#ifndef _INSTCOLL_H_
#define _INSTCOLL_H_

#include <windows.h>
#include <objbase.h>

#include "resource.h"

#define HDIB HANDLE
#define PALVERSION   0x300
#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)
#define IS_WIN30_DIB(lpbi)  ((*(LPDWORD)(lpbi)) == sizeof(BITMAPINFOHEADER))

/*
HBITMAP CopyWindowToDIB(HWND hwndTarget);
HBITMAP CopyScreenToBitmap(LPRECT lpRect);
HPALETTE GetSystemPalette(void);
HDIB BitmapToDIB(HBITMAP hBitmap, HPALETTE hPal);
int PalEntriesOnDevice(HDC hDC);
WORD PaletteSize(LPSTR lpDIB);
WORD DIBNumColors(LPSTR lpDIB);
*/

void CopyWindowToGIF(HWND hwndTarget);


#endif _INSTCOLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\simplexml.cpp ===
/*
    Copyright 1999 Microsoft Corporation
    
    Simplified XML "DOM"

    Walter Smith (wsmith)
    Rajesh Soy   (nsoy) - modified - 4/13/2000
 */

#ifdef THIS_FILE
#undef THIS_FILE
#endif

static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


#include "stdafx.h"

#define NOTRACE

#include "simplexml.h"

#ifdef SIMPLEXML_WANTPARSER

class __declspec(uuid("7887F5E7-640C-45A5-B98B-1E8645E2F7BA")) DataParser;
interface __declspec(uuid("9EFEB013-4E9C-42aa-8354-C5508E352346")) IDataParser;

struct IDataParser : public IUnknown {
    virtual HRESULT STDMETHODCALLTYPE GetTopNode(/*OUT*/ SimpleXMLNode** ppNode) = 0;
};

class ATL_NO_VTABLE DataParser : 
	public CComObjectRoot,
	public CComCoClass<DataParser, &__uuidof(DataParser)>,
    public IXMLNodeFactory,
    public IDataParser
{
public:

public:
	DataParser()
	{
        m_pNodeHolder = auto_ptr<SimpleXMLNode>(new SimpleXMLNode);
	}

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(DataParser)
	COM_INTERFACE_ENTRY(IXMLNodeFactory)
	COM_INTERFACE_ENTRY(IDataParser)
END_COM_MAP()

//private:
public:
    auto_ptr<SimpleXMLNode> m_pNodeHolder;

public:
    // IXMLNodeFactory

    STDMETHOD(NotifyEvent)(IXMLNodeSource* pSource,
                           XML_NODEFACTORY_EVENT iEvt);

    STDMETHOD(BeginChildren)(IXMLNodeSource* pSource, 
                             XML_NODE_INFO* pNodeInfo);   
            
    STDMETHOD(EndChildren)(IXMLNodeSource* pSource,
                           BOOL fEmpty,
                           XML_NODE_INFO* pNodeInfo);

    STDMETHOD(Error)(IXMLNodeSource* pSource,
                     HRESULT hrErrorCode,
                     USHORT cNumRecs,
                     XML_NODE_INFO** aNodeInfo);

    STDMETHOD(CreateNode)(IXMLNodeSource* pSource,
                          PVOID pNodeParent,
                          USHORT cNumRecs,
                          XML_NODE_INFO** aNodeInfo);

    // IDataParser

    // Get a pointer to the "node holder" (a node whose children
    // are the parsed document) -- caller gets ownership of the
    // pointer and must delete when finished.

    STDMETHOD(GetTopNode)(/*OUT*/ SimpleXMLNode** ppNode)
    {
        *ppNode = m_pNodeHolder.get();
        m_pNodeHolder.release();
        return S_OK;
    }
};

HRESULT DataParser::NotifyEvent(IXMLNodeSource* pSource,
                                XML_NODEFACTORY_EVENT iEvt)
{
    switch (iEvt) {
    case XMLNF_STARTDOCUMENT:
        {
            CComQIPtr<IXMLParser> pParser(pSource);
            ThrowIfTrue(!pParser);

            pParser->SetRoot(m_pNodeHolder.get());
        }
        break;

    default:
        break;
    }

    return S_OK;
}

HRESULT DataParser::BeginChildren(IXMLNodeSource* pSource, 
                                  XML_NODE_INFO* pNodeInfo)
{
    return S_OK;
}

HRESULT DataParser::EndChildren(IXMLNodeSource* pSource,
                                BOOL fEmpty,
                                XML_NODE_INFO* pNodeInfo)
{
    return S_OK;
}

HRESULT DataParser::Error(IXMLNodeSource* pSource,
                          HRESULT hrErrorCode,
                          USHORT cNumRecs,
                          XML_NODE_INFO** aNodeInfo)
{
    throw hrErrorCode;

    return S_OK;
}

HRESULT DataParser::CreateNode(IXMLNodeSource* pSource,
                               PVOID pNodeParent,
                               USHORT cNumRecs,
                               XML_NODE_INFO** aNodeInfo)
{
    switch (aNodeInfo[0]->dwType) {
    case XML_ELEMENT:
        {
            // Make a new node and add it to the parent node

            XML_NODE_INFO* pTagInfo = aNodeInfo[0];
            wstring tag(pTagInfo->pwcText, pTagInfo->ulLen);
            SimpleXMLNode* pNode = ((SimpleXMLNode*) pNodeParent)->AppendChild(tag);
            pTagInfo->pNode = pNode;

            // Collect attributes, if any

            if (cNumRecs > 1) {
                wstring sName;
                wstring sValue;

                for (int i = 1; i < cNumRecs; i++) {
                    XML_NODE_INFO* pInfo = aNodeInfo[i];

                    switch (pInfo->dwType) {
                    case XML_ATTRIBUTE:
                        if (!sName.empty()) {
                            pNode->SetAttribute(sName, sValue);
                            sName.erase();
                            sValue.erase();
                        }
                        sName = wstring(pInfo->pwcText, pInfo->ulLen);
                        break;

                    case XML_PCDATA:
                        sValue.append(pInfo->pwcText, pInfo->ulLen);
                        break;

                    case XML_ENTITYREF:
                        // We don't deal with non-predefined entities, so if we see
                        // an ENTITYREF we're guaranteed to parse incorrectly.
                        throw E_FAIL;
                        break;

                    default:
                        break;
                    }
                }

                if (!sName.empty()) {
                    pNode->SetAttribute(sName, sValue);
                }
            }
        }
        break;

    case XML_PCDATA:
        {
            _ASSERT(pNodeParent != NULL);
            ((SimpleXMLNode*) pNodeParent)->text.append(aNodeInfo[0]->pwcText, aNodeInfo[0]->ulLen);
        }
        break;
    }

    return S_OK;
}

class FileMapping {
public:
    FileMapping()
        : hFile(NULL), hMapping(NULL), pView(NULL)
    {
    }

    ~FileMapping()
    {
        if (pView != NULL)
            UnmapViewOfFile(pView);
        if (hMapping != NULL)
            CloseHandle(hMapping);
        if (hFile != NULL)
            CloseHandle(hFile);
    }

    void Open(LPCTSTR szFile)
    {
        // Sometimes the file is still in use by the upload library when we find
        // it in the directory -- not sure how this can be true, but it seems to
        // be short-lived, so we just give it a chance to finish up and retry a
        // couple of times.
        TraceFunctEnter(_T("FileMapping"));
        for (int tries = 0; tries < 3; tries++) {
            hFile = CreateFile(szFile,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                   // BUGBUG: use FILE_FLAG_DELETE_ON_CLOSE when this is working OK
                               NULL);
            if (hFile != INVALID_HANDLE_VALUE)
                break;
            Sleep(50);
        }
        ThrowIfTrue(hFile == INVALID_HANDLE_VALUE);
        _RPT1(_CRT_WARN, "CreateFile: %d retries\n", tries);

        hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
        ThrowIfTrue(hMapping == INVALID_HANDLE_VALUE);

        pView = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
        TraceFunctLeave();
    }

    PVOID GetDataPtr()
    {
        _ASSERT(pView != NULL);
        return pView;
    }

    DWORD GetSize()
    {
        _ASSERT(hFile != NULL);
        return GetFileSize(hFile, NULL);
    }

private:
    HANDLE hFile;
    HANDLE hMapping;
    PVOID pView;
};

void DumpNodes(SimpleXMLNode* pNode, int indent = 4)
{
    for (vector< auto_ptr<SimpleXMLNode> >::const_iterator it = pNode->children.begin();it != pNode->children.end();it++)
    { 
	    _RPT3(_CRT_WARN, "%*s<%ls", indent, _T(""), (*it)->tag.c_str());
        for (SimpleXMLNode::attrs_t::const_iterator itattr = (*it)->attrs.begin();itattr != (*it)->attrs.end();itattr++)
		{
            _RPT2(_CRT_WARN, " %ls=\"%ls\"", (*itattr).first.c_str(), (*itattr).second.c_str());
        }
        _RPT0(_CRT_WARN, ">\n");

        DumpNodes((*it).get(), indent + 4);

        if (!(*it)->text.empty())
		{
            _RPT1(_CRT_WARN, "%ls", (*it)->text.c_str());
		}

        _RPT3(_CRT_WARN, "%*s</%ls>\n", indent, _T(""), (*it)->tag.c_str());
    }
}


void SimpleXMLDocument::ParseFile(LPCTSTR szFilename)
{
    TraceFunctEnter(_T("SimpleXMLDocument::ParseFile"));
    DebugTrace(TRACE_ID, _T("Processing: %s"), szFilename);

    _RPTF1(_CRT_WARN, "Processing %s\n", szFilename);

    CComPtr<IXMLParser> pParser;
    ThrowIfFail( pParser.CoCreateInstance(__uuidof(XMLParser)) );

    _ASSERT(_CrtCheckMemory());

    CComPtr<IXMLNodeFactory> pFactory;
    DataParser::CreateInstance(&pFactory);

    _ASSERT(_CrtCheckMemory());

    ThrowIfFail( pParser->SetFactory(pFactory) );

    ThrowIfFail( pParser->SetFlags(XMLFLAG_NOWHITESPACE) ) ;

    FileMapping mapping;
    mapping.Open(szFilename);

    ThrowIfFail( pParser->PushData((const char*) mapping.GetDataPtr(), mapping.GetSize(), TRUE) );

    ThrowIfFail( pParser->Run(-1) );

    pParser.Release();

    CComQIPtr<IDataParser> pFactoryPrivate(pFactory);
    
    // We get ownership of the parser's node -- we carefully pass it
    // along to m_pTopNode (not mixing auto_ptrs and real ptrs would
    // probably be the idiomatic way to do this).
    SimpleXMLNode* pTopNode;
    pFactoryPrivate->GetTopNode(&pTopNode);
    m_pTopNode = auto_ptr<SimpleXMLNode>(pTopNode);

    // DumpNodes(m_pTopNode.get());

    pFactory.Release();
    TraceFunctLeave();
}

#endif // SIMPLEXML_WANTPARSER

// This is ATL's stuff slightly modified to pass CP_UTF8 to WideCharToMultiByte

inline LPSTR WINAPI W2Helper(LPSTR lpa, LPCWSTR lpw, int nChars, UINT acp)
{
	ATLASSERT(lpw != NULL);
	ATLASSERT(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

#define W2UTF8(lpw) (\
	((_lpw = lpw) == NULL) ? NULL : (\
		_convert = (lstrlenW(_lpw)+1)*2,\
		W2Helper((LPSTR) alloca(_convert), _lpw, _convert, CP_UTF8)))

#define USES_UTF8_CONVERSION int _convert = 0; _convert; LPCWSTR _lpw = NULL; _lpw; LPCSTR _lpa = NULL; _lpa

void OutUTF8String(ostream& out, LPCWSTR wstr, int nChars)
{
    _ASSERT(wstr != NULL);

    int nBuf = (nChars + 1) * 3;    // UTF-8 can convert one WCHAR into 3 bytes
    char* buf;
    if (nBuf >= 1024)
        buf = (char*) HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, nBuf);
    else
        buf = (char*) alloca(nBuf);
    int nWritten = WideCharToMultiByte(CP_UTF8, 0, wstr, nChars, buf, nBuf, NULL, NULL);
    // REVIEW: WideCharToMultiByte is documented as writing a null terminator to buf,
    // but it doesn't seem to be doing it.
    buf[nWritten] = 0;
    out << buf;
    if (nBuf >= 1024)
        HeapFree(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, buf);
}

void OutXMLString(ostream& out, const wstring& str)
{
    wstring::size_type iRemainder = 0;
    wstring::size_type iSpecial = str.find_first_of(L"<>&'\"");
    
    while (iSpecial < str.size()) {
        if (iSpecial > iRemainder)
            OutUTF8String(out, str.c_str() + iRemainder, iSpecial - iRemainder);
        
        switch (str.at(iSpecial)) {
        case '<':   out << "&lt;";      break;
        case '>':   out << "&gt;";      break;
        case '&':   out << "&amp;";     break;
        case '\'':  out << "&apos;";    break;
        case '"':   out << "&quot;";    break;
        default:    _ASSERT(0);         break;
        }

        iRemainder = iSpecial + 1;
        iSpecial = str.find_first_of(L"<>&'\"", iRemainder);
    }

    if (iRemainder < str.size())
        OutUTF8String(out, str.c_str() + iRemainder, str.size() - iRemainder);
}

void SaveNodes(ostream& out, SimpleXMLNode* pNode)
{
    USES_UTF8_CONVERSION;

    for (vector< auto_ptr<SimpleXMLNode> >::const_iterator it = pNode->children.begin();
            it != pNode->children.end();
            it++) {
        out << '<';
        OutXMLString(out, (*it)->tag);

        for (SimpleXMLNode::attrs_t::const_iterator itattr = (*it)->attrs.begin();
                itattr != (*it)->attrs.end();
                itattr++) {
            out << ' ';
            OutXMLString(out, (*itattr).first);
            out << "=\"";
            OutXMLString(out, (*itattr).second);
            out << '"';
        }
        
        if ((*it)->children.empty() && (*it)->text.empty()) {
            out << " />";
        }
        else {
            out << ">";

            SaveNodes(out, (*it).get());

            if (!(*it)->text.empty())
                OutXMLString(out, (*it)->text);

            out << "</";
            OutXMLString(out, (*it)->tag);
            out << ">";
        }
    }
}

void SimpleXMLDocument::SaveFile(LPCTSTR szFilename) const
{
    USES_CONVERSION;

    ofstream out(T2CA(szFilename), ios::out | ios::trunc | ios::binary);
    if (!out.is_open())
        ThrowLastError();

    out << "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r\n";
    
    SaveNodes(out, m_pTopNode.get());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\dll\logging.cpp ===
/*
    Copyright 1999 Microsoft Corporation
    
    Logging for MessageBoxes and the comment button (aka the "lame" button).

    Walter Smith (wsmith)
    Rajesh Soy   (nsoy) - modified 05/05/2000
    Rajesh Soy   (nsoy) - reorganized code and cleaned it up, added comments 06/06/2000
 */

#ifdef THIS_FILE
#undef THIS_FILE
#endif

static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

#include "stdafx.h"

#define NOTRACE

#include "logging.h"
#include "simplexml.h"
#include "Base64.h"
#include <dbgtrace.h>


//
// Routines defined here
//
int LogLameButton(PLAMELOGDATA pData);
void GetISO8601DateTime(LPTSTR buf);
wstring Hexify(DWORD dwValue);
wstring Decimalify(DWORD dwValue);
wstring WDecimalify(WORD dwValue);
void AddTextSubnode(SimpleXMLNode* pParentElt, LPCWSTR pTag, LPCWSTR pText, SimpleXMLNode** ppNewElt);
void AddBase64Subnode(SimpleXMLNode* pParentElt, LPCWSTR pTag, DWORD cbData, const LPBYTE pbData, SimpleXMLNode** ppNewElt);
void LogMessageBox(PMSGBOXLOGDATA pData);


//
// LogLameButton: This is the routine that gets called from the Comments dialog to format
//                data into XML and upload to server
//
int LogLameButton(PLAMELOGDATA pData)
{
    TraceFunctEnter("LogLameButton");
    USES_CONVERSION;

    //
    // NTRAID#NTBUG9-154248-2000/08/08-jasonr
    // NTRAID#NTBUG9-152439-2000/08/08-jasonr
    //
    // We used to pop up the "Thank You" message box in the new thread.
    // Now we pop it up in the dialog box thread instead to fix these bugs.
    // The new thread now returns 0 to indicate success, 1 to indicate
    // failure.  We only pop up the dialog box on success.
    //
    int iRet = 1;

    SimpleXMLNode* pElt;

    try {
        // 
        // Create the Top-level XML document
        //
        DebugTrace(0, "Creating XMLDocument");

        SimpleXMLDocument doc;
        SimpleXMLNode* pDocTop = doc.GetTopNode();

        // 
        // Create the <dialogComment timestamp= scope= severity= class= machineId= build= ProductSuiteMask= ProductType=>...</dialogComment> node
        //
        SimpleXMLNode* pTopElt = pDocTop->AppendChild(wstring(L"dialogComment"));

        TCHAR szTimestamp[32];
        GetISO8601DateTime(szTimestamp);

        //
        // Set the 'formatVersion' attribute of the dialogComment node
        //
		DebugTrace(0, " formatVersion is 20000822");
        pTopElt->SetAttribute(wstring(L"formatVersion"), wstring(L"20000822"));

        //
        // Set the 'timestamp' attribute of the dialogComment node
        //
		DebugTrace(0, " szTimeStamp = %ls", szTimestamp);
        pTopElt->SetAttribute(wstring(L"timestamp"), wstring(T2W(szTimestamp)));

        //
        // Set the 'eventCategory' attribute of the dialogComment node
        //
		DebugTrace(0, " eventCategory is %d", pData->dwEventCategory);
        pTopElt->SetAttribute(wstring(L"eventCategory"), Decimalify(pData->dwEventCategory));
		
        //
        // Set the 'severity' attribute of the dialogComment node
        //
		DebugTrace(0, " severity is %d", pData->dwSeverity);
        pTopElt->SetAttribute(wstring(L"severity"), Decimalify(pData->dwSeverity));
		
        //
        // Set the 'emailAddress' attribute of the dialogComment node
        //
		DebugTrace(0, " emailAddress is %s", pData->szEmailAddress);
        pTopElt->SetAttribute(wstring(L"emailAddress"), wstring(T2CW(pData->szEmailAddress)));
		
        //
        // Set the 'betaId' attribute of the dialogComment node
        //
		DebugTrace(0, " betaId is %s", pData->szBetaID);
        pTopElt->SetAttribute(wstring(L"betaId"), wstring(T2CW(pData->szBetaID)));

        //
        // Set the 'class' attribute of the dialogComment node
        //
		DebugTrace(0, " Class is %ls", pData->szClass);
        pTopElt->SetAttribute(wstring(L"class"), wstring(T2CW(pData->szClass)));

        //
        // Set the 'machineId' attibute of the dialogComment node
        //
        GUIDSTR szSignature;
        GetMachineSignature(szSignature);
        pTopElt->SetAttribute(wstring(L"machineId"), wstring(T2CW(szSignature)));

        //
        // Set the 'build' attibute of the dialogComment node
        //
        pTopElt->SetAttribute(wstring(L"build"), Decimalify(pData->versionInfo.dwBuildNumber));

        //
        // Fix for DCR 128611
        //
        pTopElt->SetAttribute(wstring(L"acp"), Decimalify(GetACP()));
        pTopElt->SetAttribute(wstring(L"userLCID"), Decimalify(GetUserDefaultLCID()));
        pTopElt->SetAttribute(wstring(L"systemLCID"), Decimalify(GetSystemDefaultLCID()));

        //
        // Fix for DCR 128609
        //
        OSVERSIONINFOEX OsInfo;
        OsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        if(FALSE == GetVersionEx( (LPOSVERSIONINFO)&OsInfo))
        {
            FatalTrace(0, "GetVersionEx failed. Error: %ld", GetLastError());
        }
        else
        {
            DebugTrace(0, "ProductSuiteMask: %ld", OsInfo.wSuiteMask);
            pTopElt->SetAttribute(wstring(L"ProductSuiteMask"), WDecimalify(OsInfo.wSuiteMask));  

            DebugTrace(0, "ProductType: %ld",  OsInfo.wProductType);
            pTopElt->SetAttribute(wstring(L"ProductType"), WDecimalify(OsInfo.wProductType)); 
        }
       

        //
        // Add the <title>...</title> subnode to dialogComment
        //
		DebugTrace(0, " Title: %ls", pData->szTitle);
        AddTextSubnode(pTopElt, L"title", T2CW(pData->szTitle), NULL);

        // 
        // Add the <comment>...</comment> subnode to dialogComment
        //
        DebugTrace(0, "Adding Comment Tag");
        AddTextSubnode(pTopElt, L"comment", T2CW(pData->szComment), NULL);

        //
        // Add the <image>...</image> subnode to dialogComment
        //
        DebugTrace(0, "Adding image tag");
        if (pData->pbImage != NULL && pData->cbImage != 0)
        {
            //
            // The image node is added only if there is an image captured else not
            //
            AddBase64Subnode(pTopElt, L"image", pData->cbImage, pData->pbImage, NULL);
        }

        //  
        // Add the <msgboxtext>...</msgboxtext> subnode to dialogComment
        //
        DebugTrace(0, "Adding msgboxtext tag");
        if (0 != _tcslen(pData->szMsgBoxText))
        {
            //
            // MsgBoxText subnode is added only if it exists
            //
            AddTextSubnode(pTopElt, L"MsgBoxText", pData->szMsgBoxText, NULL);
        }

        //    
        // Add the <STACKTRACE>...</STACKTRACE> subnode to the dialogComment
        //
        DebugTrace(0, "Adding stacktrace");
        pElt = pTopElt->AppendChild(wstring(L""));
        GenerateXMLStackTrace(pData->pStackTrace, pElt);    // defined in stack.cpp

        //
        // Add the <minidump>...</minidump> subnote do the dialogComment.
        //

        DebugTrace(0, "Adding minidump");

        if (pData->szMiniDumpPath[0] != 0) {

            //
            // Open the file containing the minidump.
            //

            HANDLE hFile = INVALID_HANDLE_VALUE;

            if ((hFile = CreateFileW(pData->szMiniDumpPath, 
                                     GENERIC_READ, 
                                     0, 
                                     NULL, 
                                     OPEN_EXISTING, 
                                     FILE_ATTRIBUTE_NORMAL + FILE_FLAG_SEQUENTIAL_SCAN + FILE_FLAG_DELETE_ON_CLOSE,
                                     NULL)) == INVALID_HANDLE_VALUE) {

                DebugTrace(0, "CreateFile() failed on minidump file \"%s\"; GetLastError() returned %lu; minidump will not be included in XML",  pData->szMiniDumpPath, GetLastError());
                DeleteFile(pData->szMiniDumpPath);
                pData->szMiniDumpPath[0] = 0;
            }
            else {

                //
                // Get the size of the file.
                //

                LARGE_INTEGER i64FileSize;

                if (!GetFileSizeEx(hFile, &i64FileSize)) {
                    DebugTrace(0, "GetFileSizeEx() failed; GetLastError() returned %lu; minidump will not be included in XML", GetLastError());
                    pData->szMiniDumpPath[0] = 0;
                }
                else if (i64FileSize.QuadPart > 16777216) {
                    DebugTrace(0, "Minidump file is greater than 16MB in size and therefore will not be included in XML");
                    pData->szMiniDumpPath[0] = 0;
                }
                else {

                    //
                    // Allocate buffer big enough to hold the file.
                    //

                    LPBYTE pBuffer = NULL;

                    if ((pBuffer = (LPBYTE) HeapAlloc(GetProcessHeap(), 0, i64FileSize.LowPart)) == NULL) {
                        DebugTrace(0, "Could not allocate %lu bytes off the process heap; minidump will not be included in XML", i64FileSize.LowPart);
                        pData->szMiniDumpPath[0] = 0;
                    }
                    else {

                        //
                        // Read the file into memory.
                        //

                        DWORD dwBytesRead = 0;

                        if (!ReadFile(hFile, pBuffer, i64FileSize.QuadPart, &dwBytesRead, NULL)) {
                            DebugTrace(0, "ReadFile() failed; GetLastError() returned %lu; minidump will not be included in XML", GetLastError());
                            pData->szMiniDumpPath[0] = 0;
                        }
                        else if (dwBytesRead < i64FileSize.LowPart) {
                            DebugTrace(0, "ReadFile() did not read all of the file; minidump will not be included in XML");
                            pData->szMiniDumpPath[0] = 0;
                        }
                        else {

                            //
                            // Add the node to the XML.
                            //

                            AddBase64Subnode(pTopElt, L"minidump", i64FileSize.LowPart, pBuffer, NULL);
                        }

                        //
                        // Deallocate the buffer.
                        //

                        HeapFree(GetProcessHeap(), 0, pBuffer);
                    }
                }

                //
                // Close the file.
                //

                CloseHandle(hFile);
            }
        }
				
        //
        // Upload the XML blob hence formed
        //
        DebugTrace(0, "Calling QueueXMLDocumentUpload");
        iRet = QueueXMLDocumentUpload(UPLOAD_LAMEBUTTON, doc);         // defined in upload.cpp
    }
    catch (HRESULT hr) {
        FatalTrace(0, "LogLameButton: unexpected error %lX\n", hr);
    }
    catch (...) {
        FatalTrace(0, "LogLameButton: unexpected error");
    }

    return iRet;
}


// 
// GetISO8601DateTime:  Get the current date/time in ISO8601 format (e.g., "1988-04-07T18:39:09.287").
//                      'buf' must be at least 24*sizeof(TCHAR) bytes long.
//
void 
GetISO8601DateTime(
    LPTSTR buf      // [out] string with the ISO8601 formated datatime
)
{
    SYSTEMTIME st;
    GetSystemTime(&st);

    wsprintf(buf, _T("%d-%02d-%02dT%02d:%02d:%02d.%03d"),
             st.wYear, st.wMonth, st.wDay,
             st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
}


//
// Hexify: converts a DWORD to wstring in Hex representation
//
wstring 
Hexify(
    DWORD dwValue   // [in] - DWORD to be converted
)
{
    WCHAR buf[64];
    wsprintfW(buf, L"0x%lx", dwValue);
    return wstring(buf);
}


//
// Decimalify: converts a DWORD to wstring in Decimal representation
//
wstring 
Decimalify(
    DWORD dwValue   // [in] - DWORD to be converted
)
{
    WCHAR buf[64];
    wsprintfW(buf, L"%ld", dwValue);
    return wstring(buf);
}


//
// Decimalify: converts a WORD to wstring in Decimal representation
//
wstring 
WDecimalify(
    WORD wValue   // [in] - WORD to be converted
)
{
    WCHAR buf[64];
    wsprintfW(buf, L"%d", wValue);
    return wstring(buf);
}


//
// AddTextSubnode: Creates a XML subnode, given data contained in the subnode as a Text blob
//
void 
AddTextSubnode(
    SimpleXMLNode* pParentElt,  // [in] - parent XML node
    LPCWSTR pTag,               // [in] - name of the child tag
    LPCWSTR pText,              // [in] - data (as Text) contained in the child node
    SimpleXMLNode** ppNewElt    // [out] - child XML node
)
{
    _ASSERT(pParentElt != NULL);
    _ASSERT(pTag != NULL);
    _ASSERT(pText != NULL);

    SimpleXMLNode* pNewNode = pParentElt->AppendChild(wstring(pTag));
    pNewNode->text = wstring(pText);

    if (ppNewElt != NULL)
        *ppNewElt = pNewNode;
}


//
//  AddBase64Subnode: Creates a XML subnode, given data contained in the subnode as a binary blob
//
void AddBase64Subnode(
    SimpleXMLNode* pParentElt,  // [in] - parent XML node
    LPCWSTR pTag,               // [in] - name of the child tag
    DWORD cbData,               // [in] - size of data
    const LPBYTE pbData,        // [in] - data (as a binary blob) contained in the child node
    SimpleXMLNode** ppNewElt    // [out] - child XML node
)
{
    USES_CONVERSION;

    _ASSERT(pParentElt != NULL);
    _ASSERT(pTag != NULL);
    _ASSERT(pbData != NULL);

    Base64Coder coder;
    coder.Encode(pbData, cbData);

    LPWSTR pszData;

    if ((pszData = (LPWSTR) HeapAlloc(GetProcessHeap(), 0, (strlen(coder.EncodedMessage()) + 1) * sizeof(WCHAR))) != NULL) {
        if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, coder.EncodedMessage(), -1, pszData, strlen(coder.EncodedMessage()) + 1) != 0)
            AddTextSubnode(pParentElt, pTag, pszData, ppNewElt);

        HeapFree(GetProcessHeap(), 0, pszData);
    }
}


//
//  LogMessageBox: Routine to log calls into the messagebox hook. This is not supported anymore.
//                 and hence not maintained.
void LogMessageBox(PMSGBOXLOGDATA pData)
{
    TraceFunctEnter("LogMessageBox");
    _ASSERTE(pData->pStackTrace != NULL);
    _ASSERTE(pData->szCaption != NULL);
    _ASSERTE(pData->szOwnerClass != NULL);
    _ASSERTE(pData->szOwnerTitle != NULL);
    _ASSERTE(pData->szText != NULL);

    USES_CONVERSION;

    SimpleXMLNode* pElt;

    try {
        // Top-level document
        
        SimpleXMLDocument doc;
        SimpleXMLNode* pDocTop = doc.GetTopNode();

        // <messageBox style= helpId= ownerClass= ownerTitle= result= machineId= build= acp= userLCID= systemLCID=>...</messageBox>

        SimpleXMLNode* pTopElt = pDocTop->AppendChild(wstring(L"messageBox"));

        TCHAR szTimestamp[32];
        GetISO8601DateTime(szTimestamp);
        pTopElt->SetAttribute(wstring(L"timestamp"), wstring(T2W(szTimestamp)));

        pTopElt->SetAttribute(wstring(L"style"), Decimalify(pData->dwStyle));
        pTopElt->SetAttribute(wstring(L"helpId"), Decimalify(pData->dwContextHelpId));
        pTopElt->SetAttribute(wstring(L"ownerClass"), wstring(T2CW(pData->szOwnerClass)));
        pTopElt->SetAttribute(wstring(L"ownerTitle"), wstring(T2CW(pData->szOwnerTitle)));
        pTopElt->SetAttribute(wstring(L"result"), Decimalify(pData->dwResult));

        GUIDSTR szSignature;
        GetMachineSignature(szSignature);
        pTopElt->SetAttribute(wstring(L"machineId"), wstring(T2CW(szSignature)));

        pTopElt->SetAttribute(wstring(L"build"), Decimalify(pData->versionInfo.dwBuildNumber));

        // <caption> ... </caption>
		DebugTrace(0, " Caption is %ls", pData->szCaption);
        AddTextSubnode(pTopElt, L"caption", T2CW(pData->szCaption), NULL);

        // <text> ... </text>
        // Only capture the first 200 characters of the text, on the assumption
        // the rest is kind of boring to look at.
        TCHAR szText[200];
        lstrcpyn(szText, pData->szText, ARRAYSIZE(szText));
        AddTextSubnode(pTopElt, L"text", T2W(szText), NULL);

        //    <STACKTRACE>...</STACKTRACE>
        
		if (pData->pStackTrace != NULL) {
            pElt = pTopElt->AppendChild(wstring(L""));
            GenerateXMLStackTrace(pData->pStackTrace, pElt);
		
        }
		

        QueueXMLDocumentUpload(UPLOAD_LAMEBUTTON, doc);
    }
    catch (HRESULT hr) {
        _RPTF1(_CRT_ERROR, "LogLameButton: unexpected error %lX\n", hr);
    }
    catch (...) {
        _RPTF0(_CRT_ERROR, "LogLameButton: unexpected error");
    }

    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\dll\stack.cpp ===
/*
    Copyright 1999 Microsoft Corporation
    
    Simplified PCHealth stack trace output

    Walter Smith (wsmith)
    Rajesh Soy   (nsoy) - modified 4/27/2000
    Rajesh Soy   (nsoy) - reorganized code and cleaned it up, added comments 06/06/2000
 */

#ifdef THIS_FILE
#undef THIS_FILE
#endif

static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

#include "stdafx.h"

#define NOTRACE

#include "logging.h"
#include <imagehlp.h>
#include <dbgtrace.h>

using namespace std;

// Forward declarations

struct MODINFO;

//
// This code is largely stolen from PC Health's fault handler.
// At some point we should probably refactor that and share the code.
// However, this code has been redone to handle exceptions properly and
// eliminate useless stuff.
//
struct MODINFO {
    TCHAR       szFilename[MAX_PATH];
    TCHAR       szFileDesc[MAX_PATH];
    TCHAR       szVersion[MAX_PATH];
    TCHAR       szCreationDate[MAX_PATH];
    TCHAR       szMfr[MAX_PATH];
    DWORD       dwFilesize;
    DWORD       dwCheckSum;
    DWORD       dwPDBSignature;
    DWORD       dwPDBAge;
    TCHAR       szPDBFile[MAX_PATH];
    UINT_PTR    BaseAddress;
};
typedef MODINFO* PMODINFO;

struct MPC_STACKFRAME {
    const MODINFO*  pModule;
    DWORD           dwSection;
    UINT_PTR        Offset;
};
typedef MPC_STACKFRAME* PMPC_STACKFRAME;

//
// PDB debug directory structures
//
typedef struct NB10I                   // NB10 debug info
{
    DWORD   nb10;                      // NB10
    DWORD   off;                       // offset, always 0
    DWORD   sig;
    DWORD   age;
} NB10I;

typedef struct cvinfo
{
	NB10I nb10;
	char rgb[0x200 - sizeof(NB10I)];
} CVINFO;


typedef map<UINT_PTR,MODINFO> MODINFOMap;




//
// Routines defined here
//
void GetFileInfo( LPTSTR szFile, LPTSTR szWhat, LPTSTR szValue);
void GetFileDateAndSize(MODINFO* pModule);
BOOL DebugDirectoryIsUseful(LPVOID Pointer, ULONG Size);
void GetPDBDebugInfo(MODINFO* pModule);
bool GetLogicalAddress(PVOID addr, DWORD* pdwSection, UINT_PTR* pOffset, UINT_PTR* pbaseAddr);
void AddDLLSubnode(SimpleXMLNode* pParentElt, LPCWSTR pTag, const MODINFO* pInfo);
void AddFunctionSubnode(SimpleXMLNode* pParentElt, MPC_STACKFRAME* pFrame);
void GenerateXMLStackTrace(PSTACKTRACEDATA pstd, SimpleXMLNode* pTopElt);


//
// ModuleCache class: Class to extrace information from binaries
//

class ModuleCache {
public:
    ModuleCache() { }
    ~ModuleCache() { }

    const MODINFO*      GetModuleInfo(UINT_PTR baseAddr);
    const MODINFO*      GetEXEInfo();
    void                AddDLLInfoSubnode(SimpleXMLNode* pParentElt);

private:
    MODINFOMap mimap;
};


//
// ModuleCache::GetModuleInfo: Extracts the following information given a base address
//        ModuleName,  CompanyName,  FileVersion, FileDescription, FileDateAndSize and PDBDebugInfo
//
const MODINFO*    
ModuleCache::GetModuleInfo(
    UINT_PTR baseAddr       // [in] - baseAddress of binary
)
{
    TraceFunctEnter("ModuleCache::GetModuleInfo");

    //
    // Locate the base address in modinfo map if present
    //
    MODINFOMap::const_iterator it = mimap.find(baseAddr);
    DWORD   dwRetVal = 0;

    if (it == mimap.end()) 
    {
        MODINFO mi;
        TCHAR   szModName[ MAX_PATH ];

        mi.BaseAddress = baseAddr;
        mi.dwCheckSum = 0;

        //
        // Obtain the ModuleFileName
        //
        DebugTrace(0, "Calling GetModuleFileName");
        dwRetVal = GetModuleFileName((HMODULE) baseAddr, szModName, MAX_PATH ) ;
        if(0 == dwRetVal)
        {
            FatalTrace(0, "GetModuleFileName failed. Error: %ld", GetLastError());
            ThrowIfZero( dwRetVal );
        }

        ZeroMemory( mi.szFilename, MAX_PATH );

        //
        // Parse the Module name. GetModuleFileName returns filepaths of the form \??\filepath
        // if the user is not logged on.  
        //
        if(( szModName[0] == '\\')&&( szModName[1] == '?') && ( szModName[2] == '?') && ( szModName[3] == '\\'))
        {
            DebugTrace(0, "Stripping the funny characters from infront of the module name");
            _tcscpy( mi.szFilename, &szModName[4]);
        }
        else
        {
            DebugTrace(0, "Normal module name");
            _tcscpy( mi.szFilename, szModName);
        }

        DebugTrace(0, "ModuleName: %ls", mi.szFilename);

        //
        // Obtain the CompanyName
        //
        DebugTrace(0, "Obtaining CompanyName");
        GetFileInfo(mi.szFilename, TEXT("CompanyName"), mi.szMfr);

        //
        // Obtain FileVersion
        //
        DebugTrace(0, "Obtaining FileVersion");
        GetFileInfo(mi.szFilename, TEXT("FileVersion"), mi.szVersion);

        //
        // Obtain FileDescription
        //
        DebugTrace(0, "Obtaining FileDescription");
        GetFileInfo(mi.szFilename, TEXT("FileDescription"), mi.szFileDesc);

        //
        // Obtain FileDateAndSize
        //
        DebugTrace(0, "Calling GetFileDateAndSize");
        GetFileDateAndSize(&mi);

        //
        // Obtain PDBDebugInfo
        //
        DebugTrace(0, "Calling GetPDBDebugInfo");
        GetPDBDebugInfo(&mi);

        //
        // Insert MODINFO into the ModInfo map
        //
        DebugTrace(0, "Calling mimap.insert");
        it = mimap.insert(MODINFOMap::value_type(baseAddr, mi)).first;
    }
    
    TraceFunctLeave();
    return &(*it).second;
}

//
// ModuleCache::GetEXEInfo: Obtain information on binaries that are Exes
//
const MODINFO*    
ModuleCache::GetEXEInfo()
{
    return GetModuleInfo((UINT_PTR) GetModuleHandle(NULL));
}


//
// ModuleCache::AddDLLInfoSubnode: adds the information contained in the MODInfo Map
//              into a DLLINFO XML subnode
void 
ModuleCache::AddDLLInfoSubnode(
    SimpleXMLNode* pParentElt   // [in] - parent XML node
)
{
    _ASSERT(pParentElt != NULL);

    //
    // Create a DLLINFO subnode
    //
    SimpleXMLNode* pTopElt = pParentElt->AppendChild(wstring(L"DLLINFO"));

    //
    // Add DLL subnodes under DLLINFO node for each item contained in the MODInfo Map
    //
    for (MODINFOMap::const_iterator it = mimap.begin(); it != mimap.end(); it++) 
    {
        AddDLLSubnode(pTopElt, L"DLL", &(*it).second);
    }
}


//
// 
// GetFileInfo: This routine uses Version.Dll API to get requested file info
//              info is returned as a string in szValue
//
void 
GetFileInfo(
        LPTSTR szFile,              // [in] file to get info for
        LPTSTR szWhat,              // [in] may specify "FileVersion",
                                    //     "CompanyName" or "FileDescription"
        LPTSTR szValue              // [out] file info obtained
        )
{
    DWORD   dwSize;
    DWORD   dwScratch;
    DWORD*  pdwLang = NULL;
    DWORD   dwLang;
    TCHAR   szLang[MAX_PATH] = TEXT("");
    TCHAR   szLocalValue[MAX_PATH] = TEXT("");
    LPTSTR  szLocal;

    lstrcpy(szValue, TEXT(""));

    _ASSERT(szFile != NULL);
    _ASSERT(szWhat != NULL);
    _ASSERT(szValue != NULL);

    //
    // get fileinfo data size
    //
    dwSize = GetFileVersionInfoSize(szFile, &dwScratch);
    if (dwSize == 0)
        return;

    auto_ptr<BYTE> pFileInfo(new BYTE[dwSize]);

    //
    // get fileinfo data
    //
    ThrowIfZero(GetFileVersionInfo(szFile, 0, dwSize, (PVOID) pFileInfo.get()));

    //
    // set default language to english
    //
    dwLang = 0x040904E4;
    pdwLang = &dwLang;

    //
    // read language identifier and code page of file
    //
    if (VerQueryValue(pFileInfo.get(),
                      TEXT("\\VarFileInfo\\Translation"),
                      (PVOID *) &pdwLang,
                      (UINT *) &dwScratch)) 
    {
        //
        // prepare query string - specify what we need ("FileVersion", 
        // "CompanyName" or "FileDescription")
        //
        _stprintf(szLang, 
                 TEXT("\\StringFileInfo\\%04X%04X\\%s"),
                 LOWORD(*pdwLang),
                 HIWORD(*pdwLang), 
                 szWhat);

        szLocal = szLocalValue;

        //
        // query for the value using codepage from file
        //
        if (VerQueryValue(pFileInfo.get(), 
                          szLang, 
                          (PVOID *) &szLocal, 
                          (UINT *) &dwScratch))
        {
            lstrcpy(szValue,szLocal);
            return;
        }
    }

    //
    // if that fails, try Unicode 
    //
    _stprintf(szLang,
              TEXT("\\StringFileInfo\\%04X04B0\\%s"),
              GetUserDefaultLangID(),
              szWhat);
    if (!VerQueryValue(pFileInfo.get(), 
                       szLang, 
                       (PVOID *) &szLocal, 
                       (UINT *) &dwScratch))
    {
        //
        // if that fails too, try Multilingual
        //
        _stprintf(szLang,
                  TEXT("\\StringFileInfo\\%04X04E4\\%s"),
                  GetUserDefaultLangID(),
                  szWhat);
        if (!VerQueryValue(pFileInfo.get(), 
                           szLang,
                           (PVOID *) &szLocal, 
                           (UINT *) &dwScratch))
        {
            //
            // and if that fails as well, try nullPage
            //
            _stprintf(szLang,
                      TEXT("\\StringFileInfo\\%04X0000\\%s"),
                      GetUserDefaultLangID(),
                      szWhat);
            if (!VerQueryValue(pFileInfo.get(), 
                               szLang,
                               (PVOID *) &szLocal, 
                               (UINT *) &dwScratch))
            {
                // giving up
                szValue[0] = 0;
                return;
            }
        }
    }

    //
    // successful; copy to return string
    //
    lstrcpy(szValue,szLocal);
}


//
// GetFileDateAndSize: get file creation date and size
//
void 
GetFileDateAndSize(
        MODINFO* pModule            // [in] [out] pointer to module node
                                    // fills file date and size fields
        )
{
    TraceFunctEnter("GetFileDateAndSize");
    _ASSERT(pModule != NULL);

    SYSTEMTIME          STCreationTime;
    WIN32_FIND_DATA     FindData;

    lstrcpy(pModule->szCreationDate,TEXT(""));
    pModule->dwFilesize = 0;

    HANDLE hFind = FindFirstFile(pModule->szFilename,&FindData);
    if(INVALID_HANDLE_VALUE == hFind)
    {
        FatalTrace(0, "FindFirstFile on %ls failed. Error: %ld", pModule->szFilename, GetLastError());
        ThrowIfTrue(hFind == INVALID_HANDLE_VALUE);
    }

    // NO THROWS -- hFind will leak

    _ASSERT(FindData.ftCreationTime.dwLowDateTime || 
            FindData.ftCreationTime.dwHighDateTime);

    FileTimeToSystemTime(&(FindData.ftCreationTime),&STCreationTime);

    _stprintf(pModule->szCreationDate, _T("%d-%02d-%02dT%02d:%02d:%02d.%03d"),
             STCreationTime.wYear, STCreationTime.wMonth, STCreationTime.wDay,
             STCreationTime.wHour, STCreationTime.wMinute, STCreationTime.wSecond,
             STCreationTime.wMilliseconds);

    pModule->dwFilesize = (FindData.nFileSizeHigh * MAXDWORD) + FindData.nFileSizeLow;

    FindClose(hFind);
    TraceFunctLeave();
}


//
// DebugDirectoryIsUseful: Check if this is an userful debug directory
//
BOOL DebugDirectoryIsUseful(LPVOID Pointer, ULONG Size) 
{
    return (Pointer != NULL) &&                          
        (Size >= sizeof(IMAGE_DEBUG_DIRECTORY)) &&    
        ((Size % sizeof(IMAGE_DEBUG_DIRECTORY)) == 0);
}


//
//  GetPDBDebugInfo: Looks up the Debug Directory to get PDB Debug Info
//
void 
GetPDBDebugInfo(
    MODINFO* pModule            // [in] [out] pointer to module node
                                // fills PDB Signature, Age and Filename
)
{
    TraceFunctEnter("GetPDBDebugInfo");
    _ASSERT(pModule != NULL);
    
    HANDLE hMapping = NULL;
    PIMAGE_NT_HEADERS pntHeaders = NULL;
    void* pvImageBase = NULL;

    //
    // Open the Binary for reading
    //
    HANDLE hFile = CreateFile(pModule->szFilename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL);
    if (INVALID_HANDLE_VALUE != hFile ) 
    {
        //
        // Create a FileMapping 
        //
        hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
        if (NULL != hMapping) 
        {
            //
            // Map view to Memory
            //
            pvImageBase = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
            if (NULL != pvImageBase) 
            {
                __try 
                {
                    //
                    // Obtain the NtImage Headers
                    //
                    pntHeaders = ImageNtHeader(pvImageBase);

                    if(NULL == pntHeaders)
                    {
                        goto done;
                    }

                    if (pntHeaders->OptionalHeader.MajorLinkerVersion >= 3 ||
                            pntHeaders->OptionalHeader.MinorLinkerVersion >= 5)
                    {
                        //
                        // Find the debug directory entries
                        //
                        ULONG cbDebugDirectories;
                        PIMAGE_DEBUG_DIRECTORY pDebugDirectories = (PIMAGE_DEBUG_DIRECTORY)
                            ImageDirectoryEntryToData(pvImageBase, FALSE, IMAGE_DIRECTORY_ENTRY_DEBUG, &cbDebugDirectories);
                        
                        if (DebugDirectoryIsUseful(pDebugDirectories, cbDebugDirectories))
                        {
                            //
                            // Find the codeview information
                            //
                            ULONG cDebugDirectories = cbDebugDirectories / sizeof(IMAGE_DEBUG_DIRECTORY);
				            ULONG iDirectory;
                            for (iDirectory=0; iDirectory<cDebugDirectories; iDirectory++)
                            {
                                PIMAGE_DEBUG_DIRECTORY pDir = &pDebugDirectories[iDirectory];
                                if (pDir->Type == IMAGE_DEBUG_TYPE_CODEVIEW)
                                {
                                    LPVOID pv = (PCHAR)pvImageBase + pDir->PointerToRawData;
                                    ULONG  cb = pDir->SizeOfData;
                                    // 
                                    // Is it the NAME of a .PDB file rather than CV info itself?
                                    //
                                    NB10I* pnb10 = (NB10I*)pv;

                                    pModule->dwPDBSignature = pnb10->sig;
                                    pModule->dwPDBAge = pnb10->age;

                                    if (pnb10->nb10 == '01BN') 
                                    {
                                        //
                                        // Got a PDB name, which immediately follows the NB10I; we take everything.
                                        //
                                        mbstowcs(pModule->szPDBFile, (char *)(pnb10+1), MAX_PATH);
                                    }
                                    else
                                    {
                                        //
                                        // Got the PDB Signature and Age
                                        // This information is used by the backend to 
                                        // locate the PDB symbol file for this binary
                                        // to resolve symbols
                                        // 
                                        pModule->dwPDBSignature = pnb10->sig;
                                        pModule->dwPDBAge = pnb10->age;
                                    }
                                }
                            }
                        }
                    }

                }
                __except(EXCEPTION_EXECUTE_HANDLER) 
                {
                    FatalTrace(0, "Unable to extract PDB information from binary");
                }    
            }
        }
    }

done:

    if(NULL != pvImageBase)
    {
        UnmapViewOfFile(pvImageBase);
        pvImageBase = NULL;
    }

    if(NULL != hMapping)
    {
        CloseHandle(hMapping);
        hMapping = NULL;
    }

    if(NULL != hFile)
    {
        CloseHandle(hFile);
        hFile = NULL;
    }

    TraceFunctLeave();
}


//
// GetLogicalAddress: converts virtual address to section and offset by searching module's section table
//
bool 
GetLogicalAddress(
        PVOID        addr,        // [in] address to be resolved
        DWORD*       pdwSection,  // [out] section number 
        UINT_PTR*    pOffset,     // [out] offset in section
        UINT_PTR*    pbaseAddr    // [out] base address of module
        )
{
    MEMORY_BASIC_INFORMATION    mbi;
    UINT_PTR                    baseAddr;        // local base address of module
    IMAGE_DOS_HEADER*           pDosHdr;         // PE File Headers
    IMAGE_NT_HEADERS*           pNTHdr;
    IMAGE_SECTION_HEADER*       pSectionHdr;
    UINT_PTR                    rva;             // relative virtual address of "addr"
    UINT_PTR                    sectionStart;
    UINT_PTR                    sectionEnd;
    UINT                        i;
    DWORD                       dwDump;
    DWORD                       dwRW;
	DWORD                       dwRetVQ;
    bool                        fFound = false;
    static DWORD                s_dwSystemPageSize = 0;

    TraceFunctEnter("GetLogicalAddress");

    if (s_dwSystemPageSize == 0) {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_dwSystemPageSize = si.dwPageSize;
    }

    *pdwSection = 0;
    *pOffset = 0;
    *pbaseAddr = 0;

    //
    // addr should not be NULL
    //
    if(NULL == addr)
    {
        FatalTrace(0, "addr is NULL");
        goto done;
    }

    //
    // get page info for page containing "addr"
    //
    DebugTrace(0, "Calling VirtualQuery");
	dwRetVQ = VirtualQuery(addr, &mbi, sizeof(mbi));
    if(0 == dwRetVQ)
    {
        FatalTrace(0, "dwRetVQ is 0. Error: %ld", GetLastError());
        ThrowIfZero(dwRetVQ);
    }
    
    //
    // Just in case this goes wild on us...
    //
    __try {
        baseAddr = (UINT_PTR) mbi.AllocationBase;

        //
        // get relative virtual address corresponding to addr
        //
        rva = (UINT_PTR) addr - baseAddr;

        //
        // read Dos header of PE file
        //
        pDosHdr = (IMAGE_DOS_HEADER*) baseAddr;

        //
        // read NT header of PE file
        //
        pNTHdr = (IMAGE_NT_HEADERS*) (baseAddr + pDosHdr->e_lfanew);

        //
        // get section header address
        //
        pSectionHdr = (IMAGE_SECTION_HEADER*) ((UINT_PTR) IMAGE_FIRST_SECTION(pNTHdr) -
                                               (UINT_PTR) pNTHdr + 
                                               baseAddr + pDosHdr->e_lfanew);

        //
        // step through section table to get to the section containing rva
        //
        DebugTrace(0, "stepping through section table...");
        for (i=0; i< pNTHdr->FileHeader.NumberOfSections; i++)
        {
            //
            // get section boundaries
            //
            sectionStart = pSectionHdr->VirtualAddress;
            sectionEnd = sectionStart +
                         max(pSectionHdr->SizeOfRawData, pSectionHdr->Misc.VirtualSize);

            //
            // check if section envelopes rva
            //
            if ((rva >= sectionStart) && (rva <= sectionEnd))
            {
                *pdwSection = i+1;
                *pOffset = rva-sectionStart;
                *pbaseAddr = baseAddr;
                fFound = true;
                break;
            }

            //
            // move pointer to next section
            //
            pSectionHdr = pSectionHdr + sizeof(IMAGE_SECTION_HEADER); 
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        _ASSERT(0);
        *pbaseAddr = NULL;
    }

    if (!fFound)
        _ASSERT(0);

done:
    TraceFunctLeave();
    return fFound;
}


//
// AddDLLSubnode: Inserts a DLL subnode to the given parent XML node
//
void 
AddDLLSubnode(
    SimpleXMLNode* pParentElt,  // [in] - parent XML node
    LPCWSTR pTag,               // [in] - name of subnode tag
    const MODINFO* pInfo        // [in] - Module Information
)
{
    USES_CONVERSION;

    TraceFunctEnter("AddDLLSubnode");

    _ASSERT(pParentElt != NULL);
    _ASSERT(pTag != NULL);
    _ASSERT(pInfo != NULL);

    if(NULL == pInfo)
    {
        FatalTrace(0, "pInfo is NULL");
        throw E_FAIL;
    }

    //
    // Create the XML subnode
    //
    SimpleXMLNode* pNode = pParentElt->AppendChild(wstring(pTag));

    //
    // Set the various attributes of the DLL subnode
    //
    pNode->SetAttribute(wstring(L"FILENAME"), wstring(T2CW(pInfo->szFilename)));
    pNode->SetAttribute(wstring(L"VERSION"), wstring(T2CW(pInfo->szVersion)));
    pNode->SetAttribute(wstring(L"CREATIONDATE"), wstring(T2CW(pInfo->szCreationDate)));
    pNode->SetAttribute(wstring(L"CHECKSUM"), Hexify(pInfo->dwCheckSum));
    pNode->SetAttribute(wstring(L"PDBSIGNATURE"), Hexify(pInfo->dwPDBSignature));
    pNode->SetAttribute(wstring(L"PDBAGE"), Hexify(pInfo->dwPDBAge));
    pNode->SetAttribute(wstring(L"PDBFILE"), wstring(T2CW(pInfo->szPDBFile)));
    pNode->SetAttribute(wstring(L"FILESIZE"), Hexify(pInfo->dwFilesize));
    pNode->SetAttribute(wstring(L"BASEADDRESS"), Hexify(pInfo->BaseAddress));
    pNode->SetAttribute(wstring(L"MANUFACTURER"), wstring(T2CW(pInfo->szMfr)));
    pNode->SetAttribute(wstring(L"DESCRIPTION"), wstring(T2CW(pInfo->szFileDesc)));

    TraceFunctLeave();
}


//
// AddFunctionSubnode: Adds a FUNCTION subnode to the given XML node
//
void 
AddFunctionSubnode(
    SimpleXMLNode* pParentElt,  // [in] - parent XML node
    MPC_STACKFRAME* pFrame      // [in] - Stack Frame
)
{
    USES_CONVERSION;

    _ASSERT(pParentElt != NULL);
    _ASSERT(pFrame != NULL);
    
    //
    // Create the FUNCTION subnode
    //
    SimpleXMLNode* pNode = pParentElt->AppendChild(wstring(L"FUNCTION"));

    //
    // Add the Attributes of the FUNCTION subnode
    //
    pNode->SetAttribute(wstring(L"FILENAME"), wstring(T2CW(pFrame->pModule->szFilename)));
    pNode->SetAttribute(wstring(L"SECTION"), Decimalify(pFrame->dwSection));
    pNode->SetAttribute(wstring(L"OFFSET"), Decimalify(pFrame->Offset));
}


//
// GenerateXMLStackTrace: Generate a stack trace in PCHealth-standard XML format
//
void 
GenerateXMLStackTrace(
    PSTACKTRACEDATA pstd,   // [in] - pointer to call stack
    SimpleXMLNode* pTopElt  // [in] - pointer to STACKTRACE XML node
)
{
    TraceFunctEnter("GenerateXMLStackTrace");
    _ASSERT(pTopElt != NULL);

    ModuleCache modCache;

    //
    // Set the Tag Name
    //
    pTopElt->tag = wstring(L"STACKTRACE");

    //
    // Obtain the Info on the binary being commented
    //  
    DebugTrace(0, "Calling modCache.GetEXEInfo");
    const MODINFO* pExeInfo = modCache.GetEXEInfo();

    //
    // Add the info collected as a EXEINFO subnode under STACKTRACE
    //
    DebugTrace(0, "Calling AddDLLSubnode");
    AddDLLSubnode(pTopElt, L"EXEINFO", pExeInfo);

    //
    // Create a CALLSTACK subnode under STACKTRACE, but only if pstd is not NULL
    //

    if (pstd != NULL) {
        DebugTrace(0, "Adding CALLSTACK element");
        SimpleXMLNode* pCallStackElt = pTopElt->AppendChild(wstring(L"CALLSTACK"));

	    ULONG_PTR  stackBase;
	    stackBase = (ULONG_PTR)pstd;
	    DWORD   dwValue;
	    ULONG   ulFrames;
	    ulFrames = pstd->nCallers;

	    bool fProceed = 1;
	    PVOID caller;
	    int iFrame = 0;

        //
        // Step through the call stack
        //
	    caller = (int *)pstd->callers;
        while(caller != 0)
	    {
		    MPC_STACKFRAME frame;
		    UINT_PTR modBase;

            //
            // Obtain the Logical Address for each caller
            //
            DebugTrace(0, "GetLogicalAddress");
		    if (GetLogicalAddress(caller, &frame.dwSection, &frame.Offset, &modBase))
		    {
                // 
                // Get Module Information for this caller
                //
			    frame.pModule = modCache.GetModuleInfo(modBase);

                //
                // Add the ModuleInformation obtained as a FUNCTION subnode under the CALLSTACK node
                //
                DebugTrace(0, "Calling AddFunctionSubnode");
			    AddFunctionSubnode(pCallStackElt, &frame);
		    }

            DebugTrace(0, "iFrame: %ld", iFrame);
            caller = pstd->callers[iFrame];
		    iFrame++;
	    }

        //
        // Now, add the DLLINFO subnode. This must happen after all the GetModuleInfo calls so the cache
        // is populated with all the necessary info.
        //
        DebugTrace(0, "Calling AddDLLInfoSubnode");
        modCache.AddDLLInfoSubnode(pTopElt);
    }

    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\dll\stdafx.h ===
/*
    Copyright 1999 Microsoft Corporation
    
    Precompiled header file

    Walter Smith (wsmith)
 */

#pragma once

#include <windows.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlwin.h>
#include <map>
#include <vector>
#include <string>
#include <fstream>
#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\dll\upload.cpp ===
/*
    Copyright 1999 Microsoft Corporation
    
    Upload to the EMI database server

    Walter Smith (wsmith)
    Rajesh Soy   (nsoy) - reorganized code and cleaned it up, added comments 06/06/2000
 */

#ifdef THIS_FILE
#undef THIS_FILE
#endif

static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

#include "stdafx.h"

#define NOTRACE

#include "uploadmanager.h"
#include "logging.h"
#include <dbgtrace.h>
#include "UploadmanagerDID.h"
#include "resource.h"

//
// Externs
//
extern CComModule _Module;

//
// PC Health registry stuff
//
const TCHAR szREGKEY_MACHINEINFO[] = _T("Software\\Microsoft\\PCHealth\\MachineInfo");
const TCHAR szREGVALUE_GUID_NONESC[] = _T("CommentPID");

//
// LAMEBTN.DLL registry stuff
//
const TCHAR szREGKEY_ERROR_MESSAGES[] = _T("Software\\Microsoft\\PCHealth\\Clients\\Error Messages");
const TCHAR szREGKEY_DIALOG_COMMENTS[] = _T("Software\\Microsoft\\PCHealth\\Clients\\Dialog Comments");
const TCHAR szREGVALUE_UPLOAD_SERVER[] = _T("Upload URL");
const TCHAR szREGVALUE_UPLOAD_PROVIDER[] = _T("Upload provider");

//
// Routines Defined here:
//
void GetRegValue(HKEY hkRoot, LPCTSTR szKeyName, LPCTSTR szValueName, LPTSTR szValue, DWORD* pcbValue);
LPCTSTR GetUploadRegKey(ENUM_UPLOAD_TYPES type);
void GetMachineSignature(GUIDSTR szGUID);
inline HRESULT ChangeSecurity(IUnknown * pUnknown);
int QueueXMLDocumentUpload(ENUM_UPLOAD_TYPES type, SimpleXMLDocument& doc);


//
// GetRegValue: Get value of required registry entry (throw if not found).
//              IN *pcbValue is the size in bytes of szValue
//              OUT *pchValue is the size of the retrieved data
//
void 
GetRegValue(
    HKEY hkRoot, 
    LPCTSTR szKeyName, 
    LPCTSTR szValueName, 
    LPTSTR szValue, 
    DWORD* pcbValue
)
{
    CRegKey rk;
    ThrowIfW32Fail( rk.Open(hkRoot, szKeyName, KEY_READ) );
    ThrowIfW32Fail( rk.QueryValue(szValue, szValueName, pcbValue) );
    rk.Close();
}


//
// GetUploadRegKey: Returns the correct registy key location
//
LPCTSTR 
GetUploadRegKey(
    ENUM_UPLOAD_TYPES type
)
{
    if (type == UPLOAD_MESSAGEBOX)
    {
        return szREGKEY_ERROR_MESSAGES;
    }
    else if (type == UPLOAD_LAMEBUTTON)
    {
        return szREGKEY_DIALOG_COMMENTS;
    }

    // WTF?!
    _ASSERT(false);
    throw E_FAIL;
    return NULL;    // the compiler
}


//
//  GetMachineSignature: Obtains the Machine signature. This however, is currently
//      not being used at the backend
//
void 
GetMachineSignature(
    GUIDSTR szGUID  // [out] - Machine GUID
)
{
    TraceFunctEnter("GetMachineSignature");
    CRegKey rk;
    DWORD dwSize = 0;

    //
    // Try to read the Machine GUID from registry
    //
    if (rk.Open(HKEY_LOCAL_MACHINE, szREGKEY_MACHINEINFO, KEY_READ) == ERROR_SUCCESS) 
    {
        dwSize = sizeof(GUIDSTR);
        if (rk.QueryValue(szGUID, szREGVALUE_GUID_NONESC, &dwSize) == ERROR_SUCCESS) 
        {
            rk.Close();
            return;
        }
    }

    rk.Close();

     
    //
    // If PCHealth's GUID is gone for some reason, We generate a GUID
    //
    DebugTrace(0, "Generating a new GUID");
    lstrcpy(szGUID, _T("{00000000-0000-0000-0000-000000000000}"));
    GUID guid;
	HRESULT hr;
	LPOLESTR lpolestr_guid;

	hr = CoCreateGuid(&guid);
	if (FAILED(hr))
    {
        FatalTrace(0, "CoCreateGuid failed. Error: %ld", hr);
        goto done;
    }

	hr = StringFromIID(guid, &lpolestr_guid);
	if (FAILED(hr))
    {
        FatalTrace(0, "StringFromIID failed. Error: %ld", hr);
        goto done;
    }

	lstrcpy(szGUID, lpolestr_guid);
    CoTaskMemFree(lpolestr_guid);

    //
    // We update the generated GUID in the registry
    //
    DebugTrace(0, "Creating %s", szREGKEY_MACHINEINFO);
    if (rk.Create(HKEY_LOCAL_MACHINE, szREGKEY_MACHINEINFO ) == ERROR_SUCCESS) 
    {
        if(rk.SetValue(szGUID, szREGVALUE_GUID_NONESC) != ERROR_SUCCESS)
        {
            FatalTrace(0, "Failed to set MachineID in registry. Error: %ld", GetLastError());
        }
    }

done:

    rk.Close();
    DebugTrace(0, "szGUID: %ls", szGUID);
    TraceFunctLeave();
    return;
}


//-----------------------------------------------------------------------------
// It's necessary to modify the security settings on a new MPCUpload interface.
//-----------------------------------------------------------------------------
inline HRESULT ChangeSecurity(IUnknown * pUnknown)
{
    TraceFunctEnter("ChangeSecurity");
	IClientSecurity * pCliSec = NULL;

    //
    // Query the IClientSecurity interface
    //
	HRESULT hr = pUnknown->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
	if (FAILED(hr))
    {
        FatalTrace(0, "pUnknown->QueryInterface failed. hr: %ld", hr);
		goto done;
    }

    DebugTrace(0, "Calling pCliSec->SetBlanket");
     
    //
    // Set the correct Security blanket
    //
    hr = pCliSec->SetBlanket(pUnknown, 
                            RPC_C_AUTHN_WINNT, 
                            RPC_C_AUTHZ_NONE, 
                            NULL, 
                            RPC_C_AUTHN_LEVEL_CONNECT, 
                            RPC_C_IMP_LEVEL_IMPERSONATE, 
                            NULL, 
                            EOAC_DEFAULT);
	pCliSec->Release();

done:
    TraceFunctLeave();
	return hr;
}


//
//  QueueXMLDocumentUpload: This routine schedules the XML blob passed to it for upload to Upload Manager
//
int 
QueueXMLDocumentUpload(
    ENUM_UPLOAD_TYPES type,     // [in] - upload type
    SimpleXMLDocument& doc      // [in] - XML blob to be uploaded
)
{
    TCHAR szTemp[1024];
    DWORD dwTemp;
    UL_STATUS status;
    long errCode;
    LPCTSTR szRegKey;

    TraceFunctEnter("QueueXMLDocumentUpload");

    //
    // NTRAID#NTBUG9-154248-2000/08/08-jasonr
    // NTRAID#NTBUG9-152439-2000/08/08-jasonr
    //
    // We used to pop up the "Thank You" message box in the new thread.
    // Now we pop it up in the dialog box thread instead to fix these bugs.
    // The new thread now returns 0 to indicate success, 1 to indicate
    // failure.  We only pop up the dialog box on success.
    //
    int iRet = 1;
    
    //
    // Make a temporary filename for the XML blob
    //
    TCHAR szTempFileName[MAX_PATH];
    TCHAR szTempPath[MAX_PATH];

    try 
    {
        ThrowIfZero( GetTempPath(ARRAYSIZE(szTempPath), szTempPath) );
        ThrowIfZero( GetTempFileName(szTempPath, _T("EMI"), 0, szTempFileName) );
    }
    catch(...)
    {
        FatalTrace(0, "Unable to get a tempFile name");
        //
        // Use a default value
        //
        _tcscpy(szTempFileName, _T("C:\\upload.xml"));
    }

    DebugTrace(0, "szTempFileName: %ls", szTempFileName);
    try {
        //
        // Generate the XML to the temp file
        //
        DebugTrace(0, "Saving: %ls", szTempFileName);
        doc.SaveFile(szTempFileName);

        //
        // Tell the PC Health upload library to upload it
        //
        CComPtr<IMPCUpload> pUploadMgr;
        CComPtr<IMPCUploadJob> pJob;
        HRESULT hr = S_OK;

        //
        // Create an instance of MPCUpload
        //
        DebugTrace(0, "Creating instance of MPCUpload");
        //MessageBox(GetFocus(), L"Creating instance of MPCUpload", L"Debug", 0);
        hr = pUploadMgr.CoCreateInstance(__uuidof(MPCUpload));
        if(FAILED(hr))
        {
            _Module.RegisterTypeLib();

            hr = pUploadMgr.CoCreateInstance(__uuidof(MPCUpload));

            if(FAILED(hr))
            {
                FatalTrace(0, "pUploadMgr.CoCreateInstance failed. hr=0x%x", hr);
                ThrowIfFail(hr);
            }
        }

        //
        // Set the appropriate security blanket
        //
        DebugTrace(0, "Changing Security of pUploadMgr");
        hr = ChangeSecurity( pUploadMgr );
        if(FAILED(hr))
        {
            FatalTrace(0, "ChangeSecurity Failed. hr=0x%x", hr);
            ThrowIfFail(hr);
        }

        //
        // Create an upload job
        //
        DebugTrace(0, "Creating Job");
        //MessageBox(GetFocus(), L"Creating Job", L"Debug", 0);
        hr = pUploadMgr->CreateJob(&pJob);
        if(FAILED(hr))
        {
            FatalTrace(0, "pUploadMgr->CreateJob failed hr=0x%x", hr);
            TCHAR szErr[1024];
            _stprintf(szErr, L"pUploadMgr->CreateJob failed hr=0x%x", hr);
           // MessageBox(GetFocus(), szErr, L"Debug", 0);
            ThrowIfFail(hr);
        }

        _ASSERT(pJob != NULL);

        //
        // Set the appropriate security blanket
        //
        DebugTrace(0, "Changing Security of pJob");

        hr = ChangeSecurity( pJob );
        if(FAILED(hr))
        {
            FatalTrace(0, "ChangeSecurity Failed. hr=0x%x", hr);
            ThrowIfFail(hr);
        }

        //
        // Obtain the Machine GUID
        //
        //GUIDSTR szSig;
        //GetMachineSignature(szSig);
        //DebugTrace(0, "Machine signature: %ls", CComBSTR(szSig));
        //
        // nsoy - we are going to use the uploadm GUID henceforth.
        // Set the machine signature in the job
        //
        DebugTrace(0, "Setting Machine signature");
        hr = pJob->put_Sig( NULL );
        if(FAILED(hr))
        {
            FatalTrace(0, "pJob->put_Server failed. hr=%ld", hr);
            ThrowIfFail( hr );
        }

        //
        // Obtain the registry key for upload server information
        //
        szRegKey = GetUploadRegKey(type);

        //
        // Read the registry key to obtain the upload server information
        //
        dwTemp = ARRAYSIZE(szTemp);
        GetRegValue(HKEY_LOCAL_MACHINE, szRegKey, szREGVALUE_UPLOAD_SERVER, szTemp, &dwTemp);

        //
        // Set the upload server name in the upload job
        //
        DebugTrace(0, "Setting Server: %ls", CComBSTR(szTemp));
        hr = pJob->put_Server(CComBSTR(szTemp));
        if(FAILED(hr))
        {
            FatalTrace(0, "pJob->put_Server failed. hr=%ld", hr);
            ThrowIfFail( hr );
        }

        //
        // Obtain the upload server provider name from registry
        //
        dwTemp = ARRAYSIZE(szTemp);
        GetRegValue(HKEY_LOCAL_MACHINE, szRegKey, szREGVALUE_UPLOAD_PROVIDER, szTemp, &dwTemp);

        //
        // Set the upload server provider ID
        //
        DebugTrace(0, "Setting ProviderID: %ls", CComBSTR(szTemp));
        hr = pJob->put_ProviderID(CComBSTR(szTemp));
        if(FAILED(hr))
        {
            FatalTrace(0, "pJob->put_Server failed. hr=%ld", hr);
            ThrowIfFail( hr );
        }

        // REVIEW: probably should be UL_HISTORY_NONE when we think it works
        DebugTrace(0, "Setting History to UL_HISTORY_LOG");
        hr = pJob->put_History(UL_HISTORY_LOG);
        if(FAILED(hr))
        {
            FatalTrace(0, "put_History failed. hr=%ld", hr);
            ThrowIfFail( hr );
        }

        //
        // Set the Compression flag
        //
        DebugTrace(0, "Setting Compressed flag to TRUE");
        hr = pJob->put_Compressed(VARIANT_TRUE);
        if(FAILED(hr))
        {
            FatalTrace(0, "put_Compressed failed. hr=%ld", hr);
            ThrowIfFail( hr );
        }

        
        //
        // Set PersitToDisk flag
        //
        DebugTrace(0, "Setting PersistToDisk flag to TRUE");
        hr = pJob->put_PersistToDisk(VARIANT_TRUE);
        if(FAILED(hr))
        {
            FatalTrace(0, "put_PersistToDisk failed. hr=%ld", hr);
            ThrowIfFail( hr );
        }

        //
        // Obtain Status & Error code before putting the job to queue
        //
        pJob->get_Status(&status);
        pJob->get_ErrorCode(&errCode);
        DebugTrace(0, "upload status: %d (error %ld)\n", status, errCode);

        //
        // Let the upload job read the data persisted in to the temp file
        //
        DebugTrace(0, "Calling GetDataFromFile: %ls", CComBSTR(szTempFileName));
        hr = pJob->GetDataFromFile(CComBSTR(szTempFileName));
        if(FAILED(hr))
        {
            FatalTrace(0, "GetDataFromFile failed. hr=%ld", hr);
            ThrowIfFail( hr );
        }

        //
        // Delete the temp file
        //
        if (FALSE == DeleteFile(szTempFileName))
        {
            FatalTrace(0, "DeleteFile failed on %ls. Error: %ld", szTempFileName, GetLastError());
            throw;
        }

        DebugTrace(0, "Calling ActivateAsyn");
        hr = pJob->ActivateAsync();
        if(FAILED(hr))
        {
            FatalTrace(0, "ActivateAsync failed. hr=%ld", hr);
            ThrowIfFail( hr );
        }
    
        pJob->get_Status(&status);
        pJob->get_ErrorCode(&errCode);
        DebugTrace(0, "upload status: %d (error %ld)\n", status, errCode);

        //
        // NTRAID#NTBUG9-154248-2000/08/08-jasonr
        // NTRAID#NTBUG9-152439-2000/08/08-jasonr
        //
        // We used to pop up the "Thank You" message box in the new thread.
        // Now we pop it up in the dialog box thread instead to fix these bugs.
        // The new thread now returns 0 to indicate success, 1 to indicate
        // failure.  We only pop up the dialog box on success.
        //

       iRet = 0;

#if 0
        //
        // Display Thank you dialog
        //
        TCHAR szThankYouMessage[1024];
        TCHAR szThankYouMessageTitle[1024];

        LoadString(_Module.GetResourceInstance(),
                   IDS_COMMENT_THANKYOU,
                   szThankYouMessage,
                   ARRAYSIZE(szThankYouMessage));

        LoadString(_Module.GetResourceInstance(),
                   IDS_COMMENT_THANKYOUTITLE,
                   szThankYouMessageTitle,
                   ARRAYSIZE(szThankYouMessageTitle));
        
        MessageBox( NULL, szThankYouMessage, szThankYouMessageTitle, MB_OK);
#endif

    }
    catch (HRESULT hr) {
        FatalTrace(0, "Error Code: %lx", hr);
    }
    catch (...) {
        DebugTrace(0, "Upload CRASHED !!!");
        throw;
    }

    return(iRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\common\pfdb\atl.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    atl.cpp

Abstract:
    includes the ATL implementation

Revision History:
    DerekM  created  05/01/99

********************************************************************/

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#if defined(ATL_STATIC_REGISTRY)
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\common\pfdb\adotest.cpp ===
// adotest.cpp : Defines the entry point for the application.
//

#include <atlbase.h>
#include <adoint.h>
#include <initguid.h>
#include <adoid.h>

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    ADOConnection   *pConn = NULL;
    ADORecordset    *pRS = NULL;
    ADOCommand      *pCmd = NULL;
    CComBSTR        bstrCS;
    CComBSTR        bstrCmd;
    VARIANT         varEmpty;
    VARIANT         varVal;
    HRESULT         hr;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
        goto done;

    // create the ADO object
    hr = CoCreateInstance(CLSID_CADOConnection, NULL, CLSCTX_INPROC_SERVER, 
                          IID_IADOConnection, (void**)&pConn);
    if (FAILED(hr))
        goto done;
        
    bstrCS = L"UID=sa;PWD=pw;DRIVER={SQL Server};SERVER=ratbertx;DATABASE=pchpf";
    hr = pConn->Open(bstrCS, NULL, NULL, adConnectUnspecified);
    if (FAILED(hr))
        goto done;

	hr = CoCreateInstance(CLSID_CADOCommand, NULL, CLSCTX_INPROC_SERVER, 
                          IID_IADOCommand, (void**)&pCmd);
    if (FAILED(hr))
        goto done;

    hr = pCmd->putref_ActiveConnection(pConn);
    if (FAILED(hr))
        goto done;
    
    bstrCmd = L"SELECT * FROM FileData";
    hr = pCmd->put_CommandText(bstrCmd);
    if (FAILED(hr))
        goto done;

    hr = pCmd->put_CommandType(adCmdText);
    if (FAILED(hr))
        goto done;

    hr = pCmd->Execute(NULL, NULL, adCmdText, &pRS);
    if (FAILED(hr))
        goto done;
    
    if (pRS != NULL)
        pRS->Close();

done:
    if (pConn != NULL)
        pConn->Release();
    if (pCmd != NULL)
        pCmd->Release();
    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\common\pfdb\stdafx.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    common include dumping ground

Revision History:
    DerekM  created  05/01/99

********************************************************************/

#if !defined(AFX_STDAFX_H__F6D93C5D_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
#define AFX_STDAFX_H__F6D93C5D_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "stdio.h"
#include "util.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.



#endif // !defined(AFX_STDAFX_H__F6D93C5D_DF3F_11D2_80AF_00C04F688C0B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\common\pfdb\pftest.cpp ===
#include "stdafx.h"
#include "pfdb.h"
#include "initguid.h"
#include <adoid.h>

const LPCWSTR   c_wszSQLConnFmt = L"UID=sa;PWD=pw;DRIVER={SQL Server};SERVER=ratbertx;DATABASE=pchpf";
const LPCWSTR   c_wszJetConnFmt = L"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=d:\adotest.mdb";

CComBSTR    g_bstrI    = L"i";
CComBSTR    g_bstrSz   = L"sz";
CComBSTR    g_bstrBlob = L"blob";


void __cdecl main(int argc, char **argv)
{
    SAFEARRAYBOUND  sab;
    VARIANT         var;
    HRESULT         hr = NOERROR;
    HANDLE          hMMF = NULL, hFile = INVALID_HANDLE_VALUE;
    LPVOID          pvData = NULL; 
    CPFDB           pfdb;
    DWORD           cbData, cbRead;
    BOOL            fInit = FALSE;

    VariantInit(&var);

    if (argc < 2)
        goto done;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
        goto done;

    fInit = TRUE;

    hr = pfdb.Init(c_wszSQLConnFmt);
    if (FAILED(hr))
        goto done;

    hr = pfdb.Begin(L"SELECT * FROM FileData", adCmdText);
    if (FAILED(hr))
        goto done;

    hr = pfdb.Execute(TRUE);
    if (FAILED(hr))
        goto done;

    while(hr != S_FALSE)
    {
        hr = pfdb.GetData(g_bstrI, &var);
        if (FAILED(hr))
            goto done;

        VariantClear(&var);
        hr = pfdb.GetData(g_bstrSz, &var);
        if (FAILED(hr))
            goto done;

        VariantClear(&var);
        hr = pfdb.GetData(g_bstrBlob, &var);
        if (FAILED(hr))
            goto done;

        VariantClear(&var);
        hr = pfdb.GetNextRow();
        if (FAILED(hr))
            goto done;
    }

    hr = pfdb.Begin(L"INSERT INTO FileData VALUES (?, ?, ?)");
    if (FAILED(hr))
        goto done;

    V_VT(&var) = VT_I4;
    V_I4(&var) = 2020;
    hr = pfdb.AddInParam(var, adInteger, 0);
    if (FAILED(hr))
        goto done;

    V_VT(&var)   = VT_BSTR;
    V_BSTR(&var) = SysAllocString(L"Dude!  There's like something over there man!");
    hr = pfdb.AddInParam(var, adBSTR, 1);
    VariantClear(&var);
    if (FAILED(hr))
        goto done;

    hFile = CreateFileA(argv[1], GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        goto done;

    cbData = GetFileSize(hFile, NULL);
    if (cbData == (DWORD)-1)
        goto done;

    V_VT(&var)   = VT_BSTR;
    V_BSTR(&var) = SysAllocStringByteLen(NULL, cbData);
    if (V_BSTR(&var) == NULL)
        goto done;

    ReadFile(hFile, V_BSTR(&var), cbData, &cbRead, NULL);

    hr = pfdb.AddInParam(var, adLongVarWChar, 2);
    VariantClear(&var);
    if (FAILED(hr))
        goto done;

    hr = pfdb.Execute(FALSE);
    if (FAILED(hr))
        goto done;

done:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (fInit)
        CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\common\xml\atl.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    atl.cpp

Abstract:
    includes the ATL implementation

Revision History:
    DerekM  created  05/01/99

********************************************************************/

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#if defined(ATL_STATIC_REGISTRY)
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\lamebtn\dll\utils_compress.cpp ===
/***** READ THIS NOW! *****

    This file Utils_Compress.cpp was copied on 08/24/00 by JasonR from 
    %sdxroot%\admin\pchealth\core\MPC_Common\Utils_Compress.cpp.

    Ideally, LAMEBTN.DLL would just link with MPC_Common.lib, but unfortunately
    that library is hacked to avoid needing to link with MSCVP60.DLL.  The hack
    code (in %sdxroot%\admin\pchealth\core\MPC_Common\StaticCRT.CPP) prevents
    MPC_Common.lib from being linkable with any binary that also needs to link
    with MSVCP60.DLL.  Rather than sort that mess out, I copied the code here
    with as little change as possible (as recommended by MazharM).  I did have
    to make some minor changes to make it compile.

    Because this file includes MPC header files, if the definitions in those
    files change, this file may no longer be compilable.

***** THANKS FOR READING! *****/

/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_Compression.cpp

Abstract:
    This file contains the implementation of the compression utility functions.

Revision History:
    Davide Massarenti   (Dmassare)  06/28/99
        created

******************************************************************************/

#include "stdafx.h"

#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>

#include <fci.h>
#include <fdi.h>

#include <list>
#include <string>

// MPC_Utils.h includes MPC_main.h, which apparently redefines ARRAYSIZE which
// causes a compiler warning.

#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif

#define NOTRACE

#include <MPC_COM.h>
#include <MPC_utils.h>

_STD_BEGIN

void __cdecl _XlenNR() { throw "string too long"; } // report a length_error
void __cdecl _XranNR() { throw "invalid string position"; } // report an out_of_range error

_STD_END

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

static DWORD LocalGetLastError()
{
    DWORD dwRes = ::GetLastError();

    if(dwRes == ERROR_SUCCESS)
    {
        dwRes = _doserrno;
        if(dwRes == ERROR_SUCCESS)
        {
            dwRes = ERROR_TOO_MANY_OPEN_FILES;
        }
    }

    return dwRes;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

LPVOID DIAMONDAPI MPC::Cabinet::mem_alloc( ULONG cb )
{
    return malloc( cb );
}

void DIAMONDAPI MPC::Cabinet::mem_free( LPVOID memory )
{
    free( memory );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int DIAMONDAPI MPC::Cabinet::fci_delete( LPSTR pszFile, int *err, LPVOID pv )
{
    int result = remove( pszFile );

    if(result != 0) *err = errno;

    return result;
}

INT_PTR DIAMONDAPI MPC::Cabinet::fci_open( LPSTR   pszFile, int oflag, int pmode, int *err, LPVOID pv )
{
    int result = _open( pszFile, oflag, pmode );

    if(result == -1) *err = errno;

    return result;
}

UINT DIAMONDAPI MPC::Cabinet::fci_read( INT_PTR hf, LPVOID memory, UINT cb, int *err, LPVOID pv )
{
    UINT result = (UINT)_read( hf, memory, cb );

    if(result != cb) *err = errno;

    return result;
}

UINT DIAMONDAPI MPC::Cabinet::fci_write( INT_PTR hf, LPVOID memory, UINT cb, int *err, LPVOID pv )
{
    unsigned int result = (unsigned int)_write( hf, memory, cb );

    if(result != cb) *err = errno;

    return result;
}

int DIAMONDAPI MPC::Cabinet::fci_close( INT_PTR hf, int *err, LPVOID pv )
{
    int result = _close( hf );

    if(result != 0) *err = errno;

    return result;
}

long DIAMONDAPI MPC::Cabinet::fci_seek( INT_PTR hf, long dist, int seektype, int *err, LPVOID pv )
{
    long result = _lseek( hf, dist, seektype );

    if(result == -1) *err = errno;

    return result;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL DIAMONDAPI MPC::Cabinet::fci_get_next_cabinet( PCCAB pccab, ULONG cbPrevCab, LPVOID pv )
{
    USES_CONVERSION;

    MPC::Cabinet* cCab = (MPC::Cabinet*)pv;

    strncpy( pccab->szCab    , W2A(cCab->m_szCabinetName), MAXSTRLEN( pccab->szCab     ) );
    strncpy( pccab->szCabPath, W2A(cCab->m_szCabinetPath), MAXSTRLEN( pccab->szCabPath ) );

    return TRUE;
}

int DIAMONDAPI MPC::Cabinet::fci_file_placed( PCCAB pccab, LPSTR pszFile, long  cbFile, BOOL fContinuation, LPVOID pv )
{
    return 0;
}

long DIAMONDAPI MPC::Cabinet::fci_progress( UINT typeStatus, ULONG cb1, ULONG cb2, LPVOID pv )
{
    MPC::Cabinet* cCab = (MPC::Cabinet*)pv;
    long          res  = 0;

    if(typeStatus == statusFile)
    {
        //
        // Notify client.
        //
        if(cCab->m_pfnCallback_Bytes)
        {
            ULONG lDone  = (cCab->m_dwSizeDone += cb2);
            ULONG lTotal =  cCab->m_dwSizeTotal;

            if(FAILED(cCab->m_pfnCallback_Bytes( cCab, lDone, lTotal, cCab->m_lpUser )))
            {
                ::SetLastError( ERROR_OPERATION_ABORTED );

                res = -1;
            }
        }
    }

    return res;
}

BOOL DIAMONDAPI MPC::Cabinet::fci_get_temp_file( LPSTR pszTempName, int cbTempName, LPVOID pv )
{
    char  szPrefix[128];
    char *psz;
    BOOL  res = FALSE;

    sprintf( szPrefix, "PCHtemp_%ld_", (long)::GetCurrentThreadId() );
    psz = _tempnam( "", szPrefix ); // Get a name
    if(psz)
    {
        if(strlen( psz ) < (unsigned)cbTempName)
        {
            strcpy( pszTempName, psz ); // Copy to caller's buffer
            res = TRUE;
        }

        free( psz );
    }

    return res;
}

INT_PTR DIAMONDAPI MPC::Cabinet::fci_get_open_info( LPSTR pszName, USHORT *pdate, USHORT *ptime, USHORT *pattribs, int *err, LPVOID pv )
{
    MPC::Cabinet*              cCab = (MPC::Cabinet*)pv;
    BY_HANDLE_FILE_INFORMATION finfo;
    FILETIME                   filetime;
    HANDLE                     handle;
    DWORD                      attrs;
    int                        hf = -1;


    /*
     * Need a Win32 type handle to get file date/time using the Win32 APIs, even though the handle we
     * will be returning is of the type compatible with _open
     */
    handle = ::CreateFileA( pszName                                          ,
                            GENERIC_READ                                     ,
                            FILE_SHARE_READ|FILE_SHARE_WRITE                 ,
                            NULL                                             ,
                            OPEN_EXISTING                                    ,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL                                             );
    if(handle != INVALID_HANDLE_VALUE)
    {
        if(::GetFileInformationByHandle( handle, &finfo ) == TRUE)
        {
            ::FileTimeToLocalFileTime( &finfo.ftLastWriteTime, &filetime               );
            ::FileTimeToDosDateTime  (                         &filetime, pdate, ptime );

            attrs = ::GetFileAttributesA( pszName );
            if(attrs == 0xFFFFFFFF)
            {
                /* failure */
                *pattribs = 0;
            }
            else
            {
                /*
                 * Mask out all other bits except these four, since other
                 * bits are used by the cabinet format to indicate a
                 * special meaning.
                 */
                *pattribs = (int)(attrs & (_A_RDONLY | _A_SYSTEM | _A_HIDDEN | _A_ARCH));
            }
        }

        ::CloseHandle( handle );
    }


    /*
     * Return handle using _open
     */
    hf = _open( pszName, _O_RDONLY | _O_BINARY );
    if(hf == -1)
    {
        *err = errno;

        return -1; // abort on error
    }

    return hf;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

INT_PTR DIAMONDAPI MPC::Cabinet::fdi_open( LPSTR pszFile, int oflag, int pmode )
{
    return _open( pszFile, oflag, pmode );
}

UINT DIAMONDAPI MPC::Cabinet::fdi_read( INT_PTR hf, LPVOID pv, UINT cb )
{
    return _read( hf, pv, cb );
}

UINT DIAMONDAPI MPC::Cabinet::fdi_write( INT_PTR hf, LPVOID pv, UINT cb )
{
    return _write( hf, pv, cb );
}

int DIAMONDAPI MPC::Cabinet::fdi_close( INT_PTR hf )
{
    return _close( hf );
}

long DIAMONDAPI MPC::Cabinet::fdi_seek( INT_PTR hf, long dist, int seektype )
{
    return _lseek( hf, dist, seektype );
}


INT_PTR DIAMONDAPI MPC::Cabinet::fdi_notification_copy( FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin )
{
    USES_CONVERSION;

    MPC::Cabinet* cCab = (MPC::Cabinet*)pfdin->pv;

    switch(fdint)
    {
    case fdintCOPY_FILE:    // file to be copied
        {
            MPC::Cabinet::Iter it;
            LPCWSTR            szName = A2W( pfdin->psz1 );

            for(it=cCab->m_lstFiles.begin(); it != cCab->m_lstFiles.end(); it++)
            {
                if(!_wcsicmp( szName, it->m_szName.c_str() ))
                {
                    it->m_fFound = true;

                    return fdi_open( W2A( (LPWSTR)it->m_szFullName.c_str() ), _O_BINARY | _O_CREAT | _O_TRUNC | _O_WRONLY | _O_SEQUENTIAL, _S_IREAD | _S_IWRITE );
                }
            }
        }
        break;

    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        fdi_close( pfdin->hf );
        return TRUE;
    }

    return 0;
}

INT_PTR DIAMONDAPI MPC::Cabinet::fdi_notification_enumerate( FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin )
{
    USES_CONVERSION;

    MPC::Cabinet* cCab = (MPC::Cabinet*)pfdin->pv;

    switch(fdint)
    {
    case fdintCOPY_FILE:    // file to be copied
        MPC::Cabinet::Iter it = cCab->m_lstFiles.insert( cCab->m_lstFiles.end() );

        it->m_szName = A2W( pfdin->psz1 );
        it->m_fFound = true;
        break;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

MPC::Cabinet::Cabinet()
{
    memset( m_szCabinetPath, 0, sizeof(m_szCabinetPath) );    // CHAR              m_szCabinetName[MAX_PATH];
    memset( m_szCabinetName, 0, sizeof(m_szCabinetName) );    // CHAR              m_szCabinetPath[MAX_PATH];
                                                              // List              m_lstFiles;
    m_itCurrent = m_lstFiles.end();                           // Iter              m_itCurrent;
                                                              //
    m_dwSizeDone  = 0;                                        // DWORD             m_dwSizeDone;
    m_dwSizeTotal = 0;                                        // DWORD             m_dwSizeTotal;
                                                              //
    m_hfci = NULL;                                            // HFCI              m_hfci;
    m_hfdi = NULL;                                            // HFDI              m_hfdi;
                                                              // ERF               m_erf;
    memset( &m_cab_parameters, 0, sizeof(m_cab_parameters) ); // CCAB              m_cab_parameters;
                                                              //
    m_fIgnoreMissingFiles = FALSE;                            // BOOL              m_fIgnoreMissingFiles;
    m_lpUser              = NULL;                             // LPVOID            m_lpUser;
    m_pfnCallback_Files   = NULL;                             // PFNPROGRESS_FILES m_pfnCallback_Files;
    m_pfnCallback_Bytes   = NULL;                             // PFNPROGRESS_BYTES m_pfnCallback_Bytes;
}

MPC::Cabinet::~Cabinet()
{
    if(m_hfci) { FCIDestroy( m_hfci ); m_hfci = NULL; }
    if(m_hfdi) { FCIDestroy( m_hfdi ); m_hfdi = NULL; }
}

//////////////////////////////////////////////////////////////////////

HRESULT MPC::Cabinet::put_CabinetFile( /*[in]*/ LPCWSTR szCabinetFile, /*[in]*/ UINT cbSpaceToReserve )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CompressAsCabinet" );

    USES_CONVERSION;

    HRESULT hr;
    Cabinet cab;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szCabinetFile);
	__MPC_PARAMCHECK_END();


    memset(  m_szCabinetPath , 0, sizeof(m_szCabinetPath ) );
    memset(  m_szCabinetName , 0, sizeof(m_szCabinetName ) );
    memset( &m_cab_parameters, 0, sizeof(m_cab_parameters) );


    //
    // Initialize cabinet path and name.
    //
    {
        LPWSTR szEnd = wcsrchr( szCabinetFile, L'\\' );
        if(szEnd == NULL)
        {
            wcsncpy( m_szCabinetName, szCabinetFile, MAXSTRLEN( m_szCabinetName ) );
        }
        else
        {
            int len = (szEnd - szCabinetFile) + 1;

            wcsncpy( m_szCabinetName, szEnd+1      ,      MAXSTRLEN( m_szCabinetName )        );
            wcsncpy( m_szCabinetPath, szCabinetFile, min( MAXSTRLEN( m_szCabinetPath ), len ) );
        }
    }

    //
    // Initialize the cabinet description header.
    //
    {
        m_cab_parameters.cb             = (LONG_MAX);
        m_cab_parameters.cbFolderThresh = (LONG_MAX);

        /*
         * Don't reserve space for any extensions
         */
        m_cab_parameters.cbReserveCFHeader = cbSpaceToReserve;
        m_cab_parameters.cbReserveCFFolder = 0;
        m_cab_parameters.cbReserveCFData   = 0;

        /*
         * We use this to create the cabinet name
         */
        m_cab_parameters.iCab = 1;

        /*
         * If you want to use disk names, use this to
         * count disks
         */
        m_cab_parameters.iDisk = 0;

        /*
         * Choose your own number
         */
        m_cab_parameters.setID = 12345;

        strncpy( m_cab_parameters.szCab    , W2A(m_szCabinetName), MAXSTRLEN( m_cab_parameters.szCab     ) );
        strncpy( m_cab_parameters.szCabPath, W2A(m_szCabinetPath), MAXSTRLEN( m_cab_parameters.szCabPath ) );
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Cabinet::put_IgnoreMissingFiles( /*[in]*/ BOOL fVal )
{
    m_fIgnoreMissingFiles = fVal;

    return S_OK;
}

HRESULT MPC::Cabinet::put_UserData( /*[in]*/ LPVOID lpVal )
{
    m_lpUser = lpVal;

    return S_OK;
}

HRESULT MPC::Cabinet::put_onProgress_Files( /*[in]*/ PFNPROGRESS_FILES pfnVal )
{
    m_pfnCallback_Files = pfnVal;

    return S_OK;
}

HRESULT MPC::Cabinet::put_onProgress_Bytes( /*[in]*/ PFNPROGRESS_BYTES pfnVal )
{
    m_pfnCallback_Bytes = pfnVal;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////

HRESULT MPC::Cabinet::ClearFiles()
{
    m_lstFiles.clear();
    m_itCurrent = m_lstFiles.end();

    return S_OK;
}

HRESULT MPC::Cabinet::GetFiles( /*[out]*/ List& lstFiles )
{
    lstFiles = m_lstFiles;

    return S_OK;
}

HRESULT MPC::Cabinet::AddFile( /*[in]*/ LPCWSTR szFileName, /*[in]*/ LPCWSTR szFileNameInsideCabinet )
{
    Iter it = m_lstFiles.insert( m_lstFiles.end() );

    if(szFileNameInsideCabinet == NULL || szFileNameInsideCabinet[0] == 0)
    {
        LPCWSTR szEnd = wcsrchr( szFileName, L'\\' );

        szFileNameInsideCabinet = szEnd ? szEnd+1 : szFileName;
    }

    it->m_szFullName = szFileName;
    it->m_szName     = szFileNameInsideCabinet;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////

HRESULT MPC::Cabinet::Compress()
{
    USES_CONVERSION;

    DWORD dwRes = ERROR_SUCCESS;
    BOOL  res   = FALSE;


    m_hfci = FCICreate( &m_erf             ,
                         fci_file_placed   ,
                         mem_alloc         ,
                         mem_free          ,
                         fci_open          ,
                         fci_read          ,
                         fci_write         ,
                         fci_close         ,
                         fci_seek          ,
                         fci_delete        ,
                         fci_get_temp_file ,
                        &m_cab_parameters  ,
                         this              );
    if(m_hfci)
    {
        for(int pass=0; pass<2 && dwRes==ERROR_SUCCESS; pass++)
        {
            Iter  it;
            ULONG lDone  = 0;
            ULONG lTotal = m_lstFiles.size();

            if(pass == 1)
            {
                //
                // Notify client about total number of bytes to compress.
                //
                if(m_pfnCallback_Bytes)
                {
                    if(FAILED(m_pfnCallback_Bytes( this, 0, m_dwSizeTotal, m_lpUser )))
                    {
                        dwRes = ERROR_OPERATION_ABORTED;
                        break;
                    }
                }
            }

            for(it=m_lstFiles.begin(); it != m_lstFiles.end(); it++, lDone++)
            {
                LPCWSTR szFilePath = it->m_szFullName.c_str();
                LPCWSTR szFileName = it->m_szName    .c_str();
                HANDLE handle;


                m_itCurrent = it;


                if(pass == 1)
                {
                    //
                    // Notify client.
                    //
                    if(m_pfnCallback_Files)
                    {
                        if(FAILED(m_pfnCallback_Files( this, szFilePath, lDone, lTotal, m_lpUser )))
                        {
                            dwRes = ERROR_OPERATION_ABORTED;
                            break;
                        }
                    }
                }


                //
                // Check the existence of the file.
                //
                handle = ::CreateFileW( szFilePath                                       ,
                                        GENERIC_READ                                     ,
                                        FILE_SHARE_READ|FILE_SHARE_WRITE                 ,
                                        NULL                                             ,
                                        OPEN_EXISTING                                    ,
                                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                        NULL                                             );
                if(handle == INVALID_HANDLE_VALUE)
                {
                    dwRes = LocalGetLastError();

                    if(m_fIgnoreMissingFiles)
                    {
                        dwRes = ERROR_SUCCESS;
                        continue; // The file doesn't exist, simply skip it.
                    }

                    break;
                }

                ////////////////////////////////////////

                if(pass == 0) // Get the size of files on first pass.
                {
                    BY_HANDLE_FILE_INFORMATION finfo;

                    if(::GetFileInformationByHandle( handle, &finfo ) == TRUE)
                    {
                        it->m_dwSizeUncompressed  = finfo.nFileSizeLow;
                        m_dwSizeTotal            += finfo.nFileSizeLow;
                    }
                }

                ::CloseHandle( handle );

                if(pass == 0) continue; // Don't compress on first pass.

                ////////////////////////////////////////

                if(FCIAddFile(     m_hfci               ,
                               W2A(szFilePath)          , /* file to add                 */
                               W2A(szFileName)          , /* name of the file in cabinet */
                                   FALSE                , /* file is not executable      */
                                   fci_get_next_cabinet ,
                                   fci_progress         ,
                                   fci_get_open_info    ,
                                   tcompTYPE_MSZIP      ) == FALSE)
                {
                    dwRes = LocalGetLastError();

                    if(dwRes == ERROR_PATH_NOT_FOUND    ||
                       dwRes == ERROR_FILE_NOT_FOUND    ||
                       dwRes == ERROR_SHARING_VIOLATION ||
                       dwRes == ERROR_ACCESS_DENIED      )
                    {
                        if(m_fIgnoreMissingFiles)
                        {
                            dwRes = ERROR_SUCCESS;
                            continue; // The file doesn't exist, simply skip it.
                        }
                    }

                    break;
                }
            }

            if(pass == 0) continue; // Don't compress on first pass.

            if(it == m_lstFiles.end())
            {
                //
                // Finalize cabinet.
                //
                if(FCIFlushCabinet( m_hfci, FALSE, fci_get_next_cabinet, fci_progress ))
                {
                    res = TRUE;
                }
                else
                {
                    dwRes = LocalGetLastError();
                }
            }
        }

        FCIDestroy( m_hfci ); m_hfci = NULL;
    }
    else
    {
        dwRes = LocalGetLastError();
    }

    m_itCurrent = m_lstFiles.end();

    ::SetLastError( dwRes );

    return (res ? S_OK : HRESULT_FROM_WIN32( dwRes ));
}

HRESULT MPC::Cabinet::Decompress()
{
    USES_CONVERSION;

    DWORD dwRes = ERROR_SUCCESS;
    BOOL  res   = FALSE;


    m_hfdi = FDICreate(  mem_alloc  ,
                         mem_free   ,
                         fdi_open   ,
                         fdi_read   ,
                         fdi_write  ,
                         fdi_close  ,
                         fdi_seek   ,
                         cpuUNKNOWN ,
                        &m_erf      );
    if(m_hfdi)
    {
        if(FDICopy( m_hfdi               ,
                    W2A(m_szCabinetName) ,
                    W2A(m_szCabinetPath) ,
                    0                    ,
                    fdi_notification_copy,
                    NULL                 ,
                    this                 ))
        {
            IterConst it;

            for(it=m_lstFiles.begin(); it != m_lstFiles.end(); it++)
            {
                if(it->m_fFound == false) break;
            }

            if(it != m_lstFiles.end())
            {
                dwRes = ERROR_FILE_NOT_FOUND;
            }
            else
            {
                res = TRUE;
            }
        }
        else
        {
            dwRes = LocalGetLastError();
        }

        FDIDestroy( m_hfdi ); m_hfdi = NULL;
    }
    else
    {
        dwRes = LocalGetLastError();
    }


    ::SetLastError( dwRes );

    return (res ? S_OK : HRESULT_FROM_WIN32( dwRes ));
}

HRESULT MPC::Cabinet::Enumerate()
{
    USES_CONVERSION;

    DWORD dwRes = ERROR_SUCCESS;
    BOOL  res   = FALSE;


    m_lstFiles.clear();

    m_hfdi = FDICreate(  mem_alloc  ,
                         mem_free   ,
                         fdi_open   ,
                         fdi_read   ,
                         fdi_write  ,
                         fdi_close  ,
                         fdi_seek   ,
                         cpuUNKNOWN ,
                        &m_erf      );
    if(m_hfdi)
    {
        if(FDICopy( m_hfdi                    ,
                    W2A(m_szCabinetName)      ,
                    W2A(m_szCabinetPath)      ,
                    0                         ,
                    fdi_notification_enumerate,
                    NULL                      ,
                    this                      ))
        {
            res = TRUE;
        }
        else
        {
            dwRes = LocalGetLastError();
        }

        FDIDestroy( m_hfdi ); m_hfdi = NULL;
    }
    else
    {
        dwRes = LocalGetLastError();
    }


    ::SetLastError( dwRes );

    return (res ? S_OK : HRESULT_FROM_WIN32( dwRes ));
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::CompressAsCabinet( LPCWSTR szInputFile   ,
								LPCWSTR szCabinetFile ,
								LPCWSTR szFileName    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CompressAsCabinet" );

    HRESULT hr;
    Cabinet cab;


    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile( szCabinetFile             ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile        ( szInputFile  , szFileName ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.Compress());

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::CompressAsCabinet( const WStringList& lstFiles            ,
								LPCWSTR            szCabinetFile       ,
								BOOL               fIgnoreMissingFiles )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CompressAsCabinet" );

    HRESULT          hr;
    Cabinet          cab;
    WStringIterConst it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile       ( szCabinetFile       ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_IgnoreMissingFiles( fIgnoreMissingFiles ));

    for(it=lstFiles.begin(); it != lstFiles.end(); it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( it->c_str() ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.Compress());

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::ListFilesInCabinet( LPCWSTR      szCabinetFile ,
								 WStringList& lstFiles      )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CompressAsCabinet" );

    HRESULT            hr;
    Cabinet            cab;
    Cabinet::List      lst;
    Cabinet::IterConst it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile( szCabinetFile ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.Enumerate());

    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.GetFiles( lst ));
    for(it=lst.begin(); it!=lst.end(); it++)
    {
        if(it->m_fFound)
        {
            lstFiles.push_back( it->m_szName );
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::DecompressFromCabinet( LPCWSTR szCabinetFile ,
									LPCWSTR szOutputFile  ,
									LPCWSTR szFileName    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CompressAsCabinet" );

    HRESULT hr;
    Cabinet cab;


    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile( szCabinetFile             ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile        ( szOutputFile , szFileName ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.Decompress());

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\common\xml\xmltest.cpp ===
#include "stdafx.h"
#include "pfarray.h"
#include "pfxml.h"
#include "util.h"
#include "stdio.h"

void __cdecl wmain(int argc, WCHAR **argv)
{
    CPFArrayUnknown rgFile, rgWQL;
    CPFXMLDocument  xmldoc;
    CPFXMLNode      *ppfxml = NULL;
    HRESULT         hr = NOERROR;
    WCHAR           sz[MAX_PATH];
    void            *szLeak;

    if (argc < 2)
        return;

    if (FAILED(CoInitialize(NULL)))
        return;

    hr = xmldoc.ParseFile(argv[1]);
    if (FAILED(hr))
    {
        printf("parse failed!\n");
        return;
    }

    wcscpy(sz, argv[1]);
    wcscat(sz, L"2.xml");
    hr = xmldoc.WriteFile(sz);
    if (FAILED(hr))
    {
        printf("write failed!\n");
        return;
    }

    hr = xmldoc.get_RootNode(&ppfxml);
    if (FAILED(hr))
        return;

    hr = ppfxml->get_MatchingChildElements(L"FILE", rgFile);
    if (FAILED(hr))
        return;

    hr = ppfxml->get_MatchingChildElements(L"WQL", rgWQL);
    if (FAILED(hr))
        return;

    ppfxml->DeleteAllChildren();
    ppfxml->append_Children(rgFile);

    wcscpy(sz, argv[1]);
    wcscat(sz, L"FILE.xml");
    hr = xmldoc.WriteFile(sz);
    if (FAILED(hr))
    {
        printf("write failed!\n");
        return;
    }

    ppfxml->DeleteAllChildren();
    ppfxml->append_Children(rgWQL);

    wcscpy(sz, argv[1]);
    wcscat(sz, L"WQL.xml");
    hr = xmldoc.WriteFile(sz);
    if (FAILED(hr))
    {
        printf("write failed!\n");
        return;
    }

    ppfxml->Release();

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\hungapp\hangcom\atl.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\common\xml\stdafx.h ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    common include dumping ground

Revision History:
    DerekM  created  05/01/99

********************************************************************/

#if !defined(AFX_STDAFX_H__F6D93C5D_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_)
#define AFX_STDAFX_H__F6D93C5D_DF3F_11D2_80AF_00C04F688C0B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.



#endif // !defined(AFX_STDAFX_H__F6D93C5D_DF3F_11D2_80AF_00C04F688C0B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\faultsvc\faultsvc.cpp ===
// faultsvc.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f faultsvcps.mk in the project directory.

#include "windows.h"
#include "shellapi.h"

SERVICE_STATUS_HANDLE   g_hSvcStatus = NULL;
SERVICE_STATUS          g_ssStatus;
WCHAR                   g_wszSvcName[] = L"faultsvc";
DWORD                   g_dwThreadId = 0;

#define sizeofSTRW(wsz) (sizeof((wsz)) / sizeof(WCHAR))

// ***************************************************************************
DWORD WINAPI threadFault(LPVOID pv)
{
    HANDLE  hFile = INVALID_HANDLE_VALUE;

    for(;;)
    {
        Sleep(5000);
        hFile = CreateFileA("d:\\faultnow.flt", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            SYSTEMTIME  st;
            DWORD       cbWrite;
            CHAR        sz[1024];

            CloseHandle(hFile);
            GetSystemTime(&st);
            wsprintfA(sz, "%02d-%02d-%04d  %02d:%02d:%02d\n", st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, st.wSecond);
            hFile = CreateFileA("d:\\faultnow.log", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                SetFilePointer(hFile, 0, NULL, FILE_END);
                WriteFile(hFile, sz, lstrlenA(sz), &cbWrite, NULL);
                CloseHandle(hFile);

                DWORD *pdw = NULL;
                *pdw = 0;

                return 0;
            }
        }
    }

    return 0;
}

// ***************************************************************************
BOOL InstallService(void)
{
    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hSvc = NULL;
    BOOL        fRet = FALSE;
    WCHAR       wszFilePath[MAX_PATH];
        
    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
        goto done;

    // does the service already exist? 
    hSvc = OpenServiceW(hSCM, g_wszSvcName, SERVICE_QUERY_CONFIG);
    if (hSvc != NULL)
        fRet = TRUE;

    if (fRet)
        goto done;

    // Get the executable file path
    GetModuleFileNameW(NULL, wszFilePath, sizeofSTRW(wszFilePath));

    hSvc = CreateServiceW(hSCM, g_wszSvcName, g_wszSvcName, SERVICE_ALL_ACCESS, 
                          SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START, 
                          SERVICE_ERROR_NORMAL, wszFilePath, NULL, NULL, 
                          L"RPCSS\0", NULL, NULL);
    if (hSvc == NULL)
        goto done;

    fRet = TRUE;

done:
    if (hSCM != NULL)
        CloseServiceHandle(hSCM);
    if (hSvc != NULL)
        CloseServiceHandle(hSvc);
    
    return fRet;
}

// ***************************************************************************
BOOL UninstallService(void)
{
    SERVICE_STATUS  status;
    SC_HANDLE       hSCM = NULL;
    SC_HANDLE       hSvc = NULL;
    BOOL            fRet = FALSE;
    WCHAR           wszFilePath[MAX_PATH];
        
    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
        goto done;

    // does the service already exist? 
    hSvc = OpenServiceW(hSCM, g_wszSvcName, SERVICE_STOP | DELETE);
    if (hSvc == NULL)
        fRet = TRUE;

    if (fRet)
        goto done;

    ControlService(hSvc, SERVICE_CONTROL_STOP, &status);
    fRet = DeleteService(hSvc);

done:
    if (hSCM != NULL)
        CloseServiceHandle(hSCM);
    if (hSvc != NULL)
        CloseServiceHandle(hSvc);
    
    return fRet;
}

// ***************************************************************************
void WINAPI ServiceHandler(DWORD fdwControl)
{
    switch (fdwControl)
    {
        case SERVICE_CONTROL_STOP:
            g_ssStatus.dwCurrentState = SERVICE_STOP_PENDING;
            SetServiceStatus(g_hSvcStatus, &g_ssStatus);
            PostThreadMessage(g_dwThreadId, WM_QUIT, 0, 0);
            break;

        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        case SERVICE_CONTROL_INTERROGATE:
        case SERVICE_CONTROL_SHUTDOWN:
        default:
            break;
    }
}

// ***************************************************************************
void WINAPI ServiceMain(DWORD dwArgc, LPWSTR *lpszArgv)
{
    HANDLE  hth = NULL;
    DWORD   dw;
    MSG     msg;

    ZeroMemory(&g_ssStatus, sizeof(g_ssStatus));

    g_hSvcStatus = RegisterServiceCtrlHandlerW(g_wszSvcName, ServiceHandler);
    if (g_hSvcStatus == NULL)
        goto done;

    // mark the service as about to start
    g_ssStatus.dwServiceType             = SERVICE_WIN32_OWN_PROCESS;
    g_ssStatus.dwCurrentState            = SERVICE_START_PENDING;
    g_ssStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
    g_ssStatus.dwWin32ExitCode           = 0;
    g_ssStatus.dwServiceSpecificExitCode = 0;
    g_ssStatus.dwCheckPoint              = 1;
    g_ssStatus.dwWaitHint                = 1000;
    SetServiceStatus(g_hSvcStatus, &g_ssStatus);

    g_dwThreadId = GetCurrentThreadId();

    // mark the service as started
    g_ssStatus.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(g_hSvcStatus, &g_ssStatus);

    hth = CreateThread(NULL, 0, threadFault, NULL, 0, &dw);
    if (hth != NULL)
    {
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

        CloseHandle(hth);
    }

    // mark the service as stopped
    g_ssStatus.dwCurrentState = SERVICE_STOPPED;
    SetServiceStatus(g_hSvcStatus, &g_ssStatus);

done:
    return;
}

// ***************************************************************************
BOOL StartService(void)
{
    SERVICE_TABLE_ENTRYW st[] =
    {
        { g_wszSvcName, ServiceMain },
        { NULL,         NULL        }
    };

    return StartServiceCtrlDispatcherW(st);
}

// ***************************************************************************
extern "C" int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
                               LPWSTR lpCmdLine, int nShowCmd)
{
    LPWSTR  wszCmdLine = NULL;
    WCHAR   **argv;
    int     argc;

    wszCmdLine = GetCommandLineW();
    argv = CommandLineToArgvW(wszCmdLine, &argc);

    if (argc > 1)
    {
        if (_wcsicmp(argv[1], L"Install") == 0)
            return InstallService();

        if (_wcsicmp(argv[1], L"Uninstall") == 0)
            return UninstallService();
    }

    StartService();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\ersamp\ersample.cpp ===
#include <windows.h>
#include "errorrep.h"



// This is the exception filter that we will use to catch an otherwise 
//  unhandled exceptions (if a global unhandled exception filter is used)
//  or to catch exceptions that occur in a __try / __except block.

LONG MyExceptionFilter(EXCEPTION_POINTERS *pep)
{
    EFaultRepRetVal frrv;
    pfn_REPORTFAULT pfn = NULL;
    HMODULE         hmodFaultRep = NULL;
    LONG            lRet = EXCEPTION_CONTINUE_SEARCH;

    // Manually load the error reporting dll.  We could have called ReportFault
    //  directly and implicitly linked with the dll, but unexpected exceptions
    //  should not be a common scenerio so we will save resources and only load
    //  it when necessary.
    // In addition, since this feature is only available on Windows Whistler, 
    //  this will let an application continue to function when on an earlier 
    //  version of Windows.

    hmodFaultRep = LoadLibrary("faultrep.dll");
    if (hmodFaultRep != NULL)
    {
        lRet = EXCEPTION_EXECUTE_HANDLER;

        pfn = (pfn_REPORTFAULT)GetProcAddress(hmodFaultRep, "ReportFault");
        if (pfn != NULL)
            frrv = (*pfn)(pep, 0);
        else
            lRet = EXCEPTION_CONTINUE_SEARCH;

        FreeLibrary(hmodFaultRep);
    }

    return lRet;
};





int __cdecl main(int argc, char **argv)
{
    DWORD  *pdw = NULL;
    BOOL   fUseGlobalExceptionFilter = FALSE;

    // There are two ways to handle unexpected exception in applications.  
    //  Either 
    //   define a global unhandled exception filter that will get called
    //    if nothing else handles the exception.
    //   use a __try / __except block to catch exceptions and define your 
    //    own filter function.
    //  Both methods will be demonstated below.  If the user of this app passed
    //   "UseGlobalFilter" as an argument to this test application, we will 
    //   use a global unhandled exception filter.  Otherwise, we will use a 
    //   __try / __except block.

    // Use a global unhandled exception filter
    if (argc > 1 && _stricmp(argv[1], "UseGlobalFilter") == 0)
    { 
        // Set the global unhandled exception filter to the exception filter
        //  function we defined above.
        SetUnhandledExceptionFilter(MyExceptionFilter);
        
        // cause a fault
        *pdw = 1;
    }

    // Use __try / __except blocks
    else
    {
        __try
        {
            // cause a fault
            *pdw = 1;
        }

        // we need to pass the structure returned by GetExceptionInformation()
        //  to the filter.  
        // Note that the pointer returned by this function is only valid during
        //  the execution of the filter (that is, within the parenthesis of the 
        //  __except() statement).  If it needs to be saved, you must copy the
        //  contents of the structure somewhere else.
        __except(MyExceptionFilter(GetExceptionInformation()))
        {
            // we don't do anything interesting in this handler
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\gpfme\fault.cpp ===
#include <windows.h>
#include "faultrep.h"
#include "util.h"
#include "stdio.h"
#include "malloc.h"

BOOL g_fDebug = FALSE;

enum EFaultType
{
    eftAV = 0,
    eftMisalign,
    eftArrayBound,

    eftStackOverflowFunc,
    eftStackOverflowAlloc,

    eftInstrPriv,
    eftInstrBad,

    eftIntDivZero,
    eftIntOverflow,
    
    eftFltDivZero,
    eftFltOverflow,
    eftFltUnderflow,
    eftFltStack,
    eftFltInexact,
    eftFltDenormal,
    eftFltInvalid,

    eftExBadRet,
    eftExNonCont,
};

// ***************************************************************************
void ShowUsage(void)
{
    printf("\n");
    printf("gpfme [command] [exception type]\n");
    printf("\nCommand options:\n");
    printf(" -a:  Access violation (default if no command is specified)\n");
#ifndef _WIN64
    printf(" -b:  Array bound violation\n");
#endif
    printf(" -i:  Integer divide by 0 (default)\n");
    printf(" -iz: Integer divide by 0\n");
    printf(" -io: Integer overflow\n");
#ifdef _WIN64
    printf(" -m:  Data misalignment fault (not available on x86)\n");
#endif
    printf(" -s:  Stack overflow via infinite recursion (default) \n");
    printf(" -sa: Stack overflow via alloca\n");
    printf(" -sf: Stack overflow via infinite recursion\n");
    printf(" -f:  Floating point divide by 0 (default)\n");
    printf(" -fi: Floating point inexact result\n");
    printf(" -fn: Floating point invalid operation\n");
    printf(" -fo: Floating point overflow\n");
    printf(" -fu: Floating point underflow\n");
    printf(" -fz: Floating point divide by 0\n");
    printf(" -n:  Execute privilidged instruction (default)\n");
    printf(" -ni: Execute invalid instruction\n");
    printf(" -np: Execute privilidged instruction\n");
}


// ***************************************************************************
LONG MyFilter(EXCEPTION_POINTERS *pep)
{
	static BOOL		fGotHere = FALSE;

    EFaultRepRetVal frrv;
    pfn_REPORTFAULT pfn = NULL;
    HMODULE         hmodFaultRep = NULL;
    WCHAR           szDebugger[2 * MAX_PATH];
    BOOL            fGotDbgr = FALSE;
    char            wszMsg[2048];


    if (g_fDebug && 
        (pep->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT ||
         pep->ExceptionRecord->ExceptionCode == EXCEPTION_SINGLE_STEP))
         return EXCEPTION_CONTINUE_SEARCH;

    if (g_fDebug && fGotHere) 
        return EXCEPTION_CONTINUE_SEARCH;

    fGotHere = TRUE;

    if (g_fDebug)
        DebugBreak();

    if (GetProfileStringW(L"AeDebug", L"Debugger", NULL, szDebugger, sizeofSTRW(szDebugger) - 1))
        fGotDbgr = TRUE;

    hmodFaultRep = LoadLibrary("faultrep.dll");
    if (hmodFaultRep != NULL)
    {
        pfn = (pfn_REPORTFAULT)GetProcAddress(hmodFaultRep, "ReportFault");
        if (pfn != NULL)
        {
            frrv = (*pfn)(pep, fGotDbgr);
        }
        else
        {
            printf("Unable to get ReportFault function\n");
            return EXCEPTION_CONTINUE_SEARCH;
        }
    }

    else
    {
        printf("Unable to load faultrep.dll\n");
        return EXCEPTION_CONTINUE_SEARCH;
    }

    switch(frrv)
    {
        case frrvOk:
            printf("DW completed fine.\n");
            break;

        case frrvOkManifest:
            printf("DW completed fine in manifest mode.\n");
            break;

        case frrvOkQueued:
            printf("DW completed fine in queue mode.\n");
            break;

        case frrvLaunchDebugger:
            printf("DW completed fine & says to launch debugger.\n");
            break;

        case frrvErrNoDW:
            printf("DW could not be launched.\n");
            break;
            
        case frrvErr:
            printf("An error occurred.\n");
            break;

        case frrvErrTimeout:
            printf("Timed out waiting for DW to complete.\n");
            break;

        default:
            printf("unexpected return value...\n");
            break;

    }

    if (hmodFaultRep != NULL)
        FreeLibrary(hmodFaultRep);

    return EXCEPTION_EXECUTE_HANDLER;
};


// ***************************************************************************
void NukeStack(void)
{
    DWORD   rgdw[512];
    DWORD   a = 1;

    // the compiler tries to be smart and not let me deliberately write a 
    //  infinitely recursive function, so gotta do this to work around it.
    if(a == 1)
        NukeStack();
}

// ***************************************************************************
typedef DWORD (*FAULT_FN)(void);
void DoException(EFaultType eft)
{
    switch(eft)
    {
        // access violation
        default:
        case eftAV:
        {
            int *p = NULL;

            fprintf(stderr, "Generating an access violation\n");
            *p = 1;
            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }

#ifdef _WIN64
        // data misalignment
        case eftMisalign:
        {
            DWORD   *pdw;
            BYTE    rg[8];

            fprintf(stderr, "Generating an misalignment fault.\n");
            pdw = (DWORD *)&rg[2];
            *pdw = 1;
            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }
#endif

#ifndef _WIN64
        // array bounds failure
        case eftArrayBound:
        {
            fprintf(stderr, "Generating an out-of-bounds exception\n");

            __int64 li;
            DWORD   *pdw = (DWORD *)&li;

            *pdw = 1;
            pdw++;
            *pdw = 2;

            // bound will throw an 'array out of bounds' exception
            _asm mov eax, 0
            _asm bound eax, li
            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }
#endif

        // stack overflow
        case eftStackOverflowFunc:
        {
            fprintf(stderr, "Generating an stack overflow via recursion\n");
            NukeStack();
            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }

        // stack overflow
        case eftStackOverflowAlloc:
        {
            LPVOID  pv;
            DWORD   i;

            fprintf(stderr, "Generating an stack overflow via alloca\n");
            for (i = 0; i < 0xffffffff; i++)
                pv = _alloca(512);
            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }

        // integer divide by 0
        case eftIntDivZero:
        {
            DWORD x = 4, y = 0;

            fprintf(stderr, "Generating an integer div by 0\n");
            x = x / y;
            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }

        // integer overflow
        case eftIntOverflow:
        {

            fprintf(stderr, "Generating an integer overflow\n");
#ifdef _WIN64
            __int64 x = 0x7fffffffffffffff, y = 0x7fffffffffffffff;
            x = x + y;
#else
            DWORD x = 0x7fffffff, y = 0x7fffffff;
            x = x + y;
            _asm into
#endif
            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }

        // floating point divide by 0
        case eftFltDivZero:
        {
            double x = 4.1, y = 0.0;
            WORD   wCtl, wCtlNew;

            fprintf(stderr, "Generating an floating point div by 0\n");

#ifdef _WIN64
            x = x / y;
#else
            // got to unmask the floating point exceptions so that the
            //  processor doesn't handle them on it's own
            _asm fnstcw wCtl
            wCtlNew = wCtl & 0xffc0;
            _asm fldcw wCtlNew
            x = x / y;
            _asm fldcw wCtl
#endif
            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }

        // floating point stack overflow
        case eftFltStack:
        {
            double x;
            WORD   wCtl, wCtlNew;

            fprintf(stderr, "Generating an floating point stack overflow\n");

#ifdef _WIN64
#else
            // Got to unmask the floating point exceptions so that the
            //  processor doesn't handle them on it's own
            _asm fnstcw wCtl
            wCtlNew = wCtl & 0xffc0;
            _asm fldcw wCtlNew

            // there should be 8 floating point stack registers, so attempting
            //  to add a 9th element should nuke it
            _asm fld x
            _asm fld x
            _asm fld x
            _asm fld x
            _asm fld x
            _asm fld x
            _asm fld x
            _asm fld x
            _asm fld x
            _asm fldcw wCtl
#endif
            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }
        
        // floating point overflow
        case eftFltOverflow:
        {
            double x = 1.0, y = 10.0;
            WORD   wCtl, wCtlNew;
            DWORD  i;

            fprintf(stderr, "Generating an floating point overflow\n");

#ifdef _WIN64
#else
            // Got to unmask the floating point exceptions so that the
            //  processor doesn't handle them on it's own
            _asm fnstcw wCtl
            wCtlNew = wCtl & 0xffe0;
            _asm fldcw wCtlNew
#endif
            
            for(i = 0; i < 100000; i++)
                x = x * y;

            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }

        // floating point invalid op
        case eftFltInvalid:
        {
            double x = 1.0, y = 10.0;
            WORD   wCtl, wCtlNew;
            DWORD  i;

#ifdef _WIN64
#else
            // Got to unmask the floating point exceptions so that the
            //  processor doesn't handle them on it's own
            _asm fnstcw wCtl
            wCtlNew = wCtl & 0xffe0;
            _asm fldcw wCtlNew
#endif

            fprintf(stderr, "Generating an floating point invalid operation\n");
            for(i = 0; i < 100000; i++)
                x = x / y;

            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }

        // floating point inexact result
        case eftFltInexact:
        {
            double x = 1.0, y = 10.0;
            WORD   wCtl, wCtlNew;
            DWORD  i;

#ifdef _WIN64
#else
            // Got to unmask the floating point exceptions so that the
            //  processor doesn't handle them on it's own
            _asm fnstcw wCtl
            wCtlNew = wCtl & 0xffc0;
            _asm fldcw wCtlNew
#endif

            fprintf(stderr, "Generating an floating point underflow\n");
            for(i = 0; i < 100000; i++)
                x = x / y;

            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }

        // floating point denormal value
        case eftFltDenormal:
        {
            double  x = 1.0;
            DWORD   i;
            WORD    wCtl, wCtlNew;
            BYTE    rg[8] = { 1, 0, 0, 0, 0, 0, 6, 0 };

            fprintf(stderr, "Generating a floating point denormal exception\n");

#ifdef _WIN64
#else
            // Got to unmask the floating point exceptions so that the
            //  processor doesn't handle them on it's own
            memcpy(&x, rg, 8);
            _asm fnstcw wCtl
            wCtlNew = wCtl & 0xf2fc;
            _asm fldcw wCtlNew
            _asm fld x
#endif

            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }

        // executing a privilidged instruction
        case eftInstrPriv:
        {
            fprintf(stderr, "Generating an privilidged instruction exception\n");

#ifdef _WIN64
#else
            // must be ring 0 to execute HLT
            _asm hlt
#endif
            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }

        // executing an invalid instruction
        case eftInstrBad:
        {
            FAULT_FN    pfn;
            BYTE        rgc[2048];

            FillMemory(rgc, sizeof(rgc), 0);
            pfn = (FAULT_FN)(DWORD_PTR)rgc;

            fprintf(stderr, "Generating an invalid instruction exception\n");
            (*pfn)();

            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }

        case eftExNonCont:
        {
            fprintf(stderr, "Generating an non-continuable exception- **not implemented**\n");
            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }

        case eftExBadRet:
        {
            fprintf(stderr, "Generating an bad exception filter exception- **not implemented**\n");
            fprintf(stderr, "Error: No exception thrown.\n");
            break;
        }
    }
}

// ***************************************************************************
int __cdecl main(int argc, char **argv)
{
    EFaultType  eft = eftAV;
    BOOL        fCheckDebug = FALSE;
    BOOL        fUseTry = FALSE;
    BOOL        fUseFilter = FALSE;

    if (argc >= 3 && (argv[2][0] == '/' || argv[2][0] == '-'))
    {
        switch(argv[2][1])
        {
            case 't':
            case 'T':
                if (argv[2][2] == 'D' || argv[2][2] == 'd')
                    g_fDebug = TRUE;
                fUseTry = TRUE;
                break;
            
            case 'g':
            case 'G':
                if (argv[2][2] == 'D' || argv[2][2] == 'd')
                    g_fDebug = TRUE;
                fUseFilter = TRUE;
                break;
        }
    }

    if (argc >= 2 && (argv[1][0] == '/' || argv[1][0] == '-'))
    {
        switch(argv[1][1])
        {
            case 't':
            case 'T':
                if (argv[1][2] == 'D' || argv[1][2] == 'd')
                    g_fDebug = TRUE;
                fUseTry = TRUE;
                break;
            
            case 'g':
            case 'G':
                if (argv[1][2] == 'D' || argv[1][2] == 'd')
                    g_fDebug = TRUE;
                fUseFilter = TRUE;
                break;

            // AV
            default:
            case 'a':
            case 'A':
                eft = eftAV;
                break;
#ifndef _WIN64
            // array bounds
            case 'b':
            case 'B':
                eft = eftArrayBound;
                break;
#endif

#ifdef _WIN64
            // Misalignment
            case 'm':
            case 'M':
                eft = eftMisalign;
                break;
#endif

            // Stack overflow
            case 's':
            case 'S':
                switch(argv[1][2])
                {
                    default:
                    case 'f':
                    case 'F':
                        eft = eftStackOverflowFunc;
                        break;

                    case 'a':
                    case 'A':
                        eft = eftStackOverflowAlloc;
                        break;
                };
                break;

            // integer exceptions
            case 'i':
            case 'I':
                switch(argv[1][2])
                {
                    default:
                    case 'z':
                    case 'Z':
                        eft = eftIntDivZero;
                        break;

                    case 'o':
                    case 'O':
                        eft = eftIntOverflow;
                        break;
                };
                break;

            // floating point exceptions
            case 'f':
            case 'F':
                switch(argv[1][2])
                {
                    default:
                    case 'z':
                    case 'Z':
                        eft = eftFltDivZero;
                        break;

                    case 'o':
                    case 'O':
                        eft = eftFltOverflow;
                        break;

                    case 'u':
                    case 'U':
                        eft = eftFltUnderflow;
                        break;

                    case 'S':
                    case 's':
                        eft = eftFltStack;
                        break;

                    case 'I':
                    case 'i':
                        eft = eftFltInexact;
                        break;

                    case 'D':
                    case 'd':
                        eft = eftFltDenormal;
                        break;

                    case 'N':
                    case 'n':
                        eft = eftFltInvalid;
                        break;
                };
                break;

            // CPU instruction exceptions
            case 'n':
            case 'N':
                switch(argv[1][2])
                {
                    default:
                    case 'p':
                    case 'P':
                        eft = eftInstrPriv;
                        break;

                    case 'i':
                    case 'I':
                        eft = eftInstrBad;
                        break;
                };
                break;

            case 'E':
            case 'e':
                switch(argv[1][2])
                {
                    default:
                    case 'n':
                    case 'N':
                        eft = eftExNonCont;
                        break;

                    case 'i':
                    case 'I':
                        eft = eftExBadRet;
                        break;
                };
                break;

            // help
            case '?':
                ShowUsage();
                return 0;
        }
    }
    else
    {
        eft = eftAV;
    }

    if (fUseFilter)
    {
        fUseTry = FALSE;
        SetUnhandledExceptionFilter(MyFilter);
    }

    if (fUseTry)
    {
        __try
        {
            DoException(eft);
        }
        __except(MyFilter(GetExceptionInformation()))
        {
        }
    }

    else
    {
        DoException(eft);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\hungapp\hangc\hangc.cpp ===
#include "windows.h"
#include "wchar.h"
#include "stdio.h"

int _cdecl wmain(int argc, WCHAR **argv)
{
    HANDLE hev = NULL;

    if (argc < 2)
    {
        printf("\nUsage:\nhangmec <event name>\n", argv[0]);
        return -1;
    }

    hev = CreateEventW(NULL, TRUE, FALSE, argv[1]);
    if (hev == NULL)
    {
        printf("\nUnable to create event %ls.\n", argv[1]);
        return -1;
    }

    printf("hangmec.exe is now hung.  Use \"unhang.exe %ls\" to 'unhang' the app...\n", argv[1]);
    for(;;)
    {
        if (WaitForSingleObject(hev, 0) != WAIT_TIMEOUT)
            break;

        Sleep(1);
    }

    printf("hangmec.exe will terminate.\n");

    CloseHandle(hev);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\hungapp\hangcom\hang.h ===
// Hang.h : Declaration of the CHang

#ifndef __HANG_H_
#define __HANG_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CHang
class ATL_NO_VTABLE CHang : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CHang, &CLSID_Hang>,
	public IDispatchImpl<IHang, &IID_IHang, &LIBID_HANGCOMLib>
{
public:
    CHang() { }

DECLARE_REGISTRY_RESOURCEID(IDR_Hang)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHang)
	COM_INTERFACE_ENTRY(IHang)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IHang
public:
	STDMETHOD(DoHang)(UINT64 hev, DWORD dwpid);
};

#endif //__HANG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\hungapp\hangcom\resource.h ===
// Microsoft Developer Studio generated include file.
// Used by hangcom.rc
//
#define IDR_Hangcom                     100
#define IDR_Hang                        101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\hungapp\hangw\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hangw.rc
//
#define IDD_HANG                        101
#define IDC_HANG                        1000
#define IDC_LOOP                        1002
#define IDC_EVENT                       1003
#define IDC_PIPE                        1004
#define IDC_COM                         1005
#define IDC_MYTEXT                      1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\hungapp\hangcom\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__46ABEB2E_ABE3_4145_BB63_24C7C98C952E__INCLUDED_)
#define AFX_STDAFX_H__46ABEB2E_ABE3_4145_BB63_24C7C98C952E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#include "Shellapi.h"

#endif // !defined(AFX_STDAFX_H__46ABEB2E_ABE3_4145_BB63_24C7C98C952E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\hungapp\hangcom\hangcom.cpp ===
// hangcom.cpp : Implementation of WinMain


#include "stdafx.h"
#include "resource.h"

#include <initguid.h>
#include <hangcom.h>
#include "Hang.h"



const DWORD g_dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD g_dwPause   = 1000; // time to wait for threads to finish up

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Hang, CHang)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHang

// **************************************************************************
STDMETHODIMP CHang::DoHang(UINT64 hev, DWORD dwpid)
{
    HANDLE  rghWait[2] = { NULL, NULL }, hevRemote, hprocRemote;
    DWORD   cWait = 1;

    hevRemote = (HANDLE)hev;
    
    rghWait[0] = CreateEventW(NULL, FALSE, FALSE, NULL);
    if (rghWait[0] == NULL)
        return HRESULT_FROM_WIN32(GetLastError());
    
    if (hevRemote != NULL)
    {
        hprocRemote = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwpid);
        if (hprocRemote != NULL)
        {
            if (DuplicateHandle(hprocRemote, hevRemote, GetCurrentProcess(),
                                &rghWait[1], SYNCHRONIZE, FALSE, 0))
                cWait = 2;
            else
                rghWait[1] = NULL;

            CloseHandle(hprocRemote);
        }
    }

	WaitForMultipleObjects(cWait, rghWait, FALSE, INFINITE);

	CloseHandle(rghWait[0]);
	if (rghWait[1] != NULL)
	    CloseHandle(rghWait[1]);
    
    return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// main stuff

// **************************************************************************
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

// **************************************************************************
LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

// **************************************************************************
void CExeModule::MonitorShutdown()
{
    DWORD dwWait = 0;

    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, g_dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);

        // timed out
        if (bActivity == false && m_nLockCnt == 0)
                break;
    }

    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

// **************************************************************************
bool CExeModule::StartMonitor()
{
    HANDLE  hth;
    DWORD   dwThreadID;

    hEventShutdown = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hEventShutdown == NULL)
        return false;

    hth = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    if (hth != NULL)
    {
        CloseHandle(hth);
        return true;
    }
    else
    {
        return false;
    }
}


// **************************************************************************
extern "C" int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, LPWSTR, int)
{
    HRESULT hr = NOERROR;
    LPWSTR  *argv, wszArg;
    MSG     msg;
    int     argc, i, nRet;
    
    argv = CommandLineToArgvW(GetCommandLineW(), &argc);
    hr = CoInitialize(NULL);
    _ASSERTE(SUCCEEDED(hr));

    _Module.Init(ObjectMap, hInstance, &LIBID_HANGCOMLib);
    _Module.dwThreadID = GetCurrentThreadId();

    for (i = 1; i < argc; i++)
    {
        wszArg = argv[i];
        if (*wszArg == L'/' || *wszArg == L'-')
        {
            wszArg++;
            if (_wcsicmp(wszArg, L"uninstall") == 0)
            {
                _Module.UpdateRegistryFromResource(IDR_Hangcom, FALSE);
                nRet = _Module.UnregisterServer(TRUE);
                goto done;
            }
            else if (_wcsicmp(wszArg, L"install") == 0)
            {
                _Module.UpdateRegistryFromResource(IDR_Hangcom, TRUE);
                nRet = _Module.RegisterServer(TRUE);
                goto done;
            }
        }
    }

    _Module.StartMonitor();
    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
                                      REGCLS_MULTIPLEUSE);
    _ASSERTE(SUCCEEDED(hr));

    while (GetMessage(&msg, 0, 0, 0))
        DispatchMessage(&msg);

    _Module.RevokeClassObjects();
    Sleep(g_dwPause);

    _Module.Term();

done:
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\hungapp\hangw\hangw.cpp ===
#include "windows.h"
#include "shellapi.h"
#include "wchar.h"
#include "stdio.h"

#include <initguid.h>
#include "hangcom.h"

#include "resource.h"

enum EHangToUse
{
    htuLoop  = IDC_LOOP,
    htuEvent = IDC_EVENT,
    htuPipe  = IDC_PIPE,
    htuCOM   = IDC_COM,
};

struct SDlgInit
{
    EHangToUse  htu;
    HANDLE      hev;
    LPWSTR      wsz;
};

BOOL g_fImmediate = FALSE;

// **************************************************************************
void HangmeSleepLoop(HANDLE hevUnhang)
{
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);

    DWORD dw = 0;
    
    for(;;)
    {
        dw += 1;
        dw *= 2;
        dw %= 101;
        dw /= 2;
    }

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
}

// **************************************************************************
void HangmeEvent(HANDLE hevUnhang)
{
    HANDLE  hev = NULL;
    HANDLE  rghWait[2] = { NULL, NULL };
    DWORD   cWait;

    hev = CreateEventW(NULL, FALSE, FALSE, NULL);
    if (hev == NULL)
        return;

    rghWait[0] = hev;
    cWait      = 1;
    if (hevUnhang)
    {
        rghWait[1] = hevUnhang;
        cWait      = 2;
    }

    WaitForMultipleObjects(cWait, rghWait, FALSE, INFINITE);
    CloseHandle(hev);
    return;
}

// **************************************************************************
void HangmePipe(HANDLE hevUnhang)
{
    OVERLAPPED  ol;
    HANDLE      hpipe = NULL, hev = NULL;
    HANDLE      rghWait[2] = { NULL, NULL };
    DWORD       cWait, dwMsg;
    BOOL        fRet;

    hev = CreateEventW(NULL, FALSE, FALSE, NULL);
    if (hev == NULL)
        return;

    hpipe = CreateNamedPipeW(L"\\\\.\\pipe\\ERHangTestPipeThisIsOnlyATest", 
                             PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                             PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
                             1, sizeof(dwMsg), sizeof(dwMsg),
                             60000, NULL);
    if (hpipe == NULL)
        return;

    ZeroMemory(&ol, sizeof(ol));
    ol.hEvent = hev;

    fRet = ConnectNamedPipe(hpipe, &ol);
    if (GetLastError() != ERROR_IO_PENDING)
        SetEvent(ol.hEvent);

    rghWait[0] = hev;
    cWait      = 1;
    if (hevUnhang)
    {
        rghWait[1] = hevUnhang;
        cWait      = 2;
    }
   
    WaitForMultipleObjects(cWait, rghWait, FALSE, INFINITE);
    CloseHandle(hev);
    return; 
}

// **************************************************************************
void HangmeCOM(HANDLE hevUnhang)
{
    HRESULT hr;
    IHang   *pHang = NULL;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
        return;

    hr = CoCreateInstance(CLSID_Hang, NULL, CLSCTX_SERVER, IID_IHang, 
                          (LPVOID *)&pHang);
    if (FAILED(hr))
    {
        CoUninitialize();
        return;
    }

    hr = pHang->DoHang((UINT64)hevUnhang, GetCurrentProcessId());

    CoUninitialize();
    
    return; 
}

// **************************************************************************
INT_PTR CALLBACK dlgFn(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SDlgInit    *pdlginit;
    WCHAR       wszBuffer[1024];
    HWND        hwnd;

    switch(uMsg)
    {
        case WM_PAINT:
            if (g_fImmediate)
            {
                g_fImmediate = FALSE;
                PostMessage(hdlg, WM_COMMAND, IDC_HANG, 0);
            }
            break;
        
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
              
                case IDOK:
                case IDCANCEL:
                    EndDialog(hdlg, LOWORD(wParam));
                    break;

                case IDC_HANG:
                    // do this so that this message will return
                    PostMessage(hdlg, WM_APP, 0, 0);
                    break;

                default:
                    break;
            }

            break;  

        case WM_INITDIALOG:
            pdlginit = (SDlgInit *)lParam;
            SetWindowLongPtr(hdlg, GWLP_USERDATA, lParam);
            
            CheckRadioButton(hdlg, IDC_LOOP, IDC_COM, (int)pdlginit->htu);

            // set the notify field
            if (pdlginit->wsz != NULL)
            {
                wsprintfW(wszBuffer, L"Click the 'Hang' Button below to hang this window.  The dialog will not repaint while hung .\nExecute 'unhang.exe %ls' to reawaken the app.", pdlginit->wsz);
                hwnd = GetDlgItem(hdlg, IDC_MYTEXT);
                SetWindowTextW(hwnd, wszBuffer);
            }
            break;

        case WM_APP:
            pdlginit = (SDlgInit *)GetWindowLongPtr(hdlg, GWLP_USERDATA);
            if (IsDlgButtonChecked(hdlg, IDC_COM) == BST_CHECKED)
                HangmeCOM(pdlginit->hev);
            else if (IsDlgButtonChecked(hdlg, IDC_PIPE) == BST_CHECKED)
                HangmePipe(pdlginit->hev);
            else if (IsDlgButtonChecked(hdlg, IDC_EVENT) == BST_CHECKED)
                HangmeEvent(pdlginit->hev);
            else if (IsDlgButtonChecked(hdlg, IDC_LOOP) == BST_CHECKED)
                HangmeSleepLoop(pdlginit->hev);

            break;
    }

    return FALSE;
}

// **************************************************************************
extern "C" int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, LPWSTR, int)
{
    SDlgInit    sdi;
    WCHAR       **argv, *wszCmdLine, *wszEvent = NULL;
    int         argc, i;

    wszCmdLine = GetCommandLineW();
    argv = CommandLineToArgvW(wszCmdLine, &argc);

    ZeroMemory(&sdi, sizeof(sdi));
    sdi.htu = htuLoop;

    if (argc == 2 && argv[1][0] != L'/' && argv[1][0] != L'-')
    {
        wszEvent = argv[1];
    }
    else
    {
        for(i = 1; i < argc; i++)
        {
            if (argv[i][0] == L'/' || argv[i][0] == L'-')
            {
                switch(argv[i][1])
                {
                    case L'L':
                    case L'l':
                        sdi.htu = htuLoop;
                        break;

                    case L'E':
                    case L'e':
                        sdi.htu = htuEvent;
                        break;

                    case L'C':
                    case L'c':
                        sdi.htu = htuCOM;
                        break;

                    case L'P':
                    case L'p':
                        sdi.htu = htuPipe;
                        break;

                    case L'U':
                    case L'u':
                        if (i + 1 < argc)
                            wszEvent = argv[++i];
                        break;

                    case L'G':
                    case L'g':
                        g_fImmediate = TRUE;
                        break;
                }
            }
        }
    }

    if (wszEvent != NULL)
    {
        sdi.hev = CreateEventW(NULL, TRUE, FALSE, wszEvent);
        if (sdi.hev == NULL)
        {
            WCHAR wszBuf[256];
            wsprintfW(wszBuf, L"Unable to create event %ls.", wszEvent);
            MessageBoxW(NULL, wszBuf, NULL, MB_OK);
        }
        else
        {
            sdi.wsz = wszEvent;
        }
    }

    DialogBoxParamW(hInstance, MAKEINTRESOURCEW(IDD_HANG), NULL, dlgFn, (LPARAM)&sdi);

    if (sdi.hev !=- NULL)
        CloseHandle(sdi.hev);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\hungapp\unhang\unhang.cpp ===
#include "windows.h"
#include "wchar.h"
#include "stdio.h"

int _cdecl wmain(int argc, WCHAR **argv)
{
    HANDLE hev = NULL;

    if (argc < 2)
    {
        printf("\nUsage:\nunhang <event name>\n", argv[0]);
        return -1;
    }

    hev = OpenEventW(EVENT_MODIFY_STATE, FALSE, argv[1]);
    if (hev == NULL)
    {
        printf("\nUnable to open event %ls.\n", argv[1]);
        return -1;
    }

    SetEvent(hev);
    CloseHandle(hev);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\mdpipe\mdpipe.cpp ===
#define NOTRACE 1

#include "windows.h"
#include "util.h"
#include "faultrep.h"
#include "pchrexec.h"
#include "stdio.h"
#include "stdlib.h"

// ***************************************************************************
LPWSTR MarshallString(LPCWSTR wszSrc, PBYTE pBase, ULONG cbMaxBuf, 
                      PBYTE *ppToWrite, DWORD *pcbWritten)
{
    DWORD cb;
    PBYTE pwszNormalized;

    cb = (wcslen(wszSrc) + 1) * sizeof(WCHAR);

    if ((*pcbWritten + cb) > cbMaxBuf)
        return NULL;

    RtlMoveMemory(*ppToWrite, wszSrc, cb);

    // the normalized ptr is the current count
    pwszNormalized = (PBYTE)(*ppToWrite - pBase);

    // cb is always a mutliple of sizeof(WHCAR) so the pointer addition below
    //  always produces a result that is 2byte aligned (assuming the input was
    //  2byte aligned of course)
    *ppToWrite  += cb;
    *pcbWritten += cb;

    return (LPWSTR)pwszNormalized;
}

// **************************************************************************
EFaultRepRetVal PrepareUserManifest(LPWSTR wszExe, DWORD dwSession, 
                                    DWORD dwProc, DWORD dwThread)
{
    SPCHExecServDWRequest   *pesdwreq = NULL;
    SPCHExecServDWReply     *pesrep = NULL;
    EFaultRepRetVal         frrvRet = frrvErrNoDW;
    HRESULT                 hr = NOERROR;
    DWORD                   cbReq, cbRead;
    WCHAR                   wszName[MAX_PATH];
    BYTE                    Buf[HANGREP_EXECSVC_BUF_SIZE], *pBuf;
    BYTE                    BufRep[HANGREP_EXECSVC_BUF_SIZE];

    VALIDATEPARM(hr, (wszExe == NULL));
    if (FAILED(hr))
        goto done;

    ZeroMemory(&Buf, sizeof(Buf));
    pesdwreq = (SPCHExecServDWRequest *)Buf;
    cbReq = ((sizeof(SPCHExecServDWRequest) * sizeof(WCHAR)) + sizeof(WCHAR) - 1) / sizeof(WCHAR);
    pBuf = Buf + cbReq;

    pesdwreq->cbESR         = sizeof(SPCHExecServDWRequest);
    pesdwreq->pidReqProcess = dwProc;
    pesdwreq->thidFault     = dwThread;
    pesdwreq->ulSessionId   = dwSession;
    pesdwreq->pvFaultAddr   = (UINT64)UnhandledExceptionFilter;
#ifdef _WIN64
    pesdwreq->fIs64bit      = TRUE;
#else
    pesdwreq->fIs64bit      = FALSE;
#endif

    // marshal in the strings
    pesdwreq->wszExe = (UINT64)MarshallString(wszExe, Buf, sizeof(Buf), &pBuf, 
                                              &cbReq);
    if (pesdwreq->wszExe == 0)
        goto done;

    pesdwreq->cbTotal = cbReq;

    // check and see if the system is shutting down.  If so, CreateProcess is 
    //  gonna pop up some annoying UI that we can't get rid of, so we don't 
    //  want to call it if we know it's gonna happen.
    if (GetSystemMetrics(SM_SHUTTINGDOWN))
        goto done;

    // Send the buffer out to the server- wait at most 2m for this to
    //  succeed.  If it times out, bail.
    wcscpy(wszName, HANGREP_EXECSVC_DWPIPE);
    TESTBOOL(hr, CallNamedPipeW(wszName, Buf, cbReq, &BufRep, sizeof(BufRep),
                                &cbRead, 120000));
    if (FAILED(hr))
    {
        // determine the error code that indicates whether we've timed out so
        //  we can set the return code appropriately.
        goto done;
    }

    pesrep = (SPCHExecServDWReply *)BufRep;

    // did the call succeed?
    VALIDATEEXPR(hr, (pesrep->fRet == FALSE), Err2HR(pesrep->dwErr));
    if (FAILED(hr))
    {
        fprintf(stdout, "Named pipe call failed: 0x%08x\n", pesrep->dwErr);
        SetLastError(pesrep->dwErr);
        goto done;
    }
    else
    {
        fprintf(stdout, "Named pipe call success\n");
    }

    // gotta wait for DW to be done before we nuke the manifest file, but if 
    //  it hasn't parsed it in 5 minutes, something's wrong with it.
    if (WaitForSingleObject(pesrep->pi.hProcess, 300000) == WAIT_TIMEOUT)
    {
        frrvRet = frrvErrTimeout;
    }

    // we're only going to delete the files if DW has finished with them.  Yes
    //  this means we can leave stray files in the temp dir, but this is better
    //  than having DW randomly fail while sending...
    else
    {
        if (pesrep->wszDump != 0)
        {
            if (pesrep->wszDump < cbRead && 
                pesrep->wszDump >= sizeof(SPCHExecServDWReply))
                pesrep->wszDump += (UINT64)pesrep;
            else
                pesrep->wszDump = 0;
        }

        if (pesrep->wszDump != 0)
            fprintf(stdout, "Dump file: %ls\n", pesrep->wszDump);

        if (pesrep->wszManifest != 0)
        {
            if (pesrep->wszManifest < cbRead && 
                pesrep->wszManifest >= sizeof(SPCHExecServDWReply))
                pesrep->wszManifest += (UINT64)pesrep;
            else
                pesrep->wszManifest = 0;
        }

        if (pesrep->wszManifest != 0)
            fprintf(stdout, "Manifest file: %ls\n", pesrep->wszDump);
    }

    CloseHandle(pesrep->pi.hProcess);
    CloseHandle(pesrep->pi.hThread);

    frrvRet = frrvOkManifest;
    SetLastError(0);

done:
    return frrvRet;
}

// **************************************************************************
void __cdecl wmain(int argc, WCHAR **argv)
{
    DWORD dwPID;
    DWORD dwThID;
    DWORD dwSession;
    WCHAR *wszExe;

    if (argc < 4 || argc > 5)
    {
        fprintf(stdout, "Usage:\nmdpipe <exe name> <PID> <Thread ID> [<Session ID>]\n");
        return;
    }
    wszExe = argv[1];
    dwPID  = _wtol(argv[2]);
    dwThID = _wtol(argv[3]);
    if (argc == 5)
        dwSession = _wtol(argv[4]);
    else
        ProcessIdToSessionId(GetCurrentProcessId(), &dwSession);

    PrepareUserManifest(wszExe, dwSession, dwPID, dwThID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\nukeapp\nukeapp.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define STACKSIZE 32768

void DebugPriv(void)
{
    PTOKEN_PRIVILEGES   pp;
    PTOKEN_PRIVILEGES   ppNew;
    HANDLE              hToken;
    UCHAR               ucPriv[sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)];
    UCHAR               ucPrivNew[sizeof(ucPriv)];
    DWORD               cb;

    if (OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, &hToken))
    {
        pp = (PTOKEN_PRIVILEGES)ucPriv;

        pp->PrivilegeCount              = 1;
        pp->Privileges[0].Luid.LowPart  = 20L;
        pp->Privileges[0].Luid.HighPart = 0;
        pp->Privileges[0].Attributes    = SE_PRIVILEGE_ENABLED;

        ppNew = (PTOKEN_PRIVILEGES)ucPrivNew ;

        AdjustTokenPrivileges(hToken, FALSE, pp, sizeof(ucPrivNew), ppNew, &cb);

        CloseHandle(hToken);
    }
}


int __cdecl main(int argc, char **argv)
{
    LPTHREAD_START_ROUTINE  pfnDBP = NULL;
    HMODULE                 hmodntdll;
    HANDLE                  hProcess;
    HANDLE                  hThread;
    ULONG                   ProcessId;
    ULONG                   ThreadId;

    if (argc < 2 || argc > 3)
    {
        fprintf(stderr, "usage: nukeapp <pid> [-breakin]\n");
        return 1;
    }

    ProcessId = atoi(argv[1]);

    if (ProcessId == 0) 
    {
        fprintf(stderr, "usage: nukeapp <pid> [-breakin]\n");
        return 1;
    }

    DebugPriv();

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId);
    if (hProcess != NULL) 
    {
        hmodntdll = GetModuleHandle("ntdll.dll");
        if (hmodntdll != NULL)
        {
            if (argc == 3 && _strcmpi(argv[2], "-breakin") == 0)
                pfnDBP = (LPTHREAD_START_ROUTINE)GetProcAddress(hmodntdll, "DbgBreakPoint");

            hThread = CreateRemoteThread(hProcess, NULL, STACKSIZE, pfnDBP, NULL, 0, &ThreadId);
            if (hThread == NULL)
                fprintf(stderr, "Unable to create remote thread.\n");

        }
    }
    else
    {
        fprintf(stderr, "Unable to open process.\n");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\rexec\cli\precomp.h ===
#include "windows.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\rexec\cli\reclient.h ===
#ifndef RECLIENT_H
#define RECLIENT_H

BOOL CreateRemoteProcessW(ULONG ulSessionId, HANDLE hToken, LPWSTR wszCmdLine,
                          DWORD fdwCreateFlags, LPSTARTUPINFOW psi,
                          LPPROCESS_INFORMATION ppi);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\rexec\cli\main.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntpsapi.h>
#include <stdio.h>
#include <windows.h>

#include "reclient.h"
#include "wchar.h"



void __cdecl wmain(int argc, WCHAR **argv)
{
    PROCESS_SESSION_INFORMATION psi;
    PROCESS_INFORMATION         pi;
    STARTUPINFOW                si;
    NTSTATUS                    nts;
    HANDLE                      hProcess = NULL;
    HANDLE                      hToken = NULL;
    DWORD                       dwpid = 0;

    if (argc < 3)
    {
        printf("Usage:\nrecli.exe <pid of process to imitate> <full path to app to run>\n");
        goto done;
    }

    dwpid = _wtol(argv[1]);
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwpid);
    if (hProcess == NULL)
    {
        printf("Could not open process %d: 0x%08x\n", dwpid, GetLastError());
        goto done;
    }

    if (OpenProcessToken(hProcess, TOKEN_ALL_ACCESS, &hToken) == FALSE)
    {
        printf("Could not open process token %d: 0x%08x\n", dwpid, GetLastError());
        goto done;
    }

    nts = NtQueryInformationProcess(hProcess, ProcessSessionInformation, &psi, sizeof(psi), NULL);
    if (NT_SUCCESS(nts) == FALSE)
    {
        printf("Could not get the session ID %d: 0x%08x\n", dwpid, GetLastError());
        goto done;
    }
    
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    if (CreateRemoteProcessW(psi.SessionId, hToken, argv[2], 0, &si, &pi) == FALSE)
    {
        printf("Could not create remote process %ls: 0x%08x\n", argv[2], GetLastError());
        goto done;
    }

    printf("Created pid %d\n", pi.dwProcessId);
    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

done:
    if (hToken == NULL)
        CloseHandle(hToken);
    if (hProcess == NULL)
        CloseHandle(hProcess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\rexec\cli\reclient.c ===
#include "precomp.h"
#include <pchrexec.h>
#include "reclient.h"

// ***************************************************************************
LPWSTR MarshallString(LPWSTR wszSrc, PBYTE pBase, ULONG cbMaxBuf, 
                      PBYTE *ppToWrite, DWORD *pcbWritten)
{
    DWORD cb;
    PBYTE pwszNormalized;

    cb = (wcslen(wszSrc) + 1) * sizeof(WCHAR);

    if ((*pcbWritten + cb) > cbMaxBuf)
        return NULL;

    RtlMoveMemory(*ppToWrite, wszSrc, cb);

    // the normalized ptr is the current count
    pwszNormalized = (PBYTE)(*ppToWrite - pBase);

    // cb is always a mutliple of sizeof(WHCAR) so the pointer addition below
    //  always produces a result that is 2byte aligned (assuming the input was
    //  2byte aligned of course)
    *ppToWrite  += cb;
    *pcbWritten += cb;

    return (LPWSTR)pwszNormalized;
}

// ***************************************************************************
BOOL CreateRemoteProcessW(ULONG ulSessionId, HANDLE hToken, LPWSTR wszCmdLine,
                          DWORD fdwCreateFlags, LPSTARTUPINFOW psi,
                          LPPROCESS_INFORMATION ppi)
{
    SPCHExecServRequest *pesreq;
    SPCHExecServReply   esrep;
    DWORD               cbWrote, cbRead, cbReq;
    WCHAR               wszPipeName[MAX_PATH];
    BYTE                Buf[HANGREP_EXECSVC_BUF_SIZE];
    BYTE                *pBuf;
    BOOL                fRet = FALSE;

    // validate params
    if (hToken == NULL || wszCmdLine == NULL || ppi == NULL || psi == NULL ||
        psi->cb != sizeof(STARTUPINFOW))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    wcscpy(wszPipeName, HANGREP_EXECSVC_PIPENAME);

    // setup the marshalling- make sure that pBuf is aligned on a 2byte
    //  boundary beacause we'll be writing WCHAR buffers to it.
    ZeroMemory(Buf, sizeof(Buf));
    pesreq  = (SPCHExecServRequest *)Buf;
    cbReq   = ((sizeof(SPCHExecServRequest) * sizeof(WCHAR)) + sizeof(WCHAR) - 1) / sizeof(WCHAR);
    pBuf    = Buf + cbReq;

    // set the basic parameters
    pesreq->cbESR          = sizeof(SPCHExecServRequest);
    pesreq->pidReqProcess  = GetCurrentProcessId();
    pesreq->hToken         = hToken;
    pesreq->ulSessionId    = ulSessionId;
    pesreq->fdwCreateFlags = fdwCreateFlags;

    // copy in the StartupInfo structure
    RtlMoveMemory(&pesreq->si, psi, sizeof(pesreq->si));

    // marshall all the strings we send across the wire.

    // CommandLine
    if (wszCmdLine != NULL)
    {
        pesreq->wszCmdLine = MarshallString(wszCmdLine, Buf, sizeof(Buf), 
                                            &pBuf, &cbReq);
        if (pesreq->wszCmdLine == NULL)
            goto done;
    }

    // Desktop 
    if (psi->lpDesktop) 
    {
        pesreq->si.lpDesktop = MarshallString(psi->lpDesktop, Buf, sizeof(Buf),
                                              &pBuf, &cbReq);
        if (pesreq->si.lpDesktop == NULL)
            goto done;
    }

    // Title
    if (psi->lpTitle)
    {
        pesreq->si.lpTitle = MarshallString(psi->lpTitle, Buf, sizeof(Buf),
                                            &pBuf, &cbReq);
        if (pesreq->si.lpTitle == NULL)
            goto done;
    }

    // this is always NULL
    pesreq->si.lpReserved = NULL;

    // set the total size of the message
    pesreq->cbTotal = cbReq;

    // Send the buffer out to the server- wait at most 2m for this to
    //  succeed.  If it times out, bail.
    fRet = CallNamedPipeW(wszPipeName, Buf, cbReq, &esrep, sizeof(esrep),
                          &cbRead, 120000);
    if (fRet == FALSE)
        goto done;

    // Check the result
    fRet = esrep.fRet;
    if (fRet == FALSE)
    {
        SetLastError(esrep.dwErr);
        goto done;
    }

    // We copy the PROCESS_INFO structure from the reply to the caller
    // Note: the remote process has kindly duplicated the process & thread
    //       handles into us, so we can use the values returned as we normally
    //       would.
    RtlMoveMemory(ppi, &esrep.pi, sizeof(PROCESS_INFORMATION));

done:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\rexec\srv\resrv.h ===
#ifndef RESRV_H
#define RESRV_H

extern CRITICAL_SECTION g_csInit;

BOOL StartExecServerThread(void);
BOOL StopExecServerThread(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\rexec\srv\resrv.cpp ===
#include "stdafx.h"
#include "winsta.h"
#include "pchrexec.h"
#include "Userenv.h"
#include "resrv.h"

//////////////////////////////////////////////////////////////////////////////
// Globals

CRITICAL_SECTION    g_csInit;
HANDLE              g_hthES = NULL;
HANDLE              g_hPipe = INVALID_HANDLE_VALUE;
HANDLE              g_hevShutdown = NULL;
HANDLE              g_hevOverlapped = NULL;

extern "C"
{
    typedef enum
    {
        NameUnknown = 0,
        NameFullyQualifiedDN = 1,
        NameSamCompatible = 2,
        NameDisplay = 3,
        NameUniqueId = 6,
        NameCanonical = 7,
        NameUserPrincipal = 8,
        NameCanonicalEx = 9,
        NameServicePrincipal = 10

    } EXTENDED_NAME_FORMAT, * PEXTENDED_NAME_FORMAT ;

    BOOLEAN
    WINAPI
    GetUserNameExW(
        EXTENDED_NAME_FORMAT NameFormat,
        LPWSTR lpNameBuffer,
        PULONG nSize
        );
}



//////////////////////////////////////////////////////////////////////////////
// utility functions

// ***************************************************************************
inline BOOL IsInvalidPtr(LPVOID pv, LPVOID pvStart, ULONG_PTR cbRange)
{
    return (pv < pvStart || pv > ((LPVOID)((ULONG_PTR)pvStart + cbRange)));
}

// ***************************************************************************
inline LPVOID NormalizePtrs(LPVOID pv, LPVOID pvBase)
{
    return (LPVOID)((ULONG_PTR)pvBase + (ULONG_PTR)pv);
}

// ***************************************************************************
inline DWORD RolloverSubtrace(DWORD dwA, DWORD dwB)
{
    return (dwA >= dwB) ? (dwA - dwB) : ((0xffffffff - dwA) + dwB);
}


//////////////////////////////////////////////////////////////////////////////
// remote execution functions

// ***************************************************************************
BOOL ProcessExecRequest(PBYTE pBuf, DWORD *pcbBuf)
{
    WINSTATIONUSERTOKEN wsut;
    SPCHExecServRequest *pesreq = (SPCHExecServRequest *)pBuf;
    SPCHExecServReply   esrep;
    HANDLE              hprocRemote = NULL;
    HANDLE              hTokenUser = NULL;
    HANDLE              hProcess = NULL;
    HANDLE              hThread = NULL;
    LPVOID              pvEnv = NULL;
    DWORD               cbWrote;
    WCHAR               wszSysDir[MAX_PATH];
    BOOL                fRet = FALSE;
    BOOL                fImpersonate = FALSE;
    char                sz[1024];

    ZeroMemory(&esrep, sizeof(esrep));
    SetLastError(ERROR_INVALID_PARAMETER);
    esrep.cb   = sizeof(esrep);
    esrep.fRet = FALSE;

    // validate parameters
    if (*pcbBuf < sizeof(SPCHExecServRequest) || 
        pesreq->cbESR != sizeof(SPCHExecServRequest))
        goto done;

    // normalize the pointers
    if (pesreq->wszCmdLine != NULL) 
    {
        pesreq->wszCmdLine = (LPWSTR)NormalizePtrs(pesreq->wszCmdLine, pesreq);
        if (IsInvalidPtr(pesreq->wszCmdLine, pesreq, *pcbBuf))
            goto done;
    }

    if(pesreq->si.lpDesktop != NULL)
    {
        pesreq->si.lpDesktop = (LPWSTR)NormalizePtrs(pesreq->si.lpDesktop, pesreq);
        if (IsInvalidPtr(pesreq->si.lpDesktop, pesreq, *pcbBuf))
            goto done;
    }

    if(pesreq->si.lpTitle != NULL)
    {
        pesreq->si.lpTitle = (LPWSTR)NormalizePtrs(pesreq->si.lpTitle, pesreq);
        if (IsInvalidPtr(pesreq->si.lpTitle, pesreq, *pcbBuf))
            goto done;
    }

    // We do not know what the reserved is, so make sure it is NULL
    pesreq->si.lpReserved = NULL;

    // Get the handle to remote process
    hprocRemote = OpenProcess(PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION,
                              FALSE, pesreq->pidReqProcess);
    if (hprocRemote == NULL)
        goto done;

    // fetch the token associated with the sessions user
    ZeroMemory(&wsut, sizeof(wsut));
	wsut.ProcessId = LongToHandle(GetCurrentProcessId());
	wsut.ThreadId  = LongToHandle(GetCurrentThreadId());
    fRet = WinStationQueryInformationW(SERVERNAME_CURRENT, pesreq->ulSessionId,
                                       WinStationUserToken, &wsut, 
                                       sizeof(wsut), &cbWrote);
    if (fRet == NULL)
        goto done;

    // create the default environment for the user token- note that we 
    //  have to set the CREATE_UNICODE_ENVIRONMENT flag...
    fRet = CreateEnvironmentBlock(&pvEnv, wsut.UserToken, FALSE);
    if (fRet == FALSE)
        pvEnv = NULL;

    pesreq->fdwCreateFlags |= CREATE_UNICODE_ENVIRONMENT;

    // If we are to run the process under USER security, impersonate
    //  the user.
    // This will also access check the users access to the exe image.
    fRet = ImpersonateLoggedOnUser(wsut.UserToken);
    if (fRet == FALSE)
        goto done;

    // note that we do not allow inheritance of handles cuz they would be 
    //  inherited from this process and not the real parent, making it sorta
    //  pointless.
    GetSystemDirectoryW(wszSysDir, sizeof(wszSysDir) / sizeof(WCHAR));
    fRet = CreateProcessAsUserW(wsut.UserToken, NULL, pesreq->wszCmdLine,
                                NULL, NULL, FALSE, pesreq->fdwCreateFlags, 
                                pvEnv, wszSysDir, &pesreq->si, &esrep.pi);

    // since we successfully impersonated above (couldn't get here otherwise),
    //  revert back to our original security context
    RevertToSelf();

    if (pvEnv != NULL)
        DestroyEnvironmentBlock(pvEnv);

    if (fRet == FALSE)
        goto done;

    // save a copy of the handles so we can close them later
    hProcess = esrep.pi.hProcess;
    hThread  = esrep.pi.hThread;

    // duplicate the process & thread handles back into the remote process
    fRet = DuplicateHandle(GetCurrentProcess(), esrep.pi.hProcess, 
                           hprocRemote, &esrep.pi.hProcess, 
                           0, FALSE, DUPLICATE_SAME_ACCESS);
    if (fRet == FALSE)
    {
        // do something useful here- can't return FALSE, cuz the process is 
        //  running...
    }


    // If the program got launched into the shared WOW virtual machine,
    //  then the hThread will be NULL.
    if(esrep.pi.hThread != NULL) 
    {
        fRet = DuplicateHandle(GetCurrentProcess(), esrep.pi.hThread, 
                               hprocRemote, &esrep.pi.hThread, 
                               0, FALSE, DUPLICATE_SAME_ACCESS);
        if (fRet == FALSE)
        {
            // do something useful here- can't return FALSE, cuz the process is
            //  running...
        }
    }

    // get rid of any errors we might have encountered
    SetLastError(0);
    fRet = TRUE;

    esrep.fRet = TRUE;

done:
    esrep.dwErr = GetLastError();

    // build the reply packet with the handle valid in the context
    //  of the requesting process
    RtlMoveMemory(pBuf, &esrep, sizeof(esrep));
    *pcbBuf = sizeof(esrep);

    // close our versions of the handles. The requestors references
    //  are now the main ones
    if (hProcess != NULL)
        CloseHandle(hProcess);
    if (hThread != NULL)
        CloseHandle(hThread);
    if (hprocRemote != NULL)
        CloseHandle(hprocRemote);
    if (hTokenUser != NULL)
        CloseHandle(hTokenUser);

    return fRet;
}

// ***************************************************************************
BOOL IsClientLocalSystem(HANDLE hPipe)
{
    WCHAR       wszClient[MAX_PATH];
    WCHAR       wszBase[MAX_PATH];
    DWORD       cbInfo;
    BOOL        fRet = FALSE;

    // we assumes that the thread is running under local system context now
    cbInfo = sizeof(wszBase) / sizeof(WCHAR);
    fRet = GetUserNameExW(NameUniqueId, wszBase, &cbInfo);
    if (fRet == FALSE)
        goto done;

    OutputDebugStringW(L"base: ");
    OutputDebugStringW(wszBase);
    OutputDebugStringW(L"\n");

    // impersonate the client & then fetch his user name.
    fRet = ImpersonateNamedPipeClient(hPipe);
    if (fRet == FALSE)
        goto done;

    cbInfo = sizeof(wszClient) / sizeof(WCHAR);
    fRet = GetUserNameExW(NameUniqueId, wszClient, &cbInfo);
    if (fRet == FALSE)
        goto done;

    OutputDebugStringW(L"client: ");
    OutputDebugStringW(wszClient);
    OutputDebugStringW(L"\n");

    // make sure to return to our base security context
    RevertToSelf();

    // check if the two names are the same
    fRet = (_wcsicmp(wszClient, wszBase) == 0);

done:
    if (fRet == FALSE)
        SetLastError(ERROR_ACCESS_DENIED);

    return fRet;
}

// ***************************************************************************
BOOL ExecServer(LPVOID pvParam)
{
    OVERLAPPED  ol;
    HANDLE      rghWait[2] = { NULL, NULL };
    HANDLE      hPipe = INVALID_HANDLE_VALUE;
    DWORD       cbBuf, cb, dwErr, dw;
    WCHAR       wszPipeName[MAX_PATH];
    BOOL        fRet, fContinue = TRUE;
    BYTE        Buf[HANGREP_EXECSVC_BUF_SIZE];

    rghWait[0] = (HANDLE)pvParam;

    // create the event we're gonna wait on- we'll pass this to the various 
    //  IO functions via the OVERLAPPED structure
    rghWait[1] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (rghWait[1] == NULL)
        goto done;

    EnterCriticalSection(&g_csInit);
        g_hevOverlapped = rghWait[1];
    LeaveCriticalSection(&g_csInit);

    // setup the overlapped structure
    ZeroMemory(&ol, sizeof(ol));
    ol.hEvent = rghWait[1];

    // create the pipe
    wcscpy(wszPipeName, HANGREP_EXECSVC_PIPENAME);
    hPipe = CreateNamedPipeW(wszPipeName, 
                             PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                             PIPE_WAIT | PIPE_READMODE_MESSAGE | PIPE_TYPE_MESSAGE,
                             PIPE_UNLIMITED_INSTANCES,
                             HANGREP_EXECSVC_BUF_SIZE, 
                             HANGREP_EXECSVC_BUF_SIZE, 0, NULL);
    if (hPipe == INVALID_HANDLE_VALUE)
        goto done;

    EnterCriticalSection(&g_csInit);
        g_hPipe = hPipe;
    LeaveCriticalSection(&g_csInit);

    while(fContinue)
    {
        // read the pipe for a request (pipe is in message mode)- note that
        //  in overlapped mode, ConnectNamedPipe should always return FALSE.
        //  So the only non-failure codes GetLastError() can return are
        //  ERROR_IO_PENDING or ERROR_PIPE_CONNECTED.
        fRet = ConnectNamedPipe(hPipe, &ol);
        if (fRet == FALSE && GetLastError() != ERROR_IO_PENDING)
        {
            // if the pipe is already connected, just set the event so we
            //  don't have to add special case code below.
            if (GetLastError() == ERROR_PIPE_CONNECTED)
                SetEvent(ol.hEvent);
            else
                goto done;
        }

        // WAIT_OBJECT_0 is the shutdown event
        // WAIT_OBJECT_0 + 1 is the overlapped event
        dw = WaitForMultipleObjects(2, rghWait, FALSE, INFINITE);
        if (dw == WAIT_OBJECT_0)
        {
            DisconnectNamedPipe(hPipe);
            fContinue = FALSE;
            break;
        }
        else if (dw != WAIT_OBJECT_0 + 1)
        {
            dwErr = (GetLastError() == ERROR_SUCCESS) ? E_FAIL : GetLastError();
            if (WaitForSingleObject(ol.hEvent, 0) == WAIT_OBJECT_0)
                DisconnectNamedPipe(hPipe);
            SetLastError(dwErr);
            goto done;
        }

        ResetEvent(ol.hEvent);
        fRet = ReadFile(hPipe, Buf, sizeof(Buf), &cb, &ol);
        if (fRet == FALSE && GetLastError() == ERROR_IO_PENDING)
        {
            // give the client 60s to write the data to us.
            // WAIT_OBJECT_0 is the shutdown event
            // WAIT_OBJECT_0 + 1 is the overlapped event
            dw = WaitForMultipleObjects(2, rghWait, FALSE, 60000);
            if (dw == WAIT_OBJECT_0)
            {
                fContinue = FALSE;
            }
            else if (dw != WAIT_OBJECT_0 + 1)
            {
                DisconnectNamedPipe(hPipe);
                if (dw == WAIT_TIMEOUT)
                    continue;
                else
                    goto done;
            }

            fRet = GetOverlappedResult(hPipe, &ol, &cbBuf, FALSE);
        }
        else
        {
            OutputDebugString("ReadFile on pipe failed\n");
        }

        // check and make sure that the calling process is running under the
        //  local system account- if this fails, we cannot proceed cuz we 
        //  don't know who the caller is
        if (fContinue)
            fRet = IsClientLocalSystem(hPipe);

        // if we got an error, the client might still be waiting for a 
        //  reply, so construct a default one.
        // ProcessExecRequest() will always construct a reply and store it
        //  in Buf, so no special handling is needed if it fails.
        if (fContinue && fRet)
        {
            fRet = ProcessExecRequest(Buf, &cbBuf);
        }
        else
        {
            SPCHExecServReply   esrep;
            ZeroMemory(&esrep, sizeof(esrep));
            esrep.cb    = sizeof(esrep);
            esrep.fRet  = FALSE;
            esrep.dwErr = GetLastError();

            RtlMoveMemory(Buf, &esrep, sizeof(esrep));
            cbBuf = sizeof(esrep);
        }

        // write the reply to the message
        ResetEvent(ol.hEvent);
        fRet = WriteFile(hPipe, Buf, cbBuf, &cb, &ol);
        if (fRet == FALSE && GetLastError() == ERROR_IO_PENDING)
        {
            // give ourselves 60s to write the data to the pipe.
            // WAIT_OBJECT_0 is the shutdown event
            // WAIT_OBJECT_0 + 1 is the overlapped event
            dw = WaitForMultipleObjects(2, rghWait, FALSE, 60000);
            if (dw == WAIT_OBJECT_0)
            {
                fContinue = FALSE;
            }
            else if (dw != WAIT_OBJECT_0 + 1)
            {
                DisconnectNamedPipe(hPipe);
                if (dw == WAIT_TIMEOUT)
                    continue;
                else
                    goto done;
            }

            fRet = TRUE;
        }

        // wait for the client to read the buffer- note that we could use 
        //  FlushFileBuffers() to do this, but that is blocking with no
        //  timeout, so we try to do a read on the pipe & wait to get an 
        //  error indicating that the client closed it.
        if (fContinue && fRet)
        {
            ResetEvent(ol.hEvent);
            fRet = ReadFile(hPipe, Buf, sizeof(Buf), &cb, &ol);
            if (fRet == FALSE && GetLastError() == ERROR_IO_PENDING)
            {
                // give ourselves 60s to read the data from the pipe. 
                //  Except for the shutdown notification, don't really
                //  care what this routine returns cuz we're just using
                //  it to wait on 
                // WAIT_OBJECT_0 is the shutdown event
                // WAIT_OBJECT_0 + 1 is the overlapped event
                dw = WaitForMultipleObjects(2, rghWait, FALSE, 60000);
                if (dw == WAIT_OBJECT_0)
                    fContinue = FALSE;
            }
        }

        // disconnect the name pipe
        DisconnectNamedPipe(hPipe);
    }

    SetLastError(0);

done:
    EnterCriticalSection(&g_csInit);
        if (hPipe != NULL)
            CloseHandle(hPipe);
        if (rghWait[1] != NULL)
            CloseHandle(rghWait[1]);
        g_hPipe         = INVALID_HANDLE_VALUE;
        g_hevOverlapped = NULL;
    LeaveCriticalSection(&g_csInit);

    return fContinue;
}

// ***************************************************************************
DWORD threadExecServer(LPVOID pvParam)
{
    DWORD   cErr = 0, dwErr = ERROR_SUCCESS, dwStart = GetTickCount();
    BOOL    fShutdown = FALSE;

    while(fShutdown == FALSE && cErr < 5)
    {
        __try
        {
            fShutdown = ExecServer(pvParam);
            if (fShutdown == FALSE)
                cErr++;

            dwErr = GetLastError();
        }
        __except(dwErr = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
        {
            cErr++;
            EnterCriticalSection(&g_csInit);
                if (g_hPipe != NULL)
                    CloseHandle(g_hPipe);
                if (g_hevOverlapped)
                    CloseHandle(g_hevOverlapped);
                g_hPipe         = INVALID_HANDLE_VALUE;
                g_hevOverlapped = NULL;
            LeaveCriticalSection(&g_csInit);
        }

        if (fShutdown || WaitForSingleObject(g_hevShutdown, 0) == WAIT_OBJECT_0)
        {
            dwErr = 0;
            break;
        }
        
        // if this is the first error in the last 10s, restart the counter
        if (RolloverSubtrace(GetTickCount(), dwStart) > 10000)
        {
            dwStart = GetTickCount();
            cErr = 1;
        }
    }
 
    return dwErr;
}


// ***************************************************************************
BOOL StartExecServerThread(void)
{
    DWORD   dwThreadId, cRef;
    WCHAR   wszPipeName[MAX_PATH];
    BOOL    fRet = FALSE;

    g_hevShutdown = CreateEventW(NULL, TRUE, FALSE, NULL);
    if (g_hevShutdown == NULL)
        goto done;

    g_hthES = CreateThread(NULL, 0, threadExecServer, (LPVOID)g_hevShutdown,
                           0, &dwThreadId);
    if (g_hthES == NULL)
    {
        CloseHandle(g_hevShutdown);
        g_hevShutdown = NULL;
        goto done;
    }

    fRet = TRUE;

done:
    return fRet;
}

// ***************************************************************************
BOOL StopExecServerThread(void)
{
    DWORD   dw;

    if (g_hthES == NULL || g_hevShutdown == NULL)
        return TRUE;

    SetEvent(g_hevShutdown);
    dw = WaitForSingleObject(g_hthES, 60000);
    if (dw != WAIT_OBJECT_0)
    {
        // need to do the TerminateThread in a CS cuz I don't want to terminate
        //  the thread while it holds the CS.
        EnterCriticalSection(&g_csInit);
            TerminateThread(g_hthES, E_FAIL);
            CloseHandle(g_hPipe);
            CloseHandle(g_hevOverlapped);
            g_hPipe         = INVALID_HANDLE_VALUE;
            g_hevOverlapped = NULL;
        EnterCriticalSection(&g_csInit);
    }

    CloseHandle(g_hthES);
    CloseHandle(g_hevShutdown);

    g_hthES         = NULL;
    g_hevShutdown   = NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\rexec\srv\stdafx.h ===
#include "windows.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\authlib.h ===
//+---------------------------------------------------------------------------
//
//  File:       authlib.h
//
//  Contents:   This file contains the functions that are needed by 
//              both analysis and u2
// 
// 
//  
// History:    AshishS    Created     7/13/97
// 
//----------------------------------------------------------------------------

#ifndef _AUTHLIB_H
#define _AUTHLIB_H

#include <cryptfnc.h>

#define COOKIE_GUID_LENGTH  16

// This function generates a random 16 byte character. It then Hex
// encodes it and NULL terminates the string
BOOL GenerateGUID( TCHAR * pszBuffer, // buffer to copy GUID in 
                   DWORD dwBufLen); // size of above buffer in characters

// the above buffer should be at least COOKIE_GUID_LENGTH * 2 +1 characters
// in length

// This initializes the library - must be called before any other
// functions are called.
BOOL InitAuthLib();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\bldver.h ===
/*bldver.h*/

/******************************************************************
**
** This file is automatically generated by BLDVER.EXE.
** Do not attempt to change this file manually. Your changes will
** be overwritten during the next build.
**
********************************************************************/

#if !defined(_BLDVER_H_)
#define _BLDVER_H_
#include <ntverp.h>
#endif // !defined(_BLDVER_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\authlib\authlib\authlib.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       authlib.cpp
//
//  Contents:   This file contains the functions that are common
//              to authfltr and verifusr
// 
// 
//  
// History:    AshishS    Created     6/03/97
// 
//----------------------------------------------------------------------------

#include <windows.h>

#include <stdlib.h>
#include <time.h>

// use the _ASSERT and _VERIFY in dbgtrace.h
#ifdef _ASSERT
#undef _ASSERT
#endif

#ifdef _VERIFY
#undef _VERIFY
#endif
#include <dbgtrace.h>
#include <cryptfnc.h>
#include <authlib.h>

#define AUTHLIBID  0x4337

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


CCryptFunctions     g_AuthLibCryptFnc;
LONG                g_lAuthLibCryptInited=0;
BOOL                g_fAuthLibCryptInitSucceeded=FALSE;



// This function generates a random 16 byte character. It then Hex
// encodes it and NULL terminates the string
BOOL GenerateRandomGUID(TCHAR            * pszBuffer,
                        CCryptFunctions  * pCCryptFnc )
{
    TraceFunctEnter("GenerateRandomGUID");
    BOOL fResult=FALSE;
    BYTE pbRandomNumber[COOKIE_GUID_LENGTH];
    DWORD dwIndex, dwOffset=0;
    
    if ((pCCryptFnc) &&
        (pCCryptFnc->GenerateSecretKey( pbRandomNumber,
                                         // Buffer to store random number
                                        COOKIE_GUID_LENGTH )))
         // length of random num in bytes
    {
        DebugTrace(AUTHLIBID, "Generated CryptoAPI random number");
    }
    else
    {
         // Cannot get a random number from CryptoAPI. Generate one
         // using C - runtime functions.
        
        int i;

        for( i = 0;   i < COOKIE_GUID_LENGTH;i++ )
        {
            pbRandomNumber[i] = rand() & 0xFF;
        }
    }

     // now hex encode the bytes in the input buffer
    for (dwIndex=0; dwIndex < COOKIE_GUID_LENGTH; dwIndex++)
    {
         // dwOffset should always increase by two in this loop
        dwOffset+=wsprintf(&pszBuffer[dwOffset],TEXT("%02x"),
                           pbRandomNumber[dwIndex]);
    }
    
    return TRUE;
}

BOOL InitAuthLib()
{
    TraceFunctEnter("InitAuthLib");    
    if (InterlockedExchange(&g_lAuthLibCryptInited, 1) == 0) 
    {
        DebugTrace(AUTHLIBID, "first time InitAuthLib has been called");
        
         /* Seed the random-number generator with current time so that
          * the numbers will be different every time we run.
          */
        srand( (unsigned)time( NULL ) );
        
        if (!g_AuthLibCryptFnc.InitCrypt())
        {
             // BUGBUG we should find out what to do in this case - at least
             // we should log an event log
            ErrorTrace(AUTHLIBID,"Could not initialize Crypt");
            g_fAuthLibCryptInitSucceeded = FALSE;
        }
        else
        {
            g_fAuthLibCryptInitSucceeded = TRUE;
        }
    }
    TraceFunctLeave();
    return TRUE;
}

BOOL GenerateGUID( TCHAR * pszBuffer, // buffer to copy GUID in 
                   DWORD   dwBufLen) // size of above buffer
{
    TraceFunctEnter("GenerateGUID");
    
    if ( (dwBufLen) < (COOKIE_GUID_LENGTH * 2 + 1) )
    {
        DebugTrace(AUTHLIBID, "Buffer not big enough");
        TraceFunctLeave();
        return FALSE;
    }
    
    
     // Get GUID value
    if (g_fAuthLibCryptInitSucceeded)
    {
        if (!GenerateRandomGUID(pszBuffer,
                                &g_AuthLibCryptFnc))
        {
            ErrorTrace(AUTHLIBID, "Error in generating GUID");
            TraceFunctLeave();            
            return FALSE;            
        }
    }
    else
    {
        if (!GenerateRandomGUID(pszBuffer,
                                NULL)) // we do not have cryptfnc
        {
            ErrorTrace(AUTHLIBID, "Error in generating GUID");
            TraceFunctLeave();            
            return FALSE;
        }
    }
    
    TraceFunctLeave();                
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\client\test\rexec\srv\faultsvc.cpp ===
// faultsvc.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f faultsvcps.mk in the project directory.

#include "windows.h"
#include "shellapi.h"
#include "resrv.h"

SERVICE_STATUS_HANDLE   g_hSvcStatus = NULL;
SERVICE_STATUS          g_ssStatus;
WCHAR                   g_wszSvcName[] = L"RESrv";
DWORD                   g_dwThreadId = 0;

#define sizeofSTRW(wsz) (sizeof((wsz)) / sizeof(WCHAR))


// ***************************************************************************
BOOL InstallService(void)
{
    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hSvc = NULL;
    BOOL        fRet = FALSE;
    WCHAR       wszFilePath[MAX_PATH];
        
    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
        goto done;

    // does the service already exist? 
    hSvc = OpenServiceW(hSCM, g_wszSvcName, SERVICE_QUERY_CONFIG);
    if (hSvc != NULL)
        fRet = TRUE;

    if (fRet)
        goto done;

    // Get the executable file path
    GetModuleFileNameW(NULL, wszFilePath, sizeofSTRW(wszFilePath));

    hSvc = CreateServiceW(hSCM, g_wszSvcName, g_wszSvcName, SERVICE_ALL_ACCESS, 
                          SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START, 
                          SERVICE_ERROR_NORMAL, wszFilePath, NULL, NULL, 
                          L"RPCSS\0", NULL, NULL);
    if (hSvc == NULL)
        goto done;

    fRet = TRUE;

done:
    if (hSCM != NULL)
        CloseServiceHandle(hSCM);
    if (hSvc != NULL)
        CloseServiceHandle(hSvc);
    
    return fRet;
}

// ***************************************************************************
BOOL UninstallService(void)
{
    SERVICE_STATUS  status;
    SC_HANDLE       hSCM = NULL;
    SC_HANDLE       hSvc = NULL;
    BOOL            fRet = FALSE;
    WCHAR           wszFilePath[MAX_PATH];
        
    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
        goto done;

    // does the service already exist? 
    hSvc = OpenServiceW(hSCM, g_wszSvcName, SERVICE_STOP | DELETE);
    if (hSvc == NULL)
        fRet = TRUE;

    if (fRet)
        goto done;

    ControlService(hSvc, SERVICE_CONTROL_STOP, &status);
    fRet = DeleteService(hSvc);

done:
    if (hSCM != NULL)
        CloseServiceHandle(hSCM);
    if (hSvc != NULL)
        CloseServiceHandle(hSvc);
    
    return fRet;
}

// ***************************************************************************
void WINAPI ServiceHandler(DWORD fdwControl)
{
    switch (fdwControl)
    {
        case SERVICE_CONTROL_STOP:
            g_ssStatus.dwCurrentState = SERVICE_STOP_PENDING;
            SetServiceStatus(g_hSvcStatus, &g_ssStatus);
            PostThreadMessage(g_dwThreadId, WM_QUIT, 0, 0);
            break;

        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        case SERVICE_CONTROL_INTERROGATE:
        case SERVICE_CONTROL_SHUTDOWN:
        default:
            break;
    }
}

// ***************************************************************************
void WINAPI ServiceMain(DWORD dwArgc, LPWSTR *lpszArgv)
{
    HANDLE  hth = NULL;
    DWORD   dw;
    MSG     msg;

    ZeroMemory(&g_ssStatus, sizeof(g_ssStatus));

    g_hSvcStatus = RegisterServiceCtrlHandlerW(g_wszSvcName, ServiceHandler);
    if (g_hSvcStatus == NULL)
        goto done;

    // mark the service as about to start
    g_ssStatus.dwServiceType             = SERVICE_WIN32_OWN_PROCESS;
    g_ssStatus.dwCurrentState            = SERVICE_START_PENDING;
    g_ssStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
    g_ssStatus.dwWin32ExitCode           = 0;
    g_ssStatus.dwServiceSpecificExitCode = 0;
    g_ssStatus.dwCheckPoint              = 1;
    g_ssStatus.dwWaitHint                = 1000;
    SetServiceStatus(g_hSvcStatus, &g_ssStatus);

    g_dwThreadId = GetCurrentThreadId();

    // mark the service as started
    g_ssStatus.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(g_hSvcStatus, &g_ssStatus);

    if (StartExecServerThread())
    {
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

        StopExecServerThread();
    }

    // mark the service as stopped
    g_ssStatus.dwCurrentState = SERVICE_STOPPED;
    SetServiceStatus(g_hSvcStatus, &g_ssStatus);

done:
    return;
}

// ***************************************************************************
BOOL StartService(void)
{
    SERVICE_TABLE_ENTRYW st[] =
    {
        { g_wszSvcName, ServiceMain },
        { NULL,         NULL        }
    };

    return StartServiceCtrlDispatcherW(st);
}

// ***************************************************************************
extern "C" int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
                               LPWSTR lpCmdLine, int nShowCmd)
{
    LPWSTR  wszCmdLine = NULL;
    WCHAR   **argv;
    int     argc;


    wszCmdLine = GetCommandLineW();
    argv = CommandLineToArgvW(wszCmdLine, &argc);

    if (argc > 1)
    {
        if (_wcsicmp(argv[1], L"Install") == 0)
            return InstallService();

        if (_wcsicmp(argv[1], L"Uninstall") == 0)
            return UninstallService();
    }

    InitializeCriticalSection(&g_csInit);

/*
    {
        PROCESS_INFORMATION pi;
        STARTUPINFOW        si;
        WCHAR               wszCmdLine[] = L"d:\\winnt\\system32\\cmd.exe";

        ZeroMemory(&si, sizeof(si));
        si.cb = sizeof(si);
        si.lpDesktop = L"Winsta0\\Default";

        if (CreateProcessW(NULL, wszCmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
        {
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
    }
*/
    StartService();

    LeaveCriticalSection(&g_csInit);
    

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\authlib\cryptfnc\cryptfnc.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       cryptfnc.cpp
//
//  Contents:   This file implements the cryptfnc class that provides
//              easy to use interfaces on the CryptoAPI.
//
// History:    AshishS    Created     12/03/96
// 
//----------------------------------------------------------------------------

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


#include <windows.h>
#include <cryptfnc.h>
#include <wincrypt.h>
#include <dbgtrace.h>

#ifndef CRYPT_MACHINE_KEYSET
#define CRYPT_MACHINE_KEYSET    0x00000020
#endif


// this function Generates a SessionKey using the pszPassword
// parameter
// Returns FALSE if a Fatal error occured, TRUE otherwise
BOOL CCryptFunctions::GenerateSessionKeyFromPassword(
    HCRYPTKEY * phKey, // location to store the session key
    TCHAR * pszPassword) // password to generate the session key from
{
    DWORD dwLength;    
    HCRYPTHASH hHash = 0;

    TraceFunctEnter("GenerateSessionKeyFromPassword");

     // Init should have been successfully called before
    _ASSERT(m_hProv);
    
    // Create hash object.
    if(!CryptCreateHash(m_hProv, // handle to CSP
                        CALG_SHA, // use SHA hash algorithm
                        0, // not keyed hash
                        0, // flags - always 0
                        &hHash)) // address where hash object should be created
    {
        ErrorTrace(CRYPT_FNC_ID, "Error 0x%x during CryptCreateHash",
                   GetLastError());
        goto cleanup;
    }

    // Hash password string.
    dwLength = lstrlen(pszPassword) * sizeof(TCHAR);
    
    if(!CryptHashData(hHash, // handle to hash object
                      (BYTE *)pszPassword, // address of data to be hashed
                      dwLength, // length of data 
                      0)) // flags
    {
        ErrorTrace(CRYPT_FNC_ID, "Error 0x%x during CryptHashData",
                   GetLastError());
        goto cleanup;
    }

     // Create block cipher session key based on hash of the password.

    if(!CryptDeriveKey(m_hProv, //CSP provider
                       CALG_RC2, // use RC2 block cipher algorithm
                       hHash, //handle to hash object 
                       0, // no flags - we do not need the key to be exportable
                       phKey)) //address the newly created key should be copied
    {
        ErrorTrace(CRYPT_FNC_ID,"Error 0x%x during CryptDeriveKey",
                   GetLastError());
        goto cleanup;
    }
    
     // Destroy hash object.
    _VERIFY(CryptDestroyHash(hHash));
    TraceFunctLeave();
    return TRUE;
    
cleanup:

    // Destroy hash object.
    if(hHash != 0)
        _VERIFY(CryptDestroyHash(hHash));
    TraceFunctLeave();
    return FALSE;
}


// This function generates a Hash using the SHA hashing
// algorithm. Four seperate buffers of data can be given to this
// function. Data of length 0 will not be used in calculation of HASH.
// Returns FALSE if a Fatal error occured, TRUE otherwise
BOOL CCryptFunctions::GenerateHash(
    BYTE * pbData, // data to hash
    DWORD dwDataLength, // length of data to hash
    BYTE * pbData1, // another data to hash
    DWORD dwData1Length, // length of above data
    BYTE * pbData2, // another data to hash
    DWORD dwData2Length, // length of above data
    BYTE * pbData3, // another data to hash
    DWORD dwData3Length, // length of above data
    BYTE * pbHashBuffer, // buffer to store hash
    DWORD * pdwHashBufLen)//length of buffer to store Hash
{
    DWORD dwLength, dwResult;
    BOOL  fResult;
    
    HCRYPTHASH hHash = 0;

    TraceFunctEnter("GenerateHash");

     // Init should have been successfully called before
    _ASSERT(m_hProv);

    dwResult = WaitForSingleObject( m_hSemaphore,// handle of object to wait for 
                                    INFINITE); // no time-out

    _ASSERT(WAIT_OBJECT_0 == dwResult);
    
    
     // At least one of the Data Pairs should be valid
    if (! (( pbData && dwDataLength ) || ( pbData1 && dwData1Length )
          || ( pbData2 && dwData2Length ) || ( pbData3 && dwData3Length ) ) )
    {
        ErrorTrace(CRYPT_FNC_ID, "No Data to hash");
        goto cleanup;        
    }
    
     // now ask the user for a password and generate a session key based
     // on the password. This session key will be used to encrypt the secret
     // key.
    // Create hash object.
    if(!CryptCreateHash(m_hProv, // handle to CSP
                        CALG_SHA, // use SHA hash algorithm
                        0, // not keyed hash
                        0, // flags - always 0
                        &hHash)) // address where hash object should be created
    {
        ErrorTrace(CRYPT_FNC_ID, "Error 0x%x during CryptCreateHash",
                   GetLastError());
        goto cleanup;
    }

    if ( pbData && dwDataLength )
    {
        if(!CryptHashData(hHash, // handle to hash object
                          pbData, // address of data to be hashed
                          dwDataLength, // length of data 
                          0)) // flags
        {
            ErrorTrace(CRYPT_FNC_ID,"Error 0x%x during CryptHashData",
                       GetLastError());
            goto cleanup;
        }
    }

    if ( pbData1 && dwData1Length )
    {
        if(!CryptHashData(hHash, // handle to hash object
                          pbData1, // address of data to be hashed
                          dwData1Length, // length of data 
                          0)) // flags
        {
            ErrorTrace(CRYPT_FNC_ID,"Error 0x%x during CryptHashData",
                       GetLastError());
            goto cleanup;
        }
    }

    if (pbData2)
    {
        if(!CryptHashData(hHash, // handle to hash object
                          pbData2, // address of data to be hashed
                          dwData2Length, // length of data 
                          0)) // flags
        {
            ErrorTrace(CRYPT_FNC_ID,"Error 0x%x during CryptHashData",
                       GetLastError());
            goto cleanup;
        }
    }

    if (pbData3)
    {
        if(!CryptHashData(hHash, // handle to hash object
                          pbData3, // address of data to be hashed
                          dwData3Length, // length of data 
                          0)) // flags
        {
            ErrorTrace(CRYPT_FNC_ID,"Error 0x%x during CryptHashData",
                       GetLastError());
            goto cleanup;
        }
    }    
        
    if (! CryptGetHashParam( hHash,// handle to hash object
                             HP_HASHVAL,// get the hash value
                             pbHashBuffer, // hash buffer
                             pdwHashBufLen, // hash buffer length
                             0 )) // flags
    {
        ErrorTrace(CRYPT_FNC_ID,"Error 0x%x during CryptGetHashParam",
                   GetLastError());
        goto cleanup;
    }
     // Destroy hash object.
    _VERIFY(CryptDestroyHash(hHash));

    _VERIFY(fResult = ReleaseSemaphore(m_hSemaphore, 1, NULL));
    
    TraceFunctLeave();
    return TRUE;
    
cleanup:

    // Destroy hash object.
    if(hHash != 0)
        _VERIFY(CryptDestroyHash(hHash));

    _VERIFY(fResult = ReleaseSemaphore(m_hSemaphore, 1, NULL));    
    
    TraceFunctLeave();
    return FALSE;    
    
}


// This function must be called before any member functions of the
// class are used.
// Returns FALSE if a Fatal error occured, TRUE otherwise
// this always gets the machine keyset
BOOL CCryptFunctions::InitCrypt()
{
    TraceFunctEnter("InitCrypt");
    TCHAR   szSemaphoreName[100];
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    BOOL fResult;
    
    if (m_hProv)
    {
        DebugTrace(CRYPT_FNC_ID,"Already been inited before");
        TraceFunctLeave();    
        return TRUE;       
    }

     // create a Unique semaphore name for each process
    wsprintf(szSemaphoreName, TEXT("%s%d"), CRYPTFNC_SEMAPHORE_NAME,
             GetCurrentProcessId());

     // also create a security descriptor so that everyone has access
     // to the semaphore. Otherwise if the semaphore is created in a
     // service running in system context, then only system can use
     // this semaphore.
    fResult = InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

    _ASSERT(fResult);
    
    
     // if the security descriptor has a NULL DACL, then this gives
     // everyone access to this semaphore.
    fResult = SetSecurityDescriptorDacl(&sd,
                                        TRUE, 
                                        NULL, // NULL ACL
                                        FALSE);

    _ASSERT(fResult);
    
    sa.nLength  = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = FALSE;
    sa.lpSecurityDescriptor = & sd;
    
    

    m_hSemaphore = CreateSemaphore(&sa, // pointer to security attributes 
                                   1, // initial count
                                   1, // maximum count
                                   szSemaphoreName);// pointer to Semaphore-object name

    if ( NULL == m_hSemaphore)
    {
        DWORD  dwError;

        dwError = GetLastError();
        ErrorTrace(CRYPT_FNC_ID, "CreateSemaphore failed 0x%x", dwError);
        
        _ASSERT(0);
        goto cleanup;
    }

    if(!CryptAcquireContext(&m_hProv, //  address to get the handle to CSP
                            NULL, // contianer name - use default container
                            NULL, //  provider
                            PROV_RSA_FULL, // type of provider
                            CRYPT_VERIFYCONTEXT))
    {
        ErrorTrace(CRYPT_FNC_ID, "Fatal Error 0x%x during first"
                   "call to CryptAcquireContext", GetLastError());
        goto cleanup;                
    }
     
#if 0 // This code is being commented out since there are problems
     // getting the machine keyset from an ASP app running in the IIS
     // anonymous user context. This means that we will not be able to
     // do any signing or in some cases encryption. This is fine since
     // we do not want to do this currently.
    
    // Get handle to machine default provider.
    if(!CryptAcquireContext(&m_hProv, //  address to get the handle to CSP
                            NULL, // contianer name - use default container
                            MS_DEF_PROV, //  provider
                            PROV_RSA_FULL, // type of provider
                            CRYPT_MACHINE_KEYSET)) 
    {
        DWORD dwError;
        dwError = GetLastError();
        ErrorTrace(CRYPT_FNC_ID, "Error 0x%x during CryptAcquireContext",
                   dwError);
        DebugTrace(CRYPT_FNC_ID, "Calling CryptAcquireContext again"
                   "to create keyset");
        if (! CryptAcquireContext(&m_hProv,// handle to CSP
                                  NULL,// contianer name - use default
                                  MS_DEF_PROV, // provider
                                  PROV_RSA_FULL, // type of provider
                                  CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET) )
                                  // create the keyset
        {
            ErrorTrace(CRYPT_FNC_ID, "Fatal Error 0x%x during second"
                       "call to CryptAcquireContext", GetLastError());
            goto cleanup;                
        }
    }
#endif
    
    TraceFunctLeave();    
    return TRUE;
    
cleanup:
     // Release provider handle.
    if(m_hProv != 0)
    {
        _VERIFY(CryptReleaseContext(m_hProv, 0));
        m_hProv =0 ;
    }
    
    TraceFunctLeave();    
    return FALSE;    
}

CCryptFunctions::~CCryptFunctions()
{
    TraceFunctEnter("~CCryptFunctions");
     // Release provider handle.    
    if(m_hProv != 0)
    {
        _VERIFY(CryptReleaseContext(m_hProv, 0));
    }

    if (NULL != m_hSemaphore)
    {
        _VERIFY(CloseHandle(m_hSemaphore));
    }
    
    TraceFunctLeave();    
}

CCryptFunctions::CCryptFunctions()
{
    m_hProv = 0;
    m_hSemaphore = NULL;
}

// This function generates random data of length dwLength bytes. This
// data is guaranteed by CryptoAPI to be truly random.
// Returns FALSE if a Fatal error occured, TRUE otherwise
BOOL CCryptFunctions::GenerateSecretKey(
    BYTE * pbData,// Buffer to store secret key
     //buffer must be long enough for dwLength bits
    DWORD dwLength ) // length of secret key in bytes
{
    DWORD   dwResult;
    BOOL    fResult;
    
     // Init should have been successfully called before
    _ASSERT(m_hProv);
    TraceFunctEnter("GenerateSecretKey");

    dwResult = WaitForSingleObject( m_hSemaphore,//handle of object to wait for
                                    INFINITE); // no time-out

    _ASSERT(WAIT_OBJECT_0 == dwResult);
    
    
    // Create a random dwLength byte number for a secret.
    if(!CryptGenRandom(m_hProv, // handle to CSP
                       dwLength , // number of bytes of
                        // random data to be generated
                       pbData )) //   buffer - uninitialized 
    {
        
        _VERIFY(fResult = ReleaseSemaphore(m_hSemaphore, 1, NULL));
        
        ErrorTrace(CRYPT_FNC_ID, "Error 0x%x during CryptGenRandom",
                   GetLastError());
        TraceFunctLeave();
        return FALSE;
    }

    _VERIFY(fResult = ReleaseSemaphore(m_hSemaphore, 1, NULL));    
    TraceFunctLeave();    
    return TRUE;
}


// Given a password, and data to encrypt this function generates a
// session key from the password. This session key is then used to
// encrypt the data.

// Returns FALSE if a Fatal error occured, TRUE otherwise
BOOL CCryptFunctions::EncryptDataWithPassword(
    TCHAR * pszPassword, // password    
    BYTE * pbData, // Data to be encrypted
    DWORD dwDataLength, // Length of data in bytes
    BYTE * pbEncryptedData, // Encrypted secret key will be stored here
    DWORD * pdwEncrytedBufferLen // Length of this buffer
    )
{
    DWORD dwBufferLength;
    HCRYPTKEY hKey = 0;    
    TraceFunctEnter("EncryptDataWithPassword");
    
     // Init should have been successfully called before
    _ASSERT(m_hProv);


    if (!GenerateSessionKeyFromPassword(&hKey, pszPassword))
        goto cleanup;

    if (dwDataLength > * pdwEncrytedBufferLen )
    {
        ErrorTrace(CRYPT_FNC_ID, "Buffer not large enough");
        goto cleanup;
    }
    
     // copy the data into another buffer to encrypt it
    memcpy (pbEncryptedData, pbData, dwDataLength);
    dwBufferLength  = *pdwEncrytedBufferLen;
    
    *pdwEncrytedBufferLen = dwDataLength;
    
    
     // now encrypt the secret key using the key generated
    if ( ! CryptEncrypt(hKey,
                        0, // no hash required
                        TRUE, // Final packet
                        0, // Flags - always 0
                        pbEncryptedData, // data buffer
                        pdwEncrytedBufferLen, // length of data
                        dwBufferLength ) ) // size of buffer
    {
        ErrorTrace(CRYPT_FNC_ID, "Error 0x%x during CryptEncrypt",
                   GetLastError());
        goto cleanup;
    }


     // destroy session key
    _VERIFY(CryptDestroyKey(hKey));
    TraceFunctLeave();        
    return TRUE;
    
cleanup:
         // destroy session key
    if (hKey != 0)
        _VERIFY(CryptDestroyKey(hKey));
    
    TraceFunctLeave();        
    return FALSE;
}

// Given a password, and encrypted data using EncryptDataWithPassword,
// this function generates a session key from the password. This
// session key is then used to decrypt the data.

//  returns
//   CRYPT_FNC_NO_ERROR   no error
//   CRYPT_FNC_BAD_PASSWORD password bad try again
//   CRYPT_FNC_INSUFFICIENT_BUFFER larger buffer is required
//   *pdwEncrytedBufferLen is set to required length
//   CRYPT_FNC_INIT_NOT_CALLED InitCrypt not successfully called
//   CRYPT_FNC_INTERNAL_ERROR 
DWORD CCryptFunctions::DecryptDataWithPassword(
    TCHAR * pszPassword, // password    
    BYTE * pbData, // Decrypted Data will be stored here
    DWORD *pdwDataBufferLength, // Length of the above buffer in bytes
    BYTE * pbEncryptedData, // Encrypted data
    DWORD dwEncrytedDataLen // Length of encrypted data
    )
{
    DWORD dwBufferLength;
    HCRYPTKEY hKey = 0;    
    TraceFunctEnter("DecryptDataWithPassword");
    DWORD dwError;
    
     // Init should have been successfully called before
    if (m_hProv== 0)
    {
        dwError = CRYPT_FNC_INIT_NOT_CALLED;
        goto cleanup;
    }
    
    if (!GenerateSessionKeyFromPassword(&hKey, pszPassword))
    {
        dwError = CRYPT_FNC_INTERNAL_ERROR;        
        goto cleanup;
    }

     // check if buffer is large enough
    if ( dwEncrytedDataLen >  *pdwDataBufferLength )
    {
        dwError = CRYPT_FNC_INSUFFICIENT_BUFFER;
        *pdwDataBufferLength = dwEncrytedDataLen;        
        goto cleanup;
    }
    
     // copy the data into another buffer to encrypt it
    memcpy (pbData, pbEncryptedData, dwEncrytedDataLen);
    
    *pdwDataBufferLength = dwEncrytedDataLen;
    


     // now decrypt the secret key using the key generated
    if ( ! CryptDecrypt(hKey,
                        0, // no hash required
                        TRUE, // Final packet
                        0, // Flags - always 0
                        pbData, // data buffer
                        pdwDataBufferLength )) // length of data
    {
        DWORD dwCryptError = GetLastError();
        DebugTrace(CRYPT_FNC_ID, "Error 0x%x during CryptDecrypt",
                   dwCryptError);
         // CryptDecrypt fails with error NTE_BAD_DATA if the password
         // is incorrect. Hence we should check for this error and prompt the
         // user again for the password
         // Issue: if the data is garbled in transit, then the secret key
         // will still be  decrypted into a wrong value and the user will not
         // know about it.
        if (  dwCryptError == NTE_BAD_DATA )
        {
            dwError = CRYPT_FNC_BAD_PASSWORD;
        }
        else
        {
            dwError = CRYPT_FNC_INTERNAL_ERROR;            
        }
        goto cleanup;
    }

     // destroy session key
    _VERIFY(CryptDestroyKey(hKey));
    TraceFunctLeave();        
    return CRYPT_FNC_NO_ERROR;
    
cleanup:
         // destroy session key
    if (hKey != 0)
        _VERIFY(CryptDestroyKey(hKey));
    
    TraceFunctLeave();        
    return dwError;
}

/*
  This function:
  1. Generates a session key to encrypt the secret data
  2. Encrypts the secret data using this session key - return this
     value in the pbEncryptedData parameter
  3. Encrypts the session key using the public key in the CSP -
     only the private key can decrypt this value. Return the encrypted
     session key in the pbEncryptedSessionKey parameter.
     
  returns
   CRYPT_FNC_NO_ERROR   no error
   CRYPT_FNC_INSUFFICIENT_BUFFER larger buffer is required
   *pdwEncrytedBufferLen and are set to required length
   CRYPT_FNC_INIT_NOT_CALLED InitCrypt not successfully called
   CRYPT_FNC_INTERNAL_ERROR 
   
*/
DWORD CCryptFunctions::EncryptDataAndExportSessionKey(
    BYTE * pbData, // Secret Data
    DWORD dwDataLen, // Secret Data Length
    BYTE * pbEncryptedData, // Buffer to store Encrypted Data
    DWORD * pdwEncrytedBufferLen, // Length of above buffer
    BYTE * pbEncryptedSessionKey, // Buffer to store encrypted session key
    DWORD * pdwEncrytedSessionKeyLength) // Length of above buffer
{
    HCRYPTKEY hXchgKey = 0;
    HCRYPTKEY hKey = 0;    
    DWORD dwBufferLen, dwError;
    TraceFunctEnter("EncryptDataAndExportSessionKey");
    
     // Init should have been successfully called before
    if (m_hProv== 0)
    {
        dwError = CRYPT_FNC_INIT_NOT_CALLED;
        goto cleanup;
    }
    
     // now get the public key to encrypt Secret key for storage
    // Get handle to exahange key.
    if(!CryptGetUserKey(m_hProv, // CSP provider
                        AT_KEYEXCHANGE, // we need the exchange public key
                        &hXchgKey))
    {
        DWORD dwCryptError;
        dwCryptError = GetLastError();
        if ( dwCryptError == NTE_NO_KEY )
        {
            DebugTrace(CRYPT_FNC_ID, "Error NTE_NO_KEY during"
                       "CryptGetUserKey");
            DebugTrace(CRYPT_FNC_ID, "Calling CryptGenKey to generate key");
            
            if (!CryptGenKey( m_hProv,// CSP provider
                              AT_KEYEXCHANGE, // generate the exchange
                                                //public key
                              0, //no flags
                              &hXchgKey ) )
            {
                ErrorTrace(CRYPT_FNC_ID, "Error 0x%x during CryptGenKey",
                           GetLastError());
                dwError = CRYPT_FNC_INTERNAL_ERROR;
                goto cleanup;    
            }
        }
        else
        {
            ErrorTrace(CRYPT_FNC_ID, "Error 0x%x during CryptGetUserKey",
                       GetLastError());
            dwError = CRYPT_FNC_INTERNAL_ERROR;
            goto cleanup;            
        }

    }

     // now generate a random session key to encrypt the secret key
     // Create block cipher session key.
    if (!CryptGenKey(m_hProv, // CSP provider
                     CALG_RC2, // use RC2 block cipher algorithm
                     CRYPT_EXPORTABLE, // flags
                     &hKey)) // address of key
    {
        ErrorTrace(CRYPT_FNC_ID, "Error 0x%x during CryptGenKey",
                   GetLastError());
        dwError = CRYPT_FNC_INTERNAL_ERROR;
        goto cleanup;
    }

    
    // Export key into a simple key blob.
    if(!CryptExportKey(hKey, // key to export
                       hXchgKey, // our exchange public key
                       SIMPLEBLOB, // type of blob
                       0, // flags (always 0)
                       pbEncryptedSessionKey, // buffer to store blob
                       pdwEncrytedSessionKeyLength)) // length of above buffer
    {
         // BUGBUG check here if insufficient buffer error
        ErrorTrace(CRYPT_FNC_ID, "Error 0x%x during CryptExportKey",
                   GetLastError());
        goto cleanup;
    }

     // check if buffer is large enough
    if ( dwDataLen >  *pdwEncrytedBufferLen )
    {
        dwError = CRYPT_FNC_INSUFFICIENT_BUFFER;
        *pdwEncrytedBufferLen = dwDataLen;        
        goto cleanup;
    }
    
     // copy the data into another buffer to encrypt it
    memcpy (pbEncryptedData, pbData, dwDataLen);

    dwBufferLen = *pdwEncrytedBufferLen;
    *pdwEncrytedBufferLen = dwDataLen;
    
    
     // now encrypt the secret key using the key generated
    if ( ! CryptEncrypt(hKey,
                        0, // no hash required
                        TRUE, // Final packet
                        0, // Flags - always 0
                        pbEncryptedData, // data buffer
                        pdwEncrytedBufferLen, // length of data
                        dwBufferLen ) ) // size of buffer
    {
        ErrorTrace(CRYPT_FNC_ID, "Error 0x%x during CryptEncrypt",
                   GetLastError());
        dwError = CRYPT_FNC_INTERNAL_ERROR;
        goto cleanup;
    }

    _VERIFY(CryptDestroyKey(hKey));
    _VERIFY(CryptDestroyKey(hXchgKey));

    TraceFunctLeave();
    return CRYPT_FNC_NO_ERROR;
    
cleanup:
    // Destroy key exchange key handle.
    if(hXchgKey != 0)
        _VERIFY(CryptDestroyKey(hXchgKey));

     // destroy session key
    if (hKey != 0)
        _VERIFY(CryptDestroyKey(hKey));
    
    TraceFunctLeave();    
    return dwError;
}


/*
  This function performs the reverse of EncryptDataAndExportSessionKey:
  1. It imports the session key using the private key in the CSP that
     was used to encrypt the secret data.
  2. It decrypts the secret data using this session key - return this
     value in the pbData parameter

     
  returns
   CRYPT_FNC_NO_ERROR   no error
   CRYPT_FNC_INSUFFICIENT_BUFFER larger buffer is required
   *pdwDataLen is set to required length
   CRYPT_FNC_INIT_NOT_CALLED InitCrypt not successfully called
   CRYPT_FNC_INTERNAL_ERROR 
   
*/
DWORD CCryptFunctions::ImportSessionKeyAndDecryptData(
    BYTE * pbData, // Buffer to store secret Data
    DWORD * pdwDataLen, // Length of Above buffer
    BYTE * pbEncryptedData, // Buffer that stores Encrypted Data
    DWORD  dwEncrytedBufferLen, // Length of above data
    BYTE * pbEncryptedSessionKey, // Buffer that stores encrypted session key
    DWORD    dwEncrytedSessionKeyLength) // Length of above data
{
    HCRYPTKEY hKey = 0;    
    DWORD  dwError;
    
    TraceFunctEnter("ImportSessionKeyAndDecryptData");
    
     // Init should have been successfully called before
    if (m_hProv== 0)
    {
        dwError = CRYPT_FNC_INIT_NOT_CALLED;
        goto cleanup;
    }

     // now import the key from the registry
     // Import key blob into CSP.
    if(!CryptImportKey(    m_hProv, // CSP provider
                        pbEncryptedSessionKey,// buffer that stores encrypted
                         // session key
                        dwEncrytedSessionKeyLength,// length of data in
                         // above buffer
                        0, // since we have a SIMPLEBLOB and the key blob
                         // is encrypted with the key exchange key pair, this
                         // parameter is zero
                        0, // flags 
                        &hKey)) // key to export to 
    {
        ErrorTrace(CRYPT_FNC_ID,"Error 0x%x during CryptImportKey",
                   GetLastError());
        dwError = CRYPT_FNC_INTERNAL_ERROR;        
        goto cleanup;
    }


     // check if buffer is large enough
    if ( dwEncrytedBufferLen >  *pdwDataLen )
    {
        dwError = CRYPT_FNC_INSUFFICIENT_BUFFER;
        *pdwDataLen = dwEncrytedBufferLen;        
        goto cleanup;
    }
    
     // copy the data into another buffer to encrypt it
    memcpy (pbData, pbEncryptedData, dwEncrytedBufferLen);

    *pdwDataLen = dwEncrytedBufferLen;
    
     // now decrypt the secret key using the key generated
    if ( ! CryptDecrypt(hKey,
                        0, // no hash required
                        TRUE, // Final packet
                        0, // Flags - always 0
                        pbData, // data buffer
                        pdwDataLen )) // length of data
    {
        ErrorTrace(CRYPT_FNC_ID,"Error 0x%x during CryptDecrypt",
                    GetLastError());
        dwError = CRYPT_FNC_INTERNAL_ERROR;        
        goto cleanup;
    }
    
    _VERIFY(CryptDestroyKey(hKey));


    TraceFunctLeave();
    return CRYPT_FNC_NO_ERROR;
    
cleanup:

     // destroy session key
    if (hKey != 0)
        _VERIFY(CryptDestroyKey(hKey));
    
    TraceFunctLeave();    
    return dwError;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\cdescrip.h ===
//#---------------------------------------------------------------
//  File:		CDescrip.h
//        
//	Synopsis:	Header for the CDescriptor class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------

#ifndef	_CDECRIPTOR_H_
#define _CDECRIPTOR_H_

#define AVAIL_SIGNATURE 	(DWORD)'daeD' 
#define DEFAULT_SIGNATURE 	(DWORD)'Defa' 

typedef enum _DESCRIPTOR_STATE_TYPE
{
    DESCRIPTOR_FREE,
    DESCRIPTOR_INUSE,
} DESCRIPTOR_STATE_TYPE;

#include "dbgtrace.h"

class CPool;

void InitializeUniqueIDs( void );
void TerminateUniqueIDs( void );

class CDescriptor
{
	public:
		CDescriptor( DWORD dwSig );
		~CDescriptor( void );

		inline DWORD GetSignature( void );
		inline DWORD GetUniqueObjectID( void );
		inline DESCRIPTOR_STATE_TYPE GetState( void );

	private:
		//
		// Structure signature
		// 
	 	const DWORD				m_dwSignature;
		//
		// unique object identifier assigned from a static DWORD that is
		//	updated with each new object being marked, In_use.
		//
		DWORD					m_dwUniqueObjectID;
		//
		// the object state
		//
		DESCRIPTOR_STATE_TYPE	m_eState;
		//
		// pointer to a generic reference item (the membership pool)
		//
#ifdef DEBUG
		inline void IsValid( void );
#else
		void IsValid( void ) { return; }
#endif
};


//+---------------------------------------------------------------
//
//  Function:	GetSignature
//
//  Returns:	the current descriptor signature
//
//  History:	HowardCu	Created						8 May 1995
//              t-alexwe    cleaned up param checking   19 Jun 1995
//				t-alexwe	inlined						27 Jun 1995
//
//----------------------------------------------------------------
inline DWORD CDescriptor::GetSignature(void)
{
	return m_dwSignature;
}

//+---------------------------------------------------------------
//
//  Function:	GetUniqueObjectID
//
//  Returns:	the current object ID
//
//  History:	HowardCu	Created						8 May 1995
//              t-alexwe    cleaned up param checking   19 Jun 1995
//				t-alexwe	inlined						27 Jun 1995
//
//----------------------------------------------------------------
inline DWORD CDescriptor::GetUniqueObjectID(void)
{
	IsValid();
	return m_dwUniqueObjectID;
}

//+---------------------------------------------------------------
//
//  Function:	GetState
//
//  Returns:	the current descriptor state
//
//  History:	HowardCu	Created						8 May 1995
//              t-alexwe    cleaned up param checking   19 Jun 1995
//				t-alexwe	inlined						27 Jun 1995
//
//----------------------------------------------------------------
inline DESCRIPTOR_STATE_TYPE CDescriptor::GetState(void)
{
	IsValid();
	return m_eState;
}


//
// this function only exists in debug builds and does parameter
// checking on many of the member variable for the CDescriptor class.
//
#ifdef DEBUG
inline void CDescriptor::IsValid()
{
    _ASSERT( m_dwSignature != AVAIL_SIGNATURE );
    _ASSERT( m_dwUniqueObjectID != 0l );
    _ASSERT( m_eState == DESCRIPTOR_INUSE );
}
#endif

#endif //!_CDECRIPTOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\ceventlogger.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    CEventLogger.h

Abstract:
	This file contains the header file for the CEventLogger class which is
	used to log events across threads and processes.


Revision History:
	  Eugene Mesgar		(eugenem)	6/16/99
		created

******************************************************************************/

#ifndef __EVENTLOGGER__
#define __EVENTLOGGER__


#define	TRIM_AT_SIZE		200000
#define NEW_FILE_SIZE		100000
#define MAX_BUFFER          1024


/*
 *	Logging Levels
 */


#define LEVEL_DEBUG		5
#define LEVEL_DETAILED	4
#define LEVEL_NORMAL	3
#define LEVEL_SPARSE	2
#define LEVEL_NONE		0

#define ERROR_CRITICAL	1
#define	ERROR_NORMAL	3
#define ERROR_DEBUG		5

class CEventLogger  
{

	HANDLE m_hSemaphore;
	// brijeshk : don't need a handle member, as we open and close the log file everytime we log to it
	// HANDLE m_hLogFile;
	LPTSTR m_pszFileName;
	DWORD m_dwLoggingLevel;

	static LPCTSTR m_aszERROR_LEVELS[];


public:
	DWORD Init(LPCTSTR pszFileName, DWORD dwLogLevel);
	DWORD Init(LPCTSTR pszFileName);
	DWORD LogEvent(DWORD dwEventLevel, LPCTSTR pszEventDesc, BOOL fPopUp);
	CEventLogger();
	virtual ~CEventLogger();
 
private:
	BOOL TruncateFileSize();

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\clicnct.h ===
//
// clicnct.h - the Rome/Shuttle Client Connection API
//
// initial version - July 1995 - t-alexwe
//
// This file lives in both the Shuttle and MOS SLM trees.  In shuttle it
// belongs in \mos\h\clicnct.h.  In MOS it belongs in \mos\include\mos.
//
#ifndef _CLICNCT_H_
#define _CLICNCT_H_
#include <windows.h>

//
// this has the event codes in it
//
#include "moscl.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DllExport
#define DllExport __declspec(dllexport)
#endif // DllExport

//
// Client Connection API error codes
//
// win32 error code - customer bit set, error bits set, facility 0x300
//
#define PROXYERR_BASE 				0xE3000000
#define PROXYERR_INVALID_STATE 		(PROXYERR_BASE+0)
#define PROXYERR_UNSUPPORTED_VER	(PROXYERR_BASE+1)
#define PROXYERR_INVALID_PACKET		(PROXYERR_BASE+2)
#define PROXYERR_HOSTNAME_TOO_LONG	(PROXYERR_BASE+3)
#define PROXYERR_TOO_MANY_SOCKOPTS	(PROXYERR_BASE+4)
#define PROXYERR_AUTH_ERROR			(PROXYERR_BASE+5)

//
// this is the callback function that will be called with event progress.
// it uses the events above
//
// possible events:
//
typedef void (WINAPI *EVENT_CALLBACK)(DWORD obj, DWORD event, DWORD errcode);
typedef void (WINAPI *ERRORLOG_CALLBACK)(DWORD obj, PSTR psz, DWORD dw);

//
// structure for passing socket options in ProxyConnectOpen().  Each element
// has the same purpose as the similarily named parameter in setsockopt().
//
typedef struct {
	int 			level;
	int				optname;
	const char FAR 	*optval;
	int				optlen;
} *PSOCKOPT, SOCKOPT;


// Init and Deinit functions because launching and killing threads in DLLMain
// causes major grief
DllExport void WINAPI ProxyDllStartup(void);
DllExport void WINAPI ProxyDllShutdown(void);

typedef void (WINAPI *LPFNPROXYDLLSTARTUP)(void);
typedef void (WINAPI *LPFNPROXYDLLSHUTDOWN)(void);

//
// Synopsis
// 	API takes a DialParams string in the form below
// 	dials up primary/backup phone number as configured in registry
//
// Parameters:
//  pszDialParams	- <P|B>:<username>:<password>
//	phEventHandle 	- returned: an event handle that is signalled when
//					  the dialing is complete (or an error has occured).
//	lpfnEventCb		- fn ptr to post events & errors
//	lpfnErrorCb		- fn ptr to log (for stats/debugging) errors 
//  dwLogParam		- magic cookie passed into lpfnEventCb, lpfnErrorCb
//	pdwDialId	    - returned: a dialing ID that can be used by
//					  ProxyDialClose() and ProxyDialGetResult().
//
// Returns: 
//	Success			- ERROR_SUCCESS (0)
//	Failure			- NT or WinSock error code
//
DllExport DWORD WINAPI ProxyDialOpen(PSTR 	  lpszDialParams,	// [in]
							EVENT_CALLBACK	  lpfnEventCb,		// [in]
							ERRORLOG_CALLBACK lpfnErrLogCb,		// [in]
							DWORD			  dwLogParam,		// [in]
							PHANDLE			  phEventHandle,	// [out]
							PDWORD			  pdwDialId );		// [out]

typedef DWORD (WINAPI *LPFNPROXYDIALOPEN)(PSTR, EVENT_CALLBACK, ERRORLOG_CALLBACK, DWORD, PHANDLE, PDWORD);

//
// Synopsis:
//	Closes a dial connection started by ProxyDialOpen().  
//	Cancels dial if still in progress.
//
// Parameters:
//	dwConnectId		- the dial ID returned by ProxyDialOpen()
//
// Returns:
//	Success			- ERROR_SUCCESS(0)
//	Failure			- NT or WinSock error code
//
// Notes:
// 	This should always succeed unless passed in invalid parameters.
//
DllExport DWORD WINAPI ProxyDialClose(DWORD	dwConnectId);	// [in]

typedef DWORD (WINAPI *LPFNPROXYDIALCLOSE)(DWORD);

//
// Synopsis:
//	Gets dial completion status a dial started by ProxyDialOpen().
//
// Parameters:
//	dwConnectId		- the dial ID returned by ProxyDialOpen()
//
// Returns:
//	Success			- ERROR_SUCCESS(0)
//	Failure			- NT or WinSock error code
// 	
DllExport DWORD WINAPI ProxyDialGetResult(DWORD dwConnectId);	// [in]

typedef DWORD (WINAPI *LPFNPROXYDIALGETRESULT)(DWORD);

//
// Synopsis:
//	Gets dial error-log string in specific format
//  applicable only to TCPCONN.DLL. Other proxy DLLs
//  should _not_ implement this entry point!!
//
// Parameters:
//	dwConnectId		- the dial ID returned by ProxyDialOpen()
//  pszErrStr		- buffer to write result into
//	dwLen			- length of buffer
//
// Returns:
//	Success			- ERROR_SUCCESS(0)
//	Failure			- NT or WinSock error code
// 	
DllExport DWORD WINAPI ProxyDialGetErrorLogString(DWORD dwConnectId, PSTR pszStr, DWORD dwLen);	// [in]

typedef DWORD (WINAPI *LPFNPROXYDIALGETERRORLOGSTRING)(DWORD, PSTR, DWORD);

//=====================================================

//
// Synopsis
// 	API takes a hostname for MSN and socket options for the socket to
// 	be created and returns immediatly with an event handle and a 
// 	connection ID.  The calling process should wait on the event
// 	handle for completion.  The connection ID is used for CancelConnect()
// 	and ProxyConnectGetResult().
//
// Parameters:
//	pszDNSName0		- the PRIMARY hostname to connect to
//	pszDNSName1		- the BACKUP hostname to connect to
//	wPort			- the TCP/IP port to connect to
//	pSockopts		- the socket options to use on the socket
//	cSockopts 		- the number of socket options in pSockopts
//	lpfnEventCb		- fn ptr to post events & errors
//	lpfnErrorCb		- fn ptr to log (for stats/debugging) errors 
//  dwLogParam		- magic cookie passed into lpfnEventCb, lpfnErrorCb
//	phEventHandle 	- returned: an event handle that is signalled when
//					  the connection is complete (or an error has occured).
//	pdwConnectId	- returned: a connection ID that can be used by
//					  ProxyConnectClose() and ProxyConnectGetResult().
//
// Returns: 
//	Success			- ERROR_SUCCESS (0)
//	Failure			- NT or WinSock error code
//
DllExport DWORD WINAPI ProxyConnectOpen(PSTR	pszDNSName0,	// [in]
							 PSTR				pszDNSName1,	// [in]
							 WORD				wPort,			// [in]
							 PSOCKOPT			pSockopts,		// [in]
							 DWORD				cSockopts,		// [in]
							 EVENT_CALLBACK		lpfnEventCb,	// [in]
							 ERRORLOG_CALLBACK	lpfnErrLogCb,	// [in]
							 DWORD				dwLogParam,		// [in]
							 PHANDLE			phEventHandle,	// [out]
							 PDWORD				pdwConnectId );	// [out]

typedef DWORD (WINAPI *LPFNPROXYCONNECTOPEN)(PSTR, PSTR, WORD, PSOCKOPT, DWORD, EVENT_CALLBACK, ERRORLOG_CALLBACK, DWORD, PHANDLE, PDWORD);

//
// Synopsis:
//	Closes a connection opened by ProxyConnectOpen().  
//	Cancels a connection attempt if in progress.
//
// Parameters:
//	dwConnectId		- the connection ID returned by ProxyConnectOpen()
//
// Returns:
//	Success			- ERROR_SUCCESS(0)
//	Failure			- NT or WinSock error code
//
// Notes:
// 	This should always succeed unless passed in invalid parameters.
//
DllExport DWORD WINAPI ProxyConnectClose(DWORD	dwConnectId	);		// [in]

typedef DWORD (WINAPI *LPFNPROXYCONNECTCLOSE)(DWORD);

//
// Synopsis:
//	Gets a connected socket handle from a connection started by
//	ProxyConnectOpen().
//
// Parameters:
//	hEventHandle	- the event handle returned by ProxyConnectOpen()
//	dwConnectId		- the connection ID returned by ProxyConnectOpen()
//	phSocket		- returned: the socket handle
//
// Returns:
//	Success			- ERROR_SUCCESS(0)
//	Failure			- NT or WinSock error code
// 	
DllExport DWORD WINAPI ProxyConnectGetResult(DWORD		dwConnectId, // [in]
								  			 PHANDLE	phSocket );	 // [out]

typedef DWORD (WINAPI *LPFNPROXYCONNECTGETRESULT)(DWORD, PHANDLE);

//
// Synopsis:
//	Gets the set of local IP addres in a string in specific format
//  applicable only to TCPCONN.DLL. Other proxy DLLs
//  should _not_ implement this entry point!!
//
// Parameters:
//	dwConnectId		- the dial ID returned by ProxyConnectOpen()
//
// Returns:
//	Success			- string ptr (LocalAlloc'd string)
//	Failure			- NULL
// 	
DllExport PSTR WINAPI ProxyConnectGetMyIPAddrs(DWORD dwConnectId);	// [in]

typedef PSTR (WINAPI *LPFNPROXYCONNECTGETMYIPADDRS)(DWORD);

typedef struct 
{
	HINSTANCE					hinst;
	LPFNPROXYDLLSTARTUP			lpfnProxyDllStartup;
	LPFNPROXYDLLSHUTDOWN		lpfnProxyDllShutdown;
	LPFNPROXYDIALOPEN			lpfnProxyDialOpen;
	LPFNPROXYDIALCLOSE			lpfnProxyDialClose;
	LPFNPROXYDIALGETRESULT		lpfnProxyDialGetResult;
	LPFNPROXYCONNECTOPEN		lpfnProxyConnectOpen;
	LPFNPROXYCONNECTCLOSE		lpfnProxyConnectClose;
	LPFNPROXYCONNECTGETRESULT	lpfnProxyConnectGetResult;
	LPFNPROXYCONNECTGETMYIPADDRS   lpfnProxyConnectGetMyIPAddrs;
	LPFNPROXYDIALGETERRORLOGSTRING lpfnProxyDialGetErrorLogString;
}
PROXYDLLPTRS, *PPROXYDLLPTRS;

#define SZPROXYDLLSTARTUP		"ProxyDllStartup"
#define SZPROXYDLLSHUTDOWN		"ProxyDllShutdown"
#define SZPROXYDIALOPEN			"ProxyDialOpen"
#define SZPROXYDIALCLOSE		"ProxyDialClose"
#define SZPROXYDIALGETRESULT	"ProxyDialGetResult"
#define SZPROXYCONNECTOPEN		"ProxyConnectOpen"
#define SZPROXYCONNECTCLOSE		"ProxyConnectClose"
#define SZPROXYCONNECTGETRESULT	"ProxyConnectGetResult"
#define SZPROXYCONNECTGETMYIPADDRS   "ProxyConnectGetMyIPAddrs"
#define SZPROXYDIALGETERRORLOGSTRING "ProxyDialGetErrorLogString"

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\cobjid.h ===
//#---------------------------------------------------------------
//  File:       CObjID.h
//        
//  Synopsis:   Header for the CObjectID
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------

#ifndef _COBJECTID_H_
#define _COBJECTID_H_

#define INITIALOBJECTID     0x12345678
#define OBJECTIDINCREMENT   1

class CObjectID
{
    public:
        CObjectID( void );
        ~CObjectID( void );
        DWORD GetUniqueID( void );
    private:
        //
        // object ID holder
        // 
        DWORD                   m_dwObjectID;
        //
        // critical section to generate unique ID
        // 
        CRITICAL_SECTION        m_ObjIDCritSect;
};

#endif //!_COBJECTID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\cpool.h ===
//#---------------------------------------------------------------
//  File:		CPool.h
//        
//	Synopsis:	Header for the CPool class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------

#ifndef	_CPOOL_H_
#define _CPOOL_H_

#include "dbgtrace.h"

#define POOL_SIGNATURE	 			(DWORD)'looP' 
#define UPSTREAM_SIGNATURE 			(DWORD)'tspU' 
#define DOWNSTREAM_SIGNATURE 		(DWORD)'tsnD' 
#define AUTHENTICATION_SIGNATURE 	(DWORD)'htuA' 
#define USER_SIGNATURE 				(DWORD)'resU' 
#define PROXY_SIGNATURE 		    (DWORD)'xorP' 

#define	DEFAULT_ALLOC_INCREMENT		0xFFFFFFFF

//
// maximum number of VirtualAlloc chunks to allow
//

#define	MAX_CPOOL_FRAGMENTS			16


class CPool
{
		//
		// struct def'n for linking free instances
		// see page 473 of Stroustrup
		//
		struct	Link	{ Link*	pNext; };

	public:
		CPool( DWORD dwSignature=1 );
		~CPool( void );

	    void *operator new( size_t cSize )
						{ return HeapAlloc( GetProcessHeap(), 0, cSize ); }

	    void operator delete (void *pInstance)
						{ HeapFree( GetProcessHeap(), 0, pInstance ); }

#ifdef DEBUG
		void	IsValid( void );
#else
		inline void IsValid( void ) { return; }
#endif
		//
		// to be called after the constructor to VirtualAlloc the necessary
		// memory address
		//
		BOOL	ReserveMemory(	DWORD MaxInstances,
								DWORD InstanceSize,
								DWORD IncrementSize = DEFAULT_ALLOC_INCREMENT ); 

		BOOL	ReleaseMemory( void );

		void*	Alloc( void );
		void	Free( void* pInstance );

		DWORD	GetContentionCount( void );

		DWORD	GetEntryCount( void );

		DWORD	GetTotalAllocCount()
				{ return	m_cTotalAllocs; }

		DWORD	GetTotalFreeCount()
				{ return	m_cTotalFrees; }

		DWORD	GetTotalExtraAllocCount()
				{ return	m_cTotalExtraAllocs; }

		DWORD	GetCommitCount()
				{ return	m_cNumberCommitted; }

		DWORD	GetAllocCount()
				{ return	m_cNumberInUse; }

		DWORD	GetInstanceSize(void);

	private:
		//
		// internal function to alloc more mem from the OS
		//
		void 	GrowPool( void );
		//
		// Structure signature for a pool object
		// 
		const DWORD			m_dwSignature;
		//
		// total number of descriptors ( maximum )
		//
		DWORD				m_cMaxInstances;
		//
		// size of the descriptor
		//
		DWORD				m_cInstanceSize;
		//
		// virtual array number of committed instances
		//
		DWORD				m_cNumberCommitted;
		//
		// number of In_use instances ( debug/admin only )
		//
		DWORD				m_cNumberInUse;
		//
		// number of Free instances ( debug/admin only )
		//
		DWORD				m_cNumberAvail;
		//
		// the handle of the pool critical section
		//
		CRITICAL_SECTION	m_PoolCriticalSection;
		//
		// the pointer to the first descriptor on the free list
		//
		Link				*m_pFreeList;
		//
		// the pointer to a free descriptor not on the free list
		//
		Link				*m_pExtraFreeLink;
		//
		// number to increment the pool when expanding
		//
		DWORD				m_cIncrementInstances;

		//
		// Debug counters for perf testing ( debug/admin only )
		//
		DWORD				m_cTotalAllocs;
		DWORD				m_cTotalFrees;
		DWORD				m_cTotalExtraAllocs;

		//
		// Debug variables to help catch heap bugs
		//
		Link				*m_pLastAlloc;
		Link				*m_pLastExtraAlloc;

		//
		// size of each fragment in instances
		//
		DWORD				m_cFragmentInstances;

		//
		// maximum number of fragments
		//
		DWORD				m_cFragments;

		//
		// maximum number of fragments
		//
		LPVOID				m_pFragments[ MAX_CPOOL_FRAGMENTS ];
};



#endif //!_CPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\cliproto.h ===
//#---------------------------------------------------------------
//  File:       cliproto.h
//        
//  Synopsis:   header for shuttle client protocol
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    t-alexwe
//----------------------------------------------------------------

#ifndef _CLIPROTO_H_
#define _CLIPROTO_H_

#include <windows.h>
#define SECURITY_WIN32

#define PROXY_PROTOCOL_VERSION MAKEWORD(1, 0)

#define MAXPACKETDATASIZE 960
#define MAXMSGSPERPACKET 4

//
// make sure everything is byte aligned
//
#pragma pack(1)

//
// the message structure
//
typedef struct {
	WORD			wCommand;			// the command requested
	WORD			cData;				// the amount of data
	WORD			cOffset;			// the offset of the data into the
										// the packets pData
} PROXYMESSAGE, *PPROXYMESSAGE;

//
// client connection protocol packet structure
//
// each packet contains 1 to 4 messages.  
//
typedef struct {
	WORD			cLength;			// the length of this packet
	WORD			cMessages;			// the message count in this packet
	//
	// information for each message
	//
	PROXYMESSAGE	pMessages[MAXMSGSPERPACKET];		
	//
	// the packets data
	//
	BYTE			pData[MAXPACKETDATASIZE];
} PROXYPACKET, *PPROXYPACKET;

#define PACKETHDRSIZE (sizeof(PROXYPACKET) - MAXPACKETDATASIZE)

//
// message types (wCommand in PROXYMESSAGE)
//
// format:
// | 16 | 15       -          0 |
//
// bit 16 - if 0 then message is handled by Shuttle server, if 1 then
// message is handled by client.
//
// generally these are laid out in the order that they are expected to be
// received in.  a command of type wCommand should return a message of type
// wCommand | 0x8000.
//
// Only exception is that PROXY_NEGOTIATE can return a PROXY_CHALLENGE or
// a PROXY_ACCEPT message.
//
#define PROXY_VERSION 				0x0000
#define PROXY_VERSION_RETURN 		0x8000
#define PROXY_NEGOTIATE 			0x0001
#define PROXY_CHALLENGE 			0x8001
#define PROXY_ACCEPT 				0x8002
#define PROXY_GETHOSTBYNAME			0x0003
#define PROXY_GETHOSTBYNAME_RETURN	0x8003
#define PROXY_CONNECT				0x0004
#define PROXY_CONNECT_RETURN		0x8004
#define PROXY_SETSOCKOPT			0x0005
#define PROXY_SETSOCKOPT_RETURN		0x8005
#define PROXY_DOGATEWAY				0x0006
#define PROXY_DOGATEWAY_RETURN		0x8006
#define MAX_PROXY_SRV_COMMAND		PROXY_DOGATEWAY

#define PROXY_NOMESSAGE				0xffff

//
// include the error codes from the client connection API
//
#include <clicnct.h>

//
// message data formats
//
// packet data sizes need to be < MAXDATASIZE bytes, so the total size
// of a group of messages going in one packet should be < MAXDATASIZE bytes.
//
// error codes are NT/WinSock or PROXYERR error codes
//
#define MAXCOMPUTERNAME MAX_COMPUTERNAME_LENGTH + 1
typedef struct {
	WORD				wRequestedVersion;	// requested ver of the protocol
	DWORD				cComputerName;		// length of the computer name
	CHAR				pszComputerName[MAXCOMPUTERNAME];	// cli's comp name
} PROXY_VERSION_DATA, *PPROXY_VERSION_DATA;

typedef struct {
	DWORD				dwError;			// error code
	WORD				wVersion;			// version of protocol used
	WORD				wHighVersion;		// highest version supported
} PROXY_VERSION_RETURN_DATA, *PPROXY_VERSION_RETURN_DATA;

#define SECBUFSIZE 768

typedef struct {
	WORD				cNegotiateBuffer;
	BYTE				pNegotiateBuffer[SECBUFSIZE];
} PROXY_NEGOTIATE_DATA, *PPROXY_NEGOTIATE_DATA;

typedef struct {
	WORD				cChallengeBuffer;
	BYTE				pChallengeBuffer[SECBUFSIZE];
} PROXY_CHALLENGE_DATA, *PPROXY_CHALLENGE_DATA;

typedef struct {
	DWORD				dwError;			// error code
} PROXY_ACCEPT_DATA, *PPROXY_ACCEPT_DATA;

#define MAXHOSTNAMELEN 512
#define MAXADDRLISTSIZE 128

typedef struct {
	WORD				cHostname;						// length of hostname
	char				pszHostname[MAXHOSTNAMELEN];	// hostname
} PROXY_GETHOSTBYNAME_DATA, *PPROXY_GETHOSTBYNAME_DATA;

typedef struct {
	DWORD				dwError;			// error code
	WORD				cAddr;				// number of addresses
	WORD				h_addrtype;			// should always be AF_INET
	WORD				h_length;			// the length of each addr
											// should always be 4
	//
	// the addresses.  this has cAddr addresses in it.  each address is of
	// length h_length and the first one starts at h_addr_list[0].
	//
	BYTE				h_addr_list[MAXADDRLISTSIZE];
} PROXY_GETHOSTBYNAME_RETURN_DATA, *PPROXY_GETHOSTBYNAME_RETURN_DATA;

typedef struct {
	WORD				cAddr;				// the length of the address (16)
	struct sockaddr		addr;				// the address
} PROXY_CONNECT_DATA, *PPROXY_CONNECT_DATA;

typedef struct {
	DWORD				dwError;			// error code
} PROXY_CONNECT_RETURN_DATA, *PPROXY_CONNECT_RETURN_DATA;

#define MAXSOCKOPTS 32						// maximum sockopts per packet
#define MAXOPTVAL 16						// maximum length of optval

typedef struct {
	WORD				level;				// option level
	WORD				optname;			// option name
	BYTE				optval[MAXOPTVAL];	// option value
	WORD				optlen;				// option length (<= MAXOPTVAL)
} NETSOCKOPT, *PNETSOCKOPT;

typedef struct {
	DWORD				cSockopt;				// number of socket options
	NETSOCKOPT			sockopts[MAXSOCKOPTS];	// the socket options
} PROXY_SETSOCKOPT_DATA, *PPROXY_SETSOCKOPT_DATA;

typedef struct {
	DWORD				dwError;			// error code
} PROXY_SETSOCKOPT_RETURN_DATA, *PPROXY_SETSOCKOPT_RETURN_DATA;

typedef struct {
	BYTE				reserved;			// we need some data...
} PROXY_DOGATEWAY_DATA, *PPROXY_DOGATEWAY_DATA;

typedef struct {
	DWORD				dwError;			// error code
} PROXY_DOGATEWAY_RETURN_DATA, *PPROXY_DOGATEWAY_RETURN_DATA;

#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\cryptfnc.h ===
//+---------------------------------------------------------------------------
//
//  File:       cryptfnc.h
//
//  Contents:	Defines the Class CCryptFunctions
//				
//
//  History:    AshishS    Created     11/28/96
//
//----------------------------------------------------------------------------

#ifndef  _CRYPT_FNC_H
#define  _CRYPT_FNC_H

#define CRYPT_FNC_ID 2983

#include <windows.h>
#include <wincrypt.h>


#define   CRYPT_FNC_NO_ERROR   0
#define   CRYPT_FNC_BAD_PASSWORD 1
#define   CRYPT_FNC_INSUFFICIENT_BUFFER 2
#define   CRYPT_FNC_INIT_NOT_CALLED 3
#define   CRYPT_FNC_INTERNAL_ERROR 4
   
#define   CRYPTFNC_SEMAPHORE_NAME     TEXT("SS_Cryptfnc_Semaphore_For_CAPI")

class CCryptFunctions
{
	HCRYPTPROV m_hProv;
    HANDLE     m_hSemaphore;
    
	BOOL GenerateSessionKeyFromPassword(
		HCRYPTKEY * phKey, // location to store the key
		TCHAR * pszPassword); // password to generate the key from
	
public:

	CCryptFunctions();
	
	~CCryptFunctions();
	
	BOOL  InitCrypt();
	
	BOOL GenerateSecretKey(
		BYTE * pbData,// Buffer to store secret key
		 //buffer must be long enough for dwLength bytes
		DWORD dwLength ); // length of secret key in bytes
	
	BOOL EncryptDataWithPassword(
		TCHAR * pszPassword, // password	
		BYTE * pbData, // Data to be encrypted
		DWORD dwDataLength, // Length of data in bytes
		BYTE * pbEncyrptedData, // Encrypted secret key will be stored here
		DWORD * pdwEncrytedBufferLen // Length of this buffer
		);

	BOOL CCryptFunctions::GenerateHash(
		BYTE * pbData, // data to hash
		DWORD dwDataLength, // length of data to hash
		BYTE * pbData1, // another data to hash
		DWORD dwData1Length, // length of above data
		BYTE * pbData2, // another data to hash
		DWORD dwData2Length, // length of above data
		BYTE * pbData3, // another data to hash
		DWORD dwData3Length, // length of above data
		BYTE * pbHashBuffer, // buffer to store hash
		DWORD * pdwHashBufLen);//length of buffer to store Hash
	
	DWORD DecryptDataWithPassword(
		TCHAR * pszPassword, // password	
		BYTE * pbData, // Decrypted Data will be stored here
		DWORD *pdwDataBufferLength, // Length of the above buffer in bytes
		BYTE * pbEncryptedData, // Encrypted data
		DWORD dwEncrytedDataLen // Length of encrypted data
		);
	
	DWORD EncryptDataAndExportSessionKey(
		BYTE * pbData, // Secret Data
		DWORD dwDataLen, // Secret Data Length
		BYTE * pbEncryptedData, // Buffer to store Encrypted Data
		DWORD * pdwEncrytedBufferLen, // Length of above buffer
		BYTE * pbEncryptedSessionKey, // Buffer to store encrypted session key
		DWORD * pdwEncrytedSessionKeyLength); // Length of above buffer

	DWORD ImportSessionKeyAndDecryptData(
		BYTE * pbData, // Buffer to store secret Data
		DWORD * pdwDataLen, // Length of Above buffer
		BYTE * pbEncryptedData, // Buffer that stores Encrypted Data
		DWORD  dwEncrytedBufferLen, // Length of above data
		BYTE * pbEncryptedSessionKey,// Buffer that stores encrypted sessionkey
		DWORD	dwEncrytedSessionKeyLength); // Length of above data
		 
};

typedef CCryptFunctions  CCRYPT_FUNCTIONS;
typedef CCryptFunctions  *PCCRYPT_FUNCTIONS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\crypt.h ===
//+---------------------------------------------------------------------------
//
//  File:       crypt.h
//
//  Contents:	Functions that had to be mostly borrowed from NT src tree
//
//  History:    SudK    Created     6/25/95
//
//----------------------------------------------------------------------------
#ifndef _NTCRYPT_
#define _NTCRYPT_

#ifndef MIDL_PASS    // Don't confuse MIDL

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#ifndef WIN16_BUILD
#include <rpc.h>   
#else 
#define NTAPI FAR PASCAL
#define IN
#define OUT
#define BOOLEAN BOOL
#define OPTIONAL
#define NTSYSAPI
#endif

#endif // MIDL_PASS


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    CHAR    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;


#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    CHAR    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;


#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    CHAR    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    ULONG   Length;         // Number of valid bytes in buffer
    ULONG   MaximumLength;  // Number of bytes pointed to by Buffer
    PVOID   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef CHAR *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)

typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;



//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH

typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;



//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;



//
// Define the index type used to encrypt OWF Passwords
//

typedef LONG                        CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types that are used to duplicate existing LM        //
//      functionality with improved algorithms.                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef UNICODE_STRING              NT_PASSWORD;
typedef NT_PASSWORD *               PNT_PASSWORD;


#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH

typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;


#define NT_CHALLENGE_LENGTH         LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;


#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;


#define ENCRYPTED_NT_OWF_PASSWORD_LENGTH ENCRYPTED_LM_OWF_PASSWORD_LENGTH

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;


#define NT_SESSION_KEY_LENGTH       LM_SESSION_KEY_LENGTH

typedef LM_SESSION_KEY              NT_SESSION_KEY;
typedef NT_SESSION_KEY *            PNT_SESSION_KEY;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types for new functionality not present in LM       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The user session key is similar to the LM and NT session key except it
// is different for each user on the system. This allows it to be used
// for secure user communication with a server.
//
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;



////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define RtlEncryptBlock                 SystemFunction001
#define RtlDecryptBlock                 SystemFunction002
#define RtlEncryptStdBlock              SystemFunction003
#define RtlEncryptData                  SystemFunction004
#define RtlDecryptData                  SystemFunction005
#define RtlCalculateLmOwfPassword       SystemFunction006
#define RtlCalculateNtOwfPassword       SystemFunction007
#define RtlCalculateLmResponse          SystemFunction008
#define RtlCalculateNtResponse          SystemFunction009
#define RtlCalculateUserSessionKeyLm    SystemFunction010
#define RtlCalculateUserSessionKeyNt    SystemFunction011
#define RtlEncryptLmOwfPwdWithLmOwfPwd  SystemFunction012
#define RtlDecryptLmOwfPwdWithLmOwfPwd  SystemFunction013
#define RtlEncryptNtOwfPwdWithNtOwfPwd  SystemFunction014
#define RtlDecryptNtOwfPwdWithNtOwfPwd  SystemFunction015
#define RtlEncryptLmOwfPwdWithLmSesKey  SystemFunction016
#define RtlDecryptLmOwfPwdWithLmSesKey  SystemFunction017
#define RtlEncryptNtOwfPwdWithNtSesKey  SystemFunction018
#define RtlDecryptNtOwfPwdWithNtSesKey  SystemFunction019
#define RtlEncryptLmOwfPwdWithUserKey   SystemFunction020
#define RtlDecryptLmOwfPwdWithUserKey   SystemFunction021
#define RtlEncryptNtOwfPwdWithUserKey   SystemFunction022
#define RtlDecryptNtOwfPwdWithUserKey   SystemFunction023
#define RtlEncryptLmOwfPwdWithIndex     SystemFunction024
#define RtlDecryptLmOwfPwdWithIndex     SystemFunction025
#define RtlEncryptNtOwfPwdWithIndex     SystemFunction026
#define RtlDecryptNtOwfPwdWithIndex     SystemFunction027
#define RtlGetUserSessionKeyClient      SystemFunction028
#define RtlGetUserSessionKeyServer      SystemFunction029
#define RtlEqualLmOwfPassword           SystemFunction030
#define RtlEqualNtOwfPassword           SystemFunction031
#define RtlEncryptData2                 SystemFunction032
#define RtlDecryptData2                 SystemFunction033


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// Core block encryption functions
//

NTSTATUS
NTAPI
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

NTSTATUS
NTAPI
RtlDecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    );

NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

//
// Arbitrary length data encryption functions
//

NTSTATUS
NTAPI
RtlEncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    );

NTSTATUS
NTAPI
RtlDecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    );

//
// Faster arbitrary length data encryption functions (using RC4)
//

NTSTATUS
RtlEncryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

NTSTATUS
RtlDecryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

//
// Password hashing functions (One Way Function)
//

NTSTATUS
NTAPI
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
NTAPI
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );



//
// OWF password comparison functions
//

BOOLEAN
RtlEqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    );

BOOLEAN
RtlEqualNtOwfPassword(
    IN PNT_OWF_PASSWORD NtOwfPassword1,
    IN PNT_OWF_PASSWORD NtOwfPassword2
    );



//
// Functions for calculating response to server challenge
//

NTSTATUS
NTAPI
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    );


NTSTATUS
NTAPI
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    );




//
// Functions for calculating User Session Key.
//

//
// Calculate a User Session Key from LM data
//
NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

//
// Calculate a User Session Key from NT data
//
NTSTATUS
NTAPI
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );





//
// OwfPassword encryption functions
//


//
// Encrypt OwfPassword using OwfPassword as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtOwfPwd(
    IN PNT_OWF_PASSWORD DataNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtOwfPwd(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PNT_OWF_PASSWORD DataNtOwfPassword
    );


//
// Encrypt OwfPassword using SessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtSesKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtSesKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using UserSessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithUserKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithUserKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlEncryptNtOwfPwdWithUserKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithUserKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using an index as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithIndex(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithIndex(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Get the user session key for an RPC connection
//

#ifndef MIDL_PASS    // Don't confuse MIDL
NTSTATUS
RtlGetUserSessionKeyClient(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyServer(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey
    );
#endif // MIDL_PASS

#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\dbgfile.h ===
/*----------------------------------------------------------------------
	dbgfile.h
		Definitions for async tracing file ATF files

	Copyright (C) 1994 Microsoft Corporation
	All rights reserved.

	Authors:
		gordm          Gord Mangione

	History:
		01/30/95 gordm		Created.
----------------------------------------------------------------------*/


//
// Trace file types and definitions
//
// The binary trace file contains the trace statement of the
// following structure. All dwLengths include the entire structure
//


typedef struct tagFIXEDTRACE
{
	WORD		wSignature;
	WORD		wLength;
	WORD		wVariableLength;
	WORD		wBinaryType;
	DWORD		dwTraceMask;
	DWORD		dwProcessId;
	DWORD		dwThreadId;
	SYSTEMTIME	TraceTime;
	DWORD 		dwParam;
	WORD		wLine;
	WORD		wFileNameOffset;
	WORD		wFunctNameOffset;
	WORD		wBinaryOffset;
} FIXEDTRACE, *PFIXEDTRACE, FIXEDTR, *PFIXEDTR;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\lockq.h ===
//
//	LOCKQ.H
//
//	This file contains classes which define a queue mechanism which will 
//	safely synchronize additions and removals from the queue, where every 
//	thread which appends to the Queue must be prepared to deal with owning the
//	queue.  Additionally, elements will come off the queue in the same order
//	that they are appended.  
//
//	The structure of a thread using this stuff should be the following : 
//
//	class	CUsefull : public CQElement { } ;
//	template	CLockQueue< CUsefull >	UsefullQ ;
//
//	
//		if( UsefullQ.Append( pUsefull ) ) {
//
//			while( UsefullQ.GetHead( &pUsefullWorkItem )  ) {
//				/* Do some usefull work. */
//
//				UsefullQ.Remove() ;
//			}
//		}
//
//	Implementation Schedule for all classes defined in this file : 
//		1 day
//
//	Unit Test schedule for all classes defined in this file : 
//		1 day
//		Unit Testing should consist of a multi theaded appli
//
//



#ifndef	_LOCKQ_H_
#define	_LOCKQ_H_

#include	"qbase.h"

#ifdef	DEBUG
#define	LOCKQ_DEBUG
#endif

#ifdef	_DEBUG
#ifndef	LOCKQ_DEBUG
#define	LOCKQ_DEBUG
#endif
#endif



//------------------------------------------------
class	CQueueLockV1	{
//
// This class implements a queue which is multi-threaded safe for append operations.
//	In addition, this queue will synchronize removal of elements amongst those 
//	threads which are appending to the queue.  Each thread that appends to the 
//	queue potentially becomes the owner of the removal lock of the queue. 
//  (If Append() returns TRUE the thread owns the removal lock of the queue.)
//	There is no way to relinquish the removal lock except to empty the queue.
//	Emptying the queue must be done as a series of GetHead(), Remove() calls.
//	A GetHead() call MUST preceed each Remove() call.
//
//	Each time the thread calls GetHead, it will be 
//	told whether it still owns the removallock (when the queue is emptied the lock is 
//	relinquished.)
//	Owning the removal lock in no way interferes with other threads appending to the queue.
//
//	The class uses InterlockedExchange to handle all synchronization issues.
//
//	For appending - InterlockedExchange does the following : 
//		Exchange the tail pointer with what we want to be the new tail.
//		Make the old tail that we got from the exchange point to the new element.
//		The list is now intact. Because there is an extra element in the queue
//		(m_special) the tail pointer never becomes NULL.
//
//	For synchronization safety - 
//		InterlockedExchange is used on the element next pointers in order to 
//		determine what thread has the removal lock.  
//		Each call to GetHead Exchanges the head's next pointer with LOCKVAL.
//		Each Append call will also Exchange the old tail elements next value 
//		with the new m_pTail value.  So there are only two threads which can 
//		be exchanging the next pointer at any given instant. 
//
//		The remove thread either gets 0 or a NON-NULL pointer after its Exchange.
//
//		If it gets Zero, it knows it Exchanged before the Appending thread, 
//		in which case it loses the lock (since it can't safely do anything.)
//		If it gets a Non-Zero value, the other thread exchanged first.
//		In this case, the remover still has the lock and repairs the list.
//
//		In the case of the appending thread - after its Exchange it either gets 
//		zero or LOCKVAL.
//
//		If the appending thread gets zero, it Exchanged first so the other thread
//		should hold onto the lock.   If the appending thread gets LOCKVAL then it 
//		owns the lock.
//
//		Finally, note that there is ALWAYS AT LEAST ONE ELEMENT in the Queue (m_special).
//		This means that if there is anything of value in the queue at all then 
//		there must be at least TWO elements in the queue (and m_pHead->p is non null).
//
//
//	Usage should be the following in each worker thread : 
//		CQueueLockV1	*pQueue ;
//
//		if( pQueue->Append( p ) ) {
//			CQueueElement *pWork ;
//
//			while( pQueue->GetHead( pWork ) ) {
//				/* Do work on pWork It is safe to do further calls to pQueue->Append()
//					while doing whatever work.  That does not mean those Appended
//					elements will be processed on this thread. */
//
//				pQueue->Remove() ;
//			}
//		}
//
private : 
	enum	CONSTANTS	{
		LOCKVAL	= 0xFFFFFFFF, 
	} ;

	CQElement	m_special ;	// element used ensure that the Queue always contains 
							// something.
	CQElement	m_release ;	// element used with ReleaseLock calls to give up the 
							//  RemovalLock on the Queue.

	//	This pointer is set after a call to ReleaseLock() - and 
	//	will pointer to the queue element before the m_release element in 
	//	the queue.
	CQElement	*m_pHead ;
	CQElement	*m_pTail ;

#ifdef	LOCKQ_DEBUG
	DWORD		m_dwOwningThread ;
	LONG		m_lock ;
#endif

	BOOL	OfferOwnership( CQElement* p ) ; 
	CQElement*	GetFront( ) ;
public : 
	CQueueLockV1( ) ;
	~CQueueLockV1( ) ;

	//
	//	Append - returns TRUE if we have added the first element into the queue
	//	and we now own the lock.
	//
	BOOL		Append( CQElement *p ) ;

	//
	// Remove - takes the head element off the list.  The head element should be 
	//  examined with GetHead().  As long as we are calling GetHead() at least once
	//	before each call to Remove(), the synchronization aspects of the queue will 
	//	work.
	//
	void		Remove( ) ;

	//
	//	GetHead - returns TRUE as long as there is an element to be had at the front 
	//	 of the queue.  The element pointer is returned through the reference to a pointer.
	//
	BOOL		GetHead( CQElement *&p ) ;

	//
	// RemoveRelease - takes the head element off the list.
	//	Also offers the removal lock to any other thread out there.
	//	If the function returns TRUE then this thread still has the lock, 
	//	otherwise another thread has it.
	//
	BOOL		RemoveAndRelease( ) ;

} ;


#ifndef _NO_TEMPLATES_
//--------------------------------------------------
template<	class	Element	>
class	TLockQueueV1	{
//
//	This template is designed for use with Elements derived from CQElement.
//	This will use the CQueueLockV1 class above to implement a locking queue containing
//	elements of type 'Element'.
//
private : 
	CQueueLockV1		m_queue ;
public : 
	inline	TLockQueueV1() ;
	inline	~TLockQueueV1() ;

	//	Add an element to the Queue - if this returns TRUE we own the lock.
	inline	BOOL		Append( Element* p ) ;

	// remove an element from the Queue - lock ownership does not change.
	inline	void		Remove( ) ;
	inline	BOOL		GetHead( Element *&p ) ;
	inline	BOOL		RemoveAndRelease( ) ;
} ;
#endif

#define	DECLARE_LOCKQ( Type )	\
class	LockQ ## Type	{	\
private :	\
	CQueueLockV1		m_queue ;	\
public :	\
	LockQ ## Type ()	{}	\
	~LockQ ## Type ()	{}	\
	BOOL	Append(	Type *	p )	{	return	m_queue.Append( (CQElement*)p ) ;	}	\
	void	Remove( )	{	m_queue.Remove() ;	}	\
	BOOL	GetHead(	Type	*&p	)	{	\
CQElement*	pTemp = 0;	\
BOOL	fTemp = m_queue.GetHead( pTemp ) ;	\
p = (Type*)pTemp ;	\
return	fTemp ;	\
}	\
	BOOL	RemoveAndRelease( )	{	\
return	m_queue.RemoveAndRelease() ;	\
}	\
} ;

#define	INVOKE_LOCKQ( Type )	LockQ ## Type


class	CQueueLock	{
//
// This class implements a queue which is multi-threaded safe for append operations.
//	In addition, this queue will synchronize removal of elements amongst those 
//	threads which are appending to the queue.  Each thread that appends to the 
//	queue potentially becomes the owner of the removal lock of the queue. 
//  (If Append() returns TRUE the thread owns the removal lock of the queue.)
//	There is no way to relinquish the removal lock except to empty the queue.
//
//	Usage should be the following in each worker thread : 
//		CQueueLock	*pQueue ;
//
//		if( pQueue->Append( p ) ) {
//			CQueueElement *pWork ;
//
//			while( (pWork = pQueue->RemoveAndRelease( )) ) {
//				/* Do work on pWork It is safe to do further calls to pQueue->Append()
//					while doing whatever work.  That does not mean those Appended
//					elements will be processed on this thread. */
//			}
//		}
//
private : 

	//
	//	Class constants - LOCKVAL that special value marking the queue element
	//	which is ready to be grabbed !
	//
	enum	CONSTANTS	{
		LOCKVAL	= 0xFFFFFFFF, 
	} ;

	//
	//	Element which always remains in the list !
	//
	CQElement	m_special ;	

	//
	//	Head of the list
	//
	CQElement	*m_pHead ;

	//
	//	Tail of the list !
	//
	CQElement	*m_pTail ;

public : 
	//
	//	Initialize the queue to an empty state - 
	//	and also sets things up so that the first Append
	//	will own the lock !	
	//
	inline	CQueueLock( ) ;

	//
	//	Also initializes to an empty state, however
	//	allows caller to specify whether queue can be 
	//	grabbed on the first Append !
	//
	inline	CQueueLock(	BOOL	fSet ) ;

#ifdef	LOCKQ_DEBUG
	//
	//	Check that the queue is emptied when it is destroyed !
	//
	inline	~CQueueLock( ) ;
#endif

	//
	//	Set the lock to the lockable state where the next
	//	call to Append() will acquire the lock !
	//	This function is not thread safe and should only
	//	be called when we are sure there is only one thread
	//	using the object !
	//
	inline	void		Reset() ;

	//
	//	Append - returns TRUE if we have added the first element into the queue
	//	and we now own the lock.
	//
	inline	BOOL		Append( CQElement *p ) ;

	//
	//	return the head of the Queue - if we return NULL then some other thread
	//	may own the lcok the queue implicitly implies !
	//
	inline	CQElement*	RemoveAndRelease( ) ;

	//
	//	return the head of the Queue - but don't let any other threads
	//	grab the queue !
	//
	inline	CQElement*	Remove( ) ;

} ;


template<	class	Element	>
class	TLockQueue	{
//
//	This template is designed for use with Elements derived from CQElement.
//	This will use the CQueueLock class above to implement a locking queue containing
//	elements of type 'Element'.
//
private : 
	CQueueLock		m_queue ;

public : 
	//
	//	Create an empty queue
	//
	inline	TLockQueue() ;

	//
	//	Create empty queue and specify whether the
	//	lock is initially available 
	//
	inline	TLockQueue( BOOL	fSet ) ;

	//	
	//	Caller must already have lock and be only thread
	//	using object - make the lock available !
	//
	inline	void	Reset() ;
	
	//
	//	Add an element to the Queue - if this returns TRUE we own the lock.
	//
	inline	BOOL		Append( Element* p ) ;
	
	//
	// remove an element from the Queue - lock ownership does not change unless this
	//	returns NULL !
	//
	inline	Element*	RemoveAndRelease( ) ;

	//
	//	remove an element from the Queue - but don't relinquish lock !
	//
	inline	Element*	Remove() ;
} ;

#include	"lockq.inl"

#endif		// _LOCKQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\dbgtrace.h ===
/*----------------------------------------------------------------------
    dbgtrace.h
        Definitions for async tracing routines

    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        gordm          Gord Mangione

    History:
        01/30/95 gordm      Created.
----------------------------------------------------------------------*/

#if !defined(_DBGTRACE_H_)
#define _DBGTRACE_H_


#ifdef __cplusplus
extern "C" {
#endif


#ifndef THIS_FILE
#define THIS_FILE   __FILE__
#endif

#if defined( NOTRACE )

#define FLUSHASYNCTRACE                         // for _ASSERT below

#define FatalTrace  1 ? (void)0 : PreAsyncTrace
#define ErrorTrace  1 ? (void)0 : PreAsyncTrace
#define DebugTrace  1 ? (void)0 : PreAsyncTrace
#define StateTrace  1 ? (void)0 : PreAsyncTrace
#define FunctTrace  1 ? (void)0 : PreAsyncTrace
#define ErrorTraceX 1 ? (void)0 : PreAsyncTrace
#define DebugTraceX 1 ? (void)0 : PreAsyncTrace

#define MessageTrace( lParam, pbData, cbData )
#define BinaryTrace( lParam, pbData, cbData )
#define UserTrace( lParam, dwUserType, pbData, cbData )

#define TraceFunctEnter( sz )
#define TraceFunctEnterEx( lparam, sz )
#define TraceFunctLeave()

//
// import functions from DBGTRACE.DLL
//
#define	InitAsyncTrace()
#define	TermAsyncTrace()
#define	FlushAsyncTrace()

__inline int PreAsyncTrace( LPARAM lParam, LPCSTR szFormat, ... )
{
        return( 1);
}


#define MessageTrace( lParam, pbData, cbData )
#define BinaryTrace( lParam, pbData, cbData )
#define UserTrace( lParam, dwUserType, pbData, cbData )



#else // NOTRACE

#define FLUSHASYNCTRACE     FlushAsyncTrace(),  // for _ASSERT below

#define FatalTrace  !(__dwEnabledTraces & FATAL_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, FATAL_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define ErrorTrace  !(__dwEnabledTraces & ERROR_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, ERROR_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define DebugTrace  !(__dwEnabledTraces & DEBUG_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, DEBUG_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define StateTrace  !(__dwEnabledTraces & STATE_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, STATE_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define FunctTrace  !(__dwEnabledTraces & FUNCT_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, FUNCT_TRACE_MASK ) &&     \
                    PreAsyncTrace

//
// Support for unspecified function names
//

#define ErrorTraceX  !(__dwEnabledTraces & ERROR_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, "Fn", ERROR_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define DebugTraceX  !(__dwEnabledTraces & DEBUG_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, "Fn", DEBUG_TRACE_MASK ) &&     \
                    PreAsyncTrace


//
// use to explicitly remove function tracing even for debug builds
//
#define TraceQuietEnter( sz )                   \
        char    *___pszFunctionName = sz

//
// disable function tracing for retail builds
// reduces code size increase and only should
// only be used sparingly
//
#ifdef  DEBUG

#define TraceFunctEnter( sz )                   \
        TraceQuietEnter( sz );                  \
        FunctTrace( 0, "Entering %s", sz )

#define TraceFunctLeave()                       \
        FunctTrace( 0, "Leaving %s", ___pszFunctionName )

#define TraceFunctEnterEx( lParam, sz )         \
        TraceQuietEnter( sz );                  \
        FunctTrace( lParam, "Entering %s", sz )

#define TraceFunctLeaveEx( lParam )             \
        FunctTrace( lParam, "Leaving %s", ___pszFunctionName )

#else

#define TraceFunctEnter( sz )           TraceQuietEnter( sz )
#define TraceFunctEnterEx( lParam, sz ) TraceQuietEnter( sz )

#define TraceFunctLeave()
#define TraceFunctLeaveEx( lParam )

#endif

//
// fixed number of parameters for Binary trace macros
//
#define MessageTrace( lParam, pbData, cbData )                  \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, TRACE_MESSAGE, pbData, cbData )

#define BinaryTrace( lParam, pbData, cbData )                   \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, TRACE_BINARY, pbData, cbData )

#define UserTrace( lParam, dwUserType, pbData, cbData )         \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, dwUserType, pbData, cbData )

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// imported trace flag used by trace macros to determine if the trace
// statement should be executed
//
extern DWORD __dwEnabledTraces;

//
// import functions from ATRACE.LIB
//
BOOL InitAsyncTrace ( void );
BOOL TermAsyncTrace ( void );
BOOL FlushAsyncTrace( void );

void DebugAssert( DWORD dwLine, LPCSTR lpszFunction, LPCSTR lpszExpression );

int SetAsyncTraceParams( LPCSTR pszFile, int iLine, LPCSTR szFunction, DWORD dwTraceMask );

int AsyncStringTrace( LPARAM lParam, LPCSTR szFormat    , va_list marker               );
int AsyncBinaryTrace( LPARAM lParam, DWORD  dwBinaryType, LPBYTE  pbData, DWORD cbData );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// Trace flag constants
//
#define FATAL_TRACE_MASK    0x00000001
#define ERROR_TRACE_MASK    0x00000002
#define DEBUG_TRACE_MASK    0x00000004
#define STATE_TRACE_MASK    0x00000008
#define FUNCT_TRACE_MASK    0x00000010
#define MESSAGE_TRACE_MASK  0x00000020
#define ALL_TRACE_MASK      0xFFFFFFFF

#define NUM_TRACE_TYPES     6

//
// Output trace types. used by tools to modify the
// registry to change the output target
//
enum tagTraceOutputTypes {
    TRACE_OUTPUT_DISABLED = 0,
    TRACE_OUTPUT_FILE = 1,
    TRACE_OUTPUT_DEBUG = 2,
    TRACE_OUTPUT_DISCARD = 4        // used to find race windows
};

#define TRACE_OUTPUT_INVALID    \
        ~(TRACE_OUTPUT_FILE|TRACE_OUTPUT_DEBUG|TRACE_OUTPUT_DISCARD)


#define IsTraceFile(x)      ((x) & TRACE_OUTPUT_FILE)
#define IsTraceDebug(x)     ((x) & TRACE_OUTPUT_DEBUG)
#define IsTraceDiscard(x)   ((x) & TRACE_OUTPUT_DISCARD)


//
// predefined types of binary trace types.  User defined
// types must be greater than 0x8000
//
enum tagBinaryTypes {
    TRACE_STRING = 0,
    TRACE_BINARY,
    TRACE_MESSAGE,
    TRACE_USER = 0x8000
};

#include <stdarg.h>

//
// use __inline to ensure grab __LINE__ and __FILE__
//
__inline int WINAPIV PreAsyncTrace( LPARAM lParam, LPCSTR szFormat, ... )
{
    va_list marker;
    int     iLength;

    va_start( marker, szFormat );
    iLength = AsyncStringTrace( lParam, szFormat, marker );
    va_end( marker );

    return  iLength;
}

// !defined(NOTRACE) from way at the top of this include file
#endif // !defined(NOTRACE)

// Asserts are independent of tracing
// (with the exception of flushing the trace buffer).

//
// For now enable ASSERT defines only if debugging is enabled
//
#ifdef  DEBUG
#define _ENABLE_ASSERTS

#ifndef NOTRACE
#define _ENABLE_VERBOSE_ASSERTS
#endif	// NO_TRACE

#endif	// DEBUG

//
// Macros added for doing asserts and verifies.  basic clones
// of the MFC macros with a prepended _ symbol
//
#ifdef  _ENABLE_ASSERTS

#ifndef _ASSERT
#ifdef  _ENABLE_VERBOSE_ASSERTS
#define _ASSERT(f)	!(f) ? DebugAssert( __LINE__,  THIS_FILE, #f ) : ((void)0)
#else
#define _ASSERT(f)	!(f) ? DebugBreak() : ((void)0)
#endif	//_ENABLE_VERBOSE_ASSERTS
#endif

#define _VERIFY(f)	_ASSERT(f)

#else

#define _ASSERT(f)	((void)0)
#define _VERIFY(f)	((void)(f))

#endif	// _ENABLE_ASSERTS

#ifdef __cplusplus
} // extern "C"

////////////////////////////////////////////////////////////////////////////////

#ifdef NOTRACE

#define TraceFunctEntry(sz)

#else

class CTraceEntry
{
public:
    CTraceEntry(char * psz)
    {
        this->___pszFunctionName = psz;
        FunctTrace( 0, "Entering %s", psz);
    }
    ~CTraceEntry()
    {
        FunctTrace( 0, "Leaving %s", this->___pszFunctionName);
    }
    char * ___pszFunctionName;
};

#define TraceFunctEntry(sz) CTraceEntry __cte(sz)

#endif // NOTRACE

////////////////////////////////////////////////////////////////////////////////

#endif

#endif // !defined(_DBGTRACE_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\mostpc.h ===
/*----------------------------------------------------------------------------
    mostpc.h
        
        Header for MOS transport common constants for client & server

    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        Phillich    Philippe Choquier

    History:
        02/24/94    Phillich    Created.
  --------------------------------------------------------------------------*/

#if !defined( _MOSTPC_DEFINED )

#define MSI_LEVEL2TIMEOUT   	6000
#define SESSION_GROUP_SEPARATOR	"\\"

#define _MOSTPC_DEFINED

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\moscl.h ===
/*----------------------------------------------------------------------------
    moscl.h
        
        Header for MOS client side API

    Copyright (C) 1993 Microsoft Corporation
    All rights reserved.

    Authors:
        Phillich    Philippe Choquier

    History:
        08/12/93    Phillich    Created.
  --------------------------------------------------------------------------*/

#if !defined(_MOSCL_DEFINED)

#include <servdefs.h>
#include <mostpc.h>

#if defined(__cplusplus)
extern "C" {
#endif

#if !defined(MOSDllImport)
#if defined(WIN32)
#define MOSDllImport(a) __declspec( dllimport ) a
#define MOSDllExport(a) __declspec( dllexport ) a
#else 
#define MOSDllExport(a) a __export
#define MOSDllImport(a) a __import
#endif
#endif

#if !defined(_MHANDLE_DEFINED)
typedef WORD MHANDLE;
typedef WORD HMCONNECT;
typedef HMCONNECT *PHMCONNECT;
typedef WORD HMSESSION;
typedef HMSESSION *PHMSESSION;
typedef WORD HMPIPE;
typedef HMPIPE *PHMPIPE;
#define _MHANDLE_DEFINED
#endif

#define INVALID_MOS_HANDLE_VALUE        ((MHANDLE)0xffff)
#define MOS_IO_ERROR                    0xffff

#define MOS_WRITE_PENDING                    0xfffffffe

typedef struct _MC_CONNECT_CB {
    WORD cSizeStructure;
    WORD Type;
    DWORD ComPort;
    DWORD BaudRate;
    DWORD dwOptions;
	WORD SpeakerMode;
	WORD wReserved;
    } MC_CONNECT_CB;

// for dwOptions

#define MOS_CONNECT_DISABLE_DATA_COMPRESSION	1
#define MOS_CONNECT_DISABLE_ERROR_CORRECTION	2
#define MOS_CONNECT_LAUNCH_LIGHTS				4
#define MOS_DONT_SET_DCEDTE_SPEED				8

enum MOS_SPEAKERMODE { MOS_SPEAKERALWAYSOFF, MOS_SPEAKERONUNTILCONNECT, MOS_SPEAKERALWAYSON, MOS_SPEAKEROFFWHILEDIALING }; 

enum MOS_CONNECT_TYPE {
    MOS_CONNECT_MODEM,
    MOS_CONNECT_ISDN,
    MOS_CONNECT_PIPE,
    MOS_CONNECT_EICON,
    MOS_CONNECT_EXISTING,
    MOS_CONNECT_INVALID,
    MOS_CONNECT_UDP,
    MOS_CONNECT_TAPI,
    MOS_CONNECT_TCP
    } ;

enum MOS_EVENT {
    EVENT_BUSY,
    EVENT_NOCARRIER,
    EVENT_CONNECTED,
    EVENT_NODIALTONE,
    EVENT_USER_CLOSED,
    EVENT_START_RECEIVE_DATA,
    EVENT_END_RECEIVE_DATA,
    EVENT_START_XMIT_DATA,
    EVENT_END_XMIT_DATA,
    EVENT_CRC_ERROR,
    EVENT_CONNECTION_DROPPED,
    EVENT_WRITE_ERROR,
    EVENT_NO_EVENT,
    EVENT_DATALINK,
    EVENT_SPEED_1200,
    EVENT_SPEED_2400,
    EVENT_SPEED_4800,
    EVENT_SPEED_9600,
    EVENT_SPEED_12000,
    EVENT_SPEED_14400,
    EVENT_SPEED_16800,
    EVENT_SPEED_19200,
    EVENT_SPEED_21600,
    EVENT_SPEED_24400,
    EVENT_SPEED_26400,
    EVENT_SPEED_28800,
    EVENT_SPEED_57600,
    EVENT_OPEN_ERROR,       // can't open communication device
	EVENT_SPEED,
	EVENT_UNREACHABLE_NETWORK_ADDRESS,
	EVENT_ACTIVE,
	EVENT_CAUSE_TOO_MANY_RCV_ERROR,
	EVENT_CAUSE_TOO_MANY_XM_ERROR,
	EVENT_PAD_DISCONNECT,
	EVENT_CAUSE_UNAVAIL,
	EVENT_SVCCONNECT_DONE,
	EVENT_RAS_AUTH_START,
	EVENT_RAS_AUTH_FAILED,
	EVENT_RAS_ERROR,
	EVENT_RAS_DIALSTART_PRIMARY,
	EVENT_RAS_DIALSTART_BACKUP,
	EVENT_TCPINSTALL_ERROR,
	EVENT_TCPCONNECT_START,
	EVENT_TCPCONNECT_RETRY,
	EVENT_TCPCONNECT_FAILED,
	EVENT_DNSLOOKUP,
	EVENT_DNSLOOKUP_FAILED,
	EVENT_LOCKEDACCOUNT,
	EVENT_INVALIDPASSWORD,
	EVENT_PPPRANDOMFAILURE,
	EVENT_RAS_REMOTE_DISCONNECTION,
	EVENT_RAS_NOCARRIER,
	EVENT_RAS_BADTCPCONFIG,
	EVENT_PROXYCONNECT_START,
	EVENT_PROXYCONNECT_FAILED,
	EVENT_PROXYAUTH_START,
	EVENT_PROXYAUTH_FAILED,
	EVENT_PROXY_DISCOVERY_START,
	EVENT_PROXY_DISCOVERY_FAILED,
	EVENT_PROXY_ALTCONNECT_START,
	EVENT_PROXY_RESOURCE_FAILURE,
	EVENT_PROXY_GENERIC_FAILURE,
	EVENT_PROXY_PROTOCOL_MISMATCH,
	EVENT_PROXY_BAD_SETTINGS,
	EVENT_PROXY_BAD_VERSION,
	EVENT_PPP_TIMEOUT,
    } ;

#define SERVER_NAME_MAX_LEN (30)
#define SERVICE_NAME_MAX_LEN (256)
#define IPADDRESS_MAX_LEN (30)
#define MOSCL_ATTACH_TIMEOUT	(15 * 1000)

#define MOSADDR_CANONIC		1
#define MOSADDR_DIALABLE	2
#define MOSADDR_WANADDR		3
#define MOSADDR_CARRIERID	4
#define MOSADDR_COUNTRYCODE	5
#define MOSADDR_AREACODE	6
#define MOSADDR_MODEMNAME	7
#define MOSADDR_CONNECTMODE	8

// Maximum Message Size
#define MSI_MAXMSGSIZE      (12*1024)

#define GMS_MAXMSGSIZE      1
#define GMS_LEVEL2TIMEOUT   2

typedef void (CALLBACK *MC_CONNECT_NOTIFY)(LPVOID, HMCONNECT, WORD, DWORD);
typedef void (CALLBACK *MP_READ_NOTIFY)(LPVOID, HMPIPE, DWORD);
typedef void (CALLBACK *MP_WRITE_NOTIFY)(LPVOID, HMPIPE, LPVOID, DWORD);
typedef void (CALLBACK *MP_OPEN_NOTIFY)(LPVOID, HMPIPE, WORD );

#if defined(WIN32)
MOSDllExport(BOOL WINAPI)               InitMOS( HINSTANCE, WORD );
#else
MOSDllExport(BOOL WINAPI)               InitMOS( HINSTANCE );
#endif
MOSDllExport(BOOL WINAPI)               TerminateMOS();
MOSDllExport(WORD WINAPI)               GetMOSConnectionStatus(HMCONNECT);
MOSDllExport(HMCONNECT WINAPI)          OpenMOSConnection(LPSTR,MC_CONNECT_NOTIFY,LPVOID,MC_CONNECT_CB FAR*);
MOSDllExport(BOOL WINAPI)               CloseMOSConnection(HMCONNECT);
MOSDllExport(HMSESSION WINAPI)          OpenMOSSession(HMCONNECT, LPSTR);
MOSDllExport(HMSESSION WINAPI)          OpenMOSSessionEx(HMCONNECT, LPSTR, SERVICE_VERSION );
MOSDllExport(BOOL WINAPI)               CloseMOSSession(HMSESSION);
MOSDllExport(HMPIPE WINAPI)             OpenMOSPipe(HMSESSION, LPSTR);
MOSDllExport(HMPIPE WINAPI)             OpenMOSPipeEx(HMSESSION, LPSTR, LPSTR);
MOSDllExport(BOOL WINAPI)               CloseMOSPipe(HMPIPE);
MOSDllExport(DWORD WINAPI)              ReadMOSPipe(HMPIPE, LPVOID, DWORD, WORD);
MOSDllExport(DWORD WINAPI)              WriteMOSPipe(HMPIPE, LPVOID, LPVOID, DWORD, BOOL);
MOSDllExport(MP_READ_NOTIFY WINAPI)     SetMOSPipeReadNotify(HMPIPE, MP_READ_NOTIFY, LPVOID);
MOSDllExport(MP_WRITE_NOTIFY WINAPI)    SetMOSPipeWriteNotify(HMPIPE, MP_WRITE_NOTIFY);
MOSDllExport(WORD WINAPI)               GetMOSLastError(HMCONNECT);
MOSDllExport(DWORD WINAPI)              GetMOSPipeReadSize(HMPIPE hmp, WORD );
MOSDllExport(DWORD WINAPI)              GetMOSSysInfo( HMCONNECT hmC, WORD wType );
MOSDllExport(HMPIPE WINAPI) 			OpenMOSPipeWithNotify(HMSESSION hms, LPSTR Name,
												LPSTR Param, MP_READ_NOTIFY r, LPVOID u, 
												MP_WRITE_NOTIFY );
MOSDllExport(HMPIPE WINAPI) 			OpenMOSPipeWithNotifyEx(HMSESSION hms, LPSTR Name,
												LPSTR Param, MP_READ_NOTIFY r, LPVOID u, 
												MP_WRITE_NOTIFY, SERVICE_VERSION sv );
MOSDllExport(HMPIPE WINAPI) 			OpenMOSPipeWithNotifyAndTimeoutEx(HMSESSION hms, LPSTR Name,
												LPSTR Param, MP_READ_NOTIFY r, LPVOID u, 
												MP_WRITE_NOTIFY, SERVICE_VERSION sv, DWORD dwT, MP_OPEN_NOTIFY pON );

#define OpenMOSPipeWithReadNotify(a,b,c,d,e) OpenMOSPipeWithNotify(a,b,c,d,e,NULL)
#if defined(__cplusplus)
}
#endif

// MOS error values
#define MOSERROR_FAILED			(-1)	  		// operation failed (reason unknown).
#define MOSERROR_SUCCESS		(0)				// operation successful.

#define MOSERROR_TIMEOUT        (1)
#define MOSERROR_IO_PENDING     (2)             // Overlapped IO operation in progress.
#define MOSERROR_IO_BUSY        (3)             // Synchronous operation in progress.
#define MOSERROR_INVALID_CONNECTION_HANDLE      (4)
#define MOSERROR_INVALID_SESSION_HANDLE (5)
#define MOSERROR_INVALID_PIPE_HANDLE    (6)
#define MOSERROR_PIPE_IS_CLOSING        (7)

#define MOSERROR_OPENING_ARENA (8)              // An error occured while trying to OpenSharedArena().
#define MOSERROR_ASYNC_WRITE_NO_CALLBACK (9)    // Cannot perform async write without first defining a callback function.
#define MOSERROR_ARENA_NOTHING_DURING_READ (10) // A call to GetFirstFromList() returned ARENA_NOTHING.
#define MOSERROR_ADDTOLIST_RET_FALSE (11)       // A call to AddToList() returned FALSE for some reason.
#define MOSERROR_PIPE_NOT_FOUND (12)

//#define MOSERROR_BUFFER_TOO_SMALL (13)      // The specified buffer was too small for the data to be returned in.
//#define MOSERROR_SERVICE_NOT_FOUND (14)     // The specified Service could not be found.
//#define MOSERROR_OVERLAPPED_BUFFERS (15)        // One or more of the specified buffers are overlapped.
//#define MOSERROR_RPC_FAILED (16)                        // An RPC call failed.

//#define MOSERROR_BILLING_DOWNLOAD_ALREADY_ACTIVE (17)   // Can't start download session event when existing session in progress.
//#define MOSERROR_BILLING_DOWNLOAD_NOT_ACTIVE (18)       // Can't ask for next or prev event when no download in progress.
//#define MOSERROR_BILLING_DOWNLOAD_INVALID_HANDLE (19)	// An invalid download session handle was specified.
//#define MOSERROR_BILLING_DOWNLOAD_INVALID_COMMAND (20)	// An invalid download command was specified.
//#define MOSERROR_ERROR_ACCESSING_LOGFILE (21)           // There was an error accessing the billing logfile.
#define MOSERROR_MSGSIZETOOBIG (22)                 // Message Size Too Big for WriteMOSPipe.

//#define MOSERROR_ERROR_SERIALIZING (23)		// An error occurred while a C++ object attempted to serialize itself.
//#define MOSERROR_ERROR_DESERIALIZING (24)	// An error occurred while a C++ object attempted to deserialize itself.
#define MOSERROR_INVALID_CONNECTION_TYPE    (25)    // InitMOS() & OpenMOSConnection mismatch

#define MOSERROR_MORE_DATA (26)	// Fitting # of logs are returned in the buffer, but more data is available still.
#define MOSERROR_INVALID_PARAMETER    (27)
#define MOSERROR_OUT_OF_RESOURCE	(28)
#define MOSERROR_ATTACH_REJECT		(29)
#define MOSERROR_NO_ACCESS			(30)
#define MOSERROR_LOCATE_REJECT		(31)
#define MOSERROR_SERVER_REJECT		(32)
#define MOSERROR_SERVICE_VERSION_MISMATCH	(33)
#define MOSERROR_TOO_MANY_PIPES		(34)
#define MOSERROR_PIPE_IS_NOTOPENED	(35)
#define MOSERROR_NO_ACCESS_ON_TOLL_FREE		(36)
#define MOSERROR_GET_RIGHTS_TIMEOUT		(37)

#define _MOSCL_DEFINED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\lockq.inl ===
inline
CQueueLock::CQueueLock( ) : m_pHead( &m_special ), m_pTail( &m_special ) {

	//
	// This function initializes the queue to an empty state.
	// In the empty state the queue contains one element which 
	// has a Next pointer of 'LOCKVAL'.
	// The next pointer is initialized to LOCKVAL so that the first
	// append to the Queue owns the removal lock.
	//
 	m_special.m_pNext = (CQElement*)((DWORD)LOCKVAL) ;
} 

inline
CQueueLock::CQueueLock(	BOOL	fSet ) : 
	m_pHead( &m_special ),
	m_pTail( &m_special )	{

	if( fSet ) {
		m_special.m_pNext = (CQElement*)((DWORD)LOCKVAL) ;
	}	else	{
		m_special.m_pNext = 0 ;
	}
}

#ifdef	LOCKQ_DEBUG

CQueueLock::~CQueueLock( ) {
//	_ASSERT( m_pHead == m_pTail ) ;
//	_ASSERT( m_pHead == &m_special ) ;
//	_ASSERT( m_dwOwningThread == 0 || m_dwOwningThread == GetCurrentThreadId() ) ;

}
#endif

inline void
CQueueLock::Reset(	)	{

	m_pTail->m_pNext = (CQElement*)((DWORD)LOCKVAL) ;

}



inline BOOL 
CQueueLock::Append( CQElement*	pAppend ) {
	//
	// We must set the Next pointer to NULL so that the next
	//	we come to append the tail pointer is properly set up.
	//
//	_ASSERT( pAppend->m_pNext == 0 ) ;
	pAppend->m_pNext = 0 ;

	// Get the old tail pointer.  This guy won't be touched by the 
	// remove thread if his next pointer is still NULL.
	CQElement*	pTemp = (CQElement*)InterlockedExchangePointer( (LPLONG)&m_pTail, (LONG)pAppend ) ;

	// After we set the old tail pointer's next pointer to NON NULL 
	// he becomes fair game for whoever is removing from the queue.
	// We may become the thread removing from the queue if whoever was
	// previously removing got to the last element and changed its next pointer 
	// to LOCKVAL.
	//
	// NOTE : This thread and any thread doing removals should be the only
	//	threads touching the pNext field of the pTemp element.
	//
	LONG	l = InterlockedExchange( (LPLONG)&(pTemp->m_pNext), (LONG)pAppend ) ;

	return	l == LOCKVAL ;
}

inline CQElement*	
CQueueLock::RemoveAndRelease( void )	{


	CQElement*	p = (CQElement*)InterlockedCompareExchangePointer( (LPVOID*)&m_pHead->m_pNext, 
												(LPVOID)LOCKVAL,
												0 ) ;

	_ASSERT( (DWORD)p != 0xFFFFFFFF ) ;

	if( p != 0 ) {

		//
		//	There is an element following the head element - 
		//	so we can safely examine the head element has nobody
		//	will touch its next pointer but us !
		//

		CQElement*	pReturn = m_pHead ;
		m_pHead = p ;
		pReturn->m_pNext = 0 ;

		if( pReturn == &m_special ) {

			//
			//	We can ignore the return value of Append - 
			//	it must always succeed as we are the only thread
			//	that is allowed to relinquish the lock, and we ain't going to 
			//	do so !
			//
			Append( pReturn ) ;

			//
			//	Now, we must offer ownership again !
			//

			p = (CQElement*)InterlockedCompareExchangePointer( (LPVOID*)&m_pHead->m_pNext, 
														(LPVOID)LOCKVAL,
														0 ) ;

			_ASSERT( (DWORD)p != 0xFFFFFFFF ) ;

			if( p != 0 ) {

				//
				//	The head element must not be the special element - 
				//	we took pains already to see that that didn't happen - 
				//	so we can safely remove the element from the head of the queue.
				//

				pReturn = m_pHead ;
				m_pHead = p ;
				pReturn->m_pNext = 0 ;
		
				return	pReturn ;
			}

		}	else	{

			return	pReturn ;

		}
	
	}

	//
	//	_ASSERT( p==0 ) ;
	//

	return	p ;
}

inline CQElement*
CQueueLock::Remove( void )	{


	CQElement*	p = m_pHead->m_pNext ;
	if( p != 0 ) {

		//
		//	There is an element following the head element - 
		//	so we can safely examine the head element has nobody
		//	will touch its next pointer but us !
		//

		if( p == &m_special ) {

			//
			//	The head element is the special element, so we want
			//	to send it to the back and try examining the front again !
			//

			m_pHead = p->m_pNext ;
			p->m_pNext = 0 ;

			//
			//	We can ignore the return value of Append - 
			//	it must always succeed as we are the only thread
			//	that is allowed to relinquish the lock, and we ain't going to 
			//	do so !
			//
			Append( p ) ;

			//
			//	Ok, lets see if we can remove the head element now !
			//

			p = m_pHead->m_pNext ;
		}
	
		//
		//	If this ain't 0, then the next pointer is set 
		//	and no other threads will be touching the next pointer, 
		//	so we can safely advance the head pointer and return
		//	the first element.
		//
		if( p != 0 ) {

			//
			//	The head element must not be the special element - 
			//	we took pains already to see that that didn't happen - 
			//	so we can safely remove the element from the head of the queue.
			//
			m_pHead = p->m_pNext ;
			p->m_pNext = 0 ;
	
			return	p ;
		}
	}

	return	0 ;
}


template< class Element > 
inline	TLockQueue< Element >::TLockQueue( ) { }

template< class	Element > 
inline	TLockQueue< Element >::TLockQueue( BOOL fSet ) : 
	m_queue( fSet ) { }

template< class Element > 
inline	void	TLockQueue< Element >::Reset()	{
	m_queue.Reset() ;
}

template< class Element > 
inline	BOOL	TLockQueue< Element >::Append( Element *p ) {
	return	m_queue.Append( (CQElement*)p ) ;
}

template< class Element > 
inline	Element*	TLockQueue< Element >::Remove( ) {
	return	(Element*) m_queue.Remove( ) ;
}

template< class Element > 
inline	Element*	TLockQueue< Element >::RemoveAndRelease( ) {
	return	(Element*) m_queue.RemoveAndRelease( ) ;
}



#ifndef _NO_TEMPLATES_

template< class Element > 
inline	TLockQueueV1< Element >::TLockQueueV1( ) { }

template< class Element > 
inline	TLockQueueV1< Element >::~TLockQueueV1( ) { } 

template< class Element > 
inline	BOOL	TLockQueueV1< Element >::Append( Element *p ) {
	return	m_queue.Append( (CQElement*)p ) ;
}

template< class Element > 
inline	void	TLockQueueV1< Element >::Remove( ) {
	m_queue.Remove( ) ;
}

template< class Element > 
inline	BOOL	TLockQueueV1< Element >::GetHead( Element* &p ) {
	CQElement	*pTemp = 0 ;
	BOOL	fTemp = m_queue.GetHead( pTemp ) ;
	p = (Element*)pTemp ;
	return	fTemp ;
}

template< class Element > 
inline	BOOL	TLockQueueV1< Element >::RemoveAndRelease( ) {
	return	m_queue.RemoveAndRelease( ) ;
} 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\mpc_config.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MCP_config.h

Abstract:
    This file contains the declaration of the ....

Revision History:
    Davide Massarenti   (Dmassare)  01/09/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___MPC___CONFIG_H___)
#define __INCLUDED___MPC___CONFIG_H___

#include <MPC_main.h>
#include <MPC_trace.h>
#include <MPC_com.h>
#include <MPC_utils.h>
#include <MPC_xml.h>

/////////////////////////////////////////////////////////////////////////

#define DECLARE_CONFIG_MAP(x) \
    typedef x _ConfigMapClass; \
    static const MPC::Config::DefinitionOfTag       _cfg_tag;\
    static const MPC::Config::DefinitionOfTag*      _cfg_table_tags[];\
    static const MPC::Config::DefinitionOfAttribute _cfg_table_attributes[];

#define DEFINE_CONFIG_DEFAULTTAG() static const MPC::Config::DefinitionOfTag* GetDefTag() { return &_cfg_tag; }

#define DECLARE_CONFIG_METHODS() \
    LPCWSTR GetTag() const;\
    void*   GetOffset( size_t offset ) const;\
    HRESULT CreateInstance( const MPC::Config::DefinitionOfTag* tag, MPC::Config::TypeConstructor*& defSubType );\
    HRESULT LoadNode( IXMLDOMNode* xdn );\
    HRESULT SaveNode( IXMLDOMNode* xdn ) const;

////////////////////

#define CFG_OFFSET(x) offsetof(_ConfigMapClass, x)

#define CFG_BEGIN_FIELDS_MAP(x) const MPC::Config::DefinitionOfAttribute x::_cfg_table_attributes[] = {

#define CFG_VALUE(type,y)                    	  { MPC::Config::XT_value    , NULL, MPC::Config::MT_##type	 , CFG_OFFSET(y), false, 0               , NULL   }
#define CFG_ATTRIBUTE(name,type,y)           	  { MPC::Config::XT_attribute, name, MPC::Config::MT_##type	 , CFG_OFFSET(y), false, 0               , NULL   }
#define CFG_ELEMENT(name,type,y)             	  { MPC::Config::XT_element  , name, MPC::Config::MT_##type	 , CFG_OFFSET(y), false, 0               , NULL   }
	   
#define CFG_VALUE__TRISTATE(type,y,flag)     	  { MPC::Config::XT_value    , NULL, MPC::Config::MT_##type	 , CFG_OFFSET(y), true , CFG_OFFSET(flag), NULL   }
#define CFG_ATTRIBUTE__TRISTATE(name,type,y,flag) { MPC::Config::XT_attribute, name, MPC::Config::MT_##type	 , CFG_OFFSET(y), true , CFG_OFFSET(flag), NULL   }
#define CFG_ELEMENT__TRISTATE(name,type,y,flag)   { MPC::Config::XT_element  , name, MPC::Config::MT_##type	 , CFG_OFFSET(y), true , CFG_OFFSET(flag), NULL   }

#define CFG_VALUE__BITFIELD(y,lookup)     	   	  { MPC::Config::XT_value    , NULL, MPC::Config::MT_bitfield, CFG_OFFSET(y), false, 0               , lookup }
#define CFG_ATTRIBUTE__BITFIELD(name,y,lookup) 	  { MPC::Config::XT_attribute, name, MPC::Config::MT_bitfield, CFG_OFFSET(y), false, 0               , lookup }
#define CFG_ELEMENT__BITFIELD(name,y,lookup)   	  { MPC::Config::XT_element  , name, MPC::Config::MT_bitfield, CFG_OFFSET(y), false, 0               , lookup }

#define CFG_END_FIELDS_MAP() { MPC::Config::XT_invalid } };

////////////////////

#define CFG_BEGIN_CHILD_MAP(x) const MPC::Config::DefinitionOfTag* x::_cfg_table_tags[] = {

#define CFG_CHILD(y) y::GetDefTag(),

#define CFG_END_CHILD_MAP() NULL };

////////////////////

#define DEFINE_CFG_OBJECT(x,tag) const MPC::Config::DefinitionOfTag x::_cfg_tag = { tag, _cfg_table_tags, _cfg_table_attributes };

////////////////////////////////////////////////////////////////////////////////

#define DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(x,tag,defSubType)                                           \
                                                                                                                 \
LPCWSTR x::GetTag() const { return _cfg_tag.m_szTag; }                                                           \
                                                                                                                 \
void* x::GetOffset( size_t offset ) const { return (void*)((BYTE*)this + offset); }                              \
                                                                                                                 \
HRESULT x::CreateInstance( const MPC::Config::DefinitionOfTag* tag, MPC::Config::TypeConstructor*& defSubType )  \
{                                                                                                                \
    HRESULT hr;


#define DEFINE_CONFIG_METHODS_SAVENODE_SECTION(x, xdn)                                                           \
                                                                                                                 \
    return E_FAIL;                                                                                               \
}                                                                                                                \
                                                                                                                 \
HRESULT x::LoadNode( IXMLDOMNode* xdn )                                                                          \
{                                                                                                                \
    return MPC::Config::LoadNode( this, &_cfg_tag, xdn );                                                        \
}                                                                                                                \
                                                                                                                 \
HRESULT x::SaveNode( IXMLDOMNode* xdn ) const                                                                    \
{                                                                                                                \
    HRESULT hr;                                                                                                  \
                                                                                                                 \
    if(SUCCEEDED(hr = MPC::Config::SaveNode( this, &_cfg_tag, xdn )))                                            \
    {

#define DEFINE_CONFIG_METHODS_END(x)                                                                             \
    }                                                                                                            \
                                                                                                                 \
    return hr;                                                                                                   \
}

////////////////////////////////////////////////////////////////////////////////

#define DEFINE_CONFIG_METHODS__NOCHILD(x)                                                                        \
                                                                                                                 \
DEFINE_CONFIG_METHODS_CREATEINSTANCE_SECTION(x,tag,defSubType)                                                   \
DEFINE_CONFIG_METHODS_SAVENODE_SECTION(x,xdn)                                                                    \
DEFINE_CONFIG_METHODS_END(x)

////////////////////////////////////////////////////////////////////////////////

namespace MPC
{
    namespace Config
    {
        typedef enum
        {
            XT_invalid  ,
            XT_attribute, // Means attribute of the current element.
            XT_value    , // Means value of the current element
            XT_element  , // Means sub-element.
        } XMLTypes;

        typedef enum
        {
            MT_bool        ,
            MT_BOOL        ,
            MT_VARIANT_BOOL,
            MT_int         ,
            MT_long        ,
            MT_DWORD       ,
            MT_float       ,
            MT_double      ,
            MT_DATE        ,
            MT_DATE_US     ,
            MT_DATE_CIM    ,
            MT_CHAR        ,
            MT_WCHAR       ,
            MT_BSTR        ,
            MT_string      ,
            MT_wstring     ,
            MT_bitfield
        } MemberTypes;

        ////////////////////////////////////////

        struct TypeConstructor;       // The class you have to inherit from in order to load/save your state.
        struct DefinitionOfTag;       // Definition of objects.
        struct DefinitionOfAttribute; // Definition of member variables.

        ////////////////////////////////////////

        struct TypeConstructor
        {
            virtual LPCWSTR GetTag() const = 0;

            virtual void* GetOffset( size_t offset ) const = 0;

            virtual HRESULT CreateInstance( const DefinitionOfTag* tag, TypeConstructor*& defSubType )       = 0;
            virtual HRESULT LoadNode      ( IXMLDOMNode* xdn                                         )       = 0;
            virtual HRESULT SaveNode      ( IXMLDOMNode* xdn                                         ) const = 0;
        };

        struct DefinitionOfAttribute
        {
            XMLTypes    			m_xt;
            LPCWSTR     			m_szName;
			
            MemberTypes 			m_mtType;
            size_t      			m_offset;
			
            bool        			m_fPresenceFlag;
            size_t      			m_offsetPresence;

			const StringToBitField* m_Lookup;
        };

        struct DefinitionOfTag
        {
            LPCWSTR                      m_szTag;
            const DefinitionOfTag**      m_tblSubTags;
            const DefinitionOfAttribute* m_tblAttributes;

            const DefinitionOfTag*       FindSubTag   (                       /*[in]*/ LPCWSTR szTag  ) const;
            const DefinitionOfAttribute* FindAttribute( /*[in]*/ XMLTypes xt, /*[in]*/ LPCWSTR szName ) const;
        };

        ////////////////////////////////////////


        void    ClearValue( /*[in]*/       TypeConstructor* defType, /*[in]*/ const DefinitionOfAttribute* defField                                                          );
        HRESULT LoadValue ( /*[in]*/       TypeConstructor* defType, /*[in]*/ const DefinitionOfAttribute* defField, /*[in/out]*/ CComVariant& value, /*[in] */ bool  fFound );
        HRESULT SaveValue ( /*[in]*/ const TypeConstructor* defType, /*[in]*/ const DefinitionOfAttribute* defField, /*[out   ]*/ CComVariant& value, /*[out]*/ bool& fFound );

        HRESULT LoadNode   ( /*[in]*/       TypeConstructor* defType, /*[in]*/ const DefinitionOfTag* defTag, /*[in]*/ IXMLDOMNode* xdn );
        HRESULT SaveNode   ( /*[in]*/ const TypeConstructor* defType, /*[in]*/ const DefinitionOfTag* defTag, /*[in]*/ IXMLDOMNode* xdn );
        HRESULT SaveSubNode( /*[in]*/ const TypeConstructor* defType,                                         /*[in]*/ IXMLDOMNode* xdn );

        HRESULT LoadXmlUtil( /*[in]*/       TypeConstructor* defType, /*[in ]*/ MPC::XmlUtil& xml );
        HRESULT SaveXmlUtil( /*[in]*/ const TypeConstructor* defType, /*[out]*/ MPC::XmlUtil& xml );

        HRESULT LoadStream( /*[in]*/       TypeConstructor* defType, /*[in ]*/ IStream*   pStream );
        HRESULT SaveStream( /*[in]*/ const TypeConstructor* defType, /*[out]*/ IStream* *ppStream );

        HRESULT LoadFile( /*[in]*/       TypeConstructor* defType, /*[in]*/ LPCWSTR szFile );
        HRESULT SaveFile( /*[in]*/ const TypeConstructor* defType, /*[in]*/ LPCWSTR szFile );

        ////////////////////////////////////////

        template <class Container> HRESULT SaveList( /*[in]*/ Container& cnt, /*[in]*/ IXMLDOMNode* xdn )
        {
            HRESULT hr = S_OK;

            for(Container::const_iterator it=cnt.begin(); it != cnt.end(); it++)
            {
                if(FAILED(hr = MPC::Config::SaveSubNode( &(*it), xdn ))) break;
            }

            return hr;
        }

    }; // namespace Config

}; // namespace MPC

/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___MPC___CONFIG_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\mpc_html.h ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    MPC_html.h

Abstract:
    This file contains the declaration of various functions and classes
    designed to help the handling of HTML elements.

Revision History:
    Davide Massarenti   (Dmassare)  07/11/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___MPC___HTML_H___)
#define __INCLUDED___MPC___HTML_H___

#include <MPC_main.h>

#include <exdisp.h>
#include <exdispid.h>

#include <shobjidl.h>
#include <mshtmlc.h>
#include <mshtmdid.h>
#include <dispex.h>
#include <ocmm.h>


/////////////////////////////////////////////////////////////////////////

namespace MPC
{
    namespace HTML
    {
        typedef std::list< IHTMLElement* >       IHTMLElementList;
        typedef IHTMLElementList::iterator       IHTMLElementIter;
        typedef IHTMLElementList::const_iterator IHTMLElementIterConst;

        ////////////////////////////////////////////////////////////////////////////////

        void QuoteEscape( /*[out]*/ MPC::wstring& strAppendTo, /*[in]*/ LPCWSTR szToEscape, /*[in]*/ WCHAR chQuote               );
        void UrlUnescape( /*[out]*/ MPC::wstring& strAppendTo, /*[in]*/ LPCWSTR szToEscape, /*[in]*/ bool fAsQueryString = false );
        void UrlEscape  ( /*[out]*/ MPC::wstring& strAppendTo, /*[in]*/ LPCWSTR szToEscape, /*[in]*/ bool fAsQueryString = false );
        void HTMLEscape ( /*[out]*/ MPC::wstring& strAppendTo, /*[in]*/ LPCWSTR szToEscape                                       );

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT ConstructFullTag( /*[out]*/ MPC::wstring&             strHTML           ,
                                  /*[in] */ LPCWSTR                   szTag             ,
                                  /*[in] */ bool                      fCloseTag         ,
                                  /*[in] */ const MPC::WStringLookup* pmapAttributes    ,
                                  /*[in] */ LPCWSTR                   szExtraAttributes ,
                                  /*[in] */ LPCWSTR                   szBody            ,
                                  /*[in] */ bool                      fEscapeBody       );

        void  ParseHREF( /*[in ]*/ LPCWSTR        szURL, /*[out]*/ MPC::wstring& strBaseURL, /*[out]*/ 		MPC::WStringLookup& mapQuery );
        void  BuildHREF( /*[out]*/ MPC::wstring& strURL, /*[in ]*/ LPCWSTR 		 szBaseURL, /*[in ]*/ const MPC::WStringLookup& mapQuery );
        void vBuildHREF( /*[out]*/ MPC::wstring& strURL, /*[in ]*/ LPCWSTR 		 szBaseURL, /*[in ]*/                           ...      );

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT IDispatch_To_IHTMLDocument2( /*[out]*/ CComPtr<IHTMLDocument2>& doc, /*[in]*/ IDispatch* pDisp );

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT GetFramePath( /*[out]*/ CComBSTR& bstrFrame, /*[in]*/ IDispatch* pDisp );

        HRESULT AreAllTheFramesInTheCompleteState( /*[out]*/ bool& fDone, /*[in]*/ IDispatch* pDisp );

        HRESULT LocateFrame( /*[out]*/ CComPtr<IHTMLWindow2>& win, /*[in]*/ IHTMLElement* pObj, /*[in]*/ LPCWSTR szName );

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT GetEventObject( /*[out]*/ CComPtr<IHTMLEventObj>& ev, /*[in]*/ IHTMLElement* pObj );

        HRESULT GetUniqueID( /*[out]*/ CComBSTR& bstrID, /*[in]*/ IHTMLElement* pObj );

        HRESULT FindFirstParentWithThisTag( /*[out]*/ CComPtr<IHTMLElement>& elem,  /*[in]*/ IHTMLElement* pObj, /*[in]*/ LPCWSTR szTag        );
        HRESULT FindFirstParentWithThisID ( /*[out]*/ CComPtr<IHTMLElement>& elem,  /*[in]*/ IHTMLElement* pObj, /*[in]*/ LPCWSTR szID  = NULL );

        HRESULT FindElementInCollection( /*[out]*/ CComPtr<IHTMLElement>&  elem     ,
                                         /*[in] */ IHTMLElementCollection* coll     ,
                                         /*[in] */ LPCWSTR                 szID     ,
                                         /*[in] */ int                     iPos = 0 );

        HRESULT FindElement( /*[out]*/ CComPtr<IHTMLElement>& elem, /*[in]*/ IHTMLElement* pObj, /*[in]*/ LPCWSTR szID , /*[in]*/ int iPos = 0 );
        HRESULT FindChild  ( /*[out]*/ CComPtr<IHTMLElement>& elem, /*[in]*/ IHTMLElement* pObj, /*[in]*/ LPCWSTR szID , /*[in]*/ int iPos = 0 );

        HRESULT EnumerateCollection( /*[out]*/ IHTMLElementList& lst, /*[in]*/ IHTMLElementCollection* pColl, /*[in]*/ LPCWSTR szFilterID = NULL );
        HRESULT EnumerateElements  ( /*[out]*/ IHTMLElementList& lst, /*[in]*/ IHTMLElement*           pObj , /*[in]*/ LPCWSTR szFilterID = NULL );
        HRESULT EnumerateChildren  ( /*[out]*/ IHTMLElementList& lst, /*[in]*/ IHTMLElement*           pObj , /*[in]*/ LPCWSTR szFilterID = NULL );

        HRESULT FindStyle( /*[out]*/ CComPtr<IHTMLRuleStyle>& style, /*[in]*/ IHTMLElement* pObj, /*[in]*/ LPCWSTR szName );

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT GetAttribute( /*[out]*/ CComPtr<IHTMLDOMAttribute>& attr , /*[in]*/ IHTMLElement* pObj, /*[in]*/ LPCWSTR szName );
        HRESULT GetAttribute( /*[out]*/ CComBSTR&                   value, /*[in]*/ IHTMLElement* pObj, /*[in]*/ LPCWSTR szName );

		////////////////////////////////////////////////////////////////////////////////

		bool ConvertColor( /*[in]*/ VARIANT& v, /*[out]*/ COLORREF& color, /*[out]*/ bool& fSystem );

    }; // namespace HTML

}; // namespace MPC

/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___MPC___HTML_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\mpc_logging.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    MPC_logging.h

Abstract:
    This file contains the declaration of a set of logging classes.

Revision History:
    Davide Massarenti   (Dmassare)  05/09/99
        created

******************************************************************************/

#if !defined(__INCLUDED___MPC___LOGGING_H___)
#define __INCLUDED___MPC___LOGGING_H___

#include <MPC_main.h>
#include <MPC_COM.h>

namespace MPC
{
    class FileLog : public MPC::CComSafeAutoCriticalSection // Hungarian: fl
    {
        MPC::wstring m_szLogFile;
        HANDLE       m_hFile;
		bool         m_fCacheHandle;
		bool         m_fUseUnicode;

        HRESULT Open ();
        HRESULT Close();

		HRESULT AppendString( /*[in]*/ LPCWSTR szLine );
		HRESULT WriteEntry  ( /*[in]*/ LPWSTR  szLine );

    public:
        FileLog( /*[in]*/ bool           fCacheHandle = true, /*[in]*/ bool fUseUnicode = false );
		FileLog( /*[in]*/ const FileLog& fl                                                     );
        ~FileLog();

        FileLog& operator=( /*[in]*/ const FileLog& fl );


        HRESULT SetLocation( /*[in]*/ LPCWSTR szLogFile  );
        HRESULT Rotate     ( /*[in]*/ DWORD   dwDays = 0 );
        HRESULT Terminate  (                             );

        HRESULT LogRecordV( /*[in]*/ LPCWSTR szFormat, /*[in]*/ va_list arglist );
        HRESULT LogRecordV( /*[in]*/ LPCSTR  szFormat, /*[in]*/ va_list arglist );
        HRESULT LogRecord ( /*[in]*/ LPCWSTR szFormat, ...                      );
        HRESULT LogRecord ( /*[in]*/ LPCSTR  szFormat, ...                      );
    };

    class NTEvent : public MPC::CComSafeAutoCriticalSection // Hungarian: ne
    {
        HANDLE m_hEventSource;

        HRESULT OpenFile ();
        HRESULT CloseFile();

    public:
        NTEvent(                            );
		NTEvent( /*[in]*/ const NTEvent& ne );
        ~NTEvent();

        NTEvent& operator=( /*[in]*/ const NTEvent& ne );


        HRESULT Init     ( /*[in]*/ LPCWSTR szEventSourceName );
        HRESULT Terminate(                                    );

        HRESULT LogEvent( /*[in]*/ WORD wEventType, /*[in]*/ DWORD dwEventID, ... );
    };
};


#endif // !defined(__INCLUDED___MPC___LOGGING_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\mpc_com.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    MPC_COM.h

Abstract:
    This file contains the declaration of various classes and macros to deal with COM.

Revision History:
    Davide Massarenti   (Dmassare)  06/18/99
        created

******************************************************************************/

#if !defined(__INCLUDED___MPC___COM_H___)
#define __INCLUDED___MPC___COM_H___

#include <atlbase.h>
#include <atlcom.h>

#include <dispex.h>

#include <MPC_trace.h>
#include <MPC_main.h>

#include <process.h>

////////////////////////////////////////////////////////////////////////////////

#define MPC_FORWARD_CALL_0(obj,method)                         return obj ? obj->method()                        : E_HANDLE
#define MPC_FORWARD_CALL_1(obj,method,a1)                      return obj ? obj->method(a1)                      : E_HANDLE
#define MPC_FORWARD_CALL_2(obj,method,a1,a2)                   return obj ? obj->method(a1,a2)                   : E_HANDLE
#define MPC_FORWARD_CALL_3(obj,method,a1,a2,a3)                return obj ? obj->method(a1,a2,a3)                : E_HANDLE
#define MPC_FORWARD_CALL_4(obj,method,a1,a2,a3,a4)             return obj ? obj->method(a1,a2,a3,a4)             : E_HANDLE
#define MPC_FORWARD_CALL_5(obj,method,a1,a2,a3,a4,a5)          return obj ? obj->method(a1,a2,a3,a4,a5)          : E_HANDLE
#define MPC_FORWARD_CALL_6(obj,method,a1,a2,a3,a4,a5,a6)       return obj ? obj->method(a1,a2,a3,a4,a5,a6)       : E_HANDLE
#define MPC_FORWARD_CALL_7(obj,method,a1,a2,a3,a4,a5,a6,a7)    return obj ? obj->method(a1,a2,a3,a4,a5,a6,a7)    : E_HANDLE
#define MPC_FORWARD_CALL_8(obj,method,a1,a2,a3,a4,a5,a6,a7,a8) return obj ? obj->method(a1,a2,a3,a4,a5,a6,a7,a8) : E_HANDLE

/////////////////////////////////////////////////////////////////////////////

#define MPC_SCRIPTHELPER_FAIL_IF_NOT_AN_OBJECT(var)                                                                      \
    if(((var).vt != VT_UNKNOWN  && (var).vt != VT_DISPATCH) ||                                                           \
       ((var).vt == VT_UNKNOWN  && (var).punkVal  == NULL ) ||                                                           \
       ((var).vt == VT_DISPATCH && (var).pdispVal == NULL )  ) __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG)

#define MPC_SCRIPTHELPER_GET__DIRECT(dst,obj,prop)                                                                       \
{                                                                                                                        \
    __MPC_EXIT_IF_METHOD_FAILS(hr, obj->get_##prop( &(dst) ));                                                           \
}

#define MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(dst,obj,prop)                                                              \
{                                                                                                                        \
    MPC_SCRIPTHELPER_GET__DIRECT(dst,obj,prop);                                                                          \
    if((dst) == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_NOINTERFACE);                                                       \
}

////////////////////

#define MPC_SCRIPTHELPER_GET_OBJECT(dst,obj,prop)                                                                        \
{                                                                                                                        \
    CComPtr<IDispatch> __disp;                                                                                           \
                                                                                                                         \
    MPC_SCRIPTHELPER_GET__DIRECT(__disp,obj,prop);                                                                       \
    if(__disp)                                                                                                           \
    {                                                                                                                    \
        __MPC_EXIT_IF_METHOD_FAILS(hr, __disp->QueryInterface( __uuidof(dst), (LPVOID*)&(dst) ));                        \
    }                                                                                                                    \
}

#define MPC_SCRIPTHELPER_GET_OBJECT__NOTNULL(dst,obj,prop)                                                               \
{                                                                                                                        \
    MPC_SCRIPTHELPER_GET_OBJECT(dst,obj,prop);                                                                           \
    if((dst) == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_NOINTERFACE);                                                       \
}

////////////////////

#define MPC_SCRIPTHELPER_GET_OBJECT__VARIANT(dst,obj,prop)                                                               \
{                                                                                                                        \
    CComVariant __v;                                                                                                     \
                                                                                                                         \
    MPC_SCRIPTHELPER_GET__DIRECT(__v,obj,prop);                                                                          \
                                                                                                                         \
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::VarToInterface( __v, __uuidof(dst), (IUnknown **)&(dst) ));             \
}

#define MPC_SCRIPTHELPER_GET_STRING__VARIANT(dst,obj,prop)                                                               \
{                                                                                                                        \
    CComVariant __v;                                                                                                     \
                                                                                                                         \
    MPC_SCRIPTHELPER_GET__DIRECT(__v,obj,prop);                                                                          \
                                                                                                                         \
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::VarToBSTR( __v, dst ));                                                 \
}

////////////////////

#define MPC_SCRIPTHELPER_GET_PROPERTY(dst,obj,prop)                                                                      \
{                                                                                                                        \
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::GetPropertyByName( obj, L#prop, dst ));                                 \
}

#define MPC_SCRIPTHELPER_GET_PROPERTY__BSTR(dst,obj,prop)                                                                \
{                                                                                                                        \
    CComVariant __v;                                                                                                     \
                                                                                                                         \
    MPC_SCRIPTHELPER_GET_PROPERTY(__v,obj,prop);                                                                         \
                                                                                                                         \
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::VarToBSTR( __v, dst ));                                                 \
}

////////////////////

#define MPC_SCRIPTHELPER_GET_COLLECTIONITEM(dst,obj,item)                                                                \
{                                                                                                                        \
    CComVariant __v;                                                                                                     \
                                                                                                                         \
    __MPC_EXIT_IF_METHOD_FAILS(hr, obj->get_Item( item, &__v ));                                                         \
                                                                                                                         \
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::COMUtil::VarToInterface( __v, __uuidof(dst), (IUnknown **)&(dst) ));             \
    if((dst) == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_NOINTERFACE);                                                       \
}

////////////////////

#define MPC_SCRIPTHELPER_PUT__DIRECT(obj,prop,val)                                                                       \
{                                                                                                                        \
    __MPC_EXIT_IF_METHOD_FAILS(hr, obj->put_##prop( val ));                                                              \
}

#define MPC_SCRIPTHELPER_PUT__VARIANT(obj,prop,val)                                                                      \
{                                                                                                                        \
    CComVariant v(val);                                                                                                  \
                                                                                                                         \
    MPC_SCRIPTHELPER_PUT__DIRECT(obj,prop,v);                                                                            \
}

////////////////////////////////////////////////////////////////////////////////

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

////////////////////////////////////////////////////////////////////////////////

namespace MPC
{
    class MPCMODULE;
    extern MPCMODULE _MPC_Module;

    /////////////////////////////////////////////////////////////////////////////

    namespace COMUtil
    {
        HRESULT GetPropertyByName( /*[in]*/ IDispatch* obj, /*[in]*/ LPCWSTR szName , /*[out]*/ CComVariant& v      );
        HRESULT GetPropertyByName( /*[in]*/ IDispatch* obj, /*[in]*/ LPCWSTR szName , /*[out]*/ CComBSTR&    bstr   );
        HRESULT GetPropertyByName( /*[in]*/ IDispatch* obj, /*[in]*/ LPCWSTR szName , /*[out]*/ bool&        fValue );
        HRESULT GetPropertyByName( /*[in]*/ IDispatch* obj, /*[in]*/ LPCWSTR szName , /*[out]*/ long&        lValue );

        HRESULT VarToBSTR     ( /*[in]*/ CComVariant& v,                          /*[out]*/ CComBSTR&  str );
        HRESULT VarToInterface( /*[in]*/ CComVariant& v, /*[in]*/ const IID& iid, /*[out]*/ IUnknown* *obj );

        template <class Base, class Itf> HRESULT CopyInterface( Base* src, Itf* *dst )
        {
            if(!dst) return E_POINTER;

            if(src)
            {
                return src->QueryInterface( __uuidof(*dst), (void**)dst );
            }

            *dst = NULL;

            return S_FALSE;
        }
    };

    /////////////////////////////////////////////////////////////////////////////

	HRESULT SafeInitializeCriticalSection( /*[in/out]*/ CRITICAL_SECTION& sec );
	HRESULT SafeDeleteCriticalSection    ( /*[in/out]*/ CRITICAL_SECTION& sec );

	class CComSafeAutoCriticalSection
	{
	public:
		CComSafeAutoCriticalSection ();
		~CComSafeAutoCriticalSection();

		void Lock  ();
		void Unlock();

		CRITICAL_SECTION m_sec;
	};

	class CComSafeMultiThreadModel
	{
    public:
		static ULONG WINAPI Increment(LPLONG p) { return InterlockedIncrement( p ); }
		static ULONG WINAPI Decrement(LPLONG p) { return InterlockedDecrement( p ); }

		typedef MPC::CComSafeAutoCriticalSection AutoCriticalSection;
		typedef CComCriticalSection      		 CriticalSection;
		typedef CComMultiThreadModelNoCS 		 ThreadModelNoCS;
	};

    /////////////////////////////////////////////////////////////////////////////

    //
    // Same as ATL::CComObjectCached, but with CreateInstance and no critical section.
    //
    // Base is the user's class that derives from CComObjectRoot and whatever
    // interfaces the user wants to support on the object
    // CComObjectCached is used primarily for class factories in DLL's
    // but it is useful anytime you want to cache an object
    template <class Base> class CComObjectCached : public Base
    {
    public:
        typedef Base _BaseClass;

        CComObjectCached(void* = NULL)
        {
        }

        // Set refcount to 1 to protect destruction
        ~CComObjectCached()
        {
            m_dwRef = 1L;
            FinalRelease();
        }

        //If InternalAddRef or InternalRelease is undefined then your class
        //doesn't derive from CComObjectRoot
        STDMETHOD_(ULONG, AddRef)()
        {
            ULONG l = InternalAddRef();

            if(l == 2) _Module.Lock();

            return l;
        }

        STDMETHOD_(ULONG, Release)()
        {
            ULONG l = InternalRelease();

            if     (l == 0) delete this;
            else if(l == 1) _Module.Unlock();

            return l;
        }

        //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) { return _InternalQueryInterface(iid, ppvObject); }
        template <class Q> HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp) { return QueryInterface(__uuidof(Q), (void**)pp); }

        static HRESULT WINAPI CreateInstance( CComObjectCached<Base>** pp )
        {
            ATLASSERT(pp != NULL);
            HRESULT hRes = E_OUTOFMEMORY;
            CComObjectCached<Base>* p = NULL;
            ATLTRY(p = new CComObjectCached<Base>())
            if(p != NULL)
            {
                p->SetVoid(NULL);
                p->InternalFinalConstructAddRef();
                hRes = p->FinalConstruct();
                p->InternalFinalConstructRelease();
                if(hRes != S_OK)
                {
                    delete p;
                    p = NULL;
                }
            }
            *pp = p;
            return hRes;
        }
    };

    //
    // Same as ATL::CComObjectNoLock, but with CreateInstance.
    //
    template <class Base> class CComObjectNoLock : public Base
    {
    public:
        typedef Base _BaseClass;

        CComObjectNoLock(void* = NULL)
        {
        }

        // Set refcount to 1 to protect destruction
        ~CComObjectNoLock()
        {
            m_dwRef = 1L;
            FinalRelease();
        }

        //If InternalAddRef or InternalRelease is undefined then your class
        //doesn't derive from CComObjectRoot
        STDMETHOD_(ULONG, AddRef)()
        {
            return InternalAddRef();
        }

        STDMETHOD_(ULONG, Release)()
        {
            ULONG l = InternalRelease();

            if(l == 0) delete this;

            return l;
        }

        //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) { return _InternalQueryInterface(iid, ppvObject); }
        template <class Q> HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp) { return QueryInterface(__uuidof(Q), (void**)pp); }

        static HRESULT WINAPI CreateInstance( CComObjectNoLock<Base>** pp )
        {
            ATLASSERT(pp != NULL);
            HRESULT hRes = E_OUTOFMEMORY;
            CComObjectNoLock<Base>* p = NULL;
            ATLTRY(p = new CComObjectNoLock<Base>())
            if(p != NULL)
            {
                p->SetVoid(NULL);
                p->InternalFinalConstructAddRef();
                hRes = p->FinalConstruct();
                p->InternalFinalConstructRelease();
                if(hRes != S_OK)
                {
                    delete p;
                    p = NULL;
                }
            }
            *pp = p;
            return hRes;
        }
    };

    //
    // Same as ATL::CComObjectGlobal, but with no module locking.
    //
    template <class Base> class CComObjectGlobalNoLock : public Base
    {
    public:
        typedef Base _BaseClass;

        CComObjectGlobalNoLock(void* = NULL)
        {
            m_hResFinalConstruct = FinalConstruct();
        }

        ~CComObjectGlobalNoLock()
        {
            FinalRelease();
        }

        STDMETHOD_(ULONG, AddRef)()  { return 2; }
        STDMETHOD_(ULONG, Release)() { return 1; }

        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {
            return _InternalQueryInterface(iid, ppvObject);
        }

        HRESULT m_hResFinalConstruct;
    };

    ////////////////////////////////////////////////////////////////////////////////

    interface CComObjectRootParentBase : IUnknown
    {
        virtual ULONG STDMETHODCALLTYPE WeakAddRef (void) = 0;
        virtual ULONG STDMETHODCALLTYPE WeakRelease(void) = 0;

        void Passivate()
        {
        }

        template <class C, class P> HRESULT CreateChild( P* pParent, C* *pVal )
        {
            C*      obj;
            HRESULT hr;

            *pVal = NULL;

            if(SUCCEEDED(hr = obj->CreateInstance( &obj )))
            {
                obj->AddRef();
                obj->Child_LinkToParent( pParent );

                *pVal = obj;
            }

            return hr;
        }
    };

    template <class ThreadModel, class T> class CComObjectRootChildEx : public CComObjectRootEx<ThreadModel>
    {
    private:
        T* m_Child_pParent;

        void Child_UnlinkParent()
        {
            Lock();

            if(m_Child_pParent)
            {
                m_Child_pParent->WeakRelease();
                m_Child_pParent = NULL;
            }

            Unlock();
        }

    public:
        CComObjectRootChildEx() : m_Child_pParent(NULL) {}

        virtual ~CComObjectRootChildEx()
        {
            Child_UnlinkParent();
        }

        void Child_LinkToParent( T* pParent )
        {
            Lock();

            Child_UnlinkParent();

            if((m_Child_pParent = pParent))
            {
                m_Child_pParent->WeakAddRef();
            }

            Unlock();
        }

        void Child_GetParent( T* *ppParent )
        {
            Lock();

            if((*ppParent = m_Child_pParent))
            {
                m_Child_pParent->AddRef();
            }

            Unlock();
        }
    };

    template <class Base> class CComObjectParent : public Base
    {
    public:
        typedef Base _BaseClass;

        CComObjectParent(void* = NULL)
        {
            m_dwRefWeak = 0L;

            ::_Module.Lock();
        }

        // Set refcount to 1 to protect destruction
        ~CComObjectParent()
        {
            m_dwRef = 1L;
            FinalRelease();

            ::_Module.Unlock();
        }

        STDMETHOD_(ULONG, AddRef)()
        {
            ULONG l;

            Lock();

            l = ++m_dwRef;

            Unlock();

            return l;
        }

        STDMETHOD_(ULONG, Release)()
        {
            ULONG l;
            bool  readytodelete = false;

            Lock();

            l = --m_dwRef;

            if(l == 0)
            {
                m_dwRef += 2; // Protect ourself during the "Passivate" process.
                Unlock();
                Passivate();
                Lock();
                m_dwRef -= 2;

                if(m_dwRefWeak == 0)
                {
                    readytodelete = true;
                }
            }

            Unlock();

            if(readytodelete)
            {
                delete this;
            }

            return l;
        }

        //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {
            return _InternalQueryInterface(iid, ppvObject);
        }


        STDMETHOD_(ULONG, WeakAddRef)()
        {
            ULONG l;

            Lock();

            l = ++m_dwRefWeak;

            Unlock();

            return l;
        }

        STDMETHOD_(ULONG, WeakRelease)()
        {
            ULONG l;
            bool  readytodelete = false;

            Lock();

            l = --m_dwRefWeak;

            if(m_dwRef == 0)
            {
                if(m_dwRefWeak == 0)
                {
                    readytodelete = true;
                }
            }

            Unlock();

            if(readytodelete)
            {
                delete this;
            }

            return l;
        }

        static HRESULT WINAPI CreateInstance( CComObjectParent<Base>** pp );

        ULONG m_dwRefWeak;
    };


    template <class Base> HRESULT WINAPI CComObjectParent<Base>::CreateInstance( CComObjectParent<Base>** pp )
    {
        ATLASSERT(pp != NULL);

        HRESULT                 hRes = E_OUTOFMEMORY;
        CComObjectParent<Base>* p    = NULL;

        ATLTRY(p = new CComObjectParent<Base>())

        if(p != NULL)
        {
            p->SetVoid(NULL);
            p->InternalFinalConstructAddRef();

            hRes = p->FinalConstruct();

            p->InternalFinalConstructRelease();
            if(hRes != S_OK)
            {
                delete p;
                p = NULL;
            }
        }
        *pp = p;
        return hRes;
    }

    template <class T, const CLSID* pclsid = &CLSID_NULL> class CComParentCoClass : public CComCoClass<T, pclsid>
    {
    public:
        typedef CComCreator2< CComCreator< MPC::CComObjectParent< T > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
    };

    /////////////////////////////////////////////////////////////////////////////

    //
    // Smart Lock class, so that locks on ATL objects can be easily acquired and released.
    //
    template <class ThreadModel> class SmartLock
    {
        CComObjectRootEx<ThreadModel>* m_p;

        SmartLock( const SmartLock& );

    public:
        SmartLock(CComObjectRootEx<ThreadModel>* p) : m_p(p)
        {
            if(p) p->Lock();
        }

        ~SmartLock()
        {
            if(m_p) m_p->Unlock();
        }

        SmartLock& operator=( /*[in]*/ CComObjectRootEx<ThreadModel>* p )
        {
            if(m_p) m_p->Unlock();
            if(p  ) p  ->Lock  ();

            m_p = p;

            return *this;
        }
    };

    //
    // Smart Lock class, works with every class exposing 'Lock' and 'Unlock'.
    //
    template <class T> class SmartLockGeneric
    {
        T* m_p;

        SmartLockGeneric( const SmartLockGeneric& );

    public:
        SmartLockGeneric( T* p ) : m_p(p)
        {
            if(p) p->Lock();
        }

        ~SmartLockGeneric()
        {
            if(m_p) m_p->Unlock();
        }

        SmartLockGeneric& operator=( /*[in]*/ T* p )
        {
            if(m_p) m_p->Unlock();
            if(p  ) p  ->Lock  ();

            m_p = p;

            return *this;
        }
    };

    /////////////////////////////////////////////////////////////////////////////

    //
    // Class used to act as an hub for all the instances of CComPtrThreadNeutral<T>.
    // It holds the Global Interface Table.
    //
    class CComPtrThreadNeutral_GIT
    {
        IGlobalInterfaceTable* m_pGIT;
        CRITICAL_SECTION       m_sec;

        void    Lock  ();
        void    Unlock();
        HRESULT GetGIT( IGlobalInterfaceTable* *ppGIT );

    public:

        CComPtrThreadNeutral_GIT();
        ~CComPtrThreadNeutral_GIT();

        HRESULT Init();
        HRESULT Term();

        HRESULT RegisterInterface( /*[in]*/ IUnknown* pUnk, /*[in]*/ REFIID riid, /*[out]*/ DWORD *pdwCookie );
        HRESULT RevokeInterface  ( /*[in]*/ DWORD dwCookie                                                   );
        HRESULT GetInterface     ( /*[in]*/ DWORD dwCookie, /*[in]*/ REFIID riid, /*[out]*/ void* *ppv       );
    };

    //
    // This smart pointer template stores THREAD-INDEPEDENT pointers to COM objects.
    //
    // The best way to use it is to store an object reference into it and then assign
    // the object itself to a CComPtr<T>.
    //
    // This way the proper proxy is looked up and the smart pointer will keep it alive.
    //
    template <class T> class CComPtrThreadNeutral
    {
    private:
        DWORD m_dwCookie;

        void Inner_Register( T* lp )
        {
            if(lp && _MPC_Module.m_GITHolder)
            {
                _MPC_Module.m_GITHolder->RegisterInterface( lp, __uuidof(T), &m_dwCookie );
            }
        }

    public:
        typedef T _PtrClass;

        CComPtrThreadNeutral()
        {
            m_dwCookie = 0xFEFEFEFE;
        }

        CComPtrThreadNeutral( /*[in]*/ const CComPtrThreadNeutral<T>& t )
        {
            m_dwCookie = 0xFEFEFEFE;

            *this = t;
        }

        CComPtrThreadNeutral( T* lp )
        {
            m_dwCookie = 0xFEFEFEFE;

            Inner_Register( lp );
        }

        ~CComPtrThreadNeutral()
        {
            Release();
        }

        //////////////////////////////////////////////////////////////////////

        operator CComPtr<T>() const
        {
            CComPtr<T> res;

            (void)Access( &res );

            return res;
        }

        CComPtr<T> operator=( T* lp )
        {
            Release();

            Inner_Register( lp );

            return (CComPtr<T>)(*this);
        }

        CComPtrThreadNeutral& operator=( /*[in]*/ const CComPtrThreadNeutral<T>& t )
        {
            CComPtr<T> obj;

            Release();

            if(SUCCEEDED(t.Access( &obj )))
            {
                Inner_Register( obj );
            }

            return *this;
        }

        bool operator!() const
        {
            return (m_dwCookie == 0xFEFEFEFE);
        }

        //////////////////////////////////////////////////////////////////////

        void Release()
        {
            if(m_dwCookie != 0xFEFEFEFE)
            {
                _MPC_Module.m_GITHolder->RevokeInterface( m_dwCookie );

                m_dwCookie = 0xFEFEFEFE;
            }
        }

        void Attach( T* p )
        {
            *this = p;

            if(p) p->Release();
        }

        T* Detach()
        {
            T* pt;

            (void)Access( &pt );

            Release();

            return pt;
        }

        HRESULT Access( T* *ppt ) const
        {
            HRESULT hr;

            if(ppt == NULL)
            {
                hr = E_POINTER;
            }
            else
            {
                *ppt = NULL;

                if(m_dwCookie != 0xFEFEFEFE)
                {
                    hr = _MPC_Module.m_GITHolder->GetInterface( m_dwCookie, __uuidof(T), (void**)ppt );
                }
                else
                {
                    hr = S_FALSE;
                }
            }

            return hr;
        }
    };

    ////////////////////////////////////////////////////////////////////////////////

    template <class T, const IID* piid, const GUID* plibid>
    class ATL_NO_VTABLE IDispatchExImpl :
       public IDispatchImpl<T, piid, plibid>,
       public IDispatchEx
    {
    public:
        typedef IDispatchExImpl<T, piid, plibid> self;
        typedef IDispatchImpl<T, piid, plibid>   super;

        //
        // IDispatch
        //
        STDMETHOD(GetTypeInfoCount)( UINT* pctinfo )
        {
            return super::GetTypeInfoCount( pctinfo );
        }

        STDMETHOD(GetTypeInfo)( UINT        itinfo  ,
                                LCID        lcid    ,
                                ITypeInfo* *pptinfo )
        {
            return super::GetTypeInfo( itinfo, lcid, pptinfo );
        }

        STDMETHOD(GetIDsOfNames)( REFIID    riid      ,
                                  LPOLESTR* rgszNames ,
                                  UINT      cNames    ,
                                  LCID      lcid      ,
                                  DISPID*   rgdispid  )
        {
            return super::GetIDsOfNames( riid, rgszNames, cNames, lcid, rgdispid );
        }

        STDMETHOD(Invoke)( DISPID      dispidMember ,
                           REFIID      riid         ,
                           LCID        lcid         ,
                           WORD        wFlags       ,
                           DISPPARAMS* pdispparams  ,
                           VARIANT*    pvarResult   ,
                           EXCEPINFO*  pexcepinfo   ,
                           UINT*       puArgErr     )
        {
            return super::Invoke( dispidMember, riid , lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr );
        }

        //
        // IDispatchEx
        //
        STDMETHOD(GetDispID)( /*[in] */ BSTR    bstrName ,
                              /*[in] */ DWORD   grfdex   ,
                              /*[out]*/ DISPID *pid      )
        {
            if(grfdex & fdexNameEnsure) return E_NOTIMPL;

            return GetIDsOfNames( IID_NULL, &bstrName, 1, 0, pid );
        }

        STDMETHOD(InvokeEx)( /*[in] */ DISPID            id        ,
                             /*[in] */ LCID              lcid      ,
                             /*[in] */ WORD              wFlags    ,
                             /*[in] */ DISPPARAMS*       pdp       ,
                             /*[out]*/ VARIANT*          pvarRes   ,
                             /*[out]*/ EXCEPINFO*        pei       ,
                             /*[in] */ IServiceProvider* pspCaller )
        {
            return Invoke( id, IID_NULL, lcid,   wFlags, pdp, pvarRes, pei, NULL );
        }

        STDMETHOD(DeleteMemberByName)( /*[in]*/ BSTR  bstrName ,
                                       /*[in]*/ DWORD grfdex   )
        {
            return E_NOTIMPL;
        }

        STDMETHOD(DeleteMemberByDispID)( /*[in]*/ DISPID id )
        {
            return E_NOTIMPL;
        }

        STDMETHOD(GetMemberProperties)( /*[in] */ DISPID  id          ,
                                        /*[in] */ DWORD   grfdexFetch ,
                                        /*[out]*/ DWORD  *pgrfdex     )
        {
            return E_NOTIMPL;
        }

        STDMETHOD(GetMemberName)( /*[in] */ DISPID  id        ,
                                  /*[out]*/ BSTR   *pbstrName )
        {
            return E_NOTIMPL;
        }

        STDMETHOD(GetNextDispID)( /*[in] */ DWORD   grfdex ,
                                  /*[in] */ DISPID  id     ,
                                  /*[out]*/ DISPID *pid    )
        {
            return E_NOTIMPL;
        }

        STDMETHOD(GetNameSpaceParent)( /*[out]*/ IUnknown* *ppunk )
        {
            return E_NOTIMPL;
        }
    };

    class CComConstantHolder
    {
        typedef std::map<DISPID,CComVariant> MemberLookup;
        typedef MemberLookup::iterator       MemberLookupIter;
        typedef MemberLookup::const_iterator MemberLookupIterConst;

        ////////////////////

        const GUID*       m_plibid;
        WORD              m_wMajor;
        WORD              m_wMinor;

        CComPtr<ITypeLib> m_pTypeLib;
        MemberLookup      m_const;

		HRESULT EnsureLoaded( /*[in]*/ LCID lcid );

    public:
        CComConstantHolder( /*[in]*/ const GUID* plibid     ,
                            /*[in]*/ WORD        wMajor = 1 ,
                            /*[in]*/ WORD        wMinor = 0 );

        HRESULT GetIDsOfNames( /*[in]*/  LPOLESTR* rgszNames ,
                               /*[in]*/  UINT      cNames    ,
                               /*[in]*/  LCID      lcid      ,
                               /*[out]*/ DISPID*   rgdispid  );

        HRESULT GetValue( /*[in]*/  DISPID   dispidMember ,
						  /*[in]*/  LCID     lcid         ,
                          /*[out]*/ VARIANT* pvarResult   );
    };

    /////////////////////////////////////////////////////////////////////////////

    //
    // Template used to manage work threads.
    // Class 'T' should implement a method like this: 'HRESULT <method>()'.
    //
    template <class T, class Itf, DWORD dwThreading = COINIT_MULTITHREADED> class Thread
    {
    public:
        typedef HRESULT (T::*THREAD_RUN)();

    private:
        CRITICAL_SECTION          m_sec;

        T*                        m_SelfDirect;
        THREAD_RUN                m_Callback;
        CComPtrThreadNeutral<Itf> m_Self;          // The keep the object alive will the thread is running.

        HANDLE                    m_hThread;       // The thread itself.
        bool                      m_fRunning;      // If true the thread is still running.

        HANDLE                    m_hEvent;        // Used to notify the worker thread.
        HANDLE                    m_hEventReverse; // Used to notify the main thread.
        bool                      m_fAbort;        // Used to tell the thread to abort and exit.

        // Passed to _beginthreadex.
        static unsigned __stdcall Thread_Startup( /*[in]*/ void* pv )
        {
            __MPC_FUNC_ENTRY( COMMONID, "MPC::Thread::Thread_Startup" );

            HRESULT                    hRes  = ::CoInitializeEx( NULL, dwThreading );
            Thread<T,Itf,dwThreading>* pThis = (Thread<T,Itf,dwThreading>*)pv;

            if(SUCCEEDED(hRes))
            {
                try
                {
                    pThis->Thread_InnerRun();
                }
                catch(...)
                {
                    pThis->Thread_Lock();

                    pThis->m_fAbort = true;

                    pThis->Thread_Unlock();
                }

                ::CoUninitialize();
            }

            pThis->Thread_Lock();

            pThis->m_fRunning = false;

            pThis->Thread_Unlock();

            __MPC_FUNC_EXIT(0);
        }

        //
        // The core loop that would keep calling 'Thread_Run' until:
        //
        // a) m_fAbort is set, and
        //
        // b) hr reports a success.
        //
        HRESULT Thread_InnerRun()
        {
            __MPC_FUNC_ENTRY( COMMONID, "MPC::Thread::Thread_InnerRun" );

            HRESULT hr = S_OK;


            Thread_Lock();

            if(m_SelfDirect && m_Callback)
            {
                while(m_fAbort == false && SUCCEEDED(hr))
                {
                    Thread_Unlock(); // Always unlock before waiting for signal.
                    (void)MPC::WaitForSingleObject( m_hEvent, INFINITE );
                    Thread_Lock(); // Lock again.

                    if(m_fAbort == false)
                    {
                        Thread_Unlock(); // Unlock while handling the request.
                        hr = (m_SelfDirect->*m_Callback)();
                        Thread_Lock(); // Lock again.
                    }
                }
            }

            Thread_Release();

            Thread_Unlock();

            __MPC_FUNC_EXIT(hr);
        }

        void Thread_Lock  () { ::EnterCriticalSection( &m_sec ); }
        void Thread_Unlock() { ::LeaveCriticalSection( &m_sec ); }

    protected:
        DWORD Thread_WaitForEvents( HANDLE hEvent, DWORD dwTimeout )
        {
            HANDLE hEvents[2] = { m_hEvent, hEvent };
            DWORD  dwWait;

            return ::WaitForMultipleObjects( hEvent ? 2 : 1, hEvents, FALSE, dwTimeout );
        }

        HANDLE Thread_GetSignalEvent()
        {
            return m_hEvent;
        }

    public:
        Thread()
        {
            ::InitializeCriticalSection( &m_sec );

                                     // CRITICAL_SECTION          m_sec;
                                     //
            m_SelfDirect    = NULL;  // T*                        m_SelfDirect;
                                     // CComPtrThreadNeutral<Itf> m_Self
                                     //
            m_hThread       = NULL;  // HANDLE                    m_hThread;
            m_fRunning      = false; // bool                      m_fRunning;
                                     //
            m_hEvent        = NULL;  // HANDLE                    m_hEvent;
            m_hEventReverse = NULL;  // HANDLE                    m_hEventReverse;
            m_fAbort        = false; // bool                      m_fAbort;
        }

        ~Thread()
        {
            Thread_Wait();

            ::DeleteCriticalSection( &m_sec );
        }


        HRESULT Thread_Start( /*[in]*/ T* selfDirect, /*[in]*/ THREAD_RUN callback, /*[in]*/ Itf* self )
        {
            __MPC_FUNC_ENTRY( COMMONID, "MPC::Thread::Thread_Start" );

            HRESULT hr;
            DWORD   dwThreadID;


            //
            // First of all, kill the currently running thread, if any.
            //
            Thread_Abort();
            Thread_Wait ();


            Thread_Lock();

            m_SelfDirect = selfDirect;
            m_Callback   = callback;
            m_Self       = self;
            m_fAbort     = false;
            m_fRunning   = false;

            //
            // Create the event used to signal the worker thread about changes in the queue or termination requests.
            //
            // The Event is created in the SET state, so the worker thread doesn't wait in the WaitForSingleObject the first time.
            //
            __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_hEvent = ::CreateEvent( NULL, FALSE, TRUE, NULL )));

            //
            // Create the event used to signal the main thread.
            //
            __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_hEventReverse = ::CreateEvent( NULL, FALSE, FALSE, NULL )));

            //
            // Create the worker thread.
            //
            __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_hThread = (HANDLE)_beginthreadex( NULL, 0, Thread_Startup, this, 0, (unsigned*)&dwThreadID )));

            m_fRunning = true;
            hr         = S_OK;


            __MPC_FUNC_CLEANUP;

            Thread_Unlock();

            __MPC_FUNC_EXIT(hr);
        }

        bool Thread_SameThread()
        {
            Thread_Lock();

            bool fRes = (::GetCurrentThread() == m_hThread);

            Thread_Unlock();

            return fRes;
        }

        void Thread_Wait( /*[in]*/ bool fForce = true, /*[in]*/ bool fNoMsg = false )
        {
            __MPC_FUNC_ENTRY( COMMONID, "MPC::Thread::Thread_Wait" );

            Thread_Lock();

            if(m_hThread && m_hEvent)
            {
                if(::GetCurrentThread() != m_hThread)
                {
                    while(m_fRunning == true)
                    {
                        if(fForce) Thread_Abort();

                        Thread_Unlock(); // Always unlock before waiting for signal.
                        if(fNoMsg)
                        {
                            (void)::WaitForSingleObject( m_hThread, INFINITE );
                        }
                        else
                        {
                            (void)MPC::WaitForSingleObject( m_hThread, INFINITE );
                        }
                        Thread_Lock(); // Lock again.
                    }
                }
            }

            if(m_hEventReverse)
            {
                ::CloseHandle( m_hEventReverse );
                m_hEventReverse = NULL;
            }

            if(m_hEvent)
            {
                ::CloseHandle( m_hEvent );
                m_hEvent = NULL;
            }

            if(m_hThread)
            {
                ::CloseHandle( m_hThread );
                m_hThread = NULL;
            }


            Thread_Release();

            Thread_Unlock();
        }

        DWORD Thread_WaitNotificationFromWorker( /*[in]*/ DWORD dwTimeout, /*[in]*/ bool fNoMessagePump )
        {
            __MPC_FUNC_ENTRY( COMMONID, "MPC::Thread::Thread_WaitNotificationFromWorker" );

            DWORD dwRes = WAIT_TIMEOUT;

            Thread_Lock();

            if(Thread_IsRunning() && m_hEventReverse && ::GetCurrentThread() != m_hThread)
            {
                Thread_Unlock(); // Always unlock before waiting for signal.

				if(fNoMessagePump)
				{
					dwRes = ::WaitForSingleObject( m_hEventReverse, dwTimeout );
				}
				else
				{
					dwRes = MPC::WaitForSingleObject( m_hEventReverse, dwTimeout );
				}

                Thread_Lock(); // Lock again.
            }

            Thread_Unlock();

            __MPC_FUNC_EXIT(dwRes);
        }

        void Thread_Release()
        {
            __MPC_FUNC_ENTRY( COMMONID, "MPC::Thread::Thread_Release" );

            Thread_Lock();

            m_SelfDirect = NULL;
            m_Callback   = NULL;
            m_Self       = NULL;

            Thread_Unlock();
        }

        void Thread_Signal()
        {
            __MPC_FUNC_ENTRY( COMMONID, "MPC::Thread::Thread_Signal" );

            Thread_Lock();

            if(m_hEvent)
            {
                ::SetEvent( m_hEvent );
            }

            Thread_Unlock();
        }

        void Thread_SignalMain()
        {
            __MPC_FUNC_ENTRY( COMMONID, "MPC::Thread::Thread_SignalMain" );

            Thread_Lock();

            if(m_hEventReverse)
            {
                ::SetEvent( m_hEventReverse );
            }

            Thread_Unlock();
        }

        void Thread_Abort()
        {
            __MPC_FUNC_ENTRY( COMMONID, "MPC::Thread::Thread_Abort" );

            Thread_Lock();

            if(m_hEvent)
            {
                m_fAbort = true;
                ::SetEvent( m_hEvent );
            }

            Thread_Unlock();
        }

        CComPtr<Itf> Thread_Self()
        {
            __MPC_FUNC_ENTRY( COMMONID, "MPC::Thread::Thread_Self" );

            //
            // Do NOT use locking, because:
            //
            // 1) It's not needed (m_Self is used internally to the thread, it's not a shared resource).
            // 2) GIT can cause a thread switch and a deadlock...
            //
            CComPtr<Itf> res = m_Self;

            __MPC_FUNC_EXIT(res);
        }

        bool Thread_IsAborted()
        {
            __MPC_FUNC_ENTRY( COMMONID, "MPC::Thread::Thread_IsAborted" );

            bool res;

            Thread_Lock();

            res = m_fAbort;

            Thread_Unlock();

            __MPC_FUNC_EXIT(res);
        }

        bool Thread_IsRunning()
        {
            __MPC_FUNC_ENTRY( COMMONID, "MPC::Thread::Thread_IsRunning" );

            bool res;

            Thread_Lock();

            res = m_fRunning;

            Thread_Unlock();

            __MPC_FUNC_EXIT(res);
        }
    };

    /////////////////////////////////////////////////////////////////////////////

    //
    // Async Invoke class, used to call IDispatch interfaces in an asynchronous way.
    //
    class AsyncInvoke : // hungarian: mpcai
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>, // For the locking support...
        public Thread<AsyncInvoke,IUnknown>
    {
    public:
        //
        // These two classes, CallItem and CallDesc, are useful also outside this class,
        // because "CallDesc" allows to have an object that can call any IDispatch-related methods,
        // irregardless to the apartment model, while "CallItem" does the same for VARIANTs.
        //
        class CallItem // hungarian: ci
        {
            VARTYPE                         m_vt;
            CComPtrThreadNeutral<IUnknown>  m_Unknown;
            CComPtrThreadNeutral<IDispatch> m_Dispatch;
            CComVariant                     m_Other;

        public:
            CallItem();

            CallItem& operator=( const CComVariant& var );

            operator CComVariant() const;
        };

        class CallDesc // hungarian: cd
        {
            CComPtrThreadNeutral<IDispatch> m_dispTarget;
            DISPID                          m_dispidMethod;
            CallItem*                       m_rgciVars;
            DWORD                           m_dwVars;

        public:
            CallDesc( IDispatch* dispTarget, DISPID dispidMethod, const CComVariant* rgvVars, int dwVars );
            ~CallDesc();

            HRESULT Call();
        };

    private:
        typedef std::list< CallDesc* > List;
        typedef List::iterator         Iter;
        typedef List::const_iterator   IterConst;

        List m_lstEvents;

        HRESULT Thread_Run();

    public:
        HRESULT Init();
        HRESULT Term();

        HRESULT Invoke( IDispatch* dispTarget, DISPID dispidMethod, const CComVariant* rgvVars, int dwVars );
    };

    /////////////////////////////////////////////////////////////////////////////

    //
    // This template facilitate the implementation of Collections and Enumerators.
    //
    // It implements a Collections of objects, all implementing the <class Itf> interface, through Type Library <const GUID* plibid>.
    //
    // All the client has to do is call "AddItem", to add elements to the collection:
    //
    //    class ATL_NO_VTABLE CNewClass : // Hungarian: hsc
    //        public MPC::CComCollection< INewClass, &LIBID_NewLib, CComMultiThreadModel>
    //    {
    //    public:
    //    BEGIN_COM_MAP(CNewClass)
    //        COM_INTERFACE_ENTRY(IDispatch)
    //        COM_INTERFACE_ENTRY(INewClass)
    //    END_COM_MAP()
    //    };
    //
    template <class Itf, const GUID* plibid, class ThreadModel>
    class CComCollection :
          public CComObjectRootEx<ThreadModel>,
          public ICollectionOnSTLImpl<
                                       IDispatchImpl< Itf, &__uuidof(Itf), plibid >,
                                       std::list    < VARIANT >,
                                                      VARIANT  ,
                                       _Copy        < VARIANT >,
                                       CComEnumOnSTL< IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT>, std::list< VARIANT >, ThreadModel >
                                     >
    {
    public:
        typedef std::list< VARIANT >           CollectionList;
        typedef CollectionList::iterator       CollectionIter;
        typedef CollectionList::const_iterator CollectionIterConst;

        void FinalRelease()
        {
            Erase();
        }

        void Erase()
        {
            MPC::SmartLock<_ThreadModel> lock( this );

            MPC::ReleaseAllVariant( m_coll );
        }

        HRESULT AddItem( /*[in]*/ IDispatch* pDisp )
        {
            MPC::SmartLock<_ThreadModel> lock( this );

            if(pDisp)
            {
                VARIANT vItem;

                ::VariantInit( &vItem );

                vItem.vt       = VT_DISPATCH;
                vItem.pdispVal = pDisp; pDisp->AddRef();

                m_coll.push_back( vItem );
            }

            return S_OK;
        }
    };

    //////////////////////////////////////////////////////////////////////

    template <class Base, const IID* piid, class ThreadModel> class ConnectionPointImpl :
        public CComObjectRootEx<ThreadModel>,
        public IConnectionPointContainerImpl< Base                            >,
        public IConnectionPointImpl         < Base, piid, CComDynamicUnkArray >
    {
    public:
        BEGIN_CONNECTION_POINT_MAP(Base)
            CONNECTION_POINT_ENTRY((*piid))
        END_CONNECTION_POINT_MAP()

    protected:
        //
        // Event firing methods.
        //
        HRESULT FireAsync_Generic( DISPID dispid, CComVariant* pVars, DWORD dwVars, CComPtr<IDispatch> pJScript )
        {
            HRESULT            hr;
            MPC::IDispatchList lst;

            //
            // Only this part should be inside a critical section, otherwise deadlocks could occur.
            //
            {
                MPC::SmartLock<_ThreadModel> lock( this );

                MPC::CopyConnections( m_vec, lst ); // Get a copy of the connection point clients.
            }

            hr = MPC::FireAsyncEvent( dispid, pVars, dwVars, lst, pJScript );

            MPC::ReleaseAll( lst );

            return hr;
        }

        HRESULT FireSync_Generic( DISPID dispid, CComVariant* pVars, DWORD dwVars, CComPtr<IDispatch> pJScript )
        {
            HRESULT            hr;
            MPC::IDispatchList lst;

            //
            // Only this part should be inside a critical section, otherwise deadlocks could occur.
            //
            {
                MPC::SmartLock<_ThreadModel> lock( this );

                MPC::CopyConnections( m_vec, lst ); // Get a copy of the connection point clients.
            }

            hr = MPC::FireEvent( dispid, pVars, dwVars, lst, pJScript );

            MPC::ReleaseAll( lst );

            return hr;
        }
    };

    HRESULT FireAsyncEvent( DISPID dispid, CComVariant* pVars, DWORD dwVars, const IDispatchList& lst, IDispatch* pJScript = NULL, bool fFailOnError = false );
    HRESULT FireEvent     ( DISPID dispid, CComVariant* pVars, DWORD dwVars, const IDispatchList& lst, IDispatch* pJScript = NULL, bool fFailOnError = false );

    template <class Coll> HRESULT CopyConnections( Coll&          coll ,
                                                   IDispatchList& lst  )
    {
        int nConnectionIndex;
        int nConnections = coll.GetSize();

        //
        // nConnectionIndex == -1 is a special case, for calling a JavaScript function!
        //
        for(nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            CComQIPtr<IDispatch> sp( coll.GetAt(nConnectionIndex) );

            if(sp)
            {
                lst.push_back( sp.Detach() );
            }
        }

        return S_OK;
    }

    /////////////////////////////////////////////////////////////////////////////

    class MPCMODULE
    {
        class AnchorBase
        {
        public:
            virtual void Call (            ) = 0;
            virtual bool Match( void* pObj ) = 0;
        };

        template <class C> class Anchor : public AnchorBase
        {
            typedef void (C::*CLASS_METHOD)();

            C*           m_pThis;
            CLASS_METHOD m_pCallback;

        public:
            Anchor( /*[in]*/ C* pThis, /*[in]*/ CLASS_METHOD pCallback )
            {
                m_pThis     = pThis;
                m_pCallback = pCallback;
            }

            void Call()
            {
                (m_pThis->*m_pCallback)();
            }

            bool Match( /*[in]*/ void* pObj )
            {
                return m_pThis == (C*)pObj;
            }
        };


        typedef std::list< AnchorBase* > List;
        typedef List::iterator           Iter;
        typedef List::const_iterator     IterConst;


        static LONG                m_lInitialized;
        static LONG                m_lInitializing;
        static CComCriticalSection m_sec;
        static List*               m_lstTermCallback;

        ////////////////////////////////////////

        static HRESULT Initialize();

        HRESULT RegisterCallbackInner  ( /*[in]*/ AnchorBase* pElem, /*[in]*/ void* pThis );
        HRESULT UnregisterCallbackInner(                             /*[in]*/ void* pThis );

    public:
        CComPtrThreadNeutral_GIT* m_GITHolder;
        AsyncInvoke*              m_AsyncInvoke;

        HRESULT Init();
        HRESULT Term();


        template <class C> HRESULT RegisterCallback( C* pThis, void (C::*pCallback)() )
        {
            if(pThis == NULL) return E_POINTER;

            return RegisterCallbackInner( new Anchor<C>( pThis, pCallback ), pThis );
        }

        template <class C> HRESULT UnregisterCallback( C* pThis )
        {
            return UnregisterCallbackInner( pThis );
        }
    };

    extern MPCMODULE _MPC_Module;


    //
    // Function to call a method in an asynchronous mode (however, no return values will be given).
    //
    HRESULT AsyncInvoke( IDispatch* dispTarget, DISPID dispidMethod, const CComVariant* rgvVars, int dwVars );

    //
    // This is like Sleep(), but it spins the message pump.
    //
    void SleepWithMessagePump( /*[in]*/ DWORD dwTimeout );

    //
    // Functions to wait on events even in an STA context.
    //
    DWORD WaitForSingleObject   ( /*[in]*/                           HANDLE   hEvent , /*[in]*/ DWORD dwTimeout = INFINITE );
    DWORD WaitForMultipleObjects( /*[in]*/ DWORD  dwEvents, /*[in]*/ HANDLE* rgEvents, /*[in]*/ DWORD dwTimeout = INFINITE );


}; // namespace


#endif // !defined(__INCLUDED___MPC___COM_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\mpc_main.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    MPC_main.h

Abstract:
    This file includes and defines things common to all modules.

Revision History:
    Davide Massarenti   (Dmassare)  05/08/99
        created

******************************************************************************/

#if !defined(__INCLUDED___MPC___MAIN_H___)
#define __INCLUDED___MPC___MAIN_H___

#include <atlbase.h>

#include <Yvals_nodll.h>
#include <iosfwd_nodll>
#include <xstring_noref>
#include <string_noref>

#include <list>
#include <vector>
#include <map>
#include <set>

#include <algorithm>

#include <httpext.h>
#include <wininet.h>

#include <comdef.h>

#define SAFEBSTR( bstr )  (bstr ? bstr : L"")
#define SAFEASTR( str )   (str  ? str  : "")
#define SAFEWSTR( str )   (str  ? str  : L"")

#define ARRAYSIZE( a )  (sizeof(a)/sizeof(*a))
#define MAXSTRLEN( a )  (ARRAYSIZE(a)-1)

#define SANITIZEASTR( str ) if(str == NULL) str = ""
#define SANITIZEWSTR( str ) if(str == NULL) str = L""

#define STRINGISPRESENT( str ) (str && str[0])

/////////////////////////////////////////////////////////////////////////

namespace MPC
{
    //
    // Non-reference counting version of std::basic_string, that is MT-safe.
    //
    typedef std::basic_stringNR<char   , std::char_traits<char>   , std::allocator<char>    >  string;
    typedef std::basic_stringNR<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > wstring;

    ////////////////////

    //
    // Auto-uppercase string classes, useful for quick maps and sets of strings (the conversion is done once).
    //
    class stringUC
    {
        MPC::string m_data;

        void Convert()
        {
            if(m_data.length()) ::CharUpperBuffA( (LPSTR)m_data.c_str(), m_data.size() );
        }

    public:
        stringUC()
        {
        }

        stringUC( const MPC::string& src )
        {
            m_data = src; Convert();
        }

        stringUC( LPCSTR src )
        {
            m_data = src; Convert();
        }

        stringUC& operator=( const MPC::string& src )
        {
            m_data = src; Convert();

            return *this;
        }

        stringUC& operator=( LPCSTR src )
        {
            m_data = src; Convert();

            return *this;
        }

        bool operator<( const stringUC& right ) const
        {
            return m_data < right.m_data;
        }

        bool operator==( const string& right ) const
        {
            return m_data == right;
        }

        operator string&()
        {
            return m_data;
        }

        operator const string&() const
        {
            return m_data;
        }

		LPCSTR c_str() const
		{
			return m_data.c_str();
		}
    };

    class wstringUC
    {
        MPC::wstring m_data;

        void Convert()
        {
            if(m_data.length()) ::CharUpperBuffW( (LPWSTR)m_data.c_str(), m_data.size() );
        }

    public:
        wstringUC()
        {
        }

        wstringUC( const MPC::wstring& src )
        {
            m_data = src; Convert();
        }

        wstringUC( LPCWSTR src )
        {
            m_data = src; Convert();
        }

        wstringUC& operator=( const MPC::wstring& src )
        {
            m_data = src; Convert();

            return *this;
        }

        wstringUC& operator=( LPCWSTR src )
        {
            m_data = src; Convert();

            return *this;
        }

        bool operator<( const wstringUC& right ) const
        {
            return m_data < right.m_data;
        }

        bool operator==( const wstring& right ) const
        {
            return m_data == right;
        }

        operator wstring&()
        {
            return m_data;
        }

        operator const wstring&() const
        {
            return m_data;
        }

		LPCWSTR c_str() const
		{
			return m_data.c_str();
		}
    };

    ////////////////////

    typedef std::list<MPC::string>                 StringList;
    typedef StringList::iterator                   StringIter;
    typedef StringList::const_iterator             StringIterConst;

    typedef std::list<MPC::wstring>                WStringList;
    typedef WStringList::iterator                  WStringIter;
    typedef WStringList::const_iterator            WStringIterConst;

    typedef std::list<MPC::stringUC>               StringUCList;
    typedef StringUCList::iterator                 StringUCIter;
    typedef StringUCList::const_iterator           StringUCIterConst;

    typedef std::list<MPC::wstringUC>              WStringUCList;
    typedef WStringUCList::iterator                WStringUCIter;
    typedef WStringUCList::const_iterator          WStringUCIterConst;

    ////////////////////

    class NocaseLess
    {
    public:
        bool operator()( /*[in]*/ const MPC::string& , /*[in]*/ const MPC::string&  ) const;
        bool operator()( /*[in]*/ const MPC::wstring&, /*[in]*/ const MPC::wstring& ) const;
        bool operator()( /*[in]*/ const BSTR         , /*[in]*/ const BSTR          ) const;
    };

    class NocaseCompare
    {
    public:
        bool operator()( /*[in]*/ const MPC::string& , /*[in]*/ const MPC::string&  ) const;
        bool operator()( /*[in]*/ const MPC::wstring&, /*[in]*/ const MPC::wstring& ) const;
        bool operator()( /*[in]*/ const BSTR         , /*[in]*/ const BSTR          ) const;
    };

    ////////////////////

    typedef std::vector<MPC::string>               StringVector;
    typedef StringVector::iterator                 StringVectorIter;
    typedef StringVector::const_iterator           StringVectorIterConst;

    typedef std::vector<MPC::wstring>              WStringVector;
    typedef WStringVector::iterator                WStringVectorIter;
    typedef WStringVector::const_iterator          WStringVectorIterConst;

    ////////////////////

    typedef std::set<MPC::string>                  StringSet;
    typedef StringSet::iterator                    StringSetIter;
    typedef StringSet::const_iterator              StringSetIterConst;

    typedef std::set<MPC::wstring>                 WStringSet;
    typedef WStringSet::iterator                   WStringSetIter;
    typedef WStringSet::const_iterator             WStringSetIterConst;

    typedef std::set<MPC::stringUC>                StringUCSet;
    typedef StringUCSet::iterator                  StringUCSetIter;
    typedef StringUCSet::const_iterator            StringUCSetIterConst;

    typedef std::set<MPC::wstringUC>               WStringUCSet;
    typedef WStringUCSet::iterator                 WStringUCSetIter;
    typedef WStringUCSet::const_iterator           WStringUCSetIterConst;

    typedef std::set<MPC::string,MPC::NocaseLess>  StringNocaseSet;
    typedef StringNocaseSet::iterator              StringNocaseSetIter;
    typedef StringNocaseSet::const_iterator        StringNocaseSetIterConst;

    typedef std::set<MPC::wstring,MPC::NocaseLess> WStringNocaseSet;
    typedef WStringNocaseSet::iterator             WStringNocaseSetIter;
    typedef WStringNocaseSet::const_iterator       WStringNocaseSetIterConst;

    ////////////////////

    typedef std::map<MPC::string,MPC::string>      StringLookup;
    typedef StringLookup::iterator                 StringLookupIter;
    typedef StringLookup::const_iterator           StringLookupIterConst;

    typedef std::map<MPC::wstring,MPC::wstring>    WStringLookup;
    typedef WStringLookup::iterator                WStringLookupIter;
    typedef WStringLookup::const_iterator          WStringLookupIterConst;

    typedef std::map<MPC::stringUC,MPC::string>    StringUCLookup;
    typedef StringUCLookup::iterator               StringUCLookupIter;
    typedef StringUCLookup::const_iterator         StringUCLookupIterConst;

    typedef std::map<MPC::wstringUC,MPC::wstring>  WStringUCLookup;
    typedef WStringUCLookup::iterator              WStringUCLookupIter;
    typedef WStringUCLookup::const_iterator        WStringUCLookupIterConst;

    ////////////////////

    typedef std::list< IDispatch* >                IDispatchList;
    typedef IDispatchList::iterator                IDispatchIter;
    typedef IDispatchList::const_iterator          IDispatchIterConst;

    /////////////////////////////////////////////////////////////////////////////

    template <class Src, class Dst> HRESULT CopyTo( Src* pSrc, Dst* *pVal )
    {
        if(!pVal) return E_POINTER;

        *pVal = pSrc; if(pSrc) pSrc->AddRef();

        return S_OK;
    }

    template <typename I, class Src, class Dst> HRESULT CopyTo2( Src* pSrc, Dst* *pVal )
    {
        if(!pVal) return E_POINTER;

        *pVal = pSrc; if(pSrc) ((I*)pSrc)->AddRef();

        return S_OK;
    }

    template <class T> void Release( T*& p )
    {
        if(p)
        {
            p->Release(); p = NULL;
        }
    }

    template <typename I, class T> void Release2( T*& p )
    {
        if(p)
        {
            ((I*)p)->Release(); p = NULL;
        }
    }

    template <class T> void Attach( T*& p, T* src )
    {
        if(src) src->AddRef ();
        if(p  ) p  ->Release();

        p = src;
    }

    template <class T> HRESULT CreateInstance( T** pp )
    {
        HRESULT hr;

        if(pp)
        {
            CComObject<T>* p = NULL;

            *pp = NULL;

            if(SUCCEEDED(hr = CComObject<T>::CreateInstance( &p )))
            {
                if(p)
                {
                    *pp = p; p->AddRef();
                }
                else
                {
                    hr = E_NOINTERFACE;
                }
            }
        }
        else
        {
            hr = E_POINTER;
        }

        return hr;
    }

    template <class T> HRESULT CreateInstanceCached( T** pp )
    {
        HRESULT hr;

        if(pp)
        {
            MPC::CComObjectCached<T>* p = NULL;

            *pp = NULL;

            if(SUCCEEDED(hr = MPC::CComObjectCached<T>::CreateInstance( &p )))
            {
                if(p)
                {
                    *pp = p; p->AddRef();
                }
                else
                {
                    hr = E_NOINTERFACE;
                }
            }
        }
        else
        {
            hr = E_POINTER;
        }

        return hr;
    }

    template <class T> HRESULT CreateInstanceNoLock( T** pp )
    {
        HRESULT hr;

        if(pp)
        {
            MPC::CComObjectNoLock<T>* p = NULL;

            *pp = NULL;

            if(SUCCEEDED(hr = MPC::CComObjectNoLock<T>::CreateInstance( &p )))
            {
                if(p)
                {
                    *pp = p; p->AddRef();
                }
                else
                {
                    hr = E_NOINTERFACE;
                }
            }
        }
        else
        {
            hr = E_POINTER;
        }

        return hr;
    }

    template <class T> void ReleaseAll( T& container )
    {
        T::const_iterator it;

        for(it = container.begin(); it != container.end(); it++)
        {
            (*it)->Release();
        }
        container.clear();
    }

    template <class T> void ReleaseAllVariant( T& container )
    {
        T::iterator it;

        for(it = container.begin(); it != container.end(); it++)
        {
            ::VariantClear( &(*it) );
        }
        container.clear();
    }

    template <class T> void CallDestructorForAll( T& container )
    {
        T::const_iterator it;

        for(it = container.begin(); it != container.end(); it++)
        {
            delete (*it);
        }
        container.clear();
    }

    /////////////////////////////////////////////////////////////////////////////

    typedef CAdapt<CComBSTR> CComBSTR_STL;

    template <class T> class CComPtr_STL : public CAdapt< CComPtr< T > >
    {
    };

}; // namespace

/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___MPC___MAIN_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\mpc_security.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    MPC_security.h

Abstract:
    This file contains the declaration of various security functions/classes.

Revision History:
    Davide Massarenti   (Dmassare)  04/26/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___MPC___SECURITY_H___)
#define __INCLUDED___MPC___SECURITY_H___

#include <MPC_main.h>
#include <MPC_utils.h>


#include <Ntsecapi.h>

//
// From #include <Ntstatus.h>  (including the file generates a lot of redefinition error with WINNT.H)
//
#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L) // ntsubauth
#define STATUS_OBJECT_NAME_NOT_FOUND     ((NTSTATUS)0xC0000034L)

#include <Lmaccess.h>
#include <Lmerr.h>
#include <Sddl.h>

#include <sspi.h>
#include <secext.h>

namespace MPC
{
    struct SID2
    {
        SID   m_main;
        DWORD m_SubAuthority2;

        operator SID&() { return m_main; }
    };

    class SecurityDescriptor
    {
    protected: // To enable other classes to extend the functionality.

        PSECURITY_DESCRIPTOR m_pSD;
        PSID                 m_pOwner;
        BOOL                 m_bOwnerDefaulted;
        PSID                 m_pGroup;
        BOOL                 m_bGroupDefaulted;
        PACL                 m_pDACL;
        BOOL                 m_bDaclDefaulted;
        PACL                 m_pSACL;
        BOOL                 m_bSaclDefaulted;

        ////////////////////////////////////////////////////////////////////////////////

    public:
        static const SID  s_EveryoneSid;
        static const SID  s_SystemSid;
        static const SID2 s_AdminSid;

        static const SID2 s_Alias_AdminsSid;
        static const SID2 s_Alias_PowerUsersSid;
        static const SID2 s_Alias_UsersSid;
        static const SID2 s_Alias_GuestsSid;


		static const SECURITY_INFORMATION s_SecInfo_ALL = OWNER_SECURITY_INFORMATION |
                                              		  	  GROUP_SECURITY_INFORMATION |
                                              		  	  DACL_SECURITY_INFORMATION  |
                                              		  	  SACL_SECURITY_INFORMATION  ;

		static const SECURITY_INFORMATION s_SecInfo_MOST = OWNER_SECURITY_INFORMATION |
                                              		  	   GROUP_SECURITY_INFORMATION |
                                              		  	   DACL_SECURITY_INFORMATION  ;

		static const SECURITY_DESCRIPTOR_CONTROL s_sdcMask = SE_DACL_AUTO_INHERIT_REQ |
                                                     		 SE_SACL_AUTO_INHERIT_REQ |
                                                     		 SE_DACL_AUTO_INHERITED   |
                                                     		 SE_SACL_AUTO_INHERITED   |
                                                     		 SE_DACL_PROTECTED        |
                                                     		 SE_SACL_PROTECTED        ;

        //
        // Any memory returned by this class should be release with ReleaseMemory( (void*&)<var> ).
        //
        static HRESULT AllocateMemory( /*[in/out]*/ LPVOID& ptr, /*[in]*/ size_t iLen );
        static void    ReleaseMemory ( /*[in/out]*/ LPVOID& ptr                       );

        static void    InitLsaString( /*[in/out]*/ LSA_UNICODE_STRING& lsaString, /*[in]*/ LPCWSTR szText );

        //
        // Utility functions.
        //
        static HRESULT SetPrivilege( /*[in]*/ LPCWSTR Privilege, /*[in]*/ BOOL bEnable = TRUE, /*[in]*/ HANDLE hToken = NULL );

        static HRESULT AddPrivilege   ( /*[in]*/ LPCWSTR szPrincipal, /*[in]*/ LPCWSTR szPrivilege );
        static HRESULT RemovePrivilege( /*[in]*/ LPCWSTR szPrincipal, /*[in]*/ LPCWSTR szPrivilege );

		////////////////////

        static HRESULT GetTokenSids  ( /*[in]*/ HANDLE hToken, /*[out]*/ PSID *ppUserSid, /*[out]*/ PSID *ppGroupSid                                           );
        static HRESULT GetProcessSids(                         /*[out]*/ PSID *ppUserSid, /*[out]*/ PSID *ppGroupSid = NULL                                    );
        static HRESULT GetThreadSids (                         /*[out]*/ PSID *ppUserSid, /*[out]*/ PSID *ppGroupSid = NULL, /*[in]*/ BOOL bOpenAsSelf = FALSE );

		////////////////////

        static HRESULT VerifyPrincipal      (                     /*[in ]*/ LPCWSTR 		szPrincipal                                                            );
        static HRESULT ConvertPrincipalToSID(                     /*[in ]*/ LPCWSTR 		szPrincipal, /*[out]*/ PSID& pSid, /*[out]*/ LPCWSTR *pszDomain = NULL );
        static HRESULT ConvertSIDToPrincipal( /*[in]*/ PSID pSid, /*[out]*/ LPCWSTR 	  *pszPrincipal                      , /*[out]*/ LPCWSTR *pszDomain = NULL );
        static HRESULT ConvertSIDToPrincipal( /*[in]*/ PSID pSid, /*[out]*/ MPC::wstring&  strPrincipal                                                            );

        static HRESULT NormalizePrincipalToStringSID( /*[in]*/ LPCWSTR szPrincipal, /*[in]*/ LPCWSTR szDomain, /*[out]*/ MPC::wstring& strSID );

		////////////////////

        static HRESULT GetAccountName       ( /*[in]*/ LPCWSTR szPrincipal, /*[out]*/ MPC::wstring& strName        );
        static HRESULT GetAccountDomain     ( /*[in]*/ LPCWSTR szPrincipal, /*[out]*/ MPC::wstring& strDomain      );
        static HRESULT GetAccountDisplayName( /*[in]*/ LPCWSTR szPrincipal, /*[out]*/ MPC::wstring& strDisplayName );

		////////////////////

        static HRESULT CloneACL( /*[in/out]*/ PACL& pDest, /*[in]*/ PACL pSrc );

        static HRESULT RemovePrincipalFromACL( /*[in    ]*/ PACL    pACL, /*[in]*/ PSID pPrincipalSID, /*[in]*/ int pos = -1 );
        static HRESULT AddACEToACL           ( /*[in/out]*/ PACL&   pACL, /*[in]*/ PSID pPrincipalSID,
                                               /*[in    ]*/ DWORD   dwAceType                      ,
                                               /*[in    ]*/ DWORD   dwAceFlags                     ,
                                               /*[in    ]*/ DWORD   dwAccessMask                   ,
                                               /*[in    ]*/ GUID*   guidObjectType          = NULL ,
                                               /*[in    ]*/ GUID*   guidInheritedObjectType = NULL );

        ////////////////////////////////////////////////////////////////////////////////

    private:
        static HRESULT CopyACL      ( /*[in    ]*/ PACL  pDest, /*[in]*/ PACL  pSrc     );
        static HRESULT EnsureACLSize( /*[in/out]*/ PACL& pACL , /*[in]*/ DWORD dwExpand );

        ////////////////////////////////////////////////////////////////////////////////

    public:
        SecurityDescriptor();
        virtual ~SecurityDescriptor();


        void    CleanUp                   (                                                                              );
        HRESULT Initialize                (                                                                              );
        HRESULT InitializeFromProcessToken( /*[in]*/ BOOL bDefaulted = FALSE                                             );
        HRESULT InitializeFromThreadToken ( /*[in]*/ BOOL bDefaulted = FALSE, /*[in]*/ BOOL bRevertToProcessToken = TRUE );


        HRESULT ConvertFromString( /*[in ]*/ LPCWSTR   szSD   );
        HRESULT ConvertToString  ( /*[out]*/ BSTR    *pbstrSD );

        ////////////////////

        HRESULT Attach      ( /*[in]*/ PSECURITY_DESCRIPTOR pSelfRelativeSD                                                         );
        HRESULT AttachObject( /*[in]*/ HANDLE               hObject        , /*[in]*/ SECURITY_INFORMATION secInfo = s_SecInfo_MOST );

        ////////////////////

        HRESULT GetControl( /*[out]*/ SECURITY_DESCRIPTOR_CONTROL& sdc );
        HRESULT SetControl( /*[in ]*/ SECURITY_DESCRIPTOR_CONTROL  sdc );

        HRESULT SetOwner( /*[in]*/ PSID    pOwnerSid  , /*[in]*/ BOOL bDefaulted = FALSE );
        HRESULT SetOwner( /*[in]*/ LPCWSTR szOwnerName, /*[in]*/ BOOL bDefaulted = FALSE );

        HRESULT SetGroup( /*[in]*/ PSID    pGroupSid  , /*[in]*/ BOOL bDefaulted = FALSE );
        HRESULT SetGroup( /*[in]*/ LPCWSTR szGroupName, /*[in]*/ BOOL bDefaulted = FALSE );

        ////////////////////

        HRESULT Remove( /*[in]*/ PSID    pPrincipalSid, /*[in]*/ int pos = -1 );
        HRESULT Remove( /*[in]*/ LPCWSTR szPrincipal  , /*[in]*/ int pos = -1 );

        HRESULT Add( /*[in]*/ PSID    pPrincipalSid                  ,
                     /*[in]*/ DWORD   dwAceType                      ,
                     /*[in]*/ DWORD   dwAceFlags                     ,
                     /*[in]*/ DWORD   dwAccessMask                   ,
                     /*[in]*/ GUID*   guidObjectType          = NULL ,
                     /*[in]*/ GUID*   guidInheritedObjectType = NULL );
        HRESULT Add( /*[in]*/ LPCWSTR szPrincipal                    ,
                     /*[in]*/ DWORD   dwAceType                      ,
                     /*[in]*/ DWORD   dwAceFlags                     ,
                     /*[in]*/ DWORD   dwAccessMask                   ,
                     /*[in]*/ GUID*   guidObjectType          = NULL ,
                     /*[in]*/ GUID*   guidInheritedObjectType = NULL );


        PSECURITY_DESCRIPTOR& GetSD   () { return m_pSD   ; }
        PSID&                 GetOwner() { return m_pOwner; }
        PSID&                 GetGroup() { return m_pGroup; }
        PACL&                 GetDACL () { return m_pDACL ; }
        PACL&                 GetSACL () { return m_pSACL ; }

		////////////////////////////////////////

		HRESULT GetForFile    ( /*[in]*/ LPCWSTR szFilename, /*[in]*/ SECURITY_INFORMATION secInfo                                );
		HRESULT SetForFile    ( /*[in]*/ LPCWSTR szFilename, /*[in]*/ SECURITY_INFORMATION secInfo                                );
		HRESULT GetForRegistry( /*[in]*/ LPCWSTR szKey     , /*[in]*/ SECURITY_INFORMATION secInfo, /*[in]*/ HKEY hKeyRoot = NULL );
		HRESULT SetForRegistry( /*[in]*/ LPCWSTR szKey     , /*[in]*/ SECURITY_INFORMATION secInfo, /*[in]*/ HKEY hKeyRoot = NULL );
    };

    ////////////////////////////////////////////////////////////////////////////////

    class Impersonation
    {
        HANDLE m_hToken;
        bool   m_fImpersonating;

        void Release();

    public:
        Impersonation();
        Impersonation( /*[in]*/ const Impersonation& imp );
        virtual ~Impersonation();

        Impersonation& operator=( /*[in]*/ const Impersonation& imp );


        HRESULT Initialize( /*[in]*/ DWORD dwDesiredAccess = TOKEN_QUERY | TOKEN_IMPERSONATE );
        void    Attach    ( /*[in]*/ HANDLE hToken                                           );
        HANDLE  Detach    (                                                                  );

        HRESULT Impersonate ();
        HRESULT RevertToSelf();

        operator HANDLE() { return m_hToken; }
    };

    ////////////////////////////////////////////////////////////////////////////////

    class AccessCheck
    {
        HANDLE m_hToken;

        void Release();

    public:
        AccessCheck();
        virtual ~AccessCheck();

        HRESULT GetTokenFromImpersonation(                        );
        void    Attach                   ( /*[in]*/ HANDLE hToken );
        HANDLE  Detach                   (                        );

        HRESULT Verify( /*[in]*/ DWORD dwDesired, /*[out]*/ BOOL& fGranted, /*[out]*/ DWORD& dwGranted, /*[in]*/ PSECURITY_DESCRIPTOR     sd );
        HRESULT Verify( /*[in]*/ DWORD dwDesired, /*[out]*/ BOOL& fGranted, /*[out]*/ DWORD& dwGranted, /*[in]*/ MPC::SecurityDescriptor& sd );
        HRESULT Verify( /*[in]*/ DWORD dwDesired, /*[out]*/ BOOL& fGranted, /*[out]*/ DWORD& dwGranted, /*[in]*/ LPCWSTR                  sd );
    };

    ////////////////////////////////////////////////////////////////////////////////

    HRESULT ChangeSD( /*[in]*/ MPC::SecurityDescriptor& sdd                                                                    ,
                      /*[in]*/ MPC::FileSystemObject&   fso                                                                    ,
					  /*[in]*/ SECURITY_INFORMATION     secInfo       = GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION ,
                      /*[in]*/ bool                     fDeep         = true                                                   ,
                      /*[in]*/ bool                     fApplyToDirs  = true                                                   ,
                      /*[in]*/ bool                     fApplyToFiles = true                                                   );

    HRESULT ChangeSD( /*[in]*/ MPC::SecurityDescriptor& sdd                                                                    ,
                      /*[in]*/ LPCWSTR                  szRoot                                                                 ,
					  /*[in]*/ SECURITY_INFORMATION     secInfo       = GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION ,
                      /*[in]*/ bool                     fDeep         = true                                                   ,
                      /*[in]*/ bool                     fApplyToDirs  = true                                                   ,
                      /*[in]*/ bool                     fApplyToFiles = true                                                   );

    ////////////////////////////////////////////////////////////////////////////////

	static const DWORD IDENTITY_SYSTEM 	   = 0x00000001;
	static const DWORD IDENTITY_ADMIN  	   = 0x00000002;
	static const DWORD IDENTITY_ADMINS 	   = 0x00000004;
	static const DWORD IDENTITY_POWERUSERS = 0x00000008;
	static const DWORD IDENTITY_USERS      = 0x00000010;
	static const DWORD IDENTITY_GUESTS     = 0x00000020;

    HRESULT GetCallerPrincipal         ( /*[in]*/ bool fImpersonate, /*[out]*/ CComBSTR& bstrUser, /*[out]*/ DWORD *pdwAllowedIdentity = NULL );
    HRESULT CheckCallerAgainstPrincipal( /*[in]*/ bool fImpersonate, /*[out]*/ BSTR      bstrUser, /*[in ]*/ DWORD   dwAllowedIdentity = 0    );

    ////////////////////////////////////////////////////////////////////////////////

    HRESULT GetInterfaceSecurity( /*[in ]*/ IUnknown*                 pUnk             ,
                                  /*[out]*/ DWORD                    *pAuthnSvc        ,
                                  /*[out]*/ DWORD                    *pAuthzSvc        ,
                                  /*[out]*/ OLECHAR*                 *pServerPrincName ,
                                  /*[out]*/ DWORD                    *pAuthnLevel      ,
                                  /*[out]*/ DWORD                    *pImpLevel        ,
                                  /*[out]*/ RPC_AUTH_IDENTITY_HANDLE *pAuthInfo        ,
                                  /*[out]*/ DWORD                    *pCapabilities    );


    HRESULT SetInterfaceSecurity( /*[in]*/ IUnknown*                 pUnk             ,
                                  /*[in]*/ DWORD                    *pAuthnSvc        ,
                                  /*[in]*/ DWORD                    *pAuthzSvc        ,
                                  /*[in]*/ OLECHAR*                  pServerPrincName ,
                                  /*[in]*/ DWORD                    *pAuthnLevel      ,
                                  /*[in]*/ DWORD                    *pImpLevel        ,
                                  /*[in]*/ RPC_AUTH_IDENTITY_HANDLE *pAuthInfo        ,
                                  /*[in]*/ DWORD                    *pCapabilities    );

    HRESULT SetInterfaceSecurity_ImpLevel( /*[in]*/ IUnknown* pUnk     ,
                                           /*[in]*/ DWORD     ImpLevel );
};

////////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___MPC___SECURITY_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\mpc_streams.h ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    MPC_streams.h

Abstract:
    This file includes and defines things for handling streams.

Revision History:
    Davide Massarenti   (Dmassare)  07/10/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___MPC___STREAMS_H___)
#define __INCLUDED___MPC___STREAMS_H___

#include <MPC_main.h>
#include <MPC_COM.h>

#include <set>

/////////////////////////////////////////////////////////////////////////

namespace MPC
{
	//
	// Some forward declarations...
	//
	class CComHGLOBAL;

	////////////////////

    //
    // Non-abstract class, meant to provide a do-nothing stub for real stream implementations.
    //
    class BaseStream : public IStream
    {
    public:
        /////////////////////////////////////////////////////////////////////////////
        //
        // ISequentialStream Interface
        //
        STDMETHOD(Read )( /*[out]*/       void* pv, /*[in]*/ ULONG cb, /*[out]*/ ULONG *pcbRead    );
        STDMETHOD(Write)( /*[in] */ const void* pv, /*[in]*/ ULONG cb, /*[out]*/ ULONG *pcbWritten );

        /////////////////////////////////////////////////////////////////////////////
        //
        // IStream Interface
        //
        STDMETHOD(Seek   )( /*[in]*/ LARGE_INTEGER  libMove   , /*[in]*/ DWORD dwOrigin, /*[out]*/ ULARGE_INTEGER *plibNewPosition );
        STDMETHOD(SetSize)( /*[in]*/ ULARGE_INTEGER libNewSize                                                                     );

        STDMETHOD(CopyTo)( /*[in]*/ IStream* pstm, /*[in]*/ ULARGE_INTEGER cb, /*[out]*/ ULARGE_INTEGER *pcbRead, /*[out]*/ ULARGE_INTEGER *pcbWritten );

        STDMETHOD(Commit)( /*[in]*/ DWORD grfCommitFlags );
        STDMETHOD(Revert)(                               );

        STDMETHOD(LockRegion  )( /*[in]*/ ULARGE_INTEGER libOffset, /*[in]*/ ULARGE_INTEGER cb, /*[in]*/ DWORD dwLockType );
        STDMETHOD(UnlockRegion)( /*[in]*/ ULARGE_INTEGER libOffset, /*[in]*/ ULARGE_INTEGER cb, /*[in]*/ DWORD dwLockType );

        STDMETHOD(Stat)( /*[out]*/ STATSTG *pstatstg, /*[in]*/ DWORD grfStatFlag);

        STDMETHOD(Clone)( /*[out]*/ IStream* *ppstm );


        static HRESULT TransferData( /*[in]*/ IStream* src, /*[in]*/ IStream* dst, /*[in]*/ ULONG ulCount = -1, /*[out]*/ ULONG *ulDone = NULL );
    };


    //
    // Class that wraps files around an IStream interface.
    //
    class ATL_NO_VTABLE FileStream : // Hungarian: hpcfs
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
        public BaseStream
    {
        MPC::wstring m_szFile;
        DWORD        m_dwDesiredAccess;
        DWORD        m_dwDisposition;
        DWORD        m_dwSharing;
        HANDLE       m_hfFile;
        bool         m_fDeleteOnRelease;

    public:

        BEGIN_COM_MAP(FileStream)
            COM_INTERFACE_ENTRY(IStream)
            COM_INTERFACE_ENTRY(ISequentialStream)
        END_COM_MAP()

        FileStream();
        virtual ~FileStream();

        HRESULT Close();

        HRESULT Init            ( /*[in]*/ LPCWSTR szFile, /*[in]*/ DWORD dwDesiredAccess, /*[in]*/ DWORD dwDisposition, /*[in]*/ DWORD dwSharing, /*[in]*/ HANDLE  hfFile = NULL );
        HRESULT InitForRead     ( /*[in]*/ LPCWSTR szFile,                                                                                         /*[in]*/ HANDLE  hfFile = NULL );
        HRESULT InitForReadWrite( /*[in]*/ LPCWSTR szFile,                                                                                         /*[in]*/ HANDLE  hfFile = NULL );
        HRESULT InitForWrite    ( /*[in]*/ LPCWSTR szFile,                                                                                         /*[in]*/ HANDLE  hfFile = NULL );

        HRESULT DeleteOnRelease( /*[in]*/ bool fFlag = true );

        /////////////////////////////////////////////////////////////////////////////
        //
        // ISequentialStream Interface
        //
        STDMETHOD(Read )( /*[out]*/       void* pv, /*[in]*/ ULONG cb, /*[out]*/ ULONG *pcbRead    );
        STDMETHOD(Write)( /*[in] */ const void* pv, /*[in]*/ ULONG cb, /*[out]*/ ULONG *pcbWritten );

        /////////////////////////////////////////////////////////////////////////////
        //
        // IStream Interface
        //
        STDMETHOD(Seek)( /*[in]*/ LARGE_INTEGER libMove, /*[in]*/ DWORD dwOrigin, /*[out]*/ ULARGE_INTEGER *plibNewPosition );

        STDMETHOD(Stat)( /*[out]*/ STATSTG *pstatstg, /*[in]*/ DWORD grfStatFlag);

        STDMETHOD(Clone)( /*[out]*/ IStream* *ppstm );
    };


    //
    // Class that encrypts/decrypts data on-the-fly.
    //
    class ATL_NO_VTABLE EncryptedStream : // Hungarian: hpcefs
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
        public BaseStream
    {
        CComPtr<IStream> m_pStream;
        HCRYPTPROV       m_hCryptProv;
        HCRYPTKEY        m_hKey;
        HCRYPTHASH       m_hHash;
        BYTE             m_rgDecrypted[512];
        DWORD            m_dwDecryptedPos;
        DWORD            m_dwDecryptedLen;

    public:
        BEGIN_COM_MAP(EncryptedStream)
            COM_INTERFACE_ENTRY(IStream)
            COM_INTERFACE_ENTRY(ISequentialStream)
        END_COM_MAP()

        EncryptedStream();
        virtual ~EncryptedStream();


        HRESULT Close();

        HRESULT Init( /*[in]*/ IStream* pStream, /*[in]*/ LPCWSTR   szPassword );
        HRESULT Init( /*[in]*/ IStream* pStream, /*[in]*/ HCRYPTKEY hKey       );

        /////////////////////////////////////////////////////////////////////////////
        //
        // ISequentialStream Interface
        //
        STDMETHOD(Read )( /*[out]*/       void* pv, /*[in]*/ ULONG cb, /*[out]*/ ULONG *pcbRead    );
        STDMETHOD(Write)( /*[in] */ const void* pv, /*[in]*/ ULONG cb, /*[out]*/ ULONG *pcbWritten );

        /////////////////////////////////////////////////////////////////////////////
        //
        // IStream Interface
        //
        STDMETHOD(Seek)( /*[in]*/ LARGE_INTEGER libMove, /*[in]*/ DWORD dwOrigin, /*[out]*/ ULARGE_INTEGER *plibNewPosition );

        STDMETHOD(Stat)( /*[out]*/ STATSTG *pstatstg, /*[in]*/ DWORD grfStatFlag);

        STDMETHOD(Clone)( /*[out]*/ IStream* *ppstm );
    };

    ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////

    class Serializer // Hungarian: stream
    {
        DWORD m_dwFlags;

    public:
        virtual ~Serializer() {};

        virtual HRESULT read ( /*[in]*/       void* pBuf, /*[in]*/ DWORD dwLen, /*[out]*/ DWORD* dwRead = NULL ) = 0;
        virtual HRESULT write( /*[in]*/ const void* pBuf, /*[in]*/ DWORD dwLen                                 ) = 0;

        virtual void  put_Flags( /*[in]*/ DWORD dwFlags ) { m_dwFlags = dwFlags; }
        virtual DWORD get_Flags(                        ) { return m_dwFlags;    }

        ////////////////////////////////////////

        //
        // We cannot rely on the compiler finding the right method,
        // since all these types map to VOID*, so the last one wins...
        //
        inline HRESULT HWND_read ( /*[out]*/       HWND& val ) { return read ( &val, sizeof(val) ); }
        inline HRESULT HWND_write( /*[in] */ const HWND& val ) { return write( &val, sizeof(val) ); }

        ////////////////////////////////////////////////////////////////////////////////

        //
        // Specialization of In/Out operators for various data types.
        //
		inline HRESULT operator>>( /*[out]*/       bool&         val ) { return read ( &val, sizeof(val) ); }
		inline HRESULT operator<<( /*[in] */ const bool&         val ) { return write( &val, sizeof(val) ); }

		inline HRESULT operator>>( /*[out]*/       VARIANT_BOOL& val ) { return read ( &val, sizeof(val) ); }
		inline HRESULT operator<<( /*[in] */ const VARIANT_BOOL& val ) { return write( &val, sizeof(val) ); }

		inline HRESULT operator>>( /*[out]*/       int&          val ) { return read ( &val, sizeof(val) ); }
		inline HRESULT operator<<( /*[in] */ const int&          val ) { return write( &val, sizeof(val) ); }

		inline HRESULT operator>>( /*[out]*/       long&         val ) { return read ( &val, sizeof(val) ); }
		inline HRESULT operator<<( /*[in] */ const long&         val ) { return write( &val, sizeof(val) ); }

		inline HRESULT operator>>( /*[out]*/       DWORD&        val ) { return read ( &val, sizeof(val) ); }
		inline HRESULT operator<<( /*[in] */ const DWORD&        val ) { return write( &val, sizeof(val) ); }

		inline HRESULT operator>>( /*[out]*/       DATE&         val ) { return read ( &val, sizeof(val) ); }
		inline HRESULT operator<<( /*[in] */ const DATE&         val ) { return write( &val, sizeof(val) ); }

		inline HRESULT operator>>( /*[out]*/       SYSTEMTIME&   val ) { return read ( &val, sizeof(val) ); }
		inline HRESULT operator<<( /*[in] */ const SYSTEMTIME&   val ) { return write( &val, sizeof(val) ); }

		inline HRESULT operator>>( /*[out]*/       CLSID&        val ) { return read ( &val, sizeof(val) ); }
		inline HRESULT operator<<( /*[in] */ const CLSID&        val ) { return write( &val, sizeof(val) ); }
								   												
		HRESULT operator>>( /*[out]*/       MPC::string&  val );
		HRESULT operator<<( /*[in] */ const MPC::string&  val );
								   												
		HRESULT operator>>( /*[out]*/       MPC::wstring& val );
		HRESULT operator<<( /*[in] */ const MPC::wstring& val );
								   
		HRESULT operator>>( /*[out]*/       CComBSTR& 	  val );
		HRESULT operator<<( /*[in] */ const CComBSTR& 	  val );

		HRESULT operator>>( /*[out]*/ 		CComHGLOBAL&  val );
		HRESULT operator<<( /*[in] */ const CComHGLOBAL&  val );

		HRESULT operator>>( /*[out]*/ CComPtr<IStream>&	  val );
		HRESULT operator<<( /*[in] */         IStream* 	  val );
    };

    ////////////////////////////////////////

    class Serializer_File : public Serializer
    {
        HANDLE m_hfFile;

        //////////////////////////////////////////////////////////////////

    public:
        Serializer_File( /*[in]*/ HANDLE hfFile );

        virtual HRESULT read ( /*[in]*/       void* pBuf, /*[in]*/ DWORD dwLen, /*[out]*/ DWORD* dwRead = NULL );
        virtual HRESULT write( /*[in]*/ const void* pBuf, /*[in]*/ DWORD dwLen                                 );
    };

    ////////////////////////////////////////

    class Serializer_Text : public Serializer
    {
        MPC::Serializer& m_stream;

    public:
        Serializer_Text( /*[in]*/ Serializer& stream ) : m_stream( stream ) {}

        virtual HRESULT read ( /*[in]*/       void* pBuf, /*[in]*/ DWORD dwLen, /*[out]*/ DWORD* dwRead = NULL );
        virtual HRESULT write( /*[in]*/ const void* pBuf, /*[in]*/ DWORD dwLen                                 );
    };

    ////////////////////////////////////////

    class Serializer_Http : public Serializer
    {
        HINTERNET m_hReq;

    public:
        Serializer_Http( HINTERNET hReq );

        virtual HRESULT read ( /*[in]*/       void* pBuf, /*[in]*/ DWORD dwLen, /*[out]*/ DWORD* dwRead = NULL );
        virtual HRESULT write( /*[in]*/ const void* pBuf, /*[in]*/ DWORD dwLen                                 );
    };

    ////////////////////////////////////////

    class Serializer_Fake : public Serializer
    {
        DWORD m_dwSize;

    public:
        Serializer_Fake();

        virtual HRESULT read ( /*[in]*/       void* pBuf, /*[in]*/ DWORD dwLen, /*[out]*/ DWORD* dwRead = NULL );
        virtual HRESULT write( /*[in]*/ const void* pBuf, /*[in]*/ DWORD dwLen                                 );

        /////////////////////////////////////////////////////////////////////////////
        //
        // Additional methods.
        //
        DWORD GetSize();
    };

    ////////////////////////////////////////

    class Serializer_Memory : public Serializer
    {
        HANDLE m_hHeap;

        BYTE*  m_pData;
        DWORD  m_dwAllocated;
        DWORD  m_dwSize;
        bool   m_fFixed;

        DWORD  m_dwCursor_Write;
        DWORD  m_dwCursor_Read;

        //////////////////////////////////////////////////////////////////

        HRESULT Alloc( /*[in]*/ DWORD dwSize );

        //////////////////////////////////////////////////////////////////

    public:
        Serializer_Memory( HANDLE hHeap=NULL );
        virtual ~Serializer_Memory();

        virtual HRESULT read ( /*[in]*/       void* pBuf, /*[in]*/ DWORD dwLen, /*[out]*/ DWORD* dwRead = NULL );
        virtual HRESULT write( /*[in]*/ const void* pBuf, /*[in]*/ DWORD dwLen                                 );

        /////////////////////////////////////////////////////////////////////////////
        //
        // Additional methods.
        //
        void    Reset ();
        void    Rewind();

        bool    IsEOR();
        bool    IsEOW();

        DWORD   GetAvailableForRead ();
        DWORD   GetAvailableForWrite();

        HRESULT SetSize( /*[in]*/ DWORD dwSize );
        DWORD   GetSize(                       );
        BYTE*   GetData(                       );
    };

    ////////////////////////////////////////

    class Serializer_IStream : public Serializer
    {
        CComPtr<IStream> m_stream;

        //////////////////////////////////////////////////////////////////

    public:
        Serializer_IStream( /*[in]*/ IStream* stream = NULL );

        virtual HRESULT read ( /*[in]*/       void* pBuf, /*[in]*/ DWORD dwLen, /*[out]*/ DWORD* dwRead = NULL );
        virtual HRESULT write( /*[in]*/ const void* pBuf, /*[in]*/ DWORD dwLen                                 );

        /////////////////////////////////////////////////////////////////////////////
        //
        // Additional methods.
        //
        HRESULT Reset    (                          );
        HRESULT GetStream( /*[out]*/ IStream* *pVal );
    };

    ////////////////////////////////////////

    class Serializer_Buffering : public Serializer
    {
        static const int MODE_READ  =  1;
        static const int MODE_WRITE = -1;

        MPC::Serializer& m_stream;
        BYTE             m_rgTransitBuffer[1024];
        DWORD            m_dwAvailable;
        DWORD            m_dwPos;
        int              m_iMode;

        //////////////////////////////////////////////////////////////////

    public:
        Serializer_Buffering( /*[in]*/ Serializer& stream );
        virtual ~Serializer_Buffering();

        virtual HRESULT read ( /*[in]*/       void* pBuf, /*[in]*/ DWORD dwLen, /*[out]*/ DWORD* dwRead = NULL );
        virtual HRESULT write( /*[in]*/ const void* pBuf, /*[in]*/ DWORD dwLen                                 );

        /////////////////////////////////////////////////////////////////////////////
        //
        // Additional methods.
        //
        HRESULT Reset();
        HRESULT Flush();
    };

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Specialization for lists.
    //

    template <class _Ty, class _A> HRESULT operator>>( /*[in]*/ Serializer& stream, /*[out]*/ std::list<_Ty, _A>& val )
    {
        __MPC_FUNC_ENTRY( COMMONID, "operator>> std::list" );

        HRESULT hr;
        DWORD   dwCount;


        val.clear();


        __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> dwCount);
        while(dwCount--)
        {
            _Ty value;

            __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> value);

            val.push_back( value );
        }

        hr = S_OK;


        __MPC_FUNC_CLEANUP;

        __MPC_FUNC_EXIT(hr);
    }

    template <class _Ty, class _A> HRESULT operator<<( /*[in]*/ Serializer& stream, /*[in]*/ const std::list<_Ty, _A>& val )
    {
        __MPC_FUNC_ENTRY( COMMONID, "operator<< std::list" );

        HRESULT                      hr;
        DWORD                        dwCount = val.size();
        std::list<_Ty, _A>::iterator it      = val.begin();


        __MPC_EXIT_IF_METHOD_FAILS(hr, stream << dwCount);
        while(dwCount--)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, stream << (*it++));
        }

        hr = S_OK;


        __MPC_FUNC_CLEANUP;

        __MPC_FUNC_EXIT(hr);
    }

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Specialization for maps.
    //

    template <class _K, class _Ty, class _Pr, class _A> HRESULT operator>>( /*[in]*/ Serializer& stream, /*[out]*/ std::map<_K, _Ty, _Pr, _A>& val )
    {
        __MPC_FUNC_ENTRY( COMMONID, "operator>> std::map" );

        HRESULT hr;
        DWORD   dwCount;


        val.clear();


        __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> dwCount);
        while(dwCount--)
        {
            _K key;

            __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> key);
            {
                _Ty value;

                __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> value);

                val[key] = value;
            }
        }

        hr = S_OK;


        __MPC_FUNC_CLEANUP;

        __MPC_FUNC_EXIT(hr);
    }

    template <class _K, class _Ty, class _Pr, class _A> HRESULT operator<<( /*[in]*/ Serializer& stream, /*[out]*/ const std::map<_K, _Ty, _Pr, _A>& val )
    {
        __MPC_FUNC_ENTRY( COMMONID, "operator<< std::map" );

        HRESULT                              hr;
        DWORD                                dwCount = val.size();
        std::map<_K, _Ty, _Pr, _A>::iterator it      = val.begin();


        __MPC_EXIT_IF_METHOD_FAILS(hr, stream << dwCount);
        while(dwCount--)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, stream <<  it   ->first );
            __MPC_EXIT_IF_METHOD_FAILS(hr, stream << (it++)->second);
        }

        hr = S_OK;


        __MPC_FUNC_CLEANUP;

        __MPC_FUNC_EXIT(hr);
    }

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Specialization for sets.
    //

    template <class _K, class _Pr, class _A> HRESULT operator>>( /*[in]*/ Serializer& stream, /*[out]*/ std::set<_K, _Pr, _A>& val )
    {
        __MPC_FUNC_ENTRY( COMMONID, "operator>> std::map" );

        HRESULT hr;
        DWORD   dwCount;


        val.clear();


        __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> dwCount);
        while(dwCount--)
        {
            _K key;

            __MPC_EXIT_IF_METHOD_FAILS(hr, stream >> key);

            val.insert( key );
        }

        hr = S_OK;


        __MPC_FUNC_CLEANUP;

        __MPC_FUNC_EXIT(hr);
    }

    template <class _K, class _Pr, class _A> HRESULT operator<<( /*[in]*/ Serializer& stream, /*[out]*/ const std::set<_K, _Pr, _A>& val )
    {
        __MPC_FUNC_ENTRY( COMMONID, "operator<< std::map" );

        HRESULT                         hr;
        DWORD                           dwCount = val.size();
        std::set<_K, _Pr, _A>::iterator it      = val.begin();


        __MPC_EXIT_IF_METHOD_FAILS(hr, stream << dwCount);
        while(dwCount--)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, stream << *it++);
        }

        hr = S_OK;


        __MPC_FUNC_CLEANUP;

        __MPC_FUNC_EXIT(hr);
    }

}; // namespace

/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___MPC___STREAMS_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\mpc_trace.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    MPC_trace.h

Abstract:
    This file contains the declaration of Tracing Macros for the MPC project.

Revision History:
    Davide Massarenti   (Dmassare)  05/08/99
        created

******************************************************************************/

#if !defined(__INCLUDED___MPC___TRACE_H___)
#define __INCLUDED___MPC___TRACE_H___

/////////////////////////////////////////////////////////////////////////

//
// We don't want tracing for RETAIL bits.
//
#ifndef DEBUG
#undef  NOTRACE
#define NOTRACE
#endif

#include <dbgtrace.h>
#include <traceids.h>

#define __MPC_PROTECT(x) try { x;} catch(...) {}
#define __MPC_PROTECT_HR(hr,x) try { x;} catch(...) { hr = HRESULT_FROM_WIN32(ERROR_EXCEPTION_IN_SERVICE); }

#define __MPC_TRY_BEGIN() try {
#define __MPC_TRY_CATCHALL(hr) } catch(...) { hr = HRESULT_FROM_WIN32(ERROR_EXCEPTION_IN_SERVICE); }


#ifndef NOTRACE

#define __MPC_TRACE_INIT() InitAsyncTrace()
#define __MPC_TRACE_TERM() TermAsyncTrace()

#define __MPC_FUNC_ENTRY(id,x) __MPC_TraceEntry __te(id,x,__FILE__);
#define __MPC_FUNC_LEAVE                      { __te.Leave( __LINE__ ); goto __func_cleanup; }
#define __MPC_FUNC_CLEANUP     __func_cleanup:  __te.Cleanup()
#define __MPC_FUNC_EXIT(x)                    { __te.Return( __LINE__ ); return x; }


#define __MPC_TRACE_HRESULT(hr) __te.FormatError(hr,__LINE__)


#define __MPC_TRACE_FATAL !(__dwEnabledTraces & FATAL_TRACE_MASK) ?   \
                          (void)0 :                                   \
                          SetAsyncTraceParams( __te.pszFileName, __LINE__, __te.pszFunctionName, FATAL_TRACE_MASK ) && \
                          PreAsyncTrace

#define __MPC_TRACE_ERROR !(__dwEnabledTraces & ERROR_TRACE_MASK) ?   \
                          (void)0 :                                   \
                          SetAsyncTraceParams( __te.pszFileName, __LINE__, __te.pszFunctionName, ERROR_TRACE_MASK ) && \
                          PreAsyncTrace

#define __MPC_TRACE_DEBUG !(__dwEnabledTraces & DEBUG_TRACE_MASK) ?   \
                          (void)0 :                                   \
                          SetAsyncTraceParams( __te.pszFileName, __LINE__, __te.pszFunctionName, DEBUG_TRACE_MASK ) && \
                          PreAsyncTrace

#define __MPC_TRACE_STATE !(__dwEnabledTraces & STATE_TRACE_MASK) ?   \
                          (void)0 :                                   \
                          SetAsyncTraceParams( __te.pszFileName, __LINE__, __te.pszFunctionName, STATE_TRACE_MASK ) && \
                          PreAsyncTrace

#define __MPC_TRACE_FUNCT !(__dwEnabledTraces & FUNCT_TRACE_MASK) ?   \
                          (void)0 :                                   \
                          SetAsyncTraceParams( pszFileName, __LINE__, pszFunctionName, FUNCT_TRACE_MASK ) && \
                          PreAsyncTrace


class __MPC_TraceEntry
{
public:
    LPARAM id;
    LPCSTR pszFunctionName;
    LPCSTR pszFileName;

    __inline __MPC_TraceEntry( LPARAM id, LPCSTR pszFunc, LPCSTR pszFile )
    {
        this->id              = id;
        this->pszFunctionName = pszFunc;
        this->pszFileName     = pszFile;

        __MPC_TRACE_FUNCT( id, "%s : Entering", (LPSTR)pszFunctionName );
    }

    __inline ~__MPC_TraceEntry()
    {
        __MPC_TRACE_FUNCT( id, "%s : Exiting", pszFunctionName );
    }

    __inline void Leave( DWORD line )
    {
        __MPC_TRACE_FUNCT( id, "%s : Leaving from line %d", pszFunctionName, line );
    }

    __inline void Return( DWORD line )
    {
        __MPC_TRACE_FUNCT( id, "%s : Returning from line %d", pszFunctionName, line );
    }

    void FormatError( HRESULT hr, DWORD line )
    {
        __MPC_TraceEntry& __te = *this;

        if(SUCCEEDED(hr)) return; // Not logging on success.

        if(HRESULT_FACILITY(hr) == FACILITY_WIN32)
        {
			CHAR rgMsgBuf[512];

            if(::FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM     |
								 FORMAT_MESSAGE_IGNORE_INSERTS,
								 NULL,
								 HRESULT_CODE(hr),
								 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
								 rgMsgBuf,
								 (sizeof(rgMsgBuf)/sizeof(*rgMsgBuf))-1,
								 NULL ))
            {
                __MPC_TRACE_ERROR( id, "Got unexpected WIN32 error at line %d: %08x %s", line, hr, rgMsgBuf );
                return;
            }
        }

        __MPC_TRACE_ERROR( id, "Got unexpected HRESULT failure at line %d: %08x", line, hr );
    }

    __inline void Cleanup()
    {
        __MPC_TRACE_FUNCT( id, "%s : Cleaning up", pszFunctionName );
    }
};


#else

#define __MPC_TRACE_INIT()
#define __MPC_TRACE_TERM()

#define __MPC_FUNC_ENTRY(id,x)
#define __MPC_FUNC_LEAVE      goto __func_cleanup
#define __MPC_FUNC_CLEANUP         __func_cleanup:
#define __MPC_FUNC_EXIT(x)    return x


#define __MPC_TRACE_HRESULT(hr) (void)0


#define __MPC_TRACE_FATAL  1 ? (void)0 : PreAsyncTrace
#define __MPC_TRACE_ERROR  1 ? (void)0 : PreAsyncTrace
#define __MPC_TRACE_DEBUG  1 ? (void)0 : PreAsyncTrace
#define __MPC_TRACE_STATE  1 ? (void)0 : PreAsyncTrace
#define __MPC_TRACE_FUNCT  1 ? (void)0 : PreAsyncTrace

#endif


#define __MPC_EXIT_IF_METHOD_FAILS(hr,x)        { if(FAILED(hr=x))           { __MPC_TRACE_HRESULT(hr); __MPC_FUNC_LEAVE; } }
#define __MPC_EXIT_IF_SYSCALL_FAILS(hr,res,x)   { if(ERROR_SUCCESS!=(res=x)) { __MPC_SET_WIN32_ERROR_AND_EXIT(hr, res);   } }

#define __MPC_EXIT_IF_CALL_RETURNS_THISVALUE(hr,x,y)	  	 { if((x)==y) { __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::GetLastError());  } }
#define __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr,x)  		  	 __MPC_EXIT_IF_CALL_RETURNS_THISVALUE(hr,x,FALSE)
#define __MPC_EXIT_IF_CALL_RETURNS_NULL(hr,x)   		  	 __MPC_EXIT_IF_CALL_RETURNS_THISVALUE(hr,x,NULL)
#define __MPC_EXIT_IF_CALL_RETURNS_ZERO(hr,x)   		  	 __MPC_EXIT_IF_CALL_RETURNS_THISVALUE(hr,x,0)

#define __MPC_EXIT_IF_ALLOC_FAILS(hr,var,x)           { if((var = (x)) == NULL) { __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY ); } }

#define __MPC_EXIT_IF_INVALID_HANDLE(hr,var,x)        { if((var = (x)) == INVALID_HANDLE_VALUE) {             __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::GetLastError() ); } }
#define __MPC_EXIT_IF_INVALID_HANDLE__CLEAN(hr,var,x) { if((var = (x)) == INVALID_HANDLE_VALUE) { var = NULL; __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::GetLastError() ); } }


#define __MPC_SET_ERROR_AND_EXIT(hr, err)       { hr = err; __MPC_TRACE_HRESULT(hr); __MPC_FUNC_LEAVE; }
#define __MPC_SET_WIN32_ERROR_AND_EXIT(hr, res) __MPC_SET_ERROR_AND_EXIT(hr, HRESULT_FROM_WIN32(res))


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


#define __MPC_PARAMCHECK_BEGIN(hr)                   \
{                                                    \
    HRESULT& hrOuter = hr;                           \
    HRESULT  hrInner = S_OK;

#define __MPC_PARAMCHECK_POINTER(ptr)                \
    {                                                \
        _ASSERTE(ptr != NULL);                       \
        if(ptr == NULL)                              \
        {                                            \
            hrInner = E_POINTER;                     \
        }                                            \
    }

#define __MPC_PARAMCHECK_POINTER_AND_SET(ptr,val)    \
    {                                                \
        _ASSERTE(ptr != NULL);                       \
        if(ptr == NULL)                              \
        {                                            \
            hrInner = E_POINTER;                     \
        }                                            \
        else                                         \
        {                                            \
            *ptr = val;                              \
        }                                            \
    }

#define __MPC_PARAMCHECK_NOTNULL(ptr)                \
    {                                                \
        _ASSERTE(ptr != NULL);                       \
        if(ptr == NULL)                              \
        {                                            \
            hrInner = E_INVALIDARG;                  \
        }                                            \
    }

#define __MPC_PARAMCHECK_STRING_NOT_EMPTY(ptr)       \
    {                                                \
        _ASSERTE(ptr != NULL && ptr[0] != 0);        \
        if(ptr == NULL || ptr[0] == 0)               \
        {                                            \
            hrInner = E_INVALIDARG;                  \
        }                                            \
    }

#define __MPC_PARAMCHECK_END()                       \
    { __MPC_EXIT_IF_METHOD_FAILS(hrOuter,hrInner); } \
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#define __MPC_BEGIN_PROPERTY_GET0(id,func,hr,pVal)                 \
    __MPC_FUNC_ENTRY( id, func );                                  \
                                                                   \
    HRESULT                      hr;                               \
    MPC::SmartLock<_ThreadModel> lock( this );                     \
                                                                   \
    __MPC_PARAMCHECK_BEGIN(hr)                                     \
        __MPC_PARAMCHECK_NOTNULL(pVal);                            \
    __MPC_PARAMCHECK_END();                                        \
    {

#define __MPC_BEGIN_PROPERTY_GET0__NOLOCK(id,func,hr,pVal)         \
    __MPC_FUNC_ENTRY( id, func );                                  \
                                                                   \
    HRESULT hr;                                                    \
                                                                   \
    __MPC_PARAMCHECK_BEGIN(hr)                                     \
        __MPC_PARAMCHECK_NOTNULL(pVal);                            \
    __MPC_PARAMCHECK_END();                                        \
    {

////////////////////

#define __MPC_BEGIN_PROPERTY_GET(id,func,hr,pVal)                  \
    __MPC_FUNC_ENTRY( id, func );                                  \
                                                                   \
    HRESULT                      hr;                               \
    MPC::SmartLock<_ThreadModel> lock( this );                     \
                                                                   \
    __MPC_PARAMCHECK_BEGIN(hr)                                     \
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);               \
    __MPC_PARAMCHECK_END();                                        \
    {

#define __MPC_BEGIN_PROPERTY_GET__NOLOCK(id,func,hr,pVal)          \
    __MPC_FUNC_ENTRY( id, func );                                  \
                                                                   \
    HRESULT hr;                                                    \
                                                                   \
    __MPC_PARAMCHECK_BEGIN(hr)                                     \
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);               \
    __MPC_PARAMCHECK_END();                                        \
    {

////////////////////

#define __MPC_BEGIN_PROPERTY_GET2(id,func,hr,pVal,value)           \
    __MPC_FUNC_ENTRY( id, func );                                  \
                                                                   \
    HRESULT                      hr;                               \
    MPC::SmartLock<_ThreadModel> lock( this );                     \
                                                                   \
    __MPC_PARAMCHECK_BEGIN(hr)                                     \
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,value);              \
    __MPC_PARAMCHECK_END();                                        \
    {

#define __MPC_BEGIN_PROPERTY_GET2__NOLOCK(id,func,hr,pVal,value)   \
    __MPC_FUNC_ENTRY(id,func);                                     \
                                                                   \
    HRESULT hr;                                                    \
                                                                   \
    __MPC_PARAMCHECK_BEGIN(hr)                                     \
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,value);              \
    __MPC_PARAMCHECK_END();                                        \
    {

////////////////////

#define __MPC_BEGIN_PROPERTY_PUT(id,func,hr)                       \
    __MPC_FUNC_ENTRY(id,func);                                     \
                                                                   \
    HRESULT                      hr;                               \
    MPC::SmartLock<_ThreadModel> lock( this );                     \
                                                                   \
    __MPC_PARAMCHECK_BEGIN(hr)                                     \
    __MPC_PARAMCHECK_END();                                        \
    {


#define __MPC_BEGIN_PROPERTY_PUT__NOLOCK(id,func,hr)               \
    __MPC_FUNC_ENTRY(id,func);                                     \
                                                                   \
    HRESULT hr;                                                    \
                                                                   \
    __MPC_PARAMCHECK_BEGIN(hr)                                     \
    __MPC_PARAMCHECK_END();                                        \
    {


#define __MPC_END_PROPERTY(hr)                                     \
    }                                                              \
    hr = S_OK;                                                     \
                                                                   \
    __MPC_FUNC_CLEANUP;                                            \
    __MPC_FUNC_EXIT(hr)

/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___MPC___TRACE_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\mpc_utils.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    MPC_utils.h

Abstract:
    This file contains the declaration of various utility functions/classes.

Revision History:
    Davide Massarenti   (Dmassare)  05/09/99
        created

******************************************************************************/

#if !defined(__INCLUDED___MPC___UTILS_H___)
#define __INCLUDED___MPC___UTILS_H___

#include <MPC_main.h>
#include <MPC_COM.h>

#include <fci.h>
#include <fdi.h>

#include <objidl.h>

#undef CopyFile
#undef MoveFile
#undef DeleteFile

namespace MPC
{
    // Forward declarations.
    class Serializer;
    class CComHGLOBAL;

    ////////////////////

    inline int StrCmp( const MPC::string&  left, const MPC::string&  right ) { return strcmp(        left.c_str(),         right.c_str() ); }
    inline int StrCmp( const MPC::string&  left,       LPCSTR        right ) { return strcmp(        left.c_str(), right ? right : ""    ); }
    inline int StrCmp(       LPCSTR        left, const MPC::string&  right ) { return strcmp( left ? left : ""   ,         right.c_str() ); }
    inline int StrCmp(       LPCSTR        left,       LPCSTR        right ) { return strcmp( left ? left : ""   , right ? right : ""    ); }

    inline int StrCmp( const MPC::wstring& left, const MPC::wstring& right ) { return wcscmp(        left.c_str(),         right.c_str() ); }
    inline int StrCmp( const MPC::wstring& left,       LPCWSTR       right ) { return wcscmp(        left.c_str(), right ? right : L""   ); }
    inline int StrCmp(       LPCWSTR       left, const MPC::wstring& right ) { return wcscmp( left ? left : L""  ,         right.c_str() ); }
    inline int StrCmp(       LPCWSTR       left,       LPCWSTR       right ) { return wcscmp( left ? left : L""  , right ? right : L""   ); }

    ////////////////////

    inline int StrICmp( const MPC::string&  left, const MPC::string&  right ) { return _stricmp(        left.c_str(),         right.c_str() ); }
    inline int StrICmp( const MPC::string&  left,       LPCSTR        right ) { return _stricmp(        left.c_str(), right ? right : ""    ); }
    inline int StrICmp(       LPCSTR        left, const MPC::string&  right ) { return _stricmp( left ? left : ""   ,         right.c_str() ); }
    inline int StrICmp(       LPCSTR        left,       LPCSTR        right ) { return _stricmp( left ? left : ""   , right ? right : ""    ); }

    inline int StrICmp( const MPC::wstring& left, const MPC::wstring& right ) { return _wcsicmp(        left.c_str(),         right.c_str() ); }
    inline int StrICmp( const MPC::wstring& left,       LPCWSTR       right ) { return _wcsicmp(        left.c_str(), right ? right : L""   ); }
    inline int StrICmp(       LPCWSTR       left, const MPC::wstring& right ) { return _wcsicmp( left ? left : L""  ,         right.c_str() ); }
    inline int StrICmp(       LPCWSTR       left,       LPCWSTR       right ) { return _wcsicmp( left ? left : L""  , right ? right : L""   ); }

    //////////////////////////////////////////////////////////////////////

    HRESULT LocalizeInit( LPCWSTR szFile = NULL );

    HRESULT LocalizeString( UINT uID, LPSTR         lpBuf, int nBufMax, bool fMUI = false );
    HRESULT LocalizeString( UINT uID, LPWSTR        lpBuf, int nBufMax, bool fMUI = false );
    HRESULT LocalizeString( UINT uID, MPC::string&  szStr             , bool fMUI = false );
    HRESULT LocalizeString( UINT uID, MPC::wstring& szStr             , bool fMUI = false );
    HRESULT LocalizeString( UINT uID, CComBSTR&     bstrStr           , bool fMUI = false );

    int LocalizedMessageBox   ( UINT uID_Title, UINT uID_Msg, UINT uType      );
    int LocalizedMessageBoxFmt( UINT uID_Title, UINT uID_Msg, UINT uType, ... );

    //////////////////////////////////////////////////////////////////////

    void RemoveTrailingBackslash( /*[in/out]*/ LPWSTR szPath );

    HRESULT GetProgramDirectory ( /*[out]*/    MPC::wstring& szPath                                                                     );
    HRESULT GetUserWritablePath ( /*[out]*/    MPC::wstring& szPath, /*[in]*/ LPCWSTR szSubDir = NULL                                   );
    HRESULT GetTemporaryFileName( /*[out]*/    MPC::wstring& szFile, /*[in]*/ LPCWSTR szBase   = NULL, /*[in]*/ LPCWSTR szPrefix = NULL );
    HRESULT RemoveTemporaryFile ( /*[in/out]*/ MPC::wstring& szFile                                                                     );

    HRESULT SubstituteEnvVariables( /*[in/out]*/ MPC::wstring& szStr );

    //////////////////////////////////////////////////

    int  HexToNum( int c );
    char NumToHex( int c );

    DATE GetSystemTime();
    DATE GetLocalTime ();

    DATE GetSystemTimeEx( /*[in]*/ bool fHighPrecision );
    DATE GetLocalTimeEx ( /*[in]*/ bool fHighPrecision );

    DATE GetLastModifiedDate( /*[out]*/ const MPC::wstring& strFile );

    HRESULT ConvertSizeUnit( /*[in]*/ const MPC::wstring& szStr, /*[out]*/ DWORD& dwRes );
    HRESULT ConvertTimeUnit( /*[in]*/ const MPC::wstring& szStr, /*[out]*/ DWORD& dwRes );

    HRESULT ConvertDateToString( /*[in] */ DATE          dDate  ,
                                 /*[out]*/ MPC::wstring& szDate ,
                                 /*[in] */ bool          fGMT   ,
                                 /*[in] */ bool          fCIM   ,
                                 /*[in] */ LCID          lcid   );

    HRESULT ConvertStringToDate( /*[in] */ const MPC::wstring& szDate ,
                                 /*[out]*/ DATE&               dDate  ,
                                 /*[in] */ bool                fGMT   ,
                                 /*[in] */ bool                fCIM   ,
                                 /*[in] */ LCID                lcid   );


    HRESULT ConvertStringToHex( /*[in]*/ const CComBSTR& bstrText, /*[out]*/ CComBSTR& bstrHex  );
    HRESULT ConvertHexToString( /*[in]*/ const CComBSTR& bstrHex , /*[out]*/ CComBSTR& bstrText );

    HRESULT ConvertHGlobalToHex( /*[in]*/ HGLOBAL         hg      , /*[out]*/ CComBSTR& bstrHex, /*[in]*/ bool fNullAllowed = false , DWORD* pdwCount = NULL );
    HRESULT ConvertHexToHGlobal( /*[in]*/ const CComBSTR& bstrText, /*[out]*/ HGLOBAL&  hg     , /*[in]*/ bool fNullAllowed = false );

    HRESULT ConvertBufferToVariant( /*[in]*/ const BYTE*    pBuf, /*[in]*/ DWORD dwLen, /*[out]*/ CComVariant& v                            );
    HRESULT ConvertVariantToBuffer( /*[in]*/ const VARIANT* v   ,                       /*[out]*/ BYTE*&       pBuf, /*[out]*/ DWORD& dwLen );

    HRESULT ConvertIStreamToVariant( /*[in]*/ IStream*       stream, /*[out]*/ CComVariant&  v       );
    HRESULT ConvertVariantToIStream( /*[in]*/ const VARIANT* v     , /*[out]*/ IStream*     *pStream );

    HRESULT ConvertListToSafeArray( /*[in]*/ const MPC::WStringList& lst  , /*[out]*/ VARIANT&          array, /*[in]*/ VARTYPE vt );
    HRESULT ConvertSafeArrayToList( /*[in]*/ const VARIANT&          array, /*[out]*/ MPC::WStringList& lst                        );

    //////////////////////////////////////////////////

    typedef struct
    {
        LPCWSTR szName;
        DWORD   dwMask;  // Mask of the bit field.
        DWORD   dwSet;   // Bits to set.
        DWORD   dwReset; // Bits to reset before set.
    } StringToBitField;

    HRESULT CommandLine_Parse( /*[out]*/ int& argc, /*[out]*/ LPCWSTR*& argv, /*[in]*/ LPWSTR lpCmdLine = NULL, /*[in]*/ bool fBackslashForEscape = false );
    void    CommandLine_Free ( /*[in ]*/ int& argc, /*[in ]*/ LPCWSTR*& argv                                                                              );

    HRESULT ConvertStringToBitField( /*[in]*/ LPCWSTR szText    , /*[out]*/ DWORD&        dwBitField, /*[in]*/ const StringToBitField* pLookup, /*[in]*/ bool fUseTilde = false );
    HRESULT ConvertBitFieldToString( /*[in]*/ DWORD   dwBitField, /*[out]*/ MPC::wstring& szText    , /*[in]*/ const StringToBitField* pLookup                                  );

    HRESULT SplitAtDelimiter( StringVector&  vec, LPCSTR  ptr, LPCSTR  delims, bool fDelimIsAString = true, bool fSkipAdjacentDelims = false );
    HRESULT SplitAtDelimiter( WStringVector& vec, LPCWSTR ptr, LPCWSTR delims, bool fDelimIsAString = true, bool fSkipAdjacentDelims = false );

    HRESULT JoinWithDelimiter( const StringVector&  vec, MPC::string&  ptr, LPCSTR  delims );
    HRESULT JoinWithDelimiter( const WStringVector& vec, MPC::wstring& ptr, LPCWSTR delims );

    //////////////////////////////////////////////////

    HRESULT MakeDir       ( /*[in]*/ const MPC::wstring& szPath, /*[in]*/ bool fCreateParent = true                                         );
    HRESULT GetDiskSpace  ( /*[in]*/ const MPC::wstring& szFile       , /*[out]*/ ULARGE_INTEGER& liFree, /*[out]*/ ULARGE_INTEGER& liTotal );
    HRESULT ExecuteCommand( /*[in]*/ const MPC::wstring& szCommandLine                                                                      );

    HRESULT FailOnLowDiskSpace( /*[in]*/ LPCWSTR szFile, /*[in]*/ DWORD dwLowLevel );
    HRESULT FailOnLowMemory   (                          /*[in]*/ DWORD dwLowLevel );

    //////////////////////////////////////////////////

    HRESULT GetCallingPidFromRPC  ( /*[out]*/ ULONG& pid                                    );
    HRESULT GetFileNameFromProcess( /*[in ]*/ HANDLE hProc, /*[out]*/ MPC::wstring& strFile );
    HRESULT GetFileNameFromPid    ( /*[in ]*/ ULONG  pid  , /*[out]*/ MPC::wstring& strFile );

    HRESULT MapDeviceToDiskLetter( /*[out]*/ MPC::wstring& strDevice, /*[out]*/ MPC::wstring& strDisk );

    bool    IsCallerInList       ( /*[in]*/ const LPCWSTR* rgList, /*[in]*/ const MPC::wstring& strCallerFile );
    HRESULT VerifyCallerIsTrusted( /*[in]*/ const LPCWSTR* rgList                                             );

    //////////////////////////////////////////////////

    class MSITS
    {
    public:
        static bool IsCHM( /*[in]*/ LPCWSTR pwzUrl, /*[out]*/ BSTR* pbstrStorageName = NULL, /*[out]*/ BSTR* pbstrFilePath = NULL );

        static HRESULT OpenAsStream( /*[in] */ const CComBSTR& bstrStorageName, /*[in] */ const CComBSTR& bstrFilePath, /*[out]*/ IStream **ppStream );
    };

    //////////////////////////////////////////////////

    class Cabinet
    {
    public:
        class File
        {
        public:
            MPC::wstring m_szFullName;
            MPC::wstring m_szName;
            bool         m_fFound;
            DWORD        m_dwSizeUncompressed;
            DWORD        m_dwSizeCompressed;

            File()
            {
                m_fFound             = false;
                m_dwSizeUncompressed = 0;
                m_dwSizeCompressed   = 0;
            }
        };

        typedef std::list<File>      List;
        typedef List::iterator       Iter;
        typedef List::const_iterator IterConst;

        typedef HRESULT (*PFNPROGRESS_FILES)( Cabinet* /*cabinet*/, LPCWSTR /*szFile*/, ULONG /*lDone*/, ULONG /*lTotal*/, LPVOID /*user*/ );
        typedef HRESULT (*PFNPROGRESS_BYTES)( Cabinet* /*cabinet*/,                     ULONG /*lDone*/, ULONG /*lTotal*/, LPVOID /*user*/ );

    private:
        WCHAR             m_szCabinetPath[MAX_PATH];
        WCHAR             m_szCabinetName[MAX_PATH];
        List              m_lstFiles;
        Iter              m_itCurrent;

        DWORD             m_dwSizeDone;
        DWORD             m_dwSizeTotal;

        HFCI              m_hfci;
        HFDI              m_hfdi;
        ERF               m_erf;
        CCAB              m_cab_parameters;

        BOOL              m_fIgnoreMissingFiles;
        LPVOID            m_lpUser;
        PFNPROGRESS_FILES m_pfnCallback_Files;
        PFNPROGRESS_BYTES m_pfnCallback_Bytes;

        ////////////////////////////////////////

        static LPVOID  DIAMONDAPI mem_alloc( ULONG  cb     );
        static void    DIAMONDAPI mem_free ( LPVOID memory );

        ////////////////////////////////////////

        static int     DIAMONDAPI fci_delete( LPSTR   pszFile,                       int *err, LPVOID pv );
        static INT_PTR DIAMONDAPI fci_open  ( LPSTR   pszFile, int oflag, int pmode, int *err, LPVOID pv );
        static UINT    DIAMONDAPI fci_read  ( INT_PTR hf, LPVOID memory, UINT cb,    int *err, LPVOID pv );
        static UINT    DIAMONDAPI fci_write ( INT_PTR hf, LPVOID memory, UINT cb,    int *err, LPVOID pv );
        static int     DIAMONDAPI fci_close ( INT_PTR hf,                            int *err, LPVOID pv );
        static long    DIAMONDAPI fci_seek  ( INT_PTR hf, long dist, int seektype,   int *err, LPVOID pv );

        static BOOL    DIAMONDAPI fci_get_next_cabinet( PCCAB pccab, ULONG cbPrevCab,                                            LPVOID pv );
        static int     DIAMONDAPI fci_file_placed     ( PCCAB pccab, LPSTR pszFile, long  cbFile, BOOL fContinuation,            LPVOID pv );
        static long    DIAMONDAPI fci_progress        ( UINT typeStatus, ULONG cb1, ULONG cb2,                                   LPVOID pv );
        static BOOL    DIAMONDAPI fci_get_temp_file   ( LPSTR pszTempName, int cbTempName,                                       LPVOID pv );
        static INT_PTR DIAMONDAPI fci_get_open_info   ( LPSTR pszName, USHORT *pdate, USHORT *ptime, USHORT *pattribs, int *err, LPVOID pv );

        ////////////////////////////////////////

        static INT_PTR DIAMONDAPI fdi_open  ( LPSTR pszFile, int oflag, int pmode );
        static UINT    DIAMONDAPI fdi_read  ( INT_PTR hf, LPVOID pv, UINT cb      );
        static UINT    DIAMONDAPI fdi_write ( INT_PTR hf, LPVOID pv, UINT cb      );
        static int     DIAMONDAPI fdi_close ( INT_PTR hf                          );
        static long    DIAMONDAPI fdi_seek  ( INT_PTR hf, long dist, int seektype );

        static INT_PTR DIAMONDAPI fdi_notification_copy     ( FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin );
        static INT_PTR DIAMONDAPI fdi_notification_enumerate( FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin );

        ////////////////////////////////////////

    public:
        Cabinet();
        ~Cabinet();


        HRESULT put_CabinetFile       ( /*[in]*/ LPCWSTR           szVal, /*[in]*/ UINT cbSpaceToReserve = 0 );
        HRESULT put_IgnoreMissingFiles( /*[in]*/ BOOL              fVal   );
        HRESULT put_UserData          ( /*[in]*/ LPVOID            lpVal  );
        HRESULT put_onProgress_Files  ( /*[in]*/ PFNPROGRESS_FILES pfnVal );
        HRESULT put_onProgress_Bytes  ( /*[in]*/ PFNPROGRESS_BYTES pfnVal );


        HRESULT ClearFiles();
        HRESULT GetFiles  ( /*[out]*/ List& lstFiles );
        HRESULT AddFile   ( /*[in]*/ LPCWSTR szFileName, /*[in]*/ LPCWSTR szFileNameInsideCabinet = NULL );


        HRESULT Compress  ();
        HRESULT Decompress();
        HRESULT Enumerate ();
    };


    HRESULT CompressAsCabinet    ( /*[in]*/       LPCWSTR      szInputFile  , /*[in]*/ LPCWSTR      szCabinetFile, /*[in]*/ LPCWSTR szFileName                  );
    HRESULT CompressAsCabinet    ( /*[in]*/ const WStringList& lstFiles     , /*[in]*/ LPCWSTR      szCabinetFile, /*[in]*/ BOOL    fIgnoreMissingFiles = FALSE );
    HRESULT ListFilesInCabinet   ( /*[in]*/       LPCWSTR      szCabinetFile, /*[in]*/ WStringList& lstFiles                                                    );
    HRESULT DecompressFromCabinet( /*[in]*/       LPCWSTR      szCabinetFile, /*[in]*/ LPCWSTR      szOutputFile , /*[in]*/ LPCWSTR szFileName                  );

    //////////////////////////////////////////////////

    class URL
    {
        MPC::wstring    m_szURL;
        URL_COMPONENTSW m_ucURL;

        void    Clean  ();
        HRESULT Prepare();

    public:
        URL();
        ~URL();


        HRESULT CheckFormat( /*[in]*/ bool fDecode = false );

        HRESULT Append( /*[in]*/ const MPC::wstring& szExtra, /*[in]*/ bool fEscape = true );
        HRESULT Append( /*[in]*/ LPCWSTR             szExtra, /*[in]*/ bool fEscape = true );

        HRESULT AppendQueryParameter( /*[in]*/ LPCWSTR szName, /*[in]*/ LPCWSTR szValue );


        HRESULT get_URL      ( /*[out]*/       MPC::wstring& szURL );
        HRESULT put_URL      ( /*[in] */ const MPC::wstring& szURL );
        HRESULT put_URL      ( /*[in] */ LPCWSTR             szURL );


        HRESULT get_Scheme   ( /*[out]*/ MPC::wstring&    szVal ) const;
        HRESULT get_Scheme   ( /*[out]*/ INTERNET_SCHEME&  nVal ) const;
        HRESULT get_HostName ( /*[out]*/ MPC::wstring&    szVal ) const;
        HRESULT get_Port     ( /*[out]*/ DWORD       &    dwVal ) const;
        HRESULT get_Path     ( /*[out]*/ MPC::wstring&    szVal ) const;
        HRESULT get_ExtraInfo( /*[out]*/ MPC::wstring&    szVal ) const;
    };

    //////////////////////////////////////////////////

    void    InitCRC   ( /*[out]   */ DWORD& dwCRC                                                  );
    void    ComputeCRC( /*[in/out]*/ DWORD& dwCRC, /*[in]*/ UCHAR*   rgBlock, /*[in]*/ int nLength );
    HRESULT ComputeCRC( /*[out]   */ DWORD& dwCRC, /*[in]*/ IStream* stream                        );
    HRESULT ComputeCRC( /*[out]   */ DWORD& dwCRC, /*[in]*/ LPCWSTR  szFile                        );

    //////////////////////////////////////////////////

    HRESULT GetBSTR( /*[in ]*/ LPCWSTR   bstr, /*[out]*/ BSTR    *  pVal, /*[in]*/ bool fNullOk = true );
    HRESULT PutBSTR( /*[out]*/ CComBSTR& bstr, /*[in ]*/ LPCWSTR  newVal, /*[in]*/ bool fNullOk = true );
    HRESULT PutBSTR( /*[out]*/ CComBSTR& bstr, /*[in ]*/ VARIANT* newVal, /*[in]*/ bool fNullOk = true );

    ////////////////////////////////////////////////////////////////////////////////

    class CComHGLOBAL
    {
        HGLOBAL        m_hg;
        mutable LPVOID m_ptr;
        mutable DWORD  m_dwLock;

    public:
        CComHGLOBAL();
        ~CComHGLOBAL();

        // copy constructors...
        CComHGLOBAL           ( /*[in]*/ const CComHGLOBAL& chg );
        CComHGLOBAL& operator=( /*[in]*/ const CComHGLOBAL& chg );

        CComHGLOBAL& operator=( /*[in]*/ HGLOBAL hg );

        void    Attach( /*[in]*/ HGLOBAL hg );
        HGLOBAL Detach(                     );

        HGLOBAL Get       () const;
        HGLOBAL GetRef    ();
        HGLOBAL GetPointer();

        DWORD Size() const;

        ////////////////////

        HRESULT New    ( /*[in]*/ UINT uFlags, /*[in]*/ DWORD dwSize );
        void    Release(                                             );

        LPVOID Lock  () const;
        void   Unlock() const;

        HRESULT Copy( /*[in]*/ HGLOBAL hg, /*[in]*/ DWORD dwMaxSize = 0xFFFFFFFF );

        HRESULT CopyFromStream( /*[in ]*/ IStream*   val                       );
        HRESULT CopyToStream  ( /*[out]*/ IStream*   val                       );
        HRESULT CloneAsStream ( /*[out]*/ IStream* *pVal                       );
        HRESULT DetachAsStream( /*[out]*/ IStream* *pVal                       );
        HRESULT GetAsStream   ( /*[out]*/ IStream* *pVal, /*[in]*/ bool fClone );
        HRESULT NewStream     ( /*[out]*/ IStream* *pVal                       );
    };

    //////////////////////////////////////////////////

    namespace Connectivity
    {
        class Proxy
        {
            bool        m_fInitialized;

            MPC::string m_strProxy;
            MPC::string m_strProxyBypass;
            CComHGLOBAL m_hgConnection;

        public:
            Proxy();
            ~Proxy();

            HRESULT Initialize( /*[in]*/ bool      fImpersonate = false );
            HRESULT Apply     ( /*[in]*/ HINTERNET hSession             );

            friend HRESULT operator>>( /*[in]*/ MPC::Serializer& stream, /*[out]*/       Proxy& val );
            friend HRESULT operator<<( /*[in]*/ MPC::Serializer& stream, /*[in ]*/ const Proxy& val );
        };

        class WinInetTimeout
        {
            MPC::CComSafeAutoCriticalSection& m_cs;
            HINTERNET&                        m_hReq;
            HANDLE                            m_hTimer;
            DWORD                             m_dwTimeout;

            INTERNET_STATUS_CALLBACK          m_PreviousCallback;
            DWORD_PTR                         m_PreviousContext;

            static VOID CALLBACK TimerFunction( PVOID lpParameter, BOOLEAN TimerOrWaitFired );

            static VOID CALLBACK InternetStatusCallback( HINTERNET hInternet                 ,
                                                         DWORD_PTR dwContext                 ,
                                                         DWORD     dwInternetStatus          ,
                                                         LPVOID    lpvStatusInformation      ,
                                                         DWORD     dwStatusInformationLength );

            HRESULT InternalSet  ();
            HRESULT InternalReset();

        public:
            WinInetTimeout( /*[in]*/ MPC::CComSafeAutoCriticalSection& cs, /*[in]*/ HINTERNET& hReq );
            ~WinInetTimeout();

            HRESULT Set  ( /*[in]*/ DWORD dwTimeout );
            HRESULT Reset(                          );
        };

        HRESULT NetworkAlive        (                                 /*[in]*/ DWORD dwTimeout, /*[in]*/ MPC::Connectivity::Proxy* pProxy = NULL );
        HRESULT DestinationReachable( /*[in]*/ LPCWSTR szDestination, /*[in]*/ DWORD dwTimeout, /*[in]*/ MPC::Connectivity::Proxy* pProxy = NULL );
    };

    ////////////////////////////////////////////////////////////////////////////////

    class RegKey
    {
        REGSAM       m_samDesired;
        HKEY         m_hRoot;
        mutable HKEY m_hKey;

        MPC::wstring m_strKey;
        MPC::wstring m_strPath;
        MPC::wstring m_strName;

        HRESULT Clean( /*[in]*/ bool fBoth );

    public:
        RegKey();
        ~RegKey();

        operator HKEY() const;

        RegKey& operator=( /*[in]*/ const RegKey& rk );


        HRESULT SetRoot( /*[in]*/ HKEY hKey, /*[in]*/ REGSAM samDesired = KEY_READ, /*[in]*/ LPCWSTR szMachine = NULL );
        HRESULT Attach ( /*[in]*/ LPCWSTR szKeyName                                                                   );


        HRESULT Exists( /*[out]*/ bool&   fFound                                ) const;
        HRESULT Create(                                                         ) const;
        HRESULT Delete( /*[in]*/  bool    fDeep                                 )      ;
        HRESULT SubKey( /*[in]*/  LPCWSTR szKeyName, /*[out]*/ RegKey& rkSubKey ) const;
        HRESULT Parent(                              /*[out]*/ RegKey& rkParent ) const;

        HRESULT EnumerateSubKeys( /*[out]*/ MPC::WStringList& lstSubKeys ) const;
        HRESULT EnumerateValues ( /*[out]*/ MPC::WStringList& lstValues  ) const;

        HRESULT DeleteSubKeys() const;
        HRESULT DeleteValues () const;


        HRESULT ReadDirect ( /*[in]*/ LPCWSTR szValueName, /*[out]*/ CComHGLOBAL& hgBuffer, /*[out]*/ DWORD& dwSize, /*[out]*/ DWORD& dwType, /*[out]*/ bool& fFound ) const;
        HRESULT WriteDirect( /*[in]*/ LPCWSTR szValueName, /*[in ]*/ void*        pBuffer , /*[in ]*/ DWORD  dwSize, /*[in ]*/ DWORD  dwType                         ) const;


        HRESULT get_Key ( /*[out]*/ MPC::wstring& strKey  ) const;
        HRESULT get_Name( /*[out]*/ MPC::wstring& strName ) const;
        HRESULT get_Path( /*[out]*/ MPC::wstring& strPath ) const;

        HRESULT get_Value( /*[out]*/       VARIANT& vValue, /*[out]*/ bool& fFound, /*[in]*/ LPCWSTR szValueName = NULL                                ) const;
        HRESULT put_Value( /*[in] */ const VARIANT  vValue,                         /*[in]*/ LPCWSTR szValueName = NULL, /*[in]*/ bool fExpand = false ) const;
        HRESULT del_Value(                                                          /*[in]*/ LPCWSTR szValueName = NULL                                ) const;

        HRESULT Read( /*[out]*/ MPC::string&       strValue, /*[out]*/ bool& fFound, /*[in]*/ LPCWSTR szValueName = NULL );
        HRESULT Read( /*[out]*/ MPC::wstring&      strValue, /*[out]*/ bool& fFound, /*[in]*/ LPCWSTR szValueName = NULL );
        HRESULT Read( /*[out]*/ CComBSTR&         bstrValue, /*[out]*/ bool& fFound, /*[in]*/ LPCWSTR szValueName = NULL );
        HRESULT Read( /*[out]*/ DWORD&              dwValue, /*[out]*/ bool& fFound, /*[in]*/ LPCWSTR szValueName = NULL );
        HRESULT Read( /*[out]*/ MPC::WStringList&  lstValue, /*[out]*/ bool& fFound, /*[in]*/ LPCWSTR szValueName        );


        HRESULT Write( /*[in]*/ const MPC::string&       strValue, /*[in]*/ LPCWSTR szValueName = NULL, /*[in]*/ bool fExpand = false );
        HRESULT Write( /*[in]*/ const MPC::wstring&      strValue, /*[in]*/ LPCWSTR szValueName = NULL, /*[in]*/ bool fExpand = false );
        HRESULT Write( /*[in]*/ BSTR                    bstrValue, /*[in]*/ LPCWSTR szValueName = NULL, /*[in]*/ bool fExpand = false );
        HRESULT Write( /*[in]*/ DWORD                     dwValue, /*[in]*/ LPCWSTR szValueName = NULL                                );
        HRESULT Write( /*[in]*/ const MPC::WStringList&  lstValue, /*[in]*/ LPCWSTR szValueName                                       );

        static HRESULT ParsePath( /*[in]*/ LPCWSTR szKey, /*[out]*/ HKEY& hKey, /*[out]*/ LPCWSTR& szPath, /*[in]*/ HKEY hKeyDefault = HKEY_LOCAL_MACHINE );
    };

    HRESULT RegKey_Value_Read ( /*[out]*/ VARIANT&              vValue, /*[out]*/ bool& fFound, /*[in]*/ LPCWSTR szKeyName, /*[in]*/ LPCWSTR szValueName = NULL, /*[in]*/ HKEY hKey = HKEY_LOCAL_MACHINE                                );
    HRESULT RegKey_Value_Read ( /*[out]*/ MPC::wstring&       strValue, /*[out]*/ bool& fFound, /*[in]*/ LPCWSTR szKeyName, /*[in]*/ LPCWSTR szValueName = NULL, /*[in]*/ HKEY hKey = HKEY_LOCAL_MACHINE                                );
    HRESULT RegKey_Value_Read ( /*[out]*/ DWORD&               dwValue, /*[out]*/ bool& fFound, /*[in]*/ LPCWSTR szKeyName, /*[in]*/ LPCWSTR szValueName = NULL, /*[in]*/ HKEY hKey = HKEY_LOCAL_MACHINE                                );

    HRESULT RegKey_Value_Write( /*[in] */ const VARIANT&        vValue,                         /*[in]*/ LPCWSTR szKeyName, /*[in]*/ LPCWSTR szValueName = NULL, /*[in]*/ HKEY hKey = HKEY_LOCAL_MACHINE, /*[in]*/ bool fExpand = false );
    HRESULT RegKey_Value_Write( /*[in] */ const MPC::wstring& strValue,                         /*[in]*/ LPCWSTR szKeyName, /*[in]*/ LPCWSTR szValueName = NULL, /*[in]*/ HKEY hKey = HKEY_LOCAL_MACHINE, /*[in]*/ bool fExpand = false );
    HRESULT RegKey_Value_Write( /*[in] */ DWORD                dwValue,                         /*[in]*/ LPCWSTR szKeyName, /*[in]*/ LPCWSTR szValueName = NULL, /*[in]*/ HKEY hKey = HKEY_LOCAL_MACHINE                                );


    //////////////////////////////////////////////////

    //
    // These functions also deal with Read-Only, protected files.
    //
    HRESULT CopyFile  ( /*[in]*/ LPCWSTR              szFileSrc, /*[in]*/ LPCWSTR              szFileDst, /*[in]*/ bool fForce = true, /*[in]*/ bool fDelayed = false );
    HRESULT CopyFile  ( /*[in]*/ const MPC::wstring& strFileSrc, /*[in]*/ const MPC::wstring& strFileDst, /*[in]*/ bool fForce = true, /*[in]*/ bool fDelayed = false );

    HRESULT MoveFile  ( /*[in]*/ LPCWSTR              szFileSrc, /*[in]*/ LPCWSTR              szFileDst, /*[in]*/ bool fForce = true, /*[in]*/ bool fDelayed = false );
    HRESULT MoveFile  ( /*[in]*/ const MPC::wstring& strFileSrc, /*[in]*/ const MPC::wstring& strFileDst, /*[in]*/ bool fForce = true, /*[in]*/ bool fDelayed = false );

    HRESULT DeleteFile( /*[in]*/ LPCWSTR              szFile,                                             /*[in]*/ bool fForce = true, /*[in]*/ bool fDelayed = false );
    HRESULT DeleteFile( /*[in]*/ const MPC::wstring& strFile,                                             /*[in]*/ bool fForce = true, /*[in]*/ bool fDelayed = false );

    ////////////////////

    class FileSystemObject // Hungarian: fso
    {
    public:
        typedef std::list<FileSystemObject*> List;
        typedef List::iterator               Iter;
        typedef List::const_iterator         IterConst;

    private:
        MPC::wstring              m_strPath;
        WIN32_FILE_ATTRIBUTE_DATA m_wfadInfo;
        List                      m_lstChilds;
        bool                      m_fLoaded;
        bool                      m_fScanned;
        bool                      m_fScanned_Deep;

        void Init ( /*[in]*/ LPCWSTR szPath, /*[in]*/ const FileSystemObject* fsoParent );
        void Clean(                                                                     );

    public:
        FileSystemObject( /*[in]*/       LPCWSTR           szPath = NULL, /*[in]*/ const FileSystemObject* fsoParent = NULL );
        FileSystemObject( /*[in]*/ const WIN32_FIND_DATAW& wfdInfo      , /*[in]*/ const FileSystemObject* fsoParent = NULL );
        FileSystemObject(                                                 /*[in]*/ const FileSystemObject& fso              );
        ~FileSystemObject();

        FileSystemObject& operator=( /*[in]*/ LPCWSTR                 szPath );
        FileSystemObject& operator=( /*[in]*/ const FileSystemObject& fso    );


        HRESULT Scan( /*[in]*/ bool fDeep = false, /*[in]*/ bool fReload = false, /*[in]*/ LPCWSTR szSearchPattern = NULL );

        bool Exists     ();
        bool IsFile     ();
        bool IsDirectory();

        HRESULT EnumerateFolders( /*[out]*/ List& lstFolders );
        HRESULT EnumerateFiles  ( /*[out]*/ List& lstFiles   );

        HRESULT get_Name  ( /*[out]*/ MPC::wstring& szName   ) const;
        HRESULT get_Path  ( /*[out]*/ MPC::wstring& szPath   ) const;
        HRESULT get_Parent( /*[out]*/ MPC::wstring& szParent ) const;

        HRESULT get_Attributes    ( /*[out]*/       DWORD&    dwFileAttributes                                         );
        HRESULT put_Attributes    ( /*[in] */       DWORD     dwFileAttributes                                         );
        HRESULT get_CreationTime  ( /*[out]*/       FILETIME& ftCreationTime                                           );
        HRESULT put_CreationTime  ( /*[in] */ const FILETIME& ftCreationTime                                           );
        HRESULT get_LastAccessTime( /*[out]*/       FILETIME& ftLastAccessTime                                         );
        HRESULT put_LastAccessTime( /*[in] */ const FILETIME& ftLastAccessTime                                         );
        HRESULT get_LastWriteTime ( /*[out]*/       FILETIME& ftLastWriteTime                                          );
        HRESULT put_LastWriteTime ( /*[in] */ const FILETIME& ftLastWriteTime                                          );
        HRESULT get_FileSize      ( /*[out]*/       DWORD&    nFileSizeLow    , /*[out]*/ DWORD *pnFileSizeHigh = NULL );


        HRESULT CreateDir     (                                          /*[in]*/ bool fForce = false                                 );
        HRESULT Delete        (                                          /*[in]*/ bool fForce = false, /*[in]*/ bool fComplain = true );
        HRESULT DeleteChildren(                                          /*[in]*/ bool fForce = false, /*[in]*/ bool fComplain = true );
        HRESULT Rename        ( /*[in]*/ const FileSystemObject& fsoDst, /*[in]*/ bool fForce = false                                 );
        HRESULT Copy          ( /*[in]*/ const FileSystemObject& fsoDst, /*[in]*/ bool fForce = false                                 );

        HRESULT Open( /*[out]*/ HANDLE& hfFile, /*[in]*/ DWORD dwDesiredAccess, /*[in]*/ DWORD dwShareMode, /*[in]*/ DWORD dwCreationDisposition );

        //////////////////////////////////////////////////

        static bool Exists     ( /*[in]*/ LPCWSTR szPath );
        static bool IsFile     ( /*[in]*/ LPCWSTR szPath );
        static bool IsDirectory( /*[in]*/ LPCWSTR szPath );
    };

    ////////////////////

    class StorageObject // Hungarian: so
    {
    public:
        typedef std::list<StorageObject*> List;
        typedef List::iterator            Iter;
        typedef List::const_iterator      IterConst;

        struct Stat : public STATSTG
        {
            Stat();
            ~Stat();

            void Clean();
        };

    private:
        StorageObject*    m_parent;
        CComBSTR          m_bstrPath;
        bool              m_fITSS;
        DWORD             m_grfMode;

        DWORD             m_type;
        Stat              m_stat;
        CComPtr<IStorage> m_stg;
        CComPtr<IStream>  m_stream;

        bool              m_fChecked;
        bool              m_fScanned;
        bool              m_fMarkedForDeletion;
        List              m_lstChilds;

        ////////////////////

        void Init ( /*[in]*/ DWORD grfMode, /*[in]*/ bool fITSS, /*[in]*/ LPCWSTR szPath, /*[in]*/ StorageObject* soParent );
        void Clean( /*[in]*/ bool  fFinal                                                                                  );

        HRESULT Scan();

        HRESULT RemoveChild( /*[in]*/ StorageObject* child );

    private:
        // copy constructors...
        StorageObject           ( /*[in]*/ const StorageObject& so );
        StorageObject& operator=( /*[in]*/ const StorageObject& so );

    public:
        StorageObject( /*[in]*/ DWORD grfMode = STGM_READ, /*[in]*/ bool fITSS = false, /*[in]*/ LPCWSTR szPath = NULL, /*[in]*/ StorageObject* soParent = NULL );
        ~StorageObject();

        StorageObject& operator=( /*[in]*/ LPCWSTR szPath );

        ////////////////////

        const Stat& GetStat() { m_stat; }

        HRESULT Compact             (                                );
        HRESULT Exists              (                                );
        HRESULT EnumerateSubStorages( /*[out]*/ List& lstSubStorages );
        HRESULT EnumerateStreams    ( /*[out]*/ List& lstStreams     );

        HRESULT GetStorage(                          /*[out]*/ CComPtr<IStorage>& out                                                                );
        HRESULT GetStream (                          /*[out]*/ CComPtr<IStream>&  out                                                                );
        HRESULT GetChild  ( /*[in]*/ LPCWSTR szName, /*[out]*/ StorageObject*&    child, /*[in]*/ DWORD grfMode = STGM_READ, /*[in]*/ DWORD type = 0 );

        HRESULT Create        ();
        HRESULT Rewind        ();
        HRESULT Truncate      ();
        HRESULT Delete        ();
        HRESULT DeleteChildren();
        void    Release       ();

        const CComBSTR& GetName() { return m_bstrPath; }
    };

    /////////////////////////////////////////////////////////////////////////////

    class NamedMutex
    {
    protected:
        bool         m_fCloseOnRelease; // If true, the mutex is closed on the last release.
        MPC::wstring m_szName;          // Name of the object, optional.
        HANDLE       m_hMutex;          // The mutex handle.
        DWORD        m_dwCount;         // Recursion counter.

        void    CleanUp          ();
        HRESULT EnsureInitialized();

    public:
        NamedMutex( LPCWSTR szName, bool fCloseOnRelease = true );
        virtual ~NamedMutex();

        HRESULT SetName( LPCWSTR szName );

        HRESULT Acquire( DWORD dwMilliseconds = INFINITE );
        HRESULT Release(                                 );
        bool    IsOwned(                                 );
    };

    class NamedMutexWithState : public NamedMutex
    {
        DWORD  m_dwSize; // Size of the shared state.
        HANDLE m_hMap;   // Handle to the mapping object.
        LPVOID m_rgData; // Pointer to the mapped area.

        void    CleanUp          ();
        void    Flush            ();
        HRESULT EnsureInitialized();

    public:
        NamedMutexWithState( LPCWSTR szName, DWORD dwSize, bool fCloseOnRelease = false );
        virtual ~NamedMutexWithState();

        HRESULT SetName( LPCWSTR szName );

        HRESULT Acquire( DWORD dwMilliseconds = INFINITE );
        HRESULT Release(                                 );

        LPVOID GetData();
    };

    ////////////////////////////////////////////////////////////////////////////////

    namespace Pooling
    {
        class Base
        {
        protected:
            MPC::CComSafeAutoCriticalSection m_cs;
            DWORD                            m_dwInCallback;
            DWORD                            m_dwThreadID;

        public:
            Base();

            void Lock  ();
            void Unlock();

            void AddRef ();
            void Release();
        };

        class Timer : public Base
        {
            DWORD  m_dwFlags;
            HANDLE m_hTimer;

            static VOID CALLBACK TimerFunction( PVOID lpParameter, BOOLEAN TimerOrWaitFired );

        public:
            Timer( /*[in]*/ DWORD dwFlags = WT_EXECUTEDEFAULT );
            ~Timer();

            HRESULT Set  ( /*[in]*/ DWORD dwTimeout, /*[in]*/ DWORD dwPeriod );
            HRESULT Reset(                                                   );

            virtual HRESULT Execute( /*[in]*/ BOOLEAN TimerOrWaitFired );
        };

        class Event : public Base
        {
            DWORD  m_dwFlags;
            HANDLE m_hWaitHandle;
            HANDLE m_hEvent;

            static VOID CALLBACK WaitOrTimerFunction( PVOID lpParameter, BOOLEAN EventOrWaitFired );

        public:
            Event( /*[in]*/ DWORD dwFlags = WT_EXECUTEDEFAULT );
            ~Event();

            void Attach( /*[in]*/ HANDLE hEvent );

            HRESULT Set  ( /*[in]*/ DWORD dwTimeout );
            HRESULT Reset(                          );

            virtual HRESULT Signaled( /*[in]*/ BOOLEAN TimerOrWaitFired );
        };
    };
};


#endif // !defined(__INCLUDED___MPC___UTILS_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\pxpacket.h ===
//#---------------------------------------------------------------
//  File:       pxpacket.h
//        
//  Synopsis:   This file contains the structure definations for
//				the CProxyPacket class.
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    t-alexwe
//----------------------------------------------------------------

#ifndef __PXPACKET_H__
#define __PXPACKET_H__

#include "cliproto.h"

//
// The CProxyPacket class is a just a wrapper for the PROXYPACKET structure.
// it has no data members except those that it inherits from PROXYPACKET
// and is used to manipulate messages found in a packet.
//
class CProxyPacket : public PROXYPACKET {
	public:
		CProxyPacket();
		~CProxyPacket();
		//
		// reset a packet to have no messages or data
		//
		void clear() { cLength = PACKETHDRSIZE; cMessages = 0; }
		//
		// Get the next available data area in the packet.  Once 
		// data has been written here it must be registered with 
		// AddMessage()
		//
		PVOID getNextDataPointer(void) 
			{ return &pData[cLength - PACKETHDRSIZE]; }
		//
		// get the number of bytes of available space in the data area
		//
		WORD getAvailableSpace(void) 
			{ return sizeof(PROXYPACKET) - cLength - PACKETHDRSIZE; }
		//
		// add a message to a packet
		//
		void addMessage(WORD wCommand, WORD cData);
		//
		// gets the length of the entire packet
		//
		WORD getSize(void) { return cLength; }
		//
		// Gets the number of messages in a packet
		//
		WORD getMessageCount(void) { return cMessages; }
		//
		// retrieves a pointer to the message data for a particular
		// message.
		//
		PVOID getMessage(WORD wIndex, PWORD pwCommand, PWORD pcData);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\qbase.h ===
//
// QBASE.h
//
//	This file defines CQElement - a base class for all types which
//	are to be used in the lockq.h and other templated queue manipulation
//	classes.
// 
// 




#ifndef	_QBASE_H_
#define	_QBASE_H_

#include	"dbgtrace.h"

//-----------------------------------------------
// Base Element Class
//
// This is the base class for Queue and stack Elements.
// The various implementations of Stacks and Queues are friends.
//	
class	CQElement	{
public : 
	CQElement	*m_pNext ;

	inline	CQElement( ) ;
	inline	CQElement( CQElement*	p ) ;
	inline	~CQElement( ) ;
} ;

CQElement::CQElement( ) : 
	m_pNext( 0 )  {
//
//	Construct a queue element - not in any list pointer must be NULL
//
}

CQElement::~CQElement( ) 	{
//
//	Destroy a queue element - next pointer must be NULL or
//	0xFFFFFFFF (for lockq.h) so that we know the element is not 
//	on a queue at destruction time and the user has properly 
//	managed the linking and unlinking of the queue.
//
	_ASSERT( m_pNext == 0 || m_pNext == (CQElement*)0xFFFFFFFF ) ;
}

CQElement::CQElement( CQElement *pIn ) : 
	m_pNext( pIn ) {
//
//	Constructor which sets the initial next pointer value !
//
}

#endif	// _CQUEUE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\rwexport.h ===
/*++

	rwexport.h

	This file defines a reader/writer lock implemented in rwnh.dll.
	We define the locks so that none of their internal workings is exposed.

--*/


#ifndef	_RWEXPORT_H
#define	_RWEXPORT_H

#ifdef	_RW_IMPLEMENTATION_
#define	_RW_INTERFACE_ __declspec( dllexport ) 
#else
#define	_RW_INTERFACE_	__declspec( dllimport ) 
#endif


class	_RW_INTERFACE_	CShareLockExport	{
private : 
	DWORD	m_dwSignature ;

	enum	constants	{
		//
		//	Signature in our objects !
		//
		SIGNATURE = (DWORD)'opxE'
	} ;

	//
	//	Reserved space for the implementation !
	//
	DWORD	m_dwReserved[16] ;

public : 

	CShareLockExport() ;
	~CShareLockExport() ;

	//
	//	Grab the lock Shared - other threads may pass through ShareLock() as well
	//
	void	ShareLock() ;

	//
	//	Releases the lock - if we are the last reader to leave writers may
	//	start to enter the lock !
	//
	void	ShareUnlock() ;

	//
	//	Grab the lock Exclusively - no other readers or writers may enter !!
	//
	void	ExclusiveLock() ;

	//
	//	Release the Exclusive Locks - if there are readers waiting they 
	//	will enter before other waiting writers !
	//
	void	ExclusiveUnlock() ;

	//
	//	Convert an ExclusiveLock to a Shared - this cannot fail !
	//
	void	ExclusiveToShared() ;

	//
	//	Convert a Shared Lock to an Exclusive one - this can fail - returns
	//	TRUE if successfull !
	//
	BOOL	SharedToExclusive() ;

	BOOL	TryShareLock() ;
	BOOL	TryExclusiveLock() ;

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\mpc_xml.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    MPC_xml.h

Abstract:
    This file contains the declaration of the XmlUtil class,
    the support class for handling XML data.

Revision History:
    Davide Massarenti   (Dmassare)  05/08/99
        created

******************************************************************************/

#if !defined(__INCLUDED___MPC___XML_H___)
#define __INCLUDED___MPC___XML_H___

#include <MPC_main.h>
#include <MPC_utils.h>

/////////////////////////////////////////////////////////////////////////

namespace MPC
{
    class XmlUtil
    {
        CComPtr<IXMLDOMDocument> m_xddDoc;
        CComPtr<IXMLDOMNode>     m_xdnRoot;
		HANDLE                   m_hEvent;    // Used to abort a download.
		DWORD                    m_dwTimeout; // Used to limit a download.

		void Init ();
		void Clean();

		HRESULT LoadPost( /*[in] */ LPCWSTR szRootTag ,
						  /*[out]*/ bool&   fLoaded   ,
						  /*[out]*/ bool*   fFound    );

		HRESULT CreateParser();

    public:
        XmlUtil( /*[in]*/ const XmlUtil&   xml                                               );
        XmlUtil( /*[in]*/ IXMLDOMDocument* xddDoc        , /*[in]*/ LPCWSTR szRootTag = NULL );
        XmlUtil( /*[in]*/ IXMLDOMNode*     xdnRoot = NULL, /*[in]*/ LPCWSTR szRootTag = NULL );

        ~XmlUtil();


        XmlUtil& operator=( /*[in]*/ const XmlUtil& xml     );
        XmlUtil& operator=( /*[in]*/ IXMLDOMNode*   xdnRoot );

        HRESULT DumpError();

        HRESULT New         (      							 /*[in]*/ IXMLDOMNode* xdnRoot  , /*[in] */ BOOL    fDeep      = false                     );
        HRESULT New         (      							 /*[in]*/ LPCWSTR      szRootTag, /*[in] */ LPCWSTR szEncoding = L"unicode"                );
        HRESULT Load        ( /*[in	]*/ LPCWSTR    szFile  , /*[in]*/ LPCWSTR      szRootTag, /*[out]*/ bool&   fLoaded, /*[out]*/ bool* fFound = NULL );
        HRESULT LoadAsStream( /*[in	]*/ IUnknown*  pStream , /*[in]*/ LPCWSTR      szRootTag, /*[out]*/ bool&   fLoaded, /*[out]*/ bool* fFound = NULL );
        HRESULT LoadAsString( /*[in	]*/ BSTR       bstrData, /*[in]*/ LPCWSTR      szRootTag, /*[out]*/ bool&   fLoaded, /*[out]*/ bool* fFound = NULL );
        HRESULT Save        ( /*[in	]*/ LPCWSTR    szFile                                                                                              );
        HRESULT SaveAsStream( /*[out]*/ IUnknown* *ppStream                                                                                            );
        HRESULT SaveAsString( /*[out]*/ BSTR      *pbstrData                                                                                           );

        HRESULT SetTimeout( /*[in]*/ DWORD dwTimeout );
        HRESULT Abort     (                          );

        HRESULT SetVersionAndEncoding( /*[in]*/ LPCWSTR szVersion, /*[in]*/ LPCWSTR szEncoding );

        HRESULT GetDocument    (                         /*[out]*/ IXMLDOMDocument*  * pVal                                        ) const;
        HRESULT GetRoot        (                         /*[out]*/ IXMLDOMNode*      * pVal                                        ) const;
        HRESULT GetNodes       ( /*[in]*/ LPCWSTR szTag, /*[out]*/ IXMLDOMNodeList*  * pVal                                        ) const;
        HRESULT GetNode        ( /*[in]*/ LPCWSTR szTag, /*[out]*/ IXMLDOMNode*      * pVal                                        ) const;
        HRESULT CreateNode     ( /*[in]*/ LPCWSTR szTag, /*[out]*/ IXMLDOMNode*      * pVal, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );

        HRESULT GetAttribute   ( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[out]*/ IXMLDOMAttribute*  *   pValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT GetAttribute   ( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[out]*/ CComBSTR&           bstrValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT GetAttribute   ( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[out]*/ MPC::wstring&         szValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT GetAttribute   ( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[out]*/ LONG&                  lValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT GetValue       ( /*[in]*/ LPCWSTR szTag,                          /*[out]*/ CComVariant&           vValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT GetValue       ( /*[in]*/ LPCWSTR szTag,                          /*[out]*/ CComBSTR&           bstrValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT GetValue       ( /*[in]*/ LPCWSTR szTag,                          /*[out]*/ MPC::wstring&         szValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );

        HRESULT ModifyAttribute( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[in] */ const CComBSTR&     bstrValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT ModifyAttribute( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[in] */ const MPC::wstring&   szValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT ModifyAttribute( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[in] */ LPCWSTR               szValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT ModifyAttribute( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[in] */ LONG                   lValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT ModifyValue    ( /*[in]*/ LPCWSTR szTag,                          /*[in] */ const CComVariant&     vValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT ModifyValue    ( /*[in]*/ LPCWSTR szTag,                          /*[in] */ const CComBSTR&     bstrValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT ModifyValue    ( /*[in]*/ LPCWSTR szTag,                          /*[in] */ const MPC::wstring&   szValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );

        HRESULT PutAttribute   ( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[in] */ IXMLDOMAttribute*  *   pValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT PutAttribute   ( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[in] */ const CComBSTR&     bstrValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT PutAttribute   ( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[in] */ const MPC::wstring&   szValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT PutAttribute   ( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[in] */ LPCWSTR               szValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT PutAttribute   ( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[in] */ LONG                   lValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT PutValue       ( /*[in]*/ LPCWSTR szTag,                          /*[in] */ const CComVariant&     vValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT PutValue       ( /*[in]*/ LPCWSTR szTag,                          /*[in] */ const CComBSTR&     bstrValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT PutValue       ( /*[in]*/ LPCWSTR szTag,                          /*[in] */ const MPC::wstring&   szValue, /*[out]*/ bool& fFound, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );

        HRESULT RemoveAttribute( /*[in]*/ LPCWSTR szTag, /*[in]*/ LPCWSTR szAttr, /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT RemoveValue    ( /*[in]*/ LPCWSTR szTag,                          /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
        HRESULT RemoveNode     ( /*[in]*/ LPCWSTR szTag,                          /*[in]*/ IXMLDOMNode* pxdnNode = NULL );
    };

	////////////////////////////////////////////////////////////////////////////////

	HRESULT ConvertFromRegistryToXML( /*[in]*/ const MPC::RegKey&  rkKey, /*[out]*/ MPC::XmlUtil& xml   );
	HRESULT ConvertFromXMLToRegistry( /*[in]*/ const MPC::XmlUtil& xml  , /*[out]*/ MPC::RegKey&  rkKey );

}; // namespace

/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___MPC___XML_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\rwintrnl.h ===
/*++

	rwintrnl.h

	Reader/Writer locks internal header file

	This file defines several objects used to implement
	reader/writer locks, however these objects should
	not be directly used by any client of rw.h



--*/


#ifndef	_RWINTRNL_H_
#define	_RWINTRNL_H_



class	CHandleInfo	{
/*++

	This class keeps track of all the handles we've allocated for 
	use by various threads.  We can't use Thread Local Storage
	directly because we can be dynamically unloaded, in which case
	we need to free all of our HANDLES !

--*/
private : 
	//
	//	Signature for our 
	//
	DWORD	m_dwSignature ;
	class	CHandleInfo*	m_pNext ;
	class	CHandleInfo*	m_pPrev ;

	CHandleInfo( CHandleInfo& ) ;
	CHandleInfo&	operator=( CHandleInfo& ) ;

	//
	//	Global lock to protect free and allocated lists !
	//
	static	CRITICAL_SECTION	s_InUseList ;
	//
	//	Allocated CHandleInfo objects !
	//
	static	CHandleInfo			s_Head ;
	//
	//	Free CHandleInfo objects 
	//
	static	CHandleInfo			s_FreeHead ;
	//
	//	Number of Free CHandleInfo objects in the s_FreeHead list 
	//
	static	DWORD	s_cFreeList ;

	enum	constants	{
		//
		//	Maximum number of CHandleInfo objects we'll hold onto !
		//
		MAX_FREE = 16,		
		//
		//	Initial number of CHandleInfo objects we'll allocate !
		//
		INITIAL_FREE = 8,
		//
		//	Signature in our objects !
		//
		SIGNATURE = (DWORD)'hnwR'
	} ;

	//
	//	Memory Allocation is done the hard way !
	//
	void*	operator new( size_t size ) ;
	void	operator delete( void *pv ) ;

	//
	//	List Manipulation routines !
	//
	void	
	InsertAtHead( CHandleInfo*	pHead	)	;

	//
	//	Remove the element from the list - returns this pointer !
	//
	CHandleInfo*
	RemoveList( )  ;

public : 

	//
	//	Constructor and Destructor !
	//
	CHandleInfo() ;
	~CHandleInfo() ;

	//
	//	This is public for all to use !
	//
	HANDLE	m_hSemaphore ;

	//
	//	Initialize the class
	//
	static	BOOL
	InitClass() ;
	
	//
	//	Terminate the class - release all outstanding handles !
	//
	static	void
	TermClass() ;

	//
	//	Get a CHandleInfo object !
	//
	static	CHandleInfo*
	AllocHandleInfo() ;

	//
	//	release a CHandleInfo object !
	//
	static	void
	ReleaseHandleInfo( CHandleInfo* ) ;

	//
	//	Check that the object is valid !
	//
	BOOL
	IsValid()	{
		return	m_dwSignature == SIGNATURE &&
				m_pNext != 0 &&
				m_pPrev != 0 ;
	}

} ;


//
//	This class serves two purposes : to provide for a linkable object
//	on which we can queue threads blocked upon semaphore handles, and 
//	a mechanism to get and set semaphore handles for reader/writer locks etc...
//
class	CWaitingThread : public	CQElement	{
private : 

	enum	{
		POOL_HANDLES = 64,
	} ;

	//
	//	Semaphore that we can use to block the thread !
	//
	CHandleInfo	*m_pInfo ;

	//
	//	Var to hold error that may have occurred manipulating the lock !
	//
	DWORD	m_dwError ;

	//
	//	Thread Local Storage offset for holding the handles !
	//
	static	DWORD	g_dwThreadHandle ;

	//
	//	Array of Handles to Semaphores which we stash away in case
	//	we have to release the handle being used by a thread at some point !
	//
	static	HANDLE	g_rghHandlePool[ POOL_HANDLES ] ;

	//
	//	No copying of these objects allowed !!!
	//
	CWaitingThread( CWaitingThread& ) ;
	CWaitingThread&	operator=( CWaitingThread& ) ;

public : 

#ifdef	DEBUG

	//
	//	Thread Id - handy for debuggiing
	//
	DWORD	m_dwThreadId ;
#endif

	CWaitingThread() ;


	//
	//	Functions to be called from the DllEntryProc function !
	//
	static	BOOL	
	InitClass() ;

	static	BOOL	
	TermClass() ;

	//
	//	Thread Entry/Exit routines which can allocate semaphore handles for us !
	//
	static	void	
	ThreadEnter() ;

	static	void	
	ThreadExit() ;

	//
	//	Function which gives us our thread handle !
	//
	inline	HANDLE	
	GetThreadHandle()	const ;

	//
	//	Function which will release a HANDLE to the Pool of available
	//	semaphore handles !
	//
	inline	void
	PoolHandle( 
				HANDLE	h 
				)	const ;

	//
	//	Function which will remove a handle from our thread's TLS !
	//	The argument must originally be from the calling thread's TLS 
	//
	inline	void
	ClearHandle(	
				HANDLE	h 
				) ;
	

	//
	//	Function which blocks the calling thread !!
	//
	inline	BOOL	
	Wait() const ;

	//
	//	Function which can release a thread !!
	//
	inline	BOOL	
	Release() const	;

	//
	//	This function is used in debug builds to check the state of our semaphore handles !
	//
	static	inline
	BOOL	ValidateHandle( 
				HANDLE	h 
				) ;

} ;

typedef	TLockQueue< CWaitingThread >	TThreadQueue ;	

class	CSingleReleaseQueue {
private : 
	//
	//	Queue of threads waiting to own the lock !
	//
	TThreadQueue	m_Waiting ;

public : 

#ifdef	DEBUG
	DWORD			m_ThreadIdNext ;
#endif

	CSingleReleaseQueue(	
				BOOL	IsSignalled = TRUE
				) ;

	//
	//	Release a single waiting thread !
	//
	void	Release( ) ;

	//
	//	Wait for the queue to become signalled !
	//
	void	WaitForIt(
				CWaitingThread&	myself 
				) ;

	//
	//	Wait for the queue to become signalled
	//
	void	WaitForIt( ) ;

} ;

//
//	This class is similar to a semaphore -
//	Threads block indefinately on WaitForIt() and another 
//	thread may release as many threads as required by calling
//	Release().
//	
class	CEventQueue	{
private : 

	//
	//	Number of threads that should be allowed to pass
	//	through the event !!!
	//
	long			m_ReleaseCount ;

	//
	//	Queue of threads blocked on this event !
	//
	TThreadQueue	m_WaitingThreads ;

	//
	//	Any thread may call this to release threads from the queue
	//
	BOOL	ResumeThreads(	
					CWaitingThread* 
					) ;

public : 

	//
	//	Create an event queue object
	//
	CEventQueue(	
				long	cInitial = 0 
				) ;

	~CEventQueue() ;

	void	Release(	
				long	NumberToRelease
				) ;

	void	WaitForIt( 
				CWaitingThread&	myself 
				) ;

	void	WaitForIt() ;

	void	Reset() ;
} ;




//
//	Function which gives us our thread handle !
//
inline	HANDLE	
CWaitingThread::GetThreadHandle()	const	{

	_ASSERT( ValidateHandle( m_pInfo->m_hSemaphore ) ) ;

	return	m_pInfo->m_hSemaphore ;	
}

//
//	Function which takes a handle (must not be ours) 
//	and places it into a pool of handles available for other threads !
//
inline	void
CWaitingThread::PoolHandle(	HANDLE	h )	const	{

	_ASSERT( h != m_pInfo->m_hSemaphore && h != 0 ) ;
	_ASSERT( ValidateHandle( h ) ) ;

	for( int i=0; 
			i < sizeof( g_rghHandlePool ) / sizeof( g_rghHandlePool[0] ) &&
			h != 0; 
			i++ ) {
		h = (HANDLE)InterlockedExchange( (long*)&g_rghHandlePool[i], (long)h ) ;
	}

	if( h != 0 ) {
		_VERIFY( CloseHandle( h ) ) ;
	}
}

//
//	Release our Handle from TLS, somebody else is going to use it !
//
inline	void
CWaitingThread::ClearHandle(	HANDLE	h )		{

	_ASSERT( h != 0 && h == m_pInfo->m_hSemaphore ) ;

	m_pInfo->m_hSemaphore = 0 ;
	//TlsSetValue( g_dwThreadHandle, (LPVOID) 0 ) ;

}



//
//	Block on the handle held within our object !
//
inline	BOOL	
CWaitingThread::Wait()	const	{	

	_ASSERT( m_pInfo->m_hSemaphore != 0 ) ;
	
	return	WAIT_OBJECT_0 == WaitForSingleObject( m_pInfo->m_hSemaphore, INFINITE ) ;	
}

//
//	Release a thread which is blocked on the semaphore within !!
//
inline	BOOL	
CWaitingThread::Release()	const	{	

	_ASSERT( m_pInfo->m_hSemaphore != 0 ) ;
	_ASSERT( ValidateHandle( m_pInfo->m_hSemaphore ) ) ;

	return	ReleaseSemaphore( m_pInfo->m_hSemaphore, 1, NULL ) ;	
}

//
//
//
inline	BOOL
CWaitingThread::ValidateHandle( HANDLE	h )	{

	DWORD	dw = WaitForSingleObject( h, 0 ) ;
	_ASSERT( dw == WAIT_TIMEOUT ) ;

	return	dw == WAIT_TIMEOUT ;
}















#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\rw.h ===
#ifndef	_CRW_H
#define	_CRW_H
						
#include	<limits.h>

//
// This class contains the meat - does actual locking etc...
//
class	CShareLock {
private : 
	long	cReadLock ;			// Number of Readers who have passed through the lock OR 
								// the number of readers waiting for the lock (will be negative).
								// A value of 0 means nobody in the lock
	long	cOutRdrs ;			// The number of readers remainin in the lock if 
								// there is a writer waiting.  This can become temporarily negative
	CRITICAL_SECTION	critWriters ; 	// Critical section to allow only one writer into the lock at a time
	HANDLE	hWaitingWriters ;	// Semaphore for waiting writers to block on (Only 1 ever, others will 
								// be queued on critWriters)
	HANDLE	hWaitingReaders ;	// Semaphore for waiting readers to block on 
public : 
	CShareLock( ) ;
	~CShareLock( ) ;

	void	ShareLock( ) ;
	void	ShareUnlock( ) ;
	void	ExclusiveLock( ) ;
	void	ExclusiveUnlock( ) ;
} ;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\rwlock.h ===
/*--------------------------------------------------------

  rwlock.h
      CReadWriteLock class provides functions that allow 
      threads to lock any resource in two different
	  modes (read-mode and write-mode).
      The class will allow multiple reader threads to access
      the resource simultaneously, but will make sure that
      a writer thread doesn't access the resource when 
      reader threads or a writer thread is currently accessing
      the resource. The class also assures fairness in access
      i.e. the access will be regulated by a first-come-first-in
	  policy.

	  Note:- ALL the functions in the class are INLINE functions.
	  So, this header can be directly used in the source.


  Copyright (C) 1995 Microsoft Corporation
  All rights reserved.

  Authors:
      rsraghav    R.S. Raghavan 

  History:
      04-20-95    rsraghav    Created.

  -------------------------------------------------------*/

#ifdef __cplusplus		// this file should be include only if this is
						// is included in a c++ source file.

#ifndef _RWLOCK_H_
#define _RWLOCK_H_

#if defined(DEBUG) && defined(INLINE)
#undef THIS_FILE
static char BASED_CODE RWLOCK_H[] = "rwlock.h";
#define THIS_FILE RWLOCK_H
#endif

#include <windows.h>

#define INLINE_EXPORT_SPEC __declspec( dllexport)

typedef enum {RWLOCK_READ_MODE, RWLOCK_WRITE_MODE} RWLOCK_MODE;

//////////////////////////////////////////////////////////////////////
// CReadWriteLock - Class that can be used to regulate read-write
//					access to resource, where multiple readers are
//					allowed simultaneously, but writers are excluded
//					from each other and from the readers. 

class INLINE_EXPORT_SPEC CReadWriteLock
{
	HANDLE 			hResource;			 
	CRITICAL_SECTION 	csReader;			
	CRITICAL_SECTION	csWriter;			
	DWORD			cReaders;
	DWORD			cWriteRecursion;

	public:
		
		CReadWriteLock()			// object constructor
		{
			cReaders =0;
			cWriteRecursion = 0;
			hResource = CreateEvent(NULL, FALSE, TRUE, NULL);	// no manual reset & initial state is signalled
			InitializeCriticalSection(&csReader);
			InitializeCriticalSection(&csWriter);
		}

		~CReadWriteLock()			// object destructor
		{
			if (hResource)
				CloseHandle(hResource);
			DeleteCriticalSection(&csReader);
			DeleteCriticalSection(&csWriter);
		}

		CReadWriteLock *PrwLock() 
		{
			return this;			
		}

		BOOL FInit()
		{
			return (BOOL)hResource;
		}

		void LockReadMode()			// Get read access to the resource
		{
			EnterCriticalSection(&csWriter);	
			LeaveCriticalSection(&csWriter);
			EnterCriticalSection(&csReader);
			if (!cReaders)
			{
				if (hResource)
					WaitForSingleObject(hResource, INFINITE);
			}
			cReaders++;
			LeaveCriticalSection(&csReader);
		}

		int LockReadModeEx(int iTimeOut)			// Get read access to the resource w/ Timeout
		{
			int status = 0;

			EnterCriticalSection(&csWriter);	
			LeaveCriticalSection(&csWriter);
			EnterCriticalSection(&csReader);
			if (!cReaders)
			{
				if (hResource) {
					status = WaitForSingleObject(hResource, iTimeOut);
					if (status == WAIT_TIMEOUT) 
					{ 
						status = -1;
					} else {
						status = 0;
					}
				}
			}
			cReaders++;
			LeaveCriticalSection(&csReader);

			return status;
		}


		void UnlockReadMode()		// Relinquish read access to the resource
		{
			EnterCriticalSection(&csReader);
			if (!(--cReaders))
			{
				if (hResource)
					SetEvent(hResource);				
			}
			LeaveCriticalSection(&csReader);
		}

		void LockCSUnderRead()
		{
			EnterCriticalSection(&csReader);
		}
		void UnlockCSUnderRead()
		{
			LeaveCriticalSection(&csReader);
		}

		void LockWriteMode()		// Get write access to the resource
		{
			EnterCriticalSection(&csWriter);
			if (!cWriteRecursion)
			{
				if (hResource)
					WaitForSingleObject(hResource, INFINITE);
			}
			cWriteRecursion++;
			
		}
		
		int LockWriteModeEx(int iTimeOut)		// Get write access to the resource
		{
			int status = 0;

			EnterCriticalSection(&csWriter);
			if (!cWriteRecursion)
			{
				if (hResource) 
				{
					status = WaitForSingleObject(hResource, iTimeOut);
					if (status == WAIT_TIMEOUT) 
					{ 
						LeaveCriticalSection(&csWriter);
						status = -1;
					} else {
						status = 0;
					}
				}				
			}
			if (status == 0)
				cWriteRecursion++;			

			return status;
		}


		void UnlockWriteMode()		// Relinquish write access to the resource
		{
			if (!(--cWriteRecursion))
			{
				if (hResource)
					SetEvent(hResource);
			}
			LeaveCriticalSection(&csWriter);
		}
};



//////////////////////////////////////////////////////////////////////
// Following class is just a utility class - users don't need to 
// necessarily use this class for obtaining read-write lock functionalities.

//////////////////////////////////////////////////////////////////////
// CScopeRWLock - This can be used to lock the given CReadWriteLock
//						object for the rest of the scope. The user just
//						needs to define this object in the scope by passing
//						a pointer to the CReadWriteLock object in the constructor. 
//						When this CScopeRWLock object goes out of scope the
//						CReadWriteLock object will automatically be unlocked.
//						This is provided just for user convenience so that the
//						user can choose to avoid remembering to unlock the object 
//						before every possible return/break path of the scope.
//						Use the RWLOCK_READ_MODE or RWLOCK_WRITE_MODE in the constructor
//						to indicate which type of access is requested.
//						Assumption:- CReadWriteLock object used here is expected to 
//								be valid at lease until the end of the scope.

class INLINE_EXPORT_SPEC CScopeRWLock
{
	CReadWriteLock *m_prwLock;
	LPCRITICAL_SECTION m_pcs;
	RWLOCK_MODE m_rwMode;

	public:
		CScopeRWLock(CReadWriteLock * prwLock, RWLOCK_MODE rwMode)
		{
			m_prwLock = prwLock;
			m_pcs = NULL;
			m_rwMode = rwMode;
			if (m_prwLock)
			{
				if (m_rwMode == RWLOCK_READ_MODE)
					m_prwLock->LockReadMode();	
				else if (m_rwMode == RWLOCK_WRITE_MODE)
					m_prwLock->LockWriteMode();
			}
		}

		CScopeRWLock(LPCRITICAL_SECTION pcsLock)
		{  	
			m_pcs = pcsLock;
			m_prwLock = NULL;
			if (m_pcs)
				EnterCriticalSection(m_pcs);
		}

		~CScopeRWLock()
		{
			if (m_prwLock)
			{
				if (m_rwMode == RWLOCK_READ_MODE)
					m_prwLock->UnlockReadMode();
				else if (m_rwMode == RWLOCK_WRITE_MODE)
					m_prwLock->UnlockWriteMode();
			}
			
			if (m_pcs)
			{
				LeaveCriticalSection(m_pcs);
			}
		}
};

#endif // _RWLOCK_H_

#endif // #if __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\rwnew.h ===
/*++
	
	rwnew.h

	This file defines several variations of Reader/Writer locks
	with different properties regarding handles used, and other 
	implementation details.

	Also defined are some variations of CRITICAL_SECTIONS which use
	fewer or no handles.

--*/



#ifndef	_RWNEW_H
#define	_RWNEW_H

#ifdef	_RW_IMPLEMENTATION_
#define	_RW_INTERFACE_ __declspec( dllexport ) 
#else
#define	_RW_INTERFACE_	__declspec( dllimport ) 
#endif

#pragma	warning( disable:4251 )
						
#include	<limits.h>
#include	"lockq.h"
#include	"rwintrnl.h"


class	_RW_INTERFACE_	CCritSection	{
private :

	//
	//	Handle of thread owning the lock !
	//
	HANDLE		m_hOwner ;

	//
	//	Count of Recursive Calls 
	//
	long	m_RecursionCount ;	

	//
	//	Count used to see who gets the lock next !
	//
	long	m_lock ;

	//
	//	Queue of waiting threads 
	//
	CSingleReleaseQueue		m_queue ;

	//
	//	Copying of these objects is not allowed !!!!
	//
	CCritSection( CCritSection& ) ;
	CCritSection&	operator=( CCritSection& ) ;

public : 

#ifdef	DEBUG
	DWORD	m_dwThreadOwner ;
#endif	

	//
	//	Construct a critical section object
	//
	CCritSection( ) :	
		m_queue( FALSE ),
		m_hOwner( INVALID_HANDLE_VALUE ), 
		m_RecursionCount( 0 ), 
		m_lock( -1 ) {
	}

	//
	//	Acquire the critical section
	//
	void	
	Enter(	
			CWaitingThread&	myself 
			) ;

	//
	//	Another version which acquires the critical section - 
	//	creates its own CWaitingThread object !
	//
	void	
	Enter() ;

	//
	//	REturns TRUE if the lock is available right now !
	//
	BOOL
	TryEnter(
			CWaitingThread&	myself 
			) ;

	//
	//	Returns TRUE if we can get the lock right now !
	//
	BOOL
	TryEnter()	{
		CWaitingThread	myself ;
		return	TryEnter( myself ) ;
	}

	//
	//	Release the critical section !
	//
	void
	Leave() ;

		
} ;


//
//	This version of critical section is more like an event - doesn't
//	care who releases locks - and doesn't handle recursive grabs !
//
class	_RW_INTERFACE_	CSimpleCritSection	{
private :

	//
	//	Count used to see who gets the lock next !
	//
	long	m_lock ;

	//
	//	Queue of waiting threads 
	//
	CSingleReleaseQueue		m_queue ;

	//
	//	Copying of these objects is not allowed !!!!
	//
	CSimpleCritSection( CCritSection& ) ;
	CSimpleCritSection&	operator=( CCritSection& ) ;

public : 

	//
	//	Construct a critical section object
	//
	CSimpleCritSection( ) :	
		m_queue( FALSE ),
		m_lock( -1 ) {
	}

	//
	//	Acquire the critical section
	//
	void	
	Enter(	
			CWaitingThread&	myself 
			) ;

	//
	//	Another version which acquires the critical section - 
	//	creates its own CWaitingThread object !
	//
	void	
	Enter() ;

	//
	//	REturns TRUE if the lock is available right now !
	//
	BOOL
	TryEnter(
			CWaitingThread&	myself 
			) ;

	//
	//	Returns TRUE if we can get the lock right now !
	//
	BOOL
	TryEnter()	{
		CWaitingThread	myself ;
		return	TryEnter( myself ) ;
	}

	//
	//	Release the critical section !
	//
	void
	Leave() ;
	
} ;

//
//	Another class which tries to create Reader/Write locks with
//	no handles !!
//

class	_RW_INTERFACE_	CShareLockNH	{
private : 

	//	
	//	Lock grabbed by writers to have exclusive access
	//
	CSimpleCritSection	m_lock ;

	//
	//	Number of readers who have grabbed the Read Lock - 
	//	Negative if a writer is waiting !
	//
	volatile	long	m_cReadLock ;

	//
	//	Number of Readers who have left the lock since a 
	//	writer tried to grab it !
	//
	volatile	long	m_cOutReaders ;

	//
	//	Number of readers who are entering the lock after 
	//	being blocked !!!
	//
	volatile	long	m_cOutAcquiringReaders ;

	//
	//	Handle that all the readers who are waiting try to grab !
	//
	volatile	HANDLE	m_hWaitingReaders ;

	//
	//	Handle that the single writer waiting for the lock is trying
	//	to grab !
	//
	volatile	HANDLE	m_hWaitingWriters ;

	void	inline
	WakeReaders() ;

	//
	//	The internal work of ShareLock - does a lot more of the stuff required
	//	when a writer is present !!!
	//
	void
	ShareLockInternal() ;

	//
	//	The internal work of ShareLock - does a lot more of the stuff required
	//	when a writer is present !!!
	//
	void
	ShareUnlockInternal() ;
	

	
public : 

	//
	//	Construction of CShareLockNH() objects always succeeds and there
	//	are no error cases !
	//
	CShareLockNH() ;

	//
	//	Grab the lock Shared - other threads may pass through ShareLock() as well
	//
	void	ShareLock() ;

	//
	//	Releases the lock - if we are the last reader to leave writers may
	//	start to enter the lock !
	//
	void	ShareUnlock() ;

	//
	//	Grab the lock Exclusively - no other readers or writers may enter !!
	//
	void	ExclusiveLock() ;

	//
	//	Release the Exclusive Locks - if there are readers waiting they 
	//	will enter before other waiting writers !
	//
	void	ExclusiveUnlock() ;

	//
	//	Convert an ExclusiveLock to a Shared - this cannot fail !
	//
	void	ExclusiveToShared() ;

	//
	//	Convert a Shared Lock to an Exclusive one - this can fail - returns
	//	TRUE if successfull !
	//
	BOOL	SharedToExclusive() ;

	BOOL	TryShareLock() ;
	BOOL	TryExclusiveLock() ;
} ;


#endif	//	_RWNEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\servdefs.h ===
/*--------------------------------------------------------

  servdefs.h
      Contains the global type definitions and constant 
      definitions used for the service & server attributes 
      used on the server-side of the datacenter.

  Copyright (C) 1993 Microsoft Corporation
  All rights reserved.

  Authors:
      rsraghav    R.S. Raghavan

  History:
      01-14-94    rsraghav    Created. 
	  06-05-94	  rsraghav 	  Changed the service state values
	  04-19-95	  rsraghav	  Added IP address definitions

  -------------------------------------------------------*/

#ifndef _SERVDEFS_H_
#define _SERVDEFS_H_

#if defined(DEBUG) && defined(INLINE)
#undef THIS_FILE
static char BASED_CODE SERVDEFS_H[] = "servdefs.h";
#define THIS_FILE SERVDEFS_H
#endif

// Type definitions of server related attributes.
typedef unsigned short MOS_SERVER_ID;	// MSID
typedef unsigned long CPU_INDEX;		// CI
typedef WORD MOS_LOCATE_TYPE;	// MLT
#if !defined(_MHANDLE_DEFINED)
typedef WORD MHANDLE;
typedef WORD HMCONNECT;
typedef WORD HMSESSION;
typedef WORD HMPIPE;
#define _MHANDLE_DEFINED
#endif

// Constants for server values
#define INVALID_MOS_SERVER_ID_VALUE (0xFFF0)
#define msidInvalid (INVALID_MOS_SERVER_ID_VALUE)
#define msidReservedForTest1 (0XFFEF)
#define msidReservedForTest2 (0XFFEE)
#define msidReservedForTest3 (0XFFED)
#define msidReservedForTest4 (0XFFEC)
#define msidReservedForTest5 (0XFFEB)
#define msidReservedForTest6 (0XFFEA)

// Locate redir values.
#define USE_LOCAL_SERVER        				0xffff
#define USE_NO_SERVER           				0xfffe
#define USE_LOAD_BALANCED_LOCATE				0xfffd
#define USE_LOAD_BALANCED_LOCATE_INCLUDE_SELF	0xfffc

// Type definitions of service attributes.
typedef unsigned long SERVICE_STATE; // SS
typedef unsigned long SERVICE_VERSION; // SV

// Type definitions of attachment state.
typedef unsigned long ATTACHMENT_STATE;	// AS

// Constants for service states	(values are kept so that ORing of two states will always give the highest of the two).
// NOTE: This strange number pattern is to reserve 2 bits between each value so that we can add new values without
//       changing the existing values and still be able to OR one or more states and get the highest state.
#define SSINVALID 			(0x00000000)
#define SSSTOPPED 			(0x00000001)
#define SSLAUNCHING 		(0x00000009)
#define SSLAUNCHED 			(0x00000049)
#define SSSYNCHRONIZING		(0x00000249)
#define SSSTOPPING	 		(0x00001249)
#define SSACTIVE	 		(0x00009249)
#define SSACTIVEACCEPTING 	(0x00049249)

// Constants for attachment states.
#define ASATTACHPENDING (0)
#define ASATTACHED		(1)
#define ASDETACHPENDING	(2)

// Constants for service version.  SVANY is used for searching in the Service Map.
#define INVALID_SERVICE_VERSION_VALUE (0xFFFFFFFF)
#define SVDEFAULT	(0)
#define SVANY		(0xFFFFFFFE)

// IP Address related definitions
typedef DWORD 			IPADDRESS; 			// IPA 

#define IPADDRESS_INVALID (0xFFFFFFFF)
#define MAX_IPADDRESS_STRING_LENGTH 16	// xxx.xxx.xxx.xxx format (max of 15 chars + \0)



//////////////////////////////////////////////////////////////////////
// CContext related definitions

// Disconnect cause.
enum CONTEXTCLOSESTATUS
{
    CCS_DATALINKDROP,
    CCS_CLIENTREQ,
    CCS_SRVREQ,
    CCS_SYSOP,
    CCS_COLDREDIR,
    CCS_HOTREDIR,
    CCS_NOP
};
#define PIPE_CLOSED_STATUS CONTEXTCLOSESTATUS


//////////////////////////////////////////////////////////////////////
// CRouter related definitions

#define ROUTER_NC               0
#define ROUTER_CONNECTED        1
#define ROUTER_CLOSING          2
#define ROUTER_IDLE             3
#define ROUTER_WAIT_OPEN        4
#define ROUTER_WAIT_CLOSE       5
#define ROUTER_GHOST            6   // no more available

#define MCP_VERSION_V1          0
#define MCP_VERSION_V2          1   // transmit intl info @ connect
#define MCP_VERSION_V3          2   // transmit intl info @ connect + failed addr
#define MCP_VERSION_V4          3   // transmit MCP config to client
#define MCP_VERSION_V5          4   // nothing new
#define MCP_VERSION_V6          5   // NAK
#define MCP_VERSION_V7          6   // transmit CLVER (client version)
#define MCP_VERSION_CURRENT     MCP_VERSION_V7
#define MCP_VERSION_NA          0x0 // not available

// Disconnect cause.
enum ROUTERUNCONNECTSTATUS
{ 
    RUS_DATALINKDROP,       // data link dropped
    RUS_CLIENTREQ,          // client requested data link drop
    RUS_SRVREQ,             // server requested data link drop
    RUS_SYSOP,              // sysop requested data link drop
    RUS_NOP,
    RUS_DATALINKTIMEOUT,    // inactivity time-out
    RUS_TOOMANYRETRANS,     // too many retransmission
    RUS_PUBLICTIMEOUT,      // public account access timeout
    RUS_TOOMANYPIPES,        // attempt to open too many pipes on a public account
	RUS_TOOMANY_BAD_PACKETS,  // too many back packets from client
	RUS_TRANSPORT_ERROR			  // transport error
};
#define CONNECTION_CLOSED_STATUS ROUTERUNCONNECTSTATUS


#endif // _SERVDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\symres.h ===
/********************************************************************
Copyright (c) 1999 Microsoft Corporation

Module Name:
    symres.h

Abstract:
    Header file for symres.dll

Revision History:

    Brijesh Krishnaswami (brijeshk) - 04/15/99 - Created
********************************************************************/

#ifndef _SYMRES_H
#define _SYMRES_H

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

void APIENTRY ResolveSymbols(LPWSTR,   // [in] filename
                             LPWSTR,   // [in] version
                             DWORD,    // [in] section 
                             UINT_PTR, // [in] offset
                             LPWSTR    // [out] resolved function name
                            );

#ifdef __cplusplus
}
#endif  // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\traceids.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    TraceIDs.h

Abstract:
    This file contains the TRACE_IDs for use in various client components

Revision History:
    Sridhar Chandrashekar   (SridharC)  04/20/99
        created

******************************************************************************/

#ifndef __TRACEIDS_H_
#define __TRACEIDS_H_

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#pragma once

// COMMON UTILITIES
#define COMMONID                0x03FF

//
// Trace IDs on the client side
//

// HELP CENTER
#define HELPCENTERID            0x0400

// DATA COLLECTION
#define DATACOLLID              0x0420
#define DCID_MAINDLL            0x0421
#define DCID_CDROM              0x0422
#define DCID_CODEC              0x0423
#define DCID_DEVICE             0x0424
#define DCID_DEVICEDRIVER       0x0425
#define DCID_DRIVE              0x0426
#define DCID_DRIVER             0x0427
#define DCID_FILEUPLOAD         0x0428
#define DCID_MODULE             0x0429
#define DCID_NETWORKADAPTER     0x042A
#define DCID_NETWORKCONNECTION  0x042B
#define DCID_NETWORKPROTOCOL    0x042C
#define DCID_OLEREGISTRATION    0x042D
#define DCID_PRINTJOB           0x042E
#define DCID_PRINTER            0x042F
#define DCID_PRINTERDRIVER      0x0431
#define DCID_PROGRAMGROUP       0x0432
#define DCID_RESOURCEDMA        0x0433
#define DCID_RESOURCEIORANGE    0x0434
#define DCID_RESOURCEIRQ        0x0435
#define DCID_RESOURCEMEMRANGE   0x0436
#define DCID_RUNNINGTASK        0x0437
#define DCID_STARTUP            0x0438
#define DCID_SYSINFO            0x0439
#define DCID_WINSOCK            0x043A
#define DCID_UTIL               0x043B
#define DCID_BIOS               0x043C
#define DCID_SYSTEMHOOK         0x043D
#define DCID_VERSION            0x043E

// UPLOAD LIBRARY
#define UPLOADLIBID             0x0440

// FAULT HANDLER
#define FAULTHANDLERID          0x0460
#define FHMAINID                0x0461
#define FHXMLOUTID              0x0462
#define FHPARSERID              0x0463
#define FHUIID                  0x0464
#define FHXMLFACTORYID          0x0465

// SCHEDULE
#define PCHSCHID                0x0481

// SYMBOL RESOLVER
#define SYMRESMAINID            0x04A0

//
// Trace IDs for the Restore
//

// RESTORE SHELL
#define TID_RSTR_MAIN           0x0500
#define TID_RSTR_CLIWND         0x0501
#define TID_RSTR_RPDATA         0x0502
#define TID_RSTR_CONFIG         0x0503

#ifdef __cplusplus
}
#endif  // __cplusplus

#endif //__TRACEIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\logging\utest\loggingtest.cpp ===
// LoggingTest.cpp : Defines the entry point for the console application.
//


#include <windows.h>
#include <stdio.h>
#include <dbgtrace.h>
#include "CEventLogger.h"

#ifdef THIS_FILE

#undef THIS_FILE

#endif

static char __szTraceSourceFile[] = __FILE__;

#define THIS_FILE __szTraceSourceFile


#define TRACE_FILEID  0





DWORD WINAPI LoggingTestThread(LPVOID lpvThreadParam)
{
    CEventLogger log;
    char szBuf[500];
    int nLoop;

    TraceFunctEnter("LoggingTestThread");

    if( log.Init("logfile") != ERROR_SUCCESS) 
    {
        printf("Erorr!\n");
        goto cleanup;
    }


    //printf("Enter in something to log: ");
    //gets(szBuf);

    for(nLoop = 0;nLoop < 2000;nLoop++) 
    {
            sprintf(szBuf, "%s %d", (LPSTR) lpvThreadParam,nLoop);
            if(log.LogEvent(1, szBuf, FALSE) != ERROR_SUCCESS ) 
                printf("ERROR\n");
            // wait 1 ms
            Sleep(1);
    }

    sprintf(szBuf,"Graphical Log Test, Thread: %s", (LPSTR) lpvThreadParam);
    log.LogEvent(1, szBuf, TRUE);

    TraceFunctLeave();
    return 1;
    
cleanup:
    TraceFunctLeave();
    return(0);
}


int _cdecl main(int argc, char* argv[])
{

HANDLE ahThreads[4];
DWORD dwId;
CEventLogger log;
char szBuf[4][256];
int nLoop;

    #if !NOTRACE    
        InitAsyncTrace();
    #endif


    if( argc < 2 ) 
    { 
        printf("need some arguments, eh?\n");
        return 0;
    }



    for(nLoop = 1;nLoop <=4;nLoop++)
        sprintf(szBuf[nLoop-1], "%s - (Thread %d)", argv[1], nLoop);


    log.Init("LogFile.tmp");

    log.LogEvent(1, "Hello, I'm a PopUp", TRUE );
    log.LogEvent(1, "Hello, I'm a PopUp1", TRUE );
    log.LogEvent(1, "Hello, I'm a PopUp2", TRUE );

    ahThreads[0] = CreateThread(NULL,0,LoggingTestThread,(LPVOID) szBuf[0], CREATE_SUSPENDED, &dwId);
    ahThreads[1] = CreateThread(NULL,0,LoggingTestThread,(LPVOID) szBuf[1], CREATE_SUSPENDED, &dwId);
    ahThreads[2] = CreateThread(NULL,0,LoggingTestThread,(LPVOID) szBuf[2], CREATE_SUSPENDED, &dwId);
    ahThreads[3] = CreateThread(NULL,0,LoggingTestThread,(LPVOID) szBuf[3], CREATE_SUSPENDED, &dwId);

    ResumeThread(ahThreads[0]);
    ResumeThread(ahThreads[1]);    
    ResumeThread(ahThreads[2]);    
    ResumeThread(ahThreads[3]);
    
    WaitForMultipleObjects(4,ahThreads,TRUE,INFINITE);

    TermAsyncTrace();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\logging\ceventlogger.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    CEventLogger.cpp

Abstract:
    This file contains implementation of the CEventLogger class which is
    used to log events across threads and processes.


Revision History:
      Eugene Mesgar        (eugenem)    6/16/99
        created

      Weiyou Cui           (weiyouc)    31/Jan/2000
        Set time resolution to milliseconds

******************************************************************************/

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <dbgtrace.h>
#include "CEventLogger.h"


#ifdef THIS_FILE

#undef THIS_FILE

#endif

static char __szTraceSourceFile[] = __FILE__;

#define THIS_FILE __szTraceSourceFile

#define TRACE_FILEID    (LPARAM)this





/*
 *    Basic constructor
 */
CEventLogger::CEventLogger() 
{
    TraceFunctEnter("CEventLogger");
    m_hSemaphore = NULL;
    // m_hLogFile = NULL;
    m_pszFileName = NULL;
    TraceFunctLeave();

}


/*
 *    Destructor
 */

CEventLogger::~CEventLogger() 
{
    
    TraceFunctEnter("~CEventLogger");

    if(m_pszFileName)
    {
        free(m_pszFileName);
    }

    if ( m_hSemaphore )
    {
        CloseHandle( m_hSemaphore );
    }

//    if( m_hLogFile )
//    {
//        CloseHandle( m_hLogFile );
//    }

    TraceFunctLeave();
}


 /*
 *    Init method
 */

DWORD CEventLogger::Init(LPCTSTR szFileName, DWORD dwLogLevel) 
{
    TCHAR   szBuf[MAX_BUFFER];
    TCHAR   *pTemp;

    TraceFunctEnter("Init");

    //Set the logging level
    m_dwLoggingLevel = dwLogLevel;

    //Get our own copy of the file name
    m_pszFileName = _tcsdup( szFileName );
    


    if(!m_pszFileName)
    {
        _ASSERT(0);
        TraceFunctLeave();
        return(ERROR_INVALID_PARAMETER);
    }
    

    //brijeshk: open and close file everytime we want to log
//    if( (m_hLogFile = CreateFile(m_pszFileName,
//                                 GENERIC_READ | GENERIC_WRITE,
//                                 FILE_SHARE_READ | FILE_SHARE_WRITE, 
//                                 NULL, //  security attributes
//                                 OPEN_ALWAYS,
//                                 FILE_FLAG_RANDOM_ACCESS,
//                                 NULL) // template file
//                                 ) == INVALID_HANDLE_VALUE)
//    {
//        DWORD dwError;
//        dwError = GetLastError();
//        DebugTrace( TRACE_FILEID,  "CreateFile Failed 0x%x", dwError);
//        TraceFunctLeave();
//        return(dwError);
//    }

    // fix the semaphore name problem -- all uppercase, remove backslashes
    _tcscpy( szBuf, m_pszFileName );
    CharUpper( szBuf );
    pTemp = szBuf;
    while( *pTemp != 0 )
    {
        if( *pTemp == _TEXT('\\') )
        {
            *pTemp = _TEXT(' ');
        }
        pTemp++;
    }


    // create the semaphore, it if dosn't already exist, we are the first
    // logger app created.. so we can prune the logfile if needed.
    if( (m_hSemaphore = CreateSemaphore(NULL, 0,1,szBuf)) == NULL )
    {
        DWORD dwError;
        dwError = GetLastError();
		// NOT 64-bits complaint!!        DebugTrace( TRACE_FILEID,"CreateSemaphore Failed 0x%x",dwError);
        TraceFunctLeave();
        return(dwError);
    }
    
    // we now know we are the first process to open the file
    if( GetLastError() != ERROR_ALREADY_EXISTS )
    {

        /*
         *    This is the place where we should "trim" the file.
         *
         */
        TruncateFileSize();
        
        ReleaseSemaphore( m_hSemaphore, 1, NULL );
    
    }        


    TraceFunctLeave();
    return(ERROR_SUCCESS);
    
}


/*
 *    Init Method
 */

DWORD CEventLogger::Init(LPCTSTR szFileName) 
{
   
    
    return( Init(szFileName,LEVEL_NORMAL) );

}


DWORD WINAPI ShowDialogBox( LPVOID lpParameter)   // thread data
{
    MessageBox(NULL,
               (TCHAR *)lpParameter,
               _TEXT("Windows System File Protection"),
               MB_ICONEXCLAMATION | MB_OK );


    free( lpParameter );
    return ERROR_SUCCESS;
}

                                    // we log in ascii
DWORD CEventLogger::LogEvent(DWORD dwEventLevel, LPCTSTR pszEventDesc, BOOL fPopUp) 
{
    TCHAR szBuf[500];
    DWORD dwWritten;
    SYSTEMTIME SystemTime;
    DWORD dwError = ERROR_SUCCESS;
    HANDLE hLogFile = NULL;
    
    TraceFunctEnter("LogEvent");

    // brijeshk : open and close file everytime we log to it
    if( (hLogFile = CreateFile(m_pszFileName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE, 
                                 NULL, //  security attributes
                                 OPEN_ALWAYS,
                                 FILE_FLAG_RANDOM_ACCESS,
                                 NULL) // template file
                               ) == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        // NOT 64-bits complaint!! DebugTrace( TRACE_FILEID,  "CreateFile Failed 0x%x", dwError);
        goto exit;
    }

    
    if (!m_hSemaphore)
    {
        _ASSERT(0);
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if( dwEventLevel > m_dwLoggingLevel)
    {
        dwError = ERROR_SUCCESS;
        goto exit;
    }



    // Lets try to get ahold of the logfile
    if(WaitForSingleObject( m_hSemaphore, 900 ) == WAIT_TIMEOUT ) 
    {
        dwError = WAIT_TIMEOUT;
        goto exit;
    }

    __try {

        if( SetFilePointer(hLogFile, 0, 0, FILE_END ) == 0xFFFFFFFF ) 
        {
            // NOT 64-bits complaint!! DebugTrace(TRACE_FILEID,"SetFilePointer Failed 0x%x", GetLastError());
            dwError = GetLastError();
            goto exit;
        }


        GetLocalTime( &SystemTime );


        // LEVEL [wMonth/wDay/wYear wHour:wMinute] Message\n
        _stprintf(szBuf,_TEXT("%s [%02d/%02d/%d %02d:%02d:%02d:%03d] %s\r\n"),
                m_aszERROR_LEVELS[dwEventLevel],
                SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,
                SystemTime.wHour, SystemTime.wMinute,
                SystemTime.wSecond, SystemTime.wMilliseconds,
                pszEventDesc);


        if(WriteFile(hLogFile,
                     szBuf,
                     _tcslen(szBuf) * sizeof(TCHAR),
                     &dwWritten,
                     NULL) == 0) 
        {
            dwError = GetLastError();
            // NOT 64-bits complaint!! DebugTrace( TRACE_FILEID, "WriteFile Failed 0x%x", dwError);
            goto exit;
        }

    }

    __finally {
        ReleaseSemaphore( m_hSemaphore, 1, NULL );
    }

    
    // show a message
    if( fPopUp )
    {
        DWORD             dwThreadId;
        HANDLE            hThread;
        LPTSTR            pszTempStr=NULL;

        if( (pszTempStr = _tcsdup( pszEventDesc )) == NULL)
        {
            dwError = GetLastError();            
            // NOT 64-bits complaint!! ErrorTrace( TRACE_FILEID, "Error duplicating string for file popup ec: %d", dwError);
            dwError = ERROR_INTERNAL_ERROR;
            goto exit;
        }
        
        hThread = CreateThread( NULL,  // pointer to security attributes
                                0, // default initial thread stack size
                                (LPTHREAD_START_ROUTINE) ShowDialogBox,
                                 // pointer to thread function
                                (LPVOID)pszTempStr, //argument for new thread
                                0, // creation flags
                                &dwThreadId); // pointer to receive thread ID
        if (INVALID_HANDLE_VALUE != hThread)
        {
            CloseHandle(hThread);
        }
    }

exit:
    // brijeshk : open and close log file each time we log to it
    if (NULL != hLogFile && INVALID_HANDLE_VALUE != hLogFile)
    {
        CloseHandle(hLogFile);
    }
    
    TraceFunctLeave();
    return dwError;
}



/*
 *    If the file is bigger than 40k, cut off the begining to leave the last 20k
 *  of the file
 * --> the file should be locked at this point <--
 */

BOOL CEventLogger::TruncateFileSize()
{
    DWORD dwSize = 0, dwNewSize = 0;
    DWORD dwRead = 0, dwWritten = 0;
    LPTSTR pcStr = NULL, pcEnd = NULL, pData = NULL;
    HANDLE hLogFile = NULL;
    BOOL   fRc = TRUE;
    
    TraceFunctEnter("TruncateFileSize");

    // brijeshk : open the file as and when we need it
    if( (hLogFile = CreateFile(m_pszFileName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE, 
                                 NULL, //  security attributes
                                 OPEN_ALWAYS,
                                 FILE_FLAG_RANDOM_ACCESS,
                                 NULL) // template file
                                 ) == INVALID_HANDLE_VALUE)
    {
        DWORD dwError;
        dwError = GetLastError();
        // NOT 64-bits complaint!! DebugTrace( TRACE_FILEID,  "CreateFile Failed 0x%x", dwError);
        fRc = FALSE;
        goto exit;
    }

    
    dwSize = GetFileSize( hLogFile, NULL );

    if( dwSize < TRIM_AT_SIZE ) 
    {
        goto exit;
    }


    // goto the last portion of the file we want to preserve
    if (FALSE == SetFilePointer(hLogFile, 0-NEW_FILE_SIZE, 0, FILE_END))
    {
        DWORD dwError;
        dwError = GetLastError();
        // NOT 64-bits complaint!! ErrorTrace(TRACE_FILEID,  "SetFilePointer failed 0x%x", dwError);
        fRc = FALSE;
        goto exit;
    }        


    // allocate memory to store this block 
    pData = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, NEW_FILE_SIZE);
    if (NULL == pData)
    {
        // NOT 64-bits complaint!! ErrorTrace(TRACE_FILEID, "Out of memory");
        fRc = FALSE;
        goto exit;        
    }
    
    // read this block into memory
    if (FALSE == ReadFile(hLogFile, pData, NEW_FILE_SIZE, &dwRead, NULL) || 
        dwRead != NEW_FILE_SIZE)
    {
        DWORD dwError;
        dwError = GetLastError();
        // NOT 64-bits complaint!! ErrorTrace(TRACE_FILEID,  "ReadFile failed 0x%x", dwError);
        fRc = FALSE;
        goto exit;
    }        

    // set the beginning and end of the block
    pcStr = pData;
    pcEnd = (LPTSTR) pData + NEW_FILE_SIZE - 1;

    // move forward until we find a newline and then go one more!
    while( (pcStr != pcEnd) && *(pcStr++) != _TEXT('\r') );

    // this is a weird file- 20k and no newlines
    if( pcStr == pcEnd ) 
    {
        // NOT 64-bits complaint!! ErrorTrace(TRACE_FILEID,  "No newline found");
        fRc = FALSE;
        goto exit;
    }

    // skip the /n as well
    if (*pcStr == _TEXT('\n'))
    {
        pcStr++;
    }
    
    // close and open the file, purging everything in it
    if (FALSE == CloseHandle(hLogFile))
    {
        DWORD dwError;
        dwError = GetLastError();
        // NOT 64-bits complaint!! ErrorTrace( TRACE_FILEID,  "CloseHandle failed 0x%x", dwError);
        fRc = FALSE;
        goto exit;
    }
    
    hLogFile = NULL;
    
    if( (hLogFile = CreateFile(m_pszFileName,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE, 
                               NULL, //  security attributes
                               CREATE_ALWAYS, // lose everything inside
                               FILE_FLAG_RANDOM_ACCESS,
                               NULL) // template file
                             ) == INVALID_HANDLE_VALUE)
    {
        DWORD dwError;
        dwError = GetLastError();
        // NOT 64-bits complaint!! ErrorTrace( TRACE_FILEID,  "CreateFile Failed 0x%x", dwError);
        fRc = FALSE;
        goto exit;
    }

    
    // now write back this block
    
    // get the new size of the block
    dwNewSize = (DWORD)(pcEnd - pcStr + 1);

    if (FALSE == WriteFile(hLogFile, pcStr, dwNewSize, &dwWritten, NULL))
    {
        DWORD dwError;
        dwError = GetLastError();
        // NOT 64-bits complaint!! DebugTrace( TRACE_FILEID,  "WriteFile failed 0x%x", dwError);
        fRc = FALSE;
        goto exit;
    }
    

exit:
    if (pData)
    {
        HeapFree(GetProcessHeap(), 0, pData);
    }

    if (hLogFile != NULL && hLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hLogFile);
    }

    
    TraceFunctLeave();
    return fRc;
}


/*
 *    Error level indentifiers
 */

LPCTSTR CEventLogger::m_aszERROR_LEVELS[] = {
        "None    :",
        "CRITICAL:",
        "UNDEF   :",
        "NORMAL  :",
        "MINIMAL :",
        "DEBUG   :"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\yvals_nodll.h ===
/* yvals.h values header for Microsoft C/C++ */
#ifndef _YVALS
#define _YVALS
#include <use_ansi.h>

/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _CRTIMP */

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

 #pragma warning(4: 4018 4114 4146 4244 4245)
 #pragma warning(4: 4663 4664 4665)
 #pragma warning(disable: 4237 4284 4290 4514)
		/* NAMESPACE */
 #if defined(__cplusplus)
  #define _STD			std::
  #define _STD_BEGIN	namespace std {
  #define _STD_END		};
  #define _STD_USING
 #else
  #define _STD			::
  #define _STD_BEGIN
  #define _STD_END
 #endif /* __cplusplus */
_STD_BEGIN
		/* TYPE bool */
 #if defined(__cplusplus)
typedef bool _Bool;
 #endif /* __cplusplus */
		/* INTEGER PROPERTIES */
#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG	36
		/* STDIO PROPERTIES */
#define _Filet _iobuf

#ifndef _FPOS_T_DEFINED
#define _FPOSOFF(fp)	((long)(fp))
#endif /* _FPOS_T_DEFINED */

		/* NAMING PROPERTIES */
 #if defined(__cplusplus)
  #define _C_LIB_DECL extern "C" {
  #define _END_C_LIB_DECL }
 #else
  #define _C_LIB_DECL
  #define _END_C_LIB_DECL
 #endif /* __cplusplus */
#define _CDECL
		// CLASS _Lockit
 #if defined(__cplusplus)
class _Lockit
	{	// lock while object in existence
public:
  #ifdef _MT
   #define _LOCKIT(x)	lockit x
	_Lockit();
	~_Lockit();
  #else
   #define _LOCKIT(x)
	_Lockit()
		{}
	~_Lockit()
		{}
  #endif /* _MT */
	};
 #endif /* __cplusplus */
		/* MISCELLANEOUS MACROS */
#define _L(c)	L##c
#define _Mbstinit(x)	mbstate_t x = {0}
#define _MAX	_cpp_max
#define _MIN	_cpp_min
_STD_END
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _YVALS */

/*
 * Copyright (c) 1996 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\configuration.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Configuration.cpp

Abstract:
    This file contains the implementation of the ...

Revision History:
    Davide Massarenti   (Dmassare)  01/09/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

const MPC::Config::DefinitionOfTag* MPC::Config::DefinitionOfTag::FindSubTag( /*[in]*/ LPCWSTR szTag ) const
{
    const DefinitionOfTag** ptr = m_tblSubTags;

    if(ptr)
    {
        while(*ptr)
        {
            if(!MPC::StrICmp( (*ptr)->m_szTag, szTag ))
            {
                return (*ptr);
            }

            ptr++;
        }
    }

    return NULL;
}

const MPC::Config::DefinitionOfAttribute* MPC::Config::DefinitionOfTag::FindAttribute( /*[in]*/ XMLTypes xt, /*[in]*/ LPCWSTR szName ) const
{
    const DefinitionOfAttribute* ptr = m_tblAttributes;

    if(ptr)
    {
        while(ptr->m_xt != XT_invalid)
        {
            if(ptr->m_xt == xt)
            {
                if(ptr->m_xt == XT_value || !MPC::StrICmp( ptr->m_szName, szName )) return ptr;
            }

            ptr++;
        }
    }

    return NULL;
}

////////////////////////////////////////////////////////////////////////////////

void MPC::Config::ClearValue( /*[in]*/ TypeConstructor*             defType   ,
                              /*[in]*/ const DefinitionOfAttribute* defAttrib )
{
    {
        void*   data = defType->GetOffset( defAttrib->m_offset );
        VARTYPE dest;

        switch(defAttrib->m_mtType)
        {
        case MT_bool        : *(bool        *)data = false        ; break;
        case MT_BOOL        : *(BOOL        *)data = FALSE        ; break;
        case MT_VARIANT_BOOL: *(VARIANT_BOOL*)data = VARIANT_FALSE; break;
        case MT_int         : *(int         *)data = 0            ; break;
        case MT_long        : *(long        *)data = 0            ; break;
        case MT_DWORD       : *(DWORD       *)data = 0            ; break;
        case MT_float       : *(float       *)data = 0            ; break;
        case MT_double      : *(double      *)data = 0            ; break;
        case MT_DATE        : *(DATE        *)data = 0            ; break;
        case MT_DATE_US     : *(DATE        *)data = 0            ; break;
        case MT_DATE_CIM    : *(DATE        *)data = 0            ; break;
        case MT_CHAR        : *(CHAR        *)data = 0            ; break;
        case MT_WCHAR       : *(WCHAR       *)data = 0            ; break;
        case MT_BSTR        : *(CComBSTR    *)data = (LPCWSTR)NULL; break;
        case MT_string      : *(MPC::string *)data = ""           ; break;
        case MT_wstring     : *(MPC::wstring*)data = L""          ; break;
        case MT_bitfield    : *(DWORD       *)data = 0            ; break;
        }
    }

    if(defAttrib->m_fPresenceFlag)
    {
        bool* data = (bool*)defType->GetOffset( defAttrib->m_offsetPresence );

        *data = false;
    }
}

HRESULT MPC::Config::LoadValue( /*[in]*/     TypeConstructor*             defType   ,
                                /*[in]*/     const DefinitionOfAttribute* defAttrib ,
                                /*[in/out]*/ CComVariant&                 value     ,
                                /*[in]*/     bool                         fFound    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Config::LoadValue" );

    USES_CONVERSION;

    HRESULT hr;


    if(fFound)
    {
        void*   data = defType->GetOffset( defAttrib->m_offset );
        VARTYPE dest;


        switch(defAttrib->m_mtType)
        {
        case MT_bool        : dest = VT_BOOL   ; break;
        case MT_BOOL        : dest = VT_BOOL   ; break;
        case MT_VARIANT_BOOL: dest = VT_BOOL   ; break;
        case MT_int         : dest = VT_I4     ; break;
        case MT_long        : dest = VT_I4     ; break;
        case MT_DWORD       : dest = VT_I4     ; break;
        case MT_float       : dest = VT_R4     ; break;
        case MT_double      : dest = VT_R8     ; break;
        case MT_DATE        : dest = VT_ILLEGAL; break;
        case MT_DATE_US     : dest = VT_ILLEGAL; break;
        case MT_DATE_CIM    : dest = VT_ILLEGAL; break;
        case MT_CHAR        : dest = VT_BSTR   ; break;
        case MT_WCHAR       : dest = VT_BSTR   ; break;
        case MT_BSTR        : dest = VT_BSTR   ; break;
        case MT_string      : dest = VT_BSTR   ; break;
        case MT_wstring     : dest = VT_BSTR   ; break;
        case MT_bitfield    : dest = VT_BSTR   ; break;
        default             : __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
        }

		if(dest == VT_ILLEGAL)
		{
			LPCWSTR szDate;
			bool  	fCIM = false;
			LCID  	lcid = 0;

			__MPC_EXIT_IF_METHOD_FAILS(hr, value.ChangeType( VT_BSTR ));
			szDate = value.bstrVal; SANITIZEWSTR(szDate);

			switch(defAttrib->m_mtType)
			{
			case MT_DATE    : fCIM = false; lcid =  0; break;
			case MT_DATE_US : fCIM = false; lcid = -1; break;
			case MT_DATE_CIM: fCIM = true ; lcid =  0; break;
			}


			//
			// We try as much as we can to parse the date. First the expected format, then the US one, finally the user default.
			//
			if(FAILED(MPC::ConvertStringToDate( szDate, *(DATE*)data, /*fGMT*/false, fCIM, lcid )))
			{
				if(FAILED(MPC::ConvertStringToDate( szDate, *(DATE*)data, /*fGMT*/false, /*fCIM*/false, -1 )))
				{
					__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertStringToDate( szDate, *(DATE*)data, /*fGMT*/false, /*fCIM*/false, 0 ));
				}
			}
		}
		else
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, value.ChangeType( dest ));

        	switch(defAttrib->m_mtType)
        	{
        	case MT_bool        : *(bool        *)data =                (value.boolVal == VARIANT_TRUE) ? true : false; break;
        	case MT_BOOL        : *(BOOL        *)data =                (value.boolVal == VARIANT_TRUE) ? TRUE : FALSE; break;
        	case MT_VARIANT_BOOL: *(VARIANT_BOOL*)data =                 value.boolVal                                ; break;
        	case MT_int         : *(int         *)data =                 value.lVal                                   ; break;
        	case MT_long        : *(long        *)data =                 value.lVal                                   ; break;
        	case MT_DWORD       : *(DWORD       *)data =                 value.lVal                                   ; break;
        	case MT_float       : *(float       *)data =                 value.fltVal                                 ; break;
        	case MT_double      : *(double      *)data =                 value.dblVal                                 ; break;
        	case MT_CHAR        : *(CHAR        *)data =                 value.bstrVal ? ( CHAR)value.bstrVal[0] : 0  ; break;
        	case MT_WCHAR       : *(WCHAR       *)data =                 value.bstrVal ? (WCHAR)value.bstrVal[0] : 0  ; break;
        	case MT_BSTR        : *(CComBSTR    *)data =                 value.bstrVal                                ; break;
        	case MT_string      : *(MPC::string *)data =  OLE2A(SAFEBSTR(value.bstrVal))                              ; break;
        	case MT_wstring     : *(MPC::wstring*)data =        SAFEBSTR(value.bstrVal)                               ; break;

        	case MT_bitfield:
				__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertStringToBitField( value.bstrVal, *(DWORD*)data, defAttrib->m_Lookup, /*fUseTilde*/false ));
				break;
        	}
		}
    }

    if(defAttrib->m_fPresenceFlag)
    {
        bool* data = (bool*)defType->GetOffset( defAttrib->m_offsetPresence );

        *data = fFound;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Config::SaveValue( /*[in]*/  const TypeConstructor*       defType   ,
                                /*[in]*/  const DefinitionOfAttribute* defAttrib ,
                                /*[out]*/ CComVariant&                 value     ,
                                /*[out]*/ bool&                        fFound    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Config::SaveValue" );

    HRESULT hr;


    if(defAttrib->m_fPresenceFlag)
    {
        bool* data = (bool*)defType->GetOffset( defAttrib->m_offsetPresence );

        fFound = *data;
    }
    else
    {
        fFound = true;
    }

    value.Clear();

    if(fFound)
    {
        const void* data = defType->GetOffset( defAttrib->m_offset );
        VARTYPE     src;
		WCHAR       rgBuf[2];

        switch(defAttrib->m_mtType)
        {
        case MT_bool        : value.boolVal = *(bool        *)data ? VARIANT_TRUE : VARIANT_FALSE; src = VT_BOOL   ; break;
        case MT_BOOL        : value.boolVal = *(BOOL        *)data ? VARIANT_TRUE : VARIANT_FALSE; src = VT_BOOL   ; break;
        case MT_VARIANT_BOOL: value.boolVal = *(VARIANT_BOOL*)data                               ; src = VT_BOOL   ; break;
        case MT_int         : value.lVal    = *(int         *)data                               ; src = VT_I4     ; break;
        case MT_long        : value.lVal    = *(long        *)data                               ; src = VT_I4     ; break;
        case MT_DWORD       : value.lVal    = *(DWORD       *)data                               ; src = VT_I4     ; break;
        case MT_float       : value.fltVal  = *(float       *)data                               ; src = VT_R4     ; break;
        case MT_double      : value.dblVal  = *(double      *)data                               ; src = VT_R8     ; break;
        case MT_DATE        :                                                                    ; src = VT_ILLEGAL; break;
        case MT_DATE_US     :                                                                    ; src = VT_ILLEGAL; break;
        case MT_DATE_CIM    :                                                                    ; src = VT_ILLEGAL; break;
        case MT_CHAR        : rgBuf[0]      = *(CHAR        *)data; rgBuf[1] = 0; value = rgBuf  ; src = VT_BSTR   ; break;
        case MT_WCHAR       : rgBuf[0]      = *(WCHAR       *)data; rgBuf[1] = 0; value = rgBuf  ; src = VT_BSTR   ; break;
        case MT_BSTR        : value         = *(CComBSTR    *)data                               ; src = VT_BSTR   ; break;
        case MT_string      : value         = ((MPC::string *)data)->c_str()                     ; src = VT_BSTR   ; break;
        case MT_wstring     : value         = ((MPC::wstring*)data)->c_str()                     ; src = VT_BSTR   ; break;

		case MT_bitfield:
			{
				MPC::wstring strText;

				__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertBitFieldToString( *(DWORD*)data, strText, defAttrib->m_Lookup ));

				value = strText.c_str(); src = VT_BSTR;
			}
			break;

        default: __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
        }

		if(src == VT_ILLEGAL)
		{
			MPC::wstring strDate;
			bool  		 fCIM = false;
			LCID  		 lcid = 0;

			switch(defAttrib->m_mtType)
			{
			case MT_DATE    : fCIM = false; lcid =  0; break;
			case MT_DATE_US : fCIM = false; lcid = -1; break;
			case MT_DATE_CIM: fCIM = true ; lcid =  0; break;
			}

			__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertDateToString( *(DATE*)data, strDate, /*fGMT*/false, fCIM, lcid ));

			value = strDate.c_str();
		}
		else if(src != VT_BSTR)
		{
			value.vt = src;
			__MPC_EXIT_IF_METHOD_FAILS(hr, value.ChangeType( VT_BSTR ));
		}
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::Config::LoadNode( /*[in]*/ TypeConstructor*       defType ,
                               /*[in]*/ const DefinitionOfTag* defTag  ,
                               /*[in]*/ IXMLDOMNode*           xdn     )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Config::LoadNode" );

    HRESULT                      hr;
    const DefinitionOfTag*       defSubTag;
    const DefinitionOfAttribute* defAttrib;


    //
    // First of all, clean all the variables.
    //
    defAttrib = defTag->m_tblAttributes;
    if(defAttrib)
    {
        while(defAttrib->m_xt != XT_invalid)
        {
            ClearValue( defType, defAttrib );

            defAttrib++;
        }
    }


    //
    // Load all the attributes.
    //
    {
        CComPtr<IXMLDOMNamedNodeMap> xdnnmAttribs;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xdn->get_attributes( &xdnnmAttribs ));
        if(xdnnmAttribs)
        {
            while(1)
            {
                CComPtr<IXMLDOMNode>        xdnNode;
                CComQIPtr<IXMLDOMAttribute> xdaAttrib;

                __MPC_EXIT_IF_METHOD_FAILS(hr, xdnnmAttribs->nextNode( &xdnNode ));
                if(xdnNode == NULL) break;

                if((xdaAttrib = xdnNode))
                {
                    CComBSTR bstrName;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, xdaAttrib->get_name( &bstrName ));

                    defAttrib = defTag->FindAttribute( XT_attribute, SAFEBSTR( bstrName ) );
                    if(defAttrib)
                    {
                        CComVariant value;

                        __MPC_EXIT_IF_METHOD_FAILS(hr, xdaAttrib->get_value( &value ));

                        __MPC_EXIT_IF_METHOD_FAILS(hr, LoadValue( defType, defAttrib, value, true ));
                    }
                }
            }
        }
    }

    //
    // Load the node as value.
    //
    defAttrib = defTag->FindAttribute( XT_value, NULL );
    if(defAttrib)
    {
        MPC::XmlUtil xml( xdn );
        CComVariant  value;
        bool         fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( NULL, value, fFound ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, LoadValue( defType, defAttrib, value, fFound ));
    }

    //
    // Load all subnodes.
    //
    if(defTag->m_tblSubTags)
    {
        CComPtr<IXMLDOMNode> xdnChild;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xdn->get_firstChild( &xdnChild ));
        while(xdnChild)
        {
            CComPtr<IXMLDOMNode> xdnSibling;
            CComBSTR             bstrName;

            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnChild->get_nodeName( &bstrName ));

            defAttrib = defTag->FindAttribute( XT_element, SAFEBSTR( bstrName ) );
            if(defAttrib)
            {
				MPC::XmlUtil xml( xdnChild );
				CComVariant  value;
				bool         fFound;

				__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( NULL, value, fFound ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, LoadValue( defType, defAttrib, value, fFound ));
            }

            defSubTag = defTag->FindSubTag( SAFEBSTR( bstrName ) );
            if(defSubTag)
            {
                TypeConstructor* defSubType;

                __MPC_EXIT_IF_METHOD_FAILS(hr, defType->CreateInstance( defSubTag, defSubType ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, defSubType->LoadNode( xdnChild ));
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnChild->get_nextSibling( &xdnSibling ));
            xdnChild = xdnSibling;
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Config::LoadXmlUtil( /*[in]*/ TypeConstructor* defType ,
								  /*[in]*/ MPC::XmlUtil&    xml     )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Config::LoadXmlUtil" );

    HRESULT              hr;
	CComPtr<IXMLDOMNode> xdnRoot;


	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetRoot( &xdnRoot ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, defType->LoadNode( xdnRoot ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Config::LoadStream( /*[in]*/ TypeConstructor* defType ,
                                 /*[in]*/ IStream*         pStream )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Config::LoadStream" );

    HRESULT      hr;
    MPC::XmlUtil xml;
    bool         fFound;
    bool         fLoaded;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.LoadAsStream( pStream, defType->GetTag(), fLoaded, &fFound ));
    if(fFound)
    {
		__MPC_EXIT_IF_METHOD_FAILS(hr, LoadXmlUtil( defType, xml ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Config::LoadFile( /*[in]*/ TypeConstructor* defType ,
                               /*[in]*/ LPCWSTR          szFile  )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Config::LoadFile" );

    HRESULT      hr;
    MPC::XmlUtil xml;
    MPC::wstring strFileOrig( szFile ); strFileOrig += L".orig";
    bool         fFound;
    bool         fLoaded;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.Load( szFile, defType->GetTag(), fLoaded, &fFound ));
    if(fFound == false)
    {
        //
        // If fails, try to load "<file>.orig"
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.Load( strFileOrig.c_str(), defType->GetTag(), fLoaded, &fFound ));
    }

    if(fFound && fLoaded)
    {
		__MPC_EXIT_IF_METHOD_FAILS(hr, LoadXmlUtil( defType, xml ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::Config::SaveNode( /*[in]*/ const TypeConstructor* defType ,
                               /*[in]*/ const DefinitionOfTag* defTag  ,
                               /*[in]*/ IXMLDOMNode*           xdn     )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Config::SaveNode" );

    HRESULT                      hr;
    const DefinitionOfAttribute* defAttrib;


    defAttrib = defTag->m_tblAttributes;
    if(defAttrib)
    {
        MPC::XmlUtil xml( xdn );

        while(defAttrib->m_xt != XT_invalid)
        {
			CComVariant value;
			bool        fFound;

			__MPC_EXIT_IF_METHOD_FAILS(hr, SaveValue( defType, defAttrib, value, fFound ));
			if(fFound)
			{
				if(defAttrib->m_xt == XT_attribute)
				{
                    CComPtr<IXMLDOMAttribute> xdaAttrib;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, defAttrib->m_szName, &xdaAttrib, fFound ));
                    if(fFound)
                    {
                        __MPC_EXIT_IF_METHOD_FAILS(hr, xdaAttrib->put_value( value ));
                    }
                }
				else if(defAttrib->m_xt == XT_value)
				{
                    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutValue( NULL, value, fFound ));
				}
				else if(defAttrib->m_xt == XT_element)
				{
                    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutValue( defAttrib->m_szName, value, fFound ));
				}
            }

            defAttrib++;
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Config::SaveSubNode( /*[in]*/ const TypeConstructor* defType ,
                                  /*[in]*/ IXMLDOMNode*           xdn     )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Config::SaveSubNode" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> xdnChild;
    MPC::XmlUtil         xml( xdn );


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( defType->GetTag(), &xdnChild ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, defType->SaveNode( xdnChild ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Config::SaveXmlUtil( /*[in ]*/ const TypeConstructor* defType ,
								  /*[out]*/ MPC::XmlUtil&          xml     )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Config::SaveXmlUtil" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> xdnRoot;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.New( defType->GetTag() ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetRoot( &xdnRoot ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, defType->SaveNode( xdnRoot ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Config::SaveStream( /*[in]*/ const TypeConstructor*  defType  ,
                                 /*[in]*/ IStream*               *ppStream )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Config::SaveStream" );

    HRESULT      hr;
    MPC::XmlUtil xml;


	__MPC_EXIT_IF_METHOD_FAILS(hr, SaveXmlUtil( defType, xml ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.SaveAsStream( (IUnknown**)ppStream ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Config::SaveFile( /*[in]*/ const TypeConstructor* defType ,
                               /*[in]*/ LPCWSTR                szFile  )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Config::SaveFile" );

    HRESULT      hr;
    MPC::XmlUtil xml;
    MPC::wstring strFileNew ( szFile ); strFileNew  += L".new";
    MPC::wstring strFileOrig( szFile ); strFileOrig += L".orig";


	__MPC_EXIT_IF_METHOD_FAILS(hr, SaveXmlUtil( defType, xml ));


    //
    // First of all, delete "<file>.new" and recreate it.
    //
    ::SetFileAttributesW( strFileNew.c_str(), FILE_ATTRIBUTE_NORMAL );
    ::DeleteFileW       ( strFileNew.c_str()                        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.Save( strFileNew.c_str() ));

    //
    // Then move "<file>" to "<file>.orig"
    //
    ::SetFileAttributesW( szFile             , FILE_ATTRIBUTE_NORMAL );
    ::SetFileAttributesW( strFileOrig.c_str(), FILE_ATTRIBUTE_NORMAL );
    ::DeleteFileW       ( strFileOrig.c_str()                        );
    if(::MoveFileW( szFile, strFileOrig.c_str() ) == FALSE)
    {
        DWORD dwRes = ::GetLastError();

        if(dwRes != ERROR_FILE_NOT_FOUND)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
        }
    }

    //
    // Then rename "<file>.new" to "<file>"
    //
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::MoveFileW( strFileNew.c_str(), szFile ));

    //
    // Finally delete "<file>.orig"
    //
    (void)::DeleteFileW( strFileOrig.c_str() );


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\htmlutil.cpp ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    HtmlUtil.cpp

Abstract:
    This file contains the implementation of various functions and classes
    designed to help the handling of HTML elements.

Revision History:
    Davide Massarenti   (Dmassare)  07/11/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

void MPC::HTML::QuoteEscape( /*[out]*/ MPC::wstring& strAppendTo ,
                             /*[in]*/  LPCWSTR       szToEscape  ,
                             /*[in]*/  WCHAR         chQuote     )
{
    if(szToEscape)
    {
        WCHAR ch;

        while((ch = *szToEscape++))
        {
            if(ch == chQuote || ch == '\\')
            {
                strAppendTo += '\\';
            }

            strAppendTo += ch;
        }
    }
}

void MPC::HTML::UrlUnescape( /*[out]*/ MPC::wstring& strAppendTo    ,
                             /*[in]*/  LPCWSTR       szToUnescape   ,
                             /*[in]*/  bool          fAsQueryString )
{
    if(szToUnescape)
    {
        WCHAR ch;

        while((ch = *szToUnescape++))
        {
            if(fAsQueryString && ch == '+')
            {
                strAppendTo += ' ';
            }
            else if(ch == '%')
            {
                int  iLen       = wcslen( szToUnescape );
                bool fFourDigit = (szToUnescape[0] == 'u');

                //
                // Do we have enough characters??
                //
                if(iLen >= (fFourDigit ? 5 : 2))
                {
                    if(fFourDigit)
                    {
                        ch = (HexToNum( szToUnescape[1] ) << 12) |
                             (HexToNum( szToUnescape[2] ) <<  8) |
                             (HexToNum( szToUnescape[3] ) <<  4) |
                              HexToNum( szToUnescape[4] );

                        szToUnescape += 5;
                    }
                    else
                    {
                        ch = (HexToNum( szToUnescape[0] ) << 4) |
                              HexToNum( szToUnescape[1] );

                        szToUnescape += 2;
                    }
                }

                if(ch) strAppendTo += ch;
            }
            else
            {
                strAppendTo += ch;
            }
        }
    }
}

void MPC::HTML::UrlEscape( /*[out]*/ MPC::wstring& strAppendTo    ,
                           /*[in]*/  LPCWSTR       szToEscape     ,
                           /*[in]*/  bool          fAsQueryString )
{
    // This is a bit field for the hex values: 00-29, 2C, 3A-3F, 5B-5E, 60, 7B-FF
    // These are the values escape encodes using the default mask (or mask >= 4)
    static const BYTE s_grfbitEscape[] =
    {
        0xFF, 0xFF, // 00 - 0F
        0xFF, 0xFF, // 10 - 1F
        0xFF, 0x13, // 20 - 2F
        0x00, 0xFC, // 30 - 3F
        0x00, 0x00, // 40 - 4F
        0x00, 0x78, // 50 - 5F
        0x01, 0x00, // 60 - 6F
        0x00, 0xF8, // 70 - 7F
        0xFF, 0xFF, // 80 - 8F
        0xFF, 0xFF, // 90 - 9F
        0xFF, 0xFF, // A0 - AF
        0xFF, 0xFF, // B0 - BF
        0xFF, 0xFF, // C0 - CF
        0xFF, 0xFF, // D0 - DF
        0xFF, 0xFF, // E0 - EF
        0xFF, 0xFF, // F0 - FF
    };
    static const WCHAR s_rgchHex[] = L"0123456789ABCDEF";

    ////////////////////

    if(szToEscape)
    {
        WCHAR ch;

        while((ch = *szToEscape++))
        {
            if(fAsQueryString && ch == ' ')
            {
                strAppendTo += '+';
            }
            else if(0 != (ch & 0xFF00))
            {
                strAppendTo += L"%u";
                strAppendTo += s_rgchHex[(ch >> 12) & 0x0F];
                strAppendTo += s_rgchHex[(ch >>  8) & 0x0F];
                strAppendTo += s_rgchHex[(ch >>  4) & 0x0F];
                strAppendTo += s_rgchHex[ ch        & 0x0F];
            }
            else if((s_grfbitEscape[ch >> 3] & (1 << (ch & 7))) || (fAsQueryString && ch == '+'))
            {
                strAppendTo += L"%";
                strAppendTo += s_rgchHex[(ch >>  4) & 0x0F];
                strAppendTo += s_rgchHex[ ch        & 0x0F];
            }
            else
            {
                strAppendTo += ch;
            }
        }
    }
}

void MPC::HTML::HTMLEscape( /*[out]*/ MPC::wstring& strAppendTo ,
                            /*[in]*/  LPCWSTR       szToEscape  )
{
    if(szToEscape)
    {
        WCHAR ch;

        while((ch = *szToEscape++))
        {
            switch(ch)
            {
            case '&': strAppendTo += L"&amp;" ; break;
            case '"': strAppendTo += L"&quot;"; break;
            case '<': strAppendTo += L"&lt;"  ; break;
            case '>': strAppendTo += L"&gt;"  ; break;
            default:  strAppendTo += ch       ; break;
            }
        }
    }
}


HRESULT MPC::HTML::ConstructFullTag( /*[out]*/ MPC::wstring&             strHTML           ,
                                     /*[in] */ LPCWSTR                   szTag             ,
                                     /*[in] */ bool                      fCloseTag         ,
                                     /*[in] */ const MPC::WStringLookup* pmapAttributes    ,
                                     /*[in] */ LPCWSTR                   szExtraAttributes ,
                                     /*[in] */ LPCWSTR                   szBody            ,
                                     /*[in] */ bool                      fEscapeBody       )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::ConstructFullTag" );

    HRESULT hr;
    size_t  iLen = szBody ? wcslen( szBody ) : 0;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szTag);
    __MPC_PARAMCHECK_END();



    //
    // Let's allocate enough storage for the common case, so we don't need to allocate at each append...
    //
    if(fEscapeBody) iLen *= 2;
    strHTML.reserve( 1024 + iLen );

    //
    // Opening tag.
    //
    strHTML.erase(); // We use 'erase' instead of an assignment, because 'erase' just resets the end of string...
    strHTML += L"<";
    strHTML += szTag;

    if(pmapAttributes)
    {
        MPC::WStringLookupIterConst it    = pmapAttributes->begin();
        MPC::WStringLookupIterConst itEnd = pmapAttributes->end  ();

        for(;it != itEnd; it++)
        {
            strHTML += L" ";
            strHTML += it->first;
            strHTML += L"=\"";

            QuoteEscape( strHTML, it->second.c_str(), '\"' ); //"

            strHTML += L"\"";
        }
    }

    if(szExtraAttributes)
    {
        strHTML += L" ";
        strHTML += szExtraAttributes;
    }

    strHTML += L">";

    //
    // Optional body.
    //
    if(szBody)
    {
        if(fEscapeBody)
        {
            HTMLEscape( strHTML, szBody );
        }
        else
        {
            strHTML += szBody;
        }
    }

    //
    // Optional closing tag.
    //
    if(fCloseTag)
    {
        strHTML += L"</";
        strHTML += szTag;
        strHTML += L">";
    }

    ////////////////////

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

void MPC::HTML::ParseHREF( /*[in] */ LPCWSTR             szText     ,
                           /*[out]*/ MPC::wstring&       strBaseURL ,
                           /*[out]*/ MPC::WStringLookup& mapQuery   )
{
    LPCWSTR szEnd;

    mapQuery.clear();

    SANITIZEWSTR(szText);

    szEnd = wcsrchr( szText, '?' );
    if(szEnd)
    {
        MPC::wstring            strRest( szEnd+1 );
        MPC::wstring::size_type iLen = strRest.size();

        //
        // Cut before the question mark.
        //
        strBaseURL = MPC::wstring( szText, szEnd );

        if(iLen)
        {
            MPC::wstring::size_type iStart = 0;
            MPC::wstring::size_type iEnd   = 0;
            MPC::wstring::size_type iMid;
            MPC::wstring            nameESCAPED;
            MPC::wstring            valueESCAPED;
            MPC::wstring            name;
            MPC::wstring            value;

            while(1)
            {
                iEnd = strRest.find( '&', iStart ); if(iEnd == strRest.npos) iEnd = iLen;
                iMid = strRest.find( '=', iStart );

                //
                // If we have an equality sign, split the query part into a name and value part, unescaping the value
                //
                if(iMid != strRest.npos && iMid++ < iEnd)
                {
                    nameESCAPED  = strRest.substr( iStart, (iMid-1) - iStart );
                    valueESCAPED = strRest.substr( iMid  ,  iEnd    - iMid   );
                }
                else
                {
                    nameESCAPED  = strRest.substr( iStart, iEnd - iStart );
                    valueESCAPED = L"";
                }

                //
                // Unescape everything.
                //
                name  = L""; UrlUnescape( name , nameESCAPED .c_str(), true );
                value = L""; UrlUnescape( value, valueESCAPED.c_str(), true );

                mapQuery[ name ] =  value;


                if(iEnd == iLen) break;

                iStart = iEnd + 1;
            }
        }
    }
    else
    {
        strBaseURL = szText;
    }
}

void MPC::HTML::BuildHREF( /*[out]*/ MPC::wstring&             strURL    ,
                           /*[in ]*/ LPCWSTR                   szBaseURL ,
                           /*[in ]*/ const MPC::WStringLookup& mapQuery  )
{
    bool fFirst = true;


    strURL = SAFEWSTR(szBaseURL);

    for(WStringLookupIterConst it=mapQuery.begin(); it!=mapQuery.end(); it++)
    {
        strURL += fFirst ? L"?" : L"&"; UrlEscape( strURL, it->first .c_str(), true );
        strURL += L"="                ; UrlEscape( strURL, it->second.c_str(), true );

        fFirst = false;
    }
}

void MPC::HTML::vBuildHREF( /*[out]*/ MPC::wstring& strURL    ,
                            /*[in ]*/ LPCWSTR       szBaseURL ,
                            /*[in ]*/               ...       )
{
    bool    fFirst = true;
    va_list arglist;
    LPCWSTR szName;
    LPCWSTR szValue;


    strURL = SAFEWSTR(szBaseURL);

    va_start( arglist, szBaseURL );
    while((szName  = va_arg(arglist,LPCWSTR)))
    {
        szValue = va_arg(arglist,LPCWSTR); if(!szValue) szValue = L"";

        strURL += fFirst ? L"?" : L"&"; UrlEscape( strURL, szName , true );
        strURL += L"="                ; UrlEscape( strURL, szValue, true );

        fFirst = false;
    }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::HTML::IDispatch_To_IHTMLDocument2( /*[out]*/ CComPtr<IHTMLDocument2>& doc   ,
                                                /*[in] */ IDispatch*               pDisp )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::IDispatch_To_IHTMLDocument2" );

    HRESULT hr;

    doc.Release();

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pDisp);
    __MPC_PARAMCHECK_END();


    //
    // The pointer passed as input can point to any of these things:
    //
    // 1) An IHTMLDocument2 itself.
    // 2) An IWebBrowser2.
    // 3) An IHTMLWindow2.
    // 3) An IHTMLElement.
    //
    if(FAILED(pDisp->QueryInterface( IID_IHTMLDocument2, (LPVOID*)&doc )))
    {
        //
        // Let's try IHTMLWindow2.
        //
        {
            CComPtr<IHTMLWindow2> win;

            if(SUCCEEDED(pDisp->QueryInterface( IID_IHTMLWindow2, (LPVOID*)&win )))
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, win->get_document( &doc ));

                if(doc == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);

                __MPC_EXIT_IF_METHOD_FAILS(hr, S_OK);
            }
        }

        //
        // Let's try IWebBrowser2 or IHTMLElement.
        //
        {
            CComPtr<IWebBrowser2> wb;
            CComPtr<IHTMLElement> elem;
            CComPtr<IDispatch>    docDisp;

            if(SUCCEEDED(pDisp->QueryInterface( IID_IWebBrowser2, (LPVOID*)&wb )))
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, wb->get_Document( &docDisp ));
            }
            else if(SUCCEEDED(pDisp->QueryInterface( IID_IHTMLElement, (LPVOID*)&elem )))
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, elem->get_document( &docDisp ));
            }

            if(docDisp == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);

            __MPC_EXIT_IF_METHOD_FAILS(hr, docDisp->QueryInterface( IID_IHTMLDocument2, (LPVOID*)&doc ));
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::HTML::GetFramePath( /*[out]*/ CComBSTR&  bstrFrame ,
                                 /*[in] */ IDispatch* pDisp     )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::GetFramePath" );

    HRESULT                 hr;
    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2>   pWin;
    CComPtr<IHTMLWindow2>   pTop;


    //
    // Get to the document and construct the recursive frame name.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, IDispatch_To_IHTMLDocument2( pDoc, pDisp ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pDoc->get_parentWindow( &pWin )); if(pWin == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    __MPC_EXIT_IF_METHOD_FAILS(hr, pWin->get_top         ( &pTop )); if(pTop == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);

    while(pWin != pTop)
    {
        CComPtr<IHTMLWindow2> pParent;
        CComBSTR              bstrName;

        pWin->get_name( &bstrName );

        //
        // Concatenate the frame names, backward.
        //
        if(bstrFrame.Length())
        {
            bstrName += L"/";
            bstrName += bstrFrame;
        }
        bstrFrame = bstrName;


        __MPC_EXIT_IF_METHOD_FAILS(hr, pWin->get_parent( &pParent ));

        if(pParent == NULL) break;

        pWin = pParent;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::HTML::AreAllTheFramesInTheCompleteState( /*[out]*/ bool&      fDone ,
                                                      /*[in] */ IDispatch* pDisp )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::AreAllTheFramesInTheCompleteState" );

    HRESULT                         hr;
    CComPtr<IHTMLDocument2>         pDoc;
    CComPtr<IHTMLFramesCollection2> pFrames;

    fDone = true;


    __MPC_EXIT_IF_METHOD_FAILS(hr, IDispatch_To_IHTMLDocument2( pDoc, pDisp ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pDoc->get_frames( &pFrames ));
    if(pFrames)
    {
        long len;

        __MPC_EXIT_IF_METHOD_FAILS(hr, pFrames->get_length( &len ));

        for(int i=0; i<len; i++)
        {
            CComVariant vIndex = i;
            CComVariant vValue;

            __MPC_EXIT_IF_METHOD_FAILS(hr, pFrames->item( &vIndex, &vValue ));

            if(vValue.vt == VT_DISPATCH)
            {
                CComQIPtr<IHTMLWindow2> fb = vValue.pdispVal;
                if(fb)
                {
                    CComPtr<IHTMLDocument2> pDoc2;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, fb->get_document( &pDoc2 ));
                    if(pDoc2)
                    {
                        CComBSTR bstrReadyState;

                        __MPC_EXIT_IF_METHOD_FAILS(hr, pDoc2->get_readyState( &bstrReadyState ));
                        if(MPC::StrICmp( bstrReadyState, L"complete" ) != 0)
                        {
                            fDone = false;
                            break;
                        }
                    }
                }
            }
        }
    }

    hr = S_OK;

    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::HTML::LocateFrame( /*[out]*/ CComPtr<IHTMLWindow2>& win    ,
                                /*[in]*/  IHTMLElement*          pObj   ,
                                /*[in]*/  LPCWSTR                szName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::LocateFrame" );

    HRESULT                 hr;
    CComPtr<IHTMLDocument2> doc;

    win.Release();


    __MPC_EXIT_IF_METHOD_FAILS(hr, IDispatch_To_IHTMLDocument2( doc, pObj ));

    if(szName && szName[0])
    {
        if(!_wcsicmp( szName, L"_top" ))
        {
            CComPtr<IHTMLWindow2> winCurrent;

            MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(winCurrent, doc       , parentWindow);
            MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(win       , winCurrent, top         );
        }
        else
        {
            CComPtr<IHTMLFramesCollection2> frames;
            CComVariant                     vName( szName );
            CComVariant                     vFrame;


			__MPC_EXIT_IF_METHOD_FAILS(hr, doc->get_frames( &frames ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, frames->item( &vName, &vFrame ));
            MPC_SCRIPTHELPER_FAIL_IF_NOT_AN_OBJECT(vFrame);

            __MPC_EXIT_IF_METHOD_FAILS(hr, vFrame.pdispVal->QueryInterface( __uuidof(IHTMLWindow2), (LPVOID*)&win ));
        }
    }
    else
    {
        MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(win, doc, parentWindow);
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::HTML::GetEventObject( /*[out]*/ CComPtr<IHTMLEventObj>& ev   ,
                                   /*[in] */ IHTMLElement*           pObj )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::GetEventObject" );

    HRESULT                 hr;
    CComPtr<IHTMLDocument2> doc;
    CComPtr<IHTMLWindow2>   win;

    ev.Release();

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pObj);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, IDispatch_To_IHTMLDocument2( doc, pObj ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, doc->get_parentWindow( &win )); if(win == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);

    MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(ev, win, event);

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::HTML::GetUniqueID( /*[out]*/ CComBSTR& bstrID, /*[in]*/ IHTMLElement* pObj )
{
    return MPC::COMUtil::GetPropertyByName( pObj, L"uniqueID", bstrID );
}


HRESULT MPC::HTML::FindFirstParentWithThisTag( /*[out]*/ CComPtr<IHTMLElement>& elem  ,
                                               /*[in] */ IHTMLElement*          pObj  ,
                                               /*[in]*/  LPCWSTR                szTag )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::FindFirstParentWithThisTag" );

    HRESULT hr;

    elem.Release();

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szTag);
    __MPC_PARAMCHECK_END();


    elem = pObj;
    while(elem)
    {
        CComBSTR              bstrTag;
        CComPtr<IHTMLElement> parent;

        __MPC_EXIT_IF_METHOD_FAILS(hr, elem->get_tagName( &bstrTag ));

        if(!MPC::StrICmp( bstrTag, szTag )) break;

        __MPC_EXIT_IF_METHOD_FAILS(hr, elem->get_parentElement( &parent ));
        elem = parent;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::HTML::FindFirstParentWithThisID( /*[out]*/ CComPtr<IHTMLElement>& elem ,
                                              /*[in] */ IHTMLElement*          pObj ,
                                              /*[in]*/  LPCWSTR                szID )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::FindFirstParentWithThisTag" );

    HRESULT hr;

    elem = pObj;
    while(elem)
    {
        CComBSTR              bstrID;
        CComPtr<IHTMLElement> parent;

        __MPC_EXIT_IF_METHOD_FAILS(hr, elem->get_id( &bstrID ));

        if(bstrID)
        {
            if(szID == NULL || !_wcsicmp( bstrID, szID ))
            {
                break;
            }
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, elem->get_parentElement( &parent ));
        elem = parent;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::HTML::FindElementInCollection( /*[out]*/ CComPtr<IHTMLElement>&  elem ,
                                            /*[in] */ IHTMLElementCollection* coll ,
                                            /*[in] */ LPCWSTR                 szID ,
                                            /*[in] */ int                     iPos )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::FindElementInCollection" );

    HRESULT            hr;
    CComPtr<IDispatch> disp;
    CComVariant        vName;
    CComVariant        vIndex;

    elem.Release();

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(coll);
    __MPC_PARAMCHECK_END();


    if(szID)
    {
        vName  = szID;
        vIndex = iPos;
    }
    else
    {
        vName  = iPos;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, coll->item( vName, vIndex, &disp ));
    if(disp)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, disp.QueryInterface( &elem ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::HTML::FindElement( /*[out]*/ CComPtr<IHTMLElement>& elem ,
                                /*[in] */ IHTMLElement*          pObj ,
                                /*[in] */ LPCWSTR                szID ,
                                /*[in] */ int                    iPos )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::FindElement" );

    HRESULT                         hr;
    CComPtr<IHTMLElementCollection> coll;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pObj);
    __MPC_PARAMCHECK_END();


    MPC_SCRIPTHELPER_GET_OBJECT__NOTNULL(coll, pObj, all);

    __MPC_SET_ERROR_AND_EXIT(hr, FindElementInCollection( elem, coll, szID, iPos ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::HTML::FindChild( /*[out]*/ CComPtr<IHTMLElement>& elem ,
                              /*[in] */ IHTMLElement*          pObj ,
                              /*[in] */ LPCWSTR                szID ,
                              /*[in] */ int                    iPos )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::FindChild" );

    HRESULT                         hr;
    CComPtr<IHTMLElementCollection> coll;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pObj);
    __MPC_PARAMCHECK_END();


    MPC_SCRIPTHELPER_GET_OBJECT__NOTNULL(coll, pObj, children);

    __MPC_SET_ERROR_AND_EXIT(hr, FindElementInCollection( elem, coll, szID, iPos ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::HTML::EnumerateCollection( /*[out]*/ IHTMLElementList&       lst        ,
                                        /*[in] */ IHTMLElementCollection* pColl      ,
                                        /*[in] */ LPCWSTR                 szFilterID )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::EnumerateCollection" );

    HRESULT     hr;
    long        lLen;
    long        lPos;
    CComVariant vName;
    CComVariant vIndex;
    bool        fFilterAsTag;

    MPC::ReleaseAll( lst );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pColl);
    __MPC_PARAMCHECK_END();


    if(szFilterID && szFilterID[0] == '<')
    {
        fFilterAsTag = true;

        szFilterID++;
    }
    else
    {
        fFilterAsTag = false;
    }


    MPC_SCRIPTHELPER_GET__DIRECT(lLen, pColl, length);

    for(lPos=0; lPos<lLen; lPos++)
    {
        CComPtr<IDispatch   > disp;
        CComPtr<IHTMLElement> elem;

        vName = lPos;

        __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->item( vName, vIndex, &disp ));
        if(disp == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_NOINTERFACE);

        __MPC_EXIT_IF_METHOD_FAILS(hr, disp.QueryInterface( &elem ));

        //
        // If we receive a string as input, filter out all the tags not matching with the ID or TAG.
        //
        if(szFilterID)
        {
            CComBSTR bstr;

            if(fFilterAsTag)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, elem->get_tagName( &bstr ));
            }
            else
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, elem->get_id( &bstr ));
            }


            if(MPC::StrICmp( bstr, szFilterID )) continue;
        }


        lst.push_back( elem.Detach() );
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::HTML::EnumerateElements( /*[out]*/ IHTMLElementList& lst        ,
                                      /*[in] */ IHTMLElement*     pObj       ,
                                      /*[in] */ LPCWSTR           szFilterID )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::EnumerateElements" );

    HRESULT                         hr;
    CComPtr<IHTMLElementCollection> coll;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pObj);
    __MPC_PARAMCHECK_END();


    MPC_SCRIPTHELPER_GET_OBJECT__NOTNULL(coll, pObj, all);

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnumerateCollection( lst, coll, szFilterID ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::HTML::EnumerateChildren( /*[out]*/ IHTMLElementList& lst        ,
                                      /*[in] */ IHTMLElement*     pObj       ,
                                      /*[in] */ LPCWSTR           szFilterID )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::EnumerateChildren" );

    HRESULT                         hr;
    CComPtr<IHTMLElementCollection> coll;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pObj);
    __MPC_PARAMCHECK_END();


    MPC_SCRIPTHELPER_GET_OBJECT__NOTNULL(coll, pObj, children);

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnumerateCollection( lst, coll, szFilterID ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::HTML::FindStyle( /*[out]*/ CComPtr<IHTMLRuleStyle>& style  ,
                              /*[in ]*/ IHTMLElement*            pObj   ,
                              /*[in ]*/ LPCWSTR                  szName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::FindStyle" );

    HRESULT                             hr;
    CComPtr<IHTMLDocument2>             doc;
    CComPtr<IHTMLStyleSheetsCollection> styles;
    VARIANT                             vIdx;
    long                                lNumStyles;

    __MPC_EXIT_IF_METHOD_FAILS(hr, IDispatch_To_IHTMLDocument2( doc, pObj ));

    MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(styles    , doc   , styleSheets);
    MPC_SCRIPTHELPER_GET__DIRECT         (lNumStyles, styles, length     );

    vIdx.vt = VT_I4;
    for(vIdx.iVal=0; vIdx.iVal<lNumStyles; vIdx.iVal++)
    {
        CComQIPtr<IHTMLStyleSheet> css;
        CComVariant                v;

        __MPC_EXIT_IF_METHOD_FAILS(hr, styles->item( &vIdx, &v ));
        if(v.vt == VT_DISPATCH && (css = v.pdispVal))
        {
			CComPtr<IHTMLStyleSheetRulesCollection> rules;
			long                                    lNumRules;

			MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(rules    , css  , rules );
			MPC_SCRIPTHELPER_GET__DIRECT         (lNumRules, rules, length);

			for(long l=0; l<lNumRules; l++)
			{
				CComPtr<IHTMLStyleSheetRule> rule;

				__MPC_EXIT_IF_METHOD_FAILS(hr, rules->item( l, &rule ));
				if(rule)
				{
					CComBSTR bstrName;

					MPC_SCRIPTHELPER_GET__DIRECT(bstrName, rule, selectorText);

					if(!MPC::StrICmp( bstrName, szName ))
					{
						__MPC_SET_ERROR_AND_EXIT(hr, rule->get_style( &style ));
					}
				}
			}
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::HTML::GetAttribute( /*[out]*/ CComPtr<IHTMLDOMAttribute>& attr   ,
                                 /*[in]*/  IHTMLElement*               pObj   ,
                                 /*[in]*/  LPCWSTR                     szName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::GetAttribute" );

    HRESULT                           hr;
    CComPtr<IHTMLDOMNode>             dom;
    CComPtr<IHTMLAttributeCollection> coll;
    CComPtr<IDispatch>                dispAttr;
    CComVariant                       v( szName );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pObj);
    __MPC_PARAMCHECK_END();


    attr.Release();


    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj->QueryInterface( IID_IHTMLDOMNode, (LPVOID *)&dom ));

    MPC_SCRIPTHELPER_GET_OBJECT__NOTNULL(coll, dom, attributes);

    __MPC_EXIT_IF_METHOD_FAILS(hr, coll->item( &v, &dispAttr ));
    if(dispAttr)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, dispAttr->QueryInterface( &attr ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::HTML::GetAttribute( /*[out]*/ CComBSTR&     value  ,
                                 /*[in]*/  IHTMLElement* pObj   ,
                                 /*[in]*/  LPCWSTR       szName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::GetAttribute" );

    HRESULT                    hr;
    CComPtr<IHTMLDOMAttribute> attr;


    value.Empty();


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetAttribute( attr, pObj, szName ));
    if(attr)
    {
        MPC_SCRIPTHELPER_GET_STRING__VARIANT(value, attr, nodeValue);
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

typedef struct
{
    const WCHAR* szName;
    DWORD        dwValue;
} COLORVALUE_PAIR;

static const COLORVALUE_PAIR c_rgColorNames[] =
{
    { L"aliceblue"           , 0xfff8f0 },
    { L"antiquewhite"        , 0xd7ebfa },
    { L"aqua"                , 0xffff00 },
    { L"aquamarine"          , 0xd4ff7f },
    { L"azure"               , 0xfffff0 },
    { L"beige"               , 0xdcf5f5 },
    { L"bisque"              , 0xc4e4ff },
    { L"black"               , 0x000000 },
    { L"blanchedalmond"      , 0xcdebff },
    { L"blue"                , 0xff0000 },
    { L"blueviolet"          , 0xe22b8a },
    { L"brown"               , 0x2a2aa5 },
    { L"burlywood"           , 0x87b8de },
    { L"cadetblue"           , 0xa09e5f },
    { L"chartreuse"          , 0x00ff7f },
    { L"chocolate"           , 0x1e69d2 },
    { L"coral"               , 0x507fff },
    { L"cornflowerblue"      , 0xed9564 },
    { L"cornsilk"            , 0xdcf8ff },
    { L"crimson"             , 0x3c14dc },
    { L"cyan"                , 0xffff00 },
    { L"darkblue"            , 0x8b0000 },
    { L"darkcyan"            , 0x8b8b00 },
    { L"darkgoldenrod"       , 0x0b86b8 },
    { L"darkgray"            , 0xa9a9a9 },
    { L"darkgreen"           , 0x006400 },
    { L"darkkhaki"           , 0x6bb7bd },
    { L"darkmagenta"         , 0x8b008b },
    { L"darkolivegreen"      , 0x2f6b55 },
    { L"darkorange"          , 0x008cff },
    { L"darkorchid"          , 0xcc3299 },
    { L"darkred"             , 0x00008b },
    { L"darksalmon"          , 0x7a96e9 },
    { L"darkseagreen"        , 0x8fbc8f },
    { L"darkslateblue"       , 0x8b3d48 },
    { L"darkslategray"       , 0x4f4f2f },
    { L"darkturquoise"       , 0xd1ce00 },
    { L"darkviolet"          , 0xd30094 },
    { L"deeppink"            , 0x9314ff },
    { L"deepskyblue"         , 0xffbf00 },
    { L"dimgray"             , 0x696969 },
    { L"dodgerblue"          , 0xff901e },
    { L"firebrick"           , 0x2222b2 },
    { L"floralwhite"         , 0xf0faff },
    { L"forestgreen"         , 0x228b22 },
    { L"fuchsia"             , 0xff00ff },
    { L"gainsboro"           , 0xdcdcdc },
    { L"ghostwhite"          , 0xfff8f8 },
    { L"gold"                , 0x00d7ff },
    { L"goldenrod"           , 0x20a5da },
    { L"gray"                , 0x808080 },
    { L"green"               , 0x008000 },
    { L"greenyellow"         , 0x2fffad },
    { L"honeydew"            , 0xf0fff0 },
    { L"hotpink"             , 0xb469ff },
    { L"indianred"           , 0x5c5ccd },
    { L"indigo"              , 0x82004b },
    { L"ivory"               , 0xf0ffff },
    { L"khaki"               , 0x8ce6f0 },
    { L"lavender"            , 0xfae6e6 },
    { L"lavenderblush"       , 0xf5f0ff },
    { L"lawngreen"           , 0x00fc7c },
    { L"lemonchiffon"        , 0xcdfaff },
    { L"lightblue"           , 0xe6d8ad },
    { L"lightcoral"          , 0x8080f0 },
    { L"lightcyan"           , 0xffffe0 },
    { L"lightgoldenrodyellow", 0xd2fafa },
    { L"lightgreen"          , 0x90ee90 },
    { L"lightgrey"           , 0xd3d3d3 },
    { L"lightpink"           , 0xc1b6ff },
    { L"lightsalmon"         , 0x7aa0ff },
    { L"lightseagreen"       , 0xaab220 },
    { L"lightskyblue"        , 0xface87 },
    { L"lightslategray"      , 0x998877 },
    { L"lightsteelblue"      , 0xdec4b0 },
    { L"lightyellow"         , 0xe0ffff },
    { L"lime"                , 0x00ff00 },
    { L"limegreen"           , 0x32cd32 },
    { L"linen"               , 0xe6f0fa },
    { L"magenta"             , 0xff00ff },
    { L"maroon"              , 0x000080 },
    { L"mediumaquamarine"    , 0xaacd66 },
    { L"mediumblue"          , 0xcd0000 },
    { L"mediumorchid"        , 0xd355ba },
    { L"mediumpurple"        , 0xdb7093 },
    { L"mediumseagreen"      , 0x71b33c },
    { L"mediumslateblue"     , 0xee687b },
    { L"mediumspringgreen"   , 0x9afa00 },
    { L"mediumturquoise"     , 0xccd148 },
    { L"mediumvioletred"     , 0x8515c7 },
    { L"midnightblue"        , 0x701919 },
    { L"mintcream"           , 0xfafff5 },
    { L"mistyrose"           , 0xe1e4ff },
    { L"moccasin"            , 0xb5e4ff },
    { L"navajowhite"         , 0xaddeff },
    { L"navy"                , 0x800000 },
    { L"oldlace"             , 0xe6f5fd },
    { L"olive"               , 0x008080 },
    { L"olivedrab"           , 0x238e6b },
    { L"orange"              , 0x00a5ff },
    { L"orangered"           , 0x0045ff },
    { L"orchid"              , 0xd670da },
    { L"palegoldenrod"       , 0xaae8ee },
    { L"palegreen"           , 0x98fb98 },
    { L"paleturquoise"       , 0xeeeeaf },
    { L"palevioletred"       , 0x9370db },
    { L"papayawhip"          , 0xd5efff },
    { L"peachpuff"           , 0xb9daff },
    { L"peru"                , 0x3f85cd },
    { L"pink"                , 0xcbc0ff },
    { L"plum"                , 0xdda0dd },
    { L"powderblue"          , 0xe6e0b0 },
    { L"purple"              , 0x800080 },
    { L"red"                 , 0x0000ff },
    { L"rosybrown"           , 0x8f8fbc },
    { L"royalblue"           , 0xe16941 },
    { L"saddlebrown"         , 0x13458b },
    { L"salmon"              , 0x7280fa },
    { L"sandybrown"          , 0x60a4f4 },
    { L"seagreen"            , 0x578b2e },
    { L"seashell"            , 0xeef5ff },
    { L"sienna"              , 0x2d52a0 },
    { L"silver"              , 0xc0c0c0 },
    { L"skyblue"             , 0xebce87 },
    { L"slateblue"           , 0xcd5a6a },
    { L"slategray"           , 0x908070 },
    { L"snow"                , 0xfafaff },
    { L"springgreen"         , 0x7fff00 },
    { L"steelblue"           , 0xb48246 },
    { L"tan"                 , 0x8cb4d2 },
    { L"teal"                , 0x808000 },
    { L"thistle"             , 0xd8bfd8 },
    { L"tomato"              , 0x4763ff },
    { L"turquoise"           , 0xd0e040 },
    { L"violet"              , 0xee82ee },
    { L"wheat"               , 0xb3def5 },
    { L"white"               , 0xffffff },
    { L"whitesmoke"          , 0xf5f5f5 },
    { L"yellow"              , 0x00ffff },
    { L"yellowgreen"         , 0x32cd9a }
};

static const COLORVALUE_PAIR c_rgSystemColors[] =
{
    { L"activeborder"         	, COLOR_ACTIVEBORDER            },
    { L"activecaption"        	, COLOR_ACTIVECAPTION           },
    { L"appworkspace"         	, COLOR_APPWORKSPACE            },
    { L"background"           	, COLOR_BACKGROUND              },
    { L"buttonface"           	, COLOR_BTNFACE                 },
    { L"buttonhighlight"      	, COLOR_BTNHIGHLIGHT            },
    { L"buttonshadow"         	, COLOR_BTNSHADOW               },
    { L"buttontext"           	, COLOR_BTNTEXT                 },
    { L"captiontext"          	, COLOR_CAPTIONTEXT             },
    { L"gradientactivecaption"	, COLOR_GRADIENTACTIVECAPTION   },
    { L"gradientinactivecaption", COLOR_GRADIENTINACTIVECAPTION },
    { L"graytext"             	, COLOR_GRAYTEXT                },
    { L"highlight"            	, COLOR_HIGHLIGHT               },
    { L"highlighttext"        	, COLOR_HIGHLIGHTTEXT           },
    { L"hotlight"        	    , COLOR_HOTLIGHT                },
    { L"inactiveborder"       	, COLOR_INACTIVEBORDER          },
    { L"inactivecaption"      	, COLOR_INACTIVECAPTION         },
    { L"inactivecaptiontext"  	, COLOR_INACTIVECAPTIONTEXT     },
    { L"infobackground"       	, COLOR_INFOBK                  },
    { L"infotext"             	, COLOR_INFOTEXT                },
    { L"menu"                 	, COLOR_MENU                    },
    { L"menutext"             	, COLOR_MENUTEXT                },
    { L"scrollbar"            	, COLOR_SCROLLBAR               },
    { L"threeddarkshadow"     	, COLOR_3DDKSHADOW              },
    { L"threedface"           	, COLOR_3DFACE                  },
    { L"threedhighlight"      	, COLOR_3DHIGHLIGHT             },
    { L"threedlightshadow"    	, COLOR_3DLIGHT                 },
    { L"threedshadow"         	, COLOR_3DSHADOW                },
    { L"window"               	, COLOR_WINDOW                  },
    { L"windowframe"          	, COLOR_WINDOWFRAME             },
    { L"windowtext"           	, COLOR_WINDOWTEXT              },
};

static const COLORVALUE_PAIR* local_LookupName( /*[in]*/ const COLORVALUE_PAIR* tbl    ,
												/*[in]*/ int                    iSize  ,
												/*[in]*/ LPCWSTR                szText )
{
	while(iSize-- > 0)
	{
		if(!_wcsicmp( tbl->szName, szText )) return tbl;

		tbl++;
	}

	return NULL;
}

bool MPC::HTML::ConvertColor( /*[in]*/ VARIANT& v, /*[out]*/ COLORREF& color, /*[out]*/ bool& fSystem )
{
	color   = RGB(255,255,255);
	fSystem = false;

	if(v.vt == VT_I4)
	{
		color = (COLORREF)v.iVal;

		return true;
	}

	if(v.vt == VT_BSTR && v.bstrVal)
	{
		const COLORVALUE_PAIR* ptr;

		ptr = local_LookupName( c_rgColorNames, ARRAYSIZE(c_rgColorNames), v.bstrVal );
		if(ptr)
		{
			color = (COLORREF)ptr->dwValue;

			return true;
		}

		ptr = local_LookupName( c_rgSystemColors, ARRAYSIZE(c_rgSystemColors), v.bstrVal );
		if(ptr)
		{
			color   = (COLORREF)::GetSysColor( ptr->dwValue );
			fSystem = true;

			return true;
		}

		if(v.bstrVal[0] == '#')
		{
			int iRED;
			int iGREEN;
			int iBLUE;

			if(swscanf( &v.bstrVal[1], L"%02x%02x%02x", &iRED, &iGREEN, &iBLUE ) == 3)
			{
				color = RGB( iRED, iGREEN, iBLUE );

				return true;
			}
		}
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\include\itss\msitstg.h ===
// MSITStg.h -- Interface declaration for IMSITStorage

#ifndef __MSITSTG_H__

#define __MSITSTG_H__

// Class ID for the ITSS File System:

DEFINE_GUID(CLSID_ITStorage, 
0x5d02926a, 0x212e, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Inteface ID for the IITStorage interface:

DEFINE_GUID(IID_ITStorage, 
0x88cc31de, 0x27ab, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IITStorageEx interface:

DEFINE_GUID(IID_ITStorageEx, 
0xe74097b0, 0x292d, 0x11d1, 0xb6, 0x7e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

// Class ID for the FSStorage wrapper for the Win32 file system:

// {D54EEE56-AAAB-11d0-9E1D-00A0C922E6EC}
DEFINE_GUID(CLSID_IFSStorage, 
0xd54eee56, 0xaaab, 0x11d0, 0x9e, 0x1d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IFSStorage interface:

// {8BB2438A-A70C-11d0-9E1C-00A0C922E6EC}
DEFINE_GUID(IID_IFSStorage, 
0x8bb2438a, 0xa70c, 0x11d0, 0x9e, 0x1c, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStream interface

DEFINE_GUID(IID_IStreamITEx, 
0xeb19b681, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStorage interface

DEFINE_GUID(IID_IStorageITEx, 
0xeb19b680, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the Data Space Manager used within an ITStorage object:

DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the plug-in data transforms:

DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the File Finder interface (used with URLs):

DEFINE_GUID(IID_IITFileFinder, 
0x77231260, 0x19c0, 0x11d1, 0xb6, 0x6e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

/*

The IITStorage interface parallels the API's defined for creating and
opening Docfiles. So if you have code that currently uses Docfiles for 
your storage mechanism, you can easily convert over to using ITS files 
instead. 

ITS files use a different on-disk structure to optimize them for very 
fast stream access and very low overhead. ITS files can manage thousands 
or millions of streams with very good access performance and very small 
directory space requirements. This makes ITS files ideal for CD-Roms and
for data collections that you'll download across the Internet. 

To make the conversion to ITS files you'll need to call CoCreateInstance 
with the class-id CLSID_ITStorage and the interface-id IID_ITStorage. You'll 
get back an interface pointer, say pItStg. Then you'll need to adjust the
places where your code creates or opens Docfiles. Instead of StgCreateDocfile
you'll call pItStg->StgCreateDocfile, and instead of StgOpenStorage, you'll
call pItStg->StgOpenStorage. In both cases you'll get back an IStorage 
interface pointer, say pIStg, which you can use just as you did before.

That's it. In general the rest of your code shouldn't have to change. There 
are some functional difference between ITS files and Docfiles -- ITS files
don't support STGM_TRANSACTED, for example. So if you have to have transacted 
file operations, you can't use ITS files -- at least for now. However in
almost all other respects ITS files interfaces can directly replace Docfile
interfaces.

Converting your data is also easy. Just open one of  your Docfiles using
StgOpenStorage, create a new ITS file via pItStg->StgCreateDocfile, and then
use the CopyTo interface to copy your data objects and their storage heirarchy
over to the ITS file:
    
    pStgDocfile->CopyTo(0, NULL, NULL, pStgITS);

In some cases you may want to exercise some control over the internal parameters
kept in an ITS file. You do this by calling SetControlData to give the IITStorage
interface a block of ITS control data. Then each subsequent call to StgCreateDocfile
will use that control data. The ITS control data determines, among other things,
the tradeoff between efficient random access to the stream data and minimizing the
size of an ITS file.  

The actual structure and interpretation of ITS control data is documented below.
(See the ITSFS_Control_Data data type). You can get default control data via the
DefaultControlData fuction. Note that DefaultControlData allocates the control
structure using IMalloc::Alloc as provided by CoGetMalloc and expects that your code will
deallocate the structure using the IMalloc::Free.

 */

// IID_IStreamITEx interface declaration:

DECLARE_INTERFACE_(IStreamITEx, IStream)
{
    // IStreamITEx methods
    
    STDMETHOD(SetDataSpaceName)(const WCHAR   * pwcsDataSpaceName) PURE;
    STDMETHOD(GetDataSpaceName)(       WCHAR **ppwcsDataSpaceName) PURE;

    STDMETHOD(Flush)() = 0;
};

// IID_IStorageITEx interface declaration:

DECLARE_INTERFACE_(IStorageITEx, IStorage)
{
    // IStorageITEx methods:

    STDMETHOD(GetCheckSum)(ULARGE_INTEGER *puli) PURE;
    STDMETHOD(CreateStreamITEx)(const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
                            DWORD grfMode, DWORD reserved1, DWORD reserved2, 
                            IStreamITEx ** ppstm
                           ) PURE;
    STDMETHOD(OpenStreamITEx)(const WCHAR * pwcsName, void * reserved1, DWORD grfMode, 
                          DWORD reserved2, IStreamITEx ** ppstm) PURE;
};

// IStorageITEx::CreateStream lets you specify the data space in which a stream
// is to be created. Currently two dataspaces are supported:
//
//    L"Uncompressed" -- This dataspace applies no compression.
//    L"MSCompressed" -- This dataspace applies a default compression transform.


#pragma warning( disable : 4200)

// ITS_Control_Data is the generic structure of control data passed to the 
// IITStorage::SetControlData method or returned by the IITStorage::DefaultControlData
// method.

typedef struct _ITS_Control_Data
{
    UINT cdwControlData;     // Number of DWords to follow.
    UINT adwControlData[0];  // Actually this will be adwControlData[cdwControlData]

} ITS_Control_Data, *PITS_Control_Data;  


// ITSFS_Control_Data is the actual prefix structure of control data for IITStorage. 

typedef struct _ITSFS_Control_Data
{
    UINT cdwFollowing;     // Must be 6 or 13

    DWORD cdwITFS_Control; // Must be 5
    DWORD dwMagic;         // Must be MAGIC_ITSFS_CONTROL (see below)
    DWORD dwVersion;       // Must be 1
    DWORD cbDirectoryBlock;// Size in bytes of directory blocks (Default is 8192)
    DWORD cMinCacheEntries;// Least upper bound on the number of directory blocks
	                       // which we'll cache in memory. (Default is 20)
    DWORD fFlags;          // Control bit flags (see below). 
	                       // Default value is fDefaultIsCompression.

} ITSFS_Control_Data, *PITSFS_Control_Data;

// Signature value for ITSFS_Control_Data

const DWORD MAGIC_ITSFS_CONTROL    = 'I' | ('T' << 8) | ('S' << 16) | ('C' << 24);

// Bit flag definitions for ITSFS_Control_Data::fFlags

const DWORD fDefaultIsCompression  = 0x00000001;
const DWORD fDefaultIsUncompressed = 0x00000000;

// Note all other fFlags bits positions are reserved for future releases and should be 
// set to zero.

// When ITSFS_Control_Data::cdwFollowing is > 6, we assume that LZX_Control_Data follows
// immediately after. (See the XformControlData type below) LZX_Control_Data defines
// parameters which control the default compressed data space. 
//
// If ITSFS_Control_Data::cdwFollowing is 6, we use default values for the LZX
// control data.

typedef struct _LZX_Control_Data
{
    UINT  cdwControlData; // Must be 6

    DWORD dwLZXMagic;     // Must be LZX_MAGIC (see below)
    DWORD dwVersion;      // Must be 2
    DWORD dwMulResetBlock;// Number of blocks between compression resets.  (Default: 4)
    DWORD dwMulWindowSize;// Maximum number of blocks kept in data history (Default: 4)
    DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
    DWORD dwOptions;  // Option flags (Default: fOptimizeCodeStreams)

} LZX_Control_Data, *PLZX_Control_Data;

// Note: The block size for LZX compression is 32768 bytes.

const DWORD LZX_MAGIC           = 'L' | ('Z' << 8 ) | ('X' << 16) | ('C' << 24);

// Values for LZX_Control_Data::dwOptions

const DWORD fOptimizeCodeStreams = 0x00000001;

// Note that all other flag bit positions are reserved for future releases and should be
// set to zero.


// The second parameter for the IITStorage::Compact method below is an enueration
// which defines the level of compaction to do.

typedef enum ECompactionLev {COMPACT_DATA=0, COMPACT_DATA_AND_PATH} ;

DECLARE_INTERFACE_(IITStorage, IUnknown)
{
    // IITStorage methods

    STDMETHOD(StgCreateDocfile)(const WCHAR * pwcsName, DWORD grfMode, 
                                DWORD reserved, IStorage ** ppstgOpen
                               ) PURE;

    STDMETHOD(StgCreateDocfileOnILockBytes)(ILockBytes * plkbyt, DWORD grfMode,
                                            DWORD reserved, IStorage ** ppstgOpen
                                           ) PURE;

    STDMETHOD(StgIsStorageFile)(const WCHAR * pwcsName) PURE;

    STDMETHOD(StgIsStorageILockBytes)(ILockBytes * plkbyt) PURE;

    STDMETHOD(StgOpenStorage)(const WCHAR * pwcsName, IStorage * pstgPriority, 
                              DWORD grfMode, SNB snbExclude, DWORD reserved, 
                              IStorage ** ppstgOpen
                             ) PURE;

    STDMETHOD(StgOpenStorageOnILockBytes)
                  (ILockBytes * plkbyt, IStorage * pStgPriority, DWORD grfMode, 
                   SNB snbExclude, DWORD reserved, IStorage ** ppstgOpen
                  ) PURE;

    STDMETHOD(StgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                           FILETIME const * patime, FILETIME const * pmtime
                          ) PURE;

    STDMETHOD(SetControlData)(PITS_Control_Data pControlData) PURE;

    STDMETHOD(DefaultControlData)(PITS_Control_Data *ppControlData) PURE;
		
    STDMETHOD(Compact)(const WCHAR * pwcsName, ECompactionLev iLev) PURE;
};

DECLARE_INTERFACE_(IITStorageEx, IITStorage)
{
    STDMETHOD(StgCreateDocfileForLocale)
        (const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(StgCreateDocfileForLocaleOnILockBytes)
        (ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(QueryFileStampAndLocale)(const WCHAR *pwcsName, DWORD *pFileStamp, 
                                                              DWORD *pFileLocale) PURE;
    
    STDMETHOD(QueryLockByteStampAndLocale)(ILockBytes * plkbyt, DWORD *pFileStamp, 
                                                                DWORD *pFileLocale) PURE;
};

typedef IITStorage *PIITStorage;

DECLARE_INTERFACE_(IFSStorage, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)  (THIS_ REFIID, VOID **) PURE;
    STDMETHOD_(ULONG, AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IFSStorage methods

    STDMETHOD(FSCreateStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSOpenStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSCreateStream)(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateTemporaryStream)(IStream **ppStrm) PURE;
    STDMETHOD(FSOpenStream  )(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateLockBytes)(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;
    STDMETHOD(FSCreateTemporaryLockBytes)(ILockBytes **ppLkb) PURE;
    STDMETHOD(FSOpenLockBytes  )(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;

    STDMETHOD(FSStgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                             FILETIME const * patime, FILETIME const * pmtime
                            ) PURE;
};

typedef IFSStorage *PIFSStorage;

/*
**   Data Spaces -- What they are.

Within an ITS file we store information in one or more data spaces. A data space
is a container which holds the bits which represent a collection of streams. Each
data space has a name and an associated collection of transforms.

Those transforms take the raw data which you write to an ITS stream and map it into
a representation stream. When you read from an ITS stream they do the reverse mapping
to reconstruct your original data from the representation. 

When you first create an ITS file, it contains one data space named "Default_Space"
which applies the LZX data compression transform. By default all of the streams you
create will have their data representations stored in the default data space.

If LZX compression meets your needs, and you're not concerned about data enciphering,
you can skip over the following discussion. If, on the other hand, you want to 
create additional data spaces or transforms, read on.

To create a data space, you must first get a pointer to the IDataSpaceManager interface.
Just do a QueryInterface for IID_DataSpaceManager from any storage created by the 
IITStorage interface. Then you can call the CreateDataSpace function to define a new
data space. 

When you're defining a collection of data spaces, be sure that their names are distinct.
Defining two data spaces with the same name is an error. Data space names follow the
rules for stream names. That is, they must be less than 260 characters long, and may
not contain the characters '/'. '\', '|', ':', or any character less than 0x0020.

Data spaces are kept in a separate name space. So you don't have to worry about
colliding with a stream name or a storage name. As noted above, we have defined one
special data space ("Default_Space") where all data resides if you take no action.

You can redefine that default space simply by creating a new data space with the
name "Default_Space". This is the one case where a name collision is allowed. If 
you do redefine the default data space, any data in the old space will automatically
be transformed appropriately and moved into the new default data space.  

**   Importing Items

If you have defined additional data spaces, the next step is to define which streams
and storages you want to move into the new data spaces. You do that by means of the 
IDataSpace::Import function. For example suppose you've defined the dataspace 
*pMyDataSpace and you want to import the stream "Alpha" contained in the storage 
*pThatStorage:

    pMyDataSpace->Import(pThatStorage, "Alpha");

Similarly if you want to import the storage "HTML_Pages" from pThisStorage:

    pMyDataSpace->Import(pThisStorage, "HTML_Pages");

That will recursively import the "HTML_Pages" storage and all of the streams and 
storages contained within it. It also conditions those storages so that anything
you create within them will be automatically imported into pMyDataSpace. Note that
subsequent Import operations may alter that conditioning.

If you later decide that you want to move "Alpha" back into the default data
space:

    hr = pDataSpaceManager->OpenDataSpace(L"Default_Space", &pDefaultDataSpace);

    pDefaultDataSpace->Import(pThatStorage, "Alpha");

**  Data Space Transform Sets 

When you define a data space, you must specify a set of transforms to apply to 
the items you import into the space. A transform is an interface that converts
data to some other representation. For example the LZX transform converts your 
imported data into a more compact, compressed representation. Other transforms
might implement word or phrase based dictionary compression, or they might encipher 
your data, or they might just convert from one data format to another. You could, 
for example, construct a transform to store HTML data as a Rich Text stream.

When you define a data space with more than one transform, they are applied in 
order. For example let's suppose that your transform set consists of these three:

  1. A Dictionary compression transform

  2. The LXZ transform

  3. An data encryption transform

Whenever you write data into this space, it will first be compressed using the
dictionary compression methods, then LZX compression will be applied, and finally
your information will be encrypted. When you read data the process is reversed so
that the encryption transform supplies data to the LZX transform which in turn 
provides data for the dictionary compression transform.

You define the transform set via a vector of class ids (paclsidXform). Each class id
defines a location where an implementation of IID_Transform can be found. In addition
you'll supply corresponding control data for each transform (papxfcd). The number of 
transforms is defined by the cXforms parameter.

Note that it is legal to define a space with zero transforms. This is useful when
you've got items which are already compressed and which won't benefit from an
additional layer of compression overhead.

The control data for a transform defines how it will operate in a particular
data space. For example the control data for the LZX transform defines how
aggressively it will pursue compression, and it controls the tradeoff between
random access performance and the level of compression.

The actual structure and content of the control data is documented above.
(See the LZX_Control_Data data type.)

**  Transform Factories -- How they are organized; What they do

Transforms have two functional capabilities. They can return default
control data (DefaultControlData), and they can create
transform instances (CreateTransformInstance). When the ITSS code calls your 
CreateTransformInstance function, it will supply a storage medium (pXFSpan_Base)
where transformed data is to be stored along with the control data for the
instance and several other useful pieces of information. 

The CreateTransformInstance function has several parameters that you can use 
when you need to access global and/or instance data streams. They also support
the construction of encryption transforms. You can ignore those parameters if your
transform doesn't do encryption, uses only a single pass over the data, and doesn't
rely on any data beyond the data in the stream being transformed.

  -- The rclsidXForm and pwszDataSpace parameters, respectively, tell you the Class ID
  by which your code was located, and the name of the data space in which your instance
  will be working. These values are used with the ITransformServices interface.

  -- The pXformServices parameter points to an instance of the ITranformServices interface. 
  That interface gives you access to a couple of storages where you can keep global and
  instance data for your transform. It also gives you a way to contruct a temporary
  stream that is automatically deleted when you release it. That's very handy when 
  you get a seek operation into the middle of the transformed data followed by a write 
  operation.

  If you're implementing a multipass strategy, you can get access to those storages
  from code outside the transform by doing a QueryInterface from any ITS storage for 
  the interface IID_ITransformServices. You identify the storage in question by the
  transform's class id and possibly the name of the data space instance. 

  The per-transform-instance storage is also a convenient place to put the navigation
  data necessary to support fast seek operations.

  -- The pKeyManager parameter is an interface pointer used with encryption transforms.
  It supplies the read and write keys to use with your encryption transform. Those keys
  are set by the SetKeys interface of the ITransformServices interface. This allows you
  to separate your user interface code where people will enter passwords from the 
  transform implementations. This can be useful when you want the same keys to be used 
  for several different data spaces.  

**  Transform Instances -- How they are organized; What they do

A Transform Instance is an object which simulates a data medium which can be 
suballocated. Suballocated items are managed as data spans (ITransformedSpan).
You must supply a function to create a data span (CreateTransformedSpan), and
a function to open a data span (OpenTransformedSpan). Both of those functions 
return an ITransformedSpan interface when they succeed. In addition you must
supply the function SpaceSize to return the size of the entire untransformed
data image. That is, SpaceSize returns the highest limit offset (offset + size)
of any data span created within the instance. 

A span is identified by an ImageSpan structure which defines an offset and a size 
for the span. Both values are defined in untransformed space. For the Create function
this is an output parameter, while it is an input parameter for the Open function.
Note the interaction between the ImageSpan and the WriteAt member function of the
ITransformedSpan interface.

**  Transformed Data Spans -- How they are organized; What they do

A transformed Data Span (ITransformedSpan) has two member functions -- ReadAt and 
WriteAt. Those functions are very similar to the ReadAt and WriteAt functions of
the ILockBytes interface. The difference is that WriteAt includes an extra output
parameter (pImageSpan) for recording the current span parameters. The ReadAt function
doesn't include that parameter because read operations can never change the span's
size or move it to a different offset.

**  Implementation Strategies

This section describes a few scenarios that you may encounter as you construct a 
transform along with strategies for those situations. This is an open ended list 
which will expand as we gain more experience with transforms.

Many compression and encryption transforms are designed around sequential I/O. That is,
they expect to get the raw data from a sequence of write opeations with no intervening
seek operations. In many cases such transforms also write out the transformed data to 
the base stream in ascending order. Similarly they expect read requests to come to them
with no intervening seek operations. 

The key issue for those transforms is how do you implement random access and interleaved
read, write, and seek operations. 

Leaving aside write operations for the moment, let's consider a random sequence of reads
interleaved with seek operations. One solution might be to construct a table to map from
raw data offsets to transformed data offsets. You can store such a table in the instance
storage for the current data space. 

One complication is that many compression transforms use the raw data as a dictionary. 
That is, you can only start reading from the beginning of the transformed data. You can
deal with those transforms telling them to reset themselves periodically. That gives
you a collection of starting points spread fairly evenly throught the transformed 
data. When you do this you'll need to supply a control data parameter to control the
frequency of those reset points so that your clients can make an appropriate tradeoff
between compression efficiency and random access performance.

Now what about adding random write operations to the mix? The short answer here is that
you can't do this in the middle of transformed data. One strategy would be to reconstruct
the entire raw data into a temporary stream and do all your I/O to that stream until
release time. Then at release time you can transform the revised data sequentially.

A variation on that strategy is to keep track of which reset spans are modified and 
write the modified versions of those transformed spans to the end of the base stream.
This leaves a certain amount of dead space in your transformed data, but it allows
you to defer the sequential reconstruction work to a more convenient time. The down 
side  is that it requires you to manage yet more navigation data in the instance 
storage for the data space.

 */

interface IDataSpaceManager;
interface IDataSpace;
interface ITransformServices;
interface IKeyInstance;
interface ITransformFactory;
interface ITransformInstance;

typedef struct _XformControlData
{
    UINT  cdwControlData;    // Size of this structure in DWords
    UINT  adwControlData[0]; // Actually this will be UINT adwData[cdwData];

} XformControlData, *PXformControlData;

/*
// {7C01FD0F-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpaceManager : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE CreateDataSpace
        (const WCHAR *pwszDataSpace, UINT cXforms,
         const CLSID *paclsidXform, PXformControlData paxfcd,
         IDataSpace *pITDataSpace
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE OpenDataSpace
        (const WCHAR *pwszDataSpace, 
         IDataSpace *pITDataSpace
        ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DiscardDataSpace
        (const WCHAR *pwszDataSpace) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumDataSpaces
        (IEnumSTATSTG ** ppenum) = 0;
};


/*
// {7C01FD0E-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpace : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetTransformInfo
        (PUINT pcXforms, PUINT pcdwXformControlData, 
         CLSID *paclsid, PXformControlData pxfcd
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Import
        (IStorage *pStg, const WCHAR * pwszElementName) = 0;

    virtual HRESULT STDMETHODCALLTYPE ImportSpace(IStorage **ppStg) = 0;
};

/*
// {7C01FD0C-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformFactory : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE DefaultControlData
        (XformControlData **ppXFCD) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTransformInstance
        (ITransformInstance *pXFormMedium,        // Container data span for transformed data
		 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
         PXformControlData   pXFCD,               // Control data for this instance
         const CLSID        *rclsidXForm,         // Transform Class ID
         const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
         ITransformServices *pXformServices,      // Utility routines
         IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance // Out: Instance transform interface
        ) = 0;
};

typedef struct _ImageSpan
{
	ULARGE_INTEGER	uliHandle;
	ULARGE_INTEGER  uliSize;

} ImageSpan;

/*
// {EB19B67E-9360-11d0-9E16-00A0C922E6EC}
DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformInstance : public IUnknown
{
public:

	virtual HRESULT STDMETHODCALLTYPE ReadAt 
	                    (ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead,
						 ImageSpan *pSpan
                        ) = 0;

	virtual HRESULT STDMETHODCALLTYPE WriteAt
	                    (ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
						 ImageSpan *pSpan
                        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush() = 0;

	virtual HRESULT STDMETHODCALLTYPE SpaceSize(ULARGE_INTEGER *puliSize) = 0;

	// Note: SpaceSize returns the high water mark for the space. That is, the largest
	//       limit value (uliOffset + uliSize) for any transformed lockbytes created within
	//       the base (*pXLKB).
};

/*
// {A55895FC-89E1-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformServices : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE PerTransformStorage
        (REFCLSID rclsidXForm, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE PerTransformInstanceStorage
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetKeys
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
         PBYTE pbReadKey,  UINT cbReadKey, 
         PBYTE pbWriteKey, UINT cbWriteKey
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTemporaryStream(IStream **ppStrm) = 0;
};

/*
// {96AF35CE-88EC-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IKeyInstance : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetKeys
        (PBYTE *pbReadKey,  PUINT pcbReadKey,
         PBYTE *pbWriteKey, PUINT pcbWriteKey
        ) = 0;
};

/* 

  Streams stored in an ITS file may be accessed through URLs with
  the form:

      its: <File Path> :: <Stream Path>

  where <File Path> may be either a Win32 file path or a URL, and
  <Stream Path> is the path to a stream stored in the ITS file. 
  Each <Stream Path> must begin with '/'. 

  This means that you can copy a Win32 directory tree of HTML files
  and associated files into an ITS file and get to them through ITS
  URLs. If all the URL references within those HTML files are 
  relative, they will be resolved within the containing ITS file.

  The <File Path> portion of the URL may either be a complete path
  to the ITS file, or it may be just the file name. In the later case
  you may need to install auxillary information in the registry to
  help the ITSS code locate the file. Here are the rules:

  1. If you don't supply a complete path, ITSS looks in the current
     working directory for the file. 

  2. If the file isn't found in step 1. ITSS looks for a registry
     value in the ITSS_MAP section of HKEY_LOCAL_MACHINE. The value
     name must match the file name, and the value will be a string
     giving the complete file path to be used.

  3. If the file isn't found in steps 1 and 2, ITSS isolates the file's 
     extension (beginning with the last '.' character) and looks
     for a corresponding class id value in the ITSS_FINDER section 
     of HKEY_LOCAL_MACHINE. The name for the value will match the
     extension, and the value will be the class id for an object
     which implements the IID_IITFileFinder interface.

  4. If the file isn't found in steps 1 through 3, the URL reference
     fails.

 */

#define ITSS_MAP     "Software\\Microsoft\\Windows\\ITStorage\\Maps"
#define ITSS_FINDER  "Software\\Microsoft\\Windows\\ITStorage\\Finders"

interface IITFileFinder : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE FindThisFile(const WCHAR *pFileName, WCHAR **ppFullPath,
                                                   BOOL *pfRecordPathInRegistry
                                                  ) = 0;

// The FindThisFile method maps a file name into a complete file path. The file name
// is defined by *pFileName, and a pointer to the complete path is returned in 
// *ppFullPath. The returned path will be a string allocated in the IMalloc heap.
// The *pfRecordPathInRegistry result should be TRUE when we should record this mapping
// in the ITSS_MAP registry section and FALSE otherwise.

    
};


#endif // __MSITSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\locres.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    LocRes.cpp

Abstract:
    This file contains the implementation of functions to ease localization.

Revision History:
    Davide Massarenti   (Dmassare)  06/17/2000
        created

******************************************************************************/

#include "stdafx.h"


////////////////////////////////////////////////////////////////////////////////

#define ENSURE_MODULE()                            \
    if(g_hModule == NULL)                          \
    {                                              \
        HRESULT hr;                                \
                                                   \
        if(FAILED(hr = LocalizeInit())) return hr; \
    }

////////////////////////////////////////////////////////////////////////////////

static HINSTANCE g_hModule;

HRESULT MPC::LocalizeInit( LPCWSTR szFile )
{
    g_hModule = ::LoadLibraryW( szFile ? szFile : L"HCAppRes.dll" );
    if(g_hModule == NULL)
    {
        return HRESULT_FROM_WIN32(::GetLastError());
    }

    return S_OK;
}

HRESULT MPC::LocalizeString( /*[in]*/ UINT  uID     ,
                             /*[in]*/ LPSTR lpBuf   ,
                             /*[in]*/ int   nBufMax ,
							 /*[in]*/ bool  fMUI    )
{
    MPC::Impersonation imp;

    ENSURE_MODULE();

	if(fMUI)
	{
		if(SUCCEEDED(imp.Initialize())) imp.Impersonate();
    }

    if(::LoadStringA( g_hModule, uID, lpBuf, nBufMax ) == 0) return E_FAIL;

    return S_OK;
}

HRESULT MPC::LocalizeString( /*[in]*/ UINT   uID     ,
                             /*[in]*/ LPWSTR lpBuf   ,
                             /*[in]*/ int    nBufMax ,
							 /*[in]*/ bool   fMUI    )
{
    MPC::Impersonation imp;

    ENSURE_MODULE();

	if(fMUI)
	{
		if(SUCCEEDED(imp.Initialize())) imp.Impersonate();
    }

    if(::LoadStringW( g_hModule, uID, lpBuf, nBufMax ) == 0) return E_FAIL;

    return S_OK;
}

HRESULT MPC::LocalizeString( /*[in ]*/ UINT         uID   ,
                             /*[out]*/ MPC::string& szStr ,
							 /*[in ]*/ bool         fMUI  )
{
    CHAR    rgTmp[512];
    HRESULT hr;

    if(SUCCEEDED(hr = LocalizeString( uID, rgTmp, MAXSTRLEN(rgTmp), fMUI )))
    {
        szStr = rgTmp;
    }

    return hr;
}

HRESULT MPC::LocalizeString( /*[in ]*/ UINT          uID   ,
                             /*[out]*/ MPC::wstring& szStr ,
							 /*[in ]*/ bool          fMUI  )
{
    WCHAR   rgTmp[512];
    HRESULT hr;

    if(SUCCEEDED(hr = LocalizeString( uID, rgTmp, MAXSTRLEN(rgTmp), fMUI )))
    {
        szStr = rgTmp;
    }

    return hr;
}

HRESULT MPC::LocalizeString( /*[in ]*/ UINT      uID     ,
                             /*[out]*/ CComBSTR& bstrStr ,
							 /*[in ]*/ bool      fMUI    )
{
    WCHAR   rgTmp[512];
    HRESULT hr;

    if(SUCCEEDED(hr = LocalizeString( uID, rgTmp, MAXSTRLEN(rgTmp), fMUI )))
    {
        bstrStr = rgTmp;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

int MPC::LocalizedMessageBox( UINT uID_Title, UINT uID_Msg, UINT uType )
{
    MPC::wstring szTitle; MPC::LocalizeString( uID_Title, szTitle );
    MPC::wstring szMsg;   MPC::LocalizeString( uID_Msg  , szMsg   );

    return ::MessageBoxW( NULL, szMsg.c_str(), szTitle.c_str(), uType );
}

int MPC::LocalizedMessageBoxFmt( UINT uID_Title, UINT uID_Msg, UINT uType, ... )
{
    MPC::wstring szTitle; MPC::LocalizeString( uID_Title, szTitle );
    MPC::wstring szMsg;   MPC::LocalizeString( uID_Msg  , szMsg   );

    WCHAR   rgLine[512];
    va_list arglist;


    //
    // Format the log line.
    //
    va_start( arglist, uID_Msg );
    _vsnwprintf( rgLine, MAXSTRLEN(rgLine), szMsg.c_str(), arglist ); rgLine[MAXSTRLEN(rgLine)] = 0;
    va_end( arglist );
    

    return ::MessageBoxW( NULL, rgLine, szTitle.c_str(), uType );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\serializer.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Serializer.cpp

Abstract:
    This file contains the implementation of various Serializer In/Out operators.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include <stdafx.h>

/////////////////////////////////////////////////////////////////////////

HRESULT MPC::Serializer::operator>>( /*[out]*/ MPC::string& szVal )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer::operator>> MPC::string" );

    HRESULT hr;
    DWORD   dwSize;
    char    rgBuf[512+1];


    szVal = "";

	__MPC_EXIT_IF_METHOD_FAILS(hr, *this >> dwSize);

    while(dwSize)
    {
        DWORD dwLen = min( 512 / sizeof(char), dwSize );

        __MPC_EXIT_IF_METHOD_FAILS(hr, read( rgBuf, dwLen * sizeof(char) ));

        rgBuf[dwLen] = 0;

        szVal += rgBuf; dwSize -= dwLen;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer::operator<<( /*[in]*/ const MPC::string& szVal )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer::operator<< MPC::string" );

    HRESULT hr;
    DWORD   dwSize = szVal.length();


    __MPC_EXIT_IF_METHOD_FAILS(hr, *this << dwSize);

    __MPC_EXIT_IF_METHOD_FAILS(hr, write( szVal.c_str(), szVal.length() * sizeof(char) ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////

HRESULT MPC::Serializer::operator>>( /*[out]*/ MPC::wstring& szVal )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer::operator>> MPC::wstring" );

    HRESULT hr;
    DWORD   dwSize;
    WCHAR   rgBuf[512+1];


    szVal = L"";

    __MPC_EXIT_IF_METHOD_FAILS(hr, *this >> dwSize);

    while(dwSize)
    {
        DWORD dwLen = min( 512 / sizeof(WCHAR), dwSize );

        __MPC_EXIT_IF_METHOD_FAILS(hr, read( rgBuf, dwLen * sizeof(WCHAR) ));

        rgBuf[dwLen] = 0;

        szVal += rgBuf; dwSize -= dwLen;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer::operator<<( /*[in]*/ const MPC::wstring& szVal )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer::operator<< MPC::wstring" );

    HRESULT hr;
    DWORD   dwSize = szVal.length();


    __MPC_EXIT_IF_METHOD_FAILS(hr, *this << dwSize);

    __MPC_EXIT_IF_METHOD_FAILS(hr, write( szVal.c_str(), szVal.length() * sizeof(WCHAR) ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////

HRESULT MPC::Serializer::operator>>( /*[out]*/ CComBSTR& bstrVal )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer::operator>> CComBSTR" );

    HRESULT hr;
    DWORD   dwSize;

	bstrVal.Empty();

    __MPC_EXIT_IF_METHOD_FAILS(hr, *this >> dwSize);

    if(dwSize)
    {
        BSTR bstr;

		__MPC_EXIT_IF_ALLOC_FAILS(hr, bstr, ::SysAllocStringByteLen( NULL, dwSize ));

        bstrVal.Attach( bstr );

        __MPC_EXIT_IF_METHOD_FAILS(hr, read( bstrVal.m_str, dwSize ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer::operator<<( /*[in]*/ const CComBSTR& bstrVal )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer::operator<< CComBSTR" );

    HRESULT hr;
    DWORD   dwSize;


    dwSize = (bstrVal.m_str) ? ::SysStringByteLen( bstrVal.m_str ) : 0;

    __MPC_EXIT_IF_METHOD_FAILS(hr, *this << dwSize);

    __MPC_EXIT_IF_METHOD_FAILS(hr, write( bstrVal.m_str, dwSize ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////

HRESULT MPC::Serializer::operator>>( /*[out]*/ CComHGLOBAL& val )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer::operator>> CComHGLOBAL" );

    HRESULT hr;
	DWORD   dwSize;

	
    __MPC_EXIT_IF_METHOD_FAILS(hr, *this >> dwSize);

	__MPC_EXIT_IF_METHOD_FAILS(hr, val.New( GMEM_FIXED, dwSize ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, read( val.Get(), dwSize ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer::operator<<( /*[in]*/ const CComHGLOBAL& val )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer::operator<< CComHGLOBAL" );

    HRESULT hr;
	DWORD   dwSize = val.Size();
	LPVOID  ptr    = val.Lock();

    __MPC_EXIT_IF_METHOD_FAILS(hr, *this << dwSize);

	__MPC_EXIT_IF_METHOD_FAILS(hr, write( ptr, dwSize ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

	val.Unlock();

    __MPC_FUNC_EXIT(hr);
}

////////////////////

HRESULT MPC::Serializer::operator>>( /*[out]*/ CComPtr<IStream>& val )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer::operator>> IStream" );

    HRESULT 	hr;
	CComHGLOBAL chg;


	val.Release();

    __MPC_EXIT_IF_METHOD_FAILS(hr, *this >> chg);

	__MPC_EXIT_IF_METHOD_FAILS(hr, chg.DetachAsStream( &val ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer::operator<<( /*[in]*/ IStream* val )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer::operator<< IStream" );

    HRESULT 	hr;
	CComHGLOBAL chg;


	__MPC_EXIT_IF_METHOD_FAILS(hr, chg.CopyFromStream( val ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, *this << chg);

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\logging.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Logging.cpp

Abstract:
    This file contains the implementation of a set of logging classes.

Revision History:
    Davide Massarenti   (Dmassare)  05/27/99
        created

******************************************************************************/

#include "stdafx.h"

#define BUFFER_LINE_LENGTH (1024)

static WCHAR l_EndOfLine[] = L"\n";

/////////////////////////////////////////////////////////////////////////////

static DATE GetMidnight( /*[in]*/ SYSTEMTIME stTime )
{
    DATE dTime;

    stTime.wHour         = 0;
    stTime.wMinute       = 0;
    stTime.wSecond       = 0;
    stTime.wMilliseconds = 0;

    ::SystemTimeToVariantTime( &stTime, &dTime );

    return dTime;
}

/////////////////////////////////////////////////////////////////////////////

MPC::FileLog::FileLog( /*[in]*/ bool fCacheHandle, /*[in]*/ bool fUseUnicode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileLog::FileLog" );


                                           // MPC::wstring m_szLogFile;
    m_hFile        = INVALID_HANDLE_VALUE; // HANDLE       m_hFile;
    m_fCacheHandle = fCacheHandle;         // bool         m_fCacheHandle;
    m_fUseUnicode  = fUseUnicode;          // bool         m_fUseUnicode;
}

MPC::FileLog::FileLog( /*[in]*/ const FileLog& fl )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileLog::FileLog" );


    m_szLogFile    = fl.m_szLogFile;       // MPC::wstring m_szLogFile;
    m_hFile        = INVALID_HANDLE_VALUE; // HANDLE       m_hFile;
    m_fCacheHandle = fl.m_fCacheHandle;    // bool         m_fCacheHandle;
    m_fUseUnicode  = fl.m_fUseUnicode;     // bool         m_fUseUnicode;
}

MPC::FileLog::~FileLog()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileLog::~FileLog" );

    Close();
}

MPC::FileLog& MPC::FileLog::operator=( /*[in]*/ const FileLog& fl )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileLog::operator=" );


    Close();


    m_szLogFile    = fl.m_szLogFile;       // MPC::wstring m_szLogFile;
    m_hFile        = INVALID_HANDLE_VALUE; // HANDLE       m_hFile;
    m_fCacheHandle = fl.m_fCacheHandle;    // bool         m_fCacheHandle;
    m_fUseUnicode  = fl.m_fUseUnicode;     // bool         m_fUseUnicode;

    return *this;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::FileLog::Open()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileLog::Open" );

    HRESULT hr;

    Lock();


    if(m_hFile == INVALID_HANDLE_VALUE)
    {
        // Ensure the directory exists.
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( m_szLogFile ));

        __MPC_EXIT_IF_INVALID_HANDLE(hr, m_hFile, ::CreateFileW( m_szLogFile.c_str(), GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, NULL ));

        ::SetFilePointer( m_hFile, 0, NULL, FILE_END );
    }


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    Unlock();

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileLog::Close()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileLog::Close" );

    HRESULT hr;

    Lock();


    if(m_hFile != INVALID_HANDLE_VALUE)
    {
        ::CloseHandle( m_hFile );

        m_hFile = INVALID_HANDLE_VALUE;
    }

    hr = S_OK;


    Unlock();

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::FileLog::Rotate( /*[in]*/ DWORD dwDays )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileLog::Rotate" );

    HRESULT      hr;
    SYSTEMTIME   st;
    WCHAR        rgTime[BUFFER_LINE_LENGTH];
    MPC::wstring szLogFileNew;

    Lock();


    //
    // Before rotating, check if it's time to do it.
    //
    if(dwDays)
    {
        FILETIME   ftCreation;
        SYSTEMTIME stCreation;
        SYSTEMTIME stNow;
        DATE       dCreation;
        DATE       dNow;

        __MPC_EXIT_IF_METHOD_FAILS(hr, Open());

        if(::GetFileTime( m_hFile, &ftCreation, NULL, NULL ))
        {
            ::FileTimeToSystemTime( &ftCreation, &stCreation );
            ::GetSystemTime       ( &stNow                   );

            dCreation = GetMidnight( stCreation );
            dNow      = GetMidnight( stNow      );

            //
            // If it's not been 'dwDays' since the creation of the log, don't rotate.
            //
            if(dCreation + (DATE)dwDays > dNow)
            {
                __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
            }
        }
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close());

    //
    // Append current time.
    //
    // <FileName>__<Year>_<Month>_<Day>_<hour>-<minute>-<second>
    //
    ::GetLocalTime( &st );
    swprintf( rgTime, L"__%04u-%02u-%02u_%02u-%02u-%02u", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond );

    szLogFileNew = m_szLogFile;
    szLogFileNew.append( rgTime );

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::MoveFileExW( m_szLogFile.c_str(), szLogFileNew.c_str(), MOVEFILE_REPLACE_EXISTING ));


    //
    // After rotation, SET the date of creation. There's a BUG in NTFS that caches the date from the previous file...
    //
    if(dwDays)
    {
        FILETIME   ftNow;
        SYSTEMTIME stNow;

        __MPC_EXIT_IF_METHOD_FAILS(hr, Open());

        ::GetSystemTime       ( &stNow         );
        ::SystemTimeToFileTime( &stNow, &ftNow );

        ::SetFileTime( m_hFile, &ftNow, NULL, NULL );

        __MPC_EXIT_IF_METHOD_FAILS(hr, Close());
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    Unlock();

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileLog::SetLocation( /*[in]*/ LPCWSTR szLogFile )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileLog::SetLocation" );

    HRESULT hr;

    Lock();

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szLogFile);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close());


    m_szLogFile = szLogFile;
    hr          = S_OK;


    __MPC_FUNC_CLEANUP;

    Unlock();

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileLog::Terminate()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileLog::Terminate" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Close());

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::FileLog::AppendString( /*[in]*/ LPCWSTR szLine )
{
    _ASSERT(m_hFile != INVALID_HANDLE_VALUE);

    USES_CONVERSION;

    HRESULT hr;
    DWORD   dwWritten;
    LPCVOID lpData;
    DWORD   dwSize;


    if(m_fUseUnicode)
    {
        lpData = szLine;
        dwSize = wcslen( szLine ) * sizeof(WCHAR);
    }
    else
    {
        LPCSTR szLineASCII = W2A( szLine );

        lpData = szLineASCII;
        dwSize = strlen( szLineASCII ) * sizeof(CHAR);
    }

    if(::WriteFile( m_hFile, lpData, dwSize, &dwWritten, NULL ) == FALSE)
    {
        hr = HRESULT_FROM_WIN32( ::GetLastError() );
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT MPC::FileLog::WriteEntry( /*[in]*/ LPWSTR szLine )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileLog::WriteEntry" );

    HRESULT    hr;
    WCHAR      rgTime[BUFFER_LINE_LENGTH];
    SYSTEMTIME st;


    Lock();


    __MPC_EXIT_IF_METHOD_FAILS(hr, Open());


    //
    // Prepend current time.
    //
    ::GetLocalTime( &st );
    swprintf( rgTime, L"%04u/%02u/%02u %02u:%02u:%02u ", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond );

    while(1)
    {
        LPWSTR szEndOfLine = wcschr( szLine, '\n' );

        if(szEndOfLine) *szEndOfLine++ = 0;

        __MPC_EXIT_IF_METHOD_FAILS(hr, AppendString( rgTime ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, AppendString( szLine ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, AppendString( L"\n"  ));

        //
        // Two cases to stop: end of string or NewLine at the end of it.
        //
        if(!szEndOfLine || !szEndOfLine[0]) break;

        szLine = szEndOfLine;
    }


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(m_fCacheHandle == false) (void)Close();

    Unlock();

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileLog::LogRecordV( /*[in]*/ LPCWSTR szFormat ,
                                  /*[in]*/ va_list arglist  )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileLog::WriteEntry" );

    HRESULT hr;
    WCHAR rgLine[BUFFER_LINE_LENGTH];

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szFormat);
    __MPC_PARAMCHECK_END();


    _vsnwprintf( rgLine, MAXSTRLEN(rgLine), szFormat, arglist ); rgLine[MAXSTRLEN(rgLine)] = 0;

    __MPC_EXIT_IF_METHOD_FAILS(hr, WriteEntry( rgLine ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileLog::LogRecordV( /*[in]*/ LPCSTR  szFormat ,
                                  /*[in]*/ va_list arglist  )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileLog::WriteEntry" );

    USES_CONVERSION;

    HRESULT hr;
    CHAR    rgLine[BUFFER_LINE_LENGTH];

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szFormat);
    __MPC_PARAMCHECK_END();


    _vsnprintf( rgLine, MAXSTRLEN(rgLine), szFormat, arglist ); rgLine[MAXSTRLEN(rgLine)] = 0;

    __MPC_EXIT_IF_METHOD_FAILS(hr, WriteEntry( A2W(rgLine) ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileLog::LogRecord( /*[in]*/ LPCWSTR szFormat,
                                 /*[in]*/ ...             )
{
    va_list arglist;

    va_start( arglist, szFormat );

    return LogRecordV( szFormat, arglist );
}

HRESULT MPC::FileLog::LogRecord( /*[in]*/ LPCSTR szFormat,
                                 /*[in]*/ ...            )
{
    va_list arglist;

    va_start( arglist, szFormat );

    return LogRecordV( szFormat, arglist );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

MPC::NTEvent::NTEvent()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NTEvent::NTEvent" );


    m_hEventSource = INVALID_HANDLE_VALUE;
}

MPC::NTEvent::NTEvent( /*[in]*/ const NTEvent& ne )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NTEvent::NTEvent" );


    m_hEventSource = INVALID_HANDLE_VALUE;
}


MPC::NTEvent::~NTEvent()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NTEvent::~NTEvent" );


    Terminate();
}

MPC::NTEvent& MPC::NTEvent::operator=( /*[in]*/ const NTEvent& fl )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NTEvent::operator=" );


    m_hEventSource = INVALID_HANDLE_VALUE;


    return *this;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::NTEvent::Init( /*[in]*/ LPCWSTR szEventSourceName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NTEvent::Init" );

    HRESULT hr;

    Lock();

    //
    // Validate params.
    //
    if(szEventSourceName == NULL)
    {
        return E_INVALIDARG;
    }


    if(m_hEventSource != INVALID_HANDLE_VALUE)
    {
        // only allow one init per lifetime of the object...
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_ALREADY_ASSIGNED);
    }

    __MPC_EXIT_IF_INVALID_HANDLE(hr, m_hEventSource, ::RegisterEventSourceW( NULL, szEventSourceName ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    Unlock();

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::NTEvent::Terminate()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NTEvent::Terminate" );

    HRESULT hr;

    Lock();


    if(m_hEventSource != INVALID_HANDLE_VALUE)
    {
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::DeregisterEventSource( m_hEventSource ));

        m_hEventSource = NULL;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    Unlock();

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::NTEvent::LogEvent( /*[in]*/ WORD  wEventType ,
                                /*[in]*/ DWORD dwEventID  ,
                                /*[in]*/ ...              )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NTEvent::LogEvent" );

    HRESULT  hr;
    va_list  arglist;
    LPCWSTR  szParams;
    LPCWSTR* pParams  = NULL;
    DWORD    dwParams = 0;
    int      i;

    Lock();

    if(m_hEventSource == INVALID_HANDLE_VALUE)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    //
    // Walk through the parameters twice, the first time to count them, the second time to collect them.
    //
    for(i=0;i<2;i++)
    {
        va_start( arglist, dwEventID );

        dwParams = 0;
        while((szParams = va_arg( arglist, LPCWSTR )) != NULL)
        {
            if(pParams) pParams[dwParams] = szParams;

            dwParams++;
        }

        va_end( arglist );

        if(i == 0 && dwParams)
        {
            pParams = (LPCWSTR*)_alloca( sizeof(*pParams) * dwParams );
        }
    }

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::ReportEventW( m_hEventSource, wEventType, 0, dwEventID, NULL, dwParams, 0, pParams, NULL ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    Unlock();

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\staticcrt.cpp ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    StaticCrt.cpp

Abstract:
    This file contains the implementation of various CRT functions, so we don't
	need to link against MSVCP60.DLL

Revision History:
    Davide Massarenti   (Dmassare)  05/29/2000
        created

******************************************************************************/

#include <stdafx.h>


// CLASS bad_alloc_nocrt
class bad_alloc_nocrt
{
public:
	bad_alloc_nocrt() _THROW0() {}
	~bad_alloc_nocrt() _THROW0() {}
};

void __cdecl operator delete(void *ptr)
{
	free( ptr );
}

void *__cdecl operator new( size_t cb )
{
	void *res = malloc( cb );

	if(!res) throw bad_alloc_nocrt();

	return res;
}

_STD_BEGIN

void __cdecl _XlenNR() { throw "string too long"; } // report a length_error
void __cdecl _XranNR() { throw "invalid string position"; } // report an out_of_range error

_STD_END

#ifdef  _MT

#include <xstddef>
#include <windows.h>
_STD_BEGIN

static CRITICAL_SECTION _CritSec;

static long _InitFlag = 0L;

static void __cdecl _CleanUp()
{
        long InitFlagValue;

        if ( InitFlagValue = InterlockedExchange( &_InitFlag, 3L ) == 2L )
            // Should be okay to delete critical section
            DeleteCriticalSection( &_CritSec );
}

_Lockit::_Lockit()
{

        // Most common case - just enter the critical section

        if ( _InitFlag == 2L ) {
            EnterCriticalSection( &_CritSec );
            return;
        }

        // Critical section either needs to be initialized.

        if ( _InitFlag == 0L ) {

            long InitFlagVal;

            if ( (InitFlagVal = InterlockedExchange( &_InitFlag, 1L )) == 0L ) {
                InitializeCriticalSection( &_CritSec );
                atexit( _CleanUp );
                _InitFlag = 2L;
            }
            else if ( InitFlagVal == 2L )
                _InitFlag = 2L;
        }

        // If necessary, wait while another thread finishes initializing the
        // critical section

        while ( _InitFlag == 1L )
            Sleep( 1 );

        if ( _InitFlag == 2L )
            EnterCriticalSection( &_CritSec );
}

_Lockit::~_Lockit()
{
        if ( _InitFlag == 2L ) 
            LeaveCriticalSection( &_CritSec );
}

_STD_END

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

//
// Warning, always leave these includes BEFORE <atlbase.h>, otherwise you won't get the right MSXML.
//
#define __msxml_h__
#include <basetyps.h>
typedef interface IXMLElement IXMLElement;
#include <msxml.h>
#undef  __msxml_h__
#include <msxml.h>

#include <atlbase.h>

extern CComModule _Module;

#include <MPC_main.h>
#include <MPC_trace.h>
#include <MPC_COM.h>
#include <MPC_streams.h>
#include <MPC_utils.h>
#include <MPC_html.h>
#include <MPC_xml.h>
#include <MPC_logging.h>
#include <MPC_config.h>
#include <MPC_security.h>

#include <shlobj.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\connectivity.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Connectivity

Abstract:
    This file contains the implementation of the MPC::Connectitivy classes,
    that are capable to check the real state of the connection with the internet.

Revision History:
    Davide Massarenti   (Dmassare)  10/19/2000
        created

******************************************************************************/

#include "stdafx.h"

#include <process.h>
#include <wininet.h>
#include <Iphlpapi.h>
#include <Winsock2.h>
#include <inetreg.h>

////////////////////////////////////////////////////////////////////////////////

//
// This structure is defined in WinINET.h in terms of TCHAR, but it's wrong, it should be CHAR...
//

typedef struct {

    //
    // dwAccessType - INTERNET_OPEN_TYPE_DIRECT, INTERNET_OPEN_TYPE_PROXY, or
    // INTERNET_OPEN_TYPE_PRECONFIG (set only)
    //

    DWORD dwAccessType;

    //
    // lpszProxy - proxy server list
    //

    LPCSTR lpszProxy;

    //
    // lpszProxyBypass - proxy bypass list
    //

    LPCSTR lpszProxyBypass;
} INTERNET_PROXY_INFOA;

////////////////////////////////////////////////////////////////////////////////

static const WCHAR c_szIESettings            [] = TSZWININETPATH;
static const WCHAR c_szIESettings_Proxy      [] = REGSTR_VAL_PROXYSERVER;
static const WCHAR c_szIESettings_ProxyBypass[] = REGSTR_VAL_PROXYOVERRIDE;

static const WCHAR c_szIEConnections         [] = TSZWININETPATH L"\\Connections";
static const WCHAR c_szIEConnections_Settings[] = L"DefaultConnectionSettings";

////////////////////////////////////////////////////////////////////////////////

static HRESULT local_GetDWORD( /*[in/out]*/ BYTE*& pBuf    ,
                               /*[in/out]*/ DWORD& dwSize  ,
                               /*[out   ]*/ DWORD& dwValue )
{
    if(dwSize < sizeof(DWORD)) return E_FAIL;

    ::CopyMemory( &dwValue, pBuf, sizeof(DWORD) );

    dwSize -= sizeof(DWORD);
    pBuf   += sizeof(DWORD);

    return S_OK;
}

static HRESULT local_GetSTRING( /*[in/out]*/ BYTE*&       pBuf     ,
                                /*[in/out]*/ DWORD&       dwSize   ,
                                /*[out   ]*/ MPC::string& strValue )
{
    DWORD   dwLen;
    HRESULT hr;

    if(FAILED(hr = local_GetDWORD( pBuf, dwSize, dwLen ))) return hr;

    if(dwSize < dwLen) return E_FAIL;

    strValue.append( (char*)pBuf, (char*)&pBuf[dwLen] );

    dwSize -= dwLen;
    pBuf   += dwLen;

    return S_OK;
}

static HRESULT local_GetProxyData( /*[in ]*/ BYTE*        pBuf                     ,
                                   /*[in ]*/ DWORD        dwSize                   ,
                                   /*[out]*/ DWORD&       dwCurrentSettingsVersion ,
                                   /*[out]*/ DWORD&       dwFlags                  ,
                                   /*[out]*/ DWORD&       dwAccessType             ,
                                   /*[out]*/ MPC::string& strProxy                 ,
                                   /*[out]*/ MPC::string& strProxyBypass           )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Connectitivy::Proxy GetProxyData" );


    HRESULT hr;
    DWORD   dwStructSize;


    __MPC_EXIT_IF_METHOD_FAILS(hr, local_GetDWORD( pBuf, dwSize, dwStructSize             )); //if(dwStructSize != 0x3C) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    __MPC_EXIT_IF_METHOD_FAILS(hr, local_GetDWORD( pBuf, dwSize, dwCurrentSettingsVersion ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, local_GetDWORD( pBuf, dwSize, dwFlags ));

    if(dwFlags & PROXY_TYPE_PROXY)
    {
        dwAccessType = INTERNET_OPEN_TYPE_PROXY;

        __MPC_EXIT_IF_METHOD_FAILS(hr, local_GetSTRING( pBuf, dwSize, strProxy       ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, local_GetSTRING( pBuf, dwSize, strProxyBypass ));
    }
    else if(dwFlags & PROXY_TYPE_DIRECT)
    {
        dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
    }
    else
    {
        dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(FAILED(hr))
    {
        dwAccessType   = 0;
        strProxy       = "";
        strProxyBypass = "";
    }

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////

MPC::Connectivity::Proxy::Proxy()
{
    m_fInitialized = false; // bool        m_fInitialized;
                            //
                            // MPC::string m_strProxy;
                            // MPC::string m_strProxyBypass;
                            // CComHGLOBAL m_hgConnection;
}

MPC::Connectivity::Proxy::~Proxy()
{
}

////////////////////

HRESULT MPC::Connectivity::Proxy::Initialize( /*[in]*/ bool fImpersonate )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Connectivity::Proxy::Initialize" );

    HRESULT            hr;
    MPC::Impersonation imp;
    MPC::RegKey        rk;
    DWORD              dwSize;
    DWORD              dwType;
    bool               fFound;


    if(fImpersonate)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize ());
        __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Impersonate());
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, rk.SetRoot( HKEY_CURRENT_USER, KEY_READ ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rk.Attach( c_szIESettings                                       ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rk.Read  ( m_strProxy      , fFound, c_szIESettings_Proxy       ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rk.Read  ( m_strProxyBypass, fFound, c_szIESettings_ProxyBypass ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rk.Attach    ( c_szIEConnections                                                  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rk.ReadDirect( c_szIEConnections_Settings, m_hgConnection, dwSize, dwType, fFound ));

    m_fInitialized = true;
    hr             = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Connectivity::Proxy::Apply( /*[in]*/ HINTERNET hSession )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Connectivity::Proxy::Apply" );

    HRESULT hr;


    if(m_fInitialized)
    {
        DWORD dwSize = m_hgConnection.Size();

        if(m_strProxy.size() == 0 && dwSize)
        {
            DWORD  dwCurrentSettingsVersion;
            DWORD  dwFlags;
            DWORD  dwAccessType;
            LPVOID ptr = m_hgConnection.Lock();

            if(FAILED(local_GetProxyData( (BYTE*)ptr, dwSize, dwCurrentSettingsVersion, dwFlags, dwAccessType, m_strProxy, m_strProxyBypass )))
            {
                //
                // Autoproxy cannot be set using the API, so we copy the whole registry value...
                //
                MPC::RegKey rk;

                __MPC_EXIT_IF_METHOD_FAILS(hr, rk.SetRoot    ( HKEY_CURRENT_USER, KEY_ALL_ACCESS                   ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, rk.Attach     ( c_szIEConnections                                   ));
                __MPC_EXIT_IF_METHOD_FAILS(hr, rk.WriteDirect( c_szIEConnections_Settings, ptr, dwSize, REG_BINARY ));
            }

            m_hgConnection.Unlock();
        }

        if(m_strProxy.size())
        {
            INTERNET_PROXY_INFOA info;

            info.dwAccessType    = INTERNET_OPEN_TYPE_PROXY;
            info.lpszProxy       = m_strProxy      .c_str();
            info.lpszProxyBypass = m_strProxyBypass.c_str(); if(info.lpszProxyBypass[0] == 0) info.lpszProxyBypass = NULL;

            __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::InternetSetOptionA( hSession, INTERNET_OPTION_PROXY, &info, sizeof(info) ));
        }
    }


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT MPC::Connectivity::operator>>( /*[in]*/ MPC::Serializer& streamIn, /*[out]*/ MPC::Connectivity::Proxy& val )
{
    __MPC_FUNC_ENTRY( COMMONID, "operator>> MPC::Connectivity::Proxy" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> val.m_fInitialized  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> val.m_strProxy      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> val.m_strProxyBypass);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> val.m_hgConnection  );

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Connectivity::operator<<( /*[in]*/ MPC::Serializer& streamOut, /*[in ]*/ const MPC::Connectivity::Proxy& val )
{
    __MPC_FUNC_ENTRY( COMMONID, "operator<< MPC::Connectivity::Proxy" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << val.m_fInitialized  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << val.m_strProxy      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << val.m_strProxyBypass);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << val.m_hgConnection  );

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

MPC::Connectivity::WinInetTimeout::WinInetTimeout( /*[in]*/ MPC::CComSafeAutoCriticalSection& cs, /*[in]*/ HINTERNET& hReq ) : m_cs( cs ), m_hReq( hReq )
{
                                              // MPC::CComSafeAutoCriticalSection& m_cs;
                                              // HINTERNET&                        m_hReq;
    m_hTimer          = INVALID_HANDLE_VALUE; // HANDLE                            m_hTimer;
    m_dwTimeout       = 0;                    // DWORD                             m_dwTimeout;
                                              //
                                              // INTERNET_STATUS_CALLBACK          m_PreviousCallback;
    m_PreviousContext = NULL;                 // DWORD_PTR                         m_PreviousContext;


#ifdef _IA64_
    m_PreviousCallback = INTERNET_INVALID_STATUS_CALLBACK;
#else
    m_PreviousCallback = ::InternetSetStatusCallback( m_hReq, InternetStatusCallback );
    if(m_PreviousCallback != INTERNET_INVALID_STATUS_CALLBACK)
    {
        DWORD_PTR dwContext = (DWORD_PTR)this;
        DWORD     dwSize    = sizeof(m_PreviousContext);

        ::InternetQueryOptionW( m_hReq, INTERNET_OPTION_CONTEXT_VALUE, &m_PreviousContext,       &dwSize     );
        ::InternetSetOptionW  ( m_hReq, INTERNET_OPTION_CONTEXT_VALUE, &dwContext        , sizeof(dwContext) );
    }
#endif
}

MPC::Connectivity::WinInetTimeout::~WinInetTimeout()
{
    if(m_hReq)
    {
        if(m_PreviousCallback != INTERNET_INVALID_STATUS_CALLBACK)
        {
            ::InternetSetOptionW       ( m_hReq, INTERNET_OPTION_CONTEXT_VALUE, &m_PreviousContext, sizeof(m_PreviousContext) );
            ::InternetSetStatusCallback( m_hReq,                                 m_PreviousCallback                           );
        }
    }

    (void)Reset();
}

VOID CALLBACK MPC::Connectivity::WinInetTimeout::TimerFunction( PVOID lpParameter, BOOLEAN TimerOrWaitFired )
{
    WinInetTimeout* pThis = (WinInetTimeout*)lpParameter;

    pThis->m_cs.Lock();

    if(pThis->m_hReq)
    {
        ::InternetCloseHandle( pThis->m_hReq ); pThis->m_hReq = NULL;
    }

    pThis->m_cs.Unlock();
}

VOID CALLBACK MPC::Connectivity::WinInetTimeout::InternetStatusCallback( HINTERNET hInternet                 ,
                                                                         DWORD_PTR dwContext                 ,
                                                                         DWORD     dwInternetStatus          ,
                                                                         LPVOID    lpvStatusInformation      ,
                                                                         DWORD     dwStatusInformationLength )
{
    WinInetTimeout* pThis = (WinInetTimeout*)dwContext;

    pThis->m_cs.Lock();

    if(dwInternetStatus == INTERNET_STATUS_DETECTING_PROXY)
    {
        pThis->InternalReset();
    }
    else
    {
        if(pThis->m_hTimer == INVALID_HANDLE_VALUE)
        {
            (void)pThis->InternalSet();
        }
    }

    pThis->m_cs.Unlock();
}

HRESULT MPC::Connectivity::WinInetTimeout::InternalSet()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Connectivity::WinInetTimeout::InternalSet" );

    HRESULT hr;

    if(m_dwTimeout)
    {
        if(m_hTimer != INVALID_HANDLE_VALUE)
        {
            __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::ChangeTimerQueueTimer( NULL, m_hTimer, m_dwTimeout, 0 ));
        }
        else
        {
            __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CreateTimerQueueTimer( &m_hTimer, NULL, TimerFunction, this, m_dwTimeout, 0, WT_EXECUTEINTIMERTHREAD ));
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Connectivity::WinInetTimeout::InternalReset()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Connectivity::WinInetTimeout::InternalReset" );

    HRESULT hr;

    if(m_hTimer != INVALID_HANDLE_VALUE)
    {
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::DeleteTimerQueueTimer( NULL, m_hTimer, INVALID_HANDLE_VALUE ));

        m_hTimer = INVALID_HANDLE_VALUE;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::Connectivity::WinInetTimeout::Set( /*[in]*/ DWORD dwTimeout )
{
    HRESULT hr;


    m_cs.Lock();

    if(SUCCEEDED(hr = InternalReset()))
    {
        m_dwTimeout = dwTimeout;

        hr = InternalSet();
    }

    m_cs.Unlock();


    return hr;
}

HRESULT MPC::Connectivity::WinInetTimeout::Reset()
{
    HRESULT hr;


    m_cs.Lock();

    if(SUCCEEDED(hr = InternalReset()))
    {
        m_dwTimeout = 0;
    }

    m_cs.Unlock();


    return hr;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

static WCHAR   s_DefaultDestination[] = L"http://www.microsoft.com";
static LPCWSTR s_AcceptTypes       [] = { L"*/*", NULL }; // */

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::Connectivity::NetworkAlive( /*[in]*/ DWORD dwTimeout, /*[in]*/ MPC::Connectivity::Proxy* pProxy )
{
    //
    // Try to contact Microsoft.
    //
    return DestinationReachable( s_DefaultDestination, dwTimeout, pProxy );
}

HRESULT MPC::Connectivity::DestinationReachable( /*[in]*/ LPCWSTR szDestination, /*[in]*/ DWORD dwTimeout, /*[in]*/ MPC::Connectivity::Proxy* pProxy )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Connectivity::DestinationReachable" );

    HRESULT         hr;
    MPC::URL        url;
    INTERNET_SCHEME nScheme;
    MPC::wstring    strScheme;
    MPC::wstring    strHostName;
    DWORD           dwPort;
    MPC::wstring    strUrlPath;
    MPC::wstring    strExtraInfo;
    HINTERNET       hInternet    = NULL;
    HINTERNET       hConnect     = NULL;
    HINTERNET       hOpenRequest = NULL;
    DWORD           dwLength;
    DWORD           dwStatus;
    DWORD           dwFlags;



    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szDestination);
    __MPC_PARAMCHECK_END();


    //
    // If there's no connection or we are in offline more, abort.
    //
    {
        DWORD dwConnMethod;


        if(!::InternetGetConnectedState( &dwConnMethod, 0 ) ||
           (dwConnMethod & INTERNET_CONNECTION_OFFLINE)      )
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INTERNET_DISCONNECTED);
        }
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, url.put_URL( szDestination ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, url.get_Scheme   (   nScheme    ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, url.get_Scheme   ( strScheme    ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, url.get_HostName ( strHostName  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, url.get_Port     (  dwPort      )); if(!dwPort) dwPort = INTERNET_DEFAULT_HTTP_PORT;
    __MPC_EXIT_IF_METHOD_FAILS(hr, url.get_Path     ( strUrlPath   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, url.get_ExtraInfo( strExtraInfo )); strUrlPath += strExtraInfo;

    //
    // If not a supported URL, just exit.
    //
    if(strScheme  .size() == 0 ||
       strHostName.size() == 0  )
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    if(nScheme != INTERNET_SCHEME_HTTP  &&
       nScheme != INTERNET_SCHEME_HTTPS  )
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    dwFlags = INTERNET_FLAG_NO_CACHE_WRITE           |
              INTERNET_FLAG_PRAGMA_NOCACHE           |
              INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP  | // ex: https:// to http://
              INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS | // ex: http:// to https://
              INTERNET_FLAG_IGNORE_CERT_DATE_INVALID | // expired X509 Cert.
              INTERNET_FLAG_IGNORE_CERT_CN_INVALID   ; // bad common name in X509 Cert.

    if(nScheme == INTERNET_SCHEME_HTTPS)
    {
        dwFlags |= INTERNET_FLAG_SECURE;
    }

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Get handle to a connection
    //
    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hInternet = ::InternetOpenW( L"HelpSupportServices"       ,
                                                                      INTERNET_OPEN_TYPE_PRECONFIG ,
                                                                      NULL                         ,
                                                                      NULL                         ,
                                                                      0                            )));

    //
    // Optional proxy settings override.
    //
    if(pProxy)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, pProxy->Apply( hInternet ));
    }

    //
    // Connect
    //
    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hConnect = ::InternetConnectW( hInternet             ,
                                                                        strHostName.c_str()   ,
                                                                        dwPort                ,
                                                                        NULL                  ,
                                                                        NULL                  ,
                                                                        INTERNET_SERVICE_HTTP ,
                                                                        INTERNET_FLAG_NO_UI   ,
                                                                        0                     )));


    for(int pass=0; pass<2; pass++)
    {
        //
        // Create a request to get the header for the page.
        //
        __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hOpenRequest = ::HttpOpenRequestW( hConnect                      ,
                                                                                pass == 0 ? L"HEAD" : L"GET"  ,
                                                                                strUrlPath.c_str()            ,
                                                                                L"HTTP/1.0"                   , // 1.0 to get filesize and time
                                                                                NULL                          , // referer
                                                                                s_AcceptTypes                 ,
                                                                                dwFlags                       ,
                                                                                0                             )));

        //
        // Because WinINET timeout support has always been broken, we have to use an external timer to close the request object. This effectively will abort the request.
        //
        {
            MPC::CComSafeAutoCriticalSection  cs;
            MPC::Connectivity::WinInetTimeout to( cs, hOpenRequest );

            if(dwTimeout != INFINITE)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, to.Set( dwTimeout ));
            }

            //
            // Send request to get request
            //
            __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::HttpSendRequestW( hOpenRequest, NULL, 0, NULL, 0 ));
        }

        if(hOpenRequest == NULL)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INTERNET_DISCONNECTED);
        }

        //
        // We have sent the request so now check the status and see if the
        // request returned a proper status code as a 32 bit number
        //
        dwLength = sizeof(dwStatus);
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::HttpQueryInfoW( hOpenRequest                                    ,
                                                               HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER ,
                                                               (LPVOID)&dwStatus                               ,
                                                               &dwLength                                       ,
                                                               NULL                                            ));

        //
        // Check status and if not OK then fail. If the status is OK this means
        // that the object/file is on the server and is reachable to be viewed
        // by downloading to the user
        //
        if(dwStatus < 400) break;

        if(pass == 1)
        {
            switch(dwStatus)
            {
            case HTTP_STATUS_BAD_REQUEST      : break;
            case HTTP_STATUS_DENIED           : break;
            case HTTP_STATUS_PAYMENT_REQ      : break;
            case HTTP_STATUS_FORBIDDEN        : break;
            case HTTP_STATUS_NOT_FOUND        : __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
            case HTTP_STATUS_BAD_METHOD       : break;
            case HTTP_STATUS_NONE_ACCEPTABLE  : break;
            case HTTP_STATUS_PROXY_AUTH_REQ   : break;
            case HTTP_STATUS_REQUEST_TIMEOUT  : __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INTERNET_DISCONNECTED);
            case HTTP_STATUS_CONFLICT         : break;
            case HTTP_STATUS_GONE             : __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
            case HTTP_STATUS_LENGTH_REQUIRED  : break;
            case HTTP_STATUS_PRECOND_FAILED   : break;
            case HTTP_STATUS_REQUEST_TOO_LARGE: break;
            case HTTP_STATUS_URI_TOO_LONG     : break;
            case HTTP_STATUS_UNSUPPORTED_MEDIA: break;
            case HTTP_STATUS_RETRY_WITH       : break;

            case HTTP_STATUS_SERVER_ERROR     : break;
            case HTTP_STATUS_NOT_SUPPORTED    : break;
            case HTTP_STATUS_BAD_GATEWAY      : __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
            case HTTP_STATUS_SERVICE_UNAVAIL  : __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
            case HTTP_STATUS_GATEWAY_TIMEOUT  : __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_INTERNET_DISCONNECTED);
            case HTTP_STATUS_VERSION_NOT_SUP  : break;
            }

        }

        ::InternetCloseHandle( hOpenRequest ); hOpenRequest = NULL;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(hOpenRequest) ::InternetCloseHandle( hOpenRequest );
    if(hInternet   ) ::InternetCloseHandle( hInternet    );
    if(hConnect    ) ::InternetCloseHandle( hConnect     );

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\stream.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Stream.cpp

Abstract:
    This file contains the implementation of the MPC::*Stream classes.

Revision History:
    Davide Massarenti   (Dmassare)  07/14/99
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP MPC::BaseStream::Read( /*[out]*/ void*  pv      ,
                                    /*[in] */ ULONG  cb      ,
                                    /*[out]*/ ULONG *pcbRead )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::BaseStream::Read");

    __MPC_FUNC_EXIT(E_NOTIMPL);
}

STDMETHODIMP MPC::BaseStream::Write( /*[in] */ const void*  pv         ,
                                     /*[in] */ ULONG        cb         ,
                                     /*[out]*/ ULONG       *pcbWritten )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::BaseStream::Write");

    __MPC_FUNC_EXIT(E_NOTIMPL);
}

STDMETHODIMP MPC::BaseStream::Seek( /*[in] */ LARGE_INTEGER   libMove         ,
                                    /*[in] */ DWORD dwOrigin                  ,
                                    /*[out]*/ ULARGE_INTEGER *plibNewPosition )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::BaseStream::Seek");

    __MPC_FUNC_EXIT(E_NOTIMPL);
}

STDMETHODIMP MPC::BaseStream::SetSize( /*[in]*/ ULARGE_INTEGER libNewSize )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::BaseStream::SetSize");

    __MPC_FUNC_EXIT(E_NOTIMPL);
}

STDMETHODIMP MPC::BaseStream::CopyTo( /*[in] */ IStream*        pstm       ,
                                      /*[in] */ ULARGE_INTEGER  cb         ,
                                      /*[out]*/ ULARGE_INTEGER *pcbRead    ,
                                      /*[out]*/ ULARGE_INTEGER *pcbWritten )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::BaseStream::CopyTo");

    __MPC_FUNC_EXIT(E_NOTIMPL);
}

STDMETHODIMP MPC::BaseStream::Commit( /*[in]*/ DWORD grfCommitFlags )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::BaseStream::Commit");

    __MPC_FUNC_EXIT(E_NOTIMPL);
}

STDMETHODIMP MPC::BaseStream::Revert()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::BaseStream::Revert");

    __MPC_FUNC_EXIT(E_NOTIMPL);
}

STDMETHODIMP MPC::BaseStream::LockRegion( /*[in]*/ ULARGE_INTEGER libOffset  ,
                                          /*[in]*/ ULARGE_INTEGER cb         ,
                                          /*[in]*/ DWORD          dwLockType )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::BaseStream::LockRegion");

    __MPC_FUNC_EXIT(E_NOTIMPL);
}

STDMETHODIMP MPC::BaseStream::UnlockRegion( /*[in]*/ ULARGE_INTEGER libOffset  ,
                                            /*[in]*/ ULARGE_INTEGER cb         ,
                                            /*[in]*/ DWORD          dwLockType )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::BaseStream::UnlockRegion");

    __MPC_FUNC_EXIT(E_NOTIMPL);
}

STDMETHODIMP MPC::BaseStream::Stat( /*[out]*/ STATSTG *pstatstg    ,
                                    /*[in] */ DWORD    grfStatFlag )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::BaseStream::Stat");

    __MPC_FUNC_EXIT(E_NOTIMPL);
}

STDMETHODIMP MPC::BaseStream::Clone( /*[out]*/ IStream* *ppstm )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::BaseStream::Clone");

    __MPC_FUNC_EXIT(E_NOTIMPL);
}

HRESULT MPC::BaseStream::TransferData( /*[in] */ IStream* src     ,
                                       /*[in] */ IStream* dst     ,
                                       /*[in] */ ULONG    ulCount ,
                                       /*[out]*/ ULONG   *ulDone  )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::BaseStream::TransferData");

    HRESULT hr;
    BYTE    rgBuf[512];
    ULONG   ulTot = 0;
    ULONG   ulRead;
    ULONG   ulWritten;
    ULONG   ul;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(src);
        __MPC_PARAMCHECK_NOTNULL(dst);
    __MPC_PARAMCHECK_END();


    while(1)
    {
        //
        // Compute the amount to read on this pass (-1 == everything).
        //
        if(ulCount == -1)
        {
            ul = sizeof( rgBuf );
        }
        else
        {
            ul = min( sizeof( rgBuf ), ulCount );
        }
        if(ul == 0) break;

        //
        // Read and write.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, src->Read( rgBuf, ul, &ulRead ));
        if(hr == S_FALSE || ulRead == 0) break;

        __MPC_EXIT_IF_METHOD_FAILS(hr, dst->Write( rgBuf, ulRead, &ulWritten ));

        //
        // Update counters.
        //
        if(ulCount != -1)
        {
            ulCount -= ulRead;
        }

        ulTot += ulWritten;
        if(ulRead != ulWritten)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, STG_E_MEDIUMFULL);
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(ulDone) *ulDone = ulTot;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


MPC::FileStream::FileStream()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileStream::FileStream");

                                                             // MPC::wstring m_szFile;
    m_dwDesiredAccess  = GENERIC_READ;                       // DWORD        m_dwDesiredAccess;
    m_dwDisposition    = OPEN_EXISTING;                      // DWORD        m_dwDisposition;
    m_dwSharing        = FILE_SHARE_READ | FILE_SHARE_WRITE; // DWORD        m_dwSharing;
    m_hfFile           = NULL;                               // HANDLE       m_hfFile;
    m_fDeleteOnRelease = false;                              // bool         m_fDeleteOnRelease;
}

MPC::FileStream::~FileStream()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileStream::~FileStream");

    Close();
}

HRESULT MPC::FileStream::Close()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileStream::Close");

	HRESULT hr;


    if(m_hfFile)
    {
        ::CloseHandle( m_hfFile ); m_hfFile = NULL;

        if(m_fDeleteOnRelease)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DeleteFile( m_szFile ));
        }
    }

    hr = S_OK;


	__MPC_FUNC_CLEANUP;

	__MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileStream::Init( /*[in]*/ LPCWSTR szFile          ,
                               /*[in]*/ DWORD   dwDesiredAccess ,
                               /*[in]*/ DWORD   dwDisposition   ,
                               /*[in]*/ DWORD   dwSharing       ,
                               /*[in]*/ HANDLE  hfFile          )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileStream::Init");

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(szFile);
    __MPC_PARAMCHECK_END();


    Close();


    m_szFile          = szFile;
    m_dwDesiredAccess = dwDesiredAccess;
    m_dwDisposition   = dwDisposition;
    m_dwSharing       = dwSharing;


    if(hfFile)
    {
        if(::DuplicateHandle( ::GetCurrentProcess(),    hfFile,
                              ::GetCurrentProcess(), &m_hfFile, m_dwDesiredAccess, FALSE, 0 ) == FALSE)
        {
            m_hfFile = NULL; // For cleanup.

            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::GetLastError() );
        }
    }
    else
    {
        __MPC_EXIT_IF_INVALID_HANDLE__CLEAN(hr, m_hfFile, ::CreateFileW( szFile, m_dwDesiredAccess, dwSharing, NULL, dwDisposition, FILE_ATTRIBUTE_NORMAL, NULL ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileStream::InitForRead( /*[in]*/ LPCWSTR szFile ,
                                      /*[in]*/ HANDLE  hfFile )
{
    return Init( szFile, GENERIC_READ, OPEN_EXISTING, FILE_SHARE_READ | FILE_SHARE_WRITE, hfFile );
}

HRESULT MPC::FileStream::InitForReadWrite( /*[in]*/ LPCWSTR szFile ,
                                           /*[in]*/ HANDLE  hfFile )
{
    return Init( szFile, GENERIC_READ | GENERIC_WRITE, CREATE_ALWAYS, 0, hfFile );
}

HRESULT MPC::FileStream::InitForWrite( /*[in]*/ LPCWSTR szFile ,
                                       /*[in]*/ HANDLE  hfFile )
{
    return Init( szFile, GENERIC_WRITE, CREATE_ALWAYS, 0, hfFile );
}

HRESULT MPC::FileStream::DeleteOnRelease( /*[in]*/ bool fFlag )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileStream::DeleteOnRelease");

    m_fDeleteOnRelease = fFlag;

    __MPC_FUNC_EXIT(S_OK);
}


STDMETHODIMP MPC::FileStream::Read( /*[out]*/ void*  pv      ,
                                    /*[in] */ ULONG  cb      ,
                                    /*[out]*/ ULONG *pcbRead )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileStream::Read");

    HRESULT hr;
    DWORD   dwRead;

    if(pcbRead) *pcbRead = 0;

    if(m_hfFile == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);
    if(pv       == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);


    if(::ReadFile( m_hfFile, pv, cb, &dwRead, NULL ) == FALSE)
    {
        DWORD dwRes = ::GetLastError();

        if(dwRes == ERROR_ACCESS_DENIED)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, STG_E_ACCESSDENIED);
        }

        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }
    else
    {
        if(dwRead == 0 && cb != 0)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
        }
    }

    if(pcbRead) *pcbRead = dwRead;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP MPC::FileStream::Write( /*[in] */ const void*  pv         ,
                                     /*[in] */ ULONG        cb         ,
                                     /*[out]*/ ULONG       *pcbWritten )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileStream::Write");

    HRESULT hr;
    DWORD   dwWritten;

    if(pcbWritten) *pcbWritten = 0;

    if(m_hfFile == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);
    if(pv       == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);

    if((m_dwDesiredAccess & GENERIC_WRITE) == 0) // Read-only stream.
    {
        __MPC_SET_ERROR_AND_EXIT(hr, STG_E_WRITEFAULT);
    }


    if(::WriteFile( m_hfFile, pv, cb, &dwWritten, NULL ) == FALSE)
    {
        DWORD dwRes = ::GetLastError();

        if(dwRes == ERROR_DISK_FULL)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, STG_E_MEDIUMFULL);
        }

        if(dwRes == ERROR_ACCESS_DENIED)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, STG_E_ACCESSDENIED);
        }

        __MPC_SET_ERROR_AND_EXIT(hr, STG_E_CANTSAVE);
    }

    if(pcbWritten) *pcbWritten = dwWritten;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP MPC::FileStream::Seek( /*[in] */ LARGE_INTEGER   libMove         ,
                                    /*[in] */ DWORD           dwOrigin        ,
                                    /*[out]*/ ULARGE_INTEGER *plibNewPosition )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileStream::Seek");

    HRESULT hr;

    if(plibNewPosition)
    {
        plibNewPosition->HighPart = 0;
        plibNewPosition->LowPart  = 0;
    }

    if(m_hfFile == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);

    switch(dwOrigin)
    {
    default             :
    case STREAM_SEEK_CUR: dwOrigin = FILE_CURRENT; break;
    case STREAM_SEEK_SET: dwOrigin = FILE_BEGIN  ; break;
    case STREAM_SEEK_END: dwOrigin = FILE_END    ; break;
    }

    if(::SetFilePointer( m_hfFile, libMove.LowPart, plibNewPosition ? (LONG*)&plibNewPosition->LowPart : NULL, dwOrigin ) == INVALID_SET_FILE_POINTER)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDFUNCTION );
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP MPC::FileStream::Stat( /*[out]*/ STATSTG *pstatstg    ,
                                    /*[in] */ DWORD    grfStatFlag )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileStream::Stat");

    HRESULT                    hr;
    BY_HANDLE_FILE_INFORMATION finfo;

    if(pstatstg == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);
    if(m_hfFile == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);

    if(::GetFileInformationByHandle( m_hfFile, &finfo ) == FALSE)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, STG_E_ACCESSDENIED);
    }


    pstatstg->pwcsName          = NULL;
    pstatstg->type              = STGTY_STREAM;
    pstatstg->cbSize.HighPart   = finfo.nFileSizeHigh;
    pstatstg->cbSize.LowPart    = finfo.nFileSizeLow;
    pstatstg->mtime             = finfo.ftCreationTime;
    pstatstg->ctime             = finfo.ftLastAccessTime;
    pstatstg->atime             = finfo.ftLastWriteTime;
    pstatstg->grfMode           = 0;
    pstatstg->grfLocksSupported = 0;
    pstatstg->clsid             = CLSID_NULL;
    pstatstg->grfStateBits      = 0;
    pstatstg->reserved          = 0;

    if(grfStatFlag != STATFLAG_NONAME)
    {
        pstatstg->pwcsName = (LPWSTR)::CoTaskMemAlloc( (m_szFile.length() + 1) * sizeof(WCHAR) );
        if(pstatstg->pwcsName == NULL)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INSUFFICIENTMEMORY);
        }

        wcscpy( pstatstg->pwcsName, m_szFile.c_str() );
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP MPC::FileStream::Clone( /*[out]*/ IStream* *ppstm )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileStream::Clone");

    HRESULT                                 hr;
    MPC::CComObjectNoLock<MPC::FileStream>* pStm = NULL;

    if(ppstm == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);


    //
    // Create a new stream object.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, pStm->CreateInstance( &pStm ));

    //
    // Initialize it with the same settings.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, pStm->Init( m_szFile.c_str(), m_dwDesiredAccess, m_dwDisposition, m_dwSharing, m_hfFile ));

    //
    // QI for its IStream interface.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, pStm->QueryInterface( IID_IStream, (void**)ppstm )); pStm = NULL;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(pStm) delete pStm;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

MPC::EncryptedStream::EncryptedStream()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::EncryptedStream::EncryptedStream");

                              //  CComPtr<IStream> m_pStream;
    m_hCryptProv     = NULL;  //  HCRYPTPROV       m_hCryptProv;
    m_hKey           = NULL;  //  HCRYPTKEY        m_hKey;
    m_hHash          = NULL;  //  HCRYPTHASH       m_hHash;
                              //  BYTE             m_rgDecrypted[512];
    m_dwDecryptedPos = 0;     //  DWORD            m_dwDecryptedPos;
    m_dwDecryptedLen = 0;     //  DWORD            m_dwDecryptedLen;
}

MPC::EncryptedStream::~EncryptedStream()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::EncryptedStream::~EncryptedStream");

    Close();
}

HRESULT MPC::EncryptedStream::Close()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::EncryptedStream::Close");

    m_pStream.Release();

    if(m_hHash)
    {
        ::CryptDestroyHash( m_hHash ); m_hHash = NULL;
    }

    if(m_hKey)
    {
        ::CryptDestroyKey( m_hKey ); m_hKey = NULL;
    }

    if(m_hCryptProv)
    {
        ::CryptReleaseContext( m_hCryptProv, 0 ); m_hCryptProv = NULL;
    }

    m_dwDecryptedPos = 0;
    m_dwDecryptedLen = 0;

    __MPC_FUNC_EXIT(S_OK);
}

HRESULT MPC::EncryptedStream::Init( /*[in]*/ IStream* pStream    ,
                                    /*[in]*/ LPCWSTR  szPassword )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::EncryptedStream::Init");

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pStream);
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szPassword);
    __MPC_PARAMCHECK_END();


    Close();

    m_pStream = pStream;

    if(!::CryptAcquireContext( &m_hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_SILENT ))
    {
        DWORD dwRes = ::GetLastError();

        if(dwRes != NTE_BAD_KEYSET)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
        }

        //
        // Key set doesn't exist, let's create one.
        //
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptAcquireContext( &m_hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET | CRYPT_SILENT ));
    }

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptCreateHash( m_hCryptProv, CALG_MD5, 0, 0, &m_hHash ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptHashData( m_hHash, (BYTE *)szPassword, sizeof(WCHAR) * wcslen( szPassword ), 0 ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptDeriveKey( m_hCryptProv, CALG_RC4, m_hHash, CRYPT_EXPORTABLE, &m_hKey ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(FAILED(hr)) Close();

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::EncryptedStream::Init( /*[in]*/ IStream*  pStream ,
                                    /*[in]*/ HCRYPTKEY hKey    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::EncryptedStream::Init");

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pStream);
        __MPC_PARAMCHECK_NOTNULL(hKey);
    __MPC_PARAMCHECK_END();


    Close();

    m_pStream = pStream;
    m_hKey    = hKey;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(FAILED(hr)) Close();

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP MPC::EncryptedStream::Read( /*[out]*/ void*  pv      ,
                                             /*[in] */ ULONG  cb      ,
                                             /*[out]*/ ULONG *pcbRead )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::EncryptedStream::Read");

    HRESULT hr;
    DWORD   dwRead = 0;

    if(pcbRead) *pcbRead = 0;

    if(m_pStream == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);
    if(m_hKey    == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);
    if(pv        == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);


    while(cb > 0)
    {
        DWORD dwCount = min( cb, (m_dwDecryptedLen - m_dwDecryptedPos));
        ULONG ulRead;

        if(dwCount)
        {
            ::CopyMemory( pv, &m_rgDecrypted[m_dwDecryptedPos], dwCount );

            m_dwDecryptedPos += dwCount;

            dwRead +=              dwCount;
            cb     -=              dwCount;
            pv      = &((BYTE*)pv)[dwCount];
        }
        else
        {
            dwCount = sizeof(m_rgDecrypted);

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_pStream->Read( m_rgDecrypted, dwCount, &ulRead ));
            if(hr == S_FALSE || ulRead == 0) break;

            dwCount = ulRead;

            __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptDecrypt( m_hKey, 0, FALSE, 0, m_rgDecrypted, &dwCount ));

            m_dwDecryptedPos = 0;
            m_dwDecryptedLen = dwCount;
        }
    }

    if(pcbRead) *pcbRead = dwRead;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP MPC::EncryptedStream::Write( /*[in] */ const void*  pv         ,
                                              /*[in] */ ULONG        cb         ,
                                              /*[out]*/ ULONG       *pcbWritten )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::EncryptedStream::Write");

    HRESULT hr;
    DWORD   dwWritten = 0;


    if(pcbWritten) *pcbWritten = 0;

    if(m_pStream == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);
    if(m_hKey    == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);
    if(pv        == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);


    while(cb > 0)
    {
        BYTE  rgTmp[512];
        DWORD dwCount = min( cb, sizeof(rgTmp) / 2 ); // Let's divide by two, just in case...
        ULONG ulWritten;

        ::CopyMemory( rgTmp, pv, dwCount );

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CryptEncrypt( m_hKey, 0, FALSE, 0, rgTmp, &dwCount, sizeof(rgTmp) ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pStream->Write( rgTmp, dwCount, &ulWritten ));

        dwWritten +=              dwCount;
        cb        -=              dwCount;
        pv         = &((BYTE*)pv)[dwCount];
    }

    if(pcbWritten) *pcbWritten = dwWritten;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP MPC::EncryptedStream::Seek( /*[in] */ LARGE_INTEGER   libMove         ,
                                             /*[in] */ DWORD           dwOrigin        ,
                                             /*[out]*/ ULARGE_INTEGER *plibNewPosition )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::EncryptedStream::Seek");

    HRESULT hr;


    hr = E_NOTIMPL;


    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP MPC::EncryptedStream::Stat( /*[out]*/ STATSTG *pstatstg    ,
                                             /*[in] */ DWORD    grfStatFlag )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::EncryptedStream::Stat");

    HRESULT hr;


    if(m_pStream == NULL) __MPC_SET_ERROR_AND_EXIT(hr, STG_E_INVALIDPOINTER);


    hr = m_pStream->Stat( pstatstg, grfStatFlag );


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

STDMETHODIMP MPC::EncryptedStream::Clone( /*[out]*/ IStream* *ppstm )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::EncryptedStream::Clone");

    HRESULT hr;


    hr = E_NOTIMPL;


    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\security.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Security.cpp

Abstract:
    This file contains the implementation of various security functions/classes.

Revision History:
    Davide Massarenti   (Dmassare)  04/26/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

const SID MPC::SecurityDescriptor::s_EveryoneSid = { SID_REVISION, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID        };
const SID MPC::SecurityDescriptor::s_SystemSid   = { SID_REVISION, 1, SECURITY_NT_AUTHORITY       , SECURITY_LOCAL_SYSTEM_RID };

const MPC::SID2 MPC::SecurityDescriptor::s_AdminSid =
{
    SID_REVISION               ,
    2                          ,
    SECURITY_NT_AUTHORITY      ,
    SECURITY_BUILTIN_DOMAIN_RID,
    DOMAIN_USER_RID_ADMIN
};

const MPC::SID2 MPC::SecurityDescriptor::s_Alias_AdminsSid =
{
    SID_REVISION               ,
    2                          ,
    SECURITY_NT_AUTHORITY      ,
    SECURITY_BUILTIN_DOMAIN_RID,
    DOMAIN_ALIAS_RID_ADMINS
};

const MPC::SID2 MPC::SecurityDescriptor::s_Alias_PowerUsersSid =
{
    SID_REVISION               ,
    2                          ,
    SECURITY_NT_AUTHORITY      ,
    SECURITY_BUILTIN_DOMAIN_RID,
    DOMAIN_ALIAS_RID_POWER_USERS
};

const MPC::SID2 MPC::SecurityDescriptor::s_Alias_UsersSid =
{
    SID_REVISION               ,
    2                          ,
    SECURITY_NT_AUTHORITY      ,
    SECURITY_BUILTIN_DOMAIN_RID,
    DOMAIN_ALIAS_RID_USERS
};

const MPC::SID2 MPC::SecurityDescriptor::s_Alias_GuestsSid =
{
    SID_REVISION               ,
    2                          ,
    SECURITY_NT_AUTHORITY      ,
    SECURITY_BUILTIN_DOMAIN_RID,
    DOMAIN_ALIAS_RID_GUESTS
};

////////////////////////////////////////////////////////////////////////////////

static DWORD Local_GenerateAccessMask( /*[in]*/ SECURITY_INFORMATION secInfo, /*[in]*/ bool fRead )
{
	DWORD dwAccess;

	if(fRead)
	{
		dwAccess = 0;

		if(secInfo & (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION))
		{
			dwAccess |= READ_CONTROL;
		}

		if(secInfo & SACL_SECURITY_INFORMATION)
		{
			dwAccess |= ACCESS_SYSTEM_SECURITY;
		}
	}
	else
	{
		dwAccess = MAXIMUM_ALLOWED;

		if(secInfo & (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION))
		{
			dwAccess |= WRITE_OWNER;
		}

		if(secInfo & DACL_SECURITY_INFORMATION)
		{
			dwAccess |= WRITE_DAC;
		}

		if(secInfo & SACL_SECURITY_INFORMATION)
		{
			dwAccess |= ACCESS_SYSTEM_SECURITY;
		}
	}

	return dwAccess;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SecurityDescriptor::AllocateMemory( /*[in/out]*/ LPVOID& ptr  ,
                                                 /*[in]    */ size_t  iLen )
{
    ReleaseMemory( ptr );

    ATLTRY(ptr = malloc( iLen ));

    return (ptr == NULL) ? E_OUTOFMEMORY : S_OK;
}

void MPC::SecurityDescriptor::ReleaseMemory( /*[in/out]*/ LPVOID& ptr )
{
    if(ptr)
    {
        free( ptr ); ptr = NULL;
    }
}

void MPC::SecurityDescriptor::InitLsaString( /*[in/out]*/ LSA_UNICODE_STRING& lsaString ,
                                             /*[in    ]*/ LPCWSTR             szText    )
{
    if(szText == NULL)
    {
        lsaString.Buffer        = NULL;
        lsaString.Length        = 0;
        lsaString.MaximumLength = 0;
    }
    else
    {
        DWORD dwLen = wcslen( szText );

        lsaString.Buffer        = (LPWSTR) szText;
        lsaString.Length        =          dwLen    * sizeof(WCHAR);
        lsaString.MaximumLength =         (dwLen+1) * sizeof(WCHAR);
    }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SecurityDescriptor::SetPrivilege( /*[in]*/ LPCWSTR Privilege ,
                                               /*[in]*/ BOOL    bEnable   ,
                                               /*[in]*/ HANDLE  hToken    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::SetPrivilege" );

    HRESULT          hr;
    TOKEN_PRIVILEGES tp;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD            cbPrevious = sizeof(TOKEN_PRIVILEGES);
    LUID             luid;
    HANDLE           hTokenUsed = NULL;


    // if no token specified open process token
    if(hToken == NULL)
    {
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::OpenProcessToken( ::GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hTokenUsed ));

        hToken = hTokenUsed;
    }

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::LookupPrivilegeValueW( NULL, Privilege, &luid ));


    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::AdjustTokenPrivileges( hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious ));

    tpPrevious.PrivilegeCount     = 1;
    tpPrevious.Privileges[0].Luid = luid;

    if(bEnable) tpPrevious.Privileges[0].Attributes |=  SE_PRIVILEGE_ENABLED;
    else        tpPrevious.Privileges[0].Attributes &= ~SE_PRIVILEGE_ENABLED;

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::AdjustTokenPrivileges( hToken, FALSE, &tpPrevious, cbPrevious, NULL, NULL ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(hTokenUsed) ::CloseHandle( hTokenUsed );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::AddPrivilege( /*[in]*/ LPCWSTR szPrincipal ,
                                               /*[in]*/ LPCWSTR szPrivilege )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::AddPrivilege" );

    HRESULT               hr;
    NTSTATUS              ntRes;
    LSA_OBJECT_ATTRIBUTES objectAttributes; ::ZeroMemory( &objectAttributes, sizeof(objectAttributes) );
    LSA_UNICODE_STRING    lsaPrivilege;
    PSID                  pSid         = NULL;
    HANDLE                policyHandle = NULL;


    InitLsaString( lsaPrivilege, szPrivilege );

    __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( szPrincipal, pSid ));


    ntRes = ::LsaOpenPolicy( NULL, &objectAttributes, POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES, &policyHandle );
    if(ntRes != STATUS_SUCCESS)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::LsaNtStatusToWinError( ntRes ));
    }

    ntRes = ::LsaAddAccountRights( policyHandle, pSid, &lsaPrivilege, 1 );
    if(ntRes != STATUS_SUCCESS)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::LsaNtStatusToWinError( ntRes ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( (void*&)pSid );

    if(policyHandle) ::LsaClose( policyHandle );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::RemovePrivilege( /*[in]*/ LPCWSTR szPrincipal ,
                                                  /*[in]*/ LPCWSTR szPrivilege )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::RemovePrivilege" );

    HRESULT               hr;
    NTSTATUS              ntRes;
    LSA_OBJECT_ATTRIBUTES objectAttributes; ::ZeroMemory( &objectAttributes, sizeof(objectAttributes) );
    LSA_UNICODE_STRING    lsaPrivilege;
    PSID                  pSid         = NULL;
    HANDLE                policyHandle = NULL;


    InitLsaString( lsaPrivilege, szPrivilege );

    __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( szPrincipal, pSid ));


    ntRes = ::LsaOpenPolicy( NULL, &objectAttributes, POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES, &policyHandle );
    if(ntRes != STATUS_SUCCESS)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::LsaNtStatusToWinError( ntRes ));
    }


    ntRes = ::LsaRemoveAccountRights( policyHandle, pSid, FALSE, &lsaPrivilege, 1 );
    if(ntRes != STATUS_SUCCESS)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::LsaNtStatusToWinError( ntRes ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( (void*&)pSid );

    if(policyHandle) ::LsaClose( policyHandle );

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SecurityDescriptor::GetTokenSids( /*[in] */ HANDLE  hToken     ,
                                               /*[out]*/ PSID   *ppUserSid  ,
                                               /*[out]*/ PSID   *ppGroupSid )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::GetTokenSids" );

    HRESULT              hr;
    DWORD                dwRes;
    PTOKEN_USER          ptkUser  = NULL;
    PTOKEN_PRIMARY_GROUP ptkGroup = NULL;
    PSID                 pSid     = NULL;
    DWORD                dwSize   = 0;


    if(ppUserSid ) *ppUserSid  = NULL;
    if(ppGroupSid) *ppGroupSid = NULL;


    if(ppUserSid)
    {
        // Get length required for TokenUser by specifying buffer length of 0
        ::GetTokenInformation( hToken, TokenUser, NULL, 0, &dwSize );
        if((dwRes = ::GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (void*&)ptkUser, dwSize ));

        // Get Sid of process token.
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetTokenInformation( hToken, TokenUser, ptkUser, dwSize, &dwSize ));

        // Make a copy of the Sid for the return value
        dwSize = ::GetLengthSid( ptkUser->User.Sid );
        __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( pSid, dwSize ));

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CopySid( dwSize, pSid, ptkUser->User.Sid ));

        ATLASSERT(::IsValidSid( pSid ));

        *ppUserSid = pSid; pSid = NULL;
    }

    if(ppGroupSid)
    {
        // Get length required for TokenPrimaryGroup by specifying buffer length of 0
        ::GetTokenInformation( hToken, TokenPrimaryGroup, NULL, 0, &dwSize );
        if((dwRes = ::GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (void*&)ptkGroup, dwSize ));

        // Get Sid of process token.
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetTokenInformation( hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize ));

        // Make a copy of the Sid for the return value
        dwSize = ::GetLengthSid( ptkGroup->PrimaryGroup );
        __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( pSid, dwSize ));

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CopySid( dwSize, pSid, ptkGroup->PrimaryGroup ));

        ATLASSERT(::IsValidSid( pSid ));

        *ppGroupSid = pSid; pSid = NULL;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( (void*&)ptkUser  );
    ReleaseMemory( (void*&)ptkGroup );
    ReleaseMemory( (void*&)pSid     );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::GetProcessSids( /*[out]*/ PSID *ppUserSid  ,
                                                 /*[out]*/ PSID *ppGroupSid )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::GetProcessSids" );

    HRESULT hr;
    HANDLE  hToken = NULL;


    if(ppUserSid ) *ppUserSid  = NULL;
    if(ppGroupSid) *ppGroupSid = NULL;


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::OpenProcessToken( ::GetCurrentProcess(), TOKEN_QUERY, &hToken ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetTokenSids( hToken, ppUserSid, ppGroupSid ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(hToken) ::CloseHandle( hToken );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::GetThreadSids( /*[out]*/ PSID *ppUserSid   ,
                                                /*[out]*/ PSID *ppGroupSid  ,
                                                /*[in] */ BOOL  bOpenAsSelf )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::GetThreadSids" );

    HRESULT hr;
    HANDLE  hToken = NULL;


    if(ppUserSid ) *ppUserSid  = NULL;
    if(ppGroupSid) *ppGroupSid = NULL;


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::OpenThreadToken( ::GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetTokenSids( hToken, ppUserSid, ppGroupSid ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(hToken) ::CloseHandle( hToken );

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SecurityDescriptor::VerifyPrincipal( /*[in]*/ LPCWSTR szPrincipal )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::VerifyPrincipal" );

    HRESULT hr;
    PSID    pSid = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( szPrincipal, pSid ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( (void*&)pSid );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::ConvertPrincipalToSID( /*[in ]*/ LPCWSTR  szPrincipal ,
                                                        /*[out]*/ PSID&    pSid        ,
                                                        /*[out]*/ LPCWSTR *pszDomain   )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::ConvertPrincipalToSID" );

    HRESULT      hr;
    DWORD        dwRes;
    LPWSTR       szDomain     = NULL;
    DWORD        dwDomainSize = 0;
    DWORD        dwSidSize    = 0;
	PSID         pSidLocal    = NULL;
    SID_NAME_USE snu;


    if(pszDomain) *pszDomain = NULL;

	if(::ConvertStringSidToSidW( szPrincipal, &pSidLocal ))
	{
		dwSidSize = ::GetLengthSid( pSidLocal );

		__MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (void*&)pSid, dwSidSize ));

		__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CopySid( dwSidSize, pSid, pSidLocal ));
	}
	else
	{
		//
		// Call to get size info for alloc
		//
		::LookupAccountNameW( NULL, szPrincipal, NULL, &dwSidSize, NULL, &dwDomainSize, &snu );
		if((dwRes = ::GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
		{
			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (void*&)pSid    ,                dwSidSize       ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (void*&)szDomain, sizeof(WCHAR)*(dwDomainSize+1) ));


		__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::LookupAccountNameW( NULL, szPrincipal, pSid, &dwSidSize, szDomain, &dwDomainSize, &snu ));

		if(pszDomain) { *pszDomain = szDomain; szDomain = NULL; }
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(pSidLocal) ::LocalFree( pSidLocal );

    ReleaseMemory( (void*&)szDomain );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::ConvertSIDToPrincipal( /*[in] */ PSID     pSid         ,
                                                        /*[out]*/ LPCWSTR *pszPrincipal ,
                                                        /*[out]*/ LPCWSTR *pszDomain    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::ConvertSIDToPrincipal" );

    HRESULT      hr;
    DWORD        dwRes;
    LPWSTR       szPrincipal = NULL;
    LPWSTR       szDomain    = NULL;
    DWORD        dwPrincipalSize = 0;
    DWORD        dwDomainSize    = 0;
    SID_NAME_USE snu;


    if(pszPrincipal) *pszPrincipal = NULL;
    if(pszDomain   ) *pszDomain    = NULL;


    // Call to get size info for alloc
    ::LookupAccountSidW( NULL, pSid, NULL, &dwPrincipalSize, NULL, &dwDomainSize, &snu );
    if((dwRes = ::GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (void*&)szPrincipal, sizeof(WCHAR)*(dwPrincipalSize+1) ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (void*&)szDomain   , sizeof(WCHAR)*(dwDomainSize   +1) ));


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::LookupAccountSidW( NULL, pSid, szPrincipal, &dwPrincipalSize, szDomain, &dwDomainSize, &snu ));


    if(pszDomain == NULL && szDomain[0])
    {
        if(pszPrincipal)
        {
            LPWSTR szPrincipalAndDomain = NULL;

            __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (void*&)szPrincipalAndDomain, sizeof(WCHAR)*(dwPrincipalSize+dwDomainSize+2) ));

            wcscpy( szPrincipalAndDomain, szDomain    );
            wcscat( szPrincipalAndDomain, L"\\"       );
            wcscat( szPrincipalAndDomain, szPrincipal );

            *pszPrincipal = szPrincipalAndDomain;
        }
    }
    else
    {
        if(pszPrincipal) { *pszPrincipal = szPrincipal; szPrincipal = NULL; }
        if(pszDomain   ) { *pszDomain    = szDomain   ; szDomain    = NULL; }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( (void*&)szPrincipal );
    ReleaseMemory( (void*&)szDomain    );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::ConvertSIDToPrincipal( /*[in] */ PSID          pSid         ,
                                                        /*[out]*/ MPC::wstring& strPrincipal )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::ConvertSIDToPrincipal" );

    HRESULT hr;
    LPCWSTR szPrincipal = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertSIDToPrincipal( pSid, &szPrincipal ));

    strPrincipal = SAFEWSTR( szPrincipal );
    hr           = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( (void*&)szPrincipal );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::NormalizePrincipalToStringSID( /*[in ]*/ LPCWSTR 		szPrincipal ,
																/*[in ]*/ LPCWSTR 		szDomain    ,
																/*[out]*/ MPC::wstring& strSID      )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::NormalizePrincipalToStringSID" );

    HRESULT      hr;
	MPC::wstring strAccount;
    PSID         pSid      = NULL;
    LPWSTR       szUserSid = NULL;


    if(szDomain)
    {
		strAccount  = szDomain;
		strAccount += L"\\";
	}
	strAccount += SAFEWSTR(szPrincipal);

	//
	// First convert the principal to a SID, then back to a string.
	//
    __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( strAccount.c_str(), pSid ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::ConvertSidToStringSidW( pSid, &szUserSid ));


	strSID = SAFEWSTR( szUserSid );
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    if(szUserSid) ::LocalFree( szUserSid );

    ReleaseMemory( (void*&)pSid );

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SecurityDescriptor::GetAccountName( /*[in]*/ LPCWSTR szPrincipal, /*[out]*/ MPC::wstring& strName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::GetAccountName" );

    HRESULT hr;
	PSID    pSid     = NULL;
	LPCWSTR szUser   = NULL;
	LPCWSTR szDomain = NULL;


	__MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( szPrincipal, pSid ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, ConvertSIDToPrincipal( pSid, &szUser, &szDomain ));

	strName = SAFEWSTR(szUser);

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

	ReleaseMemory( (void*&)pSid     );
	ReleaseMemory( (void*&)szUser   );
	ReleaseMemory( (void*&)szDomain );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::GetAccountDomain( /*[in]*/ LPCWSTR szPrincipal, /*[out]*/ MPC::wstring& strName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::GetAccountDomain" );

    HRESULT hr;
	PSID    pSid     = NULL;
	LPCWSTR szUser   = NULL;
	LPCWSTR szDomain = NULL;


	__MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( szPrincipal, pSid ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, ConvertSIDToPrincipal( pSid, &szUser, &szDomain ));

	strName = SAFEWSTR(szDomain);

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

	ReleaseMemory( (void*&)pSid     );
	ReleaseMemory( (void*&)szUser   );
	ReleaseMemory( (void*&)szDomain );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::GetAccountDisplayName( /*[in]*/ LPCWSTR szPrincipal, /*[out]*/ MPC::wstring& strName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::GetAccountDisplayName" );

    HRESULT hr;
	PSID    pSid   	  = NULL;
	LPCWSTR szUser 	  = NULL;
	LPWSTR  szDisplay = NULL;
	ULONG   lSize     = 0;


	__MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( szPrincipal, pSid ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, ConvertSIDToPrincipal( pSid, &szUser     ));

	//
	// First call is to get size, second to get the actual data.
	//
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::TranslateNameW( szUser, NameSamCompatible, NameDisplay, NULL, &lSize ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (void*&)szDisplay, sizeof(WCHAR)*(lSize+1) ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::TranslateNameW( szUser, NameSamCompatible, NameDisplay, szDisplay, &lSize ));

	strName = SAFEWSTR(szDisplay);

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

	ReleaseMemory( (void*&)pSid      );
	ReleaseMemory( (void*&)szUser    );
	ReleaseMemory( (void*&)szDisplay );

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SecurityDescriptor::CopyACL( /*[in]*/ PACL pDest,
                                          /*[in]*/ PACL pSrc )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::CopyACL" );

    HRESULT              hr;
    ACL_SIZE_INFORMATION aclSizeInfo;
    ACE_HEADER*          aceHeader;
    LPVOID               pACE;


    if(pSrc)
    {
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetAclInformation( pSrc, (LPVOID)&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation ));

        // Copy all of the ACEs to the new ACL
        for(DWORD i = 0; i < aclSizeInfo.AceCount; i++)
        {
            __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetAce( pSrc, i, (LPVOID*)&pACE ));

            aceHeader = (ACE_HEADER *)pACE;

            __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::AddAce( pDest, ACL_REVISION, 0xFFFFFFFF, pACE, aceHeader->AceSize ));
        }

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::IsValidAcl( pDest ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::CloneACL( /*[in/out]*/ PACL& pDest ,
                                           /*[in    ]*/ PACL  pSrc  )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::CloneACL" );

    HRESULT              hr;
    ACL_SIZE_INFORMATION aclSizeInfo;


    ReleaseMemory( (void*&)pDest );

    if(pSrc)
    {
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetAclInformation( pSrc, (LPVOID)&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (void*&)pDest, pSrc->AclSize ));

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::InitializeAcl( pDest, pSrc->AclSize, ACL_REVISION ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, CopyACL( pDest, pSrc ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::EnsureACLSize( /*[in/out]*/ PACL& pACL     ,
                                                /*[in    ]*/ DWORD dwExpand )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::EnsureACLSize" );

    HRESULT              hr;
    DWORD                dwSizeAvailable;
    DWORD                dwSizeRequired;
    ACL_SIZE_INFORMATION aclSizeInfo;
    PACL                 newACL = NULL;


    if(pACL)
    {
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetAclInformation( pACL, (LPVOID)&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation ));

        dwSizeAvailable = pACL->AclSize;
        dwSizeRequired  = aclSizeInfo.AclBytesInUse + dwExpand;
    }
    else
    {
        ::ZeroMemory( &aclSizeInfo, sizeof(aclSizeInfo) );

        dwSizeAvailable = 0;
        dwSizeRequired  = sizeof(ACL) + dwExpand;
    }

    //
    // If too little free space is
    //
    if(dwSizeAvailable < dwSizeRequired)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (void*&)newACL, dwSizeRequired ));

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::InitializeAcl( newACL, dwSizeRequired, ACL_REVISION ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, CopyACL( newACL, pACL ));

        ReleaseMemory( (void*&)pACL ); pACL = newACL; newACL = NULL;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( (void*&)newACL );

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SecurityDescriptor::RemovePrincipalFromACL( /*[in]*/ PACL pACL          ,
                                                         /*[in]*/ PSID pPrincipalSid ,
                                                         /*[in]*/ int  pos           )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::RemovePrincipalFromACL" );

    HRESULT              hr;
    DWORD                i;
    int                  seen = 0;
    ACL_SIZE_INFORMATION aclSizeInfo;
    PACE_HEADER          aceHeader;
    PSID                 pSid;


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetAclInformation( pACL, (LPVOID)&aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation ));

    for(i = 0; i < aclSizeInfo.AceCount; i++)
    {
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetAce(pACL, i, (LPVOID*)&aceHeader));

        switch(aceHeader->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE       : pSid = &((PACCESS_ALLOWED_ACE       )aceHeader)->SidStart; break;
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE: pSid = &((PACCESS_ALLOWED_OBJECT_ACE)aceHeader)->SidStart; break;
        case ACCESS_DENIED_ACE_TYPE        : pSid = &((PACCESS_DENIED_ACE        )aceHeader)->SidStart; break;
        case ACCESS_DENIED_OBJECT_ACE_TYPE : pSid = &((PACCESS_DENIED_OBJECT_ACE )aceHeader)->SidStart; break;
        case SYSTEM_AUDIT_ACE_TYPE         : pSid = &((PSYSTEM_AUDIT_ACE         )aceHeader)->SidStart; break;
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE  : pSid = &((PSYSTEM_AUDIT_OBJECT_ACE  )aceHeader)->SidStart; break;
        default                            : __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
        }

        if(::EqualSid( pPrincipalSid, pSid ))
        {
            if(seen == pos || pos == -1)
            {
                ::DeleteAce( pACL, i );

                aclSizeInfo.AceCount--;
                i--;
            }

            seen++;
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::AddACEToACL( /*[in/out]*/ PACL& pACL                    ,
                                              /*[in    ]*/ PSID  pPrincipalSid           ,
                                              /*[in    ]*/ DWORD dwAceType               ,
                                              /*[in    ]*/ DWORD dwAceFlags              ,
                                              /*[in    ]*/ DWORD dwAccessMask            ,
                                              /*[in    ]*/ GUID* guidObjectType          ,
                                              /*[in    ]*/ GUID* guidInheritedObjectType )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::AddACEToACL" );

    HRESULT hr;
    DWORD   dwSize;
    BOOL    fRes;


    dwSize = ::GetLengthSid( pPrincipalSid );

    switch(dwAceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE       : dwSize += sizeof(ACCESS_ALLOWED_ACE       ) - sizeof(DWORD); break;
    case ACCESS_ALLOWED_OBJECT_ACE_TYPE: dwSize += sizeof(ACCESS_ALLOWED_OBJECT_ACE) - sizeof(DWORD); break;
    case ACCESS_DENIED_ACE_TYPE        : dwSize += sizeof(ACCESS_DENIED_ACE        ) - sizeof(DWORD); break;
    case ACCESS_DENIED_OBJECT_ACE_TYPE : dwSize += sizeof(ACCESS_DENIED_OBJECT_ACE ) - sizeof(DWORD); break;
    case SYSTEM_AUDIT_ACE_TYPE         : dwSize += sizeof(SYSTEM_AUDIT_ACE         ) - sizeof(DWORD); break;
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE  : dwSize += sizeof(SYSTEM_AUDIT_OBJECT_ACE  ) - sizeof(DWORD); break;
    default                            : __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureACLSize( pACL, dwSize ));

    switch(dwAceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE       : fRes = ::AddAccessAllowedAceEx    ( pACL, ACL_REVISION, dwAceFlags, dwAccessMask                                         , pPrincipalSid             ); break;
    case ACCESS_ALLOWED_OBJECT_ACE_TYPE: fRes = ::AddAccessAllowedObjectAce( pACL, ACL_REVISION, dwAceFlags, dwAccessMask, guidObjectType, guidInheritedObjectType, pPrincipalSid             ); break;
    case ACCESS_DENIED_ACE_TYPE        : fRes = ::AddAccessDeniedAceEx     ( pACL, ACL_REVISION, dwAceFlags, dwAccessMask                                         , pPrincipalSid             ); break;
    case ACCESS_DENIED_OBJECT_ACE_TYPE : fRes = ::AddAccessDeniedObjectAce ( pACL, ACL_REVISION, dwAceFlags, dwAccessMask, guidObjectType, guidInheritedObjectType, pPrincipalSid             ); break;
    case SYSTEM_AUDIT_ACE_TYPE         : fRes = ::AddAuditAccessAceEx      ( pACL, ACL_REVISION, dwAceFlags, dwAccessMask                                         , pPrincipalSid, TRUE, TRUE ); break;
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE  : fRes = ::AddAuditAccessObjectAce  ( pACL, ACL_REVISION, dwAceFlags, dwAccessMask, guidObjectType, guidInheritedObjectType, pPrincipalSid, TRUE, TRUE ); break;
    }

    if(fRes == FALSE)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::GetLastError());
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

MPC::SecurityDescriptor::SecurityDescriptor()
{
    m_pSD             = NULL; //  PSECURITY_DESCRIPTOR m_pSD;
    m_pOwner          = NULL; //  PSID                 m_pOwner;
    m_bOwnerDefaulted = TRUE; //  BOOL                 m_bOwnerDefaulted;
    m_pGroup          = NULL; //  PSID                 m_pGroup;
    m_bGroupDefaulted = TRUE; //  BOOL                 m_bGroupDefaulted;
    m_pDACL           = NULL; //  PACL                 m_pDACL;
    m_bDaclDefaulted  = TRUE; //  BOOL                 m_bDaclDefaulted;
    m_pSACL           = NULL; //  PACL                 m_pSACL;
    m_bSaclDefaulted  = TRUE; //  BOOL                 m_bSaclDefaulted;
}

MPC::SecurityDescriptor::~SecurityDescriptor()
{
    CleanUp();
}

void MPC::SecurityDescriptor::CleanUp()
{
    ReleaseMemory( (void*&)m_pSD    );
    ReleaseMemory( (void*&)m_pOwner );
    ReleaseMemory( (void*&)m_pGroup );
    ReleaseMemory( (void*&)m_pDACL  );
    ReleaseMemory( (void*&)m_pSACL  );

    m_bOwnerDefaulted = TRUE;
    m_bGroupDefaulted = TRUE;
    m_bDaclDefaulted  = TRUE;
    m_bSaclDefaulted  = TRUE;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SecurityDescriptor::Initialize()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::Initialize" );

    HRESULT hr;


    CleanUp();

    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (void*&)m_pSD, sizeof(SECURITY_DESCRIPTOR) ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::InitializeSecurityDescriptor( m_pSD, SECURITY_DESCRIPTOR_REVISION ));

    //
    // Set the DACL to allow EVERYONE.
    //
    ::SetSecurityDescriptorDacl( m_pSD, TRUE, NULL, FALSE );

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::InitializeFromProcessToken( /*[in]*/ BOOL bDefaulted )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::InitializeFromProcessToken" );

    HRESULT hr;
    PSID    pUserSid  = NULL;
    PSID    pGroupSid = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetProcessSids( &pUserSid, &pGroupSid ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, SetOwner( pUserSid , bDefaulted ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SetGroup( pGroupSid, bDefaulted ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( pUserSid  );
    ReleaseMemory( pGroupSid );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::InitializeFromThreadToken( /*[in]*/ BOOL bDefaulted            ,
                                                            /*[in]*/ BOOL bRevertToProcessToken )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::InitializeFromThreadToken" );

    HRESULT hr;
    PSID    pUserSid  = NULL;
    PSID    pGroupSid = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());

    if(FAILED(hr = GetThreadSids( &pUserSid, &pGroupSid )))
    {
        if(HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, GetProcessSids( &pUserSid, &pGroupSid ));
        }
        else
        {
            __MPC_FUNC_LEAVE;
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, SetOwner( pUserSid , bDefaulted ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SetGroup( pGroupSid, bDefaulted ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( pUserSid  );
    ReleaseMemory( pGroupSid );

    __MPC_FUNC_EXIT(hr);
}
////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SecurityDescriptor::ConvertFromString( /*[in]*/ LPCWSTR szSD )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::ConvertFromString" );

    HRESULT              hr;
    PSECURITY_DESCRIPTOR pSD  = NULL;


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::ConvertStringSecurityDescriptorToSecurityDescriptorW( szSD, SDDL_REVISION_1, &pSD, NULL ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Attach( pSD ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(pSD) ::LocalFree( pSD );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::ConvertToString( /*[out]*/ BSTR *pbstrSD )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::ConvertToString" );

    HRESULT hr;
    LPWSTR  szSD = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pbstrSD,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::ConvertSecurityDescriptorToStringSecurityDescriptorW( m_pSD, SDDL_REVISION_1, s_SecInfo_ALL, &szSD, NULL ));

    *pbstrSD = ::SysAllocString( szSD );
    hr       = S_OK;


    __MPC_FUNC_CLEANUP;

    if(szSD) ::LocalFree( szSD );

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SecurityDescriptor::Attach( /*[in]*/ PSECURITY_DESCRIPTOR pSelfRelativeSD )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::Attach" );

    HRESULT                     hr;
    PSID                		pOwnerSid;
    PSID                		pGroupSid;
    PACL                		pDACL;
    PACL                		pSACL;
    BOOL                		bDefaulted;
    BOOL                		bPresent;
    ACCESS_ALLOWED_ACE* 		pACE;
	SECURITY_DESCRIPTOR_CONTROL sdcFlags;
	DWORD                       dwRev;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());

	if(pSelfRelativeSD == NULL) // Empty SD?
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

	//
	// Copy flags of interest.
	//
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetSecurityDescriptorControl( pSelfRelativeSD , &sdcFlags, &dwRev     ));
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetSecurityDescriptorControl( m_pSD, s_sdcMask,  sdcFlags & s_sdcMask ));

    //
    // Copy owner and group.
    //
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetSecurityDescriptorOwner( pSelfRelativeSD, &pOwnerSid, &bDefaulted ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SetOwner( pOwnerSid, bDefaulted ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetSecurityDescriptorGroup( pSelfRelativeSD, &pGroupSid, &bDefaulted ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, SetGroup( pGroupSid, bDefaulted ));


    //
    // Copy the existing DACL.
    //
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetSecurityDescriptorDacl( pSelfRelativeSD, &bPresent, &pDACL, &m_bDaclDefaulted ));

    if(bPresent)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, CloneACL( m_pDACL, pDACL ));

        //
        // set the DACL
        //
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetSecurityDescriptorDacl( m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, m_bDaclDefaulted ));
    }


    //
    // Copy the existing SACL.
    //
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetSecurityDescriptorSacl( pSelfRelativeSD, &bPresent, &pSACL, &m_bSaclDefaulted ));

    if(bPresent)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, CloneACL( m_pSACL, pSACL ));

        // set the SACL
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, m_bSaclDefaulted ));
    }


	if(m_pSD)
	{
		__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::IsValidSecurityDescriptor( m_pSD ));
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::AttachObject( /*[in]*/ HANDLE hObject, /*[in]*/ SECURITY_INFORMATION secInfo )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::AttachObject" );

    HRESULT              hr;
    DWORD                dwRes;
    DWORD                dwSize;
    PSECURITY_DESCRIPTOR pSD = NULL;


    ::GetKernelObjectSecurity( hObject, secInfo, pSD, 0, &dwSize );
    if((dwRes = ::GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
    {
		if(dwRes == ERROR_SUCCESS)
		{
			__MPC_SET_ERROR_AND_EXIT(hr, Initialize()); // Empty SD.
		}

        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( pSD, dwSize ));


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetKernelObjectSecurity( hObject, secInfo, pSD, dwSize, &dwSize ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Attach( pSD ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( pSD );

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SecurityDescriptor::GetControl( /*[out]*/ SECURITY_DESCRIPTOR_CONTROL& sdc )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::GetControl" );

    HRESULT hr;
	DWORD   dwRev;

    ATLASSERT(m_pSD);


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetSecurityDescriptorControl( m_pSD, &sdc, &dwRev ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::SetControl( /*[in ]*/ SECURITY_DESCRIPTOR_CONTROL sdc )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::SetControl" );

    HRESULT hr;

    ATLASSERT(m_pSD);


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetSecurityDescriptorControl( m_pSD, s_sdcMask, s_sdcMask & sdc ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::SecurityDescriptor::SetOwner( /*[in]*/ PSID pOwnerSid  ,
                                           /*[in]*/ BOOL bDefaulted )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::SetOwner" );

    HRESULT hr;

    ATLASSERT(m_pSD);


    m_bOwnerDefaulted = bDefaulted;

    //
    // Mark the SD as having no owner
    //
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetSecurityDescriptorOwner( m_pSD, NULL, bDefaulted ));

    ReleaseMemory( m_pOwner );

    if(pOwnerSid)
    {
        // Make a copy of the Sid for the return value
        DWORD dwSize = ::GetLengthSid( pOwnerSid );

        __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( m_pOwner, dwSize ));

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CopySid( dwSize, m_pOwner, pOwnerSid ));

        ATLASSERT(::IsValidSid( m_pOwner ));

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetSecurityDescriptorOwner( m_pSD, m_pOwner, bDefaulted ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::SetOwner( /*[in]*/ LPCWSTR szOwnerName ,
                                           /*[in]*/ BOOL    bDefaulted  )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::SetOwner" );

    HRESULT hr;
    PSID    pOwnerSid = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( szOwnerName, pOwnerSid ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, SetOwner( pOwnerSid, bDefaulted ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( (void*&)pOwnerSid );

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::SecurityDescriptor::SetGroup( /*[in]*/ PSID pGroupSid  ,
                                           /*[in]*/ BOOL bDefaulted )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::SetGroup" );

    HRESULT hr;

    ATLASSERT(m_pSD);


    m_bGroupDefaulted = bDefaulted;

    //
    // Mark the SD as having no owner
    //
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetSecurityDescriptorGroup( m_pSD, NULL, bDefaulted ));

    ReleaseMemory( m_pGroup );

    if(pGroupSid)
    {
        // Make a copy of the Sid for the return value
        DWORD dwSize = ::GetLengthSid( pGroupSid );

        __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( m_pGroup, dwSize ));

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CopySid( dwSize, m_pGroup, pGroupSid ));

        ATLASSERT(::IsValidSid( m_pGroup ));

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetSecurityDescriptorGroup( m_pSD, m_pGroup, bDefaulted ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::SetGroup( /*[in]*/ LPCWSTR szGroupName ,
                                           /*[in]*/ BOOL    bDefaulted  )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::SetGroup" );

    HRESULT hr;
    PSID    pGroupSid = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( szGroupName, pGroupSid ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, SetGroup( pGroupSid, bDefaulted ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( (void*&)pGroupSid );

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SecurityDescriptor::Remove( /*[in]*/ PSID pPrincipalSid ,
                                         /*[in]*/ int  pos           )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::Remove" );

    HRESULT hr;

    ATLASSERT(m_pSD);

    __MPC_EXIT_IF_METHOD_FAILS(hr, RemovePrincipalFromACL( m_pDACL, pPrincipalSid, pos ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetSecurityDescriptorDacl( m_pSD, TRUE, m_pDACL, FALSE ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::Remove( /*[in]*/ LPCWSTR szPrincipal ,
                                         /*[in]*/ int     pos         )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::Remove" );

    HRESULT hr;
    PSID    pPrincipalSid = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( szPrincipal, pPrincipalSid ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Remove( pPrincipalSid, pos ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( (void*&)pPrincipalSid );

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::SecurityDescriptor::Add( /*[in]*/ PSID  pPrincipalSid           ,
                                      /*[in]*/ DWORD dwAceType               ,
                                      /*[in]*/ DWORD dwAceFlags              ,
                                      /*[in]*/ DWORD dwAccessMask            ,
                                      /*[in]*/ GUID* guidObjectType          ,
                                      /*[in]*/ GUID* guidInheritedObjectType )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::Add" );

    HRESULT hr;

    ATLASSERT(m_pSD);

    __MPC_EXIT_IF_METHOD_FAILS(hr, AddACEToACL( m_pDACL, pPrincipalSid, dwAceType, dwAceFlags, dwAccessMask, guidObjectType, guidInheritedObjectType ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetSecurityDescriptorDacl( m_pSD, TRUE, m_pDACL, FALSE ));

    m_bDaclDefaulted = FALSE;
    hr               = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::Add( /*[in]*/ LPCWSTR szPrincipal             ,
                                      /*[in]*/ DWORD   dwAceType               ,
                                      /*[in]*/ DWORD   dwAceFlags              ,
                                      /*[in]*/ DWORD   dwAccessMask            ,
                                      /*[in]*/ GUID*   guidObjectType          ,
                                      /*[in]*/ GUID*   guidInheritedObjectType )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::Add" );

    HRESULT hr;
    PSID    pPrincipalSid = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertPrincipalToSID( szPrincipal, pPrincipalSid ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Add( pPrincipalSid, dwAceType, dwAceFlags, dwAccessMask, guidObjectType, guidInheritedObjectType ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( (void*&)pPrincipalSid );

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SecurityDescriptor::GetForFile( /*[in]*/ LPCWSTR              szFilename ,
											 /*[in]*/ SECURITY_INFORMATION secInfo    )
{
	__MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::GetForFile" );

    HRESULT              hr;
    PSECURITY_DESCRIPTOR pSD   = NULL;
    DWORD                dwLen = 0;
	DWORD                dwRes;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szFilename);
    __MPC_PARAMCHECK_END();


    //
    // Get the security descriptor for the file.
    //
    ::GetFileSecurityW( szFilename, secInfo, NULL, 0, &dwLen );
	if((dwRes = ::GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
	{
		if(dwRes == ERROR_SUCCESS)
		{
			__MPC_SET_ERROR_AND_EXIT(hr, Initialize()); // Empty SD.
		}

		__MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
	}

    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (LPVOID&)pSD, dwLen ));


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetFileSecurityW( szFilename, secInfo, pSD, dwLen, &dwLen ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Attach( pSD ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( (void*&)pSD );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::SetForFile( /*[in]*/ LPCWSTR              szFilename ,
											 /*[in]*/ SECURITY_INFORMATION secInfo    )
{
	__MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::SetForFile" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szFilename);
    __MPC_PARAMCHECK_END();


    //
    // Set the security descriptor for the file.
    //
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetFileSecurityW( szFilename, secInfo, GetSD() ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::SecurityDescriptor::GetForRegistry( /*[in]*/ LPCWSTR			   szKey    ,
												 /*[in]*/ SECURITY_INFORMATION secInfo  ,
												 /*[in]*/ HKEY   			   hKeyRoot )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::GetForRegistry" );

	HRESULT              hr;
    HKEY                 hKey = NULL;
    PSECURITY_DESCRIPTOR pSD  = NULL;
    DWORD                dwLen;
    DWORD                dwRes;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szKey);
    __MPC_PARAMCHECK_END();


	if(hKeyRoot == NULL)
	{
		//
		// Extract the hive from the string....
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::RegKey::ParsePath( szKey, hKeyRoot, szKey ));
	}


	__MPC_EXIT_IF_SYSCALL_FAILS(hr, dwRes, ::RegOpenKeyExW( hKeyRoot, szKey, 0, Local_GenerateAccessMask( secInfo, true ), &hKey ));


    //
    // Get the security descriptor for the registry key.
    //
    dwLen = 0;
    dwRes = ::RegGetKeySecurity( hKey, secInfo, NULL, &dwLen );
    if(dwRes != ERROR_INSUFFICIENT_BUFFER)
    {
		if(dwRes == ERROR_SUCCESS)
		{
			__MPC_SET_ERROR_AND_EXIT(hr, Initialize()); // Empty SD.
		}

        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateMemory( (LPVOID&)pSD, dwLen ));


	__MPC_EXIT_IF_SYSCALL_FAILS(hr, dwRes, ::RegGetKeySecurity( hKey, secInfo, pSD, &dwLen ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Attach( pSD ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    ReleaseMemory( (void*&)pSD );

    if(hKey) ::RegCloseKey( hKey );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SecurityDescriptor::SetForRegistry( /*[in]*/ LPCWSTR			   szKey    ,
												 /*[in]*/ SECURITY_INFORMATION secInfo  ,
												 /*[in]*/ HKEY   			   hKeyRoot )
{
	__MPC_FUNC_ENTRY( COMMONID, "MPC::SecurityDescriptor::SetForRegistry" );

    HRESULT hr;
    HKEY    hKey = NULL;
    DWORD   dwRes;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szKey);
    __MPC_PARAMCHECK_END();


	if(hKeyRoot == NULL)
	{
		//
		// Extract the hive from the string....
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::RegKey::ParsePath( szKey, hKeyRoot, szKey ));
	}


	__MPC_EXIT_IF_SYSCALL_FAILS(hr, dwRes, ::RegOpenKeyExW( hKeyRoot, szKey, 0, Local_GenerateAccessMask( secInfo, false ), &hKey ));


    //
    // Set the security descriptor for the registry key.
    //
	__MPC_EXIT_IF_SYSCALL_FAILS(hr, dwRes, ::RegSetKeySecurity( hKey, secInfo, GetSD() ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(hKey) ::RegCloseKey( hKey );

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

MPC::Impersonation::Impersonation()
{
    m_hToken         = NULL;  // HANDLE m_hToken;
    m_fImpersonating = false; // bool   m_fImpersonating;
}

MPC::Impersonation::Impersonation( /*[in]*/ const MPC::Impersonation& imp )
{
    m_hToken         = NULL;  // HANDLE m_hToken;
    m_fImpersonating = false; // bool   m_fImpersonating;

    *this = imp;
}

MPC::Impersonation::~Impersonation()
{
    Release();
}

MPC::Impersonation& MPC::Impersonation::operator=( /*[in]*/ const MPC::Impersonation& imp )
{
    Release();

    if(!::DuplicateHandle( ::GetCurrentProcess(),  imp.m_hToken,
                           ::GetCurrentProcess(), &    m_hToken, 0, FALSE, DUPLICATE_SAME_ACCESS ))
    {
        ; // Error...
    }

    return *this;
}

////////////////////////////////////////////////////////////////////////////////

void MPC::Impersonation::Release()
{
    (void)RevertToSelf();

    if(m_hToken)
    {
        ::CloseHandle( m_hToken ); m_hToken = NULL;
    }
}

HRESULT MPC::Impersonation::Initialize( DWORD dwDesiredAccess )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Impersonation::Initialize" );

    HRESULT                  hr;
    CComPtr<IServerSecurity> ss;
    bool                     fRevert = false;

    Release();


    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoGetCallContext( IID_IServerSecurity, (void**)&ss ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, ss->ImpersonateClient()); fRevert = true;

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::OpenThreadToken( ::GetCurrentThread(), dwDesiredAccess, TRUE, &m_hToken ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(fRevert && ss) ss->RevertToSelf();

    __MPC_FUNC_EXIT(hr);
}

void MPC::Impersonation::Attach( /*[in]*/ HANDLE hToken )
{
    Release();

    m_hToken = hToken;
}

HANDLE MPC::Impersonation::Detach()
{
    HANDLE hToken = m_hToken;


    (void)RevertToSelf();

    m_hToken = NULL;

    return hToken;
}

HRESULT MPC::Impersonation::Impersonate()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Impersonation::Impersonate" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_hToken);
    __MPC_PARAMCHECK_END();


    if(m_fImpersonating == false)
    {
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetThreadToken( NULL, m_hToken ));

        m_fImpersonating = true;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Impersonation::RevertToSelf()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Impersonation::RevertToSelf" );

    HRESULT hr;


    if(m_fImpersonating)
    {
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetThreadToken( NULL, NULL ));

        m_fImpersonating = false;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

MPC::AccessCheck::AccessCheck()
{
    m_hToken = NULL; // HANDLE m_hToken;
}

MPC::AccessCheck::~AccessCheck()
{
    Release();
}

void MPC::AccessCheck::Release()
{
    if(m_hToken)
    {
        ::CloseHandle( m_hToken ); m_hToken = NULL;
    }
}

HRESULT MPC::AccessCheck::GetTokenFromImpersonation()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::AccessCheck::GetTokenFromImpersonation" );

    HRESULT            hr;
    MPC::Impersonation imp;


    Release();


    __MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize( TOKEN_QUERY ));

    m_hToken = imp.Detach();
    hr       = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

void MPC::AccessCheck::Attach( /*[in]*/ HANDLE hToken )
{
    Release();

    m_hToken = hToken;
}

HANDLE MPC::AccessCheck::Detach()
{
    HANDLE hToken = m_hToken;

    m_hToken = NULL;

    return hToken;
}

HRESULT MPC::AccessCheck::Verify( /*[in ]*/ DWORD                dwDesired ,
                                  /*[out]*/ BOOL&                fGranted  ,
                                  /*[out]*/ DWORD&               dwGranted ,
                                  /*[in ]*/ PSECURITY_DESCRIPTOR sd        )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::AccessCheck::Verify" );

    HRESULT         hr;
    PRIVILEGE_SET   PrivilegeSet;
    DWORD           dwPrivSetSize = sizeof( PRIVILEGE_SET );
    GENERIC_MAPPING ObjMap        =
    {
        ACCESS_READ ,
        ACCESS_WRITE,
        ACCESS_NONE ,
        ACCESS_ALL
    };


    fGranted = FALSE;


    if(sd == NULL || !::IsValidSecurityDescriptor( sd ) )
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    //
    // This only does something if we specify generic access rights
    // like GENERIC_ALL. We are not.
    //
    ::MapGenericMask( &dwDesired, &ObjMap );

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::AccessCheck( sd              ,
                                                        m_hToken        ,
                                                        dwDesired       ,
                                                        &ObjMap         ,
                                                        &PrivilegeSet   ,
                                                        &dwPrivSetSize  ,
                                                        &dwGranted      ,
                                                        &fGranted       ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::AccessCheck::Verify( /*[in ]*/ DWORD                    dwDesired ,
                                  /*[out]*/ BOOL&                    fGranted  ,
                                  /*[out]*/ DWORD&                   dwGranted ,
                                  /*[in ]*/ MPC::SecurityDescriptor& sd        )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::AccessCheck::Verify" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Verify( dwDesired, fGranted, dwGranted, sd.GetSD() ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::AccessCheck::Verify( /*[in ]*/ DWORD  	dwDesired ,
                                  /*[out]*/ BOOL&  	fGranted  ,
                                  /*[out]*/ DWORD& 	dwGranted ,
                                  /*[in ]*/ LPCWSTR sd        )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::AccessCheck::Verify" );

    HRESULT                 hr;
    MPC::SecurityDescriptor sdd;


	__MPC_EXIT_IF_METHOD_FAILS(hr, sdd.ConvertFromString( sd ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, Verify( dwDesired, fGranted, dwGranted, sdd.GetSD() ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::ChangeSD( /*[in]*/ MPC::SecurityDescriptor& sdd           ,
                       /*[in]*/ MPC::FileSystemObject&   fso           ,
					   /*[in]*/ SECURITY_INFORMATION     secInfo       ,
                       /*[in]*/ bool                     fDeep         ,
                       /*[in]*/ bool                     fApplyToDirs  ,
                       /*[in]*/ bool                     fApplyToFiles )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ChangeSD" );

    HRESULT                     hr;
    MPC::wstring                szPath;
    MPC::FileSystemObject::List lst;
    MPC::FileSystemObject::Iter it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, fso.get_Path( szPath ));


    if((fApplyToDirs  && fso.IsDirectory()) ||
       (fApplyToFiles && fso.IsFile     ())  )
    {
        //
        // Set the security descriptor for the object.
        //
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetFileSecurityW( szPath.c_str(), secInfo, sdd.GetSD() ));
    }

    if(fDeep)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, fso.EnumerateFiles( lst ));
        for(it=lst.begin(); it != lst.end(); it++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, ChangeSD( sdd, *(*it), secInfo, true, fApplyToDirs, fApplyToFiles ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, fso.EnumerateFolders( lst ));
        for(it=lst.begin(); it != lst.end(); it++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, ChangeSD( sdd, *(*it), secInfo, true, fApplyToDirs, fApplyToFiles ));
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::ChangeSD( /*[in]*/ MPC::SecurityDescriptor& sdd           ,
                       /*[in]*/ LPCWSTR                  szRoot        ,
					   /*[in]*/ SECURITY_INFORMATION     secInfo       ,
                       /*[in]*/ bool                     fDeep         ,
                       /*[in]*/ bool                     fApplyToDirs  ,
                       /*[in]*/ bool                     fApplyToFiles )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ChangeSD" );

    HRESULT               hr;
    MPC::wstring          strRoot( szRoot          ); MPC::SubstituteEnvVariables( strRoot );
    MPC::FileSystemObject fso    ( strRoot.c_str() );


    __MPC_EXIT_IF_METHOD_FAILS(hr, fso.CreateDir( true ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, ChangeSD( sdd, fso, secInfo, fDeep, fApplyToDirs, fApplyToFiles ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::GetCallerPrincipal( /*[in ]*/ bool        fImpersonate      ,
                                 /*[out]*/ CComBSTR&   bstrUser          ,
								 /*[out]*/ DWORD     *pdwAllowedIdentity )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::GetCallerPrincipal" );

    HRESULT            hr;
    DWORD              dwRes;
    LPWSTR             szUserSid = NULL;
    PTOKEN_USER        ptkUser   = NULL;
    PTOKEN_GROUPS      ptkGroups = NULL;
    DWORD              dwSize;
    MPC::Impersonation imp;


	if(fImpersonate)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, imp.Initialize( TOKEN_QUERY ));
	}
	else
	{
		HANDLE hToken;

		//
		// First try the token attached to the thread, then the one attached to the process.
		//
		if(::OpenThreadToken( ::GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken ) == FALSE)
		{
			if((dwRes = ::GetLastError()) != ERROR_NO_TOKEN)
			{
				__MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
			}

			__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::OpenProcessToken( ::GetCurrentProcess(), TOKEN_QUERY, &hToken ));
		}

		imp.Attach( hToken );
	}


    //
    // Get caller's credentials.
    //
    dwSize = 0;
    ::GetTokenInformation( (HANDLE)imp, TokenUser, NULL, 0, &dwSize );
    if((dwRes = ::GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SecurityDescriptor::AllocateMemory( (void*&)ptkUser, dwSize ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetTokenInformation( (HANDLE)imp, TokenUser, ptkUser, dwSize, &dwSize ));


    //
    // Convert to string.
    //
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::ConvertSidToStringSidW( ptkUser->User.Sid, &szUserSid ));


    //
    // Verify identity, if requested.
    //
    if(pdwAllowedIdentity)
    {
        DWORD dwAllowedIdentity = 0;

        if(::EqualSid( ptkUser->User.Sid, (PSID)&      MPC::SecurityDescriptor::s_SystemSid )) dwAllowedIdentity |= IDENTITY_SYSTEM;
        if(::EqualSid( ptkUser->User.Sid, (PSID)&(SID&)MPC::SecurityDescriptor::s_AdminSid  )) dwAllowedIdentity |= IDENTITY_ADMIN;


        //
        // Get caller's groups.
        //
        dwSize = 0;
        ::GetTokenInformation( (HANDLE)imp, TokenGroups, NULL, 0, &dwSize );
        if((dwRes = ::GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SecurityDescriptor::AllocateMemory( (void*&)ptkGroups, dwSize ));

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetTokenInformation( (HANDLE)imp, TokenGroups, ptkGroups, dwSize, &dwSize ));


        for(DWORD i=0; i<ptkGroups->GroupCount; i++)
        {
            SID_AND_ATTRIBUTES* grp = &ptkGroups->Groups[i];

            if(grp->Attributes & SE_GROUP_ENABLED)
            {
                if(::EqualSid( grp->Sid, (PSID)&(SID&)MPC::SecurityDescriptor::s_Alias_AdminsSid     )) dwAllowedIdentity |= IDENTITY_ADMINS;
                if(::EqualSid( grp->Sid, (PSID)&(SID&)MPC::SecurityDescriptor::s_Alias_PowerUsersSid )) dwAllowedIdentity |= IDENTITY_POWERUSERS;
                if(::EqualSid( grp->Sid, (PSID)&(SID&)MPC::SecurityDescriptor::s_Alias_UsersSid      )) dwAllowedIdentity |= IDENTITY_USERS;
                if(::EqualSid( grp->Sid, (PSID)&(SID&)MPC::SecurityDescriptor::s_Alias_GuestsSid     )) dwAllowedIdentity |= IDENTITY_GUESTS;
            }
        }

        *pdwAllowedIdentity = dwAllowedIdentity;
    }

    bstrUser = szUserSid;
    hr       = S_OK;


    __MPC_FUNC_CLEANUP;

    if(szUserSid) ::LocalFree( szUserSid );

    MPC::SecurityDescriptor::ReleaseMemory( (void*&)ptkUser   );
    MPC::SecurityDescriptor::ReleaseMemory( (void*&)ptkGroups );

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::CheckCallerAgainstPrincipal( /*[in ]*/ bool  fImpersonate      ,
										  /*[out]*/ BSTR  bstrUser          ,
										  /*[in ]*/ DWORD dwAllowedIdentity )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CheckCallerAgainstPrincipal" );

    HRESULT  hr;
    CComBSTR bstrRealUser;
	DWORD    dwTokenIdentity;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetCallerPrincipal( fImpersonate, bstrRealUser, &dwTokenIdentity ));

    if(!MPC::StrICmp( bstrRealUser, bstrUser ))
    {
        //
        // Same user, exit.
        //
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    if((dwTokenIdentity & dwAllowedIdentity) != 0)
    {
        //
        // Not same user, but an authorized one, exit.
        //
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    hr = E_ACCESSDENIED;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::GetInterfaceSecurity( /*[in ]*/ IUnknown*                 pUnk             ,
                                   /*[out]*/ DWORD                    *pAuthnSvc        ,
                                   /*[out]*/ DWORD                    *pAuthzSvc        ,
                                   /*[out]*/ OLECHAR*                 *pServerPrincName ,
                                   /*[out]*/ DWORD                    *pAuthnLevel      ,
                                   /*[out]*/ DWORD                    *pImpLevel        ,
                                   /*[out]*/ RPC_AUTH_IDENTITY_HANDLE *pAuthInfo        ,
                                   /*[out]*/ DWORD                    *pCapabilities    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::GetInterfaceSecurity" );

    HRESULT                  hr;
    CComPtr<IClientSecurity> pBlanket;


    __MPC_EXIT_IF_METHOD_FAILS(hr, pUnk->QueryInterface( IID_IClientSecurity, (void**)&pBlanket ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pBlanket->QueryBlanket( pUnk             ,
                                                           pAuthnSvc        ,
                                                           pAuthzSvc        ,
                                                           pServerPrincName ,
                                                           pAuthnLevel      ,
                                                           pImpLevel        ,
                                                           pAuthInfo        ,
                                                           pCapabilities    ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SetInterfaceSecurity( /*[in]*/ IUnknown*                 pUnk             ,
                                   /*[in]*/ DWORD                    *pAuthnSvc        ,
                                   /*[in]*/ DWORD                    *pAuthzSvc        ,
                                   /*[in]*/ OLECHAR*                  pServerPrincName ,
                                   /*[in]*/ DWORD                    *pAuthnLevel      ,
                                   /*[in]*/ DWORD                    *pImpLevel        ,
                                   /*[in]*/ RPC_AUTH_IDENTITY_HANDLE *pAuthInfo        ,
                                   /*[in]*/ DWORD                    *pCapabilities    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SetInterfaceSecurity" );

    HRESULT                  hr;
    CComPtr<IClientSecurity> pBlanket;
    DWORD                    AuthnSvc;
    DWORD                    AuthzSvc;
    OLECHAR*                 ServerPrincName = NULL;
    DWORD                    AuthnLevel;
    DWORD                    ImpLevel;
    DWORD                    Capabilities;


    __MPC_EXIT_IF_METHOD_FAILS(hr, pUnk->QueryInterface( IID_IClientSecurity, (void**)&pBlanket ));

    //
    // First read the current settings.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, pBlanket->QueryBlanket(  pUnk            ,
                                                           &AuthnSvc        ,
                                                           &AuthzSvc        ,
                                                           &ServerPrincName ,
                                                           &AuthnLevel      ,
                                                           &ImpLevel        ,
                                                            NULL            ,
                                                           &Capabilities    ));


    //
    // Update only some of them.
    //
    if(pAuthnSvc       ) AuthnSvc        = *pAuthnSvc;
    if(pAuthzSvc       ) AuthzSvc        = *pAuthzSvc;
    if(pAuthnLevel     ) AuthnLevel      = *pAuthnLevel;
    if(pImpLevel       ) ImpLevel        = *pImpLevel;
    if(pCapabilities   ) Capabilities    = *pCapabilities;


    //
    // Write back.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, pBlanket->SetBlanket(  pUnk            ,
                                                          AuthnSvc        ,
                                                          AuthzSvc        ,
                                                         pServerPrincName ,
                                                          AuthnLevel      ,
                                                          ImpLevel        ,
                                                         pAuthInfo        ,
                                                          Capabilities    ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(ServerPrincName) ::CoTaskMemFree( ServerPrincName );

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::SetInterfaceSecurity_ImpLevel( /*[in]*/ IUnknown* pUnk     ,
                                            /*[in]*/ DWORD     ImpLevel )
{
    return MPC::SetInterfaceSecurity( pUnk      ,  /* IUnknown*                 pUnk             */
                                      NULL      ,  /* DWORD                    *pAuthnSvc        */
                                      NULL      ,  /* DWORD                    *pAuthzSvc        */
                                      NULL      ,  /* OLECHAR*                  pServerPrincName */
                                      NULL      ,  /* DWORD                    *pAuthnLevel      */
                                      &ImpLevel ,  /* DWORD                    *pImpLevel        */
                                      NULL      ,  /* RPC_AUTH_IDENTITY_HANDLE *pAuthInfo        */
                                      NULL      ); /* DWORD                    *pCapabilities    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_crc.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_CRC.cpp

Abstract:
    This file contains the implementation of some utility functions for
    computing CRCs.

Revision History:
    Davide Massarenti   (Dmassare)  04/17/99
        created

******************************************************************************/

#include "stdafx.h"


//
// CRC 32 table for use under ZModem protocol, IEEE 802
// G(x) = x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1
//
static DWORD CRCTable[256] =
{
    0x00000000, 0x04C11DB7, 0x09823B6E, 0x0D4326D9, 0x130476DC, 0x17C56B6B, 0x1A864DB2, 0x1E475005,
    0x2608EDB8, 0x22C9F00F, 0x2F8AD6D6, 0x2B4BCB61, 0x350C9B64, 0x31CD86D3, 0x3C8EA00A, 0x384FBDBD,
    0x4C11DB70, 0x48D0C6C7, 0x4593E01E, 0x4152FDA9, 0x5F15ADAC, 0x5BD4B01B, 0x569796C2, 0x52568B75,
    0x6A1936C8, 0x6ED82B7F, 0x639B0DA6, 0x675A1011, 0x791D4014, 0x7DDC5DA3, 0x709F7B7A, 0x745E66CD,
    0x9823B6E0, 0x9CE2AB57, 0x91A18D8E, 0x95609039, 0x8B27C03C, 0x8FE6DD8B, 0x82A5FB52, 0x8664E6E5,
    0xBE2B5B58, 0xBAEA46EF, 0xB7A96036, 0xB3687D81, 0xAD2F2D84, 0xA9EE3033, 0xA4AD16EA, 0xA06C0B5D,
    0xD4326D90, 0xD0F37027, 0xDDB056FE, 0xD9714B49, 0xC7361B4C, 0xC3F706FB, 0xCEB42022, 0xCA753D95,
    0xF23A8028, 0xF6FB9D9F, 0xFBB8BB46, 0xFF79A6F1, 0xE13EF6F4, 0xE5FFEB43, 0xE8BCCD9A, 0xEC7DD02D,
    0x34867077, 0x30476DC0, 0x3D044B19, 0x39C556AE, 0x278206AB, 0x23431B1C, 0x2E003DC5, 0x2AC12072,
    0x128E9DCF, 0x164F8078, 0x1B0CA6A1, 0x1FCDBB16, 0x018AEB13, 0x054BF6A4, 0x0808D07D, 0x0CC9CDCA,
    0x7897AB07, 0x7C56B6B0, 0x71159069, 0x75D48DDE, 0x6B93DDDB, 0x6F52C06C, 0x6211E6B5, 0x66D0FB02,
    0x5E9F46BF, 0x5A5E5B08, 0x571D7DD1, 0x53DC6066, 0x4D9B3063, 0x495A2DD4, 0x44190B0D, 0x40D816BA,
    0xACA5C697, 0xA864DB20, 0xA527FDF9, 0xA1E6E04E, 0xBFA1B04B, 0xBB60ADFC, 0xB6238B25, 0xB2E29692,
    0x8AAD2B2F, 0x8E6C3698, 0x832F1041, 0x87EE0DF6, 0x99A95DF3, 0x9D684044, 0x902B669D, 0x94EA7B2A,
    0xE0B41DE7, 0xE4750050, 0xE9362689, 0xEDF73B3E, 0xF3B06B3B, 0xF771768C, 0xFA325055, 0xFEF34DE2,
    0xC6BCF05F, 0xC27DEDE8, 0xCF3ECB31, 0xCBFFD686, 0xD5B88683, 0xD1799B34, 0xDC3ABDED, 0xD8FBA05A,
    0x690CE0EE, 0x6DCDFD59, 0x608EDB80, 0x644FC637, 0x7A089632, 0x7EC98B85, 0x738AAD5C, 0x774BB0EB,
    0x4F040D56, 0x4BC510E1, 0x46863638, 0x42472B8F, 0x5C007B8A, 0x58C1663D, 0x558240E4, 0x51435D53,
    0x251D3B9E, 0x21DC2629, 0x2C9F00F0, 0x285E1D47, 0x36194D42, 0x32D850F5, 0x3F9B762C, 0x3B5A6B9B,
    0x0315D626, 0x07D4CB91, 0x0A97ED48, 0x0E56F0FF, 0x1011A0FA, 0x14D0BD4D, 0x19939B94, 0x1D528623,
    0xF12F560E, 0xF5EE4BB9, 0xF8AD6D60, 0xFC6C70D7, 0xE22B20D2, 0xE6EA3D65, 0xEBA91BBC, 0xEF68060B,
    0xD727BBB6, 0xD3E6A601, 0xDEA580D8, 0xDA649D6F, 0xC423CD6A, 0xC0E2D0DD, 0xCDA1F604, 0xC960EBB3,
    0xBD3E8D7E, 0xB9FF90C9, 0xB4BCB610, 0xB07DABA7, 0xAE3AFBA2, 0xAAFBE615, 0xA7B8C0CC, 0xA379DD7B,
    0x9B3660C6, 0x9FF77D71, 0x92B45BA8, 0x9675461F, 0x8832161A, 0x8CF30BAD, 0x81B02D74, 0x857130C3,
    0x5D8A9099, 0x594B8D2E, 0x5408ABF7, 0x50C9B640, 0x4E8EE645, 0x4A4FFBF2, 0x470CDD2B, 0x43CDC09C,
    0x7B827D21, 0x7F436096, 0x7200464F, 0x76C15BF8, 0x68860BFD, 0x6C47164A, 0x61043093, 0x65C52D24,
    0x119B4BE9, 0x155A565E, 0x18197087, 0x1CD86D30, 0x029F3D35, 0x065E2082, 0x0B1D065B, 0x0FDC1BEC,
    0x3793A651, 0x3352BBE6, 0x3E119D3F, 0x3AD08088, 0x2497D08D, 0x2056CD3A, 0x2D15EBE3, 0x29D4F654,
    0xC5A92679, 0xC1683BCE, 0xCC2B1D17, 0xC8EA00A0, 0xD6AD50A5, 0xD26C4D12, 0xDF2F6BCB, 0xDBEE767C,
    0xE3A1CBC1, 0xE760D676, 0xEA23F0AF, 0xEEE2ED18, 0xF0A5BD1D, 0xF464A0AA, 0xF9278673, 0xFDE69BC4,
    0x89B8FD09, 0x8D79E0BE, 0x803AC667, 0x84FBDBD0, 0x9ABC8BD5, 0x9E7D9662, 0x933EB0BB, 0x97FFAD0C,
    0xAFB010B1, 0xAB710D06, 0xA6322BDF, 0xA2F33668, 0xBCB4666D, 0xB8757BDA, 0xB5365D03, 0xB1F740B4
};


#define CRCInit_1 0x00
#define CRCInit_2 0x00

#define CRC32_1(b,oldcrc) (CRCTable[(oldcrc>>24) & 0xFF] ^ (oldcrc << 8) ^ (b & 0xFF))
#define CRC32_2(b,oldcrc) (CRCTable[((oldcrc>>24) ^ b) & 0xFF] ^ (oldcrc << 8))


void MPC::InitCRC( /*[out]*/ DWORD& CRC )
{
    CRC = CRCInit_2;
}

void MPC::ComputeCRC( /*[in/out]*/ DWORD& CRC     ,
                      /*[in]    */ UCHAR* rgBlock ,
                      /*[in]    */ int    nLength )
{
    for(int i=0; i<nLength ; i++)
    {
        CRC = CRC32_2( rgBlock[i], CRC );
    }
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::ComputeCRC( /*[out]*/ DWORD& dwCRC, /*[in]*/ IStream* stream )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ComputeCRC" );

    HRESULT hr;
    UCHAR   rgBuf[512];


    //
    // Read contents and compute CRC.
    //
    while(1)
    {
        DWORD dwRead;

		__MPC_EXIT_IF_METHOD_FAILS(hr, stream->Read( rgBuf, sizeof( rgBuf ), &dwRead ));

        if(dwRead == 0) // End of File.
        {
            break;
        }


        MPC::ComputeCRC( dwCRC, rgBuf, dwRead );
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::ComputeCRC( /*[out]*/ DWORD& dwCRC, /*[in]*/ LPCWSTR szFile )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ComputeCRC" );

    HRESULT hr;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    UCHAR   rgBuf[512];


    MPC::InitCRC( dwCRC );


    //
    // Open the SOURCE file.
    //
    __MPC_EXIT_IF_INVALID_HANDLE(hr, hFile, ::CreateFileW( szFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ));

    //
    // Read contents and compute CRC.
    //
    while(1)
    {
        DWORD dwRead;
        DWORD dwWritten;

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::ReadFile( hFile, rgBuf, sizeof( rgBuf ), &dwRead, NULL ));

        if(dwRead == 0) // End of File.
        {
            break;
        }


        MPC::ComputeCRC( dwCRC, rgBuf, dwRead );
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(hFile != INVALID_HANDLE_VALUE) ::CloseHandle( hFile );

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_compress.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_Compression.cpp

Abstract:
    This file contains the implementation of the compression utility functions.

Revision History:
    Davide Massarenti   (Dmassare)  06/28/99
        created

******************************************************************************/

#include "stdafx.h"

#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>

#include <fci.h>
#include <fdi.h>

#include <list>
#include <string>

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

static DWORD LocalGetLastError()
{
    DWORD dwRes = ::GetLastError();

    if(dwRes == ERROR_SUCCESS)
    {
        dwRes = _doserrno;
        if(dwRes == ERROR_SUCCESS)
        {
            dwRes = ERROR_TOO_MANY_OPEN_FILES;
        }
    }

    return dwRes;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

LPVOID DIAMONDAPI MPC::Cabinet::mem_alloc( ULONG cb )
{
    return malloc( cb );
}

void DIAMONDAPI MPC::Cabinet::mem_free( LPVOID memory )
{
    free( memory );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int DIAMONDAPI MPC::Cabinet::fci_delete( LPSTR pszFile, int *err, LPVOID pv )
{
    int result = remove( pszFile );

    if(result != 0) *err = errno;

    return result;
}

INT_PTR DIAMONDAPI MPC::Cabinet::fci_open( LPSTR   pszFile, int oflag, int pmode, int *err, LPVOID pv )
{
    int result = _open( pszFile, oflag, pmode );

    if(result == -1) *err = errno;

    return result;
}

UINT DIAMONDAPI MPC::Cabinet::fci_read( INT_PTR hf, LPVOID memory, UINT cb, int *err, LPVOID pv )
{
    UINT result = (UINT)_read( hf, memory, cb );

    if(result != cb) *err = errno;

    return result;
}

UINT DIAMONDAPI MPC::Cabinet::fci_write( INT_PTR hf, LPVOID memory, UINT cb, int *err, LPVOID pv )
{
    unsigned int result = (unsigned int)_write( hf, memory, cb );

    if(result != cb) *err = errno;

    return result;
}

int DIAMONDAPI MPC::Cabinet::fci_close( INT_PTR hf, int *err, LPVOID pv )
{
    int result = _close( hf );

    if(result != 0) *err = errno;

    return result;
}

long DIAMONDAPI MPC::Cabinet::fci_seek( INT_PTR hf, long dist, int seektype, int *err, LPVOID pv )
{
    long result = _lseek( hf, dist, seektype );

    if(result == -1) *err = errno;

    return result;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL DIAMONDAPI MPC::Cabinet::fci_get_next_cabinet( PCCAB pccab, ULONG cbPrevCab, LPVOID pv )
{
    MPC::Cabinet* cCab = (MPC::Cabinet*)pv;

	AtlW2AHelper( pccab->szCab    , cCab->m_szCabinetName, MAXSTRLEN( pccab->szCab     ) );
	AtlW2AHelper( pccab->szCabPath, cCab->m_szCabinetPath, MAXSTRLEN( pccab->szCabPath ) );

    return TRUE;
}

int DIAMONDAPI MPC::Cabinet::fci_file_placed( PCCAB pccab, LPSTR pszFile, long  cbFile, BOOL fContinuation, LPVOID pv )
{
    return 0;
}

long DIAMONDAPI MPC::Cabinet::fci_progress( UINT typeStatus, ULONG cb1, ULONG cb2, LPVOID pv )
{
    MPC::Cabinet* cCab = (MPC::Cabinet*)pv;
    long          res  = 0;

    if(typeStatus == statusFile)
    {
        //
        // Notify client.
        //
        if(cCab->m_pfnCallback_Bytes)
        {
            ULONG lDone  = (cCab->m_dwSizeDone += cb2);
            ULONG lTotal =  cCab->m_dwSizeTotal;

            if(FAILED(cCab->m_pfnCallback_Bytes( cCab, lDone, lTotal, cCab->m_lpUser )))
            {
                ::SetLastError( ERROR_OPERATION_ABORTED );

                res = -1;
            }
        }
    }

    return res;
}

BOOL DIAMONDAPI MPC::Cabinet::fci_get_temp_file( LPSTR pszTempName, int cbTempName, LPVOID pv )
{
    char  szPrefix[128];
    char *psz;
    BOOL  res = FALSE;

    sprintf( szPrefix, "PCHtemp_%ld_", (long)::GetCurrentThreadId() );
    psz = _tempnam( "", szPrefix ); // Get a name
    if(psz)
    {
        if(strlen( psz ) < (unsigned)cbTempName)
        {
            strcpy( pszTempName, psz ); // Copy to caller's buffer
            res = TRUE;
        }

        free( psz );
    }

    return res;
}

INT_PTR DIAMONDAPI MPC::Cabinet::fci_get_open_info( LPSTR pszName, USHORT *pdate, USHORT *ptime, USHORT *pattribs, int *err, LPVOID pv )
{
    MPC::Cabinet*              cCab = (MPC::Cabinet*)pv;
    BY_HANDLE_FILE_INFORMATION finfo;
    FILETIME                   filetime;
    HANDLE                     handle;
    DWORD                      attrs;
    int                        hf = -1;


    /*
     * Need a Win32 type handle to get file date/time using the Win32 APIs, even though the handle we
     * will be returning is of the type compatible with _open
     */
    handle = ::CreateFileA( pszName                                          ,
                            GENERIC_READ                                     ,
                            FILE_SHARE_READ|FILE_SHARE_WRITE                 ,
                            NULL                                             ,
                            OPEN_EXISTING                                    ,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL                                             );
    if(handle != INVALID_HANDLE_VALUE)
    {
        if(::GetFileInformationByHandle( handle, &finfo ) == TRUE)
        {
            ::FileTimeToLocalFileTime( &finfo.ftLastWriteTime, &filetime               );
            ::FileTimeToDosDateTime  (                         &filetime, pdate, ptime );

            attrs = ::GetFileAttributesA( pszName );
            if(attrs == 0xFFFFFFFF)
            {
                /* failure */
                *pattribs = 0;
            }
            else
            {
                /*
                 * Mask out all other bits except these four, since other
                 * bits are used by the cabinet format to indicate a
                 * special meaning.
                 */
                *pattribs = (int)(attrs & (_A_RDONLY | _A_SYSTEM | _A_HIDDEN | _A_ARCH));
            }
        }

        ::CloseHandle( handle );
    }


    /*
     * Return handle using _open
     */
    hf = _open( pszName, _O_RDONLY | _O_BINARY );
    if(hf == -1)
    {
        *err = errno;

        return -1; // abort on error
    }

    return hf;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

INT_PTR DIAMONDAPI MPC::Cabinet::fdi_open( LPSTR pszFile, int oflag, int pmode )
{
    return _open( pszFile, oflag, pmode );
}

UINT DIAMONDAPI MPC::Cabinet::fdi_read( INT_PTR hf, LPVOID pv, UINT cb )
{
    return _read( hf, pv, cb );
}

UINT DIAMONDAPI MPC::Cabinet::fdi_write( INT_PTR hf, LPVOID pv, UINT cb )
{
    return _write( hf, pv, cb );
}

int DIAMONDAPI MPC::Cabinet::fdi_close( INT_PTR hf )
{
    return _close( hf );
}

long DIAMONDAPI MPC::Cabinet::fdi_seek( INT_PTR hf, long dist, int seektype )
{
    return _lseek( hf, dist, seektype );
}


INT_PTR DIAMONDAPI MPC::Cabinet::fdi_notification_copy( FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin )
{
    MPC::Cabinet* cCab = (MPC::Cabinet*)pfdin->pv;

    switch(fdint)
    {
    case fdintCOPY_FILE:    // file to be copied
        {
			USES_CONVERSION;

            MPC::Cabinet::Iter it;
            LPCWSTR            szName = A2W( pfdin->psz1 );

            for(it=cCab->m_lstFiles.begin(); it != cCab->m_lstFiles.end(); it++)
            {
                if(!_wcsicmp( szName, it->m_szName.c_str() ))
                {
                    it->m_fFound = true;

                    return fdi_open( W2A( (LPWSTR)it->m_szFullName.c_str() ), _O_BINARY | _O_CREAT | _O_TRUNC | _O_WRONLY | _O_SEQUENTIAL, _S_IREAD | _S_IWRITE );
                }
            }
        }
        break;

    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        fdi_close( pfdin->hf );
        return TRUE;
    }

    return 0;
}

INT_PTR DIAMONDAPI MPC::Cabinet::fdi_notification_enumerate( FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin )
{
    MPC::Cabinet* cCab = (MPC::Cabinet*)pfdin->pv;

    switch(fdint)
    {
    case fdintCOPY_FILE:    // file to be copied
		{
			USES_CONVERSION;

			MPC::Cabinet::Iter it = cCab->m_lstFiles.insert( cCab->m_lstFiles.end() );

			it->m_szName = A2W( pfdin->psz1 );
			it->m_fFound = true;
		}
        break;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

MPC::Cabinet::Cabinet()
{
    memset( m_szCabinetPath, 0, sizeof(m_szCabinetPath) );    // CHAR              m_szCabinetName[MAX_PATH];
    memset( m_szCabinetName, 0, sizeof(m_szCabinetName) );    // CHAR              m_szCabinetPath[MAX_PATH];
                                                              // List              m_lstFiles;
    m_itCurrent = m_lstFiles.end();                           // Iter              m_itCurrent;
                                                              //
    m_dwSizeDone  = 0;                                        // DWORD             m_dwSizeDone;
    m_dwSizeTotal = 0;                                        // DWORD             m_dwSizeTotal;
                                                              //
    m_hfci = NULL;                                            // HFCI              m_hfci;
    m_hfdi = NULL;                                            // HFDI              m_hfdi;
                                                              // ERF               m_erf;
    memset( &m_cab_parameters, 0, sizeof(m_cab_parameters) ); // CCAB              m_cab_parameters;
                                                              //
    m_fIgnoreMissingFiles = FALSE;                            // BOOL              m_fIgnoreMissingFiles;
    m_lpUser              = NULL;                             // LPVOID            m_lpUser;
    m_pfnCallback_Files   = NULL;                             // PFNPROGRESS_FILES m_pfnCallback_Files;
    m_pfnCallback_Bytes   = NULL;                             // PFNPROGRESS_BYTES m_pfnCallback_Bytes;
}

MPC::Cabinet::~Cabinet()
{
    if(m_hfci) { FCIDestroy( m_hfci ); m_hfci = NULL; }
    if(m_hfdi) { FCIDestroy( m_hfdi ); m_hfdi = NULL; }
}

//////////////////////////////////////////////////////////////////////

HRESULT MPC::Cabinet::put_CabinetFile( /*[in]*/ LPCWSTR szCabinetFile, /*[in]*/ UINT cbSpaceToReserve )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CompressAsCabinet" );

    HRESULT hr;
    Cabinet cab;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szCabinetFile);
	__MPC_PARAMCHECK_END();


    memset(  m_szCabinetPath , 0, sizeof(m_szCabinetPath ) );
    memset(  m_szCabinetName , 0, sizeof(m_szCabinetName ) );
    memset( &m_cab_parameters, 0, sizeof(m_cab_parameters) );


    //
    // Initialize cabinet path and name.
    //
    {
        LPWSTR szEnd = wcsrchr( szCabinetFile, L'\\' );
        if(szEnd == NULL)
        {
            wcsncpy( m_szCabinetName, szCabinetFile, MAXSTRLEN( m_szCabinetName ) );
        }
        else
        {
            int len = (szEnd - szCabinetFile) + 1;

            wcsncpy( m_szCabinetName, szEnd+1      ,      MAXSTRLEN( m_szCabinetName )        );
            wcsncpy( m_szCabinetPath, szCabinetFile, min( MAXSTRLEN( m_szCabinetPath ), len ) );
        }
    }

    //
    // Initialize the cabinet description header.
    //
    {
        m_cab_parameters.cb             = (LONG_MAX);
        m_cab_parameters.cbFolderThresh = (LONG_MAX);

        /*
         * Don't reserve space for any extensions
         */
        m_cab_parameters.cbReserveCFHeader = cbSpaceToReserve;
        m_cab_parameters.cbReserveCFFolder = 0;
        m_cab_parameters.cbReserveCFData   = 0;

        /*
         * We use this to create the cabinet name
         */
        m_cab_parameters.iCab = 1;

        /*
         * If you want to use disk names, use this to
         * count disks
         */
        m_cab_parameters.iDisk = 0;

        /*
         * Choose your own number
         */
        m_cab_parameters.setID = 12345;

        AtlW2AHelper( m_cab_parameters.szCab    , m_szCabinetName, MAXSTRLEN( m_cab_parameters.szCab     ) );
        AtlW2AHelper( m_cab_parameters.szCabPath, m_szCabinetPath, MAXSTRLEN( m_cab_parameters.szCabPath ) );
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Cabinet::put_IgnoreMissingFiles( /*[in]*/ BOOL fVal )
{
    m_fIgnoreMissingFiles = fVal;

    return S_OK;
}

HRESULT MPC::Cabinet::put_UserData( /*[in]*/ LPVOID lpVal )
{
    m_lpUser = lpVal;

    return S_OK;
}

HRESULT MPC::Cabinet::put_onProgress_Files( /*[in]*/ PFNPROGRESS_FILES pfnVal )
{
    m_pfnCallback_Files = pfnVal;

    return S_OK;
}

HRESULT MPC::Cabinet::put_onProgress_Bytes( /*[in]*/ PFNPROGRESS_BYTES pfnVal )
{
    m_pfnCallback_Bytes = pfnVal;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////

HRESULT MPC::Cabinet::ClearFiles()
{
    m_lstFiles.clear();
    m_itCurrent = m_lstFiles.end();

    return S_OK;
}

HRESULT MPC::Cabinet::GetFiles( /*[out]*/ List& lstFiles )
{
    lstFiles = m_lstFiles;

    return S_OK;
}

HRESULT MPC::Cabinet::AddFile( /*[in]*/ LPCWSTR szFileName, /*[in]*/ LPCWSTR szFileNameInsideCabinet )
{
    Iter it = m_lstFiles.insert( m_lstFiles.end() );

    if(szFileNameInsideCabinet == NULL || szFileNameInsideCabinet[0] == 0)
    {
        LPCWSTR szEnd = wcsrchr( szFileName, L'\\' );

        szFileNameInsideCabinet = szEnd ? szEnd+1 : szFileName;
    }

    it->m_szFullName = szFileName;
    it->m_szName     = szFileNameInsideCabinet;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////

HRESULT MPC::Cabinet::Compress()
{
    DWORD dwRes = ERROR_SUCCESS;
    BOOL  res   = FALSE;


    m_hfci = FCICreate( &m_erf             ,
                         fci_file_placed   ,
                         mem_alloc         ,
                         mem_free          ,
                         fci_open          ,
                         fci_read          ,
                         fci_write         ,
                         fci_close         ,
                         fci_seek          ,
                         fci_delete        ,
                         fci_get_temp_file ,
                        &m_cab_parameters  ,
                         this              );
    if(m_hfci)
    {
        for(int pass=0; pass<2 && dwRes==ERROR_SUCCESS; pass++)
        {
            Iter  it;
            ULONG lDone  = 0;
            ULONG lTotal = m_lstFiles.size();

            if(pass == 1)
            {
                //
                // Notify client about total number of bytes to compress.
                //
                if(m_pfnCallback_Bytes)
                {
                    if(FAILED(m_pfnCallback_Bytes( this, 0, m_dwSizeTotal, m_lpUser )))
                    {
                        dwRes = ERROR_OPERATION_ABORTED;
                        break;
                    }
                }
            }

            for(it=m_lstFiles.begin(); it != m_lstFiles.end(); it++, lDone++)
            {
				CHAR    rgFilePath[MAX_PATH];
				CHAR    rgFileName[MAX_PATH];
                LPCWSTR szFilePath = it->m_szFullName.c_str();
                LPCWSTR szFileName = it->m_szName    .c_str();
                HANDLE handle;


                m_itCurrent = it;


                if(pass == 1)
                {
                    //
                    // Notify client.
                    //
                    if(m_pfnCallback_Files)
                    {
                        if(FAILED(m_pfnCallback_Files( this, szFilePath, lDone, lTotal, m_lpUser )))
                        {
                            dwRes = ERROR_OPERATION_ABORTED;
                            break;
                        }
                    }
                }


                //
                // Check the existence of the file.
                //
                handle = ::CreateFileW( szFilePath                                       ,
                                        GENERIC_READ                                     ,
                                        FILE_SHARE_READ|FILE_SHARE_WRITE                 ,
                                        NULL                                             ,
                                        OPEN_EXISTING                                    ,
                                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                        NULL                                             );
                if(handle == INVALID_HANDLE_VALUE)
                {
                    dwRes = LocalGetLastError();

                    if(m_fIgnoreMissingFiles)
                    {
                        dwRes = ERROR_SUCCESS;
                        continue; // The file doesn't exist, simply skip it.
                    }

                    break;
                }

                ////////////////////////////////////////

                if(pass == 0) // Get the size of files on first pass.
                {
                    BY_HANDLE_FILE_INFORMATION finfo;

                    if(::GetFileInformationByHandle( handle, &finfo ) == TRUE)
                    {
                        it->m_dwSizeUncompressed  = finfo.nFileSizeLow;
                        m_dwSizeTotal            += finfo.nFileSizeLow;
                    }
                }

                ::CloseHandle( handle );

                if(pass == 0) continue; // Don't compress on first pass.

                ////////////////////////////////////////

				AtlW2AHelper( rgFilePath, szFilePath, MAXSTRLEN( rgFilePath ) );
				AtlW2AHelper( rgFileName, szFileName, MAXSTRLEN( rgFileName ) );

                if(FCIAddFile( m_hfci                             ,
                               rgFilePath                         , /* file to add                 */
                               rgFileName                         , /* name of the file in cabinet */
                               FALSE                              , /* file is not executable      */
                               fci_get_next_cabinet               ,
                               fci_progress                       ,
                               fci_get_open_info                  ,
                               tcompTYPE_LZX | tcompLZX_WINDOW_HI ) == FALSE)
                {
                    dwRes = LocalGetLastError();

                    if(dwRes == ERROR_PATH_NOT_FOUND    ||
                       dwRes == ERROR_FILE_NOT_FOUND    ||
                       dwRes == ERROR_SHARING_VIOLATION ||
                       dwRes == ERROR_ACCESS_DENIED      )
                    {
                        if(m_fIgnoreMissingFiles)
                        {
                            dwRes = ERROR_SUCCESS;
                            continue; // The file doesn't exist, simply skip it.
                        }
                    }

                    break;
                }
            }

            if(pass == 0) continue; // Don't compress on first pass.

            if(it == m_lstFiles.end())
            {
                //
                // Finalize cabinet.
                //
                if(FCIFlushCabinet( m_hfci, FALSE, fci_get_next_cabinet, fci_progress ))
                {
                    res = TRUE;
                }
                else
                {
                    dwRes = LocalGetLastError();
                }
            }
        }

        FCIDestroy( m_hfci ); m_hfci = NULL;
    }
    else
    {
        dwRes = LocalGetLastError();
    }

    m_itCurrent = m_lstFiles.end();

    ::SetLastError( dwRes );

    return (res ? S_OK : HRESULT_FROM_WIN32( dwRes ));
}

HRESULT MPC::Cabinet::Decompress()
{
    USES_CONVERSION;

    DWORD dwRes = ERROR_SUCCESS;
    BOOL  res   = FALSE;


    m_hfdi = FDICreate(  mem_alloc  ,
                         mem_free   ,
                         fdi_open   ,
                         fdi_read   ,
                         fdi_write  ,
                         fdi_close  ,
                         fdi_seek   ,
                         cpuUNKNOWN ,
                        &m_erf      );
    if(m_hfdi)
    {
        if(FDICopy( m_hfdi               ,
                    W2A(m_szCabinetName) ,
                    W2A(m_szCabinetPath) ,
                    0                    ,
                    fdi_notification_copy,
                    NULL                 ,
                    this                 ))
        {
            IterConst it;

            for(it=m_lstFiles.begin(); it != m_lstFiles.end(); it++)
            {
                if(it->m_fFound == false) break;
            }

            if(it != m_lstFiles.end())
            {
                dwRes = ERROR_FILE_NOT_FOUND;
            }
            else
            {
                res = TRUE;
            }
        }
        else
        {
            dwRes = LocalGetLastError();
        }

        FDIDestroy( m_hfdi ); m_hfdi = NULL;
    }
    else
    {
        dwRes = LocalGetLastError();
    }


    ::SetLastError( dwRes );

    return (res ? S_OK : HRESULT_FROM_WIN32( dwRes ));
}

HRESULT MPC::Cabinet::Enumerate()
{
    USES_CONVERSION;

    DWORD dwRes = ERROR_SUCCESS;
    BOOL  res   = FALSE;


    m_lstFiles.clear();

    m_hfdi = FDICreate(  mem_alloc  ,
                         mem_free   ,
                         fdi_open   ,
                         fdi_read   ,
                         fdi_write  ,
                         fdi_close  ,
                         fdi_seek   ,
                         cpuUNKNOWN ,
                        &m_erf      );
    if(m_hfdi)
    {
        if(FDICopy( m_hfdi                    ,
                    W2A(m_szCabinetName)      ,
                    W2A(m_szCabinetPath)      ,
                    0                         ,
                    fdi_notification_enumerate,
                    NULL                      ,
                    this                      ))
        {
            res = TRUE;
        }
        else
        {
            dwRes = LocalGetLastError();
        }

        FDIDestroy( m_hfdi ); m_hfdi = NULL;
    }
    else
    {
        dwRes = LocalGetLastError();
    }


    ::SetLastError( dwRes );

    return (res ? S_OK : HRESULT_FROM_WIN32( dwRes ));
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::CompressAsCabinet( LPCWSTR szInputFile   ,
								LPCWSTR szCabinetFile ,
								LPCWSTR szFileName    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CompressAsCabinet" );

    HRESULT hr;
    Cabinet cab;


    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile( szCabinetFile             ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile        ( szInputFile  , szFileName ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.Compress());

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::CompressAsCabinet( const WStringList& lstFiles            ,
								LPCWSTR            szCabinetFile       ,
								BOOL               fIgnoreMissingFiles )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CompressAsCabinet" );

    HRESULT          hr;
    Cabinet          cab;
    WStringIterConst it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile       ( szCabinetFile       ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_IgnoreMissingFiles( fIgnoreMissingFiles ));

    for(it=lstFiles.begin(); it != lstFiles.end(); it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile( it->c_str() ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.Compress());

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::ListFilesInCabinet( LPCWSTR      szCabinetFile ,
								 WStringList& lstFiles      )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ListFilesInCabinet" );

    HRESULT            hr;
    Cabinet            cab;
    Cabinet::List      lst;
    Cabinet::IterConst it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile( szCabinetFile ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.Enumerate());

    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.GetFiles( lst ));
    for(it=lst.begin(); it!=lst.end(); it++)
    {
        if(it->m_fFound)
        {
            lstFiles.push_back( it->m_szName );
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::DecompressFromCabinet( LPCWSTR szCabinetFile ,
									LPCWSTR szOutputFile  ,
									LPCWSTR szFileName    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CompressAsCabinet" );

    HRESULT hr;
    Cabinet cab;


    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.put_CabinetFile( szCabinetFile             ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.AddFile        ( szOutputFile , szFileName ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, cab.Decompress());

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_com.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_COM.cpp

Abstract:
    This file contains the implementation of commodity classes related to COM.

Revision History:
    Davide Massarenti   (Dmassare)  06/18/99
        created
    Davide Massarenti   (Dmassare)  07/21/99
        move under "core"

******************************************************************************/

#include "stdafx.h"

#include <process.h>

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::COMUtil::GetPropertyByName( /*[in]*/  IDispatch*   obj    ,
                                         /*[in]*/  LPCWSTR      szName ,
                                         /*[out]*/ CComVariant& v      )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::COMUtil::GetPropertyByName" );

    HRESULT            hr;
    CComDispatchDriver disp( obj );

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(obj);
    __MPC_PARAMCHECK_END();

    v.Clear();

    hr = disp.GetPropertyByName( CComBSTR( szName ), &v );
    if(FAILED(hr) && hr != DISP_E_UNKNOWNNAME) __MPC_FUNC_LEAVE;


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::COMUtil::GetPropertyByName( /*[in]*/  IDispatch* obj    ,
                                         /*[in]*/  LPCWSTR    szName ,
                                         /*[out]*/ CComBSTR&  bstr   )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::COMUtil::GetPropertyByName" );

    HRESULT     hr;
    CComVariant v;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetPropertyByName( obj, szName, v ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, VarToBSTR        ( v,  bstr       ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::COMUtil::GetPropertyByName( /*[in]*/  IDispatch* obj    ,
                                         /*[in]*/  LPCWSTR    szName ,
                                         /*[out]*/ bool&      fValue )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::COMUtil::GetPropertyByName" );

    HRESULT     hr;
    CComVariant v;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetPropertyByName( obj, szName, v ));
    if(v.vt != VT_NULL  &&
       v.vt != VT_EMPTY  )
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, v.ChangeType( VT_BOOL ));

        fValue = v.boolVal == VARIANT_TRUE;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::COMUtil::GetPropertyByName( /*[in]*/  IDispatch* obj    ,
                                         /*[in]*/  LPCWSTR    szName ,
                                         /*[out]*/ long&      lValue )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::COMUtil::GetPropertyByName" );

    HRESULT     hr;
    CComVariant v;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetPropertyByName( obj, szName, v ));
    if(v.vt != VT_NULL  &&
       v.vt != VT_EMPTY  )
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, v.ChangeType( VT_I4 ));

        lValue = v.lVal;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////

HRESULT MPC::COMUtil::VarToBSTR( /*[in] */ CComVariant& v   ,
                                 /*[out]*/ CComBSTR&    str )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::COMUtil::VarToBSTR" );

    HRESULT hr;

    str.Empty();

    if(v.vt != VT_NULL  &&
       v.vt != VT_EMPTY  )
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, v.ChangeType( VT_BSTR ));

        str = v.bstrVal;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::COMUtil::VarToInterface( /*[in]*/  CComVariant&  v   ,
                                      /*[in]*/  const IID&    iid ,
                                      /*[out]*/ IUnknown*    *obj )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::COMUtil::VarToInterface" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(obj,NULL);
    __MPC_PARAMCHECK_END();


    if(v.vt != VT_NULL  &&
       v.vt != VT_EMPTY  )
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, v.ChangeType( VT_UNKNOWN ));

        if(v.punkVal)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, v.punkVal->QueryInterface( iid, (LPVOID*)obj ));
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

MPC::CComConstantHolder::CComConstantHolder( /*[in]*/ const GUID* plibid ,
                                             /*[in]*/ WORD        wMajor ,
                                             /*[in]*/ WORD        wMinor )
{
    m_plibid = plibid;
    m_wMajor = wMajor;
    m_wMinor = wMinor;
}

HRESULT MPC::CComConstantHolder::EnsureLoaded( /*[in]*/ LCID lcid )
{
    HRESULT hr;

    if(!m_pTypeLib)
    {
        if(SUCCEEDED(hr = ::LoadRegTypeLib( *m_plibid, m_wMajor, m_wMinor, lcid, &m_pTypeLib )))
        {
            UINT cTypes = m_pTypeLib->GetTypeInfoCount();

            for(UINT uType=0; uType<cTypes; uType++)
            {
                CComPtr<ITypeInfo> pTypeInfo;

                if(SUCCEEDED(m_pTypeLib->GetTypeInfo( uType, &pTypeInfo )))
                {
                    TYPEATTR* pTypeAttr = NULL;

                    if(SUCCEEDED(pTypeInfo->GetTypeAttr( &pTypeAttr )) && pTypeAttr)
                    {
                        if(pTypeAttr->typekind == TKIND_ENUM)
                        {
                            for(WORD i=0; i<pTypeAttr->cVars; i++)
                            {
                                VARDESC* pVarDesc  = NULL;

                                if(SUCCEEDED(pTypeInfo->GetVarDesc( i, &pVarDesc )) && pVarDesc)
                                {
                                    if(pVarDesc->varkind == VAR_CONST && pVarDesc->lpvarValue)
                                    {
                                        m_const[pVarDesc->memid] = *pVarDesc->lpvarValue;
                                    }

                                    pTypeInfo->ReleaseVarDesc( pVarDesc );
                                }
                            }
                        }

                        pTypeInfo->ReleaseTypeAttr( pTypeAttr );
                    }
                }
            }
        }
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT MPC::CComConstantHolder::GetIDsOfNames( LPOLESTR* rgszNames ,
                                                UINT      cNames    ,
                                                LCID      lcid      ,
                                                DISPID*   rgdispid  )
{
    HRESULT hr;

    if(SUCCEEDED(hr = EnsureLoaded( lcid )))
    {
        UINT uMissing = cNames;

        for(UINT uName=0; uName<cNames; uName++)
        {
            CComPtr<ITypeInfo> pTypeInfo;
            MEMBERID           memID;
            USHORT             uFound = 1;

            if(SUCCEEDED(m_pTypeLib->FindName( rgszNames[uName], 0, &pTypeInfo, &memID, &uFound )) && uFound == 1)
            {
                rgdispid[uName] = memID; uMissing--;
            }
        }

        if(uMissing != 0) hr = DISP_E_MEMBERNOTFOUND;
    }

    return hr;
}

HRESULT MPC::CComConstantHolder::GetValue( /*[in]*/  DISPID   dispidMember ,
                                           /*[in]*/  LCID     lcid         ,
                                           /*[out]*/ VARIANT* pvarResult   )
{
    HRESULT hr;

    if(SUCCEEDED(hr = EnsureLoaded( lcid )))
    {
        MemberLookupIter it = m_const.find( dispidMember );

        if(it == m_const.end())
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = ::VariantCopy( pvarResult, &(it->second) );
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SafeInitializeCriticalSection( /*[in/out]*/ CRITICAL_SECTION& sec )
{
    try
    {
        ::ZeroMemory( &sec, sizeof( sec ) );

        ::InitializeCriticalSection( &sec );
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT MPC::SafeDeleteCriticalSection( /*[in/out]*/ CRITICAL_SECTION& sec )
{
    try
    {
        ::DeleteCriticalSection( &sec );

        ::ZeroMemory( &sec, sizeof( sec ) );
    }
    catch(...)
    {
        return E_FAIL;
    }

    return S_OK;
}

MPC::CComSafeAutoCriticalSection::CComSafeAutoCriticalSection () { SafeInitializeCriticalSection( m_sec ); }
MPC::CComSafeAutoCriticalSection::~CComSafeAutoCriticalSection() { SafeDeleteCriticalSection    ( m_sec ); }

void MPC::CComSafeAutoCriticalSection::Lock  () { try{ ::EnterCriticalSection( &m_sec ); } catch(...) {} }
void MPC::CComSafeAutoCriticalSection::Unlock() { try{ ::LeaveCriticalSection( &m_sec ); } catch(...) {} }

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// MPC::CComPtrThreadNeutral_GIT                                           //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
void MPC::CComPtrThreadNeutral_GIT::Lock()
{
    ::EnterCriticalSection( &m_sec );
}

void MPC::CComPtrThreadNeutral_GIT::Unlock()
{
    ::LeaveCriticalSection( &m_sec );
}

HRESULT MPC::CComPtrThreadNeutral_GIT::GetGIT( IGlobalInterfaceTable* *ppGIT )
{
    _ASSERTE(ppGIT != NULL);

    HRESULT hr = E_FAIL;

    Lock();

    if((*ppGIT = m_pGIT))
    {
        m_pGIT->AddRef();
        hr = S_OK;
    }

    Unlock();

    return hr;
}

MPC::CComPtrThreadNeutral_GIT::CComPtrThreadNeutral_GIT()
{
    m_pGIT = NULL;

    MPC::SafeInitializeCriticalSection( m_sec );
}

MPC::CComPtrThreadNeutral_GIT::~CComPtrThreadNeutral_GIT()
{
    Term();

    MPC::SafeDeleteCriticalSection( m_sec );
}

HRESULT MPC::CComPtrThreadNeutral_GIT::Init()
{
    HRESULT hr = S_OK;

    Lock();

    if(m_pGIT == NULL)
    {
        hr = ::CoCreateInstance( CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&m_pGIT );
    }

    Unlock();

    return hr;
}

HRESULT MPC::CComPtrThreadNeutral_GIT::Term()
{
    HRESULT hr = S_OK;

    Lock();

    if(m_pGIT)
    {
        m_pGIT->Release();

        m_pGIT = NULL;
    }

    Unlock();

    return hr;
}

HRESULT MPC::CComPtrThreadNeutral_GIT::RegisterInterface( /*[in] */ IUnknown*  pUnk      ,
                                                          /*[in] */ REFIID     riid      ,
                                                          /*[out]*/ DWORD     *pdwCookie )
{
    CComPtr<IGlobalInterfaceTable> pGIT;
    HRESULT                        hr;


    if(SUCCEEDED(hr = GetGIT( &pGIT )))
    {
        hr = pGIT->RegisterInterfaceInGlobal( pUnk, riid, pdwCookie );
    }


    return hr;
}

HRESULT MPC::CComPtrThreadNeutral_GIT::RevokeInterface( /*[in]*/ DWORD dwCookie )
{
    CComPtr<IGlobalInterfaceTable> pGIT;
    HRESULT                        hr;


    if(SUCCEEDED(hr = GetGIT( &pGIT )))
    {
        hr = pGIT->RevokeInterfaceFromGlobal( dwCookie );
    }


    return hr;
}

HRESULT MPC::CComPtrThreadNeutral_GIT::GetInterface( /*[in] */ DWORD   dwCookie ,
                                                     /*[in] */ REFIID  riid     ,
                                                     /*[out]*/ void*  *ppv      )
{
    CComPtr<IGlobalInterfaceTable> pGIT;
    HRESULT                        hr;


    if(SUCCEEDED(hr = GetGIT( &pGIT )))
    {
        hr = pGIT->GetInterfaceFromGlobal( dwCookie, riid, ppv );
    }


    return hr;
}

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//                                                            //
// AsyncInvoke, AsyncInvoke::CallDesc & AsyncInvoke::CallItem //
//                                                            //
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

MPC::AsyncInvoke::CallItem::CallItem()
{
    m_vt = VT_EMPTY; // VARTYPE                         m_vt;
                     // CComPtrThreadNeutral<IUnknown>  m_Unknown;
                     // CComPtrThreadNeutral<IDispatch> m_Dispatch;
                     // CComVariant                     m_Other;
}

MPC::AsyncInvoke::CallItem& MPC::AsyncInvoke::CallItem::operator=( const CComVariant& var )
{
    switch(m_vt = var.vt)
    {
    case VT_UNKNOWN : m_Unknown  = var.punkVal ; break;
    case VT_DISPATCH: m_Dispatch = var.pdispVal; break;
    default         : m_Other    = var         ; break;
    }

    return *this;
}

MPC::AsyncInvoke::CallItem::operator CComVariant() const
{
    CComVariant res;

    switch(m_vt)
    {
    case VT_UNKNOWN : res = (CComPtr<IUnknown> )m_Unknown ; break;
    case VT_DISPATCH: res = (CComPtr<IDispatch>)m_Dispatch; break;
    default         : res =                     m_Other   ; break;
    }

    return res;
}


MPC::AsyncInvoke::CallDesc::CallDesc( IDispatch*           dispTarget   ,
									  DISPID               dispidMethod ,
									  const CComVariant* rgvVars      ,
									  int                dwVars       )
{
    m_dispTarget   = dispTarget;
    m_dispidMethod = dispidMethod;
    m_rgciVars     = new CallItem[dwVars];
    m_dwVars       = dwVars;

    if(m_rgciVars)
    {
        for(int i=0; i<dwVars; i++)
        {
            m_rgciVars[i] = rgvVars[i];
        }
    }
}

MPC::AsyncInvoke::CallDesc::~CallDesc()
{
    if(m_rgciVars) delete [] m_rgciVars;
}

HRESULT MPC::AsyncInvoke::CallDesc::Call()
{
    HRESULT            hr;
    CComPtr<IDispatch> dispTarget = m_dispTarget;

    if(dispTarget == NULL)
    {
        hr = E_POINTER;
    }
    else
    {
        CComVariant* pvars = new CComVariant[m_dwVars];
        DISPPARAMS   disp = { pvars, NULL, m_dwVars, 0 };
        CComVariant  vResult;

        if(pvars)
        {
            for(int i=0; i<m_dwVars; i++)
            {
                pvars[i] = m_rgciVars[i];
            }

            hr = dispTarget->Invoke( m_dispidMethod, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &vResult, NULL, NULL );

            delete [] pvars;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::AsyncInvoke::Init()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::AsyncInvoke::Init" );

    return Thread_Start( this, Thread_Run, NULL );
}

HRESULT MPC::AsyncInvoke::Term()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::AsyncInvoke::Term" );

    Thread_Wait();

    return S_OK;
}

HRESULT MPC::AsyncInvoke::Thread_Run()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::AsyncInvoke::Thread_Run" );

    HRESULT   hr;
    IterConst it;
    CallDesc* cd;


    while(Thread_IsAborted() == false)
    {
        ////////////////////////////////////////
        //
        // Start of Critical Section.
        //
        SmartLock<_ThreadModel> lock( this );

        //
        // If no event in the list, go back to WaitForSingleObject.
        //
        it = m_lstEvents.begin();
        if(it == m_lstEvents.end()) break;

        //
        // Get the first event in the list.
        //
        cd = *it;

        //
        // Remove the event from the list.
        //
        m_lstEvents.erase( it );

        lock = NULL; // Unlock.
        //
        // End of Critical Section.
        //
        ////////////////////////////////////////

        //
        // Fire the event.
        //
        if(cd)
        {
            __MPC_PROTECT( (void)cd->Call() );

            delete cd;
        }
    }

    hr = S_OK;


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::AsyncInvoke::Invoke( IDispatch*         dispTarget  ,
								  DISPID             dispidMethod,
								  const CComVariant* rgvVars     ,
								  int                dwVars      )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::AsyncInvoke::Invoke" );

    HRESULT hr;

    __MPC_TRY_BEGIN();

    CallDesc*               cd;
    SmartLock<_ThreadModel> lock( NULL ); // Don't lock immediately, first create the CallDesc object (deadlocks...)


    __MPC_EXIT_IF_ALLOC_FAILS(hr, cd, new CallDesc( dispTarget, dispidMethod, rgvVars, dwVars ));


    lock = this;
    m_lstEvents.push_back( cd );
    hr = S_OK;


    Thread_Signal();

    __MPC_FUNC_CLEANUP;

    __MPC_TRY_CATCHALL(hr);

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::FireAsyncEvent( DISPID               dispid       ,
                             CComVariant*         pVars        ,
                             DWORD                dwVars       ,
                             const IDispatchList& lst          ,
                             IDispatch*           pJScript     ,
                             bool                 fFailOnError )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FireAsyncEvent" );

    HRESULT            hr;
    IDispatchIterConst it;

    if(pJScript)
    {
        HRESULT hr2;

        hr2 = MPC::AsyncInvoke( pJScript, 0, pVars, dwVars );
        if(FAILED(hr2) && fFailOnError)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, hr2);
        }
    }

    for(it=lst.begin(); it != lst.end(); it++)
    {
        if(*it != NULL)
        {
            HRESULT     hr2;
            CComVariant vResult;

            hr2 = MPC::AsyncInvoke( *it, dispid, pVars, dwVars );
            if(FAILED(hr2) && fFailOnError)
            {
                __MPC_SET_ERROR_AND_EXIT(hr, hr2);
            }
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FireEvent( DISPID               dispid       ,
                        CComVariant*         pVars        ,
                        DWORD                dwVars       ,
                        const IDispatchList& lst          ,
                        IDispatch*           pJScript     ,
                        bool                 fFailOnError )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FireEvent" );

    HRESULT            hr;
    IDispatchIterConst it;
    DISPPARAMS         disp = { pVars, NULL, dwVars, 0 };


    if(pJScript)
    {
        HRESULT     hr2;
        CComVariant vResult;

        hr2 = pJScript->Invoke( 0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &vResult, NULL, NULL );
        if(FAILED(hr2) && fFailOnError)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, hr2);
        }
    }

    for(it=lst.begin(); it != lst.end(); it++)
    {
        if(*it != NULL)
        {
            HRESULT     hr2;
            CComVariant vResult;

            hr2 = (*it)->Invoke( dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &vResult, NULL, NULL );
            if(FAILED(hr2) && fFailOnError)
            {
                __MPC_SET_ERROR_AND_EXIT(hr, hr2);
            }
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::AsyncInvoke( /*[in]*/ IDispatch*         dispTarget   ,
                          /*[in]*/ DISPID             dispidMethod ,
                          /*[in]*/ const CComVariant* rgvVars      ,
                          /*[in]*/ int                dwVars       )
{
    return MPC::_MPC_Module.m_AsyncInvoke ? MPC::_MPC_Module.m_AsyncInvoke->Invoke( dispTarget, dispidMethod, rgvVars, dwVars ) : E_FAIL;
}

void MPC::SleepWithMessagePump( /*[in]*/ DWORD  dwTimeout )
{
    HANDLE hEvent = ::CreateEvent( NULL, FALSE, FALSE, NULL );

    if(hEvent)
    {
        (void)MPC::WaitForSingleObject( hEvent, dwTimeout );

        ::CloseHandle( hEvent );
    }
}

DWORD MPC::WaitForSingleObject( /*[in]*/ HANDLE hEvent    ,
                                /*[in]*/ DWORD  dwTimeout )
{
    return MPC::WaitForMultipleObjects( 1, &hEvent, dwTimeout );
}

DWORD MPC::WaitForMultipleObjects( /*[in]*/ DWORD   dwEvents  ,
                                   /*[in]*/ HANDLE* rgEvents  ,
                                   /*[in]*/ DWORD   dwTimeout )
{
    DWORD dwTickPre;
    DWORD dwTickPost;
    DWORD dwRet;
    MSG   msg;


    while(1)
    {
        dwTickPre = ::GetTickCount();

        while(1)
        {
            //
            // Commenting out 'dwRet >= WAIT_OBJECT_0', thanks to our extremely smart compiler...
            //
            dwRet = ::WaitForMultipleObjects( dwEvents, rgEvents, FALSE, 0 );
            if((/*dwRet >= WAIT_OBJECT_0    &&*/ dwRet < WAIT_OBJECT_0    + dwEvents) || // An event was signaled.
               (  dwRet >= WAIT_ABANDONED_0 &&   dwRet < WAIT_ABANDONED_0 + dwEvents)  ) // An event was abandoned.
            {
                return dwRet;
            }

            if(!::PeekMessage( &msg, NULL, NULL, NULL, PM_REMOVE )) break;

            //
            // There is one or more window message available. Dispatch them.
            //
            ::TranslateMessage( &msg );
            ::DispatchMessage ( &msg );
        }

        ////////////////////

        dwRet      = ::MsgWaitForMultipleObjects( dwEvents, rgEvents, FALSE, dwTimeout, QS_ALLINPUT );
        dwTickPost = ::GetTickCount();

        //
        // Commenting out 'dwRet >= WAIT_OBJECT_0', thanks to our extremely smart compiler...
        //
        if((/*dwRet >= WAIT_OBJECT_0    &&*/ dwRet < WAIT_OBJECT_0    + dwEvents) || // An event was signaled.
           (  dwRet >= WAIT_ABANDONED_0 &&   dwRet < WAIT_ABANDONED_0 + dwEvents) || // An event was abandoned.
           (  dwRet !=                               WAIT_OBJECT_0    + dwEvents)  ) // Something else happened
        {
            return dwRet;
        }

        ////////////////////

        //
        // Take care of timeout.
        //
        if(dwTimeout != INFINITE)
        {
            dwTickPost -= dwTickPre;

            if(dwTimeout < dwTickPost)
            {
                return WAIT_TIMEOUT;
            }

            dwTimeout -= dwTickPost;
        }
    }

    return -1;
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// MPC::MPCMODULE                                                          //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

MPC::MPCMODULE        MPC::_MPC_Module;

LONG                  MPC::MPCMODULE::m_lInitialized  = 0;
LONG                  MPC::MPCMODULE::m_lInitializing = 0;
CComCriticalSection   MPC::MPCMODULE::m_sec;
MPC::MPCMODULE::List* MPC::MPCMODULE::m_lstTermCallback;

////////////////////////////////////////

//
// The problem we are trying to resolve is calling RegisterCallbackInner from static constructors.
//
// Because there's no order guaranteed, any static class constructor can call our method BEFORE
// the class has been initialized by the C runtime...
//
// So we cannot rely on any member variable been initialized properly.
// This means no Critical Section up and running, no list ready to use...
//
HRESULT MPC::MPCMODULE::Initialize()
{
    HRESULT hr = S_OK;

    if(m_lInitialized == 0) // m_lInitialized only changes from 0 to 1, so it's safe to look at it without locking.
    {
        //
        // Our primitive critical section...
        //
        while(::InterlockedExchange( &m_lInitializing, 1 ) != 0)
        {
            ::Sleep( 0 ); // Yield processor...
        }

        while(m_lInitialized == 0)
        {
            m_sec.Init();

            m_lstTermCallback = new List;
            if(m_lstTermCallback == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            //
            // Make sure that the TEMP environment variable is defined.
            //
            {
                WCHAR rgBuf[MAX_PATH];

                if(::GetEnvironmentVariableW( L"TEMP", rgBuf, MAXSTRLEN(rgBuf) ) == 0)
                {
                    ::GetTempPathW           ( MAXSTRLEN(rgBuf), rgBuf );
                    ::SetEnvironmentVariableW( L"TEMP"         , rgBuf );
                }
            }

            m_lInitialized = 1;
        }

        ::InterlockedExchange( &m_lInitializing, 0 );
    }

    return hr;
}

////////////////////////////////////////

HRESULT MPC::MPCMODULE::RegisterCallbackInner( /*[in]*/ AnchorBase* pElem, /*[in]*/ void* pThis )
{
    HRESULT hr;

    if(pElem == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if(SUCCEEDED(hr = Initialize()))
    {
        UnregisterCallbackInner( pThis );

        m_sec.Lock();

        m_lstTermCallback->push_back( pElem );

        m_sec.Unlock();
    }

    return hr;
}

HRESULT MPC::MPCMODULE::UnregisterCallbackInner( /*[in/out]*/ void* pThis )
{
    HRESULT hr;

    if(SUCCEEDED(hr = Initialize()))
    {
        Iter it;

        m_sec.Lock();

        for(it = m_lstTermCallback->begin(); it != m_lstTermCallback->end(); )
        {
            AnchorBase* pElem = *it;

            if(pElem->Match( pThis ))
            {
                m_lstTermCallback->erase( it ); delete pElem;

                it = m_lstTermCallback->begin();
            }
            else
            {
                it++;
            }
        }

        m_sec.Unlock();
    }

    return hr;
}

////////////////////////////////////////

HRESULT MPC::MPCMODULE::Init()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::MPCMODULE::Init" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Initialize());

    __MPC_EXIT_IF_ALLOC_FAILS (hr, m_GITHolder, new CComPtrThreadNeutral_GIT);
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_GITHolder->Init()                      );

    __MPC_EXIT_IF_ALLOC_FAILS (hr, m_AsyncInvoke, new class MPC::AsyncInvoke);
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_AsyncInvoke->Init()                    );

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::MPCMODULE::Term()
{
    HRESULT hr;

    //
    // Call the registered termination methods.
    //
    if(SUCCEEDED(hr = Initialize()))
    {
        m_sec.Lock();

        for(Iter it = m_lstTermCallback->begin(); it != m_lstTermCallback->end(); it++)
        {
            AnchorBase* pElem = *it;

            pElem->Call();
        }

        m_sec.Unlock();
    }

    if(m_AsyncInvoke) { m_AsyncInvoke->Term(); delete m_AsyncInvoke; m_AsyncInvoke = NULL; }
    if(m_GITHolder  ) { m_GITHolder  ->Term(); delete m_GITHolder  ; m_GITHolder   = NULL; }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_hglobal.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_HGLOBAL.cpp

Abstract:
    This file contains the implementation of various utility functions.

Revision History:
    Davide Massarenti   (Dmassare)  04/17/99
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

MPC::CComHGLOBAL::CComHGLOBAL()
{
    m_hg  	 = NULL; // HGLOBAL        m_hg;
    m_ptr 	 = NULL; // mutable LPVOID m_ptr;
	m_dwLock = 0;    // mutable DWORD  m_dwLock;
}

MPC::CComHGLOBAL::~CComHGLOBAL()
{
	Release();
}

MPC::CComHGLOBAL::CComHGLOBAL( /*[in]*/ const CComHGLOBAL& chg )
{
    m_hg  	 = NULL; // HGLOBAL        m_hg;
    m_ptr 	 = NULL; // mutable LPVOID m_ptr;
	m_dwLock = 0;    // mutable DWORD  m_dwLock;
	
	*this = chg;
}

MPC::CComHGLOBAL& MPC::CComHGLOBAL::operator=( /*[in]*/ const CComHGLOBAL& chg )
{
	return *this = chg.m_hg;
}

MPC::CComHGLOBAL& MPC::CComHGLOBAL::operator=( /*[in]*/ HGLOBAL hg )
{
	(void)Copy( hg );

	return *this;
}

void MPC::CComHGLOBAL::Attach( /*[in]*/ HGLOBAL hg )
{
	Release();

	m_hg = hg;
}

HGLOBAL MPC::CComHGLOBAL::Detach()
{
	HGLOBAL hg;

	while(m_ptr) Unlock();

	hg = m_hg; m_hg = NULL;

	return hg;
}

////////////////////

HRESULT MPC::CComHGLOBAL::New( /*[in]*/ UINT uFlags, /*[in]*/ DWORD dwSize )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CComHGLOBAL::New" );

    HRESULT hr;

	Release();

	if(dwSize)
	{
		__MPC_EXIT_IF_ALLOC_FAILS(hr, m_hg, ::GlobalAlloc( uFlags, dwSize ));
	}

	hr = S_OK;


	__MPC_FUNC_CLEANUP;

	__MPC_FUNC_EXIT(hr);
}

void MPC::CComHGLOBAL::Release()
{
	Unlock();

	if(m_hg)
	{
		::GlobalFree( m_hg );

		m_hg = NULL;
	}
}

LPVOID MPC::CComHGLOBAL::Lock() const
{
	if(m_ptr == NULL)
	{
		if(m_hg) m_ptr = ::GlobalLock( m_hg );
	}

	m_dwLock++;

	return m_ptr;
}

void MPC::CComHGLOBAL::Unlock() const
{
	if(m_ptr)
	{
		if(--m_dwLock == 0)
		{
			::GlobalUnlock( m_hg );

			m_ptr = NULL;
		}
	}
}

////////////////////

HGLOBAL MPC::CComHGLOBAL::Get       () const {           return  m_hg; }
HGLOBAL MPC::CComHGLOBAL::GetRef    ()       { Unlock(); return  m_hg; }
HGLOBAL MPC::CComHGLOBAL::GetPointer()       { Unlock(); return &m_hg; }

DWORD MPC::CComHGLOBAL::Size() const { return m_hg ? ::GlobalSize( m_hg ) : 0; }

////////////////////

HRESULT MPC::CComHGLOBAL::Copy( /*[in]*/ HGLOBAL hg, /*[in]*/ DWORD dwMaxSize )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CComHGLOBAL::Copy" );

    HRESULT hr;


	Release();


	if(hg)
	{
		DWORD  dwSize = ::GlobalSize( hg );
		LPVOID pIn;
		LPVOID pOut;

		if(dwMaxSize != 0xFFFFFFFF &&
		   dwMaxSize <  dwSize      )
		{
			dwSize = dwMaxSize;
		}

		__MPC_EXIT_IF_ALLOC_FAILS(hr, m_hg, ::GlobalAlloc( GMEM_SHARE | GMEM_MOVEABLE, dwSize ));

		if((pIn = ::GlobalLock( hg )))
		{
			if((pOut = ::GlobalLock( m_hg )))
			{
				::CopyMemory( pOut, pIn, dwSize );
				
				::GlobalUnlock( m_hg );
			}

			::GlobalUnlock( hg );
		}
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}	

//////////////////////////////////////////////////

HRESULT MPC::CComHGLOBAL::CopyFromStream( /*[in ]*/ IStream* val )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CComHGLOBAL::FromStream" );

    HRESULT          hr;
	CComPtr<IStream> tmp;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(val);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, New( GMEM_SHARE | GMEM_MOVEABLE, 0 ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( m_hg, FALSE, &tmp ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( val, tmp ));


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::CComHGLOBAL::CopyToStream( /*[out]*/ IStream* val )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CComHGLOBAL::ToStream" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(val);
    __MPC_PARAMCHECK_END();


	if(m_hg)
	{
		LARGE_INTEGER li;
		DWORD  		  dwWritten = 0;
		DWORD  		  dwSize    = ::GlobalSize( m_hg );
		LPVOID 		  ptr;

		if((ptr = ::GlobalLock( m_hg )))
		{
			hr = val->Write( ptr, dwSize, &dwWritten );

			::GlobalUnlock( m_hg );
		}
		else
		{
			hr = E_FAIL;
		}

		if(FAILED(hr)) __MPC_FUNC_LEAVE;

		if(dwWritten != dwSize)
		{
			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_HANDLE_DISK_FULL );
		}
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::CComHGLOBAL::CloneAsStream( /*[out]*/ IStream* *pVal )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CComHGLOBAL::CloneAsStream" );

    HRESULT     hr;
	CComHGLOBAL tmp;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, tmp.Copy( m_hg ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, tmp.DetachAsStream( pVal ));


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::CComHGLOBAL::DetachAsStream( /*[out]*/ IStream* *pVal )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CComHGLOBAL::DetachAsStream" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( m_hg, TRUE, pVal ));

	(void)Detach();

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::CComHGLOBAL::GetAsStream( /*[out]*/ IStream* *pVal, /*[in]*/ bool fClone )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CComHGLOBAL::GetAsStream" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

	if(fClone)
	{
		CComHGLOBAL h = *this;

		__MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( h.Get(), TRUE, pVal ));

		(void)h.Detach(); // Detach AFTER the stream has been created, to avoid leaks...
	}
	else
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( m_hg, FALSE, pVal ));

		if(!m_hg)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, ::GetHGlobalFromStream( *pVal, &m_hg ));
		}
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::CComHGLOBAL::NewStream( /*[out]*/ IStream* *pVal )
{
	Release();

	return GetAsStream( pVal, /*fClone*/false );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_msits.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_MSITS.cpp

Abstract:
    This file contains the implementation of the helper class for accessing files
	inside CHMs.

Revision History:
    Davide Massarenti   (Dmassare)  12/17/99
        created

******************************************************************************/

#include "stdafx.h"

#include <ITSS\msitstg.h>

/////////////////////////////////////////////////////////////////////////////

struct Prefix
{
	LPCWSTR szProtocol;
	size_t  iLen;
};

static const WCHAR l_szMS_ITS   [] = L"ms-its:";
static const WCHAR l_szMSITSTORE[] = L"mk:@MSITStore:";
static const WCHAR l_szITS      [] = L"its:";
static const WCHAR l_szSEP      [] = L"::";


static const Prefix l_rgPrefix[] =
{
	{ l_szMS_ITS   , MAXSTRLEN( l_szMS_ITS    ) },
	{ l_szMSITSTORE, MAXSTRLEN( l_szMSITSTORE ) },
	{ l_szITS      , MAXSTRLEN( l_szITS       ) },
	{ NULL                                      }
};

/////////////////////////////////////////////////////////////////////////////

bool MPC::MSITS::IsCHM( /*[in] */ LPCWSTR pwzUrl           ,
						/*[out]*/ BSTR*   pbstrStorageName ,
						/*[out]*/ BSTR*   pbstrFilePath    )
{
	bool fRes = false;

	if(pwzUrl)
	{
		for(const Prefix* ptr=l_rgPrefix; ptr->szProtocol; ptr++)
		{
			if(!_wcsnicmp( pwzUrl, ptr->szProtocol, ptr->iLen ))
			{
				LPCWSTR pwzSep;

				pwzUrl += ptr->iLen;

				if((pwzSep = wcsstr( pwzUrl, l_szSEP )))
				{
					if(pbstrStorageName) *pbstrStorageName = ::SysAllocStringLen( pwzUrl, pwzSep - pwzUrl );

					if(pbstrFilePath)
					{
						LPCWSTR pwzQuery;
						LPCWSTR pwzAnchor;
						UINT    uLen;

						pwzSep += ARRAYSIZE(l_szSEP); while(pwzSep[0] == L'/') pwzSep++; // Skip initial slash.

						pwzQuery  = wcschr( pwzSep, '?' );
						pwzAnchor = wcschr( pwzSep, '#' );

						if(pwzQuery)
						{
							if(pwzAnchor) uLen = min(pwzQuery,pwzAnchor) - pwzSep;
							else          uLen =     pwzQuery            - pwzSep;
						}
						else
						{
							if(pwzAnchor) uLen = pwzAnchor - pwzSep;
							else          uLen = wcslen( pwzSep );
						}

						*pbstrFilePath = ::SysAllocStringLen( pwzSep, uLen );
					}
				}
				else
				{
					if(pbstrStorageName) *pbstrStorageName = ::SysAllocString( pwzUrl );
				}

				fRes = true;
				break;
			}
		}
	}

	return fRes;
}


HRESULT MPC::MSITS::OpenAsStream( /*[in] */ const CComBSTR&   bstrStorageName ,
								  /*[in] */ const CComBSTR&   bstrFilePath    ,
								  /*[out]*/ IStream         **ppStream        )
{
    __MPC_FUNC_ENTRY(COMMONID,"MPC::MSITS::OpenAsStream");

    HRESULT             hr;
	CComPtr<IITStorage> pITStorage;
	CComPtr<IStorage>   pStorage;


	if(bstrStorageName.Length() == 0 || bstrFilePath.Length() == 0)
	{
		__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
	}


    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_ITStorage, NULL, CLSCTX_INPROC_SERVER, IID_ITStorage, (VOID **)&pITStorage ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pITStorage->StgOpenStorage( bstrStorageName, NULL, STGM_READ, NULL, 0, &pStorage ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pStorage->OpenStream( bstrFilePath, 0, STGM_READ, 0, ppStream ));

	hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils.cpp

Abstract:
    This file contains the implementation of various utility functions.

Revision History:
    Davide Massarenti   (Dmassare)  04/17/99
        created

******************************************************************************/

#include "stdafx.h"

#define BUFFER_TMP_SIZE 1024

////////////////////////////////////////////////////////////////////////////////

int MPC::HexToNum( int c )
{
    if(c >= '0' && c <= '9') return c - '0';
    if(c >= 'A' && c <= 'F') return c - 'A' + 10;
    if(c >= 'a' && c <= 'f') return c - 'a' + 10;

    return -1;
}

char MPC::NumToHex( int c )
{
    static char s_lookup[] = { '0', '1', '2', '3' ,
                               '4', '5', '6', '7' ,
                               '8', '9', 'A', 'B' ,
                               'C', 'D', 'E', 'F' };

    return s_lookup[ c & 0xF ];
}

////////////////////////////////////////////////////////////////////////////////

void MPC::RemoveTrailingBackslash( /*[in/out]*/ LPWSTR szPath )
{
    LPWSTR szEnd = szPath + wcslen( szPath );

    while(szEnd-- > szPath)
    {
        if(szEnd[0] != '\\' &&
           szEnd[0] != '//'  )
        {
            szEnd[1] = 0;
            break;
        }
    }
}

HRESULT MPC::GetProgramDirectory( /*[out]*/ MPC::wstring& szPath )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::GetProgramDirectory" );

    HRESULT hr;
    WCHAR   rgFileName[MAX_PATH];
    LPWSTR  szEnd;

    __MPC_EXIT_IF_CALL_RETURNS_ZERO(hr, ::GetModuleFileNameW( NULL, rgFileName, MAX_PATH ));

    // Remove file name.
    if((szEnd = wcsrchr( rgFileName, '\\' ))) szEnd[0] = 0;

    szPath = rgFileName;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::GetUserWritablePath( /*[out]*/ MPC::wstring& strPath, /*[in]*/ LPCWSTR szSubDir )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::GetUserWritablePath");

    HRESULT      hr;
    LPITEMIDLIST pidl = NULL;
    WCHAR        rgAppDataPath[MAX_PATH+1];
    LPWSTR       szPtr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ::SHGetSpecialFolderLocation( NULL, CSIDL_LOCAL_APPDATA, &pidl ));


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SHGetPathFromIDListW( pidl, rgAppDataPath ));

    MPC::RemoveTrailingBackslash( rgAppDataPath );

    if(szSubDir)
    {
        wcsncat( rgAppDataPath, L"\\"   , MAXSTRLEN(rgAppDataPath) - wcslen(rgAppDataPath) ); rgAppDataPath[MAXSTRLEN(rgAppDataPath)] = 0;
        wcsncat( rgAppDataPath, szSubDir, MAXSTRLEN(rgAppDataPath) - wcslen(rgAppDataPath) ); rgAppDataPath[MAXSTRLEN(rgAppDataPath)] = 0;

        MPC::RemoveTrailingBackslash( rgAppDataPath );
    }

    strPath = rgAppDataPath;
    hr      = S_OK;


    __MPC_FUNC_CLEANUP;

    //
    // Get the shell's allocator to free PIDLs
    //
    if(pidl != NULL)
    {
        LPMALLOC lpMalloc = NULL;

        if(SUCCEEDED(SHGetMalloc( &lpMalloc )) && lpMalloc != NULL)
        {
            lpMalloc->Free( pidl );
            lpMalloc->Release();
        }
    }

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::GetTemporaryFileName( /*[out]*/ MPC::wstring& szFile, /*[in]*/ LPCWSTR szBase, /*[in]*/ LPCWSTR szPrefix )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::GetTemporaryFileName");

    HRESULT hr;
    WCHAR   rgTmp [MAX_PATH+1];
    WCHAR   rgBase[MAX_PATH+1];


    if(szBase)
    {
        ::wcsncpy( rgBase, szBase, MAXSTRLEN(rgBase) ); rgBase[MAXSTRLEN(rgBase)] = 0;
    }
    else
    {
        __MPC_EXIT_IF_CALL_RETURNS_ZERO(hr, ::GetTempPathW( MAXSTRLEN(rgBase), rgBase ));
    }

    MPC::RemoveTrailingBackslash( rgBase );

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( rgBase, false )); // Make sure the directory exists.

    __MPC_EXIT_IF_CALL_RETURNS_ZERO(hr, ::GetTempFileNameW( rgBase, szPrefix ? szPrefix : L"MPC", 0, rgTmp ));

    szFile = rgTmp;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RemoveTemporaryFile( /*[in/out]*/ MPC::wstring& szFile )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RemoveTemporaryFile");

    HRESULT hr;

    if(szFile.size() > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DeleteFile( szFile ));

        szFile = L"";
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::SubstituteEnvVariables( /*[in/out]*/ MPC::wstring& szEnv )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::SubstituteEnvVariables" );

    HRESULT hr;
    WCHAR   rgTmp[BUFFER_TMP_SIZE];
    LPWSTR  szPtr = rgTmp;
    LPWSTR  szBuf = NULL;
    DWORD   dwSize;


    dwSize = ::ExpandEnvironmentStringsW( szEnv.c_str(), szPtr, MAXSTRLEN(rgTmp) );
    if(dwSize >= MAXSTRLEN(rgTmp))
    {
        __MPC_EXIT_IF_ALLOC_FAILS(hr, szBuf, new WCHAR[dwSize+2]);

        (void)::ExpandEnvironmentStringsW( szEnv.c_str(), szBuf, dwSize+1 );

        szPtr = szBuf;
    }

    szEnv = szPtr;
    hr    = S_OK;


    __MPC_FUNC_CLEANUP;

    delete [] szBuf;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

DATE MPC::GetSystemTime()
{
    SYSTEMTIME stNow;
    DATE       dDate;

    ::GetSystemTime( &stNow );

    ::SystemTimeToVariantTime( &stNow, &dDate );

    return dDate;
}

DATE MPC::GetLocalTime()
{
    SYSTEMTIME stNow;
    DATE       dDate;

    ::GetLocalTime( &stNow );

    ::SystemTimeToVariantTime( &stNow, &dDate );

    return dDate;
}

static DATE local_FixSubSecondTime( /*[in]*/ DATE dDate, /*[in]*/ bool fHighPrecision )
{
	double dCount;
	double dFreq;
	long   iCount;


	if(fHighPrecision)
	{
		LARGE_INTEGER liCount;
		LARGE_INTEGER liFreq;

		::QueryPerformanceCounter  ( &liCount ); dCount = (double)liCount.QuadPart;
		::QueryPerformanceFrequency( &liFreq  ); dFreq  = (double)liFreq .QuadPart;
	}
	else
	{
		dCount = ::GetTickCount();
		dFreq  = 1000;
	}

	if(dFreq)
	{
		dCount /= dFreq;
		iCount  = dCount;

		dDate += (dCount - iCount) / (24 * 60 * 60 * 1000.0);
	}

    return dDate;
}

DATE MPC::GetSystemTimeEx( /*[in]*/ bool fHighPrecision )
{
    return local_FixSubSecondTime( MPC::GetSystemTime(), fHighPrecision );
}

DATE MPC::GetLocalTimeEx( /*[in]*/ bool fHighPrecision )
{
    return local_FixSubSecondTime( MPC::GetLocalTime(), fHighPrecision );
}

DATE MPC::GetLastModifiedDate( /*[out]*/ const MPC::wstring& strFile )
{
    WIN32_FILE_ATTRIBUTE_DATA wfadInfo;
    SYSTEMTIME                sys;
    DATE                      dFile;


    if(::GetFileAttributesExW( strFile.c_str(), GetFileExInfoStandard, &wfadInfo ) == FALSE ||
       ::FileTimeToSystemTime( &wfadInfo.ftLastWriteTime             , &sys      ) == FALSE  )
    {
        return 0; // File doesn't exist.
    }

    ::SystemTimeToVariantTime( &sys, &dFile );

    return dFile;
}

HRESULT MPC::ConvertSizeUnit( /*[in] */ const MPC::wstring& szStr ,
                              /*[out]*/ DWORD&              dwRes )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertSizeUnit" );

    MPC::string::size_type iUnit = 0;
    int                    nMult = 1;


    // CODEWORK: no proper format checking...

    do
    {
        if((iUnit = szStr.find( L"KB" )) != MPC::string::npos) { nMult =      1024; break; }
        if((iUnit = szStr.find( L"MB" )) != MPC::string::npos) { nMult = 1024*1024; break; }

    } while(0);

    dwRes = nMult * _wtoi( szStr.c_str() );


    __MPC_FUNC_EXIT(S_OK);
}

HRESULT MPC::ConvertTimeUnit( /*[in] */ const MPC::wstring& szStr ,
                              /*[out]*/ DWORD&              dwRes )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertTimeUnit" );

    MPC::string::size_type iUnit = 0;
    int                    nMult = 1;


    // CODEWORK: no proper format checking...

    do
    {
        if((iUnit = szStr.find( L"m" )) != MPC::string::npos) { nMult =       60; break; }
        if((iUnit = szStr.find( L"h" )) != MPC::string::npos) { nMult =    60*60; break; }
        if((iUnit = szStr.find( L"d" )) != MPC::string::npos) { nMult = 24*60*60; break; }

    } while(0);

    dwRes = nMult * _wtoi( szStr.c_str() );


    __MPC_FUNC_EXIT(S_OK);
}

////////////////////////////////////////

HRESULT MPC::ConvertDateToString( /*[in] */ DATE          dDate  ,
                                  /*[out]*/ MPC::wstring& szDate ,
                                  /*[in] */ bool          fGMT   ,
                                  /*[in] */ bool          fCIM   ,
								  /*[in] */ LCID          lcid   )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertDateToString" );

    HRESULT hr;
    double  dTimeZone;


    if(fGMT)
    {
        TIME_ZONE_INFORMATION tzi;

        if(::GetTimeZoneInformation( &tzi ) == TIME_ZONE_ID_DAYLIGHT)
        {
            tzi.Bias += tzi.DaylightBias;
        }

        dTimeZone = (DATE)tzi.Bias / (24 * 60); // Convert BIAS from minutes to days.
    }
    else
    {
        dTimeZone = 0.0;
    }


    dDate += dTimeZone;


    if(fCIM)
    {
        SYSTEMTIME st;
        WCHAR      rgBuf[256];
        char       cTimeZone =         (dTimeZone > 0) ? '+' : '-';
        int        iTimeZone = (int)abs(dTimeZone    ) * 24 * 60;


        ::VariantTimeToSystemTime( dDate, &st );


        // supposedly the CIM format for dates is the following (grabbed from
        //  http://wmig/wbem/docs/cimdoc20.doc)
        //  yyyymmddhhmmss.mmmmmmsutc
        //   where
        //    yyyy is a 4 digit year
        //    mm is the month
        //    dd is the day
        //    hh is the hour (24-hour clock)
        //    mm is the minute
        //    ss is the second
        //    mmmmmm is the number of microseconds
        //    s is a "+" or "-", indicating the sign of the UTC (Universal
        //     Coordinated Time; for all intents and purposes the same as Greenwich
        //     Mean Time) correction field, or a ":".  In this case, the value is
        //     interpreted as a time interval, and yyyymm are interpreted as days.
        //    utc is the offset from UTC in minutes (using the sign indicated by s)
        //     It is ignored for a time interval.
        //
        //    For example, Monday, May 25, 1998, at 1:30:15 PM EST would be
        //     represented as 19980525133015.000000-300
        swprintf( rgBuf, L"%04d%02d%02d%02d%02d%02d.%06d%c%03d",
                  st.wYear               ,
                  st.wMonth              ,
                  st.wDay                ,
                  st.wHour               ,
                  st.wMinute             ,
                  st.wSecond             ,
                  st.wMilliseconds * 1000,
                  cTimeZone              ,
                  iTimeZone              );

        szDate = rgBuf;
    }
    else
    {
        CComVariant vValue;

		switch(lcid)
		{
		case  0: lcid = ::GetUserDefaultLCID();                                                   break;
		case -1: lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ), SORT_DEFAULT ); break;
		}

        vValue = dDate; vValue.vt = VT_DATE; // The assignment is not enough to set the DATE type.

		__MPC_EXIT_IF_METHOD_FAILS(hr, ::VariantChangeTypeEx( &vValue, &vValue, lcid, 0, VT_BSTR ));
		
        szDate = SAFEBSTR( vValue.bstrVal );
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::ConvertStringToDate( /*[in] */ const MPC::wstring& szDate ,
                                  /*[out]*/ DATE&               dDate  ,
                                  /*[in] */ bool                fGMT   ,
                                  /*[in] */ bool                fCIM   ,
								  /*[in] */ LCID                lcid   )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertStringToDate" );

    HRESULT     hr;
    double  dTimeZone;


    if(fGMT)
    {
        TIME_ZONE_INFORMATION tzi;

        if(::GetTimeZoneInformation( &tzi ) == TIME_ZONE_ID_DAYLIGHT)
        {
            tzi.Bias += tzi.DaylightBias;
        }

        dTimeZone = (DATE)tzi.Bias / (24 * 60); // Convert BIAS from minutes to days.
    }
    else
    {
        dTimeZone = 0.0;
    }


    if(fCIM)
    {
        SYSTEMTIME st;
        int        iYear;
        int        iMonth;
        int        iDay;
        int        iHour;
        int        iMinute;
        int        iSecond;
        int        iMicroseconds;
        wchar_t    cTimezone;
        int        iTimezone;

        if(swscanf( szDate.c_str(), L"%04d%02d%02d%02d%02d%02d.%06d%c%03d",
                    &iYear         ,
                    &iMonth        ,
                    &iDay          ,
                    &iHour         ,
                    &iMinute       ,
                    &iSecond       ,
                    &iMicroseconds ,
                    &cTimezone     ,
                    &iTimezone     ) != 9)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }


        st.wYear         = (WORD)(iYear               );
        st.wMonth        = (WORD)(iMonth              );
        st.wDay          = (WORD)(iDay                );
        st.wHour         = (WORD)(iHour               );
        st.wMinute       = (WORD)(iMinute             );
        st.wSecond       = (WORD)(iSecond             );
        st.wMilliseconds = (WORD)(iMicroseconds / 1000);

        ::SystemTimeToVariantTime( &st, &dDate );
    }
    else
    {
        CComVariant vValue = szDate.c_str();

		switch(lcid)
		{
		case  0: lcid = ::GetUserDefaultLCID();                                                   break;
		case -1: lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ), SORT_DEFAULT ); break;
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, ::VariantChangeTypeEx( &vValue, &vValue, lcid, 0, VT_DATE ));
		
        dDate = vValue.date;
    }

    dDate -= dTimeZone;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT MPC::ConvertStringToHex( /*[in] */ const CComBSTR& bstrText ,
                                 /*[out]*/       CComBSTR& bstrHex  )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertStringToHex" );

    HRESULT hr;
    int     iLen = bstrText.Length();

    if(iLen)
    {
        BSTR    bstrNew;
        LPCWSTR szIn;
        LPWSTR  szOut;

        __MPC_EXIT_IF_ALLOC_FAILS(hr, bstrNew, ::SysAllocStringLen( NULL, iLen*4 ));
        bstrHex.Attach( bstrNew );

        szIn  = bstrText;
        szOut = bstrHex;

        while(iLen > 0)
        {
            WCHAR c = szIn[0];

            szOut[0] = NumToHex( c >> 12 );
            szOut[1] = NumToHex( c >> 8  );
            szOut[2] = NumToHex( c >> 4  );
            szOut[3] = NumToHex( c       );

            iLen  -= 1;
            szIn  += 1;
            szOut += 4;
        }
    }
    else
    {
        bstrHex.Empty();
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::ConvertHexToString( /*[in] */ const CComBSTR& bstrHex  ,
                                 /*[out]*/       CComBSTR& bstrText )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertHexToString" );

    HRESULT hr;
    int     iLen = bstrHex.Length();

    if(iLen)
    {
        BSTR    bstrNew;
        LPCWSTR szIn;
        LPWSTR  szOut;

        iLen /= 4;

        __MPC_EXIT_IF_ALLOC_FAILS(hr, bstrNew, ::SysAllocStringLen( NULL, iLen ));
        bstrText.Attach( bstrNew );

        szIn  = bstrHex;
        szOut = bstrText;

        while(iLen > 0)
        {
            szOut[0] = (HexToNum( szIn[0] ) << 12) |
                       (HexToNum( szIn[1] ) <<  8) |
                       (HexToNum( szIn[2] ) <<  4) |
                        HexToNum( szIn[3] );

            iLen  -= 1;
            szIn  += 4;
            szOut += 1;
        }
    }
    else
    {
        bstrText.Empty();
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT MPC::ConvertHGlobalToHex( /*[in]*/  HGLOBAL   hg           ,
                                  /*[out]*/ CComBSTR& bstrHex      ,
                                  /*[in ]*/ bool      fNullAllowed ,
                                  /*[in ]*/ DWORD*    pdwCount /* = NULL */ )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertHGlobalToHex" );

    HRESULT hr;
    int     iLen = hg ? (pdwCount ? (int)*pdwCount : ::GlobalSize( hg )) : 0;

    if(iLen)
    {
        BSTR   bstrNew;
        BYTE*  pIn;
        LPWSTR szOut;

        __MPC_EXIT_IF_ALLOC_FAILS(hr, bstrNew, ::SysAllocStringLen( NULL, iLen*2 ));
        bstrHex.Attach( bstrNew );

        pIn   = (BYTE*)::GlobalLock( hg );
        szOut = bstrHex;

        while(iLen > 0)
        {
            BYTE c = pIn[0];

            szOut[0] = NumToHex( c >> 4 );
            szOut[1] = NumToHex( c      );

            iLen  -= 1;
            pIn   += 1;
            szOut += 2;
        }

        ::GlobalUnlock( hg );
    }
    else
    {
        bstrHex.Empty();

        if(fNullAllowed == false) __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::ConvertHexToHGlobal( /*[in] */ const CComBSTR& bstrText     ,
                                  /*[out]*/ HGLOBAL&        hg           ,
                                  /*[in ]*/ bool            fNullAllowed )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertHexToHGlobal" );

    HRESULT hr;
    int     iLen = bstrText.Length();

    if(iLen)
    {
        LPCWSTR szIn;
        BYTE*   pOut;

        iLen /= 2;

        __MPC_EXIT_IF_ALLOC_FAILS(hr, hg, ::GlobalAlloc( GMEM_FIXED, iLen ));

        szIn =        bstrText;
        pOut = (BYTE*)hg;

        while(iLen > 0)
        {
            pOut[0] = (HexToNum( szIn[0] ) << 4) |
                       HexToNum( szIn[1] );

            iLen -= 1;
            szIn += 2;
            pOut += 1;
        }
    }
    else
    {
        hg = NULL;

        if(fNullAllowed == false) __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT MPC::ConvertBufferToVariant( /*[in] */ const BYTE*  pBuf  ,
                                     /*[in] */ DWORD        dwLen ,
                                     /*[out]*/ CComVariant& v     )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertBufferToVariant" );

    HRESULT hr;


    v.Clear();

    if(pBuf && dwLen)
    {
        BYTE* rgArrayData;

        v.vt = VT_ARRAY | VT_UI1;

        __MPC_EXIT_IF_ALLOC_FAILS(hr, v.parray, ::SafeArrayCreateVector( VT_UI1, 0, dwLen ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayAccessData( v.parray, (LPVOID*)&rgArrayData ));

        ::CopyMemory( rgArrayData, pBuf, dwLen );

        ::SafeArrayUnaccessData( v.parray );
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::ConvertVariantToBuffer( /*[in] */ const VARIANT* v     ,
                                     /*[out]*/ BYTE*&         pBuf  ,
                                     /*[out]*/ DWORD&         dwLen )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertVariantToBuffer" );

    HRESULT hr;
    BYTE*   pSrc;


    if(pBuf) delete [] pBuf;

    pBuf  = NULL;
    dwLen = 0;

    switch(v->vt)
    {
    case VT_ARRAY | VT_UI1:
        {
            long lBound; ::SafeArrayGetLBound( v->parray, 1, &lBound );
            long uBound; ::SafeArrayGetUBound( v->parray, 1, &uBound );

            __MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayAccessData( v->parray, (LPVOID*)&pSrc ));

            dwLen = uBound - lBound + 1;
        }
        break;

    case VT_I1: case VT_UI1:             pSrc  = (BYTE*)&v->bVal ; dwLen = 1; break;
    case VT_I2: case VT_UI2:             pSrc  = (BYTE*)&v->iVal ; dwLen = 2; break;
    case VT_I4: case VT_UI4: case VT_R4: pSrc  = (BYTE*)&v->lVal ; dwLen = 4; break;
    case VT_I8: case VT_UI8: case VT_R8: pSrc  = (BYTE*)&v->llVal; dwLen = 8; break;

    default:
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    if(dwLen)
    {
        __MPC_EXIT_IF_ALLOC_FAILS(hr, pBuf, new BYTE[dwLen]);

        ::CopyMemory( pBuf, pSrc, dwLen );
    }

    if(v->vt == (VT_ARRAY | VT_UI1))
    {
        ::SafeArrayUnaccessData( v->parray );
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT MPC::ConvertIStreamToVariant( /*[in]*/ IStream* stream, /*[out]*/ CComVariant& v )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertIStreamToVariant" );

    HRESULT          hr;
    CComPtr<IStream> stream2;
    STATSTG          stg; ::ZeroMemory( &stg, sizeof(stg) );
    BYTE*            pBuf = NULL;
    DWORD            dwLen;
    ULONG            lRead;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(stream);
    __MPC_PARAMCHECK_END();


    v.Clear();


    //
    // If Stat fails, it can be that the size is unknown, so let's make a copy to another stream and retry.
    //
    if(FAILED(stream->Stat( &stg, STATFLAG_NONAME )))
    {

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( NULL, TRUE, &stream2 ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( stream, stream2 ));

        stream = stream2;
    }

    //
    // Rewind to the beginning.
    //
    {
        LARGE_INTEGER li = { 0, 0 };

        __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Seek( li, STREAM_SEEK_SET, NULL ));
    }

    //
    // Get the size of the stream.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Stat( &stg, STATFLAG_NONAME ));


    //
    // Sorry, we don't handle streams longer than 4GB!!
    //
    if(stg.cbSize.u.HighPart)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
    }

    //
    // Allocate buffer for the whole stream.
    //
    dwLen = stg.cbSize.u.LowPart;
    __MPC_EXIT_IF_ALLOC_FAILS(hr, pBuf, new BYTE[dwLen]);

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Read( pBuf, dwLen, &lRead ));
    if(dwLen != lRead)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_HANDLE_EOF);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertBufferToVariant( pBuf, dwLen, v ));


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(pBuf) delete [] pBuf;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::ConvertVariantToIStream( /*[in ]*/ const VARIANT*  v       ,
                                      /*[out]*/ IStream*       *pStream )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertVariantToBuffer" );

    HRESULT          hr;
    CComPtr<IStream> stream;
    BYTE*            pBuf = NULL;
    DWORD            dwLen;
    ULONG            lWritten;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(v);
        __MPC_PARAMCHECK_POINTER_AND_SET(pStream,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, ConvertVariantToBuffer( v, pBuf, dwLen ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( NULL, TRUE, &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Write( pBuf, dwLen, &lWritten ));
    if(dwLen != lWritten)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_HANDLE_DISK_FULL );
    }

    //
    // Rewind to the beginning.
    //
    {
        LARGE_INTEGER li = { 0, 0 };

        __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Seek( li, STREAM_SEEK_SET, NULL ));
    }

    *pStream = stream.Detach();
    hr       = S_OK;


    __MPC_FUNC_CLEANUP;

    if(pBuf) delete [] pBuf;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::ConvertListToSafeArray( /*[in]*/ const MPC::WStringList& lst, /*[out]*/ VARIANT& v, /*[in]*/ VARTYPE vt )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertListToSafeArray" );

    HRESULT               hr;
	LPVOID                pData;
    MPC::WStringIterConst it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ::VariantClear( &v ));

	if(vt != VT_VARIANT &&
	   vt != VT_BSTR     )
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
	}

    v.vt = VT_ARRAY | vt; __MPC_EXIT_IF_ALLOC_FAILS(hr, v.parray, ::SafeArrayCreateVector( vt, 0, lst.size() ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayAccessData( v.parray, &pData ));

    hr = S_OK;

	{
		BSTR*    rgArrayData1 = (BSTR   *)pData;
		VARIANT* rgArrayData2 = (VARIANT*)pData;

		for(it = lst.begin(); it != lst.end(); it++)
		{
			BSTR bstr;

			if((bstr = ::SysAllocString( it->c_str() )) == NULL)
			{
				hr = E_OUTOFMEMORY;
				break;
			}

			if(vt == VT_BSTR)
			{
				*rgArrayData1++ = bstr;
			}
			else
			{
				rgArrayData2->vt      = VT_BSTR;
				rgArrayData2->bstrVal = bstr;
				rgArrayData2++;
			}
		}
	}

    ::SafeArrayUnaccessData( v.parray );


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::ConvertSafeArrayToList( /*[in]*/ const VARIANT& v, /*[out]*/ MPC::WStringList& lst )
{
	__MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertSafeArrayToList" );

    HRESULT hr;
	LPVOID  pData;
    long    lBound;
    long    uBound;
    long    l;


	if(v.vt != (VT_ARRAY | VT_BSTR   ) &&
	   v.vt != (VT_ARRAY | VT_VARIANT)  )
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
	}

    ::SafeArrayGetLBound( v.parray, 1, &lBound );
    ::SafeArrayGetUBound( v.parray, 1, &uBound );

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayAccessData( v.parray, &pData ));

	{
		BSTR*    rgArrayData1 = (BSTR   *)pData;
		VARIANT* rgArrayData2 = (VARIANT*)pData;

		for(l=lBound; l<=uBound; l++)
		{
			BSTR        bstr = NULL;
			CComVariant v2;

			if(v.vt == (VT_ARRAY | VT_BSTR))
			{
				bstr = *rgArrayData1++;
			}
			else
			{
				v2 = *rgArrayData2++;

				if(SUCCEEDED(v2.ChangeType( VT_BSTR )))
				{
					bstr = v2.bstrVal;
				}
			}

			lst.push_back( SAFEBSTR( bstr ) );
		}
	}

    ::SafeArrayUnaccessData( v.parray );

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

static void Parse_SkipWhite( WCHAR*& szStr )
{
    while(iswspace( szStr[0] )) szStr++;
}

static void Parse_GetQuoted( WCHAR*& szSrc               ,
                             WCHAR*  szDst               ,
                             WCHAR   quote               ,
                             bool    fBackslashForEscape )
{
    WCHAR c;

    while((c = *++szSrc))
    {
        if(c == quote) { szSrc++; break; }

        if(fBackslashForEscape && c == '\\' && szSrc[1]) c = *++szSrc;

        *szDst++ = c;
    }

    *szDst = 0;
}

static void Parse_GetNonBlank( WCHAR*& szSrc ,
                               WCHAR*  szDst )
{
    WCHAR c;

    szSrc--;

    while((c = *++szSrc))
    {
        if(iswspace( c )) break;

        *szDst++ = c;
    }

    *szDst = 0;
}

HRESULT MPC::CommandLine_Parse( /*[out]*/ int&      argc                ,
                                /*[out]*/ LPCWSTR*& argv                ,
                                /*[in] */ LPWSTR    lpCmdLine           ,
                                /*[in] */ bool      fBackslashForEscape )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CommandLine_Parse" );

    HRESULT hr;
    LPWSTR  szArgument = NULL;
    int     iPass;


    argc = 0;
    argv = NULL;


    //
    // If no command line is supplied, use the one from the system.
    //
    if(lpCmdLine == NULL)
    {
        lpCmdLine = ::GetCommandLineW();
    }

    //
    // Nothing to parse, exit...
    //
    if(lpCmdLine == NULL)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    //
    // Allocate a temporary buffer.
    //
    __MPC_EXIT_IF_ALLOC_FAILS(hr, szArgument, new WCHAR[wcslen( lpCmdLine ) + 1]);

    //
    // Two passes, one to count the arguments, the other to allocate them.
    //
    for(iPass=0; iPass < 2; iPass++)
    {
        LPWSTR szSrc = lpCmdLine;
        int    i     = 0;

        Parse_SkipWhite( szSrc );
        while(szSrc[0])
        {
            if(szSrc[0] == '"' ||
               szSrc[0] == '\'' )
            {
                Parse_GetQuoted( szSrc, szArgument, szSrc[0], fBackslashForEscape );
            }
            else
            {
                Parse_GetNonBlank( szSrc, szArgument );
            }

            if(argv)
            {
                LPWSTR szNewParam;

                __MPC_EXIT_IF_ALLOC_FAILS(hr, szNewParam, _wcsdup( szArgument ));

                argv[i] = szNewParam;
            }

            i++;

            Parse_SkipWhite( szSrc );
        }

        if(iPass == 0)
        {
            argc = i;

            __MPC_EXIT_IF_ALLOC_FAILS(hr, argv, new LPCWSTR[argc]);
            for(i=0; i<argc; i++)
            {
                argv[i] = NULL;
            }
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(FAILED(hr))
    {
        CommandLine_Free( argc, argv );
    }

    delete [] szArgument;

    __MPC_FUNC_EXIT(hr);
}

void MPC::CommandLine_Free( /*[in ]*/ int&      argc ,
                            /*[in ]*/ LPCWSTR*& argv )
{
    if(argv)
    {
        for(int i=0; i<argc; i++)
        {
            free( (void*)argv[i] );
        }

        delete [] argv;

        argv = NULL;
    }

    argc = 0;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::ConvertStringToBitField( /*[in] */ LPCWSTR                 szText     ,
                                      /*[out]*/ DWORD&                  dwBitField ,
                                      /*[in] */ const StringToBitField* pLookup    ,
                                      /*[in] */ bool                    fUseTilde  )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertStringToBitField" );

    HRESULT hr;
    DWORD   dwVal = 0;


    if(szText && pLookup)
    {
        std::vector<MPC::wstring>           vec;
        std::vector<MPC::wstring>::iterator it;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::SplitAtDelimiter( vec, szText, L" ,", false, true ));

        for(it=vec.begin(); it!=vec.end(); it++)
        {
            LPCWSTR szToken = it->c_str();
            int     iNum    = 0;

            if(!_wcsnicmp( L"0x", szToken, 2 ) && swscanf( &szToken[2], L"%x", &iNum ) == 1)
            {
                dwVal |= iNum;
            }
            else
            {
                const StringToBitField* pPtr     = pLookup;
                bool                    fReverse = false;

                if(fUseTilde && szToken[0] == '~')
                {
                    fReverse = true;
                    szToken++;
                }

                while(pPtr->szName)
                {
                    if(!_wcsicmp( pPtr->szName, szToken ))
                    {
                        DWORD dwMask      =           pPtr->dwMask;
                        DWORD dwSet       =           pPtr->dwSet;
                        DWORD dwReset     =           pPtr->dwReset;
                        DWORD dwSelected  = dwVal &         dwMask;
                        DWORD dwRemainder = dwVal & (~      dwMask);

                        if(fReverse)
                        {
                            dwSelected &= ~dwSet;
                        }
                        else
                        {
                            dwSelected &= ~dwReset;
                            dwSelected |=  dwSet;
                        }

                        dwVal = (dwSelected & dwMask) | dwRemainder;
                        break;
                    }

                    pPtr++;
                }
            }
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    dwBitField = dwVal;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::ConvertBitFieldToString( /*[in] */ DWORD                   dwBitField ,
                                      /*[out]*/ MPC::wstring&           szText     ,
                                      /*[in] */ const StringToBitField* pLookup    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertBitFieldToString" );

    HRESULT hr;
    DWORD   dwVal = 0;

    szText = L"";

    if(pLookup)
    {
        while(pLookup->szName)
        {
            DWORD dwMask  = pLookup->dwMask;
            DWORD dwSet   = pLookup->dwSet;
            DWORD dwReset = pLookup->dwReset;

            if((dwBitField & (dwMask & dwReset)) == dwSet)
            {
                if(szText.size()) szText += L" ";
                szText += pLookup->szName;

                dwBitField = (dwBitField & ~dwMask) | ((dwBitField & ~dwReset) & dwMask);
            }

            pLookup++;
        }
    }

    if(dwBitField)
    {
        WCHAR rgBuf[64];

        swprintf( rgBuf, L"0x%x", dwBitField );

        if(szText.size()) szText += L" ";
        szText += rgBuf;
    }

    hr = S_OK;


    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

//
// This algorithm is not a very efficient one, O(N * M), but it's ok as long as "delims" is short (M small).
//
template <class E> static HRESULT InnerSplitAtDelimiter( std::vector< std::basic_stringNR<E> >& vec                 ,
                                                         const E*                               str                 ,
                                                         const E*                               delims              ,
                                                         bool                                   fDelimIsAString     ,
                                                         bool                                   fSkipAdjacentDelims )
{
    std::basic_stringNR<E>            szText  ( str    );
    std::basic_stringNR<E>            szDelims( delims );
    std::basic_stringNR<E>::size_type iPos       = 0;
    std::basic_stringNR<E>::size_type iStart     = 0;
    std::basic_stringNR<E>::size_type iDelimsLen = szDelims.length();
    bool                              fSkip      = false;

    vec.clear();

    if(fDelimIsAString)
    {
        while(1)
        {
            iPos = szText.find( szDelims, iStart );
            if(iPos == std::basic_stringNR<E>::npos)
            {
                vec.push_back( &szText[iStart] );
                break;
            }
            else
            {
                if(fSkip && iPos == iStart)
                {
                    ;
                }
                else
                {
                    fSkip = fSkipAdjacentDelims;

                    vec.push_back( std::basic_stringNR<E>( &szText[iStart], &szText[iPos] ) );
                }

                iStart = iPos + iDelimsLen;
            }
        }
    }
    else
    {
        std::basic_stringNR<E>::size_type iTextEnd = szText.length();

        while(iPos < iTextEnd)
        {
            if(szDelims.find( szText[iPos] ) != std::basic_stringNR<E>::npos)
            {
                if(fSkip == false)
                {
                    fSkip = fSkipAdjacentDelims;

                    vec.push_back( std::basic_stringNR<E>( &szText[iStart], &szText[iPos] ) );
                }

                iStart = iPos + 1;
            }
            else
            {
                if(fSkip)
                {
                    iStart = iPos;

                    fSkip = false;
                }
            }

            iPos++;
        }

        vec.push_back( std::basic_stringNR<E>( &szText[iStart] ) );
    }

    //
    // In case of single string, don't return anything.
    //
    if(vec.size() == 1 && vec[0].empty())
    {
        vec.clear();
    }

    return S_OK;
}

HRESULT MPC::SplitAtDelimiter( StringVector& vec                 ,
                               LPCSTR        str                 ,
                               LPCSTR        delims              ,
                               bool          fDelimIsAString     ,
                               bool          fSkipAdjacentDelims )
{
    return InnerSplitAtDelimiter( vec, str, delims, fDelimIsAString, fSkipAdjacentDelims );
}

HRESULT MPC::SplitAtDelimiter( WStringVector& vec                 ,
                               LPCWSTR        str                 ,
                               LPCWSTR        delims              ,
                               bool           fDelimIsAString     ,
                               bool           fSkipAdjacentDelims )
{
    return InnerSplitAtDelimiter( vec, str, delims, fDelimIsAString, fSkipAdjacentDelims );
}

////////////////////////////////////////

template <class E> static HRESULT InnerJoinWithDelimiter( const std::vector< std::basic_stringNR<E> >& vec    ,
                                                          std::basic_stringNR<E>&                      str    ,
                                                          const E*                                     delims )
{
    int i;

    for(i=0; i<vec.size(); i++)
    {
        if(i) str += delims;

        str += vec[i];
    }

    return S_OK;
}

HRESULT MPC::JoinWithDelimiter( const StringVector& vec    ,
                                MPC::string&        str    ,
                                LPCSTR              delims )
{
    return InnerJoinWithDelimiter( vec, str, delims );
}

HRESULT MPC::JoinWithDelimiter( const WStringVector& vec    ,
                                MPC::wstring&        str    ,
                                LPCWSTR              delims )
{
    return InnerJoinWithDelimiter( vec, str, delims );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Function Name : MPC::MakeDir
//
// Parameters    : MPC::wstring& szStr : path to a directory or a file.
//
// Return        : HRESULT
//
// Synopsis      : Given a path in the form '[<dir>\]*\[<file>]',
//                 it creates all the needed directories.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPC::MakeDir( /*[in]*/ const MPC::wstring& strPath, /*[in]*/ bool fCreateParent )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::MakeDir");

    HRESULT                 hr;
    MPC::wstring            szParent;
    BOOL                    fRes;
    DWORD                   dwRes;


    if(fCreateParent)
    {
        MPC::wstring::size_type iPos = strPath.rfind( '\\' );

        if(iPos == strPath.npos)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        szParent = strPath.substr( 0, iPos );
    }
    else
    {
        szParent = strPath;
    }

    //
    // Try to create parent directory...
    //
    fRes  = ::CreateDirectoryW( szParent.c_str(), NULL );
    dwRes = ::GetLastError();

    if(fRes == TRUE || dwRes == ERROR_ALREADY_EXISTS)
    {
        //
        // Success, exit.
        //
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    //
    // If the error is not PATH_NOT_FOUND, exit.
    //
    if(dwRes != ERROR_PATH_NOT_FOUND)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes );
    }


    //
    // Recursively build the parent directories.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MakeDir( szParent, true ) );


    //
    // Try again to create parent directory.
    //
    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CreateDirectoryW( szParent.c_str(), NULL ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Function Name : MPC::GetDiskSpace
//
// Parameters    : MPC::wstring&   szFile  : path to a directory or a file.
//                 ULARGE_INTEGER& liFree  : number of bytes free on that disk.
//                 ULARGE_INTEGER& liTotal : total number of bytes on that disk.
//
// Return        : HRESULT
//
// Synopsis      : Given a path, it calculates the total and available disk space.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPC::GetDiskSpace( /*[in]*/  const MPC::wstring& szFile  ,
                           /*[out]*/ ULARGE_INTEGER&     liFree  ,
                           /*[out]*/ ULARGE_INTEGER&     liTotal )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::GetDiskSpace");

    HRESULT                 hr;
    MPC::wstring            szParent;
    MPC::wstring::size_type iPos;
    DWORD                   dwSectorsPerCluster;
    DWORD                   dwBytesPerSector;
    DWORD                   dwNumberOfFreeClusters;
    DWORD                   dwTotalNumberOfClusters;


    //
    // Initialize the Parent variable.
    //
    szParent = szFile;


    //
    // Normal <DRIVE>:\... format?
    //
    iPos = szFile.find( L":\\" );
    if(iPos != szFile.npos)
    {
        szParent = szFile.substr( 0, iPos+2 );
    }
    else
    {
        //
        // If the path a UNC?
        //
        iPos = szFile.find( L"\\\\" );
        if(iPos != szFile.npos && iPos == 0)
        {
            //
            // Find slash after server name.
            //
            iPos = szFile.find( L"\\", 2 );
            if(iPos != szFile.npos)
            {
                //
                // Is a slash present after the share name?
                //
                iPos = szFile.find( L"\\", iPos+1 );
                if(iPos != szFile.npos)
                {
                    szParent = szFile.substr( 0, iPos+1 );
                }
                else
                {
                    szParent = szFile;
                    szParent.append( L"\\" ); // Share names must end with a trailing slash.
                }
            }
        }
    }

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetDiskFreeSpaceW( szParent.c_str()         ,
                                                              &dwSectorsPerCluster     ,
                                                              &dwBytesPerSector        ,
                                                              &dwNumberOfFreeClusters  ,
                                                              &dwTotalNumberOfClusters ));

    liFree .QuadPart = (ULONGLONG)(dwBytesPerSector * dwSectorsPerCluster) * (ULONGLONG)dwNumberOfFreeClusters;
    liTotal.QuadPart = (ULONGLONG)(dwBytesPerSector * dwSectorsPerCluster) * (ULONGLONG)dwTotalNumberOfClusters;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::FailOnLowDiskSpace( /*[in]*/ LPCWSTR szFile, /*[in]*/ DWORD dwLowLevel )
{
    MPC::wstring   szExpandedFile( szFile ); MPC::SubstituteEnvVariables( szExpandedFile );
    ULARGE_INTEGER liFree;
    ULARGE_INTEGER liTotal;


    if(SUCCEEDED(MPC::GetDiskSpace( szExpandedFile, liFree, liTotal )))
    {
        if(liFree.HighPart > 0          ||
           liFree.LowPart  > dwLowLevel  )
        {
            return S_OK;
        }
    }

    return HRESULT_FROM_WIN32(ERROR_DISK_FULL);
}

HRESULT MPC::FailOnLowMemory( /*[in]*/ DWORD dwLowLevel )
{
    MEMORYSTATUSEX ms;

    ::ZeroMemory( &ms, sizeof(ms) ); ms.dwLength = sizeof(ms);

    if(::GlobalMemoryStatusEx( &ms ))
    {
        if(ms.ullAvailVirtual > dwLowLevel)
        {
            return S_OK;
        }
    }

    return E_OUTOFMEMORY;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::ExecuteCommand( /*[in]*/ const MPC::wstring& szCommandLine )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ExecuteCommand" );

    HRESULT             hr;
    PROCESS_INFORMATION piProcessInformation;
    STARTUPINFOW        siStartupInfo;
    DWORD               dwExitCode;


    ::ZeroMemory( (PVOID)&piProcessInformation, sizeof( piProcessInformation ) );
    ::ZeroMemory( (PVOID)&siStartupInfo       , sizeof( siStartupInfo        ) ); siStartupInfo.cb = sizeof( siStartupInfo );


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CreateProcessW(         NULL,
                                                           (LPWSTR)szCommandLine.c_str(),
                                                                   NULL,
                                                                   NULL,
                                                                   FALSE,
                                                                   DETACHED_PROCESS,
                                                                   NULL,
                                                                   NULL,
                                                                  &siStartupInfo,
                                                                  &piProcessInformation ));

    MPC::WaitForSingleObject( piProcessInformation.hProcess, INFINITE );

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetExitCodeProcess( piProcessInformation.hProcess, &dwExitCode ));

    if(dwExitCode != 0)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwExitCode );
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(piProcessInformation.hProcess) ::CloseHandle( piProcessInformation.hProcess );
    if(piProcessInformation.hThread ) ::CloseHandle( piProcessInformation.hThread  );

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::GetBSTR( /*[in] */ LPCWSTR  bstr    ,
                      /*[out]*/ BSTR    *pVal    ,
                      /*[in] */ bool     fNullOk )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::GetBSTR" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
        if(fNullOk == false) __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstr);
    __MPC_PARAMCHECK_END();


    *pVal = ::SysAllocString( bstr );
    if(*pVal == NULL && bstr)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::PutBSTR( /*[out]*/ CComBSTR& bstr    ,
                      /*[in ]*/ LPCWSTR   newVal  ,
                      /*[in] */ bool      fNullOk )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::PutBSTR" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        if(fNullOk == false) __MPC_PARAMCHECK_STRING_NOT_EMPTY(newVal);
    __MPC_PARAMCHECK_END();


    bstr = newVal;
    if(!bstr && newVal != NULL)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::PutBSTR( /*[out]*/ CComBSTR& bstr    ,
                      /*[in ]*/ VARIANT*  newVal  ,
                      /*[in] */ bool      fNullOk )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::PutBSTR" );

    HRESULT     hr;
    CComVariant v;
    bool        fEmpty;


    if(newVal)
    {
        if(newVal->vt != VT_BSTR)
        {
            v.ChangeType( VT_BSTR, newVal );

            newVal = &v;
        }
    }

    if(newVal             == NULL    || // Null pointer.
       newVal->vt         != VT_BSTR || // Not a string.
       newVal->bstrVal    == NULL    || // Missing string.
       newVal->bstrVal[0] == 0        ) // Empty string.
    {
        if(fNullOk == false)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
        }

        fEmpty = true;
    }
    else
    {
        fEmpty = false;
    }


    if(fEmpty)
    {
        bstr.Empty();
    }
    else
    {
        bstr = newVal->bstrVal;
        if(!bstr)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

bool MPC::NocaseLess::operator()( /*[in]*/ const MPC::string& szX, /*[in]*/ const MPC::string& szY ) const
{
    return _stricmp( szX.c_str(), szY.c_str() ) < 0;
}

bool MPC::NocaseLess::operator()( /*[in]*/ const MPC::wstring& szX, /*[in]*/ const MPC::wstring& szY ) const
{
    return _wcsicmp( szX.c_str(), szY.c_str() ) < 0;
}

bool MPC::NocaseLess::operator()( /*[in]*/ const BSTR bstrX, /*[in]*/ const BSTR bstrY ) const
{
    return MPC::StrICmp( bstrX, bstrY ) < 0;
}

////////////////////////////////////////

bool MPC::NocaseCompare::operator()( /*[in]*/ const MPC::string& szX, /*[in]*/ const MPC::string& szY ) const
{
    return _stricmp( szX.c_str(), szY.c_str() ) == 0;
}

bool MPC::NocaseCompare::operator()( /*[in]*/ const MPC::wstring& szX, /*[in]*/ const MPC::wstring& szY ) const
{
    return _wcsicmp( szX.c_str(), szY.c_str() ) == 0;
}

bool MPC::NocaseCompare::operator()( /*[in]*/ const BSTR bstrX, /*[in]*/ const BSTR bstrY ) const
{
    return MPC::StrICmp( bstrX, bstrY ) == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_msits_i.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_MSITS.cpp

Abstract:
    This file contains the implementation of the helper class for accessing files
	inside CHMs.

Revision History:
    Davide Massarenti   (Dmassare)  12/17/99
        created

******************************************************************************/

#include "stdafx.h"

#include <initguid.h>

#include <ITSS\msitstg.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_filesystemobject.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_FileSystemObject.cpp

Abstract:
    This file contains the implementation of the Registry wrapper.

Revision History:
    Davide Massarenti   (Dmassare)  04/28/99
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::CopyFile( /*[in]*/ LPCWSTR szFileSrc ,
                       /*[in]*/ LPCWSTR szFileDst ,
                       /*[in]*/ bool    fForce    ,
                       /*[in]*/ bool    fDelayed  )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::CopyFile" );

    HRESULT hr;


    if(fForce)
    {
        (void)::SetFileAttributesW( szFileDst, FILE_ATTRIBUTE_NORMAL );
    }

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CopyFileW( szFileSrc, szFileDst, (fForce ? FALSE : TRUE) ));


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::CopyFile( /*[in]*/ const MPC::wstring& strFileSrc ,
                       /*[in]*/ const MPC::wstring& strFileDst ,
                       /*[in]*/ bool                fForce     ,
                       /*[in]*/ bool                fDelayed   )
{
    return MPC::CopyFile( strFileSrc.c_str(), strFileDst.c_str(), fForce, fDelayed );
}

////////////////////

HRESULT MPC::MoveFile( /*[in]*/ LPCWSTR szFileSrc ,
                       /*[in]*/ LPCWSTR szFileDst ,
                       /*[in]*/ bool    fForce    ,
                       /*[in]*/ bool    fDelayed  )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::MoveFile" );

    HRESULT hr;


    if(fForce)
    {
        (void)::SetFileAttributesW( szFileDst, FILE_ATTRIBUTE_NORMAL );
    }


    if(::MoveFileExW( szFileSrc, szFileDst, MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING ) == FALSE)
    {
        DWORD dwRes = ::GetLastError();
        DWORD dwMode;

        if(fForce == false || dwRes != ERROR_ALREADY_EXISTS)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes );
        }

        //
        // Delete the file and retry.
        //
        ::DeleteFileW( szFileDst );

        dwMode = (fDelayed ? MOVEFILE_DELAY_UNTIL_REBOOT : MOVEFILE_COPY_ALLOWED) | MOVEFILE_REPLACE_EXISTING;

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::MoveFileExW( szFileSrc, szFileDst, dwMode ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::MoveFile( /*[in]*/ const MPC::wstring& strFileSrc ,
                       /*[in]*/ const MPC::wstring& strFileDst ,
                       /*[in]*/ bool                fForce     ,
                       /*[in]*/ bool                fDelayed   )
{
    return MPC::MoveFile( strFileSrc.c_str(), strFileDst.c_str(), fForce, fDelayed );
}

////////////////////

HRESULT MPC::DeleteFile( /*[in]*/ LPCWSTR szFile   ,
                         /*[in]*/ bool    fForce   ,
                         /*[in]*/ bool    fDelayed )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::DeleteFile" );

    HRESULT hr;


    if(fForce)
    {
        (void)::SetFileAttributesW( szFile, FILE_ATTRIBUTE_NORMAL );
    }

    if(::DeleteFileW( szFile ) == FALSE)
    {
        DWORD dwRes = ::GetLastError();

        if(dwRes != ERROR_FILE_NOT_FOUND &&
           dwRes != ERROR_PATH_NOT_FOUND  )
        {
            if(fDelayed)
            {
                __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::MoveFileExW( szFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT ));
            }
            else
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
            }
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::DeleteFile( /*[in]*/ const MPC::wstring& strFile  ,
                         /*[in]*/ bool                fForce   ,
                         /*[in]*/ bool                fDelayed )
{
    return MPC::DeleteFile( strFile.c_str(), fForce, fDelayed );
}

////////////////////////////////////////////////////////////////////////////////

MPC::FileSystemObject::FileSystemObject( /*[in]*/ LPCWSTR                 lpszPath  ,
                                         /*[in]*/ const FileSystemObject* fsoParent )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::FileSystemObject" );


    Init( lpszPath, fsoParent );
}

MPC::FileSystemObject::FileSystemObject( /*[in]*/ const WIN32_FIND_DATAW& wfdInfo   ,
                                         /*[in]*/ const FileSystemObject* fsoParent )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::FileSystemObject" );


    Init( wfdInfo.cFileName[0] ? wfdInfo.cFileName : NULL, fsoParent );

    m_wfadInfo.dwFileAttributes = wfdInfo.dwFileAttributes;
    m_wfadInfo.ftCreationTime   = wfdInfo.ftCreationTime  ;
    m_wfadInfo.ftLastAccessTime = wfdInfo.ftLastAccessTime;
    m_wfadInfo.ftLastWriteTime  = wfdInfo.ftLastWriteTime ;
    m_wfadInfo.nFileSizeHigh    = wfdInfo.nFileSizeHigh   ;
    m_wfadInfo.nFileSizeLow     = wfdInfo.nFileSizeLow    ;

    m_fLoaded = true;
}

MPC::FileSystemObject::FileSystemObject( /*[in]*/ const FileSystemObject& fso )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::FileSystemObject" );

    Init( NULL, NULL );

    *this = fso;
}

MPC::FileSystemObject::~FileSystemObject()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::~FileSystemObject" );

    Clean();
}

void MPC::FileSystemObject::Clean()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::Clean" );

                                                      // MPC::wstring              m_strPath;
    ::memset( &m_wfadInfo, 0, sizeof( m_wfadInfo ) ); // WIN32_FILE_ATTRIBUTE_DATA m_wfadInfo;
                                                      // List                      m_lstChilds;
    m_fLoaded       = false;                          // bool                      m_fLoaded;
    m_fScanned      = false;                          // bool                      m_fScanned;
    m_fScanned_Deep = false;                          // bool                      m_fScanned_Deep;

    MPC::CallDestructorForAll( m_lstChilds );
}

void MPC::FileSystemObject::Init( /*[in]*/ LPCWSTR                 lpszPath  ,
                                  /*[in]*/ const FileSystemObject* fsoParent )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::Init" );

    LPCWSTR lpszEnd;


    Clean();


    //
    // Remove any trailing slashes.
    //
    SANITIZEWSTR(lpszPath);
    lpszEnd = lpszPath + wcslen( lpszPath );

    while(lpszEnd > lpszPath && (lpszEnd[-1] == '\\' || lpszEnd[-1] == '/')) lpszEnd--;

    if(fsoParent)
    {
        (void)fsoParent->get_Path( m_strPath );

        if(lpszPath != lpszEnd)
        {
            m_strPath.append( L"\\" );
        }
    }

    if(lpszPath != lpszEnd)
    {
        m_strPath.append( lpszPath, lpszEnd );
    }
}


MPC::FileSystemObject& MPC::FileSystemObject::operator=( /*[in]*/ LPCWSTR lpszPath )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::operator=" );

    Clean();


    m_strPath = lpszPath;


    return *this;
}

MPC::FileSystemObject& MPC::FileSystemObject::operator=( /*[in]*/ const FileSystemObject& fso )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::operator=" );

    IterConst it;


    Clean();

    m_strPath  = fso.m_strPath;  // MPC::wstring              m_strPath;
    m_wfadInfo = fso.m_wfadInfo; // WIN32_FILE_ATTRIBUTE_DATA m_wfadInfo;
                                 // List                      m_lstChilds;
    m_fLoaded  = fso.m_fLoaded;  // bool                      m_fLoaded;
                                 // bool                      m_fScanned;
                                 // bool                      m_fScanned_Deep;

    for(it=fso.m_lstChilds.begin(); it != fso.m_lstChilds.end(); it++)
    {
        FileSystemObject* obj = *it;

        if((obj = new FileSystemObject( *obj )))
        {
            m_lstChilds.push_back( obj );
        }
    }

    return *this;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::FileSystemObject::Scan( /*[in]*/ bool fDeep, /*[in]*/ bool fReload, /*[in]*/ LPCWSTR szSearchPattern )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::Scan" );

    HRESULT           hr;
    FileSystemObject* fsoChild  = NULL;
    HANDLE            hFindFile = NULL;
    WIN32_FIND_DATAW  wfdInfo;
    LONG              lRes;


    //
    // Before proceeding, check if we really need to scan the object.
    //
    if(fReload == false && m_fScanned)
    {
        if(m_fScanned_Deep || fDeep == false)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }


    Clean();

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetFileAttributesExW( m_strPath.c_str(), GetFileExInfoStandard, &m_wfadInfo ));

    m_fLoaded = true;

    if(m_wfadInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        MPC::wstring strSearchPattern;

        strSearchPattern = m_strPath;
        strSearchPattern.append( L"\\"                                    );
        strSearchPattern.append( szSearchPattern ? szSearchPattern : L"*" );

        __MPC_EXIT_IF_INVALID_HANDLE__CLEAN(hr, hFindFile, ::FindFirstFileW( strSearchPattern.c_str(), &wfdInfo ));

        while(1)
        {
            BOOL fProcess = TRUE;

            if(wfdInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if(!wcscmp( wfdInfo.cFileName, L"."  )) fProcess = FALSE;
                if(!wcscmp( wfdInfo.cFileName, L".." )) fProcess = FALSE;
            }

            if(fProcess)
            {
                //
                // Create a child and set up its attributes.
                //
                __MPC_EXIT_IF_ALLOC_FAILS(hr, fsoChild, new FileSystemObject( wfdInfo, this ));

                if(fDeep)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, fsoChild->Scan( true ));
                }

                m_lstChilds.push_back( fsoChild ); fsoChild = NULL;
            }

            if(::FindNextFileW( hFindFile, &wfdInfo ) == FALSE)
            {
                lRes = ::GetLastError();

                if(lRes == ERROR_NO_MORE_FILES) break;

                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, lRes);
            }
        }
    }

    m_fScanned      = true;
    m_fScanned_Deep = fDeep;
    hr              = S_OK;


    __MPC_FUNC_CLEANUP;

    if(fsoChild) delete fsoChild;

    if(hFindFile) ::FindClose( hFindFile );

    __MPC_FUNC_EXIT(hr);
}

bool MPC::FileSystemObject::Exists()
{
    return Exists( m_strPath.c_str() );
}

bool MPC::FileSystemObject::IsFile()
{
    return IsFile( m_strPath.c_str() );
}

bool MPC::FileSystemObject::IsDirectory()
{
    return IsDirectory( m_strPath.c_str() );
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::FileSystemObject::EnumerateFolders( /*[out]*/ List& lstFolders )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::EnumerateFolders" );

    HRESULT   hr;
    DWORD     dwFileAttributes;
    IterConst it;


    lstFolders.clear();


    //
    // Do a shallow scan if the object is not initialized.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());


    for(it=m_lstChilds.begin(); it != m_lstChilds.end(); it++)
    {
        FileSystemObject* obj = *it;

        (void)obj->get_Attributes( dwFileAttributes );
        if(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            lstFolders.push_back( obj );
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileSystemObject::EnumerateFiles( /*[out]*/ List& lstFiles )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::EnumerateFiles" );

    HRESULT   hr;
    DWORD     dwFileAttributes;
    IterConst it;


    lstFiles.clear();


    //
    // Do a shallow scan if the object is not initialized.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());


    for(it=m_lstChilds.begin(); it != m_lstChilds.end(); it++)
    {
        FileSystemObject* obj = *it;

        (void)obj->get_Attributes( dwFileAttributes );
        if((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY)
        {
            lstFiles.push_back( obj );
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::FileSystemObject::get_Name( /*[out]*/ MPC::wstring& szName ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::get_Name" );

    HRESULT                 hr;
    MPC::wstring::size_type iPos;


    iPos = m_strPath.rfind( '\\' );
    if(iPos == m_strPath.npos)
    {
        szName = m_strPath;
    }
    else
    {
        szName = m_strPath.substr( iPos+1 );
    }

    hr = S_OK;


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileSystemObject::get_Parent( /*[out]*/ MPC::wstring& szParent ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::get_Parent" );

    HRESULT                 hr;
    MPC::wstring::size_type iPos;


    iPos = m_strPath.rfind( '\\' );
    if(iPos == m_strPath.npos)
    {
        szParent.erase();
    }
    else
    {
        szParent = m_strPath.substr( 0, iPos );
    }

    hr = S_OK;


    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::FileSystemObject::get_Path( /*[out]*/ MPC::wstring& szPath ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::get_Path" );

    HRESULT hr;


    szPath = m_strPath;
    hr     = S_OK;


    __MPC_FUNC_EXIT(hr);
}

//////////

HRESULT MPC::FileSystemObject::get_Attributes( /*[out]*/ DWORD& dwFileAttributes )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::get_Attributes" );

    HRESULT hr;


    if(!m_fLoaded)
    {
        //
        // Do a shallow scan if the object is not initialized.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());
    }

    dwFileAttributes = m_wfadInfo.dwFileAttributes;
    hr               = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileSystemObject::put_Attributes( /*[in]*/ DWORD dwFileAttributes )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::put_Attributes" );

    HRESULT hr;


    if(!m_fLoaded)
    {
        //
        // Do a shallow scan if the object is not initialized.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());
    }


    m_wfadInfo.dwFileAttributes = dwFileAttributes;
    hr                          = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

//////////

HRESULT MPC::FileSystemObject::get_CreationTime( /*[out]*/ FILETIME& ftCreationTime )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::get_CreationTime" );

    HRESULT hr;


    if(!m_fLoaded)
    {
        //
        // Do a shallow scan if the object is not initialized.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());
    }


    ftCreationTime = m_wfadInfo.ftCreationTime;
    hr             = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileSystemObject::put_CreationTime( /*[in]*/ const FILETIME& ftCreationTime )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::put_CreationTime" );

    HRESULT hr;


    if(!m_fLoaded)
    {
        //
        // Do a shallow scan if the object is not initialized.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());
    }


    m_wfadInfo.ftCreationTime = ftCreationTime;
    hr                        = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

//////////

HRESULT MPC::FileSystemObject::get_LastAccessTime( /*[out]*/ FILETIME& ftLastAccessTime )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::get_LastAccessTime" );

    HRESULT hr;


    if(!m_fLoaded)
    {
        //
        // Do a shallow scan if the object is not initialized.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());
    }


    ftLastAccessTime = m_wfadInfo.ftLastAccessTime;
    hr               = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileSystemObject::put_LastAccessTime( /*[in]*/ const FILETIME& ftLastAccessTime )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::put_LastAccessTime" );

    HRESULT hr;


    if(!m_fLoaded)
    {
        //
        // Do a shallow scan if the object is not initialized.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());
    }


    m_wfadInfo.ftLastAccessTime = ftLastAccessTime;
    hr                          = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

//////////

HRESULT MPC::FileSystemObject::get_LastWriteTime( /*[out]*/ FILETIME& ftLastWriteTime )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::get_LastWriteTime" );

    HRESULT hr;


    if(!m_fLoaded)
    {
        //
        // Do a shallow scan if the object is not initialized.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());
    }


    ftLastWriteTime = m_wfadInfo.ftLastWriteTime;
    hr              = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileSystemObject::put_LastWriteTime( /*[in]*/ const FILETIME& ftLastWriteTime )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::put_LastWriteTime" );

    HRESULT hr;


    if(!m_fLoaded)
    {
        //
        // Do a shallow scan if the object is not initialized.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());
    }


    m_wfadInfo.ftLastWriteTime = ftLastWriteTime;
    hr                         = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

//////////

HRESULT MPC::FileSystemObject::get_FileSize( /*[out]*/ DWORD& nFileSizeLow   ,
                                             /*[out]*/ DWORD *pnFileSizeHigh )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::get_FileSize" );

    HRESULT hr;


    if(!m_fLoaded)
    {
        //
        // Do a shallow scan if the object is not initialized.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());
    }


                        nFileSizeLow   = m_wfadInfo.nFileSizeLow;
    if(pnFileSizeHigh) *pnFileSizeHigh = m_wfadInfo.nFileSizeHigh;
                        hr             = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::FileSystemObject::CreateDir( /*[in]*/ bool fForce )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::CreateDir" );

    HRESULT hr;
    LONG    lRes;


    if(fForce)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( m_strPath ));
    }

    if(::CreateDirectoryW( m_strPath.c_str(), NULL ) == FALSE)
    {
        lRes = ::GetLastError();
        if(lRes != ERROR_ALREADY_EXISTS)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, lRes);
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileSystemObject::Delete( /*[in]*/ bool fForce    ,
                                       /*[in]*/ bool fComplain )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::Delete" );

    HRESULT hr;
    LONG    lRes;


    if(FAILED(hr = Scan()))
    {
        if(fComplain)
        {
            if(hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ))
            {
                hr = S_OK;
            }
        }
        else
        {
            hr = S_OK;
        }

        __MPC_FUNC_LEAVE;
    }


    if(fForce)
    {
        (void)::SetFileAttributesW( m_strPath.c_str(), FILE_ATTRIBUTE_NORMAL );
    }


    if(m_wfadInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        //
        // First of all, try to remove the directory directly.
        //
        if(::RemoveDirectoryW( m_strPath.c_str() ) == FALSE)
        {
            lRes = fComplain ? ::GetLastError() : ERROR_SUCCESS;

            //
            // If direct attempt failed and the 'fForce' flag is set,
            // recursively delete all the files and subdirectories,
            // then retry to delete the directory.
            //
            if(fForce)
            {
                switch(lRes)
                {
                case ERROR_DIR_NOT_EMPTY:
                case ERROR_ACCESS_DENIED:
                case ERROR_SHARING_VIOLATION: lRes = ERROR_SUCCESS; break;
                }
            }

            if(lRes == ERROR_SUCCESS)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, DeleteChildren( fForce, fComplain ));

                if(::RemoveDirectoryW( m_strPath.c_str() ) == FALSE)
                {
                    lRes = fComplain ? ::GetLastError() : ERROR_SUCCESS;
                }
                else
                {
                    lRes = ERROR_SUCCESS;
                }
            }

            if(lRes != ERROR_SUCCESS)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, lRes);
            }
        }
    }
    else
    {
        //
        // It's a file, so try to remove it directly.
        //
        hr = MPC::DeleteFile( m_strPath, fForce );
        if(FAILED(hr) && fComplain)
        {
            __MPC_FUNC_LEAVE;
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileSystemObject::DeleteChildren( /*[in]*/ bool fForce    ,
                                               /*[in]*/ bool fComplain )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::DeleteChildren" );

    HRESULT   hr;
    IterConst it;


    if(FAILED(hr = Scan()))
    {
        if(fComplain)
        {
            if(hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ))
            {
                hr = S_OK;
            }
        }
        else
        {
            hr = S_OK;
        }

        __MPC_FUNC_LEAVE;
    }


    for(it=m_lstChilds.begin(); it != m_lstChilds.end(); it++)
    {
        FileSystemObject* obj = *it;

        __MPC_EXIT_IF_METHOD_FAILS(hr, obj->Delete( fForce, fComplain ));
    }
    Clean();

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::FileSystemObject::Rename( /*[in]*/ const FileSystemObject& fsoDst ,
                                       /*[in]*/ bool                    fForce )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::Rename" );

    HRESULT      hr;
    MPC::wstring szPathDst;


    __MPC_EXIT_IF_METHOD_FAILS(hr, fsoDst.get_Path( szPathDst ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MoveFile( m_strPath, szPathDst, fForce ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::FileSystemObject::Copy( /*[in]*/ const FileSystemObject& fsoDst ,
                                     /*[in]*/ bool                    fForce )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::Copy" );

    HRESULT      hr;
    MPC::wstring szPathDst;


    __MPC_EXIT_IF_METHOD_FAILS(hr, fsoDst.get_Path( szPathDst ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CopyFile( m_strPath, szPathDst, fForce ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::FileSystemObject::Open( /*[out]*/ HANDLE& hfFile                ,
                                     /*[in] */ DWORD   dwDesiredAccess       ,
                                     /*[in] */ DWORD   dwShareMode           ,
                                     /*[in] */ DWORD   dwCreationDisposition )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::Open" );

    HRESULT hr;


    //
    // Do a shallow scan if the object is not initialized.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());


    __MPC_EXIT_IF_INVALID_HANDLE__CLEAN(hr, hfFile, ::CreateFileW( m_strPath.c_str(), dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, m_wfadInfo.dwFileAttributes, NULL ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

bool MPC::FileSystemObject::Exists( /*[in]*/ LPCWSTR lpszPath )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::Exists" );

    bool                      fRes = false;
    WIN32_FILE_ATTRIBUTE_DATA wfadInfo;


    if(::GetFileAttributesExW( lpszPath, GetFileExInfoStandard, &wfadInfo ) == TRUE)
    {
        fRes = true;
    }


    __MPC_FUNC_EXIT(fRes);
}

bool MPC::FileSystemObject::IsFile( /*[in]*/ LPCWSTR lpszPath )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::IsFile" );

    bool                      fRes = false;
    WIN32_FILE_ATTRIBUTE_DATA wfadInfo;


    if(::GetFileAttributesExW( lpszPath, GetFileExInfoStandard, &wfadInfo ) == TRUE)
    {
        if((wfadInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            fRes = true;
        }
    }


    __MPC_FUNC_EXIT(fRes);
}

bool MPC::FileSystemObject::IsDirectory( /*[in]*/ LPCWSTR lpszPath )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::FileSystemObject::IsDirectory" );

    bool                      fRes = false;
    WIN32_FILE_ATTRIBUTE_DATA wfadInfo;


    if(::GetFileAttributesExW( lpszPath, GetFileExInfoStandard, &wfadInfo ) == TRUE)
    {
        if((wfadInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
        {
            fRes = true;
        }
    }


    __MPC_FUNC_EXIT(fRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_regkey.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_RegKey.cpp

Abstract:
    This file contains the implementation of the Registry wrapper.

Revision History:
    Davide Massarenti   (Dmassare)  04/28/99
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static bool IsPredefinedRegistryHandle( HKEY h )
{
    return (h == HKEY_CLASSES_ROOT        ||
            h == HKEY_CURRENT_USER        ||
            h == HKEY_LOCAL_MACHINE       ||
            h == HKEY_PERFORMANCE_DATA    ||
            h == HKEY_PERFORMANCE_TEXT    ||
            h == HKEY_PERFORMANCE_NLSTEXT ||
            h == HKEY_USERS               ||
            h == HKEY_CURRENT_CONFIG      ||
            h == HKEY_DYN_DATA             );
}

static LONG safe_RegOpenKeyExW( HKEY    hKey       ,
                                LPCWSTR lpSubKey   ,
                                DWORD   ulOptions  ,
                                REGSAM  samDesired ,
                                PHKEY   phkResult  )
{
    if(!STRINGISPRESENT(lpSubKey) && IsPredefinedRegistryHandle( hKey ) && phkResult) // Reopening a predefined registry key is considered bad!! Go figure....
    {
        *phkResult = hKey; return ERROR_SUCCESS;
    }

    return ::RegOpenKeyExW( hKey       ,
                            lpSubKey   ,
                            ulOptions  ,
                            samDesired ,
                            phkResult  );
}

static LONG safe_RegCloseKey( HKEY hKey )
{
    if(IsPredefinedRegistryHandle( hKey )) // Closing a predefined registry key is considered bad!! Go figure....
    {
        return ERROR_SUCCESS;
    }

    return ::RegCloseKey( hKey );
}

////////////////////////////////////////////////////////////////////////////////

MPC::RegKey::RegKey()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::RegKey" );


    m_samDesired = KEY_READ; // REGSAM       m_samDesired;
    m_hRoot      = NULL;     // HKEY         m_hRoot;
    m_hKey       = NULL;     // HKEY         m_hKey;
                             //
                             // MPC::wstring m_strKey;
                             // MPC::wstring m_strPath;
                             // MPC::wstring m_strName;

}

MPC::RegKey::~RegKey()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::~RegKey" );


    (void)Clean( true );
}

HRESULT MPC::RegKey::Clean( /*[in]*/ bool fBoth )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::Clean" );

    HRESULT hr;
    LONG    lRes;


    if(m_hKey != NULL)
    {
        __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, safe_RegCloseKey( m_hKey ));

        m_hKey = NULL;
    }

    if(fBoth == true)
    {
        if(m_hRoot != NULL)
        {
            __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, safe_RegCloseKey( m_hRoot ));

            m_hRoot  = NULL;
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

MPC::RegKey::operator HKEY() const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::operator HKEY()" );

    HKEY hKey = m_hKey;

    __MPC_FUNC_EXIT(hKey);
}

MPC::RegKey& MPC::RegKey::operator=( /*[in]*/ const RegKey& rk )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::operator=" );


    Clean( true );


    m_samDesired = rk.m_samDesired; // REGSAM       m_samDesired;
                                    // HKEY         m_hRoot;
                                    // HKEY         m_hKey;
                                    //
    m_strKey     = rk.m_strKey;     // MPC::wstring m_strKey;
    m_strPath    = rk.m_strPath;    // MPC::wstring m_strPath;
    m_strName    = rk.m_strName;    // MPC::wstring m_strName;

    if(rk.m_hRoot) (void)safe_RegOpenKeyExW( rk.m_hRoot, NULL, 0, m_samDesired, &m_hRoot );
    if(rk.m_hKey ) (void)safe_RegOpenKeyExW( rk.m_hKey , NULL, 0, m_samDesired, &m_hKey  );


    __MPC_FUNC_EXIT(*this);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::RegKey::SetRoot( /*[in]*/ HKEY    hKey        ,
                              /*[in]*/ REGSAM  samDesired  ,
                              /*[in]*/ LPCWSTR lpszMachine )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::SetRoot" );

    HRESULT hr;
    LONG    lRes;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Clean( true ));


    m_samDesired = samDesired;

    if(lpszMachine && lpszMachine[0] && _wcsicmp( lpszMachine, L"localhost" ) != 0)
    {
        __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, ::RegConnectRegistryW( lpszMachine, hKey, &m_hRoot ));
    }
    else
    {
        __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, safe_RegOpenKeyExW( hKey, NULL, 0, m_samDesired, &m_hRoot ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::Attach( /*[in]*/ LPCWSTR lpszKeyName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::Attach" );

    HRESULT                 hr;
    MPC::wstring::size_type iPos;


    //
    // Release previously opened key, if any.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Clean( false ));

    m_strKey = lpszKeyName;

    //
    // If the key has a parent, split into basename and path.
    //
    iPos = m_strKey.rfind( '\\' );
    if(iPos != MPC::wstring::npos)
    {
        m_strPath = m_strKey.substr( 0, iPos   );
        m_strName = m_strKey.substr(    iPos+1 );
    }
    else
    {
        m_strPath = L"";
        m_strName = m_strKey;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::RegKey::Exists( /*[out]*/ bool& fFound ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::Exists" );

    HRESULT hr;
    LONG    lRes;


    //
    // Default to a negative result, in case of errors.
    //
    fFound = false;

    if(m_hKey == NULL)
    {
        lRes = safe_RegOpenKeyExW( m_hRoot, (m_strKey.empty() ? NULL : m_strKey.c_str()), 0, m_samDesired, &m_hKey  );
        if(lRes != ERROR_SUCCESS)
        {
            if(lRes == ERROR_FILE_NOT_FOUND)
            {
                __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
            }

            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, lRes);
        }
    }

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::Create() const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::Create" );

    HRESULT hr;
    LONG    lRes;
    bool    fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Exists( fFound ));
    if(fFound == false)
    {
        MPC::RegKey rkParent;

        __MPC_EXIT_IF_METHOD_FAILS(hr, Parent( rkParent ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, rkParent.Create());

        __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, ::RegCreateKeyExW( rkParent.m_hKey, m_strName.c_str(), 0, NULL, REG_OPTION_NON_VOLATILE, m_samDesired, NULL, &m_hKey, NULL ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::Delete( /*[in]*/ bool fDeep )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::Delete" );

    HRESULT hr;
    LONG    lRes;
    bool    fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Exists( fFound ));
    if(fFound == true)
    {
        MPC::RegKey rkParent;

        if(fDeep)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, DeleteSubKeys());
        }

        //
        // Release the opened key.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, Clean( false ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, Parent( rkParent ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, rkParent.Exists( fFound ));
        if(fFound == true)
        {
            __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, ::RegDeleteKeyW( rkParent.m_hKey, m_strName.c_str() ));
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);

}

HRESULT MPC::RegKey::SubKey( /*[in]*/  LPCWSTR lpszKeyName ,
                             /*[out]*/ RegKey& rkSubKey    ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::SubKey" );

    HRESULT      hr;
    MPC::wstring strKey;


    //
    // First of all, make a copy of the key.
    //
    rkSubKey = *this;

    //
    // Then close its key handle, but not the one to the root of the hive.
    //
    rkSubKey.Clean( false );

    //
    // Finally construct the name of the subkey.
    //
    strKey  = m_strKey;
    strKey += L"\\";
    strKey += lpszKeyName;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkSubKey.Attach( strKey.c_str() ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::Parent( /*[out]*/ RegKey& rkParent ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::Parent" );

    HRESULT hr;


    //
    // First of all, make a copy of the key.
    //
    rkParent = *this;

    //
    // Then close its key handle, but not the one to the root of the hive.
    //
    rkParent.Clean( false );

    //
    // Finally attach it to the pathname of our parent.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkParent.Attach( m_strPath.c_str() ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::RegKey::EnumerateSubKeys( /*[out]*/ MPC::WStringList& lstSubKeys ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::EnumerateSubKeys" );

    HRESULT hr;
    DWORD   dwIndex = 0;
    WCHAR   rgBuf[MAX_PATH + 1];
    LONG    lRes;
    bool    fFound;


    lstSubKeys.clear();

    __MPC_EXIT_IF_METHOD_FAILS(hr, Exists( fFound ));
    if(fFound == true)
    {
        while((lRes = ::RegEnumKeyW( m_hKey, dwIndex++, rgBuf, MAX_PATH )) == ERROR_SUCCESS)
        {
            lstSubKeys.push_back( MPC::wstring( rgBuf ) );
        }

        if(lRes != ERROR_SUCCESS       &&
           lRes != ERROR_NO_MORE_ITEMS  )
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, lRes);
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::EnumerateValues( /*[out]*/ MPC::WStringList& lstValues ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::EnumerateValues" );

    HRESULT hr;
    DWORD   dwIndex = 0;
    DWORD   dwCount;
    WCHAR   rgBuf[MAX_PATH + 1];
    WCHAR*  rgBuffer = NULL;
    LONG    lRes;
    bool    fFound;


    lstValues.clear();

    __MPC_EXIT_IF_METHOD_FAILS(hr, Exists( fFound ));
    if(fFound == false)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }


    while(1)
    {
        WCHAR* rgPtr;

        dwCount = MAXSTRLEN(rgBuf);

        lRes = ::RegEnumValueW( m_hKey, dwIndex, rgPtr = rgBuf, &dwCount, NULL, NULL, NULL, NULL );
        if(lRes == ERROR_MORE_DATA)
        {
            delete [] rgBuffer;

            __MPC_EXIT_IF_ALLOC_FAILS(hr, rgBuffer, new WCHAR[dwCount+1]);

            lRes = ::RegEnumValueW( m_hKey, dwIndex, rgPtr = rgBuffer, &dwCount, NULL, NULL, NULL, NULL );
        }
        if(lRes != ERROR_SUCCESS) break;


        lstValues.push_back( MPC::wstring( rgPtr ) ); dwIndex++;
    }

    if(lRes != ERROR_SUCCESS       &&
       lRes != ERROR_NO_MORE_ITEMS  )
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, lRes);
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    delete [] rgBuffer;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::DeleteSubKeys() const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::DeleteSubKeys" );

    HRESULT          hr;
    LONG             lRes;
    MPC::WStringList lst;
    MPC::WStringIter it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, EnumerateSubKeys( lst ));

    for(it=lst.begin(); it != lst.end(); it++)
    {
        RegKey rkSubKey;

        __MPC_EXIT_IF_METHOD_FAILS(hr,          SubKey( it->c_str(), rkSubKey ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, rkSubKey.Delete( true                  ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::DeleteValues() const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::DeleteValues" );

    HRESULT          hr;
    LONG             lRes;
    MPC::WStringList lst;
    MPC::WStringIter it;


    __MPC_EXIT_IF_METHOD_FAILS(hr, EnumerateValues( lst ));

    for(it=lst.begin(); it != lst.end(); it++)
    {
        __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, ::RegDeleteValueW( m_hKey, it->c_str() ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::RegKey::ReadDirect( /*[in ]*/ LPCWSTR      lpszValueName ,
                                 /*[out]*/ CComHGLOBAL& chg           ,
                                 /*[out]*/ DWORD&       dwSize        ,
                                 /*[out]*/ DWORD&       dwType        ,
                                 /*[out]*/ bool&        fFound        ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::ReadDirect" );

    HRESULT hr;
    LONG    lRes;
    bool    fFoundKey;


    dwSize = 0;
    dwType = 0;
    fFound = false;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Exists( fFoundKey ));
    if(fFoundKey == false)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, S_OK);
    }


    lRes = ::RegQueryValueExW( m_hKey, (LPWSTR)lpszValueName, NULL, &dwType, NULL, &dwSize );
    if(lRes != ERROR_SUCCESS)
    {
        //
        // If the result is ERROR_FILE_NOT_FOUND, the value doesn't exist, so return VT_EMPTY (done by calling VariantClear).
        //
        if(lRes == ERROR_FILE_NOT_FOUND)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }


        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, lRes);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, chg.New( GMEM_FIXED, dwSize ));

    __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, ::RegQueryValueExW( m_hKey, lpszValueName, NULL, NULL, (LPBYTE)chg.Get(), &dwSize ));

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::WriteDirect( /*[in]*/ LPCWSTR lpszValueName ,
                                  /*[in]*/ void*   pBuffer       ,
                                  /*[in]*/ DWORD   dwSize        ,
                                  /*[in]*/ DWORD   dwType        ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::WriteDirect" );

    HRESULT hr;
    LONG    lRes;
    bool    fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Exists( fFound ));
    if(fFound == false)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }


    __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, ::RegSetValueExW( m_hKey, lpszValueName, NULL, dwType, (LPBYTE)pBuffer, dwSize ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::RegKey::get_Key( /*[out]*/ MPC::wstring& strKey ) const
{
    strKey = m_strKey;

    return S_OK;
}

HRESULT MPC::RegKey::get_Name( /*[out]*/ MPC::wstring& strName ) const
{
    strName = m_strName;

    return S_OK;
}

HRESULT MPC::RegKey::get_Path( /*[out]*/ MPC::wstring& strPath ) const
{
    strPath = m_strPath;

    return S_OK;
}


HRESULT MPC::RegKey::get_Value( /*[out]*/ VARIANT& vValue        ,
                                /*[out]*/ bool&    fFound        ,
                                /*[in] */ LPCWSTR  lpszValueName ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::get_Value" );

    HRESULT     hr;
    CComHGLOBAL chg;
    LPVOID      ptr;
    DWORD       dwSize   = 0;
    DWORD       dwType   = 0;
    bool        fFoundKey;
    LONG        lRes;


    fFound = false;

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::VariantClear( &vValue ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, ReadDirect( lpszValueName, chg, dwSize, dwType, fFoundKey ));
    if(fFoundKey == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    ptr = chg.Lock();

    if(dwType == REG_DWORD)
    {
        vValue.vt   = VT_I4;
        vValue.lVal = *(DWORD*)ptr;
    }
    else if(dwType == REG_SZ        ||
            dwType == REG_EXPAND_SZ  )
    {
        vValue.vt      = VT_BSTR;
        vValue.bstrVal = ::SysAllocString( (LPCWSTR)ptr );
        if(vValue.bstrVal == NULL && ((LPCWSTR)ptr)[0])
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
        }
    }
    else if(dwType == REG_MULTI_SZ)
    {
        BSTR*   rgArrayData;
        LPCWSTR szStrings;
        int     iCount;

        //
        // Count the number of strings.
        //
        iCount    =          0;
        szStrings = (LPCWSTR)ptr;
        while(szStrings[0]) // This doesn't cover the case of null strings, but who cares?
        {
            szStrings += wcslen( szStrings ) + 1; iCount++;
        }

        //
        // Allocate SAFEARRAY.
        //
        __MPC_EXIT_IF_ALLOC_FAILS(hr, vValue.parray, ::SafeArrayCreateVector( VT_BSTR, 0, iCount ));
        vValue.vt = VT_ARRAY | VT_BSTR;

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayAccessData( vValue.parray, (LPVOID*)&rgArrayData ));

        //
        // Copy strings into the SAFEARRAY.
        //
        szStrings = (LPCWSTR)ptr;
        while(szStrings[0]) // This doesn't cover the case of null strings, but who cares?
        {
            if((*rgArrayData++ = ::SysAllocString( szStrings )) == NULL) break;

            szStrings += wcslen( szStrings ) + 1;
        }

        ::SafeArrayUnaccessData( vValue.parray );

        if(szStrings[0]) // TRUE means we break out of the loop for an allocation failure.
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
        }
    }
    else if(dwType == REG_BINARY)
    {
        BYTE* rgArrayData;

        vValue.vt = VT_ARRAY | VT_UI1;

        __MPC_EXIT_IF_ALLOC_FAILS(hr, vValue.parray, ::SafeArrayCreateVector( VT_UI1, 0, dwSize ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayAccessData( vValue.parray, (LPVOID*)&rgArrayData ));

        ::CopyMemory( rgArrayData, ptr, dwSize );

        ::SafeArrayUnaccessData( vValue.parray );
    }
    else
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::put_Value( /*[in]*/ const VARIANT vValue        ,
                                /*[in]*/ LPCWSTR       lpszValueName ,
                                /*[in]*/ bool          fExpand       ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::put_Value" );

    HRESULT hr;
    LONG    lRes;
    bool    fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Exists( fFound ));
    if(fFound == false)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    if(vValue.vt == VT_EMPTY)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, del_Value( lpszValueName ));
    }
    else if(vValue.vt == VT_I4)
    {
        __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, ::RegSetValueExW( m_hKey, lpszValueName, NULL, REG_DWORD, (LPBYTE)&vValue.lVal, sizeof(DWORD) ));
    }
    else if(vValue.vt == VT_BOOL)
    {
        LPCWSTR rgBuffer = vValue.boolVal ? L"true" : L"false";
        UINT    iLen     = (wcslen( rgBuffer ) + 1) * sizeof(WCHAR);

        __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, ::RegSetValueExW( m_hKey, lpszValueName, NULL, fExpand ? REG_EXPAND_SZ : REG_SZ, (LPBYTE)rgBuffer, iLen ));
    }
    else if(vValue.vt == VT_BSTR)
    {
        LPCWSTR rgBuffer = SAFEBSTR(vValue.bstrVal);
        UINT    iLen     = (wcslen( rgBuffer ) + 1) * sizeof(WCHAR);

        __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, ::RegSetValueExW( m_hKey, lpszValueName, NULL, fExpand ? REG_EXPAND_SZ : REG_SZ, (LPBYTE)rgBuffer, iLen ));
    }
    else if(vValue.vt == (VT_ARRAY | VT_BSTR))
    {
        LPWSTR rgBuffer;
        LPWSTR rgBufferPtr;
        BSTR*  rgArrayData;
        BSTR*  rgArrayDataPtr;
        DWORD  dwLen;
        long   lBound;
        long   uBound;
        long   l;
        int    iSize;

        ::SafeArrayGetLBound( vValue.parray, 1, &lBound );
        ::SafeArrayGetUBound( vValue.parray, 1, &uBound );

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayAccessData( vValue.parray, (LPVOID*)&rgArrayData ));

        iSize          = 1;
        rgArrayDataPtr = rgArrayData;
        for(l=lBound; l<=uBound; l++)
        {
            if((dwLen = ::SysStringLen( *rgArrayDataPtr++ )))
            {
                iSize += dwLen + 1;
            }
        }


        __MPC_EXIT_IF_ALLOC_FAILS(hr, rgBuffer, new WCHAR[iSize]);

        rgArrayDataPtr = rgArrayData;
        rgBufferPtr    = rgBuffer;
        for(l=lBound; l<=uBound; l++, rgArrayDataPtr++)
        {
            if((dwLen = ::SysStringLen( *rgArrayDataPtr )))
            {
                wcscpy( rgBufferPtr, SAFEBSTR(*rgArrayDataPtr) );

                rgBufferPtr += dwLen + 1;
            }
        }
        rgBufferPtr[0] = 0;


        __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, ::RegSetValueExW( m_hKey, lpszValueName, NULL, REG_MULTI_SZ, (LPBYTE)rgBuffer, iSize*sizeof(WCHAR) ));

        ::SafeArrayUnaccessData( vValue.parray );
    }
    else if(vValue.vt == (VT_ARRAY | VT_UI1))
    {
        BYTE* rgArrayData;
        long  lBound;
        long  uBound;

        ::SafeArrayGetLBound( vValue.parray, 1, &lBound );
        ::SafeArrayGetUBound( vValue.parray, 1, &uBound );

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayAccessData( vValue.parray, (LPVOID*)&rgArrayData ));

        __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, ::RegSetValueExW( m_hKey, lpszValueName, NULL, REG_BINARY, rgArrayData, uBound-lBound+1 ));

        ::SafeArrayUnaccessData( vValue.parray );
    }
    else
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::del_Value( /*[in]*/ LPCWSTR lpszValueName ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::del_Value" );

    HRESULT hr;
    LONG    lRes;
    bool    fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Exists( fFound ));
    if(fFound == false)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_FILE_NOT_FOUND);
    }

    __MPC_EXIT_IF_SYSCALL_FAILS(hr, lRes, ::RegDeleteValueW( m_hKey, lpszValueName ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::RegKey::Read( /*[out]*/ MPC::string& strValue      ,
                           /*[out]*/ bool&        fFound        ,
                           /*[in] */ LPCWSTR      lpszValueName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::Read" );

    HRESULT     hr;
    CComVariant vValue;


    fFound = false;

    __MPC_EXIT_IF_METHOD_FAILS(hr, get_Value( vValue, fFound, lpszValueName ));

    if(vValue.vt == VT_BSTR)
    {
        USES_CONVERSION;

        strValue = W2A( SAFEBSTR(vValue.bstrVal) );
    }
    else
    {
        fFound = false;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::Read( /*[out]*/ MPC::wstring& strValue      ,
                           /*[out]*/ bool&         fFound        ,
                           /*[in] */ LPCWSTR       lpszValueName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::Read" );

    HRESULT     hr;
    CComVariant vValue;


    fFound = false;

    __MPC_EXIT_IF_METHOD_FAILS(hr, get_Value( vValue, fFound, lpszValueName ));

    if(vValue.vt == VT_BSTR)
    {
        strValue = SAFEBSTR(vValue.bstrVal);
    }
    else
    {
        fFound = false;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::Read( /*[out]*/ CComBSTR& bstrValue     ,
                           /*[out]*/ bool&     fFound        ,
                           /*[in] */ LPCWSTR   lpszValueName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::Read" );

    HRESULT     hr;
    CComVariant vValue;


    fFound = false;

    __MPC_EXIT_IF_METHOD_FAILS(hr, get_Value( vValue, fFound, lpszValueName ));

    if(vValue.vt == VT_BSTR)
    {
        bstrValue = vValue.bstrVal;
    }
    else
    {
        fFound = false;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::Read( /*[out]*/ DWORD&  dwValue       ,
                           /*[out]*/ bool&   fFound        ,
                           /*[in] */ LPCWSTR lpszValueName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::Read" );

    HRESULT     hr;
    CComVariant vValue;


    fFound = false;

    __MPC_EXIT_IF_METHOD_FAILS(hr, get_Value( vValue, fFound, lpszValueName ));

    if(vValue.vt == VT_I4)
    {
        dwValue = vValue.lVal;
    }
    else
    {
        fFound = false;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey::Read( /*[out]*/ MPC::WStringList& lstValue      ,
                           /*[out]*/ bool&             fFound        ,
                           /*[in] */ LPCWSTR           lpszValueName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::Read" );

    HRESULT     hr;
    CComVariant vValue;


    lstValue.clear();
    fFound = false;

    __MPC_EXIT_IF_METHOD_FAILS(hr, get_Value( vValue, fFound, lpszValueName ));

    if(vValue.vt == (VT_ARRAY | VT_BSTR))
    {
        BSTR* rgArrayData;
        long  lBound;
        long  uBound;
        long  l;

        ::SafeArrayGetLBound( vValue.parray, 1, &lBound );
        ::SafeArrayGetUBound( vValue.parray, 1, &uBound );

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayAccessData( vValue.parray, (LPVOID*)&rgArrayData ));

        for(l=lBound; l<=uBound; l++, rgArrayData++)
        {
            lstValue.push_back( SAFEBSTR(*rgArrayData) );
        }

        ::SafeArrayUnaccessData( vValue.parray );
    }
    else
    {
        fFound = false;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::RegKey::Write( /*[in]*/ const MPC::string& strValue      ,
                            /*[in]*/ LPCWSTR            lpszValueName ,
                            /*[in]*/ bool               fExpand       )
{
    USES_CONVERSION;

    return put_Value( CComVariant( A2W( strValue.c_str() ) ), lpszValueName, fExpand );
}

HRESULT MPC::RegKey::Write( /*[in]*/ const MPC::wstring& strValue      ,
                            /*[in]*/ LPCWSTR             lpszValueName ,
                            /*[in]*/ bool                fExpand       )
{
    return put_Value( CComVariant( strValue.c_str() ), lpszValueName, fExpand );
}

HRESULT MPC::RegKey::Write( /*[in]*/ BSTR    bstrValue     ,
                            /*[in]*/ LPCWSTR lpszValueName ,
                            /*[in]*/ bool    fExpand       )
{
    return put_Value( CComVariant( bstrValue ), lpszValueName, fExpand );
}

HRESULT MPC::RegKey::Write( /*[in]*/ DWORD   dwValue       ,
                            /*[in]*/ LPCWSTR lpszValueName )
{
    return put_Value( CComVariant( (long)dwValue ), lpszValueName );
}

HRESULT MPC::RegKey::Write( /*[in]*/ const MPC::WStringList& lstValue      ,
                            /*[in]*/ LPCWSTR                 lpszValueName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::Write" );

    HRESULT     hr;
    CComVariant vValue;
    BSTR*       rgArrayData;
    bool        fLocked = false;

    //
    // Allocate SAFEARRAY.
    //
    __MPC_EXIT_IF_ALLOC_FAILS(hr, vValue.parray, ::SafeArrayCreateVector( VT_BSTR, 0, lstValue.size() ));
    vValue.vt = VT_ARRAY | VT_BSTR;

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayAccessData( vValue.parray, (LPVOID*)&rgArrayData )); fLocked = true;

    for(MPC::WStringIterConst it = lstValue.begin(); it != lstValue.end(); it++)
    {
        if((*rgArrayData++ = ::SysAllocString( it->c_str() )) == NULL)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
        }
    }

    ::SafeArrayUnaccessData( vValue.parray ); fLocked = false;


    __MPC_EXIT_IF_METHOD_FAILS(hr, put_Value( vValue, lpszValueName, /*fExpand*/false ));


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(fLocked) ::SafeArrayUnaccessData( vValue.parray );

    __MPC_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::RegKey::ParsePath( /*[in ]*/ LPCWSTR  szKey       ,
                                /*[out]*/ HKEY&    hKey        ,
                                /*[out]*/ LPCWSTR& szPath      ,
                                /*[in ]*/ HKEY     hKeyDefault )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey::ParsePath" );


    static const WCHAR s_HKEY_CLASSES_ROOT    [] = L"HKEY_CLASSES_ROOT";
    static const WCHAR s_HKEY_CLASSES_ROOT_s  [] = L"HKCR";
    static const WCHAR s_HKEY_CURRENT_CONFIG  [] = L"HKEY_CURRENT_CONFIG";
    static const WCHAR s_HKEY_CURRENT_USER    [] = L"HKEY_CURRENT_USER";
    static const WCHAR s_HKEY_CURRENT_USER_s  [] = L"HKCU";
    static const WCHAR s_HKEY_LOCAL_MACHINE   [] = L"HKEY_LOCAL_MACHINE";
    static const WCHAR s_HKEY_LOCAL_MACHINE_s [] = L"HKLM";
    static const WCHAR s_HKEY_PERFORMANCE_DATA[] = L"HKEY_PERFORMANCE_DATA";
    static const WCHAR s_HKEY_USERS           [] = L"HKEY_USERS";

    static struct
    {
        HKEY    hKey;
        LPCWSTR szName;
        int     iLen;
    } s_Lookup[] =
      {
          { HKEY_CLASSES_ROOT    , s_HKEY_CLASSES_ROOT    , MAXSTRLEN(s_HKEY_CLASSES_ROOT    )  },
          { HKEY_CLASSES_ROOT    , s_HKEY_CLASSES_ROOT_s  , MAXSTRLEN(s_HKEY_CLASSES_ROOT_s  )  },
          { HKEY_CURRENT_CONFIG  , s_HKEY_CURRENT_CONFIG  , MAXSTRLEN(s_HKEY_CURRENT_CONFIG  )  },
          { HKEY_CURRENT_USER    , s_HKEY_CURRENT_USER    , MAXSTRLEN(s_HKEY_CURRENT_USER    )  },
          { HKEY_CURRENT_USER    , s_HKEY_CURRENT_USER_s  , MAXSTRLEN(s_HKEY_CURRENT_USER_s  )  },
          { HKEY_LOCAL_MACHINE   , s_HKEY_LOCAL_MACHINE   , MAXSTRLEN(s_HKEY_LOCAL_MACHINE   )  },
          { HKEY_LOCAL_MACHINE   , s_HKEY_LOCAL_MACHINE_s , MAXSTRLEN(s_HKEY_LOCAL_MACHINE_s )  },
          { HKEY_PERFORMANCE_DATA, s_HKEY_PERFORMANCE_DATA, MAXSTRLEN(s_HKEY_PERFORMANCE_DATA)  },
          { HKEY_USERS           , s_HKEY_USERS           , MAXSTRLEN(s_HKEY_USERS           )  },
      };


    //
    // Setup results in case of a mismatch.
    //
    hKey   = hKeyDefault;
    szPath = szKey;


    for(int i=0; i<ARRAYSIZE(s_Lookup); i++)
    {
        LPCWSTR szName = s_Lookup[i].szName;
        int     iLen   = s_Lookup[i].iLen;

        if(!_wcsnicmp( szName, szKey, iLen ) && szKey[iLen] == '\\')
        {
            hKey   = s_Lookup[i].hKey;
            szPath = &szKey[iLen+1];
            break;
        }
    }

    __MPC_FUNC_EXIT(S_OK);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::RegKey_Value_Read( /*[out]*/ VARIANT& vValue        ,
                                /*[out]*/ bool&    fFound        ,
                                /*[in] */ LPCWSTR  lpszKeyName   ,
                                /*[in] */ LPCWSTR  lpszValueName ,
                                /*[in] */ HKEY     hKey          )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey_Value_Read" );

    HRESULT     hr;
    MPC::RegKey rkRead;


    fFound = false;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRead.SetRoot( hKey, KEY_READ ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRead.Attach ( lpszKeyName    ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRead.get_Value( vValue, fFound, lpszValueName ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey_Value_Read( /*[out]*/ MPC::wstring& strValue      ,
                                /*[out]*/ bool&         fFound        ,
                                /*[in] */ LPCWSTR       lpszKeyName   ,
                                /*[in] */ LPCWSTR       lpszValueName ,
                                /*[in] */ HKEY          hKey          )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey_Value_Read" );

    HRESULT     hr;
    MPC::RegKey rkRead;


    fFound = false;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRead.SetRoot( hKey, KEY_READ ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRead.Attach ( lpszKeyName    ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRead.Read( strValue, fFound, lpszValueName ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey_Value_Read( /*[out]*/ DWORD&  dwValue       ,
                                /*[out]*/ bool&   fFound        ,
                                /*[in] */ LPCWSTR lpszKeyName   ,
                                /*[in] */ LPCWSTR lpszValueName ,
                                /*[in] */ HKEY    hKey          )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey_Value_Read" );

    HRESULT     hr;
    MPC::RegKey rkRead;


    fFound = false;

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRead.SetRoot( hKey, KEY_READ ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRead.Attach ( lpszKeyName    ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkRead.Read( dwValue, fFound, lpszValueName ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////

HRESULT MPC::RegKey_Value_Write( /*[in]*/ const VARIANT& vValue        ,
                                 /*[in]*/ LPCWSTR        lpszKeyName   ,
                                 /*[in]*/ LPCWSTR        lpszValueName ,
                                 /*[in]*/ HKEY           hKey          ,
                                 /*[in]*/ bool           fExpand       )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey_Value_Write" );

    HRESULT     hr;
    MPC::RegKey rkWrite;


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkWrite.SetRoot( hKey, KEY_ALL_ACCESS ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkWrite.Attach (         lpszKeyName  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkWrite.Create (                      ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkWrite.put_Value( vValue, lpszValueName, fExpand ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey_Value_Write( /*[in]*/ const MPC::wstring& strValue      ,
                                 /*[in]*/ LPCWSTR             lpszKeyName   ,
                                 /*[in]*/ LPCWSTR             lpszValueName ,
                                 /*[in]*/ HKEY                hKey          ,
                                 /*[in]*/ bool                fExpand       )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey_Value_Write" );

    HRESULT     hr;
    MPC::RegKey rkWrite;


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkWrite.SetRoot( hKey, KEY_ALL_ACCESS ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkWrite.Attach (         lpszKeyName  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkWrite.Create (                      ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkWrite.Write( strValue, lpszValueName, fExpand ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::RegKey_Value_Write( /*[in]*/ DWORD   dwValue       ,
                                 /*[in]*/ LPCWSTR lpszKeyName   ,
                                 /*[in]*/ LPCWSTR lpszValueName ,
                                 /*[in]*/ HKEY    hKey          )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::RegKey_Value_Write" );

    HRESULT     hr;
    MPC::RegKey rkWrite;


    __MPC_EXIT_IF_METHOD_FAILS(hr, rkWrite.SetRoot( hKey, KEY_ALL_ACCESS ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkWrite.Attach (         lpszKeyName  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, rkWrite.Create (                      ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, rkWrite.Write( dwValue, lpszValueName ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_mutex.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_Mutex.cpp

Abstract:
    This file contains the implementation of C++ wrappers for Mutex and
    Memory Mapping.

Revision History:
    Davide Massarenti   (Dmassare)  12/14/99
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

MPC::NamedMutex::NamedMutex( LPCWSTR szName, bool fCloseOnRelease )
{
    m_fCloseOnRelease = fCloseOnRelease;    // bool         m_fCloseOnRelease;
    m_szName          = SAFEWSTR( szName ); // MPC::wstring m_szName;
                                            //
    m_hMutex          = NULL;               // HANDLE       m_hMutex;
    m_dwCount         = 0;                  // DWORD        m_dwCount;
}

MPC::NamedMutex::~NamedMutex()
{
    CleanUp();
}

////////////////////

void MPC::NamedMutex::CleanUp()
{
    while(m_dwCount) Release();

    if(m_hMutex)
    {
        ::CloseHandle( m_hMutex ); m_hMutex = NULL;
    }
}

HRESULT MPC::NamedMutex::EnsureInitialized()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NamedMutex::EnsureInitialized" );

    HRESULT hr;


    if(m_hMutex == NULL)
    {
        MPC::SecurityDescriptor sd;
        SECURITY_ATTRIBUTES     ss;

        __MPC_EXIT_IF_METHOD_FAILS(hr, sd.InitializeFromProcessToken( FALSE ));

        //
        // Just allow the capability to lock it.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, sd.Add( (PSID)&sd.s_EveryoneSid, ACCESS_ALLOWED_ACE_TYPE, 0, SYNCHRONIZE ));

        ss.nLength              = sizeof(ss);
        ss.lpSecurityDescriptor = sd.GetSD();
        ss.bInheritHandle       = FALSE;


        if(m_szName.empty())
        {
            m_hMutex = ::CreateMutexW( &ss, FALSE, NULL );
        }
        else
        {
            m_hMutex = ::CreateMutexW( &ss, FALSE, m_szName.c_str() );
            if(m_hMutex == NULL)
            {
                if(::GetLastError() == ERROR_ACCESS_DENIED)
                {
                    m_hMutex = ::OpenMutexW( SYNCHRONIZE, FALSE, m_szName.c_str() );
                }
            }
        }

        if(m_hMutex == NULL)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::GetLastError());
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////

HRESULT MPC::NamedMutex::SetName( LPCWSTR szName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NamedMutex::SetName" );

    HRESULT hr;


    CleanUp();


    m_szName = SAFEWSTR( szName );
    hr       = S_OK;


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::NamedMutex::Acquire( DWORD dwMilliseconds )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NamedMutex::Acquire" );

    HRESULT hr;
    DWORD   dwRes;


    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInitialized());

    if(m_dwCount)
    {
        m_dwCount++;

        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    ////////////////////

    dwRes = ::WaitForSingleObject( m_hMutex, dwMilliseconds );
    if(dwRes == WAIT_FAILED)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ::GetLastError());
    }

    if(dwRes != WAIT_OBJECT_0  &&
       dwRes != WAIT_ABANDONED  )
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, WAIT_TIMEOUT);
    }

    m_dwCount = 1;
    hr        = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::NamedMutex::Release()
{
    if(m_dwCount)
    {
        if(--m_dwCount == 0)
        {
            ::ReleaseMutex( m_hMutex );

            if(m_fCloseOnRelease)
            {
                ::CloseHandle( m_hMutex ); m_hMutex = NULL;
            }
        }
    }

    return S_OK;
}

bool MPC::NamedMutex::IsOwned()
{
    return m_dwCount != 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

MPC::NamedMutexWithState::NamedMutexWithState( LPCWSTR szName, DWORD dwSize, bool fCloseOnRelease ) : NamedMutex( szName, fCloseOnRelease )
{
    m_dwSize = dwSize; // DWORD  m_dwSize;
    m_hMap   = NULL;   // HANDLE m_hMap;
    m_rgData = NULL;   // LPVOID m_rgData;
}

MPC::NamedMutexWithState::~NamedMutexWithState()
{
    CleanUp();
}

////////////////////

void MPC::NamedMutexWithState::CleanUp()
{
    MPC::NamedMutex::CleanUp();

    if(m_rgData)
    {
        ::UnmapViewOfFile( m_rgData ); m_rgData = NULL;
    }

    if(m_hMap)
    {
        ::CloseHandle( m_hMap ); m_hMap = NULL;
    }
}

void MPC::NamedMutexWithState::Flush()
{
    if(m_rgData)
    {
        ::FlushViewOfFile( m_rgData, m_dwSize );
    }
}

HRESULT MPC::NamedMutexWithState::EnsureInitialized()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NamedMutexWithState::EnsureInitialized" );

    HRESULT hr;
    DWORD   dwAccess = FILE_MAP_ALL_ACCESS;
    DWORD   dwRes;


    __MPC_EXIT_IF_METHOD_FAILS(hr, NamedMutex::EnsureInitialized());


    if(m_hMap == NULL)
    {
        MPC::SecurityDescriptor sd;
        SECURITY_ATTRIBUTES     ss;

        __MPC_EXIT_IF_METHOD_FAILS(hr, sd.InitializeFromProcessToken( FALSE ));

        //
        // Just allow the capability to lock it.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, sd.Add( (PSID)&sd.s_EveryoneSid, ACCESS_ALLOWED_ACE_TYPE, 0, FILE_MAP_READ | FILE_MAP_WRITE ));

        ss.nLength              = sizeof(ss);
        ss.lpSecurityDescriptor = sd.GetSD();
        ss.bInheritHandle       = FALSE;


        if(m_szName.empty())
        {
            m_hMap = ::CreateFileMappingW( INVALID_HANDLE_VALUE, &ss, PAGE_READWRITE, 0, m_dwSize, NULL );
            dwRes  = ::GetLastError();
        }
        else
        {
            MPC::wstring szName( m_szName); szName += L"__State";

            m_hMap = ::CreateFileMappingW( INVALID_HANDLE_VALUE, &ss, PAGE_READWRITE, 0, m_dwSize, szName.c_str() );
            dwRes  = ::GetLastError();

            if(m_hMap == NULL)
            {
                if(dwRes != ERROR_ACCESS_DENIED)
                {
                    __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
                }

                dwAccess = FILE_MAP_READ | FILE_MAP_WRITE;

                __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_hMap = ::OpenFileMappingW( dwAccess, FALSE, szName.c_str() )));

                dwRes = ERROR_ALREADY_EXISTS; // Don't try to initialize it.
            }
        }

        if(m_hMap == NULL)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
        }

        __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_rgData = ::MapViewOfFile( m_hMap, dwAccess, 0, 0, m_dwSize )));

        if(dwRes != ERROR_ALREADY_EXISTS)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, Acquire( INFINITE ));

            ::ZeroMemory( m_rgData, m_dwSize );

            Release();
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////

HRESULT MPC::NamedMutexWithState::SetName( LPCWSTR szName )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NamedMutexWithState::SetName" );

    HRESULT hr;


    CleanUp();


    __MPC_EXIT_IF_METHOD_FAILS(hr, NamedMutex::SetName( szName ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::NamedMutexWithState::Acquire( DWORD dwMilliseconds )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NamedMutexWithState::Acquire" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInitialized());

    __MPC_EXIT_IF_METHOD_FAILS(hr, NamedMutex::Acquire( dwMilliseconds ));

    Flush();

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::NamedMutexWithState::Release()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::NamedMutexWithState::Release" );

    HRESULT hr;


    if(IsOwned())
    {
        Flush();

        __MPC_EXIT_IF_METHOD_FAILS(hr, NamedMutex::Release());

        if(IsOwned() == false && m_fCloseOnRelease)
        {
            CleanUp();
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

LPVOID MPC::NamedMutexWithState::GetData()
{
    return m_rgData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_rpc.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_RPC.cpp

Abstract:
    This file contains the implementation of various utility functions.

Revision History:
    Davide Massarenti   (Dmassare)  04/17/99
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::GetCallingPidFromRPC( /*[out]*/ ULONG& pid )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::GetCallingPidFromRPC" );

    HRESULT hr;


    pid = -1;

    __MPC_EXIT_IF_METHOD_FAILS(hr, I_RpcBindingInqLocalClientPID( NULL, &pid ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::GetFileNameFromProcess( /*[in ]*/ HANDLE  		 hProc   , 
									 /*[out]*/ MPC::wstring& strFile )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::GetFileNameFromProcess" );

    HRESULT 		hr;
	DWORD           err;
	BYTE    		rgBuf[MAX_PATH*3];
	UNICODE_STRING* pstr = (UNICODE_STRING*)rgBuf;


	__MPC_EXIT_IF_SYSCALL_FAILS(hr, err, ::NtQueryInformationProcess( hProc, ProcessImageFileName, rgBuf, sizeof(rgBuf), NULL ));

    strFile.assign( pstr->Buffer, pstr->Length );

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::GetFileNameFromPid( /*[in ]*/ ULONG         pid     ,
                                 /*[out]*/ MPC::wstring& strFile )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::GetFileNameFromPid" );

    HRESULT hr;
    HANDLE  hProc = NULL;


    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hProc = ::OpenProcess( PROCESS_ALL_ACCESS, FALSE, pid )));

	__MPC_EXIT_IF_METHOD_FAILS(hr, GetFileNameFromProcess( hProc, strFile ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    if(hProc) ::CloseHandle( hProc );

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::MapDeviceToDiskLetter( /*[out]*/ MPC::wstring& strDevice ,
									/*[out]*/ MPC::wstring& strDisk   )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::MapDeviceToDiskLetter" );

    HRESULT      hr;
	MPC::wstring strOurImageAsDevice;
	WCHAR        rgOurImageAsDevice[MAX_PATH];
	WCHAR        rgOurImageAsDisk  [MAX_PATH];
	LPWSTR       szDevice;
	LPWSTR       szDisk;

	__MPC_EXIT_IF_METHOD_FAILS(hr, GetFileNameFromProcess( ::GetCurrentProcess(), strOurImageAsDevice ));

	__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetModuleFileName( NULL, rgOurImageAsDisk, MAXSTRLEN(rgOurImageAsDisk) ));

	wcsncpy( rgOurImageAsDevice, strOurImageAsDevice.c_str(), MAXSTRLEN(rgOurImageAsDevice) );

	szDevice = rgOurImageAsDevice; szDevice += wcslen(szDevice);
	szDisk   = rgOurImageAsDisk;   szDisk   += wcslen(szDisk  );

	while(1)
	{
		while(szDevice > rgOurImageAsDevice && szDevice[-1] != '\\') szDevice--;
		while(szDisk   > rgOurImageAsDisk   && szDisk  [-1] != '\\') szDisk--;

		if(szDevice == rgOurImageAsDevice ||
		   szDisk   == rgOurImageAsDisk    ) break;

		if(_wcsicmp( szDevice, szDisk )) break;

		*szDevice-- = 0;
		*szDisk--   = 0;
	}

	strDevice = rgOurImageAsDevice;
	strDisk   = rgOurImageAsDisk;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

bool MPC::IsCallerInList( /*[in]*/ const LPCWSTR* rgList, /*[in]*/ const MPC::wstring& strCallerFile )
{
	MPC::wstring strDevice;
	MPC::wstring strDisk;
    MPC::wstring strFile;

	if(SUCCEEDED(MPC::MapDeviceToDiskLetter( strDevice, strDisk )))
	{
		while(*rgList)
		{
			MPC::SubstituteEnvVariables( strFile = *rgList++ );

			if(!_wcsnicmp( strFile.c_str(), strDisk.c_str(), strDisk.size()))
			{
				strFile.replace( 0, strDisk.size(), strDevice.c_str() );
			}

			if(!MPC::StrICmp( strFile, strCallerFile )) return true;
		}
	}

    return false;
}

HRESULT MPC::VerifyCallerIsTrusted( const LPCWSTR* rgList )
{
    ULONG        pid;
    MPC::wstring strCaller;

    if(SUCCEEDED(MPC::GetCallingPidFromRPC( pid            )) &&
       SUCCEEDED(MPC::GetFileNameFromPid  ( pid, strCaller ))  )
    {
        if(IsCallerInList( rgList, strCaller ) == true)
        {
            return S_OK;
        }
    }

    return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_serializer_istream.cpp ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    Utils_Serializer_IStream.cpp

Abstract:
    This file contains the implementation of the Serializer_IStream class,
    which implements the MPC::Serializer interface on top of an IStream.

Revision History:
    Davide Massarenti   (Dmassare)  07/16/2000
        created

******************************************************************************/

#include "stdafx.h"

MPC::Serializer_IStream::Serializer_IStream( /*[in]*/ IStream* stream )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_IStream::Serializer_IStream");

	// CComPtr<IStream> m_stream;

    if(stream)
    {
		m_stream = stream;
	}
	else
	{
		(void)::CreateStreamOnHGlobal( NULL, TRUE, &m_stream );
	}
}

HRESULT MPC::Serializer_IStream::read( /*[in]*/  void*   pBuf   ,
									   /*[in]*/  DWORD   dwLen  ,
									   /*[out]*/ DWORD* pdwRead )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_IStream::read");

    HRESULT hr;
	DWORD   dwRead = 0;


	if(pdwRead) *pdwRead = 0;

	if(m_stream && dwLen)
	{
		if(pBuf == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_POINTER);

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_stream->Read( pBuf, dwLen, &dwRead ));
	}

	if(dwRead != dwLen && pdwRead == NULL)
	{
		__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_HANDLE_EOF);
	}

	if(pdwRead) *pdwRead = dwRead;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer_IStream::write( /*[in]*/ const void* pBuf  ,
										/*[in]*/ DWORD       dwLen )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_IStream::write");

    HRESULT hr;
	DWORD   dwWritten = 0;


	if(m_stream)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_stream->Write( pBuf, dwLen, &dwWritten ));
	}

	if(dwLen != dwWritten)
	{
		__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_HANDLE_DISK_FULL );
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Methods.
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::Serializer_IStream::Reset()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_IStream::Reset");

	HRESULT hr;


	if(m_stream)
	{
		LARGE_INTEGER li = { 0, 0 };

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_stream->Seek( li, STREAM_SEEK_SET, NULL ));
	}

	hr = S_OK;


	__MPC_FUNC_CLEANUP;
	
	__MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer_IStream::GetStream( /*[out]*/ IStream* *pVal )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_IStream::GetStream");

	HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_stream);
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


	(*pVal = m_stream)->AddRef();

	hr = S_OK;


	__MPC_FUNC_CLEANUP;

	__MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_serializer_http.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_Serializer_Http.cpp

Abstract:
    This file contains the implementation of the Serializer_Http class,
    which implements the MPC::Serializer interface,
    to use a HINTERNET handle as the medium for storage.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#include "stdafx.h"


MPC::Serializer_Http::Serializer_Http( /*[in]*/ HINTERNET hReq )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Http::Serializer_Http" );


    m_hReq = hReq;
}

HRESULT MPC::Serializer_Http::read( /*[in]*/  void*   pBuf   ,
									/*[in]*/  DWORD   dwLen  ,
									/*[out]*/ DWORD* pdwRead )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Http::read" );

    HRESULT hr;
    BOOL    fRet;
    DWORD   dwRead = 0;


	if(pdwRead) *pdwRead = 0;

    if(dwLen)
    {
		if(pBuf == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_POINTER);

        fRet = ::InternetReadFile( m_hReq, pBuf, dwLen, &dwRead );
        if(fRet == FALSE)
        {
			dwRead = 0;
        }
    }

	if(dwLen != dwRead && pdwRead == NULL)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
	}

	if(pdwRead) *pdwRead = dwRead;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer_Http::write( /*[in]*/ const void* pBuf  ,
                                     /*[in]*/ DWORD       dwLen )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Http::write" );

    HRESULT hr;
    DWORD   dwWritten;
    BOOL    fRet;


    if(dwLen)
    {
		if(pBuf == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_POINTER);

        fRet = ::InternetWriteFile( m_hReq, pBuf, dwLen, &dwWritten );
        if(fRet == FALSE || dwWritten != dwLen)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_serializer_fake.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_Serializer_Fake.cpp

Abstract:
    This file contains the implementation of the Serializer_Fake class,
    which implements the MPC::Serializer interface,
    to use when you want to calculate the length of an output stream.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#include "stdafx.h"


MPC::Serializer_Fake::Serializer_Fake()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Fake::Serializer_Fake" );


    m_dwSize = 0;
}

HRESULT MPC::Serializer_Fake::read( /*[in]*/  void*   pBuf   ,
									/*[in]*/  DWORD   dwLen  ,
									/*[out]*/ DWORD* pdwRead )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Fake::read" );


    HRESULT hr = E_FAIL;


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer_Fake::write( /*[in]*/ const void* pBuf  ,
                                     /*[in]*/ DWORD       dwLen )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Fake::write" );


    m_dwSize += dwLen;


    __MPC_FUNC_EXIT(S_OK);
}

DWORD MPC::Serializer_Fake::GetSize()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Fake::GetSize" );


    DWORD dwRes = m_dwSize;


    __MPC_FUNC_EXIT(dwRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_serializer_buffering.cpp ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    Utils_Serializer_Buffering.cpp

Abstract:
    This file contains the implementation of the Serializer_Buffering class,
    which implements the MPC::Serializer interface with buffering.

Revision History:
    Davide Massarenti   (Dmassare)  07/16/2000
        created

******************************************************************************/

#include "stdafx.h"

MPC::Serializer_Buffering::Serializer_Buffering( /*[in]*/ Serializer& stream ) : m_stream( stream )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Buffering::Serializer_Buffering");

    				   // MPC::Serializer& stream
    				   // BYTE             m_rgTransitBuffer[1024];
    m_dwAvailable = 0; // DWORD            m_dwAvailable;
    m_dwPos       = 0; // DWORD            m_dwPos;
    m_iMode       = 0; // int              m_iMode;
}

MPC::Serializer_Buffering::~Serializer_Buffering()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Buffering::~Serializer_Buffering");

    (void)Flush();
}

HRESULT MPC::Serializer_Buffering::read( /*[in]*/  void*   pBuf   ,
										 /*[in]*/  DWORD   dwLen  ,
										 /*[out]*/ DWORD* pdwRead )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Buffering::read");

    HRESULT hr;
	BYTE*   pDst = (BYTE*)pBuf;
	DWORD   dwAvailable;
	DWORD   dwCopied;
	DWORD   dwRead = 0;


	if(pdwRead) *pdwRead = 0;

    if(pBuf == NULL && dwLen) __MPC_SET_ERROR_AND_EXIT(hr, E_POINTER);

	//
	// Don't mix read and write accesses.
	//
	if(m_iMode != MODE_READ)
	{
		if(m_iMode == MODE_WRITE) __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);

		m_iMode = MODE_READ;
	}


	while(dwLen)
	{
		dwAvailable = m_dwAvailable - m_dwPos;

		//
		// Copy from buffer.
		//
		if(dwAvailable)
		{
			dwCopied = min(dwAvailable, dwLen);

			::CopyMemory( pDst, &m_rgTransitBuffer[m_dwPos], dwCopied );

			pDst    += dwCopied;
			m_dwPos += dwCopied;
			dwLen   -= dwCopied;
			dwRead  += dwCopied;
			continue;
		}

		//
		// Fill the transit buffer.
		//
		m_dwPos       = 0;
		m_dwAvailable = 0;
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_stream.read( m_rgTransitBuffer, sizeof(m_rgTransitBuffer), &m_dwAvailable ));
		if(m_dwAvailable == 0)
		{
			if(pdwRead) break; // Don't fail, report how much we read up to now.

			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_HANDLE_EOF);
		}
	}

	if(pdwRead) *pdwRead = dwRead;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer_Buffering::write( /*[in]*/ const void* pBuf  ,
										  /*[in]*/ DWORD       dwLen )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Buffering::write");

    HRESULT hr;
	BYTE*   pSrc = (BYTE*)pBuf;
	DWORD   dwAvailable;
	DWORD   dwCopied;


	//
	// Don't mix read and write accesses.
	//
	if(m_iMode != MODE_WRITE)
	{
		if(m_iMode == MODE_READ) __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);

		m_iMode = MODE_WRITE;
	}


	while(dwLen)
	{
		dwAvailable = sizeof(m_rgTransitBuffer) - m_dwPos;

		//
		// Copy to buffer.
		//
		if(dwAvailable)
		{
			dwCopied = min(dwAvailable, dwLen);

			::CopyMemory( &m_rgTransitBuffer[m_dwPos], pSrc, dwCopied );

			pSrc    += dwCopied;
			m_dwPos += dwCopied;
			dwLen   -= dwCopied;
			continue;
		}

		//
		// Fill the transit buffer.
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_stream.write( m_rgTransitBuffer, m_dwPos ));

		m_dwPos = 0;
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Methods.
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::Serializer_Buffering::Reset()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Buffering::Reset");

	HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, Flush());

	m_iMode = 0;
	hr      = S_OK;


	__MPC_FUNC_CLEANUP;

	__MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer_Buffering::Flush()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Buffering::Flush");

	HRESULT hr;


    if(m_iMode == MODE_WRITE && m_dwPos)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_stream.write( m_rgTransitBuffer, m_dwPos ));

		m_dwPos = 0;
	}

	hr = S_OK;


	__MPC_FUNC_CLEANUP;

	__MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_serializer_file.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_Serializer_File.cpp

Abstract:
    This file contains the implementation of the Serializer_File class,
    which implements the MPC::Serializer interface,
    to use the filesystem as the medium for storage.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#include "stdafx.h"


MPC::Serializer_File::Serializer_File( /*[in]*/ HANDLE hfFile )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_File::Serializer_File" );


    m_hfFile = hfFile;
}

HRESULT MPC::Serializer_File::read( /*[in]*/  void*   pBuf   ,
									/*[in]*/  DWORD   dwLen  ,
									/*[out]*/ DWORD* pdwRead )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_File::read" );

    HRESULT hr;
    DWORD   dwRead = 0;


	if(pdwRead) *pdwRead = 0;

    if(dwLen)
    {
		if(pBuf == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_POINTER);

        if(::ReadFile( m_hfFile, pBuf, dwLen, &dwRead, NULL ) == FALSE)
        {
            DWORD dwRes = ::GetLastError();

            if(dwRes != ERROR_MORE_DATA)
            {
                __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes );
            }
        }
	}

	if(dwRead != dwLen && pdwRead == NULL)
	{
		__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_HANDLE_EOF );
    }

	if(pdwRead) *pdwRead = dwRead;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer_File::write( /*[in]*/ const void* pBuf ,
                                     /*[in]*/ DWORD       dwLen )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_File::write" );

    HRESULT hr;
    DWORD   dwWritten;


    if(dwLen)
    {
		if(pBuf == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_POINTER);

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::WriteFile( m_hfFile, pBuf, dwLen, &dwWritten, NULL ));

        if(dwWritten != dwLen)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_HANDLE_DISK_FULL );
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\unittest\cabinet\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

//
// Warning, always leave these includes BEFORE <atlbase.h>, otherwise you won't get the right MSXML.
//
#define __msxml_h__
#include <basetyps.h>
typedef interface IXMLElement IXMLElement;
#include <msxml.h>
#undef  __msxml_h__
#include <msxml.h>

#include <atlbase.h>

extern CComModule _Module;

#include <MPC_main.h>
#include <MPC_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_serializer_text.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_Serializer_Text.cpp

Abstract:
    This file contains the implementation of the Serializer_Text class,
    which wraps another MPC::Serializer, simply converting everything to HEX.

Revision History:
    Davide Massarenti   (Dmassare)  01/27/99
        created

******************************************************************************/

#include "stdafx.h"

static BYTE	HexToNum( BYTE c )
{
	switch( c )
	{
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9': return c - '0';

	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F': return c - 'A' + 10;

	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f': return c - 'a' + 10;
	}

	return 0;
}

static BYTE	NumToHex( BYTE c )
{
	return (c &= 0xF) < 10 ? (c + '0') : (c + 'A' - 10);
}


HRESULT MPC::Serializer_Text::read( /*[in]*/  void*   pBuf   ,
									/*[in]*/  DWORD   dwLen  ,
									/*[out]*/ DWORD* pdwRead )
{
	__MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Text::read" );

	HRESULT hr;


	if(pdwRead) *pdwRead = dwLen; // We don't support partial read on this stream!

	if(dwLen)
	{
		BYTE* pPtr = (BYTE*)pBuf;

		if(pBuf == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_POINTER);

		while(dwLen--)
		{
			BYTE  buf[2];
			DWORD dwRead;
		
			__MPC_EXIT_IF_METHOD_FAILS(hr, m_stream.read( buf, sizeof(buf) ));

			*pPtr++ = (HexToNum( buf[0] ) << 4) | HexToNum( buf[1] );
		}
	}

	hr = S_OK;
	
	
	__MPC_FUNC_CLEANUP;
	
	__MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer_Text::write( /*[in]*/ const void* pBuf ,
								     /*[in]*/ DWORD       dwLen )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Text::write" );

    HRESULT hr;


	if(dwLen)
	{
		const BYTE* pPtr = (const BYTE*)pBuf;

		if(pBuf == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_POINTER);

		while(dwLen--)
		{
			BYTE  buf[2];
			DWORD dwRead;
			BYTE  bOut = *pPtr++;

			buf[0] = NumToHex( bOut >> 4 );
			buf[1] = NumToHex( bOut      );

			__MPC_EXIT_IF_METHOD_FAILS(hr, m_stream.write( buf, sizeof(buf) ));
		}
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_url.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_URL.cpp

Abstract:
    This file contains the implementation of functions for parsing URLs.

Revision History:
    Davide Massarenti   (Dmassare)  04/17/99
        created
    Davide Massarenti   (Dmassare)  05/16/99
        Added MPC::URL class.

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const WCHAR l_mkPrefix[] = L"mk:@";

////////////////////////////////////////////////////////////////////////////////

static HRESULT AllocBuffer( /*[out]*/ LPWSTR& szBuf   ,
                            /*[out]*/ DWORD&  dwCount ,
                            /*[in] */ DWORD   dwSize  )
{
    dwCount =           dwSize;
    szBuf   = new WCHAR[dwSize];

    return (szBuf ? S_OK : E_OUTOFMEMORY);
}


MPC::URL::URL()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::URL" );


    ::ZeroMemory( (PVOID)&m_ucURL, sizeof(m_ucURL) );
    m_ucURL.dwStructSize = sizeof(m_ucURL);
}

MPC::URL::~URL()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::~URL" );


    Clean();
}

void MPC::URL::Clean()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::Clean" );


    delete [] m_ucURL.lpszScheme   ;
    delete [] m_ucURL.lpszHostName ;
    delete [] m_ucURL.lpszUrlPath  ;
    delete [] m_ucURL.lpszExtraInfo;

    ::ZeroMemory( (PVOID)&m_ucURL, sizeof(m_ucURL) );
    m_ucURL.dwStructSize = sizeof(m_ucURL);
}

HRESULT MPC::URL::Prepare()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::Prepare" );

    HRESULT hr;


    Clean();

    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocBuffer( m_ucURL.lpszScheme   , m_ucURL.dwSchemeLength   , MAX_PATH ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocBuffer( m_ucURL.lpszHostName , m_ucURL.dwHostNameLength , MAX_PATH ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocBuffer( m_ucURL.lpszUrlPath  , m_ucURL.dwUrlPathLength  , MAX_PATH ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocBuffer( m_ucURL.lpszExtraInfo, m_ucURL.dwExtraInfoLength, MAX_PATH ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::URL::CheckFormat( /*[in]*/ bool fDecode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::CheckFormat" );

    HRESULT hr;
    LPCWSTR szURL = m_szURL.c_str();
    bool    fMkHack = false;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Prepare());

    //
    // InternetCrackURL doesn't like mk:@MSITSTORE:, so we have to work around it...
    //
    if(!_wcsnicmp( szURL, l_mkPrefix, MAXSTRLEN( l_mkPrefix ) ))
    {
        szURL   += MAXSTRLEN( l_mkPrefix );
        fMkHack  = true;
    }

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::InternetCrackUrlW( szURL, 0, fDecode ? ICU_DECODE : 0, &m_ucURL ));

    if(fMkHack)
    {
        MPC::wstring szTmp = m_ucURL.lpszScheme;

        wcscpy( m_ucURL.lpszScheme, l_mkPrefix    );
        wcscat( m_ucURL.lpszScheme, szTmp.c_str() );
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::URL::Append( /*[in]*/ const MPC::wstring& szExtra ,
                          /*[in]*/ bool                fEscape )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::Append" );

    HRESULT hr;


    hr = Append( szExtra.c_str(), fEscape );


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::URL::Append( /*[in]*/ LPCWSTR szExtra ,
                          /*[in]*/ bool    fEscape )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::Append" );

    HRESULT hr;


    if(fEscape == false)
    {
        m_szURL.append( szExtra );
    }
    else
    {
		MPC::HTML::UrlEscape( m_szURL, szExtra, /*fAsQueryString*/true );
    }

    hr = S_OK;


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::URL::AppendQueryParameter( /*[in]*/ LPCWSTR szName  ,
                                        /*[in]*/ LPCWSTR szValue )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::AppendQueryParameter" );

    HRESULT hr;
    LPCWSTR szSeparator;

    __MPC_EXIT_IF_METHOD_FAILS(hr, CheckFormat());


    //
    // If it's the first parameter, append '?', otherwise append '&'.
    //
    szSeparator = (m_ucURL.lpszExtraInfo[0] == 0) ? L"?" : L"&";
    m_szURL.append( szSeparator ); Append( szName , true );
    m_szURL.append( L"="        ); Append( szValue, true );

    hr = S_OK; 


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::URL::get_URL( /*[out]*/ MPC::wstring& szURL )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::get_URL" );

    HRESULT hr;


    szURL = m_szURL;
    hr    = S_OK;


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::URL::put_URL( /*[in]*/ const MPC::wstring& szURL )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::put_URL" );

    HRESULT hr;


    hr = put_URL( szURL.c_str() );


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::URL::put_URL( /*[in]*/ LPCWSTR szURL )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::put_URL" );

    HRESULT hr;


    Clean();

    m_szURL = szURL;

    hr = CheckFormat();


    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::URL::get_Scheme( /*[out]*/ MPC::wstring& szVal ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::get_Scheme" );

    HRESULT hr;


    szVal = m_ucURL.lpszScheme;
    hr    = S_OK;


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::URL::get_Scheme( /*[out]*/ INTERNET_SCHEME& nVal ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::get_Scheme" );

    HRESULT hr;


    nVal = m_ucURL.nScheme;
    hr   = S_OK;


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::URL::get_HostName( /*[out]*/ MPC::wstring& szVal ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::get_HostName" );

    HRESULT hr;


    szVal = m_ucURL.lpszHostName;
    hr    = S_OK;


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::URL::get_Port( /*[out]*/ DWORD& dwVal ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::get_Port" );

    HRESULT hr;


    dwVal = m_ucURL.nPort;
    hr    = S_OK;


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::URL::get_Path( /*[out]*/ MPC::wstring& szVal ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::get_Path" );

    HRESULT hr;


    szVal = m_ucURL.lpszUrlPath;
    hr    = S_OK;


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::URL::get_ExtraInfo( /*[out]*/ MPC::wstring& szVal ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::URL::get_ExtraInfo" );

    HRESULT hr;


    szVal = m_ucURL.lpszExtraInfo;
    hr    = S_OK;


    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_threadpool.cpp ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    Utils_ThreadPool.cpp

Abstract:
    This file contains the implementation of classes to wrapper the thread-pooling API.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/2001
        created

******************************************************************************/

#include "stdafx.h"

MPC::Pooling::Base::Base()
{
                        // MPC::CComSafeAutoCriticalSection m_cs;
    m_dwInCallback = 0; // DWORD                            m_dwInCallback;
	m_dwThreadID   = 0; // DWORD                            m_dwThreadID;
}

void MPC::Pooling::Base::Lock()
{
    m_cs.Lock();

    if(m_dwInCallback && m_dwThreadID != ::GetCurrentThreadId())
    {
		//
		// Wait for the callback to finish.
		//
		while(m_dwInCallback)
		{
			m_cs.Unlock();
			::Sleep( 1 );
			m_cs.Lock();
		}
	}
}

void MPC::Pooling::Base::Unlock()
{
    m_cs.Unlock();
}

void MPC::Pooling::Base::AddRef()
{
    DWORD dwThreadID = ::GetCurrentThreadId();

    m_cs.Lock();

    while(m_dwInCallback && m_dwThreadID != dwThreadID)
    {
        m_cs.Unlock();
        ::Sleep( 1 );
        m_cs.Lock();
    }

    m_dwInCallback++;
    m_dwThreadID = dwThreadID;

    m_cs.Unlock();
}

void MPC::Pooling::Base::Release()
{
    m_cs.Lock();

    if(m_dwInCallback) m_dwInCallback--;

	if(!m_dwInCallback) m_dwThreadID = 0;

    m_cs.Unlock();
}

////////////////////////////////////////////////////////////////////////////////

MPC::Pooling::Timer::Timer( /*[in]*/ DWORD dwFlags )
{
    m_dwFlags = dwFlags;              // DWORD  m_dwFlags;
    m_hTimer  = INVALID_HANDLE_VALUE; // HANDLE m_hTimer;
}

MPC::Pooling::Timer::~Timer()
{
    (void)Reset();
}

VOID CALLBACK MPC::Pooling::Timer::TimerFunction( PVOID lpParameter, BOOLEAN TimerOrWaitFired )
{
    MPC::Pooling::Timer* pThis = (MPC::Pooling::Timer*)lpParameter;

    pThis->AddRef();

    pThis->Execute( TimerOrWaitFired );

    pThis->Release();
}

HRESULT MPC::Pooling::Timer::Set( /*[in]*/ DWORD dwTimeout, /*[in]*/ DWORD dwPeriod )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Pooling::Timer::Set" );

    HRESULT                     hr;
	MPC::SmartLockGeneric<Base> lock( this );


	//
	// Unfortunately, we cannot hold any lock while trying to destroy the timer...
	//
	while(m_hTimer != INVALID_HANDLE_VALUE)
	{
		lock = NULL;

		__MPC_EXIT_IF_METHOD_FAILS(hr, Reset());

		lock = this;
	}


    if(dwTimeout)
    {
		__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::CreateTimerQueueTimer( &m_hTimer, NULL, TimerFunction, this, dwTimeout, dwPeriod, m_dwFlags ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Pooling::Timer::Reset()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Pooling::Timer::Reset" );

    HRESULT hr;
    HANDLE  hTimer;


	//
	// Unfortunately, we cannot hold any lock while trying to destroy the timer...
	//
    Lock();

	hTimer   = m_hTimer;
	m_hTimer = INVALID_HANDLE_VALUE;

    Unlock();


    if(hTimer != INVALID_HANDLE_VALUE)
    {
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::DeleteTimerQueueTimer( NULL, hTimer, INVALID_HANDLE_VALUE ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;


    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Pooling::Timer::Execute( BOOLEAN TimerOrWaitFired )
{
    return S_FALSE;
}

////////////////////////////////////////////////////////////////////////////////

MPC::Pooling::Event::Event( /*[in]*/ DWORD dwFlags )
{
                             // MPC::CComSafeAutoCriticalSection m_cs;
    m_dwFlags     = dwFlags; // DWORD                            m_dwFlags;
    m_hWaitHandle = NULL;    // HANDLE                           m_hWaitHandle;
    m_hEvent      = NULL;    // HANDLE                           m_hEvent;
}

MPC::Pooling::Event::~Event()
{
    (void)Reset();
}

VOID CALLBACK MPC::Pooling::Event::WaitOrTimerFunction( PVOID lpParameter, BOOLEAN TimerOrWaitFired )
{
    MPC::Pooling::Event* pThis = (MPC::Pooling::Event*)lpParameter;

    pThis->AddRef();

    pThis->Signaled( TimerOrWaitFired );

    pThis->Release();
}

void MPC::Pooling::Event::Attach( /*[in]*/ HANDLE hEvent )
{
    Reset();

    Lock();

    m_hEvent = hEvent;

    Unlock();
}

HRESULT MPC::Pooling::Event::Set( /*[in]*/ DWORD dwTimeout )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Pooling::Event::Set" );

    HRESULT                     hr;
	MPC::SmartLockGeneric<Base> lock( this );


	//
	// Unfortunately, we cannot hold any lock while trying to destroy the event...
	//
	while(m_hWaitHandle)
	{
		lock = NULL;

		__MPC_EXIT_IF_METHOD_FAILS(hr, Reset());

		lock = this;
	}

    if(m_hEvent)
    {
        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::RegisterWaitForSingleObject( &m_hWaitHandle, m_hEvent, WaitOrTimerFunction, this, dwTimeout, m_dwFlags ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Pooling::Event::Reset()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Pooling::Event::Reset" );

    HRESULT hr;
    HANDLE  hWaitHandle;
	DWORD   dwThreadID;


	//
	// Unfortunately, we cannot hold any lock while trying to destroy the event...
	//
    Lock();

	dwThreadID    = m_dwThreadID;
	hWaitHandle   = m_hWaitHandle;
	m_hWaitHandle = NULL;

	Unlock();


    if(hWaitHandle)
    {
		if(dwThreadID == ::GetCurrentThreadId()) // Same thread, it would deadlock...
		{
			(void)::UnregisterWaitEx( hWaitHandle, NULL );
		}
		else
		{
			__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::UnregisterWaitEx( hWaitHandle, INVALID_HANDLE_VALUE ));
		}
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Pooling::Event::Signaled( BOOLEAN TimerOrWaitFired )
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\unittest\cabinet\test_cabinet.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    test_Cabinet.cpp

Abstract:
    This file contains the Unit Test for Cabinet functions.

Revision History:
    Davide Massarenti   (Dmassare)  09/03/99
        created

******************************************************************************/

#include "stdafx.h"
#include <iostream>

#include <string>
#include <list>

//////////////////////////////////////////////////////////////////////

HRESULT fnCallback_Files( MPC::Cabinet* cabinet, LPCWSTR szFile, ULONG lDone, ULONG lTotal, LPVOID user )
{
	HRESULT hr = S_OK;

	return hr;
}

HRESULT fnCallback_Bytes( MPC::Cabinet* cabinet, ULONG lDone, ULONG lTotal, LPVOID user )
{
	HRESULT hr = S_OK;

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
int __cdecl wmain( int     argc   ,
                   LPCWSTR argv[] )
{
	HRESULT hr;

	if(argc > 1)
	{
		if(!_wcsicmp( argv[1], L"COMPRESS" ))
		{
			if(argc < 5)
			{
				wprintf( L"Usage: %s COMPRESS <File to compress> <Cabinet file> <Name in cabinet>\n", argv[0] );
				exit( 10 );
			}

			if(FAILED(hr = MPC::CompressAsCabinet( argv[2], argv[3], argv[4] )))
			{
				wprintf( L"Error: %08lx\n", hr );
			}
		}

		if(!_wcsicmp( argv[1], L"COMPRESS_MULTI" ))
		{
			if(argc < 4)
			{
				wprintf( L"Usage: %s COMPRESS_MULTI <Cabinet file> <File> ...\n", argv[0] );
				exit( 10 );
			}

			MPC::WStringList lst;

			for(int i = 3; i<argc; i++)
			{
				lst.push_back( MPC::wstring( argv[i] ) );
			}

			if(FAILED(hr = MPC::CompressAsCabinet( lst, argv[2] )))
			{
				wprintf( L"Error: %08lx\n", hr );
			}
		}

		if(!_wcsicmp( argv[1], L"COMPRESS_PROGRESS" ))
		{
			if(argc < 4)
			{
				wprintf( L"Usage: %s COMPRESS_PROGRESS <Cabinet file> <File> ...\n", argv[0] );
				exit( 10 );
			}

			MPC::Cabinet cab;

			for(int i = 3; i<argc; i++)
			{
				cab.AddFile( argv[i] );
			}
		
			cab.put_CabinetFile     ( argv[2]          );
			cab.put_onProgress_Files( fnCallback_Files );
			cab.put_onProgress_Bytes( fnCallback_Bytes );

			if(FAILED(hr = cab.Compress()))
			{
				wprintf( L"Error: %08lx\n", hr );
			}
		}

		if(!_wcsicmp( argv[1], L"UNCOMPRESS" ))
		{
			if(argc < 5)
			{
				wprintf( L"Usage: %s UNCOMPRESS <Cabinet file> <Output file> <Name in cabinet>\n", argv[0] );
				exit( 10 );
			}

			if(FAILED(hr = MPC::DecompressFromCabinet( argv[2], argv[3], argv[4] )))
			{
				wprintf( L"Error: %08lx\n", hr );
			}
		}

		if(!_wcsicmp( argv[1], L"LIST" ))
		{
			if(argc < 3)
			{
				wprintf( L"Usage: %s LIST <Cabinet file>\n", argv[0] );
				exit( 10 );
			}

			MPC::WStringList      lst;
			MPC::WStringIterConst it;
			int                   i;

			if(FAILED(hr = MPC::ListFilesInCabinet( argv[2], lst )))
			{
				wprintf( L"Error: %08lx\n", hr );
			}

			for(i=0, it=lst.begin(); it != lst.end(); it++, i++)
			{
				wprintf( L"File %d: %s\n", i, (*it).c_str() );
			}
		}
	}

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_serializer_memory.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Utils_Serializer_Memory.cpp

Abstract:
    This file contains the implementation of the Serializer_Memory class,
    which implements the MPC::Serializer interface,
    to use a memory buffer as the medium for storage.

Revision History:
    Davide Massarenti   (Dmassare)  04/15/99
        created

******************************************************************************/

#include "stdafx.h"


#define SERIALIZER_MEMORY_CHUNKS (8192)


MPC::Serializer_Memory::Serializer_Memory( /*[in]*/ HANDLE hHeap )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::Serializer_Memory");


    m_hHeap          = hHeap ? hHeap : ::GetProcessHeap();
    m_pData          = NULL;
    m_dwAllocated    = 0;
    m_dwSize         = 0;
    m_fFixed         = false;

    m_dwCursor_Read  = 0;
    m_dwCursor_Write = 0;
}

MPC::Serializer_Memory::~Serializer_Memory()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::~Serializer_Memory");

    Reset();
}

HRESULT MPC::Serializer_Memory::read( /*[in]*/  void*   pBuf   ,
									  /*[in]*/  DWORD   dwLen  ,
									  /*[out]*/ DWORD* pdwRead )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::read");

    HRESULT hr;
    DWORD   dwAvailable = m_dwCursor_Write - m_dwCursor_Read;


	if(pdwRead) *pdwRead = 0;

    if(dwLen > dwAvailable)
    {
		if(pdwRead == NULL)
		{
			if(m_dwCursor_Write < m_dwSize)
			{
				hr = E_PENDING; __MPC_FUNC_LEAVE;
			}

			__MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_HANDLE_EOF);
		}

		dwLen = dwAvailable; // pdwRead not null, read as much as possible.
    }

    if(dwLen)
    {
		if(pBuf == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_POINTER);

        ::CopyMemory( pBuf, &m_pData[m_dwCursor_Read], dwLen );

        m_dwCursor_Read += dwLen;
    }

	if(pdwRead) *pdwRead = dwLen;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::Serializer_Memory::write( /*[in]*/ const void* pBuf ,
                                       /*[in]*/ DWORD       dwLen )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::write");

    HRESULT hr;
    DWORD   dwAvailable = m_dwSize - m_dwCursor_Write;


    if(dwLen > dwAvailable)
    {
        if(m_fFixed)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_HANDLE_DISK_FULL);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, Alloc( m_dwCursor_Write + dwLen));
    }

    if(dwLen)
    {
		if(pBuf == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_POINTER);

        ::CopyMemory( &m_pData[m_dwCursor_Write], pBuf, dwLen );

        m_dwCursor_Write += dwLen;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Protected Methods.
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::Serializer_Memory::Alloc( /*[in]*/ DWORD dwSize )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::Alloc");

    HRESULT hr;
    BYTE*   pData;


    //
    // Memory already allocated, simply update the size indicator.
    //
    if(dwSize <= m_dwAllocated)
    {
        m_dwSize = dwSize;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    //
    // Calculate the amount to allocate.
    //
    while(dwSize > m_dwAllocated)
    {
        m_dwAllocated += SERIALIZER_MEMORY_CHUNKS;
    }


    if(m_pData) pData = (BYTE*)::HeapReAlloc( m_hHeap, 0, m_pData, m_dwAllocated );
    else        pData = (::BYTE*)HeapAlloc  ( m_hHeap, 0,          m_dwAllocated );

    if(pData == NULL)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
    }

    m_pData  = pData;
    m_dwSize = dwSize;

    if(m_dwCursor_Read > m_dwSize) m_dwCursor_Read = m_dwSize;
    if(m_dwCursor_Read > m_dwSize) m_dwCursor_Read = m_dwSize;

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Methods.
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


void MPC::Serializer_Memory::Reset()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::Reset");

    if(m_pData) ::HeapFree( m_hHeap, 0, m_pData );

    m_pData          = NULL;
    m_dwAllocated    = 0;
    m_dwSize         = 0;
    m_fFixed         = false;

    m_dwCursor_Read  = 0;
    m_dwCursor_Write = 0;
}

void MPC::Serializer_Memory::Rewind()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::Rewind");

    m_dwCursor_Read = 0;
}


bool MPC::Serializer_Memory::IsEOR()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::IsEOR");

    bool res = (m_dwCursor_Read == m_dwSize);


    __MPC_FUNC_EXIT(res);
}

bool MPC::Serializer_Memory::IsEOW()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::IsEOW");

    bool fRes = (m_dwCursor_Write == m_dwSize);


    __MPC_FUNC_EXIT(fRes);
}


DWORD MPC::Serializer_Memory::GetAvailableForRead()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::GetAvailableForRead");

    DWORD dwRes = (m_dwCursor_Write - m_dwCursor_Read);


    __MPC_FUNC_EXIT(dwRes);
}

DWORD MPC::Serializer_Memory::GetAvailableForWrite()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::GetAvailableForWrite");

    DWORD dwRes = (m_dwSize - m_dwCursor_Write);


    __MPC_FUNC_EXIT(dwRes);
}


HRESULT MPC::Serializer_Memory::SetSize( /*[in]*/ DWORD dwSize )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::SetSize");

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Alloc( dwSize ));

    m_fFixed         = true;
    m_dwCursor_Read  = 0;
    m_dwCursor_Write = 0;
    hr               = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

DWORD MPC::Serializer_Memory::GetSize()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::GetSize");

    DWORD dwRes = m_dwSize;


    __MPC_FUNC_EXIT(dwRes);
}

BYTE* MPC::Serializer_Memory::GetData()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::Serializer_Memory::GetData");

    BYTE* pRes = m_pData;


    __MPC_FUNC_EXIT(pRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\utils_storageobject.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Utils_StorageObject.cpp

Abstract:
    This file contains the implementation of the MPC::StorageObject, which is
    used to manipulate IStorage-like files.

Revision History:
    Davide Massarenti   (Dmassare)  10/20/2000
        created

******************************************************************************/

#include "stdafx.h"

#include <ITSS\msitstg.h>

////////////////////////////////////////////////////////////////////////////////

MPC::StorageObject::Stat::Stat()
{
    ::ZeroMemory( this, sizeof( *this ) );
}

MPC::StorageObject::Stat::~Stat()
{
    Clean();
}

void MPC::StorageObject::Stat::Clean()
{
    if(pwcsName)
    {
        ::CoTaskMemFree( pwcsName );
    }

    ::ZeroMemory( this, sizeof( *this ) );
}

////////////////////////////////////////

MPC::StorageObject::StorageObject( /*[in]*/ DWORD          grfMode  ,
                                   /*[in]*/ bool           fITSS    ,
                                   /*[in]*/ LPCWSTR        szPath   ,
                                   /*[in]*/ StorageObject* soParent )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::StorageObject" );

    Init( grfMode, fITSS, szPath, soParent );
}

MPC::StorageObject::~StorageObject()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::~StorageObject" );

    Clean( /*fFinal*/true );
}

MPC::StorageObject& MPC::StorageObject::operator=( /*[in]*/ LPCWSTR szPath )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::operator=" );

    Clean( /*fFinal*/false );


    if(szPath)
    {
        m_bstrPath = szPath;
    }

    return *this;
}

////////////////////

void MPC::StorageObject::Init( /*[in]*/ DWORD          grfMode  ,
                               /*[in]*/ bool           fITSS    ,
                               /*[in]*/ LPCWSTR        szPath   ,
                               /*[in]*/ StorageObject* soParent )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::Init" );

    m_parent   			 = soParent; // StorageObject*    m_parent;
               						 // CComBSTR          m_bstrPath;
    m_fITSS    			 = fITSS;    // bool              m_fITSS;
    m_grfMode  			 = grfMode;  // DWORD             m_grfMode;
               						 //
    m_type     			 = 0;        // DWORD             m_type;
               						 // Stat              m_stat;
               						 // CComPtr<IStorage> m_stg;
               						 // CComPtr<IStream>  m_stream;
               						 //
    m_fChecked 			 = false;    // bool              m_fChecked;
    m_fScanned 			 = false;    // bool              m_fScanned;
    m_fMarkedForDeletion = false;    // bool              m_fMarkedForDeletion;
               						 // List              m_lstChilds;


    if(szPath)
    {
        m_bstrPath = szPath;
    }
}

void MPC::StorageObject::Clean( /*[in]*/ bool fFinal )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::Clean" );

                                              // StorageObject*    m_parent;
                                              // CComBSTR          m_bstrPath;
                                              // bool              m_fITSS;
                                              // DWORD             m_grfMode;
                                              //
    m_type = 0;                               // DWORD             m_type;
    m_stat  .Clean  ();                       // Stat              m_stat;
    m_stg   .Release();                       // CComPtr<IStorage> m_stg;
    m_stream.Release();                       // CComPtr<IStream>  m_stream;
                                              //
    m_fChecked = false;                       // bool              m_fChecked;
    m_fScanned = false;                       // bool              m_fScanned;
                                              // bool              m_fMarkedForDeletion;
    MPC::CallDestructorForAll( m_lstChilds ); // List              m_lstChilds;

    if(fFinal)
    {
        m_parent = NULL;
        m_bstrPath.Empty();
    }
}

////////////////////

HRESULT MPC::StorageObject::Compact()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::Compact" );

    HRESULT hr;

    Clean( /*fFinal*/false );

    if(m_parent == NULL || m_parent->m_stg == NULL)
    {
        if(m_fITSS)
        {
            CComPtr<IITStorage> pITStorage;

            __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_ITStorage, NULL, CLSCTX_INPROC_SERVER, IID_ITStorage, (VOID **)&pITStorage ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, pITStorage->Compact( m_bstrPath, COMPACT_DATA ));
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::StorageObject::Exists()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::Exists" );

    HRESULT hr;


    if(m_fChecked)
    {
        //
        // Already checked.
        //
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    if(m_parent == NULL || m_parent->m_stg == NULL)
    {
        m_type = STGTY_STORAGE;

        if(m_fITSS)
        {
            CComPtr<IITStorage> pITStorage;

            __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_ITStorage, NULL, CLSCTX_INPROC_SERVER, IID_ITStorage, (VOID **)&pITStorage ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, pITStorage->StgOpenStorage( m_bstrPath, NULL, STGM_SHARE_EXCLUSIVE | m_grfMode, NULL, 0, &m_stg ));
        }
        else
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, ::StgOpenStorageEx( m_bstrPath, STGM_SHARE_EXCLUSIVE | m_grfMode, STGFMT_STORAGE, 0, NULL, NULL, IID_IStorage, (VOID **)&m_stg ));
        }
    }
    else
    {
        if(m_type == STGTY_STORAGE)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->m_stg->OpenStorage( m_bstrPath, NULL, STGM_SHARE_EXCLUSIVE | m_grfMode, 0, 0, &m_stg ));
        }
        else
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->m_stg->OpenStream( m_bstrPath, NULL, STGM_SHARE_EXCLUSIVE | m_grfMode, 0, &m_stream ));
        }
    }

    m_fChecked = true;
    hr         = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::StorageObject::Scan()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::Scan" );

    HRESULT        hr;
    StorageObject* soChild = NULL;


    //
    // Before proceeding, check if we really need to scan the object.
    //
    if(m_fScanned == true)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    if(m_fChecked == false)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, Exists());
    }

    if(m_stg)
    {
        CComPtr<IEnumSTATSTG> pEnum;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_stg->EnumElements( 0, NULL, 0, &pEnum ));
        while(1)
        {
            ULONG lFetched = 0;

            __MPC_EXIT_IF_ALLOC_FAILS(hr, soChild, new StorageObject( m_grfMode, m_fITSS, NULL, this ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, pEnum->Next( 1, &soChild->m_stat, &lFetched ));
            if(lFetched == 0) break;

            soChild->m_bstrPath = soChild->m_stat.pwcsName;
            soChild->m_type     = soChild->m_stat.type;

            m_lstChilds.push_back( soChild ); soChild = NULL;
        }
    }

    m_fScanned = true;
    hr         = S_OK;


    __MPC_FUNC_CLEANUP;

    if(soChild) delete soChild;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::StorageObject::RemoveChild( /*[in]*/ StorageObject* child )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::RemoveChild" );

    HRESULT    hr;
    IterConst it;


    for(it=m_lstChilds.begin(); it != m_lstChilds.end(); it++)
    {
        StorageObject* obj = *it;

        if(obj == child)
        {
            if(m_stg)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_stg->DestroyElement( obj->m_bstrPath ));
            }

			if(obj->m_fMarkedForDeletion == false)
			{
				m_lstChilds.erase( it );

				delete obj;
			}
            break;
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::StorageObject::EnumerateSubStorages( /*[out]*/ List& lstSubStorages )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::EnumerateSubStorages" );

    HRESULT   hr;
    IterConst it;


    lstSubStorages.clear();


    //
    // Do a shallow scan if the object is not initialized.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());


    for(it=m_lstChilds.begin(); it != m_lstChilds.end(); it++)
    {
        StorageObject* obj = *it;

        if(obj->m_stat.type == STGTY_STORAGE)
        {
            lstSubStorages.push_back( obj );
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::StorageObject::EnumerateStreams( /*[out]*/ List& lstStreams )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::EnumerateStreams" );

    HRESULT   hr;
    IterConst it;


    lstStreams.clear();


    //
    // Do a shallow scan if the object is not initialized.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());


    for(it=m_lstChilds.begin(); it != m_lstChilds.end(); it++)
    {
        StorageObject* obj = *it;

        if(obj->m_stat.type == STGTY_STREAM)
        {
            lstStreams.push_back( obj );
        }
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::StorageObject::GetStorage( /*[out]*/ CComPtr<IStorage>& out )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::GetStorage" );

    HRESULT   hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Exists());

    out = m_stg;
    hr  = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::StorageObject::GetStream( /*[out]*/ CComPtr<IStream>& out )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::GetStream" );

    HRESULT   hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Exists());
	__MPC_EXIT_IF_METHOD_FAILS(hr, Rewind());

    out = m_stream;
    hr  = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::StorageObject::GetChild( /*[in ]*/ LPCWSTR         szName  ,
                                      /*[out]*/ StorageObject*& child   ,
                                      /*[in ]*/ DWORD           grfMode ,
                                      /*[in ]*/ DWORD           type    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::GetChild" );

    HRESULT        hr;
    StorageObject* soChild = NULL;
    IterConst      it;


    child = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, Scan());

    for(it=m_lstChilds.begin(); it != m_lstChilds.end(); it++)
    {
        StorageObject* obj = *it;

        if(!MPC::StrICmp( szName, obj->m_bstrPath ))
        {
            child = obj;
            break;
        }
    }

	if(type) // Means "create new object"
	{
		if(child)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, child->Delete()); child = NULL;
		}

        __MPC_EXIT_IF_ALLOC_FAILS(hr, soChild, new StorageObject( grfMode, m_fITSS, NULL, this ));

        soChild->m_type     = type;
        soChild->m_bstrPath = szName;

        __MPC_EXIT_IF_METHOD_FAILS(hr, soChild->Create());

        child = soChild;
        m_lstChilds.push_back( soChild ); soChild = NULL;
    }

    hr  = S_OK;


    __MPC_FUNC_CLEANUP;

    if(soChild) delete soChild;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::StorageObject::Create()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::Create" );

    HRESULT hr;


    m_stg   .Release();
    m_stream.Release();
    m_fChecked = false;


    if(m_parent == NULL || m_parent->m_stg == NULL)
    {
        m_type = STGTY_STORAGE;

        if(m_fITSS)
        {
            CComPtr<IITStorage> pITStorage;

            __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_ITStorage, NULL, CLSCTX_INPROC_SERVER, IID_ITStorage, (VOID **)&pITStorage ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, pITStorage->StgCreateDocfile( m_bstrPath, STGM_CREATE | STGM_SHARE_EXCLUSIVE | m_grfMode, 0, &m_stg ));
        }
        else
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, ::StgCreateStorageEx( m_bstrPath, STGM_CREATE | STGM_SHARE_EXCLUSIVE | m_grfMode, STGFMT_STORAGE, 0, NULL, NULL, IID_IStorage, (VOID **)&m_stg ));
        }
    }
    else
    {
        if(m_type == STGTY_STORAGE)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->m_stg->CreateStorage( m_bstrPath, STGM_SHARE_EXCLUSIVE | m_grfMode, 0, 0, &m_stg ));
        }
        else
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->m_stg->CreateStream( m_bstrPath, STGM_SHARE_EXCLUSIVE | m_grfMode, 0, 0, &m_stream ));
        }
    }

    m_fChecked = true;
    hr         = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::StorageObject::Rewind()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::Rewind" );

    HRESULT hr;


    if(m_stream)
    {
        LARGE_INTEGER  libMove; libMove.QuadPart = 0;
        ULARGE_INTEGER libNewPos;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_stream->Seek( libMove, STREAM_SEEK_SET, &libNewPos ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::StorageObject::Truncate()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::Truncate" );

    HRESULT hr;


    if(m_stream)
    {
        ULARGE_INTEGER libNewSize; libNewSize.QuadPart = 0;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_stream->SetSize( libNewSize ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::StorageObject::Delete()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::Delete" );

    HRESULT hr;


    if(FAILED(hr = Exists()))
    {
        if(hr == STG_E_FILENOTFOUND)
        {
            hr = S_OK;
        }

        __MPC_FUNC_LEAVE;
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, DeleteChildren());

    m_stg   .Release();
    m_stream.Release();
    m_fChecked = false;

    if(m_parent)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->RemoveChild( this ));
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DeleteFile( m_bstrPath ));
    }


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::StorageObject::DeleteChildren()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::StorageObject::DeleteChildren" );

    HRESULT   hr;
    IterConst it;


    if(FAILED(hr = Scan()))
    {
        if(hr == STG_E_FILENOTFOUND)
        {
            hr = S_OK;
        }

        __MPC_FUNC_LEAVE;
    }


    for(it=m_lstChilds.begin(); it != m_lstChilds.end(); it++)
    {
        StorageObject* obj = *it;

		obj->m_fMarkedForDeletion = true; // Protect against early garbage collection.

        __MPC_EXIT_IF_METHOD_FAILS(hr, obj->Delete());
    }
    MPC::CallDestructorForAll( m_lstChilds );

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

void MPC::StorageObject::Release()
{
    Clean( false );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\xmlutil.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    XmlUtil.cpp

Abstract:
    This file contains the implementation of the XmlUtil class,
    the support class for handling XML data.

Revision History:
    Davide Massarenti   (Dmassare)  04/17/99
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE AsyncXMLParser : public CComObjectRootEx<CComMultiThreadModel>, public IDispatch
{
	CComPtr<IXMLDOMDocument> m_xddDoc;
	HANDLE                   m_hEvent;
	HRESULT                  m_hr;

	void SetHandler( IDispatch* obj )
	{
		if(m_xddDoc)
		{
			VARIANT v;

			v.vt       = VT_DISPATCH;
			v.pdispVal = obj;

			m_xddDoc->put_onreadystatechange( v );

			if(obj)
			{
				m_xddDoc->put_async( VARIANT_TRUE );
			}
		}
	}

	void Init( IXMLDOMDocument* xddDoc ,
			   HANDLE           hEvent )
	{
        MPC::SmartLock<_ThreadModel> lock( this );

		Clean();

		m_xddDoc = xddDoc;
		m_hEvent = hEvent; if(hEvent) ::ResetEvent( hEvent );
		m_hr     = E_ABORT;

		SetHandler( this );
	}

	void Clean()
	{
        MPC::SmartLock<_ThreadModel> lock( this );

		//
		// Before releasing the object, unregister from event notification.
		//
		SetHandler( NULL );

		m_xddDoc.Release();
		m_hEvent = NULL;
	}

public:
	BEGIN_COM_MAP(AsyncXMLParser)
		COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

	AsyncXMLParser()
	{
							// CComPtr<IXMLDOMDocument> m_xddDoc;
		m_hEvent = NULL;    // HANDLE                   m_hEvent;
		m_hr     = E_ABORT; // HRESULT                  m_hr;
	}

	~AsyncXMLParser()
	{
		Clean();
	}

	HRESULT Load( /*[in]*/ IXMLDOMDocument* xddDoc    ,
				  /*[in]*/ HANDLE           hEvent    ,
				  /*[in]*/ DWORD            dwTimeout ,
				  /*[in]*/ CComVariant&     v         )
	{
		__MPC_FUNC_ENTRY( COMMONID, "AsyncXMLParser::Load" );

		HRESULT                      hr;
        MPC::SmartLock<_ThreadModel> lock( this );
		VARIANT_BOOL 				 fSuccess;
		DWORD                        dwRes;

		Init( xddDoc, hEvent );

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->load( v, &fSuccess ));

		lock  = NULL;
		dwRes = MPC::WaitForSingleObject( hEvent, dwTimeout );
		lock  = this;

		hr = m_hr;


		__MPC_FUNC_CLEANUP;

		Clean();

		if(xddDoc && hr == E_ABORT) xddDoc->abort();

		__MPC_FUNC_EXIT(hr);
	}

public:
	//
	// IDispatch
	//
	STDMETHOD(GetTypeInfoCount)( UINT* pctinfo )
	{
		return E_NOTIMPL;
	}

	STDMETHOD(GetTypeInfo)( UINT        itinfo  ,
							LCID        lcid    ,
							ITypeInfo* *pptinfo )
	{
		return E_NOTIMPL;
	}

	STDMETHOD(GetIDsOfNames)( REFIID    riid      ,
							  LPOLESTR* rgszNames ,
							  UINT      cNames    ,
							  LCID      lcid      ,
							  DISPID*   rgdispid  )
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Invoke)( DISPID      dispidMember ,
					   REFIID      riid         ,
					   LCID        lcid         ,
					   WORD        wFlags       ,
					   DISPPARAMS* pdispparams  ,
					   VARIANT*    pvarResult   ,
					   EXCEPINFO*  pexcepinfo   ,
					   UINT*       puArgErr     )
	{
        MPC::SmartLock<_ThreadModel> lock( this );

		if(m_hEvent && m_xddDoc)
		{
			long state;

			if(SUCCEEDED(m_xddDoc->get_readyState( &state )) && state == 4) // COMPLETED
			{
				CComPtr<IXMLDOMParseError> pError;

				if(FAILED(m_xddDoc->get_parseError( &pError )) || !pError || FAILED(pError->get_errorCode( &m_hr ))) m_hr = E_ABORT;

				::SetEvent( m_hEvent );
			}
		}

		return S_OK;
	}
};

////////////////////////////////////////////////////////////////////////////////

static HRESULT getStartNode( /*[in ]*/ LPCWSTR               szTag        ,
                             /*[in ]*/ IXMLDOMNode*          pxdnNode     ,
                             /*[out]*/ CComPtr<IXMLDOMNode>& xdnNodeStart ,
                             /*[out]*/ bool&                 fFound       )
{
    __MPC_FUNC_ENTRY( COMMONID, "getStartNode" );

    HRESULT hr;

    //
    // Initialize OUT parameters for 'Not Found' case.
    //
    xdnNodeStart = NULL;
    fFound       = false;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(pxdnNode); // No root...
	__MPC_PARAMCHECK_END();


    if(szTag)
    {
        CComBSTR tagName = szTag;

        __MPC_EXIT_IF_METHOD_FAILS(hr, pxdnNode->selectSingleNode( tagName, &xdnNodeStart ));
    }
    else
    {
        xdnNodeStart = pxdnNode;
    }

    if(xdnNodeStart)
    {
        fFound = true;
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

static HRESULT getValueNode( /*[in ]*/ IXMLDOMNode*          pxdnNode ,
                             /*[out]*/ CComPtr<IXMLDOMNode>& xdnValue ,
                             /*[out]*/ bool&                 fFound   )
{
    __MPC_FUNC_ENTRY( COMMONID, "getValueNode" );

    _ASSERT(pxdnNode != NULL);

    HRESULT                  hr;
    CComPtr<IXMLDOMNodeList> xdnlList;
    CComPtr<IXMLDOMNode>     xdnChild;


    //
    // Initialize OUT parameters for 'Not Found' case.
    //
    xdnValue = NULL;
    fFound   = false;

    //
    // Get all the childs of given element.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, pxdnNode->get_childNodes( &xdnlList ));

    //
    // Walk through all the child, searching for a TEXT or CDATA_SECTION.
    //
    for(;SUCCEEDED(hr = xdnlList->nextNode( &xdnChild )) && xdnChild != NULL; xdnChild = NULL)
    {
        DOMNodeType nodeType;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xdnChild->get_nodeType( &nodeType ));

        if(nodeType == NODE_TEXT          ||
           nodeType == NODE_CDATA_SECTION  )
        {
            //
            // Found...
            //
            xdnValue = xdnChild;
            fFound   = true;
            break;
        }
    }


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

MPC::XmlUtil::XmlUtil( /*[in]*/ const XmlUtil& xml )
{
	m_xddDoc  = xml.m_xddDoc;
	m_xdnRoot = xml.m_xdnRoot;

	Init();
}

MPC::XmlUtil::XmlUtil( /*[in]*/ IXMLDOMDocument* xddDoc    ,
					   /*[in]*/ LPCWSTR          szRootTag )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::XmlUtil" );

    CComPtr<IXMLDOMElement> xdeElem;
    CComPtr<IXMLDOMNode>    xdnRoot;


	Init();


    if(SUCCEEDED(xddDoc->get_documentElement( &xdeElem )))
    {
        if(SUCCEEDED(xdeElem->QueryInterface( IID_IXMLDOMNode, (void **)&xdnRoot )))
        {
            *this = xdnRoot;
        }
    }

	if(szRootTag)
	{
		bool fLoaded;
		bool fFound;

		(void)LoadPost( szRootTag, fLoaded, &fFound );
	}
}

MPC::XmlUtil::XmlUtil( /*[in]*/ IXMLDOMNode* xdnRoot   ,
					   /*[in]*/ LPCWSTR      szRootTag )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::XmlUtil" );


	Init(); *this = xdnRoot;


	if(szRootTag)
	{
		bool fLoaded;
		bool fFound;

		(void)LoadPost( szRootTag, fLoaded, &fFound );
	}
}


MPC::XmlUtil::~XmlUtil()
{
	Clean();
}


MPC::XmlUtil& MPC::XmlUtil::operator=( /*[in]*/ const XmlUtil& xml )
{
	m_xddDoc  = xml.m_xddDoc;
	m_xdnRoot = xml.m_xdnRoot;

	return *this;
}

MPC::XmlUtil& MPC::XmlUtil::operator=( /*[in]*/ IXMLDOMNode* xdnRoot )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::operator=" );


    m_xddDoc  = NULL;
    m_xdnRoot = NULL;

    if(xdnRoot)
    {
        if(SUCCEEDED(xdnRoot->get_ownerDocument( &m_xddDoc )))
        {
            m_xdnRoot = xdnRoot;
        }
    }

	return *this;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void MPC::XmlUtil::Init()
{
	m_hEvent    = ::CreateEvent( NULL, FALSE, TRUE, NULL ); // HANDLE m_hEvent;
	m_dwTimeout = INFINITE;                                 // DWORD  m_dwTimeout;
}

void MPC::XmlUtil::Clean()
{
	if(m_hEvent)
	{
		::CloseHandle( m_hEvent );
		m_hEvent = NULL;
	}
}


HRESULT MPC::XmlUtil::CreateParser()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::CreateParser" );

    HRESULT hr;

    m_xddDoc .Release();
    m_xdnRoot.Release();

    //
    // Create the DOM object.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**)&m_xddDoc ));

	//
	// Set synchronous operation.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->put_async( VARIANT_FALSE ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::New( /*[in]*/ IXMLDOMNode* xdnRoot,
                           /*[in]*/ BOOL         fDeep  )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::New" );

    HRESULT                  hr;
    CComPtr<IXMLDOMDocument> xddDoc;
    CComPtr<IXMLDOMNode>     xdnNode;
    CComPtr<IXMLDOMNodeList> xdnlList;
    CComPtr<IXMLDOMNode>     xdnChild;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(xdnRoot);
	__MPC_PARAMCHECK_END();



    //
    // Create the parser.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateParser());


    //
    // Search the processing elements in the document to clone.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xdnRoot->get_ownerDocument(                           &xddDoc   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xddDoc ->QueryInterface   ( IID_IXMLDOMNode, (void **)&xdnNode  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNode->get_childNodes   (                           &xdnlList )); xdnNode = NULL;

    for(;SUCCEEDED(hr = xdnlList->nextNode( &xdnChild )) && xdnChild != NULL; xdnChild = NULL)
    {
        DOMNodeType nodeType;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xdnChild->get_nodeType( &nodeType ));

        //
        // It's a processing element, so clone it.
        //
        if(nodeType == NODE_PROCESSING_INSTRUCTION)
        {
            CComPtr<IXMLDOMNode> xdnChildCloned;
            CComPtr<IXMLDOMNode> xdnChildNew;

            __MPC_EXIT_IF_METHOD_FAILS(hr, xdnChild->cloneNode  ( VARIANT_TRUE  , &xdnChildCloned ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->appendChild( xdnChildCloned, &xdnChildNew    ));
        }
    }


    //
    // Clone the node.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xdnRoot->cloneNode( fDeep ? VARIANT_TRUE : VARIANT_FALSE, &xdnNode ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->appendChild( xdnNode, &m_xdnRoot ));


    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::New( /*[in]*/ LPCWSTR szRootTag  ,
                           /*[in]*/ LPCWSTR szEncoding )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::New" );

    HRESULT hr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szRootTag);
	__MPC_PARAMCHECK_END();


    //
    // Create the parser.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateParser());


    //
    // XML header.
    //
	{
		CComPtr<IXMLDOMProcessingInstruction> xdpiElem;
		CComPtr<IXMLDOMNode>                  xdnNode;
		CComPtr<IXMLDOMNode>                  xdnNodeNew;
		CComBSTR                              bstrData( L"version=\"1.0\" encoding=\"" );
		CComBSTR                              bstrPI  ( L"xml"                         );

		bstrData.Append( szEncoding );
		bstrData.Append( "\""       );

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->createProcessingInstruction( bstrPI, bstrData, &xdpiElem ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, xdpiElem->QueryInterface( IID_IXMLDOMNode, (void **)&xdnNode ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->appendChild( xdnNode, &xdnNodeNew ));
	}

    //
    // Create the root node.
    //
	{
		CComPtr<IXMLDOMNode>    xdnNode;
		CComPtr<IXMLDOMElement> xdeElem;

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->createElement( CComBSTR( szRootTag ), &xdeElem ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, xdeElem->QueryInterface( IID_IXMLDOMNode, (void **)&xdnNode ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->appendChild( xdnNode, &m_xdnRoot ));
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::LoadPost( /*[in ]*/ LPCWSTR szRootTag ,
                                /*[out]*/ bool&   fLoaded   ,
                                /*[out]*/ bool*   fFound    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::LoadPost" );

    HRESULT hr;


    if(szRootTag)
    {
		CComBSTR             bstrTag( szRootTag );
        CComPtr<IXMLDOMNode> xdnNode;

		if(m_xdnRoot)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, m_xdnRoot->selectSingleNode( bstrTag, &xdnNode ));
		}
		else
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->selectSingleNode( bstrTag, &xdnNode ));
		}

		m_xdnRoot = xdnNode;
    }
    else
    {
        CComPtr<IXMLDOMElement> xdeElem;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->get_documentElement( &xdeElem ));

		m_xdnRoot.Release();

		if(xdeElem)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, xdeElem->QueryInterface( IID_IXMLDOMNode, (void **)&m_xdnRoot ));
		}
    }

    if(m_xdnRoot)
    {
        if(fFound) *fFound = true;
    }

    fLoaded = true;
    hr      = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::Load( /*[in ]*/ LPCWSTR szFile    ,
                            /*[in ]*/ LPCWSTR szRootTag ,
                            /*[out]*/ bool&   fLoaded   ,
                            /*[out]*/ bool*   fFound    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::Load" );

    HRESULT                 hr;
	CComVariant             v( szFile );
	CComPtr<AsyncXMLParser> pAsync;

    fLoaded = false;
    if(fFound) *fFound = false;


    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateParser());

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstanceNoLock( &pAsync ));

	if(FAILED(pAsync->Load( m_xddDoc, m_hEvent, m_dwTimeout, v )))
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadPost( szRootTag, fLoaded, fFound ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::LoadAsStream( /*[in ]*/ IUnknown* pStream   ,
                                    /*[in ]*/ LPCWSTR   szRootTag ,
                                    /*[out]*/ bool&     fLoaded   ,
                                    /*[out]*/ bool*     fFound    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::LoadAsStream" );

    HRESULT                 hr;
	CComVariant             v( pStream );
	CComPtr<AsyncXMLParser> pAsync;

    fLoaded = false;
    if(fFound) *fFound = false;

    //
    // Create the parser.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateParser());


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstanceNoLock( &pAsync ));

	if(FAILED(pAsync->Load( m_xddDoc, m_hEvent, m_dwTimeout, v )))
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
	}

    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadPost( szRootTag, fLoaded, fFound ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::LoadAsString( /*[in ]*/ BSTR    bstrData  ,
                                    /*[in ]*/ LPCWSTR szRootTag ,
                                    /*[out]*/ bool&   fLoaded   ,
                                    /*[out]*/ bool*   fFound    )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::LoadAsString" );

    HRESULT      hr;
    VARIANT_BOOL fSuccess;


    fLoaded = false;
    if(fFound) *fFound = false;

    //
    // Create the parser.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CreateParser());


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->loadXML( bstrData, &fSuccess ));
    if(fSuccess == VARIANT_FALSE)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadPost( szRootTag, fLoaded, fFound ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::XmlUtil::Save( /*[in]*/ LPCWSTR szFile )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::Save" );

    HRESULT hr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(m_xddDoc); // No document...
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szFile);
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->save( CComVariant( szFile ) ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::SaveAsStream( /*[out]*/ IUnknown* *ppStream )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::SaveAsStream" );

    HRESULT hr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(m_xddDoc); // No document...
		__MPC_PARAMCHECK_POINTER_AND_SET(ppStream,NULL);
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->QueryInterface( IID_IStream, (void **)ppStream ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::SaveAsString( /*[out]*/ BSTR *pbstrData )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::SaveAsString" );

    HRESULT hr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(m_xddDoc); // No document...
		__MPC_PARAMCHECK_POINTER_AND_SET(pbstrData,NULL);
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->get_xml( pbstrData ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::XmlUtil::DumpError()
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::DumpError" );

    HRESULT                    hr;
    CComPtr<IXMLDOMParseError> pxdpeError;
    long                       lErrorCode;
    CComBSTR                   bstrUrlString;
    CComBSTR                   bstrReasonString;
    CComBSTR                   bstrSourceString;
    long                       lLineNumber;
    long                       lLinePosition;
    long                       lFilePosition;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(m_xddDoc); // No document...
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->get_parseError( &pxdpeError ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, pxdpeError->get_errorCode( &lErrorCode       ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pxdpeError->get_url      ( &bstrUrlString    ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pxdpeError->get_reason   ( &bstrReasonString ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pxdpeError->get_srcText  ( &bstrSourceString ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pxdpeError->get_line     ( &lLineNumber      ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pxdpeError->get_linepos  ( &lLinePosition    ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pxdpeError->get_filepos  ( &lFilePosition    ));

    // CODEWORK: dump error information.


    __MPC_FUNC_CLEANUP;


    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::XmlUtil::SetTimeout( /*[in]*/ DWORD dwTimeout ) { m_dwTimeout = dwTimeout;                 return S_OK; }
HRESULT MPC::XmlUtil::Abort     (                          ) { if(m_hEvent) { ::SetEvent( m_hEvent ); } return S_OK; }

HRESULT MPC::XmlUtil::SetVersionAndEncoding( /*[in]*/ LPCWSTR szVersion  ,
                                             /*[in]*/ LPCWSTR szEncoding )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::SetVersionAndEncoding" );

    HRESULT                               hr;
    CComPtr<IXMLDOMProcessingInstruction> xdpiElem;
    CComPtr<IXMLDOMNode>                  xdnOldPI;
    CComPtr<IXMLDOMNode>                  xdnNewPI;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->get_firstChild( &xdnOldPI ));
    if(xdnOldPI)
    {
        CComBSTR bstrTarget = L"xml";
        CComBSTR bstrData   = L"version=\"";


        bstrData.Append( szVersion         );
        bstrData.Append( L"\" encoding=\"" );
        bstrData.Append( szEncoding        );
        bstrData.Append( "\""              );


        __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->createProcessingInstruction( bstrTarget, bstrData, &xdpiElem ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, xdpiElem->QueryInterface( IID_IXMLDOMNode, (void **)&xdnNewPI ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->replaceChild( xdnNewPI, xdnOldPI, NULL ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::GetDocument( /*[out]*/ IXMLDOMDocument* *pVal ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::GetDocument" );

    HRESULT hr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(m_xddDoc); // No document...
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
	__MPC_PARAMCHECK_END();


    hr = m_xddDoc->QueryInterface( IID_IXMLDOMDocument, (void **)pVal );


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::GetRoot( /*[out]*/ IXMLDOMNode* *pVal ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::GetRoot" );

    HRESULT hr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(m_xdnRoot); // No document...
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
	__MPC_PARAMCHECK_END();


    hr = m_xdnRoot->QueryInterface( IID_IXMLDOMNode, (void **)pVal );


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::GetNodes( /*[in ]*/ LPCWSTR           szTag ,
                                /*[out]*/ IXMLDOMNodeList* *pVal  ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::GetNodes" );

    HRESULT  hr;
    CComBSTR bstrTagName = szTag;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(m_xdnRoot); // No root...
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szTag);
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
	__MPC_PARAMCHECK_END();


    hr = m_xdnRoot->selectNodes( bstrTagName, pVal );


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::GetNode( /*[in ]*/ LPCWSTR       szTag ,
                               /*[out]*/ IXMLDOMNode* *pVal  ) const
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::GetNode" );

    HRESULT hr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(m_xdnRoot); // No root...
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szTag);
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
	__MPC_PARAMCHECK_END();


    hr = m_xdnRoot->selectSingleNode( CComBSTR( szTag ), pVal );


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::CreateNode( /*[in ]*/ LPCWSTR       szTag    ,
                                  /*[out]*/ IXMLDOMNode* *pVal     ,
                                  /*[in ]*/ IXMLDOMNode*  pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::CreateNode" );

    HRESULT                 hr;
    CComPtr<IXMLDOMElement> xdeElem;
    CComPtr<IXMLDOMNode>    xdnChild;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szTag);
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
	__MPC_PARAMCHECK_END();


	if(m_xdnRoot)
	{
		if(pxdnNode == NULL) { pxdnNode = m_xdnRoot; } // Use root as base of search, if no base node is supplied.

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->createElement( CComBSTR( szTag ), &xdeElem ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, xdeElem->QueryInterface( IID_IXMLDOMNode, (void **)&xdnChild ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, pxdnNode->appendChild( xdnChild, pVal ));
	}
	else
	{
		//
		// No document, so create a new one or attach to the supplied node's document.
		//
		if(pxdnNode)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, New( pxdnNode ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, CreateNode( szTag, pVal ));
		}
		else
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, New( szTag ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, GetRoot( pVal ));
		}
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::XmlUtil::GetAttribute( /*[in ]*/ LPCWSTR            szTag    ,
                                    /*[in ]*/ LPCWSTR            szAttr   ,
                                    /*[out]*/ IXMLDOMAttribute* *pVal     ,
                                    /*[out]*/ bool&              fFound   ,
                                    /*[in ]*/ IXMLDOMNode*       pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::GetAttribute" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> xdnNodeStart;
    CComPtr<IXMLDOMNode> xdnAttr;

    //
    // Initialize OUT parameters for 'Not Found' case.
    //
    fFound = false;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
	__MPC_PARAMCHECK_END();


    if(pxdnNode == NULL) { pxdnNode = m_xdnRoot; } // Use root as base of search, if no base node is supplied.


    __MPC_EXIT_IF_METHOD_FAILS(hr, getStartNode( szTag, pxdnNode, xdnNodeStart, fFound ));
    if(fFound == false)
    {
        // Node not found...
        fFound = false;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    if(szAttr)
    {
        CComBSTR                     bstrAttrName = szAttr;
        CComPtr<IXMLDOMNamedNodeMap> xdnnmAttrs;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNodeStart->get_attributes( &xdnnmAttrs ));
        if(xdnnmAttrs == NULL)
        {
            // No attributes...
            fFound = false;
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }


        __MPC_EXIT_IF_METHOD_FAILS(hr, xdnnmAttrs->getNamedItem( bstrAttrName, &xdnAttr ));
        if(hr == S_FALSE)
        {
            // Unknown attribute...
            fFound = false;
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, xdnAttr->QueryInterface( IID_IXMLDOMAttribute, (void**)pVal ));
    }
    else
    {
        CComQIPtr<IXMLDOMAttribute> xdaAttr;

        xdaAttr = xdnNodeStart;
        if(xdaAttr == NULL)
        {
            // Unknown attribute...
            fFound = false;
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        *pVal = xdaAttr.Detach();
    }

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::GetAttribute( /*[in ]*/ LPCWSTR       szTag    ,
                                    /*[in ]*/ LPCWSTR       szAttr   ,
                                    /*[out]*/ CComBSTR&     bstrVal  ,
                                    /*[out]*/ bool&         fFound   ,
                                    /*[in ]*/ IXMLDOMNode*  pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::GetAttribute" );

    HRESULT                   hr;
    CComPtr<IXMLDOMAttribute> xdaAttr;
    CComVariant               vValue;


    bstrVal.Empty();

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetAttribute( szTag, szAttr, &xdaAttr, fFound, pxdnNode ));
    if(fFound == false)
    {
        // Unknown attribute...
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, xdaAttr->get_value( &vValue ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, vValue.ChangeType( VT_BSTR ));

    bstrVal = vValue.bstrVal;
    fFound  = true;
    hr      = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::GetAttribute( /*[in ]*/ LPCWSTR       szTag    ,
                                    /*[in ]*/ LPCWSTR       szAttr   ,
                                    /*[out]*/ MPC::wstring& szVal    ,
                                    /*[out]*/ bool&         fFound   ,
                                    /*[in ]*/ IXMLDOMNode*  pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::GetAttribute" );

    HRESULT  hr;
    CComBSTR bstrVal;


    szVal = L"";


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetAttribute( szTag, szAttr, bstrVal, fFound, pxdnNode ));
    if(fFound)
    {
        szVal = SAFEBSTR( bstrVal );
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::GetAttribute( /*[in ]*/ LPCWSTR      szTag    ,
                                    /*[in ]*/ LPCWSTR      szAttr   ,
                                    /*[out]*/ LONG&        lVal     ,
                                    /*[out]*/ bool&        fFound   ,
                                    /*[in ]*/ IXMLDOMNode* pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::GetAttribute" );

    HRESULT                   hr;
    CComPtr<IXMLDOMAttribute> xdaAttr;
    CComVariant               vValue;


    lVal = 0;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetAttribute( szTag, szAttr, &xdaAttr, fFound, pxdnNode ));
    if(fFound == false)
    {
        // Unknown attribute...
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, xdaAttr->get_value( &vValue ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, vValue.ChangeType( VT_I4 ));

    lVal   = vValue.lVal;
    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::XmlUtil::GetValue( /*[in ]*/ LPCWSTR      szTag    ,
                                /*[out]*/ CComVariant& vValue   ,
                                /*[out]*/ bool&        fFound   ,
                                /*[in ]*/ IXMLDOMNode* pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::GetValue" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> xdnNodeStart;
    CComPtr<IXMLDOMNode> xdnChild;


    vValue.Clear();

    if(pxdnNode == NULL) { pxdnNode = m_xdnRoot; } // Use root as base of search, if no base node is supplied.


    __MPC_EXIT_IF_METHOD_FAILS(hr, getStartNode( szTag, pxdnNode, xdnNodeStart, fFound ));
    if(fFound == false)
    {
        // Node not found...
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    //
    // Find the node holding the value.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, getValueNode( xdnNodeStart, xdnChild, fFound ));
    if(fFound == false)
    {
        //
        // Not found...
        //
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    //
    // Read the value.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xdnChild->get_nodeValue( &vValue ));

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}


HRESULT MPC::XmlUtil::GetValue( /*[in ]*/ LPCWSTR      szTag     ,
                                /*[out]*/ CComBSTR&    bstrValue ,
                                /*[out]*/ bool&        fFound    ,
                                /*[in ]*/ IXMLDOMNode* pxdnNode  )
{
    HRESULT     hr;
    CComVariant vValue;

    if(SUCCEEDED(hr = GetValue( szTag, vValue, fFound, pxdnNode )))
    {
        if(fFound && SUCCEEDED(vValue.ChangeType( VT_BSTR )))
        {
            bstrValue = vValue.bstrVal;
        }
    }

    return hr;
}

HRESULT MPC::XmlUtil::GetValue( /*[in ]*/ LPCWSTR       szTag    ,
                                /*[out]*/ MPC::wstring& szValue  ,
                                /*[out]*/ bool&         fFound   ,
                                /*[in ]*/ IXMLDOMNode*  pxdnNode )
{
    HRESULT     hr;
    CComVariant vValue;

    if(SUCCEEDED(hr = GetValue( szTag, vValue, fFound, pxdnNode )))
    {
        if(fFound && SUCCEEDED(vValue.ChangeType( VT_BSTR )))
        {
            szValue = SAFEBSTR( vValue.bstrVal );
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::XmlUtil::ModifyAttribute( /*[in ]*/ LPCWSTR         szTag    ,
                                       /*[in ]*/ LPCWSTR         szAttr   ,
                                       /*[in ]*/ const CComBSTR& bstrVal  ,
                                       /*[out]*/ bool&           fFound   ,
                                       /*[in ]*/ IXMLDOMNode*    pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::ModifyAttribute" );

    HRESULT                   hr;
    CComPtr<IXMLDOMAttribute> xdaAttr;
    CComVariant               vValue( bstrVal );


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetAttribute( szTag, szAttr, &xdaAttr, fFound, pxdnNode ));
    if(fFound == false)
    {
        // Unknown attribute...
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, xdaAttr->put_value( vValue ));

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::ModifyAttribute( /*[in ]*/ LPCWSTR             szTag    ,
									   /*[in ]*/ LPCWSTR             szAttr   ,
									   /*[in ]*/ const MPC::wstring& szVal    ,
									   /*[out]*/ bool&               fFound   ,
									   /*[in ]*/ IXMLDOMNode*        pxdnNode )
{
	return ModifyAttribute( szTag, szAttr, SAFEWSTR( szVal.c_str() ), fFound, pxdnNode );
}

HRESULT MPC::XmlUtil::ModifyAttribute( /*[in ]*/ LPCWSTR      szTag    ,
                                       /*[in ]*/ LPCWSTR      szAttr   ,
									   /*[in ]*/ LPCWSTR      szVal    ,
                                       /*[out]*/ bool&        fFound   ,
                                       /*[in ]*/ IXMLDOMNode* pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::ModifyAttribute" );

    HRESULT                   hr;
    CComPtr<IXMLDOMAttribute> xdaAttr;
    CComVariant               vValue( szVal );


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetAttribute( szTag, szAttr, &xdaAttr, fFound, pxdnNode ));
    if(fFound == false)
    {
        // Unknown attribute...
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, xdaAttr->put_value( vValue ));

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::ModifyAttribute( /*[in ]*/ LPCWSTR      szTag    ,
                                       /*[in ]*/ LPCWSTR      szAttr   ,
                                       /*[in ]*/ LONG         lVal     ,
                                       /*[out]*/ bool&        fFound   ,
                                       /*[in ]*/ IXMLDOMNode* pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::ModifyAttribute" );

    HRESULT                   hr;
    CComPtr<IXMLDOMAttribute> xdaAttr;
    CComVariant               vValue( lVal );


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetAttribute( szTag, szAttr, &xdaAttr, fFound, pxdnNode ));
    if(fFound == false)
    {
        // Unknown attribute...
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, xdaAttr->put_value( vValue ));

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::XmlUtil::ModifyValue( /*[in ]*/ LPCWSTR            szTag    ,
                                   /*[in ]*/ const CComVariant& vValue   ,
                                   /*[out]*/ bool&              fFound   ,
                                   /*[in ]*/ IXMLDOMNode*       pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::ModifyValue" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> xdnNodeStart;
    CComPtr<IXMLDOMNode> xdnChild;


    if(pxdnNode == NULL) { pxdnNode = m_xdnRoot; } // Use root as base of search, if no base node is supplied.


    __MPC_EXIT_IF_METHOD_FAILS(hr, getStartNode( szTag, pxdnNode, xdnNodeStart, fFound ));
    if(fFound == false)
    {
        // Node not found...
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    //
    // Find the node holding the value.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, getValueNode( xdnNodeStart, xdnChild, fFound ));
    if(fFound == false)
    {
        //
        // Not found...
        //
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    //
    // Modify the value.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xdnChild->put_nodeValue( vValue ));

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::ModifyValue( /*[in ]*/ LPCWSTR         szTag     ,
                                   /*[in ]*/ const CComBSTR& bstrValue ,
                                   /*[out]*/ bool&           fFound    ,
                                   /*[out]*/ IXMLDOMNode*    pxdnNode  )
{
    CComVariant vValue = bstrValue;

    return ModifyValue( szTag, vValue, fFound, pxdnNode );
}

HRESULT MPC::XmlUtil::ModifyValue( /*[in ]*/ LPCWSTR             szTag    ,
                                   /*[in ]*/ const MPC::wstring& szValue  ,
                                   /*[out]*/ bool&               fFound   ,
                                   /*[out]*/ IXMLDOMNode*        pxdnNode )
{
    CComVariant vValue = szValue.c_str();

    return ModifyValue( szTag, vValue, fFound, pxdnNode );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::XmlUtil::PutAttribute( /*[in ]*/ LPCWSTR            szTag    ,
                                    /*[in ]*/ LPCWSTR            szAttr   ,
                                    /*[out]*/ IXMLDOMAttribute* *pVal     ,
                                    /*[out]*/ bool&              fFound   ,
                                    /*[in ]*/ IXMLDOMNode*       pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::PutAttribute" );

    HRESULT                      hr;
    CComBSTR                     bstrAttrName = szAttr;
    CComPtr<IXMLDOMNode>         xdnNodeStart;
    CComPtr<IXMLDOMNamedNodeMap> xdnnmAttrs;
    CComPtr<IXMLDOMNode>         xdnAttr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(szAttr);
		__MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
	__MPC_PARAMCHECK_END();


    if(pxdnNode == NULL) { pxdnNode = m_xdnRoot; } // Use root as base of search, if no base node is supplied.


    __MPC_EXIT_IF_METHOD_FAILS(hr, getStartNode( szTag, pxdnNode, xdnNodeStart, fFound ));
    if(fFound == false)
    {
        // Node not found...
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNodeStart->get_attributes( &xdnnmAttrs ));
    if(xdnnmAttrs == NULL)
    {
        // No attributes...
        fFound = false;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, xdnnmAttrs->getNamedItem( bstrAttrName, &xdnAttr ));
    if(hr == S_FALSE)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->createAttribute( bstrAttrName, pVal ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, xdnnmAttrs->setNamedItem( *pVal, NULL ));
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, xdnAttr->QueryInterface( IID_IXMLDOMAttribute, (void**)pVal ));
    }

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::PutAttribute( /*[in ]*/ LPCWSTR         szTag    ,
                                    /*[in ]*/ LPCWSTR         szAttr   ,
                                    /*[in ]*/ const CComBSTR& bstrVal  ,
                                    /*[out]*/ bool&           fFound   ,
                                    /*[in ]*/ IXMLDOMNode*    pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::PutAttribute" );

    HRESULT                   hr;
    CComPtr<IXMLDOMAttribute> xdaAttr;
    CComVariant               vValue( bstrVal );


    __MPC_EXIT_IF_METHOD_FAILS(hr, PutAttribute( szTag, szAttr, &xdaAttr, fFound, pxdnNode ));
    if(fFound == true)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, xdaAttr->put_value( vValue ));
    }

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::PutAttribute( /*[in ]*/ LPCWSTR             szTag    ,
                                    /*[in ]*/ LPCWSTR             szAttr   ,
                                    /*[in ]*/ const MPC::wstring& szVal    ,
                                    /*[out]*/ bool&               fFound   ,
                                    /*[in ]*/ IXMLDOMNode*        pxdnNode )
{
	return PutAttribute( szTag, szAttr, SAFEWSTR( szVal.c_str() ), fFound, pxdnNode );
}

HRESULT MPC::XmlUtil::PutAttribute( /*[in ]*/ LPCWSTR      szTag    ,
                                    /*[in ]*/ LPCWSTR      szAttr   ,
                                    /*[in ]*/ LPCWSTR      szVal    ,
                                    /*[out]*/ bool&        fFound   ,
                                    /*[in ]*/ IXMLDOMNode* pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::PutAttribute" );

    HRESULT                   hr;
    CComPtr<IXMLDOMAttribute> xdaAttr;
    CComVariant               vValue( szVal );


    __MPC_EXIT_IF_METHOD_FAILS(hr, PutAttribute( szTag, szAttr, &xdaAttr, fFound, pxdnNode ));
    if(fFound == true)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, xdaAttr->put_value( vValue ));
    }

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::PutAttribute( /*[in ]*/ LPCWSTR      szTag    ,
                                    /*[in ]*/ LPCWSTR      szAttr   ,
                                    /*[in ]*/ LONG         lVal     ,
                                    /*[out]*/ bool&        fFound   ,
                                    /*[in ]*/ IXMLDOMNode* pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::PutAttribute" );

    HRESULT                   hr;
    CComPtr<IXMLDOMAttribute> xdaAttr;
    CComVariant               vValue( lVal );


    __MPC_EXIT_IF_METHOD_FAILS(hr, PutAttribute( szTag, szAttr, &xdaAttr, fFound, pxdnNode ));
    if(fFound == true)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, xdaAttr->put_value( vValue ));
    }

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPC::XmlUtil::PutValue( /*[in ]*/ LPCWSTR            szTag    ,
                                /*[in ]*/ const CComVariant& vValue   ,
                                /*[out]*/ bool&              fFound   ,
                                /*[out]*/ IXMLDOMNode*       pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::PutValue" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> xdnNodeStart;
    CComPtr<IXMLDOMNode> xdnChild;


    if(pxdnNode == NULL) { pxdnNode = m_xdnRoot; } // Use root as base of search, if no base node is supplied.


    __MPC_EXIT_IF_METHOD_FAILS(hr, getStartNode( szTag, pxdnNode, xdnNodeStart, fFound ));
    if(fFound == false)
    {
		if(szTag == NULL)
		{
			// Node not found...
			__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
		}

		//
		// Tag supplied, let's try to create a new node.
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, CreateNode( szTag, &xdnNodeStart, pxdnNode ));
    }


    //
    // Find the node holding the value.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, getValueNode( xdnNodeStart, xdnChild, fFound ));
    if(fFound == false)
    {
        if(vValue.vt == VT_ARRAY)
        {
            CComPtr<IXMLDOMCDATASection> xdcData;

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->createCDATASection( NULL, &xdcData ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, xdcData->QueryInterface( IID_IXMLDOMNode, (void **)&xdnChild ));
        }
        else
        {
            CComPtr<IXMLDOMText> xdtData;

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_xddDoc->createTextNode( NULL, &xdtData ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, xdtData->QueryInterface( IID_IXMLDOMNode, (void **)&xdnChild ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNodeStart->appendChild( xdnChild, NULL ));
    }


    //
    // Modify the value.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, xdnChild->put_nodeValue( vValue ));

    fFound = true;
    hr     = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::PutValue( /*[in ]*/ LPCWSTR         szTag     ,
                                /*[in ]*/ const CComBSTR& bstrValue ,
                                /*[out]*/ bool&           fFound    ,
                                /*[out]*/ IXMLDOMNode*    pxdnNode  )
{
    CComVariant vValue = bstrValue;

    return PutValue( szTag, vValue, fFound, pxdnNode );
}

HRESULT MPC::XmlUtil::PutValue( /*[in ]*/ LPCWSTR             szTag    ,
                                /*[in ]*/ const MPC::wstring& szValue  ,
                                /*[out]*/ bool&               fFound   ,
                                /*[out]*/ IXMLDOMNode*        pxdnNode )
{
    CComVariant vValue = szValue.c_str();

    return PutValue( szTag, vValue, fFound, pxdnNode );
}

////////////////////////////////////////

HRESULT MPC::XmlUtil::RemoveAttribute( /*[in]*/ LPCWSTR      szTag    ,
									   /*[in]*/ LPCWSTR      szAttr   ,
									   /*[in]*/ IXMLDOMNode* pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::RemoveAttribute" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> xdnNodeStart;
	bool                 fFound;


    if(pxdnNode == NULL) { pxdnNode = m_xdnRoot; } // Use root as base of search, if no base node is supplied.


    __MPC_EXIT_IF_METHOD_FAILS(hr, getStartNode( szTag, pxdnNode, xdnNodeStart, fFound ));
    if(fFound)
    {
        CComPtr<IXMLDOMNamedNodeMap> xdnnmAttrs;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xdnNodeStart->get_attributes( &xdnnmAttrs ));
        if(xdnnmAttrs)
        {
			CComPtr<IXMLDOMNode> xdnAttr;

			(void)xdnnmAttrs->removeNamedItem( CComBSTR( szAttr ), &xdnAttr );
		}
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::RemoveValue( /*[in]*/ LPCWSTR      szTag    ,
								   /*[in]*/ IXMLDOMNode* pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::RemoveValue" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> xdnNodeStart;
	bool                 fFound;


    if(pxdnNode == NULL) { pxdnNode = m_xdnRoot; } // Use root as base of search, if no base node is supplied.


    __MPC_EXIT_IF_METHOD_FAILS(hr, getStartNode( szTag, pxdnNode, xdnNodeStart, fFound ));
    if(fFound)
    {
		; // TODO
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::XmlUtil::RemoveNode( /*[in]*/ LPCWSTR      szTag    ,
								  /*[in]*/ IXMLDOMNode* pxdnNode )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::XmlUtil::RemoveNode" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> xdnNodeStart;
	bool                 fFound;


    if(pxdnNode == NULL) { pxdnNode = m_xdnRoot; } // Use root as base of search, if no base node is supplied.


    __MPC_EXIT_IF_METHOD_FAILS(hr, getStartNode( szTag, pxdnNode, xdnNodeStart, fFound ));
    if(fFound)
    {
		CComPtr<IXMLDOMNode> xdnNodeParent;

		__MPC_EXIT_IF_METHOD_FAILS(hr, xdnNodeStart->get_parentNode( &xdnNodeParent ));
		if(xdnNodeParent)
		{
			CComPtr<IXMLDOMNode> xdnNodeChild;

			__MPC_EXIT_IF_METHOD_FAILS(hr, xdnNodeParent->removeChild( xdnNodeStart, &xdnNodeChild ));
		}
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

static HRESULT local_Reg_to_XML( /*[in]*/ const MPC::RegKey& rkKey  ,
								 /*[in]*/ LPCWSTR            szName ,
								 /*[in]*/ IXMLDOMNode*       node   )
{
    __MPC_FUNC_ENTRY( COMMONID, "local_Reg_to_XML" );

    HRESULT      	 hr;
    MPC::WStringList lst;
    MPC::WStringIter it;
	MPC::XmlUtil 	 xml( node ); 
	MPC::RegKey 	 rkSubKey;
	CComVariant  	 v;
	bool         	 fFound;


	//
	// Get the subkey.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkKey.SubKey( szName, rkSubKey ));


	//
	// Copy all the values.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkSubKey.EnumerateValues( lst ));
    for(it=lst.begin(); it != lst.end(); it++)
    {
		LPCWSTR szNameValue = it->c_str();

		if(szNameValue[0] == 0) szNameValue = NULL; // Special case for the default key.

		__MPC_EXIT_IF_METHOD_FAILS(hr, rkSubKey.get_Value( v, fFound, szNameValue ));
		if(fFound)
		{
			if(szNameValue)
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, v.ChangeType( VT_BSTR ));

				__MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, szNameValue, v.bstrVal, fFound ));
			}
			else
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutValue( NULL, v, fFound ));
			}
		}
	}


	//
	// Copy all the subkeys.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkSubKey.EnumerateSubKeys( lst ));
    for(it=lst.begin(); it != lst.end(); it++)
    {
		CComPtr<IXMLDOMNode> xdnChild;
		LPCWSTR              szNameKey = it->c_str();

		__MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( szNameKey, &xdnChild ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, local_Reg_to_XML( rkSubKey, szNameKey, xdnChild ));
    }

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::ConvertFromRegistryToXML( /*[in] */ const MPC::RegKey&  rkKey ,
									   /*[out]*/       MPC::XmlUtil& xml   )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertFromRegistryToXML" );

    HRESULT          hr;
    MPC::WStringList lst;


	//
	// Get the first subkey.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkKey.EnumerateSubKeys( lst ));
	if(lst.size() > 0)
	{
		CComPtr<IXMLDOMNode> xdnRoot;
		LPCWSTR     		 szName = lst.begin()->c_str();

		__MPC_EXIT_IF_METHOD_FAILS(hr, xml.New    ( szName   ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetRoot( &xdnRoot ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, local_Reg_to_XML( rkKey, szName, xdnRoot ));
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////

static HRESULT local_XML_to_Reg( /*[in]*/ IXMLDOMNode* node  ,
								 /*[in]*/ MPC::RegKey& rkKey )
{
    __MPC_FUNC_ENTRY( COMMONID, "local_XML_to_Reg" );

    HRESULT      hr;
	MPC::XmlUtil xml( node ); 
	MPC::RegKey  rkSubKey;
	CComVariant  v;
	CComBSTR     bstr;
	bool         fFound;

	//
	// Create a subkey using the TAG name.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, node->get_nodeName( &bstr ));
	if(!bstr) __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);

	__MPC_EXIT_IF_METHOD_FAILS(hr, rkKey.SubKey( bstr, rkSubKey )); bstr.Empty();


	//
	// Clean up the key.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkSubKey.Create       ());
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkSubKey.DeleteSubKeys());
	__MPC_EXIT_IF_METHOD_FAILS(hr, rkSubKey.DeleteValues ());


	//
	// Transfer the default value.
	//
	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( NULL, v, fFound ));
	if(fFound)
	{
        __MPC_EXIT_IF_METHOD_FAILS(hr, rkSubKey.put_Value( v ));
	}

	//
	// Copy all the values.
	//
	{
		CComPtr<IXMLDOMNamedNodeMap> xdnnmAttrs;

		__MPC_EXIT_IF_METHOD_FAILS(hr, node->get_attributes( &xdnnmAttrs ));
		if(xdnnmAttrs)
		{
			while(1)
			{
				CComPtr<IXMLDOMNode>      xdnAttr;
				CComPtr<IXMLDOMAttribute> xdaAttr;

				__MPC_EXIT_IF_METHOD_FAILS(hr, xdnnmAttrs->nextNode( &xdnAttr ));
				if(xdnAttr == NULL) break;

				__MPC_EXIT_IF_METHOD_FAILS(hr, xdnAttr->QueryInterface( &xdaAttr ));
				__MPC_EXIT_IF_METHOD_FAILS(hr, xdaAttr->get_name      ( &bstr    ));
				__MPC_EXIT_IF_METHOD_FAILS(hr, xdaAttr->get_value     ( &v       ));

				if(bstr)
				{
					__MPC_EXIT_IF_METHOD_FAILS(hr, rkSubKey.put_Value( v, bstr ));

					bstr.Empty();
				}
			}
		}
	}

	//
	// Copy all the subnodes.
	//
	{
		CComPtr<IXMLDOMNodeList> xdnlNodes;

		__MPC_EXIT_IF_METHOD_FAILS(hr, node->get_childNodes( &xdnlNodes ));
		if(xdnlNodes)
		{
			while(1)
			{
				CComPtr<IXMLDOMNode> xdnChild;
				DOMNodeType          type;

				__MPC_EXIT_IF_METHOD_FAILS(hr, xdnlNodes->nextNode( &xdnChild ));
				if(xdnChild == NULL) break;

				__MPC_EXIT_IF_METHOD_FAILS(hr, xdnChild->get_nodeType( &type ));
				if(type == NODE_ELEMENT)
				{
					__MPC_EXIT_IF_METHOD_FAILS(hr, local_XML_to_Reg( xdnChild, rkSubKey ));
				}
			}
		}
	}

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::ConvertFromXMLToRegistry( /*[in] */ const MPC::XmlUtil& xml   ,
									   /*[out]*/       MPC::RegKey&  rkKey )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::ConvertFromXMLToRegistry" );

    HRESULT              hr;
	MPC::wstring         szName;
	CComPtr<IXMLDOMNode> xdnRoot;


	__MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetRoot( &xdnRoot ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, local_XML_to_Reg( xdnRoot, rkKey ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\unittest\filesystemobject\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

//
// Warning, always leave these includes BEFORE <atlbase.h>, otherwise you won't get the right MSXML.
//
#define __msxml_h__
#include <basetyps.h>
typedef interface IXMLElement IXMLElement;
#include <msxml.h>
#undef  __msxml_h__
#include <msxml.h>

#include <atlbase.h>

extern CComModule _Module;

#include <MPC_main.h>
#include <MPC_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\unittest\encryption\stdafx.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


Revision History:
    Davide Massarenti   (Dmassare)  07/21/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#include <atlbase.h>

extern CComModule _Module;

#include <MPC_main.h>
#include <MPC_trace.h>
#include <MPC_com.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_streams.h>

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\core\mpc_common\unittest\configuration\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__356DF1F8_D4FF_11D2_9379_00C04F72DAF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

//
// Warning, always leave these includes BEFORE <atlbase.h>, otherwise you won't get the right MSXML.
//
#define __msxml_h__
#include <basetyps.h>
typedef interface IXMLElement IXMLElement;
#include <msxml.h>
#undef  __msxml_h__
#include <msxml.h>

#