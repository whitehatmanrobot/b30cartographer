nionFormat =
           (const NDR64_ENCAPSULATED_UNION*)pFormat;

        ALIGN(pStubMsg->Buffer, pEncapUnionFormat->Alignment);
        pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pEncapUnionFormat + 1);
        
        if ( fMustAlloc || ! *ppMemory )
             {
             *ppMemory = (uchar*)NdrAllocate( pStubMsg, pEncapUnionFormat->MemorySize );

             //
             // We must zero out all of the new memory in case there are pointers
             // in any of the arms.
             //
             MIDL_memset( *ppMemory, 0, pEncapUnionFormat->MemorySize );
             NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
             }

        SwitchIs = Ndr64pSimpleTypeToExprValue( pEncapUnionFormat->SwitchType,
                                                pStubMsg->Buffer );

        Ndr64SimpleTypeUnmarshall( pStubMsg,
                                   *ppMemory,
                                   pEncapUnionFormat->SwitchType );

        pArmMemory = *ppMemory + pEncapUnionFormat->MemoryOffset;

        break;
        }

        default:
            NDR_ASSERT("Bad union format\n", 0);
            return;
        }
    
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );


    ALIGN(pStubMsg->Buffer, pArmSelector->Alignment);

    PNDR64_FORMAT pArmFormat = 
        Ndr64pFindUnionArm( pStubMsg,
                            pArmSelector,
                            SwitchIs );

    // check we aren't EOB after unmarshalling arm selector
    // we won't corrupt memory as there is no in place unmarshall here.
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );    


    if ( pArmFormat )
        {
        Ndr64EmbeddedTypeUnmarshall( pStubMsg,
                                     &pArmMemory,
                                     pArmFormat );
        }
}


void  
Ndr64XmitOrRepAsUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                /*fMustAlloc*/,
    bool                bIsEmbedded )
/*++

Routine Description :

    Unmarshalls a transmit as (or represent as)object.

    Means:  allocate the transmitted object,
            unmarshall transmitted object,
            translate the transmitted into presented
            free the transmitted.

    See mrshl.c for the description of the FC layout.

Arguments :

    pStubMsg    - a pointer to the stub message
    ppMemory    - pointer to the presented type where to put data
    pFormat     - format string description
    fMustAlloc  - allocate flag

Note.
    fMustAlloc is ignored as we always allocate outside of the buffer.

--*/
{
    unsigned char  *         pPresentedType = *ppMemory;

    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;
    
    NDR64_TRANSMIT_AS_FORMAT    *pTransFormat = 
        ( NDR64_TRANSMIT_AS_FORMAT *) pFormat;
    NDR_ASSERT( pTransFormat->FormatCode == FC64_TRANSMIT_AS || pTransFormat->FormatCode , "invalid format string for user marshal" );

    unsigned short QIndex = pTransFormat->RoutineIndex;
    unsigned long  PresentedTypeSize = pTransFormat->PresentedTypeMemorySize;

    if ( ! pPresentedType )
        {        
        pPresentedType = (uchar*)NdrAllocate( pStubMsg, (uint) PresentedTypeSize );
        MIDL_memset( pPresentedType, 0, (uint) PresentedTypeSize );
        }

    // Allocate the transmitted object outside of the buffer
    // and unmarshall into it

    if ( NDR64_IS_SIMPLE_TYPE( *(PFORMAT_STRING)pTransFormat->TransmittedType ))
        {
        __int64 SimpleTypeValueBuffer[2];
        unsigned char * pTransmittedType = (unsigned char *)SimpleTypeValueBuffer;
        
        Ndr64SimpleTypeUnmarshall( pStubMsg,
                                 pTransmittedType,
                                *(PFORMAT_STRING)pTransFormat->TransmittedType );
        
        // Translate from the transmitted type into the presented type.

        pStubMsg->pTransmitType = pTransmittedType;
        pStubMsg->pPresentedType = pPresentedType;

        pQuintuple[ QIndex ].pfnTranslateFromXmit( pStubMsg );

        *ppMemory = pStubMsg->pPresentedType;
        }
    else
        {

        // Save the current state of the memory list so that the temporary
        // memory allocated for the transmitted type can be easily removed
        // from the list.   This assumes that the memory allocated here 
        // will not have any linkes to other blocks of memory.   This is true
        // as long as full pointers are not used.  Fortunatly, full pointers
        // do not work correctly in the current code.
   
        void *pMemoryListSave = pStubMsg->pMemoryList;        

        unsigned char *pTransmittedType = NULL;  // asking the engine to allocate

        // In NDR64, Xmit/Rep cannot be a pointer or contain a pointer.
        // So we don't need to worry about the pointer queue here.

        if ( bIsEmbedded )
            {
            Ndr64EmbeddedTypeUnmarshall( pStubMsg,
                                         &pTransmittedType,
                                         pTransFormat->TransmittedType );
            }
        else
            {
            Ndr64TopLevelTypeUnmarshall( pStubMsg,
                                         &pTransmittedType,
                                         pTransFormat->TransmittedType,
                                         TRUE );
            }

        // Translate from the transmitted type into the presented type.
    
        pStubMsg->pTransmitType = pTransmittedType;
        pStubMsg->pPresentedType = pPresentedType;
    
        pQuintuple[ QIndex ].pfnTranslateFromXmit( pStubMsg );
    
        *ppMemory = pStubMsg->pPresentedType;

        // Free the transmitted object (it was allocated by the engine)
        // and its pointees. The call through the table frees the pointees
        // only (plus it'd free the object itself if it were a pointer).
        // As the transmitted type is not a pointer here, we need to free it
        // explicitely later.

        // Remove the memory that will be freed from the allocated memory
        // list by restoring the memory list pointer.
        // If an exception occures during one of these free routines, we 
        // are in trouble anyway.
        
        pStubMsg->pMemoryList = pMemoryListSave;        

        if ( bIsEmbedded )
            {
            Ndr64EmbeddedTypeFree( pStubMsg,
                                   pTransmittedType,
                                   pTransFormat->TransmittedType );
            }
        else
            {
            Ndr64ToplevelTypeFree( pStubMsg,
                                   pTransmittedType,
                                   pTransFormat->TransmittedType );
            }

        // The buffer reusage check.

        if ( pTransmittedType < pStubMsg->BufferStart  ||
             pTransmittedType > pStubMsg->BufferEnd )
            (*pStubMsg->pfnFree)( pTransmittedType );

        }
}

void 
Ndr64TopLevelXmitOrRepAsUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
{
    Ndr64XmitOrRepAsUnmarshall( pStubMsg,
                                ppMemory,
                                pFormat,
                                fMustAlloc,
                                false );
}

void 
Ndr64EmbeddedXmitOrRepAsUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
{
    Ndr64XmitOrRepAsUnmarshall( pStubMsg,
                                ppMemory,
                                pFormat,
                                fMustAlloc,
                                true );
}

void
Ndr64UserMarshallUnmarshallInternal(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    NDR64_USER_MARSHAL_FORMAT  *pUserFormat =
        ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    unsigned char * pUserBuffer = pStubMsg->Buffer;
    unsigned char * pUserBufferSaved = pUserBuffer;

    USER_MARSHAL_CB UserMarshalCB;
    Ndr64pInitUserMarshalCB( pStubMsg,
                           pUserFormat,
                           USER_MARSHAL_CB_UNMARSHALL, 
                           & UserMarshalCB );

    unsigned short QIndex = pUserFormat->RoutineIndex;
    const USER_MARSHAL_ROUTINE_QUADRUPLE * pQuadruple = (const USER_MARSHAL_ROUTINE_QUADRUPLE * )
                 (  ( NDR_PROC_CONTEXT *)pStubMsg->pContext )->pSyntaxInfo->aUserMarshalQuadruple;

    if ((pUserBufferSaved < (uchar *) pStubMsg->RpcMsg->Buffer) ||
        ((unsigned long) (pUserBufferSaved - (uchar *) pStubMsg->RpcMsg->Buffer) 
                                           > pStubMsg->RpcMsg->BufferLength)) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    pUserBuffer = pQuadruple[ QIndex ].pfnUnmarshall( (ulong*) &UserMarshalCB,
                                                      pUserBuffer,
                                                      pMemory );

    if ((pUserBufferSaved > pUserBuffer) || 
        ((unsigned long) (pUserBuffer - (uchar *) pStubMsg->RpcMsg->Buffer)
                                      > pStubMsg->RpcMsg->BufferLength )) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    // Step over the pointee.

    pStubMsg->Buffer = pUserBuffer;

}

void 
NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    
    Ndr64UserMarshallUnmarshallInternal( pStubMsg,
                                         pMemory,
                                         pFormat );
}

#if defined(DBG)
void 
NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
}
#endif

void
Ndr64UserMarshallPointeeUnmarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    if ( !pStubMsg->pPointerQueueState ||
         !pStubMsg->pPointerQueueState->GetActiveQueue() )
        {
        POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);
        Ndr64UserMarshallUnmarshallInternal( 
            pStubMsg,
            pMemory,
            pFormat );
        return;
        }

    NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT*pElement = 
       new(pStubMsg->pPointerQueueState) 
           NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT(pMemory,
                                                         (PFORMAT_STRING)pFormat );
    pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
}



void  
Ndr64UserMarshalUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc,
    bool                bIsEmbedded )
/*++

Routine Description :

    Unmarshals a user_marshal object.
    The layout is described in marshalling.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to pointer to the usr_marshall object to unmarshall.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    NDR64_USER_MARSHAL_FORMAT  *pUserFormat =
        ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    NDR_ASSERT( pUserFormat->FormatCode == FC64_USER_MARSHAL, "invalid format string for user marshal" );

    // Align for the object or a pointer to it.

    ALIGN( pStubMsg->Buffer, pUserFormat->TransmittedTypeWireAlignment );

    // Take care of the pointer, if any.
    NDR64_PTR_WIRE_TYPE                     PointerMarker;
    if ( ( pUserFormat->Flags & USER_MARSHAL_UNIQUE)  ||
         (( pUserFormat->Flags & USER_MARSHAL_REF) && bIsEmbedded) )
        {
        PointerMarker = *((NDR64_PTR_WIRE_TYPE *)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
        }

    // We always call user's routine to unmarshall the user object.

    // However, the top level object is allocated by the engine.
    // Thus, the behavior is exactly the same as for represent_as(),
    // with regard to the top level presented type.

    if ( *ppMemory == NULL )
        {
        // Allocate a presented type object first.

        uint MemSize = pUserFormat->UserTypeMemorySize;

        *ppMemory = (uchar *) NdrAllocate( pStubMsg, MemSize );

        MIDL_memset( *ppMemory, 0, MemSize );
        }

    if ( ( pUserFormat->Flags & USER_MARSHAL_UNIQUE)  &&  (0 == PointerMarker ))
       {
       // The user type is a unique pointer, and it is 0. So, we are done.

       return;
       }

    if ( pUserFormat->Flags & USER_MARSHAL_POINTER )
        {
        Ndr64UserMarshallPointeeUnmarshall( pStubMsg,
                                            *ppMemory,
                                            pFormat );
        return;
        }

    Ndr64UserMarshallUnmarshallInternal( pStubMsg,
                                         *ppMemory,
                                         pFormat );
}


void 
Ndr64TopLevelUserMarshalUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
{
    Ndr64UserMarshalUnmarshall( pStubMsg,
                                ppMemory,
                                pFormat,
                                fMustAlloc,
                                false );
}

void
Ndr64EmbeddedUserMarshalUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
{
    Ndr64UserMarshalUnmarshall( pStubMsg,
                                ppMemory,
                                pFormat,
                                fMustAlloc,
                                true );
}


void 
Ndr64ClientContextUnmarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_CCONTEXT *        pContextHandle,
    RPC_BINDING_HANDLE    BindHandle )
/*++

Routine Description :

    Unmarshalls a context handle on the client side.

Arguments :

    pStubMsg        - Pointer to stub message.
    pContextHandle  - Pointer to context handle to unmarshall.
    BindHandle      - The handle value used by the client for binding.

Return :

    None.

--*/
{
    // Note, this is a routine called directly from -Os stubs.
    // The routine called by interpreter is called Ndr64UnmarshallHandle
    // and can be found in hndl.c

    ALIGN(pStubMsg->Buffer,3);

    // All 20 bytes of the buffer are touched so a check is not needed here.
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CONTEXT_HANDLE_WIRE_SIZE );    

    NDRCContextUnmarshall( pContextHandle,
                           BindHandle,
                           pStubMsg->Buffer,
                           pStubMsg->RpcMsg->DataRepresentation );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}

NDR_SCONTEXT 
Ndr64ServerContextUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg )
/*++

Routine Description :

    Unmarshalls a context handle on the server side.

Arguments :

    pStubMsg    - Pointer to stub message.

Return :

    The unmarshalled context handle.

--*/
{
    // Note, this is a routine called directly from -Os stubs.
    // The routine called by interpreter is called Ndr64UnmarshallHandle
    // and can be found in hndl.c

    NDR_SCONTEXT    Context;

    ALIGN(pStubMsg->Buffer,3);

    // we could corrupt memory if it's out of bound
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CONTEXT_HANDLE_WIRE_SIZE );    

    Context = NDRSContextUnmarshall2(pStubMsg->RpcMsg->Handle,
                                     pStubMsg->Buffer,
                                     pStubMsg->RpcMsg->DataRepresentation,
                                     RPC_CONTEXT_HANDLE_DEFAULT_GUARD,
                                     RPC_CONTEXT_HANDLE_DEFAULT_FLAGS );

    if ( ! Context )
        RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

    return Context;
}

NDR_SCONTEXT  
Ndr64ContextHandleInitialize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*
    This routine is to initialize a context handle with a new NT5 flavor.
    It is used in conjunction with Ndr64ContextHandleUnmarshal.
*/
{
    NDR_SCONTEXT    SContext;
    void *          pGuard = RPC_CONTEXT_HANDLE_DEFAULT_GUARD;
    DWORD           Flags  = RPC_CONTEXT_HANDLE_DEFAULT_FLAGS;
    NDR64_CONTEXT_HANDLE_FORMAT * pContextFormat;

    pContextFormat = ( NDR64_CONTEXT_HANDLE_FORMAT * )pFormat;
    NDR_ASSERT( pContextFormat->FormatCode == FC64_BIND_CONTEXT, "invalid format char " );

    // NT5 beta2 features: strict context handle, serialize and noserialize.

    if ( pContextFormat->ContextFlags & NDR_STRICT_CONTEXT_HANDLE )
        {
        pGuard = pStubMsg->StubDesc->RpcInterfaceInformation;
        pGuard = & ((PRPC_SERVER_INTERFACE)pGuard)->InterfaceId;
        }
    if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_NOSERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_DONT_SERIALIZE;
        }
    else if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_SERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_SERIALIZE;
        }

    SContext = NDRSContextUnmarshall2(
                    pStubMsg->RpcMsg->Handle,
                    (void *)0,  // buffer
                    pStubMsg->RpcMsg->DataRepresentation,
                    pGuard,
                    Flags );

    return SContext;
}

NDR_SCONTEXT 
Ndr64ServerContextNewUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*
    This routine to unmarshal a context handle with a new NT5 flavor.
    For the old style handles, we call an optimized routine
    Ndr64ServerContextUnmarshall below.
    Interpreter calls Ndr64UnmarshallHandle from hndl.c

      ppMemory - note, this is not a pointer to user's context handle but
                 a pointer to NDR_SCONTEXT pointer to the runtime internal object.
                 User's handle is a field of that object.
*/
{
    void *          pGuard = RPC_CONTEXT_HANDLE_DEFAULT_GUARD;
    DWORD           Flags  = RPC_CONTEXT_HANDLE_DEFAULT_FLAGS;

    ALIGN( pStubMsg->Buffer, 0x3 );

    // we might corrupt the memory during the byte swap
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CONTEXT_HANDLE_WIRE_SIZE );

    NDR64_CONTEXT_HANDLE_FORMAT *pContextFormat = ( NDR64_CONTEXT_HANDLE_FORMAT * )pFormat;
    NDR_ASSERT( pContextFormat->FormatCode == FC64_BIND_CONTEXT, "invalid format char " );

    // Anti-attack defense for servers, NT5 beta3 feature.

    if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_CANNOT_BE_NULL )
        {
        // Check the incoming context handle on the server.
        // Context handle wire layout: ulong with version (always 0), then a uuid.
        //
        if ( !pStubMsg->IsClient  &&  0 == memcmp( pStubMsg->Buffer + 4,
                                                   &GUID_NULL,
                                                   sizeof(GUID) ) )
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    // NT5 beta2 features: strict context handle, serialize and noserialize.

    if ( pContextFormat->ContextFlags & NDR_STRICT_CONTEXT_HANDLE )
        {
        pGuard = pStubMsg->StubDesc->RpcInterfaceInformation;
        pGuard = & ((PRPC_SERVER_INTERFACE)pGuard)->InterfaceId;
        }
    if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_NOSERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_DONT_SERIALIZE;
        }
    else if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_SERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_SERIALIZE;
        }

    NDR_SCONTEXT SContext = 
        NDRSContextUnmarshall2(
                    pStubMsg->RpcMsg->Handle,
                    pStubMsg->Buffer,
                    pStubMsg->RpcMsg->DataRepresentation,
                    pGuard,
                    Flags );

    if ( ! SContext )
        RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

    return SContext;
}

// define the jump table
#define NDR64_BEGIN_TABLE  \
PNDR64_UNMARSHALL_ROUTINE extern const Ndr64UnmarshallRoutinesTable[] = \
{                                                          

#define NDR64_TABLE_END    \
};                         

#define NDR64_ZERO_ENTRY   NULL
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) ,NULL
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) ,NULL

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,unmarshall                      

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
   ,Ndr64UDTSimpleTypeUnmarshall1   
   
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64UnmarshallRoutinesTable)/sizeof(PNDR64_UNMARSHALL_ROUTINE) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_ENTRY

#define NDR64_BEGIN_TABLE  \
PNDR64_UNMARSHALL_ROUTINE extern const Ndr64EmbeddedUnmarshallRoutinesTable[] = \
{

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,embeddedunmarshall
   
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64EmbeddedUnmarshallRoutinesTable)/sizeof(PNDR64_UNMARSHALL_ROUTINE) == 256 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Yong  Qu   (yongqu)  Dec-12-1999

Revision History:

!ENDIF

TARGETNAME=rpcndr64
TARGETPATH=obj
TARGETTYPE=LIBRARY
386_STDCALL=1

MSC_WARNING_LEVEL=/W3 /WX

INCLUDES=..;..\..\ndr20;..\..\midl\inc;..\..\runtime\mtrt;$(INCLUDES);$(PROJECT_ROOT)\inc\ndrshared

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.hxx

SOURCES=        \
    ..\async.cxx   \
    ..\auxilary.cxx\
    ..\bufsize.cxx \
    ..\free.cxx    \
    ..\global.cxx  \
    ..\memsize.cxx \
    ..\misc.cxx    \
    ..\srvout.cxx  \
    ..\pickle64.cxx\
    ..\pointer.cxx \
    ..\expr.cxx    \
    ..\mrshl.cxx   \
    ..\unmrshl.cxx \
    ..\hndl.cxx    \
    ..\asyncu.cxx  \
    ..\cltcall.cxx \
    ..\mulsyntx.cxx\
    ..\proxy.cxx   \
    ..\srvcall.cxx \
    ..\srvwrap.cxx \
    ..\relmrl.cxx  \
    ..\pipes.cxx   


!ifdef DOSWIN32RPC
RPCENV=$(RPCENV) -DDOSWIN32RPC -DWIN32RPC
!else
RPCENV=$(RPCENV) -DNTENV
!endif

C_DEFINES=$(RPCENV) -D_RPCRT4_ -DBUILD_NDR64

BUILD_NDR64=1
!ifdef BUILD_NDR64FAKE
C_DEFINES=$(C_DEFINES) -DBUILD_NDR64FAKE
!endif


UMTYPE=console
UMTEST=testc
UMLIBS=$(O)\rpcndr64.lib $(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\rpcrt4.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\srvout.cxx ===
/************************************************************************

Copyright (c) 1993 - 1999 Microsoft Corporation

Module Name :

    srvout.cxx

Abstract :

    Contains routines for support of [out] parameters on server side during 
    unmarshalling phase. This includes deferral, allocation and handle 
    initialization.

Author :     

    Bruce McQuistan (brucemc)   12/93.

Revision History :

    DKays   10/94   Major comment and code clean up.

 ***********************************************************************/

#include "precomp.hxx"

void
Ndr64OutInit(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PNDR64_FORMAT           pFormat,
    uchar **                ppArg
    )
/*++

Routine Description :        

    This routine is called to manage server side issues for [out] params 
    such as allocation and context handle initialization. Due to the fact 
    that for [out] conformant objects on stack, their size descriptors may 
    not have been unmarshalled when we need to know their size, this routine 
    must be called after all other unmarshalling has occurred. Really, we 
    could defer only [out], conformant data, but the logic in walking the 
    format string to determine if an object is conformant does not warrant 
    that principle, so all [out] data is deferred.

Arguments :      

    pStubMsg    - Pointer to stub message.
    pFormat     - Format string description for the type.
    ppArg       - Location of argument on stack.

Return :

    None.

 --*/
{

    const NDR64_POINTER_FORMAT *pPointerFormat = 
        (const NDR64_POINTER_FORMAT*)pFormat;

    // This must be a signed long!
    LONG_PTR    Size;  

    //
    // Check for a non-Interface pointer (they have a much different format 
    // than regular pointers).
    //
    if ( NDR64_IS_BASIC_POINTER(*(PFORMAT_STRING)pFormat) )
        {
        //
        // Check for a pointer to a basetype (we don't have to worry about
        // a non-sized string pointer because these are not allowed as [out]
        // only.
        //
        if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) )
            {
            Size = NDR64_SIMPLE_TYPE_MEMSIZE( *(PFORMAT_STRING)pPointerFormat->Pointee );
            goto DoAlloc;
            }

        //
        // Check for a pointer to a pointer.
        //
        if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
            {
            Size = PTR_MEM_SIZE;
            goto DoAlloc;
            }

        // We have a pointer to complex type.
        pFormat = pPointerFormat->Pointee;

        }

    if ( *(PFORMAT_STRING)pFormat == FC64_BIND_CONTEXT )
        {
        NDR_SCONTEXT Context = 
            Ndr64ContextHandleInitialize( pStubMsg,
                                          (PFORMAT_STRING)pFormat );

        if ( ! Context )
            RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

        Ndr64SaveContextHandle(
            pStubMsg,
            Context,
            ppArg,
            (PFORMAT_STRING)pFormat );

        return;
        }

    //
    // If we get here we have to make a call to size a complex type.
    //
    Size = Ndr64pMemorySize( pStubMsg,
                             pFormat,
                             FALSE );

DoAlloc:

    //
    // Check for a negative size.  This an application error condition for
    // signed size specifiers.
    //
    if ( Size < 0 )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    *ppArg = (uchar *)NdrAllocate( pStubMsg, (size_t) Size);

    MIDL_memset( *ppArg, 0, (size_t) Size );

    // We are almost done, except for an out ref to ref to ... etc.
    // If this is the case keep allocating pointees of ref pointers.

    if ( *(PFORMAT_STRING)pFormat == FC64_RP  &&  NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
        {

        pFormat = pPointerFormat->Pointee;

        if ( *(PFORMAT_STRING)pFormat == FC64_RP )
            Ndr64OutInit( pStubMsg, pFormat, (uchar **) *ppArg );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrexts\jitdump\jitdump.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    jitdump.h

Abstract:

    This file contains routines to dump typelib generated proxy information.

Author:

    Yong Qu (yongqu)     August 24 1999

Revision History:


--*/

#ifndef _JITDUMP_H_
#define _JITDUMP_H_

typedef
HRESULT (STDAPICALLTYPE * PFNCREATEPROXYFROMTYPEINFO)
(
    IN  ITypeInfo *         pTypeInfo,
    IN  IUnknown *          punkOuter,
    IN  REFIID              riid,
    OUT IRpcProxyBuffer **  ppProxy,
    OUT void **             ppv
);

typedef
HRESULT (STDAPICALLTYPE * PFNCREATESTUBFROMTYPEINFO)
(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    IN  IUnknown *          punkServer,
    OUT IRpcStubBuffer **   ppStub
);

#include <ndrexts.hxx>

#endif // _JITDUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrexts\jitdump\jitdump.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    jitdump.cxx

Abstract:

    This file contains routines to dump typelib generated proxy information.


Author:

    Yong Qu (yongqu)     August 24 1999

Revision History:


--*/

#include <ole2.h>
#include <oleauto.h>
#include <oaidl.h>
#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include "jitdump.h"

// CreateStubFromTypeInfo is a private export. We have to LoadLibrary to
// retrieve it.
PFNCREATESTUBFROMTYPEINFO pfnCreateStubFromTypeInfo = NULL;

void PrintHelp()
{
    printf("usage: jitdump <tlbname> [{iid} [<procnum>]]\n");
    printf("Arguments:\n");
    printf("\t<tlbname> typelibrary filename.\n");
    printf("\t[{iid}] when presented, jitdump will dump all proc info of the interface \n");
    printf("\t[<procnum>] when presented, jitdump will dump only the specified proc info\n");
}

//+---------------------------------------------------------------------------
//
//  Function:   PrintStubInfo
//
//  Synopsis:   Create a proxy from given type library name and IID, then
//              dump the specified procedure information accordingly.
//              NdrpDumpStubProc is exported from ndrexts.dll. The debug
//              extension needs to be presented during runtime.
//              Dump all the methods if nProcNum is 0.
//
//  Returns:
//    S_OK if everything is fine.
//    error code if error occur somewhere.
//
//----------------------------------------------------------------------------


HRESULT PrintStubInfo(LPOLESTR wszFile, REFIID riid, unsigned long nProcNum)
{
    HRESULT hr;
    ITypeLib *pTypeLib = NULL;
    ITypeInfo *pTypeInfo = NULL;
    IRpcStubBuffer *pStub;

    hr = LoadTypeLib(wszFile,&pTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = pTypeLib->GetTypeInfoOfGuid(riid,&pTypeInfo);
    }

    if (SUCCEEDED(hr))
    {
        hr = (*pfnCreateStubFromTypeInfo)(pTypeInfo,riid,NULL, &pStub);
    }

    if (SUCCEEDED(hr))
    {
        if (nProcNum > 0)
            NdrpDumpStubProc(pStub,nProcNum);
        else
            NdrpDumpStub(pStub);
            
        pStub->Release();
    }

    if (pTypeLib)
        pTypeLib->Release();

    return hr;
}

// dump all the interface defined in the tlb.
HRESULT PrintAllStubInfo(LPOLESTR wszFile)
{
    int nCount = 0;
    HRESULT hr = S_OK;
    ITypeLib *pTypeLib = NULL;
    ITypeInfo *pTypeInfo = NULL;
    IRpcStubBuffer *pStub = NULL;
    TYPEATTR       *pTypeAttr = NULL;
    TYPEKIND tkind;

    hr = LoadTypeLib(wszFile,&pTypeLib);

    if (SUCCEEDED(hr))
    {
        nCount = pTypeLib->GetTypeInfoCount();
    }

    for (int i = 0; ( i < nCount ) ; i++)
        {
        hr = pTypeLib->GetTypeInfoType(i,&tkind);

        if (FAILED(hr))
            break;

        // we need to process interface only.
        if (tkind == TKIND_INTERFACE || 
            tkind == TKIND_DISPATCH )
            {
            hr = pTypeLib->GetTypeInfo(i,&pTypeInfo);

            if (SUCCEEDED(hr))
                {
                hr = pTypeInfo->GetTypeAttr(&pTypeAttr);

                if (SUCCEEDED(hr))
                    {
                    hr = (*pfnCreateStubFromTypeInfo)(pTypeInfo,pTypeAttr->guid,NULL, &pStub);

                    // IDispatch, IUnknown etc. would show up here also. We'll continue without 
                    // dumping those interface.
                    if (SUCCEEDED(hr))
                        {
                        NdrpDumpStub(pStub);
                        pStub->Release();
                        }
                        
                    pTypeInfo->ReleaseTypeAttr(pTypeAttr);
                    }
                pTypeInfo->Release();
                }
            }
        }

    if (pTypeLib)
        pTypeLib->Release();

    return hr;

    
}

void __cdecl main(int argc, char *argv[])
{
    HRESULT  ret;
    GUID     riid;
    unsigned long    nProcNum,dwlen = 0;
    WCHAR           *wszGUID = NULL, *wszFile = NULL;
    char            *szTLB;

    if ( argc < 2  || argc > 4)
    {
        PrintHelp();
        return;
    }

    ret = CoInitialize(NULL);
    if (FAILED (ret) )
    {
        printf("CoInitialize failed 0x%x\n",ret);
        return;
    }
    
    // load rpcrt4!CreateStubFromTypeInfo. It's not in .lib file
    if (NULL == pfnCreateStubFromTypeInfo )
    {
        HMODULE hMod = LoadLibraryA("rpcrt4.dll");
        if (hMod)
        {
            pfnCreateStubFromTypeInfo = (PFNCREATESTUBFROMTYPEINFO)GetProcAddress(hMod,
                                        "CreateStubFromTypeInfo");
        }
        if (NULL == hMod || NULL == pfnCreateStubFromTypeInfo )
        {
            printf("can't load rpcrt4.dll\n");
            return;
        }
        
    }
    // covert the filename to LPOLESTR to be used in LoadTypeLib
    dwlen = ( strlen(argv[1]) + 1 ) * sizeof(OLECHAR) ;
    wszFile = (LPOLESTR)alloca( dwlen );
    memset( wszFile , 0 , dwlen );
    dwlen /= sizeof(OLECHAR);       // MultiByteTo wants a char count

    if ( !MultiByteToWideChar(CP_ACP, 0, argv[1], -1, wszFile, dwlen ) )
    {
        printf("Can't process iid, error is 0x%x \n", GetLastError() );
        return;
    }

    if ( argc == 2 )
    {
        // dump all interfaces if only tlb name is provided.
        ret = PrintAllStubInfo(wszFile);   
    }
    else
    {
        // convert iid string into real iid.
        dwlen = ( strlen(argv[2]) + 1 ) * sizeof(OLECHAR) ;
        wszGUID = (LPOLESTR)alloca( dwlen );
        memset( wszGUID , 0 , dwlen );
        dwlen /= sizeof(OLECHAR);

        if ( !MultiByteToWideChar(CP_ACP, 0, argv[2], -1, wszGUID, dwlen ) )
        {
            printf("Can't process iid, error is 0x%x \n", GetLastError() );
            return;
        }

        ret = IIDFromString(wszGUID, &riid );
        if ( FAILED (ret) )
        {
            printf("can't convert iid %S 0x%x\n",wszGUID,ret);
            PrintHelp();
            return;
        } 

        if ( argc == 3 )
            {
            ret = PrintStubInfo(wszFile,riid,0);
            }
        else
            {
            nProcNum = atol(argv[3]);

            ret = PrintStubInfo(wszFile,riid,nProcNum);
            }
    } 

    

    if ( ret != S_OK )
    {
        printf("failed to dump the proxy 0x%x \n",ret);
    }

    CoUninitialize();
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrexts\ndrexts\format.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    format.cxx

Abstract:

    This file contains format string printer debugger extension for RPC NDR.

Author:

    Mike Zoran  (mzoran)     Sepember 3, 1999

Revision History:

--*/

#include "ndrextsp.hxx"

char * FormatCharNames[] = 
{
    "FC_ZERO",
    "byte",
    "char",
    "small",
    "usmall",
    "wchar",
    "short",
    "ushort",
    "long",
    "ulong",
    "float",
    "hyper",
    "double",
    "enum16",
    "enum32",
    "ignore",
    "error_status_t",
    "ref ptr",
    "unique ptr",
    "object ptr",
    "full ptr",

    "FC_STRUCT",
    "FC_PSTRUCT",
    "FC_CSTRUCT",
    "FC_CPSTRUCT",
    "FC_CVSTRUCT",
    "FC_BOGUS_STRUCT",

    "FC_CARRAY",
    "FC_CVARRAY",
    "FC_SMFARRAY",
    "FC_LGFARRAY",
    "FC_SMVARRAY",
    "FC_LGVARRAY",
    "FC_BOGUS_ARRAY",       

    "FC_C_CSTRING",
    "FC_C_BSTRING",
    "FC_C_SSTRING",
    "FC_C_WSTRING",

    "FC_CSTRING",
    "FC_BSTRING",
    "FC_SSTRING",
    "FC_WSTRING",           

    "FC_ENCAPSULATED_UNION",
    "FC_NON_ENCAPSULATED_UNION",

    "FC_BYTE_COUNT_POINTER",

    "FC_TRANSMIT_AS",
    "FC_REPRESENT_AS",

    "FC_IP",

    "FC_BIND_CONTEXT",
    "FC_BIND_GENERIC",
    "FC_BIND_PRIMITIVE",
    "FC_AUTO_HANDLE",
    "FC_CALLBACK_HANDLE",
    "FC_PICKLE_HANDLE",

    "FC_POINTER",

    "FC_ALIGNM2",
    "FC_ALIGNM4",
    "FC_ALIGNM8",
    "FC_ALIGNB2",
    "FC_ALIGNB4",
    "FC_ALIGNB8",        

    "FC_STRUCTPAD1",
    "FC_STRUCTPAD2",
    "FC_STRUCTPAD3",
    "FC_STRUCTPAD4",
    "FC_STRUCTPAD5",
    "FC_STRUCTPAD6",
    "FC_STRUCTPAD7",

    "FC_STRING_SIZED",
    "FC_STRING_NO_SIZE",    

    "FC_NO_REPEAT",
    "FC_FIXED_REPEAT",
    "FC_VARIABLE_REPEAT",
    "FC_FIXED_OFFSET",
    "FC_VARIABLE_OFFSET",      

    "FC_PP",

    "FC_EMBEDDED_COMPLEX",

    "FC_IN_PARAM",
    "FC_IN_PARAM_BASETYPE",
    "FC_IN_PARAM_NO_FREE_INST",
    "FC_IN_OUT_PARAM",
    "FC_OUT_PARAM",
    "FC_RETURN_PARAM",         
    "FC_RETURN_PARAM_BASETYPE",

    "FC_DEREFERENCE",
    "FC_DIV_2",
    "FC_MULT_2",
    "FC_ADD_1",
    "FC_SUB_1",
    "FC_CALLBACK",

    "FC_CONSTANT_IID",

    "FC_END",
    "FC_PAD",

    // ** Gap before new format string types **

    "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES",

    // ** Gap before new format string types end **

    // 
    // Post NT 3.5 format characters.
    //

    // Hard struct

    "FC_HARD_STRUCT",            // 0xb1

    "FC_TRANSMIT_AS_PTR",        // 0xb2
    "FC_REPRESENT_AS_PTR",       // 0xb3

    "FC_USER_MARSHAL",           // 0xb4

    "FC_PIPE",                   // 0xb5

    "FC_BLKHOLE",                // 0xb6

    "FC_RANGE",                   // 0xb7     NT 5 beta2 MIDL 3.3.110

    "FC_INT3264",                 // 0xb8     NT 5 beta2, MIDL64, 5.1.194+
    "FC_UINT3264",                // 0xb9     NT 5 beta2, MIDL64, 5.1.194+

    "FC_END_OF_UNIVERSE",         // 0xb5

    ""
};

FORMAT_STRING::FORMAT_STRING(UINT64 Addr) 
: Address(Addr)
    {
    
    }

VOID  FORMAT_STRING::Move(LONG Delta)
    {
    Address += Delta;
    }

VOID  FORMAT_STRING::GotoOffset()
    {
    UINT64 CurrentAddress = Address;
    SHORT Offset = GetSHORT();
    Address = CurrentAddress + Offset;
    }

UINT64 FORMAT_STRING::ComputeOffset()
    {
    UINT64 CurrentAddress = Address;
    SHORT Offset = GetSHORT();
    return CurrentAddress + Offset;
    }

UINT64 FORMAT_STRING::GetAddress()
    {
    return Address;
    }
UINT64 FORMAT_STRING::SetAddress(UINT64 Addr)
    {
    UINT64 Tmp = Address; 
    Address = Addr; 
    return Tmp;
    }

BOOL FORMAT_STRING::SkipCorrelationDesc( BOOL Robust )
    {
    ULONG Desc = GetULONG();
    if ( Robust )
        {
        Move(2);
        }
    return Desc != 0xFFFFFFFF;
    }

#define DEFINE_FORMAT_TYPE(type)                                                 \
    type FORMAT_STRING::Read##type##() {                                         \
        type Tmp;  ReadMemory(Address,&Tmp); return Tmp;                         \
    }                                                                            \
    type FORMAT_STRING::Get##type##() {                                          \
        type Tmp;  ReadMemory(Address,&Tmp); Address += sizeof(Tmp); return Tmp; \
    }                                                                            \
    VOID FORMAT_STRING::Inc##type##() {                                          \
        Address += sizeof(type);                                                 \
    }

DEFINE_FORMAT_TYPE(UCHAR)
DEFINE_FORMAT_TYPE(CHAR)
DEFINE_FORMAT_TYPE(USHORT)
DEFINE_FORMAT_TYPE(SHORT)
DEFINE_FORMAT_TYPE(ULONG)
DEFINE_FORMAT_TYPE(LONG)
DEFINE_FORMAT_TYPE(GUID)

PCHAR FORMAT_STRING::GetFormatCharName( UCHAR FC )
    {
    return (0 <= FC  &&  FC <= FC_END)
    ?  FormatCharNames[ FC ]
    :  "FC unknown" ;
    }

FORMAT_TYPE_QUEUE::FORMAT_TYPE_QUEUE() : Set(),
                                         Queue()
    {
    Clear();
    }

VOID FORMAT_TYPE_QUEUE::Clear()
    {
    Set.clear();
    while(!Queue.empty()) 
        Queue.pop();
    }

VOID FORMAT_TYPE_QUEUE::Add(UINT64 FormatAddress, UINT64 BaseAddress)
    {
    if (!Set.insert(FormatAddress).second)
        {
        // already hit this item
        return;
        }

    FORMAT_TYPE_QUEUE_ITEM Item = {FormatAddress, BaseAddress};
    Queue.push(Item);
    }

VOID FORMAT_TYPE_QUEUE::PrintTypes(FORMAT_PRINTER *pFormatPrinter)
    {
    while (!Queue.empty())
        {

        FORMAT_TYPE_QUEUE_ITEM Item = Queue.front();
        Queue.pop();

        UINT64 BackupFormatAddress = pFormatPrinter->FormatString.GetAddress();
        UINT64 BackupBaseAddress = pFormatPrinter->BaseAddress;
        pFormatPrinter->FormatString.SetAddress(Item.FormatAddress);
        pFormatPrinter->BaseAddress = Item.BaseAddress;

        pFormatPrinter->OutputType();
        pFormatPrinter->dout << '\n';

        pFormatPrinter->FormatString.SetAddress(BackupFormatAddress);
        pFormatPrinter->BaseAddress = BackupBaseAddress;

        }
    }

FORMAT_PRINTER::FORMAT_PRINTER(FORMATTED_STREAM_BUFFER & ds) : dout(ds), 
                                                               FormatString(0), 
                                                               Robust(FALSE)
    {
    
    }

// Os dumper
void FORMAT_PRINTER::PrintOsHeader(UINT64 ProcHeader)
    {
    ABORT("Printing the proc header is unavailable in Os mode.\n\n");
    }


void FORMAT_PRINTER::PrintOsParamList(UINT64 ParamList, UINT64 TypeInfo)
    {
    BaseAddress = ParamList;
    UINT64 Address = FormatString.SetAddress(ParamList);                              
    PrintOldStyleParamList(TypeInfo);
    FormatString.SetAddress(Address);
    }

void FORMAT_PRINTER::PrintOsProc(UINT64 ProcHeader, UINT64 TypeInfo)
    {
    PrintOsParamList(ProcHeader, TypeInfo);
    }

// Oi dumper
void FORMAT_PRINTER::PrintOiHeader(UINT64 ProcHeader)
    {
    BaseAddress = ProcHeader;
    UINT64 Address = FormatString.SetAddress(ProcHeader);
    PrintNewStyleProcHeader(FALSE, FALSE, 0);
    FormatString.SetAddress(Address);
    }

void FORMAT_PRINTER::PrintOiParamList(UINT64 Paramlist, UINT64 TypeInfo)
    {
    BaseAddress = Paramlist;
    UINT64 Address = FormatString.SetAddress(Paramlist);
    PrintOldStyleParamList(TypeInfo);
    FormatString.SetAddress(Address);
    }

void FORMAT_PRINTER::PrintOiProc(UINT64 ProcHeader, UINT64 TypeInfo)
    {
    BaseAddress = ProcHeader;
    UINT64 Address = FormatString.SetAddress(ProcHeader);
    PrintNewStyleProcHeader(FALSE, TRUE, TypeInfo);
    FormatString.SetAddress(Address);

    }

// Oif dumper
void FORMAT_PRINTER::PrintOifHeader(UINT64 ProcHeader)
    {
    BaseAddress = ProcHeader;
    UINT64 Address = FormatString.SetAddress(ProcHeader);
    PrintNewStyleProcHeader(TRUE, FALSE, 0);
    FormatString.SetAddress(Address);
    }

void FORMAT_PRINTER::PrintOifParamList(UINT64 ParamList, UINT64 TypeInfo)
    {
    ABORT("Printing the parameter list without the proc header\n" <<
          "is unavailable with the new style proc header.\n\n");
    }

void FORMAT_PRINTER::PrintOifProc(UINT64 ProcHeader, UINT64 TypeInfo)
    {
    BaseAddress = ProcHeader;
    UINT64 Address = FormatString.SetAddress(ProcHeader);
    PrintNewStyleProcHeader(TRUE, TRUE, TypeInfo);
    FormatString.SetAddress(Address);
    }

// Type printer 
void FORMAT_PRINTER::PrintTypeFormat(UINT64 TypeFormatString, BOOL IsRobust)
    {
    TypeSet.Clear();
    Robust = IsRobust;
    TypeSet.Add(TypeFormatString, TypeFormatString);
    TypeSet.PrintTypes(this);
    }

void FORMAT_PRINTER::PrintProcHeader(UINT64 ProcHeader, NDREXTS_STUBMODE_TYPE ContextStubMode)
    {
    switch ( ContextStubMode )
        {
        case OS:
            PrintOsHeader(ProcHeader);
            break;
        case OI:
            PrintOiHeader(ProcHeader);
            break;
        case OIC:
        case OICF:
        case OIF:
            PrintOifHeader(ProcHeader);
            break;
        default:
            ABORT("Corrupt stub mode.\n");
        }
    }

void FORMAT_PRINTER::PrintProcParamList(UINT64 ParamList, UINT64 TypeInfo, 
                                        NDREXTS_STUBMODE_TYPE ContextStubMode)
    {
    switch ( ContextStubMode )
        {
        case OS:
            PrintOsParamList(ParamList, TypeInfo);
            break;
        case OI:
            PrintOiParamList(ParamList, TypeInfo);
            break;
        case OIC:
        case OICF:
        case OIF:
            PrintOifParamList(ParamList, TypeInfo);
            break;
        default:
            ABORT("Corrupt stub mode.\n");
        }   
    }


void FORMAT_PRINTER::PrintProc(UINT64 ProcHeader, UINT64 TypeInfo, 
                               NDREXTS_STUBMODE_TYPE ContextStubMode)
    {
    switch ( ContextStubMode )
        {
        case OS:
            PrintOsProc(ProcHeader, TypeInfo);
            break;
        case OI:
            PrintOiProc(ProcHeader, TypeInfo);
            break;
        case OIC:
        case OICF:
        case OIF:
            PrintOifProc(ProcHeader, TypeInfo);
            break;
        default:
            ABORT("Corrupt stub mode.\n");
        }
    }


void FORMAT_PRINTER::PrintNewStyleProcHeader(BOOL IsOif, BOOL PrintParams, UINT64 TypeList)
    {

    dout << "Oi style header:\n";
    UCHAR HandleType = FormatString.GetUCHAR(); 
    dout << FormatString.GetFormatCharName(HandleType) << '\n';
    UCHAR OiFlags = FormatString.GetUCHAR();
    dout << "OiFlags:     " << HexOut(OiFlags) << '\n';
    {
        IndentLevel l(dout);
        if ( OiFlags & Oi_FULL_PTR_USED ) dout << "Oi_FULL_PTR_USED "; 
        if ( OiFlags & Oi_RPCSS_ALLOC_USED ) dout << "Oi_RPCSS_ALLOC_USED ";
        if ( OiFlags & Oi_OBJECT_PROC ) dout << "Oi_OBJECT_PROC ";
        if ( OiFlags & Oi_HAS_RPCFLAGS ) dout << "Oi_HAS_RPCFLAGS ";
        if ( OiFlags & Oi_IGNORE_OBJECT_EXCEPTION_HANDLING ) 
            {
            if ( OiFlags & Oi_OBJECT_PROC ) dout << "Oi_IGNORE_OBJECT_EXCEPTION_HANDLING ";
            else dout << "ENCODE_IS_USED ";
            } 
        if ( OiFlags & Oi_OBJ_USE_V2_INTERPRETER ) 
            {
            if ( OiFlags & Oi_OBJECT_PROC ) dout << "(Oi_OBJ_USE_V2_INTERPRETER|Oi_HAS_COMM_OR_FAULT) ";
            else dout << "(Oi_HAS_COMM_OR_FAULT|DECODE_IS_USED) ";
            }
        if ( OiFlags & Oi_USE_NEW_INIT_ROUTINES )  dout << "Oi_USE_NEW_INIT_ROUTINES ";
        dout << '\n';
    }

    if ( OiFlags & Oi_HAS_RPCFLAGS )
        {
        dout << "Rpc flags:   " << HexOut(FormatString.GetULONG()) << '\n';
        }   
    dout << "Proc number: " << HexOut(FormatString.GetUSHORT()) << "                    ";
    dout << "Stack size:  " << HexOut(FormatString.GetUSHORT()) << '\n';

    if ( HandleType==0 )
        {
        UCHAR HandleType = FormatString.GetUCHAR();
        switch ( HandleType )
            {
            case FC_BIND_PRIMITIVE:
                // Output the FC_BIND_PRIMITIVE
                dout << FormatString.GetFormatCharName(HandleType) << '\n';
                {
                    IndentLevel l(dout);
                    dout << "Flags:  " << HexOut(FormatString.GetUCHAR()) << '\n';
                    dout << "Offset: " << HexOut(FormatString.GetUSHORT()) << '\n';
                }
                break;
            case FC_BIND_GENERIC:
                {
                    // Output the FC_BIND_GENERIC
                    dout << FormatString.GetFormatCharName(HandleType) << '\n';
                    {
                        IndentLevel l(dout);
                        UCHAR FlagsAndSize = FormatString.GetUCHAR();
                        dout << "FlagsAndSize:               " << HexOut(FlagsAndSize) 
                        << " Flags: " << HexOut((UCHAR)(FlagsAndSize >> 8))
                        << " Size:  " << HexOut((UCHAR)(FlagsAndSize & 0xF)) << '\n';
                        dout << "Offset:                     " << HexOut(FormatString.GetUSHORT()) << '\n';
                        dout << "Binding routine pair index: " << HexOut(FormatString.GetUCHAR()) << '\n';
                        dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';
                    }
                    break;
                }
            case FC_BIND_CONTEXT:
                // Output the FC_BIND_PRIMITIVE
                dout << FormatString.GetFormatCharName(HandleType) << '\n';
                {
                    IndentLevel l(dout);
                    dout << "Flags:                         " << HexOut(FormatString.GetUCHAR()) << '\n';
                    dout << "Offset:                        " << HexOut(FormatString.GetUSHORT()) << '\n';
                    dout << "Context rundown routine index: " << FormatString.GetUCHAR() << '\n';
                    dout << "Parameter number:              " << FormatString.GetUCHAR() << '\n';
                }
                break;
            default:
                dout << "Unknown handle type " << HexOut(HandleType) << '\n';
                break;
            }  
        }

    // Oif extensions
    if ( IsOif )
        {

        dout << "Oif extensions:\n";
        dout << "Constant client buffer size: " << HexOut(FormatString.GetUSHORT()) << "    ";
        dout << "Constant server buffer size: " << HexOut(FormatString.GetUSHORT()) << '\n';

        UCHAR InterpreterFlagsUCHAR = FormatString.GetUCHAR();
        PINTERPRETER_OPT_FLAGS InterpreterFlags = (PINTERPRETER_OPT_FLAGS)&InterpreterFlagsUCHAR;
        dout << "INTERPRETER_OPT_FLAGS: \n";
        {
            IndentLevel l(dout);
            if (InterpreterFlags->ServerMustSize) dout << "ServerMustSize ";
            if (InterpreterFlags->ClientMustSize) dout << "ClientMustSize ";
            if (InterpreterFlags->HasReturn) dout << "HasReturn ";
            if (InterpreterFlags->HasPipes) dout << "HasPipes ";
            if (InterpreterFlags->HasAsyncUuid) dout << "HasAsyncUuid ";
            if (InterpreterFlags->HasExtensions) dout << "HasExtensions ";
            if (InterpreterFlags->HasAsyncHandle) dout << "HasAsyncHandle ";
            dout << '\n';
            dout << "Unused:         " << HexOut(InterpreterFlags->Unused) << '\n';
        }

        UCHAR NumberOfParameters = FormatString.GetUCHAR();
        dout << "NumberOfParameters: " << HexOut(NumberOfParameters) << '\n';

        // NT 5.0 extensions
        if ( InterpreterFlags->HasExtensions )
            {

            dout << "NT5.0 extensions\n";
            UCHAR ExtensionVersion = FormatString.GetUCHAR();
            dout << "Extension Version: " << HexOut(ExtensionVersion) << '\n';

            UCHAR InterpreterFlags2UCHAR = FormatString.GetUCHAR();
            PINTERPRETER_OPT_FLAGS2 InterpreterFlags2 = (PINTERPRETER_OPT_FLAGS2)&InterpreterFlags2UCHAR;
            dout << "INTERPRETER_OPT_FLAGS2: \n";
            {
                IndentLevel l(dout);
                if (InterpreterFlags2->HasNewCorrDesc) 
                    {
                    dout << "HasNewCorrDesc ";
                    Robust = TRUE;
                    }
                if (InterpreterFlags2->ClientCorrCheck) dout << "ClientCorrCheck ";
                if (InterpreterFlags2->ServerCorrCheck) dout << "ServerCorrCheck ";
                if (InterpreterFlags2->HasNotify) dout << "HasNotify ";
                if (InterpreterFlags2->HasNotify2) dout << "HasNotify2 ";
                dout << '\n';
                dout << "Unused:          " << HexOut(InterpreterFlags2->Unused) << '\n';
            } 
            dout << "ClientCorrHint:    " << HexOut(FormatString.GetUSHORT()) << "              ";
            dout << "ServerCorrHint:    " << HexOut(FormatString.GetUSHORT()) << '\n';
            dout << "NotifyIndex:       " << HexOut(FormatString.GetUSHORT()) << "              ";
            if ( ExtensionVersion == 12 )
                {
                dout << "FloatDoubleMask:   " << HexOut(FormatString.GetULONG()) << '\n';
                }
            else 
                dout << '\n';

            }

        if ( PrintParams )
            {
            PrintNewSytleParamList(NumberOfParameters, TypeList);
            }

        }
    }

void FORMAT_PRINTER::PrintNewSytleParamList(UINT NumberOfParameters, UINT64 TypeList)
    {

    TypeSet.Clear();
    dout << '\n';
    dout << "Oif style parameter list( " << NumberOfParameters << " parameters )\n";
    UINT ParamNumber = 0;
    while ( NumberOfParameters-- )
        {
        dout << "Param:            " << HexOut(ParamNumber++) << '\n';
        USHORT ParamAttributesUSHORT = FormatString.GetUSHORT();
        PPARAM_ATTRIBUTES ParamAttributes = (PPARAM_ATTRIBUTES)&ParamAttributesUSHORT;
        dout << "Param attributes: \n";
        {
            IndentLevel l(dout);
            if (ParamAttributes->MustSize) dout << "MustSize ";
            if (ParamAttributes->MustFree) dout << "MustFree ";
            if (ParamAttributes->IsPipe) dout << "IsPipe ";
            if (ParamAttributes->IsIn) dout << "IsIn ";
            if (ParamAttributes->IsOut) dout << "IsOut ";
            if (ParamAttributes->IsReturn) dout << "IsReturn ";
            if (ParamAttributes->IsBasetype) dout << "IsBasetype ";
            if (ParamAttributes->IsByValue) dout << "IsByValue ";
            if (ParamAttributes->IsSimpleRef) dout << "IsSimpleRef ";
            if (ParamAttributes->IsDontCallFreeInst) dout << "IsDontCallFreeInst ";
            if (ParamAttributes->SaveForAsyncFinish) dout << "SaveForAsyncFinish ";
            if (ParamAttributes->IsPartialIgnore) dout << "IsPartialIgnore ";
            if (ParamAttributes->IsForceAllocate) dout << "IsForceAllocate ";
            dout << '\n';
            dout << "ServerAllocSize:  " << HexOut(ParamAttributes->ServerAllocSize) << "              ";
            dout << '\n';
        }
        dout << "Stack offset:     " << HexOut(FormatString.GetUSHORT()) << "               ";
        if ( ParamAttributes->IsBasetype )
            {
            dout << "TypeFormatChar:   " << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';
            dout << "Unused:           " << HexOut(FormatString.GetUCHAR()) << '\n';
            }
        else
            {
            dout << '\n';
            ProcOutputTypeAtOffset(TypeList);
            }
        dout << '\n';
        }

    dout << '\n';
    dout << "Printing the set of types used.\n";
    TypeSet.PrintTypes(this);
    dout << "End of types.\n";
    dout << "\n";
    }

    

void FORMAT_PRINTER::PrintOldStyleParamList(UINT64 TypeListAddress)
    {

    TypeSet.Clear();

    UINT ParamNumber = 0;
    dout << "Os/Oi style parameter list\n";

    while ( 1 )
        {
        UCHAR Format = FormatString.ReadUCHAR();
        switch ( Format )
            {
            case FC_END:
                dout << "FC_END\n";
                goto Exit;
            case FC_IN_PARAM_BASETYPE:
                dout << "Param:      " << ParamNumber++ << '\n';
                dout << "FC_IN_PARAM_BASETYPE\n";
                OutputType();
                break;
            case FC_RETURN_PARAM_BASETYPE:
                dout << "Param:      " << ParamNumber++ << '\n';
                dout << "FC_RETURN_PARAM_BASETYPE\n";
                OutputType();
                break;
            default:
                dout << "Param:      " << ParamNumber++ << '\n'; 
                dout << FormatString.GetFormatCharName(Format) << '\n';
                dout << "Stack size: " << HexOut(FormatString.GetUCHAR()) << '\n';
                ProcOutputTypeAtOffset(TypeListAddress);         
            }
        dout << '\n';

        }
Exit:
    dout << '\n';
    dout << "Printing the set of types used.\n";
    TypeSet.PrintTypes(this);
    dout << "End of types.\n";

    }

void FORMAT_PRINTER::ProcOutputTypeAtOffset(UINT64 TypeList)
    {

    UINT64 Address = FormatString.GetAddress();
    SHORT Offset = FormatString.GetUSHORT();
    if ( !TypeList )
        {
        dout << "Type offset: " << HexOut(Offset) << '(' << Offset << ")\n";
        return;
        }

    if ( !Offset)
        {
        dout << "Type offset is 0, type info is not available!\n";         
        }

    UINT64 NewAddress = TypeList+Offset;
    UINT64 OldBaseAddress = BaseAddress;
    BaseAddress = TypeList;
    PrintOffsetComment("Type offset: ", Offset, NewAddress);
    TypeSet.Add(NewAddress, TypeList);
    BaseAddress = OldBaseAddress;    
    }

void FORMAT_PRINTER::OutputTypeAtOffset(char *Label, char *NoOffsetComment)
    {
    UINT64 Address = FormatString.GetAddress();
    SHORT Offset = FormatString.GetUSHORT();
    
    if ( !Offset )
        {
        dout << NoOffsetComment << '\n';
        return;
        }

    UINT64 NewAddress = Address+Offset;
    PrintOffsetComment(Label, Offset, NewAddress);
    
    TypeSet.Add(NewAddress, BaseAddress);

    }

void FORMAT_PRINTER::PrintFormatOffset()
    {
    ULONG Offset = FormatString.GetAddress() - BaseAddress;
    dout << HexOut(Offset) << '(' << Offset << ')' << ' ';
    }

VOID FORMAT_PRINTER::PrintOffsetComment(const char *pComment, SHORT Offset, UINT64 NewAddress)
{
    LONG NewRelAddress = NewAddress - BaseAddress;
    dout << pComment << HexOut(Offset) << '(' << Offset << ')' << " to "
                     << HexOut(NewRelAddress) << '(' << NewRelAddress << ')' << '\n';
}

#define DISPATCH_TYPE(type)         \
   case type:                       \
      HANDLE_##type ();             \
      break;

void FORMAT_PRINTER::OutputType()
    {

    UINT64 Address = FormatString.GetAddress();
    
    PrintFormatOffset();
    UCHAR FormatChar = FormatString.ReadUCHAR();
    switch ( FormatChar )
        {
        default:
            ABORT( "Unknown type " << HexOut(FormatChar) << ".\n" );
            break;

            DISPATCH_TYPE(FC_ZERO)
            DISPATCH_TYPE(FC_BYTE)                    
            DISPATCH_TYPE(FC_CHAR)                    
            DISPATCH_TYPE(FC_SMALL)                   
            DISPATCH_TYPE(FC_USMALL)                  
            DISPATCH_TYPE(FC_WCHAR)                   
            DISPATCH_TYPE(FC_SHORT)                   
            DISPATCH_TYPE(FC_USHORT)                  
            DISPATCH_TYPE(FC_LONG)                    
            DISPATCH_TYPE(FC_ULONG)                   
            DISPATCH_TYPE(FC_FLOAT)                   
            DISPATCH_TYPE(FC_HYPER)                  
            DISPATCH_TYPE(FC_DOUBLE)                  
            DISPATCH_TYPE(FC_ENUM16)                  
            DISPATCH_TYPE(FC_ENUM32)                  
            DISPATCH_TYPE(FC_IGNORE)                  
            DISPATCH_TYPE(FC_ERROR_STATUS_T)          
            DISPATCH_TYPE(FC_RP)                   
            DISPATCH_TYPE(FC_UP)                   
            DISPATCH_TYPE(FC_OP)                   
            DISPATCH_TYPE(FC_FP)                    
            DISPATCH_TYPE(FC_STRUCT)                  
            DISPATCH_TYPE(FC_PSTRUCT)               
            DISPATCH_TYPE(FC_CSTRUCT)                 
            DISPATCH_TYPE(FC_CPSTRUCT)               
            DISPATCH_TYPE(FC_CVSTRUCT)      
            DISPATCH_TYPE(FC_BOGUS_STRUCT)          
            DISPATCH_TYPE(FC_CARRAY)             
            DISPATCH_TYPE(FC_CVARRAY)             
            DISPATCH_TYPE(FC_SMFARRAY)            
            DISPATCH_TYPE(FC_LGFARRAY)         
            DISPATCH_TYPE(FC_SMVARRAY)            
            DISPATCH_TYPE(FC_LGVARRAY)            
            DISPATCH_TYPE(FC_BOGUS_ARRAY)       
            DISPATCH_TYPE(FC_C_CSTRING)                
            DISPATCH_TYPE(FC_C_SSTRING)           
            DISPATCH_TYPE(FC_C_WSTRING)            
            DISPATCH_TYPE(FC_CSTRING)                        
            DISPATCH_TYPE(FC_SSTRING)              
            DISPATCH_TYPE(FC_WSTRING)               
            DISPATCH_TYPE(FC_ENCAPSULATED_UNION)      
            DISPATCH_TYPE(FC_NON_ENCAPSULATED_UNION) 
            DISPATCH_TYPE(FC_BYTE_COUNT_POINTER)      
            DISPATCH_TYPE(FC_TRANSMIT_AS)            
            DISPATCH_TYPE(FC_REPRESENT_AS)            
            DISPATCH_TYPE(FC_IP)                     
            DISPATCH_TYPE(FC_BIND_CONTEXT)          
            DISPATCH_TYPE(FC_BIND_GENERIC)          
            DISPATCH_TYPE(FC_BIND_PRIMITIVE)       
            DISPATCH_TYPE(FC_AUTO_HANDLE)             
            DISPATCH_TYPE(FC_CALLBACK_HANDLE)           
            DISPATCH_TYPE(FC_UNUSED1)                       
            DISPATCH_TYPE(FC_ALIGNM2)               
            DISPATCH_TYPE(FC_ALIGNM4)               
            DISPATCH_TYPE(FC_ALIGNM8)               
            DISPATCH_TYPE(FC_UNUSED2)              
            DISPATCH_TYPE(FC_UNUSED3)             
            DISPATCH_TYPE(FC_UNUSED4)             
            DISPATCH_TYPE(FC_STRUCTPAD1)       
            DISPATCH_TYPE(FC_STRUCTPAD2)            
            DISPATCH_TYPE(FC_STRUCTPAD3)           
            DISPATCH_TYPE(FC_STRUCTPAD4)            
            DISPATCH_TYPE(FC_STRUCTPAD5)            
            DISPATCH_TYPE(FC_STRUCTPAD6)             
            DISPATCH_TYPE(FC_STRUCTPAD7)            
            DISPATCH_TYPE(FC_EMBEDDED_COMPLEX)        
            DISPATCH_TYPE(FC_END)                     
            DISPATCH_TYPE(FC_PAD)                                 
            DISPATCH_TYPE(FC_USER_MARSHAL)           
            DISPATCH_TYPE(FC_PIPE)                   
            DISPATCH_TYPE(FC_BLKHOLE)                 
            DISPATCH_TYPE(FC_RANGE)                       
            DISPATCH_TYPE(FC_INT3264)              
            DISPATCH_TYPE(FC_UINT3264)   
        }

    }

// Many types just need printing
#define PRINT_SIMPLE_TYPE(type)             \
void FORMAT_PRINTER::HANDLE_##type() { \
   dout << #type "\n";                      \
   FormatString.IncUCHAR();                 \
}                                           \

// Some types need redirecting to a common processing function
#define PRINT_REDIRECT_TYPE(type,func)      \
void FORMAT_PRINTER::HANDLE_##type() { \
   func();                                  \
}

PRINT_SIMPLE_TYPE(FC_ZERO)
PRINT_SIMPLE_TYPE(FC_BYTE)                    
PRINT_SIMPLE_TYPE(FC_CHAR)                    
PRINT_SIMPLE_TYPE(FC_SMALL)                   
PRINT_SIMPLE_TYPE(FC_USMALL)                  
PRINT_SIMPLE_TYPE(FC_WCHAR)                   
PRINT_SIMPLE_TYPE(FC_SHORT)                   
PRINT_SIMPLE_TYPE(FC_USHORT)                  
PRINT_SIMPLE_TYPE(FC_LONG)                    
PRINT_SIMPLE_TYPE(FC_ULONG)                   
PRINT_SIMPLE_TYPE(FC_FLOAT)                   
PRINT_SIMPLE_TYPE(FC_HYPER)                  
PRINT_SIMPLE_TYPE(FC_DOUBLE)                  
PRINT_SIMPLE_TYPE(FC_ENUM16)                  
PRINT_SIMPLE_TYPE(FC_ENUM32)                  
PRINT_SIMPLE_TYPE(FC_IGNORE)                  
PRINT_SIMPLE_TYPE(FC_ERROR_STATUS_T)

void FORMAT_PRINTER::PrintPointerType()
    {

    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';

    UCHAR Flags = FormatString.GetUCHAR();
    dout << "Flags: " << HexOut(Flags);
    if ( Flags & FC_ALLOCATE_ALL_NODES )
        {
        dout << " FC_ALLOCATE_ALL_NODES ";
        }
    if ( Flags & FC_DONT_FREE )
        {
        dout << " FC_DONT_FREE ";
        }
    if ( Flags & FC_ALLOCED_ON_STACK )
        {
        dout << " FC_ALLOCATED_ON_STACK ";
        }
    if ( Flags & FC_SIMPLE_POINTER )
        {
        dout << " FC_SIMPLE_POINTER ";
        }
    if ( Flags & FC_POINTER_DEREF )
        {
        dout << " FC_POINTER_DEREF ";
        }
    dout << '\n';

    if ( Flags & FC_SIMPLE_POINTER )
        {
        // Output the simple type
        OutputType();
        FormatString.IncUCHAR();
        }
    else
        {
        OutputTypeAtOffset("Offset to type: ", "Offset to type is 0, no type info.");
        }

    }

void FORMAT_PRINTER::PrintPointerInstance(void)
    {

    SHORT  OffsetInMemory = FormatString.GetSHORT();
    dout << "Offset to pointer in memory: " << HexOut(OffsetInMemory) 
    << '(' << OffsetInMemory << ")\n";

    SHORT  OffsetInBuffer = FormatString.GetSHORT();
    dout << "Offset to pointer in buffer: " << HexOut(OffsetInBuffer) 
    << '(' << OffsetInBuffer << ")\n";

    PrintPointerType();

    }

void FORMAT_PRINTER::PrintPointerRepeat(void)
    {

    UCHAR LayoutType = FormatString.GetUCHAR();
    dout << FormatString.GetFormatCharName(LayoutType) << '\n';

    //The next char should be FC_FIXED_OFFSET, FC_VARIABLE_OFFSET, or FC_PAD
    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';

    if ( FC_FIXED_REPEAT == LayoutType )
        {
        dout << "Iterations:         " << HexOut(FormatString.GetUCHAR()) << '\n';
        }

    dout << "Increment:          " << HexOut(FormatString.GetUSHORT()) << '\n';
    dout << "Offset to array:    " << HexOut(FormatString.GetUSHORT()) << '\n';

    USHORT NumberOfPointers = FormatString.GetUSHORT();
    dout << "Number of pointers: " << HexOut(NumberOfPointers) << '\n';

    while ( NumberOfPointers-- )
        {
        PrintPointerInstance();
        }

    }

void FORMAT_PRINTER::PrintPointerLayout()
    {

    UCHAR FcPP = FormatString.ReadUCHAR();
    if ( FC_PP != FcPP )
        {
        // This isn't a pointer layout so silently return
        return;
        }
    FormatString.IncUCHAR();
    dout << "FC_PP\n";

    //Output the FC_PAD
    OutputType();

    UCHAR LayoutType;
    while ( LayoutType = FormatString.GetUCHAR(), LayoutType != FC_END )
        {
        switch ( LayoutType )
            {
            case FC_NO_REPEAT:
                dout << "FC_NO_REPEAT\n";         
                // Output the FC_PAD
                OutputType();
                PrintPointerInstance();
                break;
            case FC_FIXED_REPEAT:
            case FC_VARIABLE_REPEAT:
                FormatString.SetAddress(FormatString.GetAddress() - sizeof(UCHAR));
                PrintPointerRepeat();
                break;
            default:
                dout << "Unknown pointer layout type " << HexOut(LayoutType) << '\n';
                return;
            }
        }

    }

void FORMAT_PRINTER::PrintCorrelationDescriptor()
    {

    UCHAR CorrelationType = FormatString.GetUCHAR();     

    dout << "Correlation descriptor:\n";
        {

        IndentLevel l(dout);

        dout << "Correlation type:     " << HexOut(CorrelationType);
        switch ( CorrelationType & 0xF0 )
            {
            case FC_NORMAL_CONFORMANCE:
                dout << "(FC_NORMAL_CONFORMANCE,";
                break;
            case FC_POINTER_CONFORMANCE:
                dout << "(FC_POINTER_CONFORMANCE,";
                break;
            case FC_TOP_LEVEL_CONFORMANCE:
                dout << "(FC_TOP_LEVEL_CONFORMANCE,";
                break;
            case FC_TOP_LEVEL_MULTID_CONFORMANCE:
                dout << "(FC_TOP_LEVEL_MULTID_CONFORMANCE,";
                break;
            case FC_CONSTANT_CONFORMANCE:
                dout << "(FC_CONSTANT_CONFORMANCE,";
                break;
            default:
                dout << "(Unknown,";
                break;
            }
        dout << FormatString.GetFormatCharName(CorrelationType & 0x0F) << ")\n";

        UCHAR CorrelationOperator = FormatString.GetUCHAR();     
        dout << "Correlation operator: " << HexOut(CorrelationOperator);
        switch ( CorrelationOperator )
            {
            case FC_DEREFERENCE:
                dout << "(FC_DEREFERENCE)\n";
                break;
            case FC_DIV_2:
                dout << "(FC_DIV_2)\n";
                break;
            case FC_MULT_2:
                dout << "(FC_MULT_2)\n";
                break;
            case FC_SUB_1:
                dout << "(FC_SUB_1)\n";
                break;
            case FC_ADD_1:
                dout << "(FC_ADD_1)\n";
                break;
            case FC_CALLBACK:
                dout << "(FC_CALLBACK)\n";
                break;
            case 0:
                dout << "(NONE)\n";
                break;
            default:
                dout << "(Unknown)\n";
                break;
            }

        SHORT Offset = FormatString.GetSHORT();
        dout << "Offset:               " << HexOut(Offset) << '(' << Offset << ")\n";

        if ( Robust )
            {

            USHORT FlagsAsUSHORT = FormatString.GetUSHORT();
            NDR_CORRELATION_FLAGS *pFlags = (NDR_CORRELATION_FLAGS*)&FlagsAsUSHORT;

            dout << "Robust flags: ";
            if ( pFlags->Early )
                {
                dout << " Early ";
                }
            if ( pFlags->Split )
                {
                dout << " Split ";
                }
            if ( pFlags->IsIidIs )
                {
                dout << " IsIidIs ";
                }
            if ( pFlags->DontCheck )
                {
                dout << " IsIidIs ";
                }
            dout << '\n';
            }
        
        }
    }


PRINT_REDIRECT_TYPE(FC_RP,PrintPointerType)                    
PRINT_REDIRECT_TYPE(FC_UP,PrintPointerType)                    
PRINT_REDIRECT_TYPE(FC_OP,PrintPointerType)                     
PRINT_REDIRECT_TYPE(FC_FP,PrintPointerType)

// Structs have a common code path
#define PRINT_STRUCT_TYPE(type,ha,hp,hbp)    \
void FORMAT_PRINTER::HANDLE_##type() {  \
   PrintStruct(ha,hp,hbp);                   \
}

void FORMAT_PRINTER::PrintStruct(BOOL bHasArray, BOOL bHasPointers, BOOL bHasBogusPointers)
    {

    

    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';
    dout << "Alignment:   " << HexOut(FormatString.GetUCHAR()) << "      ";
    dout << "Memory size: " << HexOut(FormatString.GetUSHORT()) << '\n';

    if ( bHasArray )
        {
        OutputTypeAtOffset("Offset to array description: ", "Offset is 0, no array.");
        }

    UINT64 PointerLayoutAddress = FormatString.GetAddress();

    if ( bHasBogusPointers )
        {
        UINT64 Address = FormatString.GetAddress();
        SHORT Offset = FormatString.GetSHORT();
        UINT64 NewAddress = Address + Offset;
        PrintOffsetComment("Offset to bogus pointer layout: ", Offset, NewAddress);
        PointerLayoutAddress = NewAddress;
        }
    if ( bHasPointers )
        {
        dout << "Structure pointer layout:\n";
        UINT64 CurrentAddress = FormatString.SetAddress(PointerLayoutAddress); 
        PrintPointerLayout();
        if ( bHasBogusPointers )
            {
            PointerLayoutAddress = FormatString.SetAddress(CurrentAddress);            
            }

        }

    dout << "Structure memory layout:\n";
    UCHAR Format;
    while ( Format = FormatString.ReadUCHAR(), Format != FC_END )
        {
        IndentLevel l(dout);
        if ( FC_POINTER == Format )
            {
            dout << "FC_POINTER\n";
            FormatString.IncUCHAR();
            UINT64 CurrentAddress = FormatString.SetAddress(PointerLayoutAddress);
            PrintPointerType();
            PointerLayoutAddress = FormatString.SetAddress(CurrentAddress);
            }
        else {
            OutputType();            
        }
        }
    // Output the FC_END
    OutputType();

    }

//                type             ha     hp     hbp
PRINT_STRUCT_TYPE(FC_STRUCT,       FALSE, FALSE, FALSE)                  
PRINT_STRUCT_TYPE(FC_PSTRUCT,      FALSE, TRUE,  FALSE)               
PRINT_STRUCT_TYPE(FC_CSTRUCT,      TRUE,  FALSE, FALSE)                 
PRINT_STRUCT_TYPE(FC_CPSTRUCT,     TRUE,  TRUE,  FALSE)               
PRINT_STRUCT_TYPE(FC_CVSTRUCT,     TRUE,  TRUE,  FALSE)
PRINT_STRUCT_TYPE(FC_BOGUS_STRUCT, TRUE,  FALSE, TRUE)


// Arrays have a common code path
#define PRINT_ARRAY_TYPE(type,ts2,ts4,ne2,ne4,esize,cd,vd)       \
void FORMAT_PRINTER::HANDLE_##type() {                      \
    PrintArray(ts2,ts4,ne2,ne4,esize,cd,vd);                     \
}

void FORMAT_PRINTER::PrintArray(BOOL HasTotalSize2,
                                BOOL HasTotalSize4,
                                BOOL HasNumberElements2,                   
                                BOOL HasNumberElements4,
                                BOOL HasElementSize,
                                BOOL HasConformanceDescription,
                                BOOL HasVarianceDescription
                               )
    {
    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n'; 
    dout << "Alignment:       " << HexOut(FormatString.GetUCHAR()) << '\n';

    if ( HasTotalSize2 )
        {
        dout << "Total Size:      " << HexOut(FormatString.GetUSHORT()) << '\n';
        }

    if ( HasTotalSize4 )
        {
        dout << "Total Size:      " << HexOut(FormatString.GetULONG()) << '\n';
        }

    if ( HasNumberElements2 )
        {
        dout << "Number Elements: " << HexOut(FormatString.GetUSHORT()) << '\n';
        }

    if ( HasNumberElements4 )
        {
        dout << "Number Elements: " << HexOut(FormatString.GetULONG()) << '\n';
        }

    if ( HasElementSize )
        {
        dout << "Element Size:    " << HexOut(FormatString.GetUSHORT()) << '\n';
        }

    if ( HasConformanceDescription )
        {
        dout << "Array conformance descriptor:\n";
        PrintCorrelationDescriptor();
        }

    if ( HasVarianceDescription )
        {
        dout << "Array variance descriptor:\n";
        PrintCorrelationDescriptor();
        }

    dout << "Array pointer layout:\n";
    PrintPointerLayout();
    dout << "Element type:\n";
    OutputType();
    //Output the trailing FC_END
    OutputType();      
    }

//               type            ts2    ts4    ne2    ne4    esize  cd     vd
PRINT_ARRAY_TYPE(FC_CARRAY,      FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE)             
PRINT_ARRAY_TYPE(FC_CVARRAY,     FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE)             
PRINT_ARRAY_TYPE(FC_SMFARRAY,    TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)
PRINT_ARRAY_TYPE(FC_LGFARRAY,    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE)
PRINT_ARRAY_TYPE(FC_SMVARRAY,    TRUE,  FALSE, TRUE,  FALSE, TRUE,  FALSE, TRUE)
PRINT_ARRAY_TYPE(FC_LGVARRAY,    FALSE, TRUE,  FALSE, TRUE,  TRUE,  FALSE, TRUE)
PRINT_ARRAY_TYPE(FC_BOGUS_ARRAY, FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE)            

void FORMAT_PRINTER::PrintFixedString()
    {

    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';

    // Output the FC_PAD
    OutputType();

    dout << "String size: " << HexOut(FormatString.GetUSHORT()) << '\n';
    }

//DISPATCH_TYPE(FC_C_BSTRING)
PRINT_REDIRECT_TYPE(FC_CSTRING,PrintFixedString)
PRINT_REDIRECT_TYPE(FC_WSTRING,PrintFixedString)

void FORMAT_PRINTER::HANDLE_FC_C_SSTRING()
    {

    dout << "FC_C_SSTRING\n";
    FormatString.IncUCHAR();

    dout << "Element Size: " << FormatString.GetUCHAR() << '\n';
    dout << "Elements: " << FormatString.GetUSHORT() << '\n';
    }

void FORMAT_PRINTER::PrintCountedString()
    {

    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';    

    UCHAR PadChar = FormatString.GetUCHAR();
    if ( FC_PAD == PadChar )
        {
        dout << "FC_PAD\n";
        }
    else if ( FC_STRING_SIZED == PadChar )
        {
        dout << "FC_STRING_SIZED\n";
        PrintCorrelationDescriptor();
        }
    else
        {
        dout << "Unexpected char " << HexOut(PadChar) << '\n';
        }

    }

PRINT_REDIRECT_TYPE(FC_C_CSTRING,PrintCountedString)
PRINT_REDIRECT_TYPE(FC_C_WSTRING,PrintCountedString)            


//DISPATCH_TYPE(FC_BSTRING)            

void FORMAT_PRINTER::HANDLE_FC_SSTRING()
    {

    dout << "FC_C_SSTRING\n";
    FormatString.IncUCHAR();

    dout << "Element Size: " << FormatString.GetUCHAR() << '\n';
    dout << "Elements:     " << FormatString.GetUSHORT() << '\n';

    }

void FORMAT_PRINTER::PrintUnionArmOffsetToDescriptor()
    {
    
    SHORT OffsetToArmDescription = FormatString.ReadSHORT();
    
    dout << "Offset to arm description: " << HexOut(OffsetToArmDescription);
    if ( 0x8000 == (OffsetToArmDescription & 0xFF00) )
        {
        dout << " Simple type: " << 
        FormatString.GetFormatCharName((UCHAR)(OffsetToArmDescription & 0xFF)) << '\n';
        FormatString.IncSHORT();
        }
    else
        {
        dout << '\n';
        OutputTypeAtOffset(" Offset ", "Offset is 0, so arm is unused.");
        }    
    }

void FORMAT_PRINTER::PrintUnionArmSelector()
    {
    PrintFormatOffset();
    dout << "Union arm selector.\n";
    dout << "Memory size:  " << FormatString.GetUSHORT() << '\n';
    USHORT UnionArms = FormatString.GetUSHORT();

    USHORT ArmCounter;
    dout << "Union arms:   " << HexOut(UnionArms) 
    << " Alignment:   " << HexOut((USHORT)(UnionArms >> 12))
    << " ArmCounter:  " << HexOut(ArmCounter = (UnionArms & 0x0FFF)) << '\n';

    while ( ArmCounter-- )
        {
        ULONG ArmCaseValue = FormatString.GetULONG();
        dout << "ArmCaseValue: " << HexOut(ArmCaseValue) << ' ';

        PrintUnionArmOffsetToDescriptor(); 

        }
    dout << "Default arm\n";
    PrintUnionArmOffsetToDescriptor();

    }

void FORMAT_PRINTER::HANDLE_FC_ENCAPSULATED_UNION()
    {

    dout << "FC_ENCAPSULATED_UNION\n";
    FormatString.IncUCHAR();

    UCHAR SwitchType = FormatString.GetUCHAR();
    dout << "SwitchType:   " << HexOut(SwitchType) 
    << " MemoryInc:   " << HexOut((USHORT)(SwitchType & 0xF0)) 
    << " Actual Type: " << FormatString.GetFormatCharName(SwitchType & 0x0F) << '\n';

    PrintUnionArmSelector();

    }

void FORMAT_PRINTER::HANDLE_FC_NON_ENCAPSULATED_UNION()
    {

    dout << "FC_NON_ENCAPSULATED_UNION\n";
    FormatString.IncUCHAR();

    UCHAR SwitchType = FormatString.GetUCHAR();
    dout << "SwitchType:   " << HexOut(SwitchType) 
    << "(" << FormatString.GetFormatCharName(SwitchType) << ")\n";

    PrintCorrelationDescriptor();

    UINT64 CurrentAddress = FormatString.GetAddress();
    SHORT Offset = FormatString.GetSHORT();
    
        
    if ( Offset )
        {
        UINT64 NewAddress = CurrentAddress + Offset;
        PrintOffsetComment("Offset to union arms: ", Offset, NewAddress);
        FormatString.SetAddress(NewAddress);
        PrintUnionArmSelector();
        }
    else
        {
        dout << "Type offset is 0, type info is not available!\n";      
        }
    FormatString.SetAddress(CurrentAddress);
    FormatString.IncSHORT();

    }

void FORMAT_PRINTER::HANDLE_FC_BYTE_COUNT_POINTER()
    {

    dout << "FC_BYTE_COUNT_POINTER";
    FormatString.IncUCHAR();

    UCHAR SimpleType = FormatString.GetUCHAR();
    dout << "Simple Type:  " << FormatString.GetFormatCharName(SimpleType) << '\n';

    PrintCorrelationDescriptor();
    if ( FC_PAD == SimpleType )
        {
        dout << "Pointee description:\n";
        IndentLevel l(dout);
        OutputType();
        }
    }

void FORMAT_PRINTER::PrintTransmitAsRepresentAs()
    {

    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';

    UCHAR Flags = FormatString.GetUCHAR();

    dout << "Flags:                        " << HexOut(Flags) << '\n';
    {
        IndentLevel l(dout);
        if ( Flags & PRESENTED_TYPE_IS_ARRAY )
            {
            dout << " PRESENTED_TYPE_IS_ARRAY ";
            }
        if ( Flags & PRESENTED_TYPE_ALIGN_4 )
            {
            dout << " PRESENTED_TYPE_ALIGN_4 ";
            }
        if ( Flags & PRESENTED_TYPE_ALIGN_8 )
            {
            dout << " PRESENTED_TYPE_ALIGN_8 ";
            }
        dout << '\n';
    }

    dout << "Quintuple Index:              " << HexOut(FormatString.GetUSHORT()) << '\n';
    dout << "Presented type memory size:   " << HexOut(FormatString.GetUSHORT()) << '\n';
    dout << "Transmitted type buffer size: " << HexOut(FormatString.GetUSHORT()) << '\n';

    OutputTypeAtOffset("Offset to transmitted type: ", "Offset to tranmitted type is zero, no type selected.");

    }

PRINT_REDIRECT_TYPE(FC_TRANSMIT_AS, PrintTransmitAsRepresentAs)            
PRINT_REDIRECT_TYPE(FC_REPRESENT_AS, PrintTransmitAsRepresentAs)

void FORMAT_PRINTER::HANDLE_FC_IP()
    {

    dout << "FC_IP\n";
    FormatString.IncUCHAR();

    UCHAR SimpleType = FormatString.GetUCHAR();

    if ( FC_CONSTANT_IID == SimpleType )
        {
        dout << "FC_CONSTANT_IID\n";
        dout << "GUID:         " << FormatString.GetGUID() << '\n';
        }
    else if ( FC_PAD == SimpleType )
        {
        dout << "FC_PAD\n";
        PrintCorrelationDescriptor();
        }
    else
        {
        dout << "Unexpected char " << HexOut(SimpleType) << '\n';
        }

    }

PRINT_SIMPLE_TYPE(FC_BIND_CONTEXT)          
PRINT_SIMPLE_TYPE(FC_BIND_GENERIC)          
PRINT_SIMPLE_TYPE(FC_BIND_PRIMITIVE)       
PRINT_SIMPLE_TYPE(FC_AUTO_HANDLE)             
PRINT_SIMPLE_TYPE(FC_CALLBACK_HANDLE)           
PRINT_SIMPLE_TYPE(FC_UNUSED1)           

PRINT_SIMPLE_TYPE(FC_ALIGNM2)               
PRINT_SIMPLE_TYPE(FC_ALIGNM4)               
PRINT_SIMPLE_TYPE(FC_ALIGNM8)               
PRINT_SIMPLE_TYPE(FC_UNUSED2)              
PRINT_SIMPLE_TYPE(FC_UNUSED3)             
PRINT_SIMPLE_TYPE(FC_UNUSED4)             
PRINT_SIMPLE_TYPE(FC_STRUCTPAD1)       
PRINT_SIMPLE_TYPE(FC_STRUCTPAD2)            
PRINT_SIMPLE_TYPE(FC_STRUCTPAD3)           
PRINT_SIMPLE_TYPE(FC_STRUCTPAD4)            
PRINT_SIMPLE_TYPE(FC_STRUCTPAD5)            
PRINT_SIMPLE_TYPE(FC_STRUCTPAD6)             
PRINT_SIMPLE_TYPE(FC_STRUCTPAD7)

void FORMAT_PRINTER::HANDLE_FC_EMBEDDED_COMPLEX()
    {

    dout << "FC_EMBEDDED_COMPLEX\n";
    FormatString.IncUCHAR();
    {
       IndentLevel l(dout);
       dout << "Memory Pad:   " << HexOut(FormatString.GetUCHAR()) << '\n';
   
       OutputTypeAtOffset("Offset to embedded type: ", 
                          "Offset to embedded type is zero, no type selected.");    
    }

    }

PRINT_SIMPLE_TYPE(FC_END)                     
PRINT_SIMPLE_TYPE(FC_PAD)

void FORMAT_PRINTER::HANDLE_FC_USER_MARSHAL()
    {

    dout << "FC_USER_MARSHAL\n";
    FormatString.IncUCHAR();

    UCHAR Flags = FormatString.GetUCHAR();
    dout << "Flags:        " << HexOut(Flags) << '\n';
    {
        IndentLevel l(dout);
        if ( Flags & USER_MARSHAL_UNIQUE )
            {
            dout << " USER_MARSHAL_UNIQUE ";
            }
        if ( Flags & USER_MARSHAL_REF )
            {
            dout << " USER_MARSHAL_REF ";
            }
        if ( Flags & USER_MARSHAL_POINTER )
            {
            dout << " USER_MARSHAL_POINTER ";
            }
        if ( Flags & USER_MARSHAL_IID )
            {
            dout << " USER_MARSHAL_IID ";
            }
        dout << '\n';    
    }

    dout << "Quintuple Index:              " << HexOut(FormatString.GetUSHORT()) << '\n';
    dout << "User type memory size:        " << HexOut(FormatString.GetUSHORT()) << '\n';
    dout << "Transmitted type buffer size: " << HexOut(FormatString.GetUSHORT()) << '\n';

    OutputTypeAtOffset("Offset to transmitted type: ", 
                       "Offset to tranmitted type is zero, no type selected.");

    }

void FORMAT_PRINTER::HANDLE_FC_PIPE()
    {

    dout << "FC_PIPE\n";
    FormatString.IncUCHAR();


    UCHAR FlagsAndAlignment = FormatString.GetUCHAR();
    dout << "FlagsAndAlignment: " << HexOut(FlagsAndAlignment) << '\n';
    dout << "Flags:             \n";
    {
        IndentLevel l(dout);
        if ( FlagsAndAlignment & FC_BIG_PIPE )
            {
            dout << "FC_BIG_PIPE";
            }
        if ( FlagsAndAlignment & FC_OBJECT_PIPE )
            {
            dout << "FC_OBJECT_PIPE";
            }
        if ( FlagsAndAlignment & FC_PIPE_HAS_RANGE )
            {
            dout << "FC_PIPE_HAS_RANGE";
            }
        dout << '\n';
    }
    dout << "Alignment: " << HexOut((UCHAR)(FlagsAndAlignment & 0x0F)) << '\n';

    OutputTypeAtOffset("Offset to type: ", 
                       "Offset to tranmitted type is zero, no type for pipe!.");

    if ( FlagsAndAlignment & FC_BIG_PIPE )
        {
        dout << "Memory size:   " << HexOut(FormatString.GetULONG()) << '\n';
        dout << "Buffer size:   " << HexOut(FormatString.GetULONG()) << '\n';
        }
    else
        {
        dout << "Memory size:   " << HexOut(FormatString.GetUSHORT()) << '\n';
        dout << "Buffer size:   " << HexOut(FormatString.GetUSHORT()) << '\n';
        }
    if ( FlagsAndAlignment & FC_PIPE_HAS_RANGE )
        {
        dout << "Minimum size:  " << HexOut(FormatString.GetUSHORT()) << '\n';
        dout << "Maximum size:  " << HexOut(FormatString.GetUSHORT()) << '\n';
        }

    }

PRINT_SIMPLE_TYPE(FC_BLKHOLE) //Todo                

void FORMAT_PRINTER::HANDLE_FC_RANGE()
    {

    dout << "FC_RANGE\n";
    FormatString.IncUCHAR();

    UCHAR TypeAndFlags = FormatString.GetUCHAR();
    dout << "Type and flags: " << HexOut(TypeAndFlags)
    << " Flags: " << HexOut((UCHAR)(TypeAndFlags & 0xF0))
    << " Type:  " << FormatString.GetFormatCharName((UCHAR)(TypeAndFlags & 0x0F)) << '\n';

    dout << "Min value:      " << HexOut(FormatString.GetULONG()) << '\n';
    dout << "Max value:      " << HexOut(FormatString.GetULONG()) << '\n';

    }

PRINT_SIMPLE_TYPE(FC_INT3264)              
PRINT_SIMPLE_TYPE(FC_UINT3264)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrexts\ndrexts\globals.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    This file contains globals variable for RPC NDR debugger extensions.

Author:

    David Kays  (dkays)     August 1 1994

Revision History:


--*/


#define NDREXTS_GLOBALS
#include "ndrextsp.hxx"

#define NDR_GLOBAL_TABLES_ONLY

#include "..\ndr20\global.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrexts\ndrexts\bufout.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    bufout.cxx

Abstract:


Author:

    Mike Zoran  (mzoran)     September 3, 1999

Revision History:


--*/

#include "ndrextsp.hxx"

//
// BUFFER_PRINTER
//

BUFFER_SIMPLE_TYPE::BUFFER_SIMPLE_TYPE() : IsInt(TRUE),
                                           Precision(1),
                                           IntValue(0),
                                           FloatValue(0.0)
{}

void BUFFER_SIMPLE_TYPE::SetIntValue(INT64 x)
{
    IsInt = TRUE;
    IntValue = x;
}

void BUFFER_SIMPLE_TYPE::SetCHAR(CHAR x) 
{
   Precision = 1;
   SetIntValue(x);
}

void BUFFER_SIMPLE_TYPE::SetSHORT(SHORT x)
{
    Precision = sizeof(SHORT);
    SetIntValue(x);
}

void BUFFER_SIMPLE_TYPE::SetLONG(LONG x)
{
    Precision = sizeof(LONG);
    SetIntValue(x);
}

void BUFFER_SIMPLE_TYPE::SetINT64(INT64 x)
{
    Precision = sizeof(INT64);
    SetIntValue(x);
}

void BUFFER_SIMPLE_TYPE::SetDOUBLE(double x)
{
    IsInt = FALSE;
    FloatValue = x;
}

BOOL BUFFER_SIMPLE_TYPE::operator==(const BUFFER_SIMPLE_TYPE & x)
{
    
    if (IsInt && x.IsInt)
        return IntValue == x.IntValue;
    else if (!IsInt && !IsInt)
        return FloatValue == x.FloatValue;        
    
    double ThisValue = IsInt ? (double)IntValue : FloatValue;
    double OtherValue = IsInt ? (double)x.IntValue : x.FloatValue;
    return ThisValue == OtherValue;
}

BOOL BUFFER_SIMPLE_TYPE::operator==(INT64 x)
{   
    if (IsInt)
       return IntValue == x;

    return FloatValue==(double)x;
}

BOOL BUFFER_SIMPLE_TYPE::operator==(double x)
{
    if (!IsInt)
        return FloatValue == x;
  
    return (double)IntValue == x;      
}

ostream & BUFFER_SIMPLE_TYPE::Print(ostream & out)
{
    if (IsInt)
        {
        return out << HexOut(IntValue, Precision);
        }
    return out << HexOut(FloatValue);
}



//
// BUFFER
//


BUFFER::BUFFER(UINT64 Addr, ULONG Len) : BufferBegin(Addr),
BufferCurrent(Addr),
BufferEnd(Addr + Len),
BufferLength(Len)
    {
    
    }

VOID BUFFER::ValidateRange(LONG Delta)
    {
    if ( BufferCurrent < BufferBegin || BufferCurrent > BufferEnd )
        {
        ABORT("Current rpc buffer position is out of range.\n" <<
              "Current buffer pointer: " << HexOut((ULONG)BufferCurrent) <<
              " Buffer start: " << HexOut((ULONG)BufferBegin) <<
              " Buffer end: " << HexOut((ULONG)BufferEnd) << '\n');
        }
    if ( BufferCurrent+Delta < BufferBegin || BufferCurrent+Delta > BufferEnd )
        {
        ABORT("New rpc buffer position is out of range.\n" <<
              "New buffer pointer: " << HexOut((ULONG)(BufferCurrent+Delta)) <<
              " Buffer start: " << HexOut((ULONG)BufferBegin) <<
              " Buffer end: " << HexOut((ULONG)BufferEnd) << '\n');
        }
    }

VOID  BUFFER::Move(LONG Delta)
    {
    ValidateRange(Delta);
    BufferCurrent += Delta;
    }

UINT64 BUFFER::GetAddress()
    {
    return BufferCurrent;
    }

UINT64 BUFFER::SetAddress(UINT64 Addr)
    {

    ValidateRange(0);

    if ( Addr < BufferBegin || Addr > BufferEnd )
        {
        ABORT("New rpc buffer position is out of range.\n" <<
              "New buffer pointer: " << HexOut(Addr) <<
              " Buffer start: " << HexOut(BufferBegin) <<
              " Buffer end: " << HexOut(BufferEnd) << '\n');
        }

    swap( Addr, BufferCurrent );
    return Addr;
    }

VOID BUFFER::Align( UINT64 Mask )
    {

    ValidateRange(0);

    UINT64 NewAddress = (BufferCurrent + Mask) & ~Mask;
    SetAddress(NewAddress);

    }

#define DEFINE_BUFFER_TYPE(type)                                                 \
    type BUFFER::Read##type##() {                                                \
        ValidateRange(sizeof(type));                                             \
        type Tmp;  ReadMemory(BufferCurrent,&Tmp); return Tmp;                   \
    }                                                                            \
    type BUFFER::Get##type##() {                                                 \
        ValidateRange(sizeof(type));                                             \
        type Tmp;  ReadMemory(BufferCurrent,&Tmp); BufferCurrent += sizeof(Tmp); return Tmp; \
    }                                                                            \
    VOID BUFFER::Inc##type##() {                                                 \
        Move(sizeof(type));                                                      \
    }                                                                            \
    void BUFFER::Align##type##() {                                               \
        Align(sizeof(type) - 1);                                                 \
    }

DEFINE_BUFFER_TYPE(UCHAR)
DEFINE_BUFFER_TYPE(CHAR)
DEFINE_BUFFER_TYPE(USHORT)
DEFINE_BUFFER_TYPE(SHORT)
DEFINE_BUFFER_TYPE(ULONG)
DEFINE_BUFFER_TYPE(LONG)
DEFINE_BUFFER_TYPE(UINT64)
DEFINE_BUFFER_TYPE(INT64)
DEFINE_BUFFER_TYPE(FLOAT)
DEFINE_BUFFER_TYPE(DOUBLE)

GUID BUFFER::ReadGUID()
{
    GUID RetVal;
    Read(&RetVal, sizeof(GUID));
    return RetVal;
}

GUID BUFFER::GetGUID()
{
    GUID RetVal;
    Get(&RetVal, sizeof(GUID));
    return RetVal;

}

VOID BUFFER::IncGUID()
{
    Move(sizeof(GUID));
}

VOID BUFFER::AlignGUID()
{
    // GUIDs are ULONG aligned on the wire
    AlignULONG();
}

VOID BUFFER::AlignBUFFER_SIMPLE_TYPE(UCHAR FormatChar)
{
    Align( SIMPLE_TYPE_ALIGNMENT( FormatChar ) );
}

BUFFER_SIMPLE_TYPE BUFFER::ReadBUFFER_SIMPLE_TYPE(UCHAR FormatChar)
{
    BUFFER_SIMPLE_TYPE retval;

    switch ( FormatChar )
        {
        case FC_CHAR :
            retval.SetCHAR(ReadCHAR());
            break;
        
        case FC_BYTE :
        case FC_SMALL :
        case FC_USMALL :
            retval.SetCHAR(ReadUCHAR());
            break;

        case FC_ENUM16 :
        case FC_SHORT :
            retval.SetSHORT(ReadSHORT());
            break;

        case FC_WCHAR :
        case FC_USHORT :
            retval.SetSHORT(ReadUSHORT());
            break;

        case FC_INT3264:
        case FC_LONG :
        case FC_ENUM32 :
        case FC_ERROR_STATUS_T:
            retval.SetLONG(ReadLONG());
            break;

        case FC_UINT3264:
        case FC_ULONG :            
            retval.SetLONG(ReadULONG());
            break;
        
        case FC_HYPER :
            retval.SetINT64(ReadINT64());

        case FC_FLOAT :
            retval.SetDOUBLE(ReadFLOAT());
            break;

        case FC_DOUBLE :
            retval.SetDOUBLE(ReadDOUBLE());
            break;
        case FC_IGNORE :
            break;

        default :
            ABORT( "Bad format char.\n" );
            break;
        }

    return retval;
       
}

BUFFER_SIMPLE_TYPE BUFFER::GetBUFFER_SIMPLE_TYPE(UCHAR FormatChar)
{
    BUFFER_SIMPLE_TYPE retval = ReadBUFFER_SIMPLE_TYPE( FormatChar );
    IncBUFFER_SIMPLE_TYPE( FormatChar );
    return retval;
}

VOID BUFFER::IncBUFFER_SIMPLE_TYPE(UCHAR FormatChar)
{
    Move( SIMPLE_TYPE_BUFSIZE( FormatChar ) );
}


VOID BUFFER::Read(PVOID pOut, LONG Len)
    {
    ValidateRange(Len);
    ReadMemory((void*)BufferCurrent, pOut, Len);
    }

VOID BUFFER::Get(PVOID pOut, LONG Len)
    {
    Read(pOut, Len);
    Move(Len);
    }

ULONG BUFFER::GetCurrentOffset()
    {
    return BufferCurrent - BufferBegin;
    }

// FULL_PTR_TABLE

BOOL
FULL_PTR_TABLE::Add(UINT64 Address)
    {
    return s.insert(Address).second;
    }

VOID
FULL_PTR_TABLE::Clear()
    {
    s.clear();
    }

// POINTER

char * PointerNames[] =
{
    "Ref",
    "Unique",
    "Object",
    "Full"
};

ULONG POINTER::GlobalPtrId = 0;

POINTER::POINTER( FORMAT_STRING *pFormat, BUFFER *pBuffer, BUFFER_PRINTER *pBufferPrinter,
                  BOOL ArrayRef ) :
                  dout(pBufferPrinter->dout)
    {
    POINTER::pBufferPrinter = pBufferPrinter;
    PtrId = GlobalPtrId++;
    BufferAddress = pBuffer->GetAddress();
    FormatAddress = pFormat->GetAddress();
    PointerType = pFormat->GetUCHAR();
    PointerAttributes = pFormat->GetUCHAR();
    IsEmbedded = pBufferPrinter->IsEmbedded;
    POINTER::ArrayRef = ArrayRef;

    if ( ArrayRef )
        {
        if (FC_RP != PointerType || !IsEmbedded)
            {
            ABORT("Only refer ref pointer embedded in array can be ArrayRef.\n");
            }
        }

    switch ( PointerType )
        {
        case FC_IP:
            if ( FC_CONSTANT_IID == PointerAttributes )
                {
                IId = pFormat->GetGUID();
                }
            else
                {
                pFormat->SkipCorrelationDesc( pBufferPrinter->IsRobust );
                }
            break;

        case FC_BYTE_COUNT_POINTER:

            // BUG, BUG does not skip entire format string
            if ( FC_PAD == PointerAttributes )
                {
                pFormat->SkipCorrelationDesc( pBufferPrinter->IsRobust );
                PointeeFormatAddress = pFormat->GetAddress();
                }
            else
                {
                PointeeFormatAddress = pFormat->GetAddress() - 1;
                pFormat->SkipCorrelationDesc( pBufferPrinter->IsRobust );
                }

        default:
            if ( SIMPLE_POINTER(PointerAttributes) )
                {
                PointeeFormatAddress = pFormat->GetAddress();
                pFormat->IncUCHAR(); // Skip type format char
                pFormat->IncUCHAR(); // Skip pad.
                }
            else
                {
                PointeeFormatAddress = pFormat->ComputeOffset();
                }
        }
    }

VOID POINTER::SkipCommonPointerFormat( FORMAT_STRING *FormatString )
  {
  FormatString->IncUCHAR();
  FormatString->IncUCHAR();
  FormatString->IncSHORT();
  }

BOOL 
POINTER::HasWireRep()
  {
   return !ArrayRef && (FC_RP != PointerType || IsEmbedded);
  }

ULONG 
POINTER::GetWireRep(BUFFER *pBuffer) 
    {
    BUFFER TempBuffer = *pBuffer;
    pBuffer = &TempBuffer;

    if ( HasWireRep() )
        {
        pBuffer->SetAddress( BufferAddress);
        pBuffer->AlignULONG();
        return pBuffer->GetULONG(); 
        }
    return NULL;
    }

VOID 
POINTER::OutputPointer( ULONG WireRep ) 
    {
    dout << PointerNames[ PointerType - FC_RP ] << " pointer <id=" << PtrId << ">";

    if ( HasWireRep() )
        dout << " <wire ref=" << HexOut( WireRep ) << ">\n";

    else
        dout << "Pointer does not have a wire reprentation. \n";                   
    }

VOID 
POINTER::OutputPointee( ULONG WireRep, FULL_PTR_TABLE *pFullPointerList, 
                        BUFFER *pPointeeBuffer ) 
    {

    IndentLevel l(dout);

    if ( PointerType != FC_RP  && !WireRep )
        {
        dout << "Pointer is done: pointer <id=" << PtrId << ">.\n";
        return;
        }

    if ( FC_FP == PointerType && !pFullPointerList->Add( WireRep ) )
        {
        dout << "Pointer is done: pointer <id=" << PtrId << ">.\n";
        return;
        }

    dout << "Pointee of pointer <id=" << PtrId << ">.\n";

    if ( FC_IP == PointerType )
        {
        OutputInterfacePointer( pPointeeBuffer ); 
        }
    else
        {

        // Swap the embedded pointer list if we are not embedded
        POINTER_LIST NewEmbeddedPointerList;
        SWAP_SCOPE<POINTER_LIST*> swapscope1(& pBufferPrinter->EmbeddedPointerList, 
                                             & NewEmbeddedPointerList, TRUE );
        SWAP_SCOPE<BUFFER*> swapscope2( & pBufferPrinter->Buffer, 
                                        pPointeeBuffer );
        
        // Pointee is no longer embedded
        SWAP_SCOPE<BOOL> swapscope3( & pBufferPrinter->IsEmbedded, FALSE );
        SWAP_SCOPE<BOOL> swapscope4( & pBufferPrinter->IsConformantArrayDone, FALSE );
        SWAP_SCOPE<BOOL> swapscope5( & pBufferPrinter->IsStructEmbedded, FALSE );
        SWAP_SCOPE<BOOL> swapscope6( & pBufferPrinter->IsArrayEmbedded, FALSE );        
        SWAP_SCOPE<BUFFER*> swapscope7( & pBufferPrinter->ConformanceCountBuffer, NULL );

        IndentLevel l(dout);

        pBufferPrinter->OutputType( PointeeFormatAddress );
        }

    }

VOID
POINTER::OutputPointee() 
    {
    BUFFER WireBuffer = *pBufferPrinter->Buffer;
    WireBuffer.SetAddress( BufferAddress );
    ULONG WireRep = GetWireRep( &WireBuffer );

    OutputPointee( WireRep, &pBufferPrinter->FullPointerTable, 
                   pBufferPrinter->Buffer );  
    }

VOID
POINTER::OutputInterfacePointer(BUFFER * Buffer) 
    {
    GUID IGUID;
    ULONG Size, SizeAgain;

    // See where the GUID comes from.

    if ( FC_CONSTANT_IID == PointerAttributes )
        {
        dout << "Interface pointer with constant IID\n";
        }
    else
        {
        dout << "Interface pointer with variable IID\n";

        Buffer->AlignULONG();
        IGUID = Buffer->GetGUID();
        }
    {
        IndentLevel l(dout);
        dout << "GUID is " << IGUID << '\n';

        // Now the open array.

        // Read the conformant size for the open array.

        Buffer->AlignULONG();
        ULONG Size = Buffer->GetULONG();


        dout << "Data size is " << Size;

        // Skip the size field of the struct.

        SizeAgain = Buffer->GetULONG();

        if ( SizeAgain != Size )
            dout << " SizeAgain = " << SizeAgain << " ???" << '\n';

        if ( Size )
            {
            char *pBuffer = new char[ Size ];
            Buffer->Get( pBuffer, Size );

            for ( uint j = 0; j < Size; j++ )
                {
                if ( (j % 16) == 0 )
                    {
                    dout << '\n';
                    }
                dout << HexOut((unsigned char)pBuffer[j]);
                }
            delete[] pBuffer;
            }

        dout << '\n';
    }
    }

POINTER_LIST::POINTER_LIST() {}

POINTER_LIST::~POINTER_LIST()
    {
    Clear();
    }

BOOL POINTER_LIST::Add(UINT64 Address, POINTER *pPointer) 
    {
    //Only add to list if pointer has a wire rep.
    if (pPointer->HasWireRep())
        {
        BOOL bNew = m.insert(MAP_TYPE::value_type(Address,pPointer)).second;
        if ( !bNew )
           return bNew;
        
        }
    q.push_back( pPointer );

    return TRUE;
    }

BOOL POINTER_LIST::Lookup(UINT64 Address, POINTER ** ppPointer) 
    {
    MAP_TYPE::const_iterator i;
    i = m.find( Address );
    if ( m.end() == i )
        return FALSE;
    if (NULL != ppPointer)
        {
        *ppPointer = i->second;        
        }
    return TRUE;
    }

VOID POINTER_LIST::Clear()
    {
    m.clear();
    for ( LIST_TYPE::iterator i = q.begin(); i != q.end(); i++ )
        {
        delete (*i);
        }
    q.clear();
    }

VOID POINTER_LIST::OutputPointees()
    {
    for ( LIST_TYPE::iterator i = q.begin(); i != q.end(); i++ )
        {
        (*i)->OutputPointee();
        }
    }

//
// Buffer Printer
// 

BUFFER_PRINTER::BUFFER_PRINTER(
                              FORMATTED_STREAM_BUFFER & mydout,
                              UINT64 Buffer, 
                              ULONG BufferLength, 
                              UINT64 ProcInfo,
                              UINT64 TypeInfo ) : OriginalBuffer( Buffer, BufferLength ) ,
ProcFormatString( ProcInfo ), 
TypeFormatString( TypeInfo ),
dout(mydout)
    {
    
    }

VOID BUFFER_PRINTER::SetupWorkValues()
    {

    WorkBuffer = OriginalBuffer;
    Buffer = &WorkBuffer;
    ConformanceCountBuffer = NULL;
    VarianceBuffer = NULL;

    WorkProcFormatString = ProcFormatString;
    WorkTypeFormatString = TypeFormatString;
    FormatString = &WorkProcFormatString;

    FullPointerTable.Clear();
    OriginalEmbeddedPointerList.Clear();
    EmbeddedPointerList = &OriginalEmbeddedPointerList;
    IsEmbedded = IsRobust = FALSE;
    IsConformantArrayDone = IsStructEmbedded = IsArrayEmbedded = FALSE;
    }

#define DISPATCH_TYPE(type)         \
   case type:                       \
      HANDLE_##type ();             \
      break;


VOID
BUFFER_PRINTER::OutputType()
    {
    UCHAR FormatChar = FormatString->ReadUCHAR();
    switch ( FormatChar )
        {
        default:
            dout << "Unknown type " << HexOut(FormatChar) << " found at " 
            << HexOut(FormatString->GetAddress()) << ".\n";
            break;

            DISPATCH_TYPE(FC_ZERO)
            DISPATCH_TYPE(FC_BYTE)                    
            DISPATCH_TYPE(FC_CHAR)                    
            DISPATCH_TYPE(FC_SMALL)                   
            DISPATCH_TYPE(FC_USMALL)                  
            DISPATCH_TYPE(FC_WCHAR)                   
            DISPATCH_TYPE(FC_SHORT)                   
            DISPATCH_TYPE(FC_USHORT)                  
            DISPATCH_TYPE(FC_LONG)                    
            DISPATCH_TYPE(FC_ULONG)                   
            DISPATCH_TYPE(FC_FLOAT)                   
            DISPATCH_TYPE(FC_HYPER)                  
            DISPATCH_TYPE(FC_DOUBLE)                  
            DISPATCH_TYPE(FC_ENUM16)                  
            DISPATCH_TYPE(FC_ENUM32)                  
            DISPATCH_TYPE(FC_IGNORE)                  
            DISPATCH_TYPE(FC_ERROR_STATUS_T)          
            DISPATCH_TYPE(FC_RP)                   
            DISPATCH_TYPE(FC_UP)                   
            DISPATCH_TYPE(FC_OP)                   
            DISPATCH_TYPE(FC_FP)                    
            DISPATCH_TYPE(FC_STRUCT)                  
            DISPATCH_TYPE(FC_PSTRUCT)               
            DISPATCH_TYPE(FC_CSTRUCT)                 
            DISPATCH_TYPE(FC_CPSTRUCT)               
            DISPATCH_TYPE(FC_CVSTRUCT)      
            DISPATCH_TYPE(FC_BOGUS_STRUCT)          
            DISPATCH_TYPE(FC_CARRAY)             
            DISPATCH_TYPE(FC_CVARRAY)             
            DISPATCH_TYPE(FC_SMFARRAY)            
            DISPATCH_TYPE(FC_LGFARRAY)         
            DISPATCH_TYPE(FC_SMVARRAY)            
            DISPATCH_TYPE(FC_LGVARRAY)            
            DISPATCH_TYPE(FC_BOGUS_ARRAY)       
            DISPATCH_TYPE(FC_C_CSTRING)                
            DISPATCH_TYPE(FC_C_SSTRING)           
            DISPATCH_TYPE(FC_C_WSTRING)            
            DISPATCH_TYPE(FC_CSTRING)                        
            DISPATCH_TYPE(FC_SSTRING)              
            DISPATCH_TYPE(FC_WSTRING)               
            DISPATCH_TYPE(FC_ENCAPSULATED_UNION)      
            DISPATCH_TYPE(FC_NON_ENCAPSULATED_UNION) 
            DISPATCH_TYPE(FC_BYTE_COUNT_POINTER)      
            DISPATCH_TYPE(FC_TRANSMIT_AS)            
            DISPATCH_TYPE(FC_REPRESENT_AS)            
            DISPATCH_TYPE(FC_IP)                     
            DISPATCH_TYPE(FC_BIND_CONTEXT)          
            DISPATCH_TYPE(FC_BIND_GENERIC)          
            DISPATCH_TYPE(FC_BIND_PRIMITIVE)       
            DISPATCH_TYPE(FC_AUTO_HANDLE)             
            DISPATCH_TYPE(FC_CALLBACK_HANDLE)           
            DISPATCH_TYPE(FC_UNUSED1)                       
            DISPATCH_TYPE(FC_ALIGNM2)               
            DISPATCH_TYPE(FC_ALIGNM4)               
            DISPATCH_TYPE(FC_ALIGNM8)               
            DISPATCH_TYPE(FC_UNUSED2)              
            DISPATCH_TYPE(FC_UNUSED3)             
            DISPATCH_TYPE(FC_UNUSED4)             
            DISPATCH_TYPE(FC_STRUCTPAD1)       
            DISPATCH_TYPE(FC_STRUCTPAD2)            
            DISPATCH_TYPE(FC_STRUCTPAD3)           
            DISPATCH_TYPE(FC_STRUCTPAD4)            
            DISPATCH_TYPE(FC_STRUCTPAD5)            
            DISPATCH_TYPE(FC_STRUCTPAD6)             
            DISPATCH_TYPE(FC_STRUCTPAD7)            
            DISPATCH_TYPE(FC_EMBEDDED_COMPLEX)        
            DISPATCH_TYPE(FC_END)                     
            DISPATCH_TYPE(FC_PAD)                                 
            DISPATCH_TYPE(FC_USER_MARSHAL)           
            DISPATCH_TYPE(FC_PIPE)                   
            DISPATCH_TYPE(FC_BLKHOLE)                 
            DISPATCH_TYPE(FC_RANGE)                       
            DISPATCH_TYPE(FC_INT3264)              
            DISPATCH_TYPE(FC_UINT3264)   
        }

    }

// Some types need redirecting to a common processing function
#define PRINT_REDIRECT_TYPE(type,func)      \
void BUFFER_PRINTER::HANDLE_##type() {      \
   func();                                  \
}

#define PRINT_SIMPLE_TYPE(type)             \
void BUFFER_PRINTER::HANDLE_##type() {      \
   OutputSimpleType( FALSE, 0 );            \
}

#define IGNORE_TYPE(type)                   \
void BUFFER_PRINTER::HANDLE_##type() {      \
   FormatString->GetUCHAR();                \
   return;                                  \
}

#define TODO_TYPE(type)                     \
void BUFFER_PRINTER::HANDLE_##type() {      \
   FormatString->GetUCHAR();                \
   return;                                  \
}

PRINT_SIMPLE_TYPE(FC_ZERO)
PRINT_SIMPLE_TYPE(FC_BYTE)                    
PRINT_SIMPLE_TYPE(FC_CHAR)                    
PRINT_SIMPLE_TYPE(FC_SMALL)                   
PRINT_SIMPLE_TYPE(FC_USMALL)                  
PRINT_SIMPLE_TYPE(FC_WCHAR)                   
PRINT_SIMPLE_TYPE(FC_SHORT)                   
PRINT_SIMPLE_TYPE(FC_USHORT)                  
PRINT_SIMPLE_TYPE(FC_LONG)                    
PRINT_SIMPLE_TYPE(FC_ULONG)                   
PRINT_SIMPLE_TYPE(FC_FLOAT)                   
PRINT_SIMPLE_TYPE(FC_HYPER)                  
PRINT_SIMPLE_TYPE(FC_DOUBLE)                  
PRINT_SIMPLE_TYPE(FC_ENUM16)                  
PRINT_SIMPLE_TYPE(FC_ENUM32)                  
IGNORE_TYPE(FC_IGNORE)                  
PRINT_SIMPLE_TYPE(FC_ERROR_STATUS_T)

#define PRINT_POINTER_TYPE(type)            \
void BUFFER_PRINTER::HANDLE_##type() {      \
   OutputPointer(!IsEmbedded, FALSE);       \
}

PRINT_POINTER_TYPE(FC_RP)                   
PRINT_POINTER_TYPE(FC_UP)                   
PRINT_POINTER_TYPE(FC_OP)                   
PRINT_POINTER_TYPE(FC_FP)   

PRINT_REDIRECT_TYPE(FC_STRUCT,OutputStructure)   
PRINT_REDIRECT_TYPE(FC_PSTRUCT,OutputStructure)   
PRINT_REDIRECT_TYPE(FC_CSTRUCT,OutputStructure)   
PRINT_REDIRECT_TYPE(FC_CPSTRUCT,OutputStructure)   
PRINT_REDIRECT_TYPE(FC_CVSTRUCT,OutputStructure)   
PRINT_REDIRECT_TYPE(FC_BOGUS_STRUCT,OutputStructure)

PRINT_REDIRECT_TYPE(FC_CARRAY,OutputArray)          
PRINT_REDIRECT_TYPE(FC_CVARRAY,OutputArray)
PRINT_REDIRECT_TYPE(FC_SMFARRAY,OutputArray)
PRINT_REDIRECT_TYPE(FC_LGFARRAY,OutputArray)             
PRINT_REDIRECT_TYPE(FC_SMVARRAY,OutputArray)
PRINT_REDIRECT_TYPE(FC_LGVARRAY,OutputArray)
PRINT_REDIRECT_TYPE(FC_BOGUS_ARRAY,OutputArray)

PRINT_REDIRECT_TYPE(FC_C_CSTRING,OutputString)
PRINT_REDIRECT_TYPE(FC_C_SSTRING,OutputString)
PRINT_REDIRECT_TYPE(FC_C_WSTRING,OutputString)
PRINT_REDIRECT_TYPE(FC_CSTRING,OutputString)
PRINT_REDIRECT_TYPE(FC_SSTRING,OutputString)
PRINT_REDIRECT_TYPE(FC_WSTRING,OutputString)

PRINT_REDIRECT_TYPE(FC_ENCAPSULATED_UNION,OutputEncapsulatedUnion)                                                   
PRINT_REDIRECT_TYPE(FC_NON_ENCAPSULATED_UNION,OutputUnion)
PRINT_POINTER_TYPE(FC_BYTE_COUNT_POINTER)        
PRINT_REDIRECT_TYPE(FC_TRANSMIT_AS,OutputXmit)            
PRINT_REDIRECT_TYPE(FC_REPRESENT_AS,OutputXmit)   
PRINT_POINTER_TYPE(FC_IP)            

PRINT_REDIRECT_TYPE(FC_BIND_CONTEXT,OutputContextHandle)          
IGNORE_TYPE(FC_BIND_GENERIC)          
IGNORE_TYPE(FC_BIND_PRIMITIVE)       
IGNORE_TYPE(FC_AUTO_HANDLE)             
IGNORE_TYPE(FC_CALLBACK_HANDLE)           
IGNORE_TYPE(FC_UNUSED1)
IGNORE_TYPE(FC_ALIGNM2)               
IGNORE_TYPE(FC_ALIGNM4)               
IGNORE_TYPE(FC_ALIGNM8)               
IGNORE_TYPE(FC_UNUSED2)              
IGNORE_TYPE(FC_UNUSED3)             
IGNORE_TYPE(FC_UNUSED4)             
IGNORE_TYPE(FC_STRUCTPAD1)       
IGNORE_TYPE(FC_STRUCTPAD2)            
IGNORE_TYPE(FC_STRUCTPAD3)           
IGNORE_TYPE(FC_STRUCTPAD4)            
IGNORE_TYPE(FC_STRUCTPAD5)            
IGNORE_TYPE(FC_STRUCTPAD6)             
IGNORE_TYPE(FC_STRUCTPAD7)            
PRINT_REDIRECT_TYPE(FC_EMBEDDED_COMPLEX,OutputEmbeddedComplex)        
IGNORE_TYPE(FC_END)                     
IGNORE_TYPE(FC_PAD)                                 
PRINT_REDIRECT_TYPE(FC_USER_MARSHAL,OutputXmit)           
TODO_TYPE(FC_PIPE)                   
IGNORE_TYPE(FC_BLKHOLE)                 
PRINT_REDIRECT_TYPE(FC_RANGE,OutputRangedType)                       
PRINT_SIMPLE_TYPE(FC_INT3264)              
PRINT_SIMPLE_TYPE(FC_UINT3264)

VOID BUFFER_PRINTER::OutputType(UINT64 Address)
    {
    FORMAT_STRING *pBackupFormatString = FormatString;
    FORMAT_STRING NewFormatString;
    FormatString = &NewFormatString;

    FormatString->SetAddress( Address );
    OutputType();
    FormatString = pBackupFormatString;

    }

VOID BUFFER_PRINTER::OutputTypeFromOffset() 
    {
    FormatString->GotoOffset();
    OutputType();
    }

// Spaces needed for pretty printing.

char * FcTypeName[] =
{
    "FC_ZERO??",
    "byte    ",
    "char    ",
    "small   ",
    "usmall  ",
    "wchar   ",
    "short   ",
    "ushort  ",
    "long    ",
    "ulong   ",
    "float   ",
    "hyper   ",
    "double  ",
    "enum16  ",
    "enum32  ",
    "ignore  ",
    "err_st_t",
    "ref  ptr",
    "uniq ptr",
    "obj  ptr",
    "full ptr"
};

void
BUFFER_PRINTER::OutputSimpleType( BOOL IsArray, ULONG ArrayElements )
    {

    UCHAR FormatChar = FormatString->GetUCHAR();
    UINT64 BufferAddress = Buffer->GetAddress();

    UCHAR UseFormatChar = IS_SIMPLE_TYPE( FormatChar ) ? FormatChar : FC_ULONG;
    
    Buffer->AlignBUFFER_SIMPLE_TYPE( UseFormatChar );

    if (!IsArray)
        {
        ArrayElements = 1;
        }

    // BUG, BUG expand this to include multiple 
    // line widths.
    ULONG CharsPerLine = dout.GetAvailableColumns();
    

    if (0 == ArrayElements)
        {
        dout << "Array has 0 elements\n";
        }

    ULONG RemainingChars = CharsPerLine;
    

    for(ULONG i = 0; i < ArrayElements; i++)
        {

        BUFFER_SIMPLE_TYPE SimpleData = Buffer->ReadBUFFER_SIMPLE_TYPE( UseFormatChar );
        
        if ( SIMPLE_TYPE_BUFSIZE( UseFormatChar ) == sizeof(ULONG) )
            {
            // Check if the long is a pointer in a struct.
    
            POINTER *pPointer;
    
            if ( EmbeddedPointerList->Lookup(BufferAddress, &pPointer) )
                {
                ULONG WireRep = pPointer->GetWireRep( Buffer );
                Buffer->IncBUFFER_SIMPLE_TYPE( UseFormatChar );
                pPointer->OutputPointer( WireRep );
                return;
                }
            }
    
        Buffer->IncBUFFER_SIMPLE_TYPE( UseFormatChar );
    
        stringstream str;
        str << SimpleData; 

        ULONG RequiredChars = (ULONG)str.str().length() + 1;

        if (RemainingChars < RequiredChars)
            {
            // prepend a newline
            dout << '\n';
            RemainingChars = CharsPerLine;
            }

        RemainingChars -= RequiredChars;

        dout << str.str().c_str() << ' ';

        }

        dout << '\n';
    }

VOID
BUFFER_PRINTER::OutputRangedType()
    {

    UCHAR FormatChar = FormatString->GetUCHAR();
    UINT64 TypeAddress = FormatString->GetAddress();
    UCHAR SimpleType = FormatString->GetAddress();
    ULONG Min = FormatString->GetULONG();
    ULONG Max = FormatString->GetULONG();

    OutputType( TypeAddress );
    }

VOID 
BUFFER_PRINTER::OutputEmbeddedComplex()
    {

    UCHAR FormatChar = FormatString->GetUCHAR();
    UCHAR Pad = FormatString->GetUCHAR();
    UINT64 Address = FormatString->ComputeOffset();

    OutputType( Address );
    }

VOID
BUFFER_PRINTER::OutputString()
    {
    
    BUFFER_PRINTER_SAVE_CONTEXT SaveCtxt(this);
     
    StartEmbedded(&SaveCtxt, IsStructEmbedded, IsArrayEmbedded);

    UINT64 StringAddress = FormatString->GetAddress();

    UCHAR FormatType = FormatString->GetUCHAR();
    
    switch ( FormatType )
        {
        case FC_C_CSTRING :
        case FC_C_WSTRING :
        case FC_C_BSTRING :

            if ( FormatString->GetUCHAR() == FC_STRING_SIZED )
                {
                FormatString->IncUSHORT(); //skip string size
                }
            {
               SetupConformanceCountBuffer(&SaveCtxt, StringAddress);
               Elements = ConformanceCountBuffer->GetULONG();
            }

            break;

        case FC_CSTRING :
        case FC_WSTRING :
        case FC_BSTRING :
            FormatString->IncUCHAR(); // Skip FC_PAD
            Elements = FormatString->GetUSHORT(); // get size
            break;

        case FC_SSTRING :
        case FC_C_SSTRING :
            ABORT( "STRING::Output : Stringable struct, no way" );

        default :
            ABORT( "STRING::Output : Bad format type" ); 
        }

    Buffer->AlignULONG();
    Offset = Buffer->GetULONG();
    Length = Buffer->GetULONG();

    dout << "String of " << 
    (( FormatType == FC_C_WSTRING || FormatType == FC_WSTRING )
     ? "wchars"
     : "chars")
    << " (size=" << Elements << ", length=" << Length << ") :\n";

    {
        IndentLevel l(dout);
        char * CharString;
        BOOL fWChar = FALSE;

        if ( FormatType == FC_C_WSTRING || FormatType == FC_WSTRING )
            {
            CharString = (char *) new wchar_t[Length];
            Buffer->Get( (char *) CharString, Length*2 );
            fWChar = TRUE;
            }
        else
            {
            CharString = new char[Length];
            Buffer->Get( CharString, Length );
            }

        if ( Length < 60 )
            {
            if ( fWChar )
                {
                dout << '\"' << WCHAR_OUT((PWCHAR)CharString) << "\"\n";
                }
            else
                {
                dout << '\"' << (PCHAR)CharString << "\"\n";
                }
            }
        else
            {

            for ( long i = 0; i < Length; i++ )
                {
                if ( ( i % 40 ) == 0 )
                    {
                    dout << '\n';
                    }
                if ( fWChar )
                    {
                    dout << WCHAR_OUT(*((PWCHAR)CharString + i));
                    }
                dout << CharString[i];
                }
            dout << '\n';
            }
        delete[] CharString;
    }

    }

VOID
BUFFER_PRINTER::OutputContextHandle()
    {

    // Skip format string goo.
    UCHAR FormatChar = FormatString->GetUCHAR();
    UCHAR HandleFlags = FormatString->GetUCHAR();
    SHORT StackOffset = FormatString->GetSHORT();
    UCHAR RoutineIndex = FormatString->GetUCHAR();
    UCHAR Pad = FormatString->GetUCHAR();

    // A context handle is represented as a GUID on the wire.

    Buffer->AlignGUID();
    GUID Guid = Buffer->GetGUID();

    dout << "Context Handle: " << Guid << '\n'; 

    }

VOID
BUFFER_PRINTER::OutputXmit()
    {

    UCHAR FormatType = FormatString->GetUCHAR();

    switch ( FormatType )
        {
        case FC_USER_MARSHAL:
            dout << "User Marshal (transmitted type shown)\n";
            break;
        case FC_TRANSMIT_AS:
            dout << "Transmit As (transmitted type shown)\n";
            break;
        case FC_REPRESENT_AS:
            dout << "Represent As (transmitted type shown)\n";
            break;
        default:
            ABORT( "Xmit or UserM as expected, " <<
                   FormatString->GetFormatCharName( FormatType ) <<
                   '=' << HexOut( FormatType ) << " found.\n" );
            break;
        }

    FormatString->Move(7); // Skip to type offset

    //Output the transmitted type
    OutputTypeFromOffset( );

    }


VOID
BUFFER_PRINTER::OutputUnionArm()
    {
    UINT64 CurrentAddress = FormatString->GetAddress();
    SHORT Offset = FormatString->GetSHORT(); 
    IndentLevel l(dout);

    if ( (USHORT)Offset >> 8 == 0x80 )
        {
        OutputSimpleType(FALSE, 0);
        return;
        }

    OutputType(CurrentAddress + Offset );
    }

VOID
BUFFER_PRINTER::OutputUnionArms(BUFFER_SIMPLE_TYPE SwitchIs)
    {

    //
    // Get the union's arm descriptions.
    //
    FormatString->IncUSHORT(); //Memory size
    USHORT UnionArms = FormatString->GetUSHORT();

    ULONG Arms      = UnionArms & 0x0fff;
    ULONG Alignment = UnionArms >> 12;
    Buffer->Align( Alignment );

    BOOL ArmTaken = FALSE;

    for ( Arms; Arms > 0; Arms-- )
        {
        ULONG CaseValue = FormatString->GetULONG();

        if ( SwitchIs == (INT64)CaseValue )
            {
            dout << "Using arm with case value of " << HexOut(CaseValue) << ".\n";         
            OutputUnionArm();
            ArmTaken = TRUE;
            }
        else
            {
            FormatString->Move(2);
            }
        }

    // handle the default case
    if ( !ArmTaken )
        {
        dout << "Using default using arm.\n";
        OutputUnionArm();
        }
    else
        {
        FormatString->Move(2);
        }

    }

VOID
BUFFER_PRINTER::OutputUnion()
    {

    BUFFER_PRINTER_SAVE_CONTEXT SaveCtxt(this);
     
    StartEmbedded(&SaveCtxt, IsStructEmbedded, IsArrayEmbedded);

    BUFFER_SIMPLE_TYPE SwitchIs;
    UINT64 BufferOffset = Buffer->GetCurrentOffset();
    
    // Read the fixed part of the union's description.

    UCHAR FormatType = FormatString->GetUCHAR();
    UCHAR SwitchType = FormatString->GetUCHAR();
    FormatString->SkipCorrelationDesc(IsRobust);
    
    Buffer->AlignBUFFER_SIMPLE_TYPE( SwitchType );
    SwitchIs = Buffer->GetBUFFER_SIMPLE_TYPE( SwitchType );

    dout << "Non-encapsulated union (switch is == " << SwitchIs
    << " (" << FormatString->GetFormatCharName(SwitchType) 
    << "), bufoff = " << HexOut(BufferOffset) << ") : \n";

    UINT64 CurrentAddress = FormatString->GetAddress();
    FormatString->GotoOffset();
    
    OutputUnionArms( SwitchIs );

    FormatString->SetAddress(CurrentAddress);
    FormatString->IncSHORT();

    if ( !SaveCtxt.IsEmbedded )
        {
        // Output the pointees for this flat block
        dout << "Flat part of union is done, printing pointees.\n";
        dout << '\n';
        EmbeddedPointerList->OutputPointees();
        }


    dout << "Union is done.\n";

    }

VOID
BUFFER_PRINTER::OutputEncapsulatedUnion()
    {

    BUFFER_PRINTER_SAVE_CONTEXT SaveCtxt(this);
 
    StartEmbedded(&SaveCtxt, IsStructEmbedded, IsArrayEmbedded);
    BUFFER_SIMPLE_TYPE SwitchIs;
    UINT64 BufferOffset = Buffer->GetCurrentOffset();

    // Read the fixed part of the union's description.
    UCHAR FormatType = FormatString->GetUCHAR();
    UCHAR SwitchType = (FormatString->GetUCHAR() & 0x0f);

    Buffer->AlignBUFFER_SIMPLE_TYPE( SwitchType );
    SwitchIs = Buffer->GetBUFFER_SIMPLE_TYPE( SwitchType );

    dout << "Encapsulated union (switch is == " << SwitchIs
    << " (" << FormatString->GetFormatCharName(SwitchType) 
    << "), bufoff= " << HexOut(BufferOffset) << ") : \n";

    OutputUnionArms( SwitchIs );

    if ( !SaveCtxt.IsEmbedded )
        {
        // Output the pointees for this flat block
        dout << "Flat part of union is done, printing pointees.\n";
        dout << '\n';
        EmbeddedPointerList->OutputPointees();
        }

    dout << "Union is done.\n";
    }

VOID
BUFFER_PRINTER::OutputStructure()
    {

    BUFFER_PRINTER_SAVE_CONTEXT SaveCtxt(this);

    StartEmbedded(&SaveCtxt, TRUE, IsArrayEmbedded);

    if (!IsConformantArrayDone)
        {
        IsConformantArrayDone = FALSE;
        }
    
    UINT64 ArrayAddress;

    FORMAT_STRING BogusLayout;

    UINT64 BufferOffset = Buffer->GetCurrentOffset();    

    //
    // Read first four bytes of description.
    //
    UCHAR FormatType = FormatString->GetUCHAR();
    CHAR Alignment = FormatString->GetCHAR();
    USHORT MemSize = FormatString->GetUSHORT();

    UINT64 CurrentAddress = 0;
    SHORT ArrayOffset = 0;

    BOOL IsBogus = (FormatType == FC_BOGUS_STRUCT);

    // Get the conformant/varying array description.

    switch ( FormatType )
        {
        case FC_BOGUS_STRUCT:
        case FC_CSTRUCT:    
        case FC_CPSTRUCT:
        case FC_CVSTRUCT:
            CurrentAddress = FormatString->GetAddress();
            ArrayOffset = FormatString->GetUSHORT();
            if ( ArrayOffset )
                {
                ArrayAddress = CurrentAddress + ArrayOffset; 

                // Read the conformant size info into the buffer.
                
                SetupConformanceCountBuffer(&SaveCtxt, ArrayAddress);
                Elements = ConformanceCountBuffer->ReadULONG();
                }
            break;

        case FC_STRUCT:    
        case FC_PSTRUCT:
            break;

        default:
            ABORT( "BAD FC: a struct expected : " << FormatString->GetFormatCharName( FormatType ) << '\n');
            return;
        }

    Buffer->Align( Alignment );

    dout << "Structure (bufoff= " << HexOut(BufferOffset) << ") aligned at " 
    << HexOut(Alignment) << ", mem size " << HexOut(MemSize) << '\n';
    {
        IndentLevel l(dout);


        if ( FormatType != FC_STRUCT  &&
             FormatType != FC_CSTRUCT )
            {
            // Skip the pointer layout part.
            //
            // For the complex struct skip only the offset to the layout.
            // When non-bogus, create the pointee list to walk later.
            // Pointee for bogus would be added when outputting the flat part.

            if ( FormatType == FC_BOGUS_STRUCT )
                {
                BogusLayout.SetAddress(FormatString->ComputeOffset());
                }
            else
                {
                // Set the buffer offset mark to the beginning of the structure.

                if ( FC_CVSTRUCT == FormatType )
                    {

                    // In this case, the correct number of elements
                    // is the variance count, not the conformance count.

                    BUFFER TempBuffer = *Buffer;

                    // Move past block copyable part of structure
                    TempBuffer.Move(MemSize);

                    TempBuffer.AlignULONG();
                    ULONG TempOffset = TempBuffer.GetULONG();
                    ULONG TempActualCount = TempBuffer.GetULONG();

                    SWAP_SCOPE<ULONG> swapscope(&Elements, TempActualCount);
                    ProcessPointerLayout( Buffer );
                    }

                else 
                    {
                    ProcessPointerLayout( Buffer );             
                    }
                }
            }

        UCHAR MemberFormatType = FormatString->ReadUCHAR();

        while ( MemberFormatType != FC_END )
            {

            // Actual field to read from the buffer.

            if ( MemberFormatType == FC_POINTER )
                {
                AddPointer( &BogusLayout, TRUE );
                FormatString->Move(1);
                }
            else
                {
                OutputType( );
                }

            MemberFormatType = FormatString->ReadUCHAR();
            }
        
        // If this is an embedded bogus struct, the topmost 
        // bogus struct unmarshales the array.
        // BUT, a bogus struct can contain a bogus struct in which
        // case the conformant struct unmarshals the array.
        if ( ArrayOffset && 
             !IsConformantArrayDone &&
             ( !IsBogus || (IsBogus && !SaveCtxt.IsStructEmbedded) ) )
            {
            dout << "Tail array for structure.\n";
            OutputType( ArrayAddress );
            IsConformantArrayDone = TRUE;
            }
    }

    if ( !SaveCtxt.IsEmbedded )
        {
        // Output the pointees for this flat block
        dout << "Flat part of structure is done, printing pointees.\n";
        dout << '\n';
        EmbeddedPointerList->OutputPointees();
        }

    dout << "Structure is done\n";

    return;
    }

ULONG
BUFFER_PRINTER::GetArrayDimensions(UINT64 Address, BOOL CountStrings)
{
    FORMAT_STRING CurrentFormat(Address);
    ULONG    Dimensions;

    //
    // Only a complex array can have multiple dimensions.
    //
    if ( CurrentFormat.ReadUCHAR() != FC_BOGUS_ARRAY )
        return 1;

    Dimensions = 1;

    CurrentFormat.IncUCHAR(); //Skip type
    CurrentFormat.IncUCHAR(); //Skip Alignment
    CurrentFormat.IncUSHORT(); //Skip # elements.
    CurrentFormat.SkipCorrelationDesc( IsRobust );
    CurrentFormat.SkipCorrelationDesc( IsRobust );

    for ( ; CurrentFormat.ReadUCHAR() == FC_EMBEDDED_COMPLEX; )
        {
        CurrentFormat.Move(2);
        CurrentFormat.GotoOffset();

        //
        // Search for a fixed, complex, or string array.
        //
        switch ( CurrentFormat.ReadUCHAR() ) 
            {
            case FC_SMFARRAY :
                CurrentFormat.Move(4);
                break;

            case FC_LGFARRAY :
                CurrentFormat.Move(6);
                break;

            case FC_BOGUS_ARRAY :
                CurrentFormat.Move(12);
                CurrentFormat.SkipCorrelationDesc( IsRobust );
                CurrentFormat.SkipCorrelationDesc( IsRobust );
                break;

            case FC_CSTRING :
            case FC_BSTRING :
            case FC_WSTRING :
            case FC_SSTRING :
            case FC_C_CSTRING :
            case FC_C_BSTRING :
            case FC_C_WSTRING :
            case FC_C_SSTRING :

            //
            // Can't have any more dimensions after a string array.
            //
            return CountStrings ? Dimensions + 1 : Dimensions;

            default :
                return Dimensions;
            }

        Dimensions++;
        }

    //
    // Get here if you have only one dimension.
    //
    return Dimensions;
}

void
BUFFER_PRINTER::OutputArray()
    {

    BUFFER_PRINTER_SAVE_CONTEXT SaveCtxt(this);

    StartEmbedded(&SaveCtxt, IsStructEmbedded, TRUE); 

    ULONG TotalSize;
    BOOL HasConformance = FALSE;
    BOOL HasVariance = FALSE;
    BOOL HasPointerLayout = FALSE;

    UINT64 BufferOffset = Buffer->GetCurrentOffset();

    UINT64 ArrayAddress = FormatString->GetAddress();    

    UCHAR FormatType = FormatString->GetUCHAR();
    UCHAR Alignment = FormatString->GetUCHAR();

    switch ( FormatType )
        {
        
        case FC_SMFARRAY :
            TotalSize = FormatString->GetUSHORT();
            HasPointerLayout = TRUE;
            break;

        case FC_LGFARRAY :
            TotalSize = FormatString->GetULONG();
            HasPointerLayout = TRUE;
            break;

        case FC_CARRAY :
            FormatString->GetUSHORT(); //Element size
            FormatString->SkipCorrelationDesc(IsRobust);
            HasPointerLayout = TRUE;
            HasConformance = TRUE;
            break;

        case FC_CVARRAY :
            FormatString->GetUSHORT(); //Element size
            FormatString->SkipCorrelationDesc(IsRobust);
            FormatString->SkipCorrelationDesc(IsRobust);
            HasPointerLayout =TRUE;
            HasConformance = HasVariance = TRUE;
            break;

        case FC_SMVARRAY :
            FormatString->GetUSHORT(); //Total size
            Elements = FormatString->GetUSHORT(); //Number of elements
            FormatString->GetUSHORT(); //Element size
            FormatString->SkipCorrelationDesc(IsRobust);
            HasPointerLayout = TRUE;
            HasVariance = TRUE;
            break;

        case FC_LGVARRAY :
            FormatString->GetULONG(); //Total size
            Elements = FormatString->GetULONG(); //Number of elements
            FormatString->GetUSHORT(); //Element size
            FormatString->SkipCorrelationDesc(IsRobust);
            HasPointerLayout = TRUE;
            HasVariance = TRUE;
            break;

        case FC_BOGUS_ARRAY :
            {
            ULONG TempElements = FormatString->GetUSHORT();
            if (TempElements)
                {
                // This is a fixed size bogus array.
                Elements = TempElements;
                }
            HasConformance = FormatString->SkipCorrelationDesc(IsRobust);
            HasVariance    = FormatString->SkipCorrelationDesc(IsRobust);
            break;            
            }

        default :
            ABORT( "Unknown array type\n" );

        }

    if ( HasConformance )
        {
        SetupConformanceCountBuffer(&SaveCtxt, ArrayAddress);
        Elements = ConformanceCountBuffer->GetULONG();
        }

    if ( HasVariance )
        {
        SetupVarianceBuffer(&SaveCtxt, ArrayAddress);
        
        Buffer->AlignULONG();
        Offset = VarianceBuffer->GetULONG();
        Length = VarianceBuffer->GetULONG();
        }

    // Note that a fixed array can never have a variable repeat.
    if ( HasPointerLayout && ( FormatString->ReadUCHAR() == FC_PP ) )
        {
        BUFFER BufferMark = *Buffer;
        // Set elements to actual count for pointer layout processing if
        // the array is varying.
        SWAP_SCOPE<ULONG> swapscope( &Elements, Length , FC_CVARRAY == FormatType ||
                                                         FC_SMVARRAY == FormatType ||
                                                         FC_LGVARRAY == FormatType );
        ProcessPointerLayout( & BufferMark );
        }

    // Need to compute the number of elements for fixed arrays
    if ( FC_SMFARRAY == FormatType ||
         FC_LGFARRAY == FormatType )
        {

        FORMAT_STRING TempFormat = *FormatString;

        switch ( TempFormat.ReadUCHAR() )
            {
            case FC_EMBEDDED_COMPLEX :

                TempFormat.Move(2);
                TempFormat.GotoOffset();

                //
                // We must be at FC_STRUCT, FC_PSTRUCT, FC_SMFARRAY, or FC_LGFARRAY.
                // All these have the total size as a short at 2 bytes past the 
                // beginning of the description except for large fixed array.
                //
                { 

                    UCHAR FormatChar = TempFormat.ReadUCHAR();
                    TempFormat.Move(2);

                    if ( FormatChar != FC_LGFARRAY )
                        Elements = TotalSize / TempFormat.GetUSHORT();
                    else
                        Elements = TotalSize / TempFormat.GetULONG();                              
                    break;

                }

                //
                // Simple type (enum16 not possible).
                //
            default :
                Elements = TotalSize / SIMPLE_TYPE_MEMSIZE( TempFormat.GetUCHAR() );
                break;
            }

        }

    switch ( FormatType )
        {
        case FC_SMFARRAY :
        case FC_LGFARRAY :
            dout << "Fixed array (elements= " << Elements 
                 << ", bufoff= " << HexOut(BufferOffset) << ") : \n";
            break;
        case FC_CARRAY :
            dout << "Conformant array (elements= " << Elements 
                 << ", bufoff= " << HexOut(BufferOffset) << ") : \n";
            break;
        case FC_CVARRAY :
            dout << "Conf-var. array";
            dout << "    (size= " << Elements << ", offset= " << Offset << ", length= " 
            << Length << ", bufoff= " << HexOut(BufferOffset) << ") : \n";
            Elements = Length;
            break;
        case FC_SMVARRAY :
        case FC_LGVARRAY :
            dout << "Conf-var. array";
            dout << "    (size= " << Elements << ", offset= " << Offset << ", length= " 
            << Length << ", bufoff= " << HexOut(BufferOffset) << ") : \n";
            Elements = Length;
            break;
        case FC_BOGUS_ARRAY :
            dout << "Bogus array (elements= " << Elements 
                 << ", bufoff= " << HexOut(BufferOffset) << ") : \n";
            if ( HasConformance )
                dout << " Conf.";
            if ( HasVariance )
                dout <<" -Var.: offset = " << Offset << ", length = " << Length << ";";
            dout << " :\n";
            if ( HasVariance )
                Elements = Length;
            break;
        }

    if ( HasPointerLayout && ( FormatString->ReadUCHAR() == FC_PP ) )
        {
        
        ProcessPointerLayout( Buffer );
        
        }



    UCHAR ArrayType = FormatString->ReadUCHAR();
    
    ULONG ArrayElements = Elements; // Array element may change elements.

    if ( !ArrayElements )
        {
        dout << "Array has 0 elements.\n";
        }
    else 
        {
        // Arrays of reference pointers do not have a wire representation.
        // Complex array only.
        if (FC_RP == ArrayType)
            {
            dout << "Array of reference pointers(Pointers have no wire format).\n";
            for( ULONG i = 0; i < ArrayElements - 1; i++ ) {
               dout << "Array element " << i << ": ";
               FORMAT_STRING NewFormatString = *FormatString;
               AddArrayRefPointer(&NewFormatString, TRUE);
            }
            dout << "Array element " << i << ": ";
            AddArrayRefPointer(FormatString, TRUE);
            }
        
        // If the first element match a pointer, this is probably an array of
        // pointers.   Use the long format.

        else if ( IS_SIMPLE_TYPE(ArrayType) &&
                   !EmbeddedPointerList->Lookup(Buffer->GetAddress()))
            {
            OutputSimpleType( TRUE, ArrayElements );            
            }
        else
            {
            for (ULONG i = 0; i < ArrayElements - 1; i++)
                {
                dout << "Array element " << i << ": ";
                OutputType(FormatString->GetAddress());
                }
            dout << "Array element " << i << ": ";
            OutputType( );
            }
        }

    if ( ! SaveCtxt.IsEmbedded )
        {
        dout << "Flat part of array done, printing pointees.\n";
        dout << '\n';
        EmbeddedPointerList->OutputPointees();        
        }

    dout << "Array is done.\n";

    }



VOID
BUFFER_PRINTER::ProcessPointerLayout( BUFFER *pBufferMark )
/*--

RoutineDescription :

    Skips a pointer layout format string description.
    This is for the proper pointer layout (not for FC_BOGUS_STRUCT).
    Also, put the pointers to the pointer dictionary.

--*/
    {
    ULONG NumberPointers;

    UCHAR FormatPP = FormatString->ReadUCHAR();

    if ( FormatPP != FC_PP )
        {
        return;
        }
    
    FormatString->IncUCHAR();
    UCHAR FormatPAD = FormatString->GetUCHAR();

    for ( ;; )
        {

        UCHAR LayoutType = FormatString->GetUCHAR();
        UCHAR VariableRepeatType;
        ULONG Iterations = 1;
        switch ( LayoutType )
            {
            case FC_END :
                return;

            case FC_NO_REPEAT :
                {
                    FormatString->IncUCHAR(); // Skip FC_PAD
                    FormatString->IncSHORT(); //Skip offset to pointer in memory.
                    BUFFER BufferMark = *pBufferMark;
                    BufferMark.Move(FormatString->GetSHORT());
                    SWAP_SCOPE<BUFFER*> swapscope(&Buffer, &BufferMark);
                    AddPointer( FormatString, FALSE );
                    break;         
                }

            case FC_FIXED_REPEAT :
                FormatString->IncUCHAR();  //Skip FC_PAD
                Iterations = FormatString->GetUSHORT();
                goto REPEAT_COMMON;
                // fall through...

            case FC_VARIABLE_REPEAT :
                FormatString->GetUCHAR(); // Skip Repeat Type
                Iterations = Elements;

                REPEAT_COMMON:
                {

                    SHORT Increment = FormatString->GetSHORT();
                    // Skip offset to array since pointer offsets are
                    // relative to buffermark.
                    FormatString->IncSHORT();
                    NumberPointers = FormatString->GetUSHORT(); 

                    if ( Iterations )
                        {
                        // Add the pointers while we skip them.
                        
                        FORMAT_STRING WorkFormatString;

                        LONG Offset = 0;

                        do
                           {
                           WorkFormatString = *FormatString;
                           for ( ULONG i = NumberPointers; i > 0; i-- )
                               {
                               WorkFormatString.IncSHORT(); //Skip offset in memory
                               SHORT PtrOffset = WorkFormatString.       GetSHORT();
                               BUFFER BufferMark = *pBufferMark;
                               BufferMark.Move(Offset + PtrOffset);
                               SWAP_SCOPE<BUFFER*> swapscope(&Buffer, &BufferMark);
                               AddPointer( &WorkFormatString, FALSE );
                               }                        
                           
                           Offset += Increment;

                           } while (--Iterations);

                        *FormatString = WorkFormatString;
                        }
                    
                    else 
                        {
                        // Just skip the pointer list
                        for (UINT i = NumberPointers; i > 0; i-- )
                            {
                            FormatString->IncSHORT(); //Skip offset in memory
                            FormatString->IncSHORT(); //Skip pointer offset
                            POINTER::SkipCommonPointerFormat( FormatString );
                            }
                        }

                    break;         
                } 

            default :
                ABORT( "ProcessPointerLayout : unexpected FC: " << FormatString->GetFormatCharName(LayoutType) << '\n');
            }

        }

    return;
    }

VOID
BUFFER_PRINTER::AddArrayRefPointer( FORMAT_STRING *pFormat,
                                    BOOL PrintPointer) 
    {
    AddPointer( pFormat, PrintPointer, TRUE);
    }

VOID
BUFFER_PRINTER::AddPointer( FORMAT_STRING *pFormat,
                            BOOL PrintPointer,
                            BOOL ArrayRef
                            )
    {
    if (!ArrayRef)
        {
        Buffer->AlignULONG();        
        }
    POINTER *pPointer = new POINTER( pFormat, Buffer, this , ArrayRef);

    EmbeddedPointerList->Add( Buffer->GetAddress(), pPointer );

    if ( PrintPointer )
        {
        ULONG WireRep = 0;
        if (pPointer->HasWireRep())
           {       
           WireRep = pPointer->GetWireRep( Buffer );
           Buffer->IncULONG();        
           }
        pPointer->OutputPointer( WireRep );        
        }
    }

VOID
BUFFER_PRINTER::OutputPointer(BOOL OutputPointee, BOOL ArrayRef )
    {
    ULONG WireRep = 0;
    Buffer->AlignULONG();
    auto_ptr<POINTER> pPointer = 
        auto_ptr<POINTER>(new POINTER( FormatString, Buffer, this, ArrayRef ));
    UINT WireAddress = Buffer->GetAddress();
    if (pPointer->HasWireRep())
        {
        WireRep = pPointer->GetWireRep( Buffer );
        Buffer->IncULONG();        
        }
    pPointer->OutputPointer( WireRep );
    if ( OutputPointee )
        {
        pPointer->OutputPointee( WireRep, &FullPointerTable, Buffer );
        }
    else 
        {

        EmbeddedPointerList->Add( Buffer->GetAddress(), pPointer.release() );
        }
    }

VOID BUFFER_PRINTER::OutputProcPicklingHeader()
    {
    PROC_PICKLING_HEADER ProcHeader;
    Buffer->Get(&ProcHeader, sizeof(ProcHeader));
    
    dout << "Proc picking header:\n";
        {
        IndentLevel l(dout);
        Print(dout, ProcHeader, VerbosityLevel);
        dout << '\n';
        }
    }

VOID BUFFER_PRINTER::OutputTypePicklingHeader()
    {
    TYPE_PICKLING_HEADER TypeHeader;
    Buffer->Get(&TypeHeader, sizeof(TypeHeader));
    
    dout << "Type picking header:\n";
        {
        IndentLevel l(dout);
        Print(dout, TypeHeader, VerbosityLevel);
        dout << '\n';
        }
    }

VOID BUFFER_PRINTER::OutputBuffer(NDREXTS_STUBMODE_TYPE StubMode, 
                                  NDREXTS_DIRECTION_TYPE Direction, BOOL IsPickling )
    {

    switch ( StubMode )
        {
        case OS:
            OutputOsBuffer(Direction, IsPickling);
            break;
        case OI:
            OutputOIBuffer(Direction, IsPickling);
            break;
        case OIC:
        case OICF:
        case OIF:
            OutputOIFBuffer(Direction, IsPickling);
            break;
        default:
            ABORT("Corrupt stub mode.\n");
        }
    }

void BUFFER_PRINTER::SkipOiHeader()
    {

    UCHAR HandleType = FormatString->GetUCHAR();
    UCHAR OiFlags = FormatString->GetUCHAR();

    FormatString->Move(4); //Common part 
    if ( OiFlags & Oi_HAS_RPCFLAGS )
        {
        FormatString->Move(4); // Has rpc flags
        }
    if ( 0==HandleType )
        {
        HandleType = FormatString->GetUCHAR();
        switch ( HandleType )
            {
            case FC_BIND_PRIMITIVE:
                FormatString->Move(3);
                break;
            case FC_BIND_GENERIC:
                FormatString->Move(5);
                break;
            case FC_BIND_CONTEXT:
                FormatString->Move(5);
                break;
            default:
                ABORT("Unknown handle type, " << HexOut(HandleType) << "."); 
            }
        }
    }

void BUFFER_PRINTER::OutputOIBuffer(NDREXTS_DIRECTION_TYPE Direction, BOOL IsPickling )
    {

    SetupWorkValues();

    // Skip past the proc header and treat as an OS_PROCEDURE
    SkipOiHeader();
    OutputOsBufferInternal( Direction, IsPickling );
    }

void BUFFER_PRINTER::OutputParameters(UINT NumberOfParameters, BOOL IsIn, BOOL IsPipe)
    {

    UINT64 FormatStringAddressSave = FormatString->GetAddress();

    for ( UINT i = 0; i < NumberOfParameters; i++ )
        {
        USHORT ParamAttributes = FormatString->GetUSHORT();
        FormatString->IncUSHORT();
        PPARAM_ATTRIBUTES pParamAttributes = (PPARAM_ATTRIBUTES)&ParamAttributes;

        if ( (pParamAttributes->IsPipe == IsPipe) &&
             ((IsIn && pParamAttributes->IsIn) ||
              (!IsIn && (pParamAttributes->IsOut || pParamAttributes->IsReturn))) )
            {

            dout << "Param number " << i << ":\n";
            dout << "IsPipe: " << HexOut(pParamAttributes->IsPipe) << ' ';
            dout << "IsIn: " << HexOut(pParamAttributes->IsIn) << '\n';
            dout << "IsOut: " << HexOut(pParamAttributes->IsOut) << ' ';
            dout << "IsReturn: " << HexOut(pParamAttributes->IsReturn) << '\n';

            if ( pParamAttributes->IsBasetype )
                {
                OutputType();
                FormatString->Move(1);
                }
            else
                {
                SHORT Offset = FormatString->GetSHORT();
                FORMAT_STRING TypeFormat = WorkTypeFormatString;
                FormatString = &TypeFormat;
                FormatString->Move(Offset);
                OutputType( );
                FormatString = &WorkProcFormatString;
                }
            dout << '\n';
            }
        else
            {
            FormatString->IncUSHORT();
            }
        }

    FormatString->SetAddress(FormatStringAddressSave);
    }

void BUFFER_PRINTER::OutputOIFBuffer( NDREXTS_DIRECTION_TYPE Direction, BOOL IsPickling )
    {

    BOOL PrintInParameters = (Direction == IN_BUFFER_MODE);

    SetupWorkValues();

    SkipOiHeader();

    FormatString->Move(4);
    UCHAR InterpretorFlags = FormatString->GetUCHAR();
    PINTERPRETER_OPT_FLAGS pInterpretorFlags = (PINTERPRETER_OPT_FLAGS)&InterpretorFlags;
    UINT NumberOfParameters = FormatString->GetUCHAR();

    if ( pInterpretorFlags->HasExtensions )
        {
        UINT64 FormatAddressSave = FormatString->GetAddress();
        UINT ExtensionSize;
        if ( (ExtensionSize = FormatString->GetUCHAR()) >= 2 )
            {
            UCHAR InterpreterFlags2 = FormatString->GetUCHAR();
            PINTERPRETER_OPT_FLAGS2 pInterpreterFlags2 = (PINTERPRETER_OPT_FLAGS2)&InterpreterFlags2;
            IsRobust = pInterpreterFlags2->HasNewCorrDesc; 
            }
        FormatString->SetAddress(FormatAddressSave + ExtensionSize); 
        }

    if (IsPickling)
        {
        OutputProcPicklingHeader();        
        }

    dout << "Procedure has " << NumberOfParameters << " parameters.\n";


    if ( PrintInParameters )
        {
        //pipes are last in the in stream
        dout << "Non-pipe parameters:\n";
        OutputParameters(NumberOfParameters, PrintInParameters, FALSE);
        dout << "Pipe parameters:\n";
        OutputParameters(NumberOfParameters, PrintInParameters, TRUE);
        }
    else
        {
        //pipes are first in the out stream
        dout << "Pipe parameters:\n";
        OutputParameters(NumberOfParameters, PrintInParameters, TRUE);
        dout << "Non pipe parameters:\n";
        OutputParameters(NumberOfParameters, PrintInParameters, FALSE);
        }
    dout << "End of parameters.\n\n";
    }

void BUFFER_PRINTER::OutputOsBuffer( NDREXTS_DIRECTION_TYPE Direction, BOOL IsPickling )
    {
    SetupWorkValues();
    OutputOsBufferInternal( Direction, IsPickling );
    }

void BUFFER_PRINTER::OutputOsBufferInternal( NDREXTS_DIRECTION_TYPE Direction, BOOL IsPickling )
    {


    if (IsPickling)
        {
        OutputProcPicklingHeader();        
        }

    BOOL PrintInParameters = (Direction == IN_BUFFER_MODE);

    for ( UINT ParamNumber = 0; ; ParamNumber++)
        {

        uchar   FormatType;
        char    *ParamKind;

        UCHAR ParamDirection = FormatString->GetUCHAR();
        BOOL SkipParam;

        switch ( ParamDirection )
            {
            case FC_IN_PARAM :
            case FC_IN_PARAM_BASETYPE :
            case FC_IN_PARAM_NO_FREE_INST :
                ParamKind = "[in] only";
                SkipParam = !PrintInParameters;
                break;
            case FC_IN_OUT_PARAM :
                ParamKind = "[in,out]";
                SkipParam = FALSE;
                break;
            case FC_OUT_PARAM :
                ParamKind = "[out] only";
                SkipParam = PrintInParameters;
                break;
            case FC_RETURN_PARAM :
            case FC_RETURN_PARAM_BASETYPE :
                ParamKind = "the return value";
                SkipParam = PrintInParameters;
                break;
            case FC_END:
                dout << "End of parameters.\n\n";
                return;
            default :
                ABORT( "Aborting expected a parameter FC, found " << 
                       FormatString->GetFormatCharName( ParamDirection ) <<
                       HexOut(ParamDirection) << ".\n");
                break;
            }

        if ( SkipParam )
            {
            if ( ParamDirection == FC_IN_PARAM_BASETYPE || ParamDirection == FC_RETURN_PARAM_BASETYPE )
                {
                FormatString->Move(1); // Skip past simple type

                }
            else
                {
                FormatString->Move(3); // skip past stacksize and pad.
                }
            continue;
            }

        dout << "Parameter " << ParamNumber << " is " 
        << ParamKind << " \n\n";

        switch ( ParamDirection )
            {
            case FC_IN_PARAM_BASETYPE :
            case FC_RETURN_PARAM_BASETYPE :
                OutputType( );
                dout << '\n';
                break;

            default :
                FormatString->Move(1); //skip stacksize              
                SHORT Offset = FormatString->GetSHORT();
                FORMAT_STRING TypeFormat = WorkTypeFormatString;
                FormatString = &TypeFormat;
                FormatString->Move(Offset);
                OutputType( );
                FormatString = &WorkProcFormatString;
                dout << '\n';
                break;
            }

        }

    }

VOID 
BUFFER_PRINTER::OutputTypeBuffer( BOOL IsPickling, BOOL IsRobust )
{
   SetupWorkValues();
   BUFFER_PRINTER::IsRobust = IsRobust;

   if (IsPickling)
       {
       OutputTypePicklingHeader();
       }

   OutputType();
}

VOID
BUFFER_PRINTER::StartEmbedded(BUFFER_PRINTER_SAVE_CONTEXT *SaveCtxt, 
                              BOOL IsStructEmbedded, BOOL IsArrayEmbedded)
{
    if (!SaveCtxt->IsEmbedded)
        {
        EmbeddedPointerList = &SaveCtxt->NewEmbeddedPointerList;
        }
    IsEmbedded = TRUE;
    BUFFER_PRINTER::IsStructEmbedded = IsStructEmbedded;
    BUFFER_PRINTER::IsArrayEmbedded = IsArrayEmbedded;
}

VOID
BUFFER_PRINTER::SetupConformanceCountBuffer(BUFFER_PRINTER_SAVE_CONTEXT *SaveCtxt,
                                            UINT64 ArrayAddress)
{
    if (!ConformanceCountBuffer)
        {
        Buffer->AlignULONG();
        ConformanceCountBuffer = &SaveCtxt->NewConformanceCountBuffer;
        *ConformanceCountBuffer = *Buffer;
        ULONG Dimensions = GetArrayDimensions(ArrayAddress, TRUE);
        Buffer->Move(Dimensions * sizeof(ULONG));
        }
    else 
        {
        SaveCtxt->NewConformanceCountBuffer = *ConformanceCountBuffer;
        ConformanceCountBuffer = &SaveCtxt->NewConformanceCountBuffer;
        }
}

VOID
BUFFER_PRINTER::SetupVarianceBuffer(BUFFER_PRINTER_SAVE_CONTEXT *SaveCtxt,
                                    UINT64 ArrayAddress)
{

    if (!VarianceBuffer)
        {
        Buffer->AlignULONG();
        VarianceBuffer = &SaveCtxt->NewVarianceBuffer;        
        *VarianceBuffer = *Buffer;
        ULONG Dimensions = GetArrayDimensions(ArrayAddress, FALSE);
        Buffer->Move(Dimensions * sizeof(ULONG) * 2);
        }
    else 
        {
        SaveCtxt->NewVarianceBuffer = *VarianceBuffer;
        VarianceBuffer = &SaveCtxt->NewVarianceBuffer;
        }
}


BUFFER_PRINTER_SAVE_CONTEXT::BUFFER_PRINTER_SAVE_CONTEXT(BUFFER_PRINTER *pPrinter) :
    Buffer(pPrinter->Buffer),
    ConformanceCountBuffer(pPrinter->ConformanceCountBuffer),
    VarianceBuffer(pPrinter->VarianceBuffer),
    FormatString(pPrinter->FormatString),
    EmbeddedPointerList(pPrinter->EmbeddedPointerList),
    IsEmbedded(pPrinter->IsEmbedded),
    IsStructEmbedded(pPrinter->IsStructEmbedded),
    IsArrayEmbedded(pPrinter->IsArrayEmbedded)
{
    BUFFER_PRINTER_SAVE_CONTEXT::pPrinter = pPrinter;    
}

BUFFER_PRINTER_SAVE_CONTEXT::~BUFFER_PRINTER_SAVE_CONTEXT()
{
    
    pPrinter->Buffer = Buffer;
    pPrinter->ConformanceCountBuffer = ConformanceCountBuffer;
    pPrinter->VarianceBuffer = VarianceBuffer;
    pPrinter->FormatString = FormatString;
    pPrinter->EmbeddedPointerList = EmbeddedPointerList;
    pPrinter->IsEmbedded = IsEmbedded;
    pPrinter->IsStructEmbedded = IsStructEmbedded;
    pPrinter->IsArrayEmbedded = IsArrayEmbedded; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrexts\ndrexts\basicinf.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    basicinf.cxx

Abstract:


Author:

    Michael Zoran(mzoran)   August 25 1999

Revision History:

--*/

#include "ndrextsp.hxx"
#include "basicinf.hxx"

BASIC_INFO::BASIC_INFO() 
{
    Clear();
}

VOID BASIC_INFO::Clear()
{
    StubMessageIsAvailable = RpcMessageIsAvailable = FALSE;
    StubDescIsAvailable = RpcClientInterfaceIsAvailable =  ServerInfoIsAvailable = FALSE;
    ProcFormatAddressIsAvailable = FALSE;
}

VOID BASIC_INFO::GetInfoFromStubMessage(UINT64 Address)
{
    GetInfo(TRUE, Address);
}

VOID BASIC_INFO::GetInfoFromRpcMessage(UINT64 Address)
{
    GetInfo(FALSE, Address);
}

VOID BASIC_INFO::GetInfo(BOOL IsStubMsg, UINT64 Address) 
{
    Clear();

    if (IsStubMsg)
        {
        try 
           {
           StubMessageAddress = Address;
           ReadMemory(StubMessageAddress, &StubMessage);
           StubMessageIsAvailable = TRUE;
       
           StubDescAddress = (UINT64)StubMessage.StubDesc;
           ReadMemory(StubDescAddress, &StubDesc);
           StubDescIsAvailable = TRUE;
           
           InterfaceInformationAddress = (UINT64)StubDesc.RpcInterfaceInformation;
           ReadMemory(InterfaceInformationAddress, &RpcClientInterface);
           RpcClientInterfaceIsAvailable = TRUE;           
           
           ServerInfoAddress = (UINT64)RpcClientInterface.InterpreterInfo;
           ReadMemory(ServerInfoAddress, &MidlServerInfo);
           ServerInfoIsAvailable = TRUE;
           }
        catch(...)
           {
           }

        }

    if (!IsStubMsg)
        {
        RpcMessageAddress = Address;
        }
    else if (!StubMessageIsAvailable || !StubMessage.RpcMsg)
        {
        // Nothing more to do
        return;
        }
    else 
        {
        RpcMessageAddress = (UINT64)StubMessage.RpcMsg;
        }

    //try the RPC_MESSAGE chain
    try
       {
       
       ReadMemory(RpcMessageAddress, &RpcMessage);
       RpcMessageIsAvailable = TRUE;
       
       if (!RpcClientInterfaceIsAvailable)
           {
           InterfaceInformationAddress = (UINT64)RpcMessage.RpcInterfaceInformation;
           ReadMemory(InterfaceInformationAddress, &RpcClientInterface);
           RpcClientInterfaceIsAvailable = TRUE;

           ServerInfoAddress = (UINT64)RpcClientInterface.InterpreterInfo;
           ReadMemory(ServerInfoAddress, &MidlServerInfo);
           ServerInfoIsAvailable = TRUE;

           if (!StubDescIsAvailable)
               {
               StubDescAddress = (UINT64)MidlServerInfo.pStubDesc;
               ReadMemory(StubDescAddress, &StubDesc);
               StubDescIsAvailable = TRUE;               
               }
           }

       }
    catch(...)
       {
       }
    try 
        {
        if (RpcMessageIsAvailable && ServerInfoIsAvailable)
            {
            ProcFormatAddress = (UINT64)MidlServerInfo.ProcString;
            UINT64 FmtStringOffset = (UINT64)MidlServerInfo.FmtStringOffset;
            if (FmtStringOffset)
                {
                SHORT Offset;
                ReadMemory(FmtStringOffset + (sizeof(SHORT) * RpcMessage.ProcNum), &Offset);
                ProcFormatAddress += Offset;
                ProcFormatAddressIsAvailable = TRUE;
                }
            }
        
        }
    catch(...)
        {
        } 
        
}

VOID BASIC_INFO::PrintInfo(FORMATTED_STREAM_BUFFER & dout)
{
    ostringstream MidlBuffer;
    ostringstream StubMessageAddressTxt;
    if (StubMessageIsAvailable)
        {
        MidlBuffer << HexOut(StubMessage.Buffer);
        StubMessageAddressTxt << HexOut(StubMessageAddress);
        }
    else 
        {
                     //0x0000000000000000
        MidlBuffer << "NA                ";
                                //0x0000000000000000
        StubMessageAddressTxt << "NA                ";
        }

    ostringstream InterfaceGUID;
    ostringstream InterfaceAddressTxt;
    if (RpcClientInterfaceIsAvailable)
        {
        InterfaceGUID << RpcClientInterface.InterfaceId.SyntaxGUID;
        InterfaceAddressTxt << HexOut(InterfaceInformationAddress);
        }
    else
        {
                       //{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}
        InterfaceGUID << "NA                                   ";
                              //0x0000000000000000
        InterfaceAddressTxt << "NA                ";
        }

    ostringstream ProcNum;
    ostringstream Handle;
    ostringstream RpcBuffer;
    ostringstream RpcBufferLength;
    ostringstream RpcMessageAddressTxt;

    if (RpcMessageIsAvailable)
        {
        ProcNum << HexOut(RpcMessage.ProcNum);
        Handle << HexOut(RpcMessage.Handle);
        RpcBuffer << HexOut(RpcMessage.Buffer);
        RpcBufferLength << HexOut(RpcMessage.BufferLength);        
        RpcMessageAddressTxt << HexOut(RpcMessageAddress);
        }
    else 
        {
                  //0x00000000
        ProcNum << "NA        ";
                  //0x0000000000000000
        Handle <<  "NA                ";
                    //0x0000000000000000
        RpcBuffer << "NA                ";
                          //0x00000000
        RpcBufferLength << "NA        ";
                               //0x0000000000000000
        RpcMessageAddressTxt << "NA                ";
        }

    ostringstream StubDescAddressTxt;
    string NDRVersion;
    string MIDLVersion;
    ostringstream TypeFormat;

    if (StubDescIsAvailable)
        {
        ostringstream TempNDRVersion;
        TempNDRVersion << ((StubDesc.Version >> 16) & 0xFFFF) << '.'
                       << (StubDesc.Version && 0xFFFF);
        NDRVersion = TempNDRVersion.str();
        NDRVersion.resize(10, ' ');

        ostringstream TempMIDLVersion;
        TempMIDLVersion << ((StubDesc.MIDLVersion >> 24) & 0xFF) << '.' 
                        << ((StubDesc.MIDLVersion >> 16) & 0xFF) << '.'
                        << (StubDesc.MIDLVersion && 0xFFFF);
        MIDLVersion = TempMIDLVersion.str();
        MIDLVersion.resize(10, ' ');

        TypeFormat << HexOut(StubDesc.pFormatTypes);
        StubDescAddressTxt << HexOut(StubDescAddress);
        }
    else
        {
                    //0x00000000
        NDRVersion = "NA        ";
                    //0x00000000
        MIDLVersion= "NA        ";
                      //0x0000000000000000
        TypeFormat <<  "NA                ";
                             //0x0000000000000000
        StubDescAddressTxt << "NA                ";        
        }

    ostringstream ServerInfoAddressTxt;
    if (ServerInfoIsAvailable)
        {
        ServerInfoAddressTxt << HexOut(ServerInfoAddress);
        // Compute address of proc format string
        }
    else
        {
                               //0x0000000000000000
        ServerInfoAddressTxt << "NA                ";
        }

    ostringstream ProcFormat;
    if (ProcFormatAddressIsAvailable)
        {
        ProcFormat << HexOut(ProcFormatAddress);
        }
    else 
        {
                     //0x0000000000000000
        ProcFormat << "NA                ";
        }

    dout << "Interface: " << InterfaceGUID.str().c_str() 
         << " ProcNum: " << ProcNum.str().c_str() << '\n';

    dout << "Version(NDR):      " << NDRVersion.c_str() 
         << "         Version(MIDL):    " << MIDLVersion.c_str() << '\n';

    dout << "ProcFormat:        " << ProcFormat.str().c_str() 
         << " TypeFormat:       " << TypeFormat.str().c_str() << '\n';

    dout << "RpcBuffer:         " << RpcBuffer.str().c_str() 
         << " RpcBufferLength:  " << RpcBufferLength.str().c_str() << '\n';

    dout << "Handle:            " << Handle.str().c_str() 
         << " MIDLBuffer:       " << MidlBuffer.str().c_str() << '\n';

    dout << "MIDL_STUB_MESSAGE: " << StubMessageAddressTxt.str().c_str()
         << " RPC_MESSAGE:      " << RpcMessageAddressTxt.str().c_str() << '\n';

    dout << "MIDL_STUB_DESC:    " << StubDescAddressTxt.str().c_str() 
         << " MIDL_SERVER_INFO: " << ServerInfoAddressTxt.str().c_str() << '\n';

    dout << "RPC_CLIENT_INTERFACE/RPC_SERVER_INTERFACE: " << 
            InterfaceAddressTxt.str().c_str() << '\n';

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrexts\ndrexts\ndrexts.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ndrexts.cxx

Abstract:

    This file contains ntsd debugger extensions for RPC NDR.

Author:

    Mike Zoran  (mzoran)     September 3, 1999

Revision History:

--*/
#define USE_STUBLESS_PROXY
#include "ndrextsp.hxx"
#include "orpcexts.h"
#include "basicinf.hxx"

// =======================================================================

//
// Project wide global variables
//

EXT_API_VERSION        ApiVersion = {
    VER_PRODUCTVERSION_W >> 8,
    VER_PRODUCTVERSION_W & 0xFF,
    EXT_API_VERSION_NUMBER,
    0
};

BOOL                    OldExtensions=TRUE;
BOOL                    ExtensionsInitialized=FALSE;
USHORT                  SavedMajorVersion=0;
USHORT                  SavedMinorVersion=0;
BOOL                    ChkTarget;            // is debuggee a CHK build?

// ntstatus to error name lookup
#include <ntstatus.dbg>

EXTERN_C HANDLE ProcessHandle = 0;
EXTERN_C BOOL fKD = 0;

// Settings

NDREXTS_STUBMODE_TYPE ContextStubMode = OICF;
NDREXTS_DIRECTION_TYPE ContextDirection = IN_BUFFER_MODE;
BOOL ContextPickling = FALSE;
BOOL ContextRobust = FALSE;
NDREXTS_VERBOSITY VerbosityLevel = MEDIUM;

// Printing

class DEBUGGER_STREAM_BUFFER : public FORMATTED_STREAM_BUFFER
   {
protected:
   virtual void SystemOutput(const char *p);
   virtual BOOL SystemPollCtrlC();
   } DbgOutStream; // Stream to output to the debugger.

void DEBUGGER_STREAM_BUFFER::SystemOutput(const char *p)
   {
       dprintf(p);
   }

BOOL DEBUGGER_STREAM_BUFFER::SystemPollCtrlC()
   {
   return ::PollCtrlC();
   }

FORMATTED_STREAM_BUFFER & dout = DbgOutStream;

//
// Project wide memory management
//

void * __cdecl ::operator new(size_t Bytes)
    {
    void *p = HeapAlloc(GetProcessHeap(), 0, Bytes);
    if ( !p )
        {
        throw bad_alloc();
        }
    return p;
    }

void __cdecl ::operator delete (void *p)
    {
    HeapFree(GetProcessHeap(),0,p);
    }

const char CExceptionText[] = "C Exception";

class SEHException : public exception
    {
    unsigned int ExceptionCode;

    const char *GenerateString(unsigned int Id)
        {
        int i = 0;
        while ( ntstatusSymbolicNames[i].SymbolicName )
            {
            if ( ntstatusSymbolicNames[i].MessageId == Id )
                {
                return ntstatusSymbolicNames[i].SymbolicName;
                }
            i++;
            }
        return CExceptionText;
        }
public:
    SEHException(unsigned int c) : exception(GenerateString(c)) ,ExceptionCode(c)
        {

        }
    virtual unsigned int GetExceptionCode(void)
        {
        return ExceptionCode;
        }
    };

void _cdecl SEHTranslator(unsigned int ExceptionCode, struct _EXCEPTION_POINTERS* ExceptionPointers)
    {
    throw SEHException(ExceptionCode);
    }




extern "C" {

    DllMain(
           HANDLE hModule,
           DWORD  dwReason,
           DWORD  dwReserved
           )
        {
        switch ( dwReason )
            {
            case DLL_THREAD_ATTACH:
                break;

            case DLL_THREAD_DETACH:
                break;

            case DLL_PROCESS_DETACH:
                break;

            case DLL_PROCESS_ATTACH:
                _set_se_translator(SEHTranslator);
                break;
            }

        return TRUE;
        }


    VOID
    WinDbgExtensionDllInit(
                          PWINDBG_EXTENSION_APIS lpExtensionApis,
                          USHORT MajorVersion,
                          USHORT MinorVersion
                          )
        {
        ExtensionApis = *lpExtensionApis;

        SavedMajorVersion = MajorVersion;
        SavedMinorVersion = MinorVersion;
        ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;

        OldExtensions = FALSE;
        ExtensionsInitialized = TRUE;

    fKD = 1;

    return;
}

    VOID
    CheckVersion(
                VOID
                )
        {

#if DBG
        char Kind[] = "Checked";
#else
        char Kind[] = "Free";
#endif

        char *VersionKind = (SavedMajorVersion==0x0f) ? "Free" : "Checked";
        if ( (SavedMajorVersion != 0x0c) || (SavedMinorVersion !=
            VER_PRODUCTBUILD) )
            {
            dout << '\n';
            dout << "*** Extension DLL(" << VER_PRODUCTBUILD << " " << Kind
            << ") does not match target system(" << SavedMinorVersion
            << " " << VersionKind << ") \n";
            dout << '\n';
            }
        }

    LPEXT_API_VERSION
    ExtensionApiVersion(
                       VOID
                       )
        {
        return &ApiVersion;
        }

} // extern "C"


ULONG
ReadProcessMemoryThunk(
                      ULONG_PTR  offset,
                      PVOID      lpBuffer,
                      ULONG      cb,
                      PULONG     lpcbBytesRead
                      )
    {
        SIZE_T RealBytesRead;
        ULONG rc = ReadProcessMemory(hCurrentProcess, (PVOID)offset, lpBuffer, cb, &RealBytesRead);
        *lpcbBytesRead = rc ? (ULONG)RealBytesRead : 0;
        return rc;
    }

ULONG
WriteProcessMemoryThunk(
                       ULONG_PTR  offset,
                       LPVOID     lpBuffer,
                       ULONG      cb,
                       PULONG     lpcbBytesWritten
                       )
    {
        SIZE_T RealBytesWritten;
        ULONG rc = WriteProcessMemory(hCurrentProcess, (PVOID)offset, lpBuffer, cb, &RealBytesWritten);
        *lpcbBytesWritten = rc ? (ULONG)RealBytesWritten : 0;
        return rc;
    }

typedef VOID (*PEXTENSION_API_ROUTINE)(VOID);

LPSTR lpArgumentString;

DWORD
ExtensionWrapRoutine(
                    IN LPVOID ExtensionRoutine
                    )
    {
    try
        {

        // Parse extension arguments.
        ExtensionArgumentString = lpArgumentString;
        ExtensionArgs.clear();
        if ( lpArgumentString )
            {
            size_t c = strlen(lpArgumentString) + 1;
            char *p = (char *)_alloca(c);
            const char seps[] = " \t\n";
            memcpy(p, lpArgumentString, c);
            p = strtok(p, seps);
            while ( p )
                {
                ExtensionArgs.push_back(string(p));
                p = strtok(NULL, seps);
                }

            }

        // Run the actual extension
        (*((PEXTENSION_API_ROUTINE)ExtensionRoutine))();
        }
    catch ( exception & e )
        {
        dout << '\n';
        dout << "An unexpected error occured.\n";
        dout << e.what() << '\n';
        }
    return 0;
    }

VOID
InitExtensionApi(IN HANDLE hCurrentProcess,
                 IN HANDLE hCurrentThread,
                 IN DWORD_PTR dwCurrentPc,
                 IN PWINDBG_EXTENSION_APIS lpExtensionsApis,
                 IN LPSTR lpArgumentString,
                 IN PEXTENSION_API_ROUTINE ExtensionRoutine
                )
    {

    // Initialize global variables for extension
    ::hCurrentProcess = ProcessHandle = hCurrentProcess;
    ::hCurrentThread = hCurrentThread;
    ::dwCurrentPc = dwCurrentPc;
    ::lpArgumentString = lpArgumentString;
    ::fKD = 1;

    //Windbg does not pass this, it uses WinDbgExtensionDllInit
    if (!ExtensionsInitialized)
        {
        if ( OldExtensions )
            {
            memset(&ExtensionApis, 0, sizeof(ExtensionApis));
            if ( sizeof(WINDBG_OLD_EXTENSION_APIS) == lpExtensionsApis->nSize )
                {
                memcpy(&ExtensionApis, lpExtensionsApis, lpExtensionsApis->nSize);
                ExtensionApis.lpReadProcessMemoryRoutine = ReadProcessMemoryThunk;
                ExtensionApis.lpWriteProcessMemoryRoutine = (PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE)WriteProcessMemoryThunk;
                }
            else if ( lpExtensionsApis->nSize >= sizeof(WINDBG_EXTENSION_APIS) )
                {
                memcpy(&ExtensionApis, lpExtensionsApis, sizeof(WINDBG_EXTENSION_APIS));
                }
            }
        else
           memcpy(&ExtensionApis, lpExtensionsApis, sizeof(WINDBG_EXTENSION_APIS));
        }


    ::Myprintf = ExtensionApis.lpOutputRoutine;


    ExtensionWrapRoutine(ExtensionRoutine);

    }


#define DECLARE_EXTAPI_STUB(apiname)                \
                                                    \
VOID                                                \
do##apiname(VOID);                                  \
                                                    \
extern "C"                                          \
VOID                                                \
apiname(IN HANDLE hCurrentProcess,                  \
        IN HANDLE hCurrentThread,                   \
        IN DWORD_PTR dwCurrentPc,                   \
        IN PWINDBG_EXTENSION_APIS lpExtensionApis,  \
        IN LPSTR lpArgumentString                   \
        )                                           \
{                                                   \
   InitExtensionApi(hCurrentProcess,                \
                    hCurrentThread,                 \
                    dwCurrentPc,                    \
                    lpExtensionApis,                \
                    lpArgumentString,               \
                    do##apiname);                   \
}                                                   \

#define DECLARE_EXTAPI(apiname)                     \
VOID                                                \
do##apiname(VOID)                                   \

// EXTENSION SETTINGS AND HELP
DECLARE_EXTAPI_STUB(help)
DECLARE_EXTAPI_STUB(version)
DECLARE_EXTAPI_STUB(settings)

// COMMON STRUCTURE PRINTERS
DECLARE_EXTAPI_STUB(cltinterface)
DECLARE_EXTAPI_STUB(rpcversion)
DECLARE_EXTAPI_STUB(syntaxid)
DECLARE_EXTAPI_STUB(srvinterface)
DECLARE_EXTAPI_STUB(stubdesc)
DECLARE_EXTAPI_STUB(stubmsg)

// FORMAT STRING PRINTERS
DECLARE_EXTAPI_STUB(procheader)
DECLARE_EXTAPI_STUB(procparamlist)
DECLARE_EXTAPI_STUB(proc)
DECLARE_EXTAPI_STUB(type)
DECLARE_EXTAPI_STUB(proxy)
DECLARE_EXTAPI_STUB(stub)
DECLARE_EXTAPI_STUB(proxyproc)
DECLARE_EXTAPI_STUB(stubproc)

// BUFFER PRINTERS
DECLARE_EXTAPI_STUB(procbuffer)
DECLARE_EXTAPI_STUB(typebuffer)
DECLARE_EXTAPI_STUB(pickleheader)

// MISC
DECLARE_EXTAPI_STUB(basicinfo)

// MISC TEST CODE
DECLARE_EXTAPI_STUB(testctrlc)

typedef VOID (*PSIMPLE_EXTAPI_ONE_NUMPARAM)(UINT64);
typedef VOID (*PPRINT_USAGE_ROUTINE)(VOID);

VOID ProcessSimpleExtapiOneNumParam(PSIMPLE_EXTAPI_ONE_NUMPARAM pDoRoutine,
                                    PPRINT_USAGE_ROUTINE pHelpRoutine)
    {
    size_t size = ExtensionArgs.size();
    if (size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0) {
       (*pHelpRoutine)();
       return;
    }
    if (size != 1) {
       dout << "Incorrect syntax.\n";
       (*pHelpRoutine)();
       return;
    }
    UINT64 NumberParam = GetExpression(ExtensionArgs.at(0).c_str());
    (*pDoRoutine)(NumberParam);
    }

#define DECLARE_SIMPLE_EXAPI_ONE_NUMPARAM_STUB(apiname,helproutine)    \
VOID do2##apiname(UINT64 Parameter);                                   \
VOID                                                                   \
do##apiname(VOID)                                                      \
{                                                                      \
    ProcessSimpleExtapiOneNumParam(do2##apiname,helproutine);          \
}                                                                      \
VOID                                                                   \
do2##apiname(UINT64 Parameter)                                         \

VOID ParseBasicInfo(BASIC_INFO *BasicInfo)
   {
   if (_strcmpi(ExtensionArgs.at(0).c_str(), "stubmsg") == 0)
       {
       UINT64 StubMessageAddress = GetExpression(ExtensionArgs.at(1).c_str());
       dout << "Detecting settings using MIDL_STUB_MESSAGE at " << HexOut(StubMessageAddress) << ".\n";
       BasicInfo->GetInfoFromStubMessage(StubMessageAddress);
       }
   else if (_strcmpi(ExtensionArgs.at(0).c_str(), "rpcmsg") == 0)
       {
       UINT64 RpcMessageAddress = GetExpression(ExtensionArgs.at(1).c_str());
       dout << "Detecting settings using RPC_MESSAGE at " << HexOut(RpcMessageAddress) << ".\n";
       BasicInfo->GetInfoFromRpcMessage(RpcMessageAddress);
       }
   else
       {
       ABORT("Structure type must be stubmsg or rpcmsg!\n")
       return;
       }
   }

DECLARE_EXTAPI(help)
    {

    dout <<
    "NDREXTS: NDR DEBUGGER EXTENSIONS.                                             \n"
    "                                                                              \n"
    "EXTENSION SETTINGS AND HELP:                                                  \n"
    "version                                 Version information.                  \n"
    "help                                    This message.                         \n"
    "settings                                Print extension settings.             \n"
    "settings <variable> <value>             Set extension settings.               \n"
    "                                                                              \n"
    "COMMON STRUCTURE PRINTERS:                                                    \n"
    "cltinterface <address>                  RPC_CLIENT_INTERFACE                  \n"
    "rpcversion <address>                    RPC_VERSION                           \n"
    "syntaxid <address>                      RPC_SYNTAX_IDENTIFIER                 \n"
    "srvinterface <address>                  RPC_SERVER_INTERFACE                  \n"
    "stubdesc <address>                      MIDL_STUB_DESC                        \n"
    "stubmsg <address>                       MIDL_STUB_MESSAGE                     \n"
    "                                                                              \n"
    "FORMAT STRING PRINTERS:                                                       \n"
    "proc <procaddr> <typeaddr>              Print the proc format.                \n"
    "proc (rpcmsg|stubmsg) <address>         Print the proc format.                \n"
    "procheader <address>                    Print the proc header.                \n"
    "procheader (rpcmsg|stubmsg) <address>   Print the proc header.                \n"
    "procparam <procaddr> <typeaddr>         Print the param list.                 \n"
    "proxy <ProxyAddr>                       Print OLE proxy information.          \n"
    "proxyproc <ProxyAddr> <ProcNum>         Print specified proxy procedure info. \n"
    "stub <StubAddr>                         Print OLE stub information.           \n"
    "stubproc <StubAddr> <ProcNum>           Print specified stub procedure info.  \n"
    "type <address>                          Print the type string.                \n"
    "                                                                              \n"
    "BUFFER PRINTERS:                                                              \n"
    "pickleheader <address>                  Print type or proc pickling header.   \n"
    "procbuffer <buf> <len> <proca> <typea>  Print the proc marshling buffer.      \n"
    "procbuffer (rpcmsg|stubmsg) <addres>    Print the proc marshling buffer.      \n"
    "typebuffer <buffer> <len> <typea>       Print a single type from buffer.      \n"
    "                                                                              \n"
    "MISC:                                                                         \n"
    "basicinfo (rpcmsg|stubmsg) <address>    Basic debugging info(use first).      \n"
    "Type commandname /? for more information.                                     \n"
    "                                                                              \n"
    ;

    }

DECLARE_EXTAPI(version)
    {
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    if ( !OldExtensions )
        {

        PCHAR BuildKind = SavedMajorVersion == 0x0c ? "Checked" : "Free";

        dout << DebuggerType << " NDR Extension dll for Build " << VER_PRODUCTBUILD
        << " debugging " << BuildKind << " Build " << SavedMinorVersion << '\n';
        }
    else
        {
        dout << DebuggerType << " NDR Extension dll for Build " << VER_PRODUCTBUILD
        << " debugging unknown Build \n";
        }

    }

//
// Settings management
//

void PrintSettingsUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.settings                                                             \n"
    "!ndrexts.settings <variable> <value>                                          \n"
    "                                                                              \n"
    "The first form displays the current settings. The second form sets the given  \n"
    "setting to the given value.                                                   \n"
    "                                                                              \n"
    "First form parameters:                                                        \n"
    "   None.                                                                      \n"
    "                                                                              \n"
    "Second form parameters:                                                       \n"
    "    variable:  The name of the variable to set.                               \n"
    "    value:     Value to set the variable to.                                  \n"
    "                                                                              \n"
    "The following variables are available:                                        \n"
    "   StubMode:  (OS | OI | OIC | OICF | OIF)                                    \n"
    "       Sets the MIDL mode that the stub was generated in.                     \n"
    "   Direction: (IN | OUT)                                                      \n"
    "       Sets the type of parameters in the RPC buffer.                         \n"
    "   Pickling:  (ON | OFF)                                                      \n"
    "       RPC buffer is a pickling buffer.                                       \n"
    "   Robust:    (ON | OFF)                                                      \n"
    "       Long correlation descriptors are used.   This is a default only and    \n"
    "       will be overridden if the extension can detect this.                   \n"
    "                                                                              \n"
    "   Verbosity: (LOW | MEDIUM | HIGH)                                           \n"
    "       Level of detail for output.                                            \n"
    "                                                                              \n";
    }

VOID DisplaySettings()
{

    dout << "Current NDREXTS settings:\n";

    dout << "Verbosity: ";
    switch ( VerbosityLevel )
        {
        case LOW:
            dout << "LOW\n";
            break;
        case MEDIUM:
            dout << "MEDIUM\n";
            break;
        case HIGH:
            dout << "HIGH\n";
            break;
        default:
            ABORT(" Corrupt verbosity level. \n" );
        }

    dout << "StubMode:  ";
    switch ( ContextStubMode )
        {
        case OS:
            dout << "OS\n";
            break;
        case OI:
            dout << "OI\n";
            break;
        case OIC:
            dout << "OIC\n";
            break;
        case OICF:
            dout << "OICF\n";
            break;
        case OIF:
            dout << "OIF\n";
            break;
        default:
            ABORT("Corrupt StubMode\n");
        }

    dout << "Direction: ";
    switch ( ContextDirection )
        {
        case IN_BUFFER_MODE:
            dout << "IN\n";
            break;
        case OUT_BUFFER_MODE:
            dout << "OUT\n";
            break;
        default:
            ABORT("Corrupt direction\n");
        }
    dout << "Pickling:  " << ( ContextPickling ? "ON" : "OFF" ) << '\n';
    dout << "Robust:    " << ( ContextRobust ? "ON" : "OFF" ) << '\n';
    dout << '\n';

}

VOID SetSetting(LPCSTR VariableName, LPCSTR Value )
{
    if ( _strcmpi(VariableName, "Verbosity") == 0 )
        {
        LPCSTR Level = Value;
        if ( _strcmpi( Level, "LOW" ) == 0 )
            {
            VerbosityLevel = LOW;
            }
        else if ( _strcmpi( Level, "MEDIUM" ) == 0 )
            {
            VerbosityLevel = MEDIUM;
            }
        else if ( _strcmpi( Level, "HIGH" ) == 0 )
            {
            VerbosityLevel = HIGH;
            }
        else
            {
            dout << Level << " is an invalid verbosity level.\n";
            PrintSettingsUsage();
            }
        }

    else if ( _strcmpi(VariableName, "StubMode") == 0 )
        {
        LPCSTR Mode = Value;
        if ( _strcmpi(Mode, "OS") == 0 )
            {
            ContextStubMode = OS;
            }
        else if ( _strcmpi(Mode, "OI") == 0 )
            {
            ContextStubMode = OI;
            }
        else if ( _strcmpi(Mode, "OIC") == 0 )
            {
            ContextStubMode = OIC;
            }
        else if ( _strcmpi(Mode, "OICF") == 0 )
            {
            ContextStubMode= OICF;
            }
        else if ( _strcmpi(Mode, "OIF") == 0 )
            {
            ContextStubMode = OIF;
            }
        else
            {
            dout << Mode << " is an invalid StubMode.\n";
            PrintSettingsUsage();
            return;
            }
        }

    else if ( _strcmpi(VariableName, "Direction") == 0 )
        {
        LPCSTR Direction = Value;
        if ( _strcmpi(Direction, "IN") == 0 )
            {
            ContextDirection = IN_BUFFER_MODE;
            }
        else if ( _strcmpi(Direction, "OUT") == 0 )
            {
            ContextDirection = OUT_BUFFER_MODE;
            }
        else
            {
            dout << Direction << " is an invalid direction.\n";
            PrintSettingsUsage();
            return;
            }
        }

    else if ( _strcmpi(VariableName, "Pickling") == 0 )
        {
        LPCSTR PicklingMode = Value;
        if ( _stricmp(PicklingMode,"ON") == 0 )
            {
            ContextPickling = TRUE;
            }
        else if ( _stricmp(PicklingMode,"OFF") == 0 )
           {
           ContextPickling = FALSE;
           }
        else
           {
           dout << PicklingMode << " must be either ON or OFF.\n";
           PrintSettingsUsage();
           }
        }
    else if ( _strcmpi(VariableName, "Robust") == 0 )
        {
        LPCSTR RobustMode = Value;
        if ( _stricmp(RobustMode,"ON") == 0 )
            {
            ContextRobust = TRUE;
            }
        else if ( _stricmp(RobustMode,"OFF") == 0 )
           {
           ContextRobust = FALSE;
           }
        else
           {
           dout << RobustMode << " must be either ON or OFF.\n";
           PrintSettingsUsage();
           }
        }
    else
        {
        dout << VariableName << " is an unknown variable name.\n";
        PrintSettingsUsage();
        return;
        }
}

DECLARE_EXTAPI(settings)
    {
    size_t size = ExtensionArgs.size();
    if ( size == 1 && (_strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0) )
        {
        PrintSettingsUsage();
        }
    else if ( size == 0 )
        {
        DisplaySettings();
        }
    else if ( size == 2 )
        {
        SetSetting( ExtensionArgs.at(0).c_str(), ExtensionArgs.at(1).c_str() );
        }
    else
        {
        dout << "Incorrect number of arguments!\n";
        PrintSettingsUsage();
        }
    }

//
// Basic structure dumpers
//

#define DECLARE_SIMPLE_STRUCT_PRINTER(apiname,structtype)              \
VOID Print##apiname##Usage(VOID)                                       \
    {                                                                  \
    dout <<                                                            \
    "Syntax:                                            \n"            \
    "!ndrexts." #apiname "<address>                     \n"            \
    "                                                   \n"            \
    "Prints a " #structtype " at address.               \n"            \
    "                                                   \n"            \
    "Parameters:                                        \n"            \
    "    Address: address of " #structtype " to print.  \n"            \
    "\n";                                                              \
    }                                                                  \
                                                                       \
VOID                                                                   \
do2##apiname(UINT64 Address)                                           \
{                                                                      \
    dout << "Printing " #structtype " at " << HexOut(Address) << '\n'; \
    structtype structdata;                                             \
    ReadMemory(Address, &structdata);                                  \
    IndentLevel l(dout);                                               \
    Print(dout, structdata, VerbosityLevel);                           \
    dout << '\n';                                                      \
}                                                                      \
                                                                       \
VOID                                                                   \
do##apiname(VOID)                                                      \
{                                                                      \
    ProcessSimpleExtapiOneNumParam(do2##apiname,Print##apiname##Usage);\
}                                                                      \
                                                                       \


DECLARE_SIMPLE_STRUCT_PRINTER(cltinterface,RPC_CLIENT_INTERFACE);
DECLARE_SIMPLE_STRUCT_PRINTER(rpcversion,RPC_VERSION);
DECLARE_SIMPLE_STRUCT_PRINTER(syntaxid,RPC_SYNTAX_IDENTIFIER);
DECLARE_SIMPLE_STRUCT_PRINTER(srvinterface,RPC_SERVER_INTERFACE);
DECLARE_SIMPLE_STRUCT_PRINTER(stubdesc,MIDL_STUB_DESC);
DECLARE_SIMPLE_STRUCT_PRINTER(stubmsg,MIDL_STUB_MESSAGE);

//
// Format string printing
//

void PrintProcHeaderUsage()
    {

    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.procheader <address>                                                 \n"
    "!ndrexts.procheader (rpcmsg|stubmsg) <address>                                \n"
    "                                                                              \n"
    "Prints the format string for the procedure header located at address.         \n"
    "The first form requires the address of the format string on the command line. \n"
    "The second format requires the address of the stubmsg or rpcmsg and an        \n"
    "attempt is made to automatically detect the procedure header.                 \n"
    "                                                                              \n"
    "First form parameters:                                                        \n"
    "    address: Address of the procedure header.                                 \n"
    "                                                                              \n"
    "Second form parameters:                                                       \n"
    "    (rpcmsg | stubmsg): Indicates if address is a stubmsg or rpcmsg.          \n"
    "    address: Address of the structure used for detection.                     \n"
    "                                                                              \n"
    "The following setting have an effect on this command:                         \n"
    "                                                                              \n"
    "    StubMode:     MIDL mode used to compile the stub.                         \n"
    "                                                                              \n";
    }

DECLARE_EXTAPI(procheader)
    {
    size_t size = ExtensionArgs.size();
    UINT64 ProcFormat;
    if ( size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0 )
        {
        PrintProcHeaderUsage();
        return;
        }
    else if (size == 2)
        {

        BASIC_INFO BasicInfo;

        try
           {
           ParseBasicInfo(&BasicInfo);
           }
        catch(exception e)
           {
           dout << e.what();
           PrintProcHeaderUsage();
           return;
           }

        if (!BasicInfo.ProcFormatAddressIsAvailable)
            {
            dout << "Unable to detect information!\n";
            return;
            }

        ProcFormat = BasicInfo.ProcFormatAddress;

        }
    else if ( size == 1 )
        {
        ProcFormat = GetExpression(ExtensionArgs.at(0).c_str());
        }
    else
        {
        dout << "Incorrect syntax.\n";
        PrintProcHeaderUsage();
        return;
        }

    dout << "Using proc format string at " << HexOut(ProcFormat) << ":\n";
    FORMAT_PRINTER FormatPrinter(dout);

    FormatPrinter.PrintProcHeader(ProcFormat, ContextStubMode);

    }

void PrintProcParamListUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.procparam <procaddress> <typeaddress>                                \n"
    "                                                                              \n"
    "Prints the parameter list at procaddress.                                     \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "    procaddress: Address of the parameter list.                               \n"
    "    typeaddress: Address of the type format array.                            \n"
    "                                                                              \n"
    "The following setting have an effect on this command:                         \n"
    "                                                                              \n"
    "    StubMode:     MIDL mode used to compile the stub.                         \n"
    "                                                                              \n";

    }

DECLARE_EXTAPI(procparamlist)
    {

    size_t size = ExtensionArgs.size();
    UINT64 ProcFormat, TypeFormat;
    if ( size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0 )
        {
        PrintProcParamListUsage();
        return;
        }

    if (size == 2)
        {
        ProcFormat = GetExpression(ExtensionArgs.at(0).c_str());
        TypeFormat = GetExpression(ExtensionArgs.at(1).c_str());
        }
    else {
        dout << "Incorrect syntax.\n";
        PrintProcParamListUsage();
        return;
        }

    dout << "Using proc format at " << HexOut(ProcFormat) << " and type format at "
    << HexOut(TypeFormat) << ":\n";
    FORMAT_PRINTER FormatPrinter(dout);

    FormatPrinter.PrintProcParamList(ProcFormat, TypeFormat, ContextStubMode);
    }

void PrintProcUsage()
    {

    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.proc <procaddress> <tpeaddress>                                      \n"
    "!ndrexts.proc (rpcmsg|stubmsg) <address>                                      \n"
    "                                                                              \n"
    "Prints the format string for the procedure located at address.                \n"
    "The first form requires the address of the format strings on the command line.\n"
    "The second format requires the address of the stubmsg or rpcmsg and an        \n"
    "attempt is made to automatically detect the proc format string and the type   \n"
    "format array.                                                                 \n"
    "                                                                              \n"
    "First form parameters:                                                        \n"
    "    procaddress: Address of the procedure format string.                      \n"
    "    typeaddress: Address of start of type format string array.                \n"
    "                                                                              \n"
    "Second form parameters:                                                       \n"
    "    (rpcmsg | stubmsg): Indicates if address is a stubmsg or rpcmsg.          \n"
    "    address: Address of the structure used for detection.                     \n"
    "                                                                              \n"
    "The following setting have an effect on this command:                         \n"
    "                                                                              \n"
    "    StubMode:     MIDL mode used to compile the stub.                         \n"
    "                                                                              \n";

    }

DECLARE_EXTAPI(proc)
    {

    size_t size = ExtensionArgs.size();
    UINT64 ProcFormat, TypeFormat;
    if ( size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0 )
        {
        PrintProcUsage();
        return;
        }

    if (size == 2)
        {
        try
           {
           BASIC_INFO BasicInfo;
           ParseBasicInfo(&BasicInfo);

           if (!BasicInfo.ProcFormatAddressIsAvailable || !BasicInfo.StubDescIsAvailable)
               {
               dout << "Unable to detect information!\n";
               return;
               }

           ProcFormat = BasicInfo.ProcFormatAddress;
           TypeFormat = (UINT64)BasicInfo.StubDesc.pFormatTypes;
           }
        catch(...)
           {
            ProcFormat = GetExpression(ExtensionArgs.at(0).c_str());
            TypeFormat = GetExpression(ExtensionArgs.at(1).c_str());
           }
        }
    else {
        dout << "Incorrect syntax.\n";
        PrintProcUsage();
        return;
        }

    dout << "Using proc format at " << HexOut(ProcFormat) << " and type format at "
    << HexOut(TypeFormat) << ":\n";
    FORMAT_PRINTER FormatPrinter(dout);

    FormatPrinter.PrintProc(ProcFormat, TypeFormat, ContextStubMode);

    }

void PrintTypeUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.type <typeaddress>                                                   \n"
    "                                                                              \n"
    "Prints the type format string at typeaddress.                                 \n"
    "                                                                              \n"
    "First form parameters:                                                        \n"
    "    typeaddres: Address of the type format string.                            \n"
    "                                                                              \n"
    "The following setting have an effect on this command:                         \n"
    "                                                                              \n"
    "    Robust:       ON if long correlation descriptors are used.                \n"
    "                                                                              \n";

    }

DECLARE_EXTAPI(type)
    {

    size_t size = ExtensionArgs.size();
    if ( size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0 )
        {
        PrintTypeUsage();
        return;
        }
    if ( size != 1 )
        {
        dout << "Incorrect syntax.\n";
        PrintTypeUsage();
        return;
        }

    UINT64 TypeFormat = GetExpression(ExtensionArgs.at(0).c_str());
    FORMAT_PRINTER FormatPrinter(dout);
    dout << "Using type format string at " << HexOut(TypeFormat) << ":\n";
    FormatPrinter.PrintTypeFormat(TypeFormat, ContextRobust);

    }

//
// Buffer printing
//

void PrintProcBufferUsage()
    {
    dout <<
    "Syntax:                                                                        \n"
    "!ndrexts.procbuffer <buffer> <len> <procaddr> <typeaddr>                       \n"
    "!ndrexts.procbuffer (rpcmsg|stubmsg) address                                   \n"
    "                                                                               \n"
    "Pretty prints a RPC buffer for a procedure call. If the second form is used,   \n"
    "the format strings and buffer settings are detected from the rpcmsg or stubmsg.\n"
    "                                                                               \n"
    "Parameters:                                                                    \n"
    "    buffer: address of the RPC buffer                                          \n"
    "    len: length of the RPC buffer                                              \n"
    "    procaddr: address of the procedure format string.                          \n"
    "    typeaddr: address of the start of type format string table.                \n"
    "                                                                               \n"
    "Second form parameters:                                                        \n"
    "    (rpcmsg | stubmsg): Indicates if address is a stubmsg or rpcmsg.           \n"
    "    address: Address of the structure used for detection.                      \n"
    "                                                                               \n"
    "The following setting have an effect on this command:                          \n"
    "                                                                               \n"
    "    StubMode:     MIDL mode used to compile the stub.                          \n"
    "    Direction:    Determines if the buffer contains IN or OUT parameters.      \n"
    "    Pickling:     ON if buffer is a procedure pickling buffer.                 \n"
    "                                                                               \n";

    }

DECLARE_EXTAPI(procbuffer)
    {
    size_t size = ExtensionArgs.size();
    UINT64 BufferAddress;
    ULONG BufferLength;
    UINT64 ProcAddress;
    UINT64 TypeAddress;

    if ( size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0 )
        {
        PrintProcBufferUsage();
        return;
        }

    if ( size == 2 )
        {

        BASIC_INFO BasicInfo;

        try
           {
           ParseBasicInfo(&BasicInfo);
           }
        catch(exception e)
           {
           dout << e.what();
           PrintProcBufferUsage();
           return;
           }

        if (!BasicInfo.RpcMessageIsAvailable || !BasicInfo.StubDescIsAvailable
            || !BasicInfo.ProcFormatAddressIsAvailable)
            {
            dout << "Unable to get settings.\n\n";
            return;
            }

        BufferAddress = (UINT64)BasicInfo.RpcMessage.Buffer;
        BufferLength = BasicInfo.RpcMessage.BufferLength;
        ProcAddress = BasicInfo.ProcFormatAddress;
        TypeAddress = (UINT64)BasicInfo.StubDesc.pFormatTypes;

        }
    else if (4 == size)
        {
        BufferAddress = GetExpression(ExtensionArgs.at(0).c_str());
        BufferLength = GetExpression(ExtensionArgs.at(1).c_str());
        ProcAddress = GetExpression(ExtensionArgs.at(2).c_str());
        TypeAddress = GetExpression(ExtensionArgs.at(3).c_str());
        }
    else
        {
        dout << "Incorrect syntax.\n";
        PrintProcBufferUsage();
        return;
        }

    BUFFER_PRINTER BufferPrinter( dout, BufferAddress, BufferLength,
                                  ProcAddress, TypeAddress );

    dout << "Printing proc buffer.\n";
    dout << "Buffer address: " << HexOut(BufferAddress) << ".\n";
    dout << "Buffer length: " << HexOut(BufferLength) << ".\n";
    dout << "Procedure format string: " << HexOut(ProcAddress) << ".\n";
    dout << "Type format table: " << HexOut(TypeAddress) << ".\n";
    dout << '\n';

    BufferPrinter.OutputBuffer(ContextStubMode,ContextDirection, ContextPickling);

    }

VOID PrintTypeBufferUsage()
    {
    dout <<
    "Syntax:                                                                        \n"
    "!ndrexts.typebuffer <buffer> <len> <typeaddr>                                  \n"
    "                                                                               \n"
    "Pretty prints a since type from an RPC buffer.                                 \n"
    "                                                                               \n"
    "Parameters:                                                                    \n"
    "    buffer: address of the start of the type in the RPC buffer.                \n"
    "    len: remaining length of the RPC buffer                                    \n"
    "    typeaddr: address of type format string for this type.                     \n"
    "                                                                               \n"
    "                                                                               \n"
    "The following setting have an effect on this command:                          \n"
    "                                                                               \n"
    "    Pickling:     ON if buffer is a type pickling buffer.                      \n"
    "    Robust:       ON if long correlation descriptors are used.                 \n"
    "                                                                               \n";
    }

DECLARE_EXTAPI(typebuffer)
    {

    size_t size = ExtensionArgs.size();

    if ( size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0 )
        {
        PrintProcBufferUsage();
        return;
        }
    if (size == 3)
        {
        UINT64 BufferAddress = GetExpression(ExtensionArgs.at(0).c_str());
        ULONG BufferLength = GetExpression(ExtensionArgs.at(1).c_str());
        UINT64 TypeAddress = GetExpression(ExtensionArgs.at(2).c_str());

        BUFFER_PRINTER BufferPrinter( dout, BufferAddress, BufferLength,
                              TypeAddress, TypeAddress );

        dout << "Printing type buffer.\n";
        dout << "Buffer address: " << HexOut(BufferAddress) << ".\n";
        dout << "Buffer length: " << HexOut(BufferLength) << ".\n";
        dout << "Type format string: " << HexOut(TypeAddress) << ".\n";
        dout << '\n';

        BufferPrinter.OutputTypeBuffer(ContextPickling, ContextRobust);

        }
    else
        {
        dout << "Incorrect syntax!\n";
        PrintTypeBufferUsage();
        return;
        }
    }

VOID PrintPickleHeaderUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.pickleheader <address>                                               \n"
    "                                                                              \n"
    "Prints the pickling header at address. Detects type or proc header.           \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "    Address: Address of the type or procedure pickling header.                \n"
    "                                                                              \n";
    }

DECLARE_SIMPLE_EXAPI_ONE_NUMPARAM_STUB(pickleheader,PrintPickleHeaderUsage)
    {
    UINT64 Address = Parameter;

    TYPE_PICKLING_HEADER TypeHeader;
    PROC_PICKLING_HEADER ProcHeader;

    ReadMemory(Address, &TypeHeader);

    // MS proc headers always have a (short)0xcccc filler where the type header size is.
    // MS type headers always have 8 for the size.
    if ((USHORT)0xCCCC == TypeHeader.HeaderSize)
        {
        dout << "Printing proc pickling header at " << HexOut(Address) << ".\n";
        ReadMemory(Address, &ProcHeader);
        IndentLevel l(dout);
        Print(dout, ProcHeader, VerbosityLevel);
        return;
        }

    if (sizeof(TypeHeader) == TypeHeader.HeaderSize)
        {
        dout << "Printing type pickling header at " << HexOut(Address) << ".\n";
        }
    else
        {
        dout << "Unsure what type of header this is.  Printing as a type header.\n";
        dout << "Address: " << HexOut(Address) << ".\n";
        }

    IndentLevel l(dout);
    Print(dout, TypeHeader, VerbosityLevel);
    dout << '\n';
    }

void PrintProxyUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.proxy <address>                                                      \n"
    "                                                                              \n"
    "Prints information about DCOM proxy located at address.                       \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "   Address:  This pointer for the proxy.                                      \n"
    "                                                                              \n";
    }

DECLARE_EXTAPI(proxy)
{
    size_t size = ExtensionArgs.size();
    if (size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0) {
       PrintProxyUsage();
    }
    if (size != 1) {
       Myprintf("Incorrect syntax.\n");
       PrintProxyUsage();
       return;
    }

    ULONG_PTR pAddr = GetExpression(ExtensionArgs.at(0).c_str());

    CNDRPROXY Proxy(pAddr,dout);
    Proxy.InitIfNecessary();
    Proxy.PrintProxy();

}

void PrintStubUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.stub <address>                                                       \n"
    "                                                                              \n"
    "Prints information about DCOM proxy located at address.                       \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "   Address:  Address of the stub.                                             \n"
    "                                                                              \n";
    }

DECLARE_EXTAPI(stub)
{
    size_t size = ExtensionArgs.size();
    if (size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0) {
       PrintStubUsage();
    }
    if (size != 1) {
       Myprintf("Incorrect syntax.\n");
       PrintStubUsage();
    }

    ULONG_PTR pAddr = GetExpression(ExtensionArgs.at(0).c_str());
    CNDRSTUB Stub(pAddr, dout);
    Stub.PrintStub();

}

void PrintProxyProcUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.proxyproc <address> <ProcNum>                                        \n"
    "                                                                              \n"
    "Prints the format string for the proc in the proxy.                           \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "   Address: Address of proxy.                                                 \n"
    "   ProcNum:  Proc number to dump information for.                             \n"
    "                                                                              \n";
    }

DECLARE_EXTAPI(proxyproc)
{
    size_t size = ExtensionArgs.size();
    if (size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0) {
       PrintProxyProcUsage();
    }
    if (size != 2) {
       dout << "Incorrect syntax.\n";
       PrintProxyProcUsage();
    }

    ULONG_PTR pAddr = GetExpression(ExtensionArgs.at(0).c_str());
    ULONG_PTR nProcNum = GetExpression(ExtensionArgs.at(1).c_str());

    CNDRPROXY Proxy(pAddr,dout);
    Proxy.PrintProc(nProcNum);

    return;
}

void PrintStubProcUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.stubproc <address> <ProcNum>                                         \n"
    "                                                                              \n"
    "Prints the format string for the stub in the proxy.                           \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "   Address:  Address of stub.                                                 \n"
    "   ProcNum:  Proc number to dump information for.                             \n"
    "                                                                              \n";
    }

DECLARE_EXTAPI(stubproc)
{
    size_t size = ExtensionArgs.size();
    if (size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0) {
       PrintStubProcUsage();
    }
    if (size != 2) {
       dout << "Incorrect syntax.\n";
       PrintStubProcUsage();
    }

    ULONG_PTR pAddr = GetExpression(ExtensionArgs.at(0).c_str());
    ULONG_PTR nProcNum = GetExpression(ExtensionArgs.at(1).c_str());

    CNDRSTUB Stub(pAddr,dout);
    Stub.PrintProc(nProcNum);

    return;
}

//
// Misc
//

VOID PrintBasicInfoUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.basicinfo (rpcmsg|stubmsg) <address>                                 \n"
    "                                                                              \n"
    "Prints basic debugging information about the current call.                    \n"
    "Try this first when debugging a problem.                                      \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "    Address: Address of the RPC_MESSAGE or MIDL_STUB_MESSAGE.                 \n"
    "                                                                              \n";
    }

DECLARE_EXTAPI(basicinfo)
    {
    size_t size = ExtensionArgs.size();
    if ((1 == size) && (_strcmpi(ExtensionArgs.at(0).c_str(), "/?")==0) )
        {
        PrintBasicInfoUsage();
        return;
        }
    if ( size != 2 )
        {
        dout << "Wrong number of arguments!\n";
        PrintBasicInfoUsage();
        return;
        }

    BASIC_INFO BasicInfo;
    try
        {
        ParseBasicInfo(&BasicInfo);
        }
    catch(exception e)
        {
        dout << e.what();
        PrintBasicInfoUsage();
        }

    BasicInfo.PrintInfo(dout);
    }

DECLARE_EXTAPI(testctrlc)
    {
    ULONG i = 0;
    while(1)
        {
        dout << "This is my test " << i++ << ".\n";
        }
    }

//
//  C entry points
//


ULONG NoopCheckCtrlC() {
    return 0;
}

void NonNtsdInit()
{
    CHAR szBuffer[10];      // long enough to hold low/medium/high
    DWORD len;

    fKD = 0;
    hCurrentProcess = ProcessHandle = GetCurrentProcess();
    Myprintf = (PWINDBG_OUTPUT_ROUTINE)printf;
    memset(&ExtensionApis,0,sizeof(WINDBG_EXTENSION_APIS) );
    ExtensionApis.nSize = sizeof(WINDBG_EXTENSION_APIS);
    ExtensionApis.lpReadProcessMemoryRoutine = (PWINDBG_READ_PROCESS_MEMORY_ROUTINE)ReadProcessMemoryThunk;
    ExtensionApis.lpOutputRoutine = (PWINDBG_OUTPUT_ROUTINE)printf;
    ExtensionApis.lpCheckControlCRoutine = (PWINDBG_CHECK_CONTROL_C)NoopCheckCtrlC;

    len = GetEnvironmentVariable("NDR_VERBOSE",(LPTSTR)szBuffer,10);
    // invalid value, assuming endium
    if (len == 0 || len > 10 )
    {
        VerbosityLevel = MEDIUM;
    }
    else
    {
        if ( _strcmpi( szBuffer, "LOW" ) == 0 )
            {
            VerbosityLevel = LOW;
            }
        else if ( _strcmpi( szBuffer, "MEDIUM" ) == 0 )
            {
            VerbosityLevel = MEDIUM;
            }
        else if ( _strcmpi( szBuffer, "HIGH" ) == 0 )
            {
            VerbosityLevel = HIGH;
            }

    }
}

class STDOUT_STREAM_BUFFER : public FORMATTED_STREAM_BUFFER
   {
protected:
   virtual void SystemOutput(const char *p);
   virtual BOOL SystemPollCtrlC();
   } StdoutFormattedStream;; // Stream to output to stdout.

void STDOUT_STREAM_BUFFER::SystemOutput(const char *p)
   {
       printf(p);
   }

BOOL STDOUT_STREAM_BUFFER::SystemPollCtrlC()
   {
   return FALSE;
   }

FORMATTED_STREAM_BUFFER & conout = StdoutFormattedStream;

#define BEGIN_C_ENTRY                                 \
    NonNtsdInit();                                    \
    try {                                             \

#define END_C_ENTRY                                   \
    }                                                 \
    catch ( exception & e )                           \
        {                                             \
        conout << '\n';                               \
        conout << "An unexpected error occurred.\n";   \
        conout << e.what() << '\n';                   \
        }                                             \

EXTERN_C void STDAPICALLTYPE
NdrpDumpProxy(
              IN LPVOID pAddr)
{
    BEGIN_C_ENTRY;

    CNDRPROXY Proxy((ULONG_PTR)pAddr,conout);
    Proxy.PrintProxy();

    END_C_ENTRY;

}

EXTERN_C void STDAPICALLTYPE
NdrpDumpProxyProc(
                  IN LPVOID pAddr,
                  IN ULONG_PTR nProcNum)
{

    BEGIN_C_ENTRY;

    CNDRPROXY Proxy((ULONG_PTR)pAddr, conout);
    Proxy.PrintProc(nProcNum);

    END_C_ENTRY;
}


EXTERN_C void STDAPICALLTYPE
NdrpDumpStub(
              IN LPVOID pAddr)
{
    BEGIN_C_ENTRY;
    long nCount = 0;

    CNDRSTUB Stub((ULONG_PTR)pAddr,conout);

    if (HIGHVERBOSE)
        Stub.PrintStub();

    nCount = Stub.GetDispatchCount();
    // I don't care about IUnknown methods. Don't care about IDispatch for now
    for (int i = 3; i < nCount; i++)
        Stub.PrintProc(i);

    END_C_ENTRY;

}

EXTERN_C void STDAPICALLTYPE
NdrpDumpStubProc(
                  IN LPVOID pAddr,
                  IN ULONG_PTR nProcNum)
{

    BEGIN_C_ENTRY;

    CNDRSTUB Stub((ULONG_PTR)pAddr,conout);
    Stub.PrintProc(nProcNum);

    END_C_ENTRY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrexts\ndrexts\orpcprt.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    orpcprt.h

Abstract:

    This file contains ntsd debugger extensions for OPRC part of NDR. 

Author:

    Yong Qu, yongqu@microsoft.com, Aug 10th, 1999

Revision History:

--*/

#ifndef _OPRCPRT_H
#define _OPRCPRT_H

#if defined(__cplusplus)
extern "C" 
{
#endif
 int NdrpDumpProxyBuffer(CStdProxyBuffer2 *pThis);
 int PrintErrorMsg(LPSTR ErrMsg, void * Addr, long ErrCode);
 int NdrpDumpIID(LPSTR Msg,GUID * iid);
 int NdrpDumpProxyInfo(PMIDL_STUBLESS_PROXY_INFO pProxyInfo);
 int NdrpDumpPointer(LPSTR Msg, void * pAddr);
 int NdrpDumpStubBuffer(CStdStubBuffer *pThis);
 int NdrpDumpServerInfo(MIDL_SERVER_INFO *pServerInfo);
#if defined(__cplusplus)
}
#endif

#endif // _OPRCPRT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrexts\ndrexts\ndrextsv.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    This file contains version info for RPC NDR debugger extensions.

Author:

    Mike Zoran  (mzoran)     September 3, 1999

Revision History:


--*/

#define  NdrVers  "0.80"


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrexts\ndrexts\orpcexts.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    orpcexts.h

Abstract:

    This file contains ntsd debugger extensions for OPRC part of NDR. 

Author:

    Yong Qu, yongqu@microsoft.com, Aug 10th, 1999

Revision History:

--*/

#ifndef _OPRCEXTS_H_

#define _ORPCEXTS_H_

#ifdef __cplusplus
extern "C" 
{
#endif
void ProcessProxyVtbl(ULONG_PTR);
void ProcessStubVtbl(ULONG_PTR);
BOOL GetData(IN ULONG_PTR dwAddress,  IN LPVOID ptr, IN ULONG size, IN PCSTR type );
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

#include "print.hxx"

class CPRINTPROXY 
{
private:
    FORMATTED_STREAM_BUFFER &_dout;
public:
    CPRINTPROXY(FORMATTED_STREAM_BUFFER & dout);
    void PrintIID(LPSTR Msg, GUID * IID);
    void PrintPointer(LPSTR Msg, void *pAddr);
    void PrintErrorMsg(LPSTR ErrMsg, void * pAddr, long ErrCode);
    void PrintStubDesc(MIDL_STUB_DESC *pStubDesc);

};

class CNDRPROXY: public CPRINTPROXY
{
private:
    boolean                     fInit;
    ULONG_PTR                   _pAddr;
    CStdProxyBuffer2            _ProxyBuffer;
    CInterfaceProxyHeader       _ProxyHeader;   
    GUID                        _riid;
    MIDL_STUBLESS_PROXY_INFO    _ProxyInfo;
    MIDL_STUB_DESC              _StubDesc;
    FORMATTED_STREAM_BUFFER      &_dout;
    
public:
    CNDRPROXY(ULONG_PTR pAddr, FORMATTED_STREAM_BUFFER &dout); 
    HRESULT STDAPICALLTYPE InitIfNecessary();

    void PrintProxy();
    void PrintProxyBuffer();
    void PrintProxyInfo();
    void PrintProc(ULONG_PTR nProcNum) ;

};

class CNDRSTUB: public CPRINTPROXY
{
private:
    boolean                 fInit;
    ULONG_PTR               _pAddr;
    CStdStubBuffer2         _StubBuffer;
    GUID                    _riid;
    CInterfaceStubHeader    _StubHeader;
    MIDL_SERVER_INFO        _ServerInfo;
    MIDL_STUB_DESC          _StubDesc;
    FORMATTED_STREAM_BUFFER &_dout;
public:
    CNDRSTUB(ULONG_PTR pAddr, FORMATTED_STREAM_BUFFER & dout); 
    HRESULT STDAPICALLTYPE InitIfNecessary();

    void PrintStub();
    void PrintStubBuffer(CStdStubBuffer2 *pStubBuffer);
    void PrintServerInfo(MIDL_SERVER_INFO *pServerInfo);
    void PrintProc(ULONG_PTR nProcNum) ;
    long GetDispatchCount();

};

#endif

#define MIN(x, y) ((x) < (y)) ? x:y

#endif // _ORPCEXTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrexts\ndrexts\orpcexts.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    orpcexts.c

Abstract:

    This file contains ntsd debugger extensions for OPRC part of NDR. 

Author:

    Yong Qu, yongqu@microsoft.com, Aug 10th, 1999

Revision History:

--*/

#define USE_STUBLESS_PROXY
#include <stddef.h>
#include <limits.h>
#define CINTERFACE
#include <ndrole.h>
#include <rpcproxy.h>
#undef CINTERFACE
#include <ndrexts.hxx>
#include <wdbgexts.h>
#include "orpcexts.h"
#include "orpcprt.h"
#include "print.hxx"
EXTERN_C int fKD;
EXTERN_C HANDLE ProcessHandle;

EXTERN_C BOOL 
GetData(IN ULONG_PTR dwAddress,  IN LPVOID ptr, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    if (fKD == 0)
        {
        return ReadProcessMemory(ProcessHandle, (LPVOID) dwAddress, ptr, size, 0);
        }

    while( size > 0 )
        {
        count = MIN( size, 3000 );

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count )
            {
            if (NULL == type)
                {
                type = "unspecified" ;
                }
            return FALSE;
            }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
        }

    return TRUE;
}

CNDRPROXY::CNDRPROXY(ULONG_PTR pAddr, FORMATTED_STREAM_BUFFER &dout):
    CPRINTPROXY(dout),
    _dout(dout),
    _pAddr(pAddr),
    fInit(FALSE) 
{
       
}

HRESULT STDAPICALLTYPE
CNDRPROXY::InitIfNecessary()
{
    HRESULT hr = S_OK;
    BOOL                    Status;
    ULONG_PTR               pTemp;
    ULONG_PTR pAddr = _pAddr;

    if (fInit)
        return S_OK;

        pAddr -= offsetof(CStdProxyBuffer2,pProxyVtbl);

        Status = GetData(pAddr,
                         (void *)&_ProxyBuffer,
                         sizeof(CStdProxyBuffer2),
                         NULL);
    
        if ( ! Status )
            {
            PrintErrorMsg("CstdProxyBuffer: Could not read memory at",(LPVOID)pAddr,GetLastError());
            return GetLastError();
            }


        pTemp = (ULONG_PTR)_ProxyBuffer.pProxyVtbl;
        pTemp -= sizeof(CInterfaceProxyHeader);


        
        Status = GetData(pTemp,(LPVOID)&_ProxyHeader,sizeof(CInterfaceProxyHeader),NULL);
        if ( ! Status )
            {
            PrintErrorMsg("CInterfaceProxyHeader: Could not read memory at",(LPVOID)pTemp,GetLastError());
            return GetLastError();
            }

        
        Status = GetData((ULONG_PTR)_ProxyHeader.piid,(LPVOID)&_riid,sizeof(IID),NULL);
        if ( !Status )
            {
            PrintErrorMsg("CInterfaceProxyHeader->IID Could not read memory at",(LPVOID)_ProxyHeader.piid,GetLastError());
            return GetLastError();
            }


       
        Status = GetData((ULONG_PTR)_ProxyHeader.pStublessProxyInfo,(LPVOID)&_ProxyInfo,sizeof(MIDL_STUBLESS_PROXY_INFO),NULL);
        if ( !Status )
            {
            PrintErrorMsg("ProxyInfo Could not read memory at",(LPVOID)_ProxyHeader.pStublessProxyInfo,GetLastError());
            return GetLastError();
            }

        Status = GetData((ULONG_PTR)_ProxyInfo.pStubDesc,(LPVOID)&_StubDesc,sizeof(MIDL_STUB_DESC), NULL );
        if ( !Status )
            {
            PrintErrorMsg("stub desc Could not read memory at",(LPVOID)_ProxyInfo.pStubDesc,GetLastError());
            return GetLastError();
            }

            

    return S_OK;
}

CNDRSTUB::CNDRSTUB(ULONG_PTR pAddr, FORMATTED_STREAM_BUFFER &dout):
    CPRINTPROXY(dout),
    _dout(dout),
    _pAddr(pAddr),
    fInit(FALSE) 
{
       
}


HRESULT  STDAPICALLTYPE
CNDRSTUB::InitIfNecessary()
{
    if (fInit)
        return S_OK;
    BOOL Status;
    ULONG_PTR               pTemp, pAddr = _pAddr;


        pAddr -= offsetof(CStdStubBuffer2,lpVtbl);
        
        Status = GetData(pAddr,
                         (void *)&_StubBuffer,
                         sizeof(CStdStubBuffer2),
                         NULL);
    
        if ( ! Status )
            {
            PrintErrorMsg("CstdStubBuffer2: Could not read memory at",(LPVOID)pAddr,E_FAIL);
            return E_FAIL;
            }


        pTemp = (ULONG_PTR)_StubBuffer.lpVtbl;
        pTemp -= sizeof(CInterfaceStubHeader);


        
        Status = GetData(pTemp,(LPVOID)&_StubHeader,sizeof(CInterfaceStubHeader),NULL);
        if ( ! Status )
            {
            PrintErrorMsg("CInterfaceStubHeader: Could not read memory at",(LPVOID)pTemp,E_FAIL);
            return E_FAIL;
            }

        
        Status = GetData((ULONG_PTR)_StubHeader.piid,(LPVOID)&_riid,sizeof(IID),NULL);
        if ( !Status )
            {
            PrintErrorMsg("CInterfaceStubHeader->IID Could not read memory at",(LPVOID)_StubHeader.piid,E_FAIL);
            return E_FAIL;
            }



        
        Status = GetData((ULONG_PTR)_StubHeader.pServerInfo,(LPVOID)&_ServerInfo,sizeof(MIDL_SERVER_INFO),NULL);
        if ( !Status )
            {
            PrintErrorMsg("server info Could not read memory at",(LPVOID)_StubHeader.pServerInfo,E_FAIL);
            return E_FAIL;
            }


        Status = GetData((ULONG_PTR)_ServerInfo.pStubDesc,(LPVOID)&_StubDesc,sizeof(MIDL_STUB_DESC), NULL );
        if ( !Status )
            {
            PrintErrorMsg("stub desc Could not read memory at",(LPVOID)_ServerInfo.pStubDesc,E_FAIL);
            return E_FAIL;
            }

        fInit = TRUE;            
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrexts\ndrexts\orpcprt.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    orpcexts.c

Abstract:

    This file contains ntsd debugger extensions for OPRC part of NDR. 

Author:

    Yong Qu, yongqu@microsoft.com, Aug 10th, 1999

Revision History:

--*/

#define USE_STUBLESS_PROXY
#include "ndrextsp.hxx"
#include <rpcproxy.h>
#include "orpcprt.h"
#include <orpcexts.h>

CPRINTPROXY::CPRINTPROXY(FORMATTED_STREAM_BUFFER & dout) :
    _dout(dout)
{

}

void CPRINTPROXY::PrintErrorMsg(LPSTR ErrMsg, void * Addr, long ErrCode)
{
    _dout << ErrMsg << " " << HexOut(Addr) << " " << ErrCode << "\n";
}

// ugly: can't display unicode string. 
void CPRINTPROXY::PrintIID(LPSTR Msg,GUID * riid)
{
   _dout << Msg << " " << *riid << "\n";
}


void CPRINTPROXY::PrintPointer(LPSTR Msg, void * pAddr)
{
    _dout << Msg << " " << HexOut(pAddr) << "\n";
}


void CPRINTPROXY::PrintStubDesc(MIDL_STUB_DESC *pStubDesc)
{
    
    _dout << "\nStub descriptor\n";
    Print(_dout, *pStubDesc, VerbosityLevel);
}




void CNDRPROXY::PrintProxy()
{

    if (SUCCEEDED( InitIfNecessary() ) )
        {
        PrintProxyBuffer();
        PrintPointer("\naddr. of proxy header: ", (LPVOID) ( (ULONG_PTR)_ProxyBuffer.pProxyVtbl - sizeof(CInterfaceProxyHeader) ) );
        PrintIID("ProxyHeader: IID",&_riid);
        PrintPointer("\naddr. of proxy info ", (LPVOID)_ProxyHeader.pStublessProxyInfo);
        PrintProxyInfo();

        PrintStubDesc(&_StubDesc);
        _dout << '\n';
        }
}


void CNDRPROXY::PrintProxyBuffer()
{
    _dout << "lpVtbl:          " << HexOut(_ProxyBuffer.lpVtbl) << ' ' <<
             "pProxyVtbl:      " << HexOut(_ProxyBuffer.pProxyVtbl) << '\n';
    _dout << "punkOut:         " << HexOut(_ProxyBuffer.punkOuter) << ' ' <<
             "BaseProxy:       " << HexOut(_ProxyBuffer.pBaseProxy) << '\n';
    _dout << "BaseProxyBuf:    " << HexOut(_ProxyBuffer.pBaseProxyBuffer) << ' ' <<
             "CallFactory:     " << HexOut(_ProxyBuffer.pPSFactory) << '\n';
}



void CNDRPROXY::PrintProxyInfo()
{
    _dout << "StubDesc:               " << HexOut(_ProxyInfo.pStubDesc) << '\n';
    _dout << "ProcFormatString:       " << HexOut((LPVOID)_ProxyInfo.ProcFormatString) << '\n';
    _dout << "FormatStringOffset:     " << HexOut((LPVOID)_ProxyInfo.FormatStringOffset) << '\n';
}

void CNDRPROXY::PrintProc(ULONG_PTR nProcNum)
{
    FORMAT_PRINTER FormatPrinter(_dout);
    unsigned short sOffset;

    // We don't care about IUnknow methods. 
    if (nProcNum < 3)
    {
        _dout << "Invalid proc number " << (LONG)nProcNum << '\n';
        return;
    }
    
    if ( SUCCEEDED(InitIfNecessary() ) )
        {
        if (GetData((ULONG_PTR) (_ProxyInfo.FormatStringOffset+ nProcNum ), 
                    (LPVOID)&sOffset,
                    sizeof(short),
                    NULL ) && (sOffset != -1 ))
           FormatPrinter.PrintProc((UINT64)( _ProxyInfo.ProcFormatString + sOffset),
                                (UINT64)_StubDesc.pFormatTypes, OICF);
    
        }

}


// don't print original address in low verbosity
void CNDRSTUB::PrintStub()
{
    if ( SUCCEEDED(InitIfNecessary() ) )
        {
        if (!LOWVERBOSE)
            PrintPointer("CStdStubBuffer2 @ ", (LPVOID)_pAddr);
        PrintStubBuffer(&_StubBuffer);

        if (!LOWVERBOSE)
            PrintPointer("\nstub header: ", (LPVOID)( _StubBuffer.lpVtbl - sizeof(CInterfaceStubHeader) ) );

        if (!LOWVERBOSE)
            PrintPointer("addr. of IID ", (LPVOID)_StubHeader.piid);

        PrintIID("CInterfaceStubHeader: IID",&_riid);

        if (!LOWVERBOSE)
            PrintPointer("addr. of server info ", (LPVOID)_StubHeader.pServerInfo);

        if (!LOWVERBOSE)
            PrintPointer("\nMIDL_SERVER_INFO @", (LPVOID)_StubHeader.pServerInfo );

        PrintServerInfo(&_ServerInfo);
        PrintPointer("dispatch count ",ULongToPtr(_StubHeader.DispatchTableCount));
        PrintPointer("Addr. of dispatch table ", (LPVOID)_StubHeader.pDispatchTable);

        PrintStubDesc(&_StubDesc);
        _dout << '\n';
        }

}

long CNDRSTUB::GetDispatchCount()
{
    if ( SUCCEEDED(InitIfNecessary() ) )
    {
        return _StubHeader.DispatchTableCount;
    }
    else
        return 0;
}


void CNDRSTUB::PrintStubBuffer(CStdStubBuffer2 *pThis)
{
    IID asyncIID;
    _dout << "formatvtbl:      " << HexOut(pThis->lpForwardingVtbl) << ' '
          << "pBaseStubBuffer: " << HexOut(pThis->pBaseStubBuffer) << '\n';
    _dout << "vtbl:            " << HexOut(pThis->lpVtbl) << ' '
          << "RefCount:        " << HexOut(pThis->RefCount) << '\n';
    _dout << "ServerObject:    " << HexOut(pThis->pvServerObject) << ' '
          << "CallFactory:     " << HexOut(pThis->pCallFactoryVtbl) << '\n';
    
    if (NULL == pThis->pAsyncIID)
        {
        PrintPointer("asyncIID", NULL);
        }
    else
        {
        if (! GetData((ULONG_PTR)pThis->pAsyncIID,&asyncIID,sizeof(IID), NULL ) )
            PrintErrorMsg("failed to retrive async IID",(LPVOID)pThis->pAsyncIID,E_FAIL);
        else
            PrintIID("asyncIID",&asyncIID);
        }

    _dout << "PSFactory:       " << HexOut(pThis->pPSFactory) << ' '
          << "RMBVtbl:         " << HexOut(pThis->pRMBVtbl) << '\n';
}


void CNDRSTUB::PrintServerInfo(MIDL_SERVER_INFO *pServerInfo)
{
    _dout << "StubDesc:        " << HexOut(pServerInfo->pStubDesc) << ' '
          << "DispatchTable:   " << HexOut(pServerInfo->DispatchTable) << '\n';
    _dout << "ProcString:      " << HexOut(pServerInfo->ProcString) << ' '
          << "offset table:    " << HexOut(pServerInfo->FmtStringOffset) << '\n';
}


void CNDRSTUB::PrintProc(ULONG_PTR nProcNum)
{
    FORMAT_PRINTER FormatPrinter(_dout);
    unsigned short sOffset;

    // We don't care about IUnknow methods. 
    if (nProcNum < 3)
    {
        Myprintf("Invalid proc number %d\n",nProcNum);
        return;
    }
    if ( SUCCEEDED(InitIfNecessary() ) )
        {
        if (GetData((ULONG_PTR) (_ServerInfo.FmtStringOffset + nProcNum ), 
                    (LPVOID)&sOffset,
                    sizeof(short),
                    NULL ) && (sOffset != -1 ) )  
            FormatPrinter.PrintProc((UINT64)( _ServerInfo.ProcString + sOffset),
                                (UINT64)_StubDesc.pFormatTypes, OICF);
    
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrlib\ccontext.cxx ===
/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1991

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

Description :

Provides RPC client side stub context management

History :

stevez  01-15-91        First bits into the bucket.

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <osfpcket.hxx>
#include <context.hxx>

// The NDR format of a context is a (GUID, long) instead of a pointer
// in the server address space due history.  Anyway, we just save this
// cookie, which is sent on the and mapped to and from a pointer
// on the server side.

const ULONG CONTEXT_MAGIC_VALUE = 0xFEDCBA98;

typedef struct _CCONTEXT {

    RPC_BINDING_HANDLE hRPC;    // binding handle assoicated with context

    unsigned long MagicValue;
    WIRE_CONTEXT NDR;

} CCONTEXT, *PCCONTEXT;


RPC_BINDING_HANDLE RPC_ENTRY
NDRCContextBinding (
    IN NDR_CCONTEXT CContext
    )
/*++

Routine Description:

    Given a client context handle, we need to extract the binding from it.
    If an addressing exception occurs, we need to return invalid handle
    rather than GP-fault.

Arguments:

    CContext - Supplies the client context handle.

Return Value:

    The binding handle associated with the supplied client context handle
    will be returned.  If the client context handle is invalid, then we
    raise the RPC_X_SS_CONTEXT_MISMATCH exception.

--*/
{
    __try
        {
        if ( ((CCONTEXT PAPI *) CContext)->MagicValue != CONTEXT_MAGIC_VALUE )
            {
            RpcRaiseException(RPC_X_SS_CONTEXT_MISMATCH);
            }
        }
    _except(    ( GetExceptionCode() == STATUS_ACCESS_VIOLATION )
              || ( GetExceptionCode() == STATUS_DATATYPE_MISALIGNMENT ) )
        {
        RpcRaiseException(RPC_X_SS_CONTEXT_MISMATCH);
        }

    return(((CCONTEXT PAPI *) CContext)->hRPC);
}


RPC_STATUS RPC_ENTRY
RpcSsGetContextBinding (
    IN void *ContextHandle,
    OUT RPC_BINDING_HANDLE PAPI * Binding
    )
{
    RPC_STATUS Status = RPC_S_OK;

    __try
        {
        if ( ((CCONTEXT PAPI *) ContextHandle)->MagicValue != CONTEXT_MAGIC_VALUE )
            {
            Status = RPC_S_INVALID_ARG;
            }
        else
            {
            *Binding = (((CCONTEXT PAPI *) ContextHandle)->hRPC);
            }
        }
    __except(    ( GetExceptionCode() == STATUS_ACCESS_VIOLATION )
              || ( GetExceptionCode() == STATUS_DATATYPE_MISALIGNMENT ) )
        {
        Status = RPC_S_INVALID_ARG;
        }

    return Status;
}



void RPC_ENTRY
NDRCContextMarshall (           // copy a context to a buffer
    IN  NDR_CCONTEXT hCC,           // context to marshell
    OUT void PAPI *pBuff            // buffer to marshell to
    )
    // Copy the interal representation of a context into a buffer
    //-----------------------------------------------------------------------//
{
#define hCContext ((CCONTEXT PAPI *) hCC)  // cast opaque pointer to internal

    THREAD *ThisThread;

    ThisThread = RpcpGetThreadPointer();
    ASSERT(ThisThread);

    ThisThread->SetLastSuccessfullyDestroyedContext(NULL);

    if (!hCContext)
        memset(pBuff, 0, cbNDRContext);
    else
        {

        // Check the magic value to see if this is a legit context
        __try
            {
            if ( ((CCONTEXT PAPI *) hCContext)->MagicValue != CONTEXT_MAGIC_VALUE )
                {
                RpcRaiseException(RPC_X_SS_CONTEXT_MISMATCH);
                }
            }
        __except(    ( GetExceptionCode() == STATUS_ACCESS_VIOLATION )
                  || ( GetExceptionCode() == STATUS_DATATYPE_MISALIGNMENT ) )
            {
            RpcRaiseException(RPC_X_SS_CONTEXT_MISMATCH);
            }

        memcpy(pBuff, &hCContext->NDR, sizeof(hCContext->NDR));
        }

#undef hCContext
}

long 
NDRCCopyContextHandle (
    IN void *SourceBinding,
    OUT void **DestinationBinding
    )

/*++

Routine Description:

    Duplicates a context handle by copying the binding handle and
    the context information.

Arguments:

    SourceBinding - the source handle
    DestinationBinding - the copied handle on success. Undefined on
        failure.

Return Value:

    RPC_S_OK for success. RPC_S_* for errors.

--*/
{
    CCONTEXT *ContextHandle = (CCONTEXT *)SourceBinding;
    CCONTEXT *NewContextHandle;
    RPC_BINDING_HANDLE OldBindingHandle;
    RPC_STATUS Status;

    Status = RpcSsGetContextBinding(ContextHandle, &OldBindingHandle);
    if (Status != RPC_S_OK)
        return Status;

    NewContextHandle = new CCONTEXT;
    if (NewContextHandle == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcpMemoryCopy(NewContextHandle, ContextHandle, sizeof(CCONTEXT));

    Status = RpcBindingCopy(OldBindingHandle, &NewContextHandle->hRPC);

    if (Status != RPC_S_OK)
        {
        delete NewContextHandle;
        return Status;
        }

    *DestinationBinding = NewContextHandle;

    return RPC_S_OK;
}


void
ByteSwapWireContext(
    IN WIRE_CONTEXT PAPI * WireContext,
    IN unsigned long PAPI * DataRepresentation
    )
/*++

Routine Description:

    If necessary, the wire context will be byte swapped in place.

Arguments:

    WireContext - Supplies the wire context be byte swapped and returns the
        resulting byte swapped context.

    DataRepresentation - Supplies the data representation of the supplied wire
        context.

--*/
{
    if ( (*DataRepresentation & NDR_LITTLE_ENDIAN)
                      != NDR_LOCAL_ENDIAN )
        {
        WireContext->ContextType = RpcpByteSwapLong(WireContext->ContextType);
        ByteSwapUuid((class RPC_UUID *)&WireContext->ContextUuid);
        }
}

void RPC_ENTRY
NDRCContextUnmarshall (         // process returned context
    OUT NDR_CCONTEXT PAPI *phCContext,// stub context to update
    IN  RPC_BINDING_HANDLE hRPC,            // binding handle to associate with
    IN  void PAPI *pBuff,           // pointer to NDR wire format
    IN  unsigned long DataRepresentation    // pointer to NDR data rep
    )
    // Update the users context handle from the servers NDR wire format.
    //-----------------------------------------------------------------------//
{
    PCCONTEXT hCC = (PCCONTEXT) *phCContext;
    THREAD *ThisThread;

    ThisThread = RpcpGetThreadPointer();
    ASSERT(ThisThread);

    ThisThread->SetLastSuccessfullyDestroyedContext(NULL);

    ByteSwapWireContext((WIRE_CONTEXT PAPI *) pBuff,
            (unsigned long PAPI *) &DataRepresentation);

    ASSERT( !RpcpCheckHeap() );

    // destory this context if the server returned none

    if (RpcpMemoryCompare(pBuff, &NullContext, cbNDRContext) == 0)
        {
        if (hCC)
            {
            if (hCC->hRPC)
                RpcBindingFree(&(hCC->hRPC));   // discard duplicated binding

            hCC->MagicValue = 0;
            I_RpcFree(hCC);
            }

        *phCContext = Nil;

        ThisThread->SetLastSuccessfullyDestroyedContext(hCC);

        return;
        }

    PCCONTEXT hCCtemp = 0;

    if (! hCC)                  // allocate new if none existed
        {
        hCCtemp = (PCCONTEXT) I_RpcAllocate(sizeof(CCONTEXT));

        if (hCCtemp == 0)
           {
           RpcRaiseException(RPC_S_OUT_OF_MEMORY);
           }

        hCCtemp->MagicValue = CONTEXT_MAGIC_VALUE;
        }
    else if (RpcpMemoryCompare(&hCC->NDR, pBuff, sizeof(hCC->NDR)) == 0)
        {
        // the returned context is the same as the app's context.

        return;
        }


    RPC_BINDING_HANDLE hBindtemp ;

    if( I_RpcBindingCopy(hRPC, &hBindtemp) != RPC_S_OK )
        {
        ASSERT( !RpcpCheckHeap() );
        I_RpcFree( hCCtemp );
        RpcRaiseException(RPC_S_OUT_OF_MEMORY);
        }

    if ( hCCtemp )
        hCC = hCCtemp;
    else
        RpcBindingFree(&(hCC->hRPC));

    memcpy(&hCC->NDR, pBuff, sizeof(hCC->NDR));
    hCC->hRPC = hBindtemp;

    ASSERT( !RpcpCheckHeap() );

    *phCContext = (NDR_CCONTEXT)hCC;
}


void RPC_ENTRY
RpcSsDestroyClientContext (
    IN OUT void PAPI * PAPI * ContextHandle
    )
/*++

Routine Description:

    A client application will use this routine to destroy a context handle
    which it no longer needs.  This will work without having to contact the
    server.

Arguments:

    ContextHandle - Supplies the context handle to be destroyed.  It will
        be set to zero before this routine returns.

Exceptions:

    If the context handle is invalid, then the RPC_X_SS_CONTEXT_MISMATCH
    exception will be raised.

--*/
{
    RPC_BINDING_HANDLE BindingHandle;
    RPC_STATUS RpcStatus;
    THREAD *ThisThread;
    PVOID OldLastSuccessfullyDestroyedContext;

    ThisThread = RpcpGetThreadPointer();
    if (ThisThread)
        {
        OldLastSuccessfullyDestroyedContext = ThisThread->GetLastSuccessfullyDestroyedContext();
        ThisThread->SetLastSuccessfullyDestroyedContext(NULL);

        if (OldLastSuccessfullyDestroyedContext && (*ContextHandle == OldLastSuccessfullyDestroyedContext))
            {
            *ContextHandle = 0;
            return;
            }
        }

    BindingHandle = NDRCContextBinding(*ContextHandle);

    // If a live context handle is destroyed, set the association
    // to don't linger state. This is necessary so that the server
    // receives the rundown for the destroyed context handles when the
    // association goes away. Otherwise the client may reconnect before
    // the garbage collector kills the connection, and the server will
    // leak the context handle
    // N.B. Ignore return value. For binding handles not tied to an
    // association, that's ok, because there is no association to linger
    // behind them.
    (void) RpcBindingSetOption(BindingHandle,
        RPC_C_OPT_DONT_LINGER,
        TRUE);

    RpcStatus = RpcBindingFree(&BindingHandle);

    PCCONTEXT hCC = (PCCONTEXT) *ContextHandle;
    hCC->MagicValue = 0;

    I_RpcFree(*ContextHandle);
    *ContextHandle = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrexts\ndrexts\print.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    print.cxx

Abstract:

    This file contains a print wrapper for ndr debug extensions.

Author:

    Mike Zoran (mzoran)     September 3, 1999

Revision History:

--*/


#include <ndrextsp.hxx>

const char INDENT_CHAR = ' ';
const char INDENT_MAX_CHAR = '+';
const ULONG INDENT_LIMIT = 30;
const ULONG INDENT_STEP = 1;
const ULONG NUMBER_COLUMNS = 75;

FORMATTED_STREAM_BUFFER::FORMATTED_STREAM_BUFFER() :
   IndentBuffer(NULL)
   {
   IndentLevel = 0;
   IndentPrinted = FALSE;
   IndentBuffer = new char[INDENT_LIMIT+1];
   memset(IndentBuffer, INDENT_CHAR, INDENT_LIMIT-1);
   IndentBuffer[INDENT_LIMIT-1] = INDENT_MAX_CHAR;
   IndentBuffer[INDENT_LIMIT] = '\0';
   OldIndentChar = INDENT_CHAR;
   OldIndentCharLocation = 0;
   }

FORMATTED_STREAM_BUFFER::~FORMATTED_STREAM_BUFFER()
   {
   if (IndentBuffer)
       {
       delete[] IndentBuffer;
       IndentBuffer = NULL;
       }
   }

FORMATTED_STREAM_BUFFER::_Myt& FORMATTED_STREAM_BUFFER::operator<<(const char * X)
{
    FormatOutput(X);
    return *this;
}


#define DEFINE_PRINT_TYPE_OPERATOR(type)                                            \
FORMATTED_STREAM_BUFFER::_Myt& FORMATTED_STREAM_BUFFER::operator<<(type X)          \
{                                                                                   \
     ostringstream str;                                                             \
     str << X;                                                                      \
     FormatOutput(str.str().c_str());                                               \
     return *this;                                                                  \
}                                                                      

DEFINE_PRINT_TYPE_OPERATOR(char);
DEFINE_PRINT_TYPE_OPERATOR(unsigned char);
DEFINE_PRINT_TYPE_OPERATOR(bool);
DEFINE_PRINT_TYPE_OPERATOR(short);
DEFINE_PRINT_TYPE_OPERATOR(unsigned short);
DEFINE_PRINT_TYPE_OPERATOR(int);
DEFINE_PRINT_TYPE_OPERATOR(unsigned int);
DEFINE_PRINT_TYPE_OPERATOR(long);
DEFINE_PRINT_TYPE_OPERATOR(unsigned long);
DEFINE_PRINT_TYPE_OPERATOR(float);
DEFINE_PRINT_TYPE_OPERATOR(double);
DEFINE_PRINT_TYPE_OPERATOR(long double);
DEFINE_PRINT_TYPE_OPERATOR(void const *);

VOID FORMATTED_STREAM_BUFFER::FormatOutput(const char *p)
    {
        
    char TempBuffer[80];

    PollCtrlC(TRUE);

    const char *p1 = p;
    const char *p2 = p;

    while(1)
        {
        SIZE_T StrSize;

        // This is an empty chunk

        if ( '\0' == *p1 )
            {
            break;
            }

        while( ( ( StrSize = (p2 - p1 + 1 ) ) < 79 ) &&
               ( '\0' != *p2 ) && 
               ( '\n' != *p2 ) ) 
            {
            p2++;
            }

        memcpy( TempBuffer, p1, StrSize );
        TempBuffer[ StrSize ] = '\0';

        if ( IndentLevel && !IndentPrinted )
            {
            SystemOutput(IndentBuffer);
            }
        // Need to print indent next time if ending char is a '\n';
        IndentPrinted = (*p2 != '\n');

        SystemOutput( TempBuffer );

        // This was the last chunk
        if ('\0' == *p2)
            {
            break;
            }

        // Setup for next chunk

        p1 = p2 = ( p2 + 1 );

        }

    }


ULONG FORMATTED_STREAM_BUFFER::SetIndentLevel(ULONG NewIndentLevel)
    {
    ULONG OldIndentLevel = IndentLevel;
    // restore character on top of \0
    IndentBuffer[OldIndentCharLocation] = OldIndentChar;
    IndentLevel = NewIndentLevel;
    // backup char at new \0
    OldIndentCharLocation = min(IndentLevel, INDENT_LIMIT);
    OldIndentChar = IndentBuffer[OldIndentCharLocation];
    // set new terminator
    IndentBuffer[IndentLevel] = '\0';
    return OldIndentLevel;
    }

ULONG FORMATTED_STREAM_BUFFER::GetIndentLevel() const 
    {
    return IndentLevel;
    }

ULONG FORMATTED_STREAM_BUFFER::IncIndentLevel(void)
    {
    return SetIndentLevel(IndentLevel + INDENT_STEP);
    }


ULONG FORMATTED_STREAM_BUFFER::DecIndentLevel(void)
    {
    ULONG NewIndentLevel = (IndentLevel <= INDENT_STEP) ? 0 : (IndentLevel - INDENT_STEP);
    return SetIndentLevel(NewIndentLevel); 
    }

ULONG FORMATTED_STREAM_BUFFER::GetAvailableColumns()
    {
    return NUMBER_COLUMNS - IndentLevel;
    }

BOOL FORMATTED_STREAM_BUFFER::PollCtrlC(BOOL ThrowException) 
{
    BOOL CtrlCPressed = SystemPollCtrlC();
    if (CtrlCPressed)
        {
        ABORT("CTRL-C pressed.\n");
        }
    return CtrlCPressed;
}

IndentLevel::IndentLevel(FORMATTED_STREAM_BUFFER & NewStream) : Stream(NewStream)
    {
    Stream.IncIndentLevel();
    }

IndentLevel::~IndentLevel()
    {
    Stream.DecIndentLevel();
    }

ostream & operator<<(ostream & out, Printable & obj)
    {
    return obj.Print(out);
    }
    
inline char NibbleToHexChar(unsigned char x) 
{
    return ( x >= 0xA ) ? ( 'A' + x - 0xA ) : '0' + x;
}

void HexOut::SetValue(_int64 val, unsigned int Precision)
    {
    if (Precision > 16 || Precision < 1)
        {
        ABORT("Invalid precision of " << Precision << " passed to HexOut.\n" );
        return;
        }

    str << "0x";
    while(Precision--) 
        {
        unsigned int workbyte = val >> (8 * Precision);
        unsigned char uppernibble = ( workbyte >> 4 ) & 0xF;
        unsigned char lowernibble = workbyte & 0xF;
        char upperchar = NibbleToHexChar(uppernibble);
        char lowerchar = NibbleToHexChar(lowernibble);
        str << upperchar << lowerchar;
        }    
    }

HexOut::HexOut(unsigned char x)
    {
    SetValue(x, 1);
    }
    
HexOut::HexOut(char x)
    {
    SetValue(x,1);
    }
    
HexOut::HexOut(unsigned short x)
    {
    SetValue(x, 2);
    }
    
HexOut::HexOut(short x)
    {
    SetValue(x, 2);
    }
    
HexOut::HexOut(unsigned int x)
    {
    SetValue(x, sizeof(x));
    }

HexOut::HexOut(int x)
    {
    SetValue(x, sizeof(x));
    }

HexOut::HexOut(unsigned long x)
    {
    SetValue(x, 4);
    }
    
HexOut::HexOut(long x)
    {
    SetValue(x, 4);
    }
    
HexOut::HexOut(const void *x)
    {
    SetValue((_int64)x, 8);
    }
    
HexOut::HexOut(unsigned _int64 x)
    {
    SetValue(x, 8);
    }

HexOut::HexOut(_int64 x)
    {
    SetValue(x, 8);
    }

HexOut::HexOut(_int64 x, int Precision)
    {
    SetValue(x, Precision);
    }

HexOut::HexOut(double x)
    {
    // For now, output as a int64
    _int64 TempValue = *(_int64 *)&x;
    SetValue(TempValue, 8); 
    }

ostream & HexOut::Print(ostream & out)
    {
    return out << str.str().c_str();
    }

WCHAR_OUT::WCHAR_OUT(WCHAR x) : ansitext(NULL)
{
    WCHAR TempBuffer[2];
    TempBuffer[1] = L'\0';
    TempBuffer[0] = x;
    FillAnsiText(TempBuffer);
}

WCHAR_OUT::WCHAR_OUT(PWCHAR x) : ansitext(NULL)
{
    FillAnsiText(x);
}

WCHAR_OUT::~WCHAR_OUT()
{
    if (ansitext)
        {
        delete[] ansitext;        
        }
}

ostream & WCHAR_OUT::Print(ostream & out) 
{
    return out << ansitext;
}

VOID WCHAR_OUT::FillAnsiText(PWCHAR x)
{
    int ret = WideCharToMultiByte(CP_ACP, 0, x, -1, NULL, 0, NULL, NULL);
    if (0 == ret)
        {
        ABORT("Unable to convert unicode to ansi.\n");
        }
    
    ansitext = new char[ret];
    ret = WideCharToMultiByte(CP_ACP, 0, x, -1, ansitext, ret, NULL, NULL);
    if (0 == ret)
        {
        delete[] ansitext;
        ansitext = NULL;
        ABORT("Unable to convert unicode to ansi.\n");
        }
}

ostream & operator<<(ostream & out, const GUID & Guid)
    {    
    const int GUIDSize = sizeof("{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" + 1);
    WCHAR GUIDBuffer[GUIDSize];
    int ret = StringFromGUID2(Guid, GUIDBuffer, GUIDSize);
    if (0 == ret )
        {
        ABORT("Error printing GUID.\n");
        }
    return out << WCHAR_OUT(GUIDBuffer);
    }

FORMATTED_STREAM_BUFFER & operator<<(FORMATTED_STREAM_BUFFER & out, Printable & obj)
    {
    ostringstream str;
    str << obj;
    out << str.str().c_str();
    return out;
    }

FORMATTED_STREAM_BUFFER & operator<<(FORMATTED_STREAM_BUFFER & out, const GUID & Guid)
    {
    ostringstream str;
    str << Guid;
    out << str.str().c_str();
    return out;
    }

//
//  Basic RPC structure printers(FORMATTED_STREAM_BUFFER version only)
//

VOID Print(FORMATTED_STREAM_BUFFER &out, RPC_VERSION & Version, NDREXTS_VERBOSITY VerbosityLevel)
{
    out << "MajorVersion: " << HexOut(Version.MajorVersion) << "    ";
    out << "MinorVersion: " << HexOut(Version.MinorVersion) << '\n';
}

VOID Print(FORMATTED_STREAM_BUFFER &out, RPC_SYNTAX_IDENTIFIER & Syntax, NDREXTS_VERBOSITY VerbosityLevel)
{
    out << "GUID:          " << Syntax.SyntaxGUID << '\n';
    out << "SyntaxVersion: " << '\n';
    IndentLevel l(out);
        Print(out, Syntax.SyntaxVersion, VerbosityLevel);
}

VOID Print(FORMATTED_STREAM_BUFFER & out, RPC_SERVER_INTERFACE & SrvInterface, NDREXTS_VERBOSITY VerbosityLevel) 
{
    out << "Length:                  " << HexOut(SrvInterface.Length) << '\n';
    out << "InterfaceId:             \n";
    {
       IndentLevel l(out);
       Print(out, SrvInterface.InterfaceId, VerbosityLevel);
    }
    out << "TransferSyntax:          \n"; 
    {
       IndentLevel l(out);
       Print(out, SrvInterface.TransferSyntax, VerbosityLevel);
    }
    out << "DispatchTable:           " << HexOut(SrvInterface.DispatchTable) << '\n';    
    out << "RpcProtseqEndpointCount: " << HexOut(SrvInterface.RpcProtseqEndpointCount) << '\n';
    out << "DefaultManagerEpv:       " << HexOut(SrvInterface.RpcProtseqEndpoint) << '\n';    
    out << "Flags:                   " << HexOut(SrvInterface.Flags) << '\n';    
    out << "InterpreterInfo:         " << HexOut(SrvInterface.DefaultManagerEpv) << '\n';
}

VOID Print(FORMATTED_STREAM_BUFFER & out, RPC_CLIENT_INTERFACE & CltInterface, NDREXTS_VERBOSITY VerbosityLevel) 
{
    out << "Length:                  \n" << HexOut(CltInterface.Length);
    out << "InterfaceId:             \n";
    {
       IndentLevel l(out);
       Print(out, CltInterface.InterfaceId, VerbosityLevel);
    }
    out << "TransferSyntax:          \n"; 
    {
       IndentLevel l(out);
       Print(out, CltInterface.TransferSyntax, VerbosityLevel);
    }
    out << "DispatchTable:           " << HexOut(CltInterface.DispatchTable) << '\n';
    out << "RpcProtseqEndpointCount: " << HexOut(CltInterface.RpcProtseqEndpointCount) << '\n';
    out << "RpcProtseqEndpoint:      " << HexOut(CltInterface.RpcProtseqEndpoint) << '\n';

    out << "InterpreterInfo:         " << HexOut(CltInterface.InterpreterInfo) << '\n';
    out << "Flags:                   " << HexOut(CltInterface.Flags) << '\n';
}

VOID Print(FORMATTED_STREAM_BUFFER & out, MIDL_STUB_DESC & StubDesc, NDREXTS_VERBOSITY VerbosityLevel)
{

    out << "RpcInterfaceInformation:     " << HexOut(StubDesc.RpcInterfaceInformation) << '\n';    
    out << "pfnAllocate:                 " << HexOut(StubDesc.pfnAllocate) << '\n';
    out << "pfnFree:                     " << HexOut(StubDesc.pfnFree) << '\n';
    //out << "IMPLICIT_HANDLE_INFO:        " << HexOut(StubDesc.pAutoHandle) << '\n';
    
    out << "apfnNdrRundownRoutines:      " << HexOut(StubDesc.apfnNdrRundownRoutines) << '\n';
    out << "aGenericBindingRoutinePairs: " << HexOut(StubDesc.aGenericBindingRoutinePairs) << '\n';
    out << "apfnExprEval:                " << HexOut(StubDesc.apfnExprEval) << '\n';
    out << "aXmitQuintuple:              " << HexOut(StubDesc.aXmitQuintuple) << '\n';    
    out << "pFormatTypes:                " << HexOut(StubDesc.pFormatTypes) << '\n';
    out << "fCheckBounds:                " << (StubDesc.fCheckBounds ? "YES " : "NO  ") << '\n';
    out << "Version(NDR):                " << ((StubDesc.Version >> 16) & 0xFFFF) << '.'
                                           << (StubDesc.Version && 0xFFFF) << '\n';
    out << "MIDLVersion:                 " << ((StubDesc.MIDLVersion >> 24) & 0xFF) << '.' 
                                           << ((StubDesc.MIDLVersion >> 16) & 0xFF) << '.'
                                           << (StubDesc.MIDLVersion && 0xFFFF) << '\n';   
    out << "pMallocFreeStruct:           " << HexOut(StubDesc.pMallocFreeStruct) << '\n';    
    out << "CommFaultOffsets:            " << HexOut(StubDesc.CommFaultOffsets) << '\n';
    out << "aUserMarshalQuadruple:       " << HexOut(StubDesc.aUserMarshalQuadruple) << '\n';
    out << "NotifyRoutineTable:          " << HexOut(StubDesc.NotifyRoutineTable) << '\n';
    out << "mFlags:                      " << HexOut(StubDesc.mFlags) << '\n';
    
    if (HIGHVERBOSE)
        {
        out << "Reserved5:                   " << HexOut(StubDesc.Reserved5) << '\n';
        }
}

VOID Print(FORMATTED_STREAM_BUFFER & out, MIDL_STUB_MESSAGE & StubMsg, NDREXTS_VERBOSITY VerbosityLevel)
{

    out << "RpcMsg:                 " << HexOut(StubMsg.RpcMsg) << '\n';
    out << "Buffer:                 " << HexOut(StubMsg.Buffer) << '\n';
    out << "BufferStart:            " << HexOut(StubMsg.BufferStart) << '\n';   
    out << "BufferEnd:              " << HexOut(StubMsg.BufferEnd) << '\n';
    out << "BufferMark:             " << HexOut(StubMsg.BufferMark) << '\n';
    out << "BufferLength:           " << HexOut(StubMsg.BufferLength) << '\n';    
    out << "MemorySize:             " << HexOut(StubMsg.MemorySize) << '\n';
    out << "Memory:                 " << HexOut(StubMsg.Memory) << '\n';

    out << "IsClient:           " << (StubMsg.IsClient ? "YES " : "NO  ");
    out << "ReuseBuffer:        " << (StubMsg.ReuseBuffer ? "YES " : "NO ") << '\n';
    
    if (HIGHVERBOSE)
        {
        out << "pAllocAllNodesContext:  " << HexOut(StubMsg.pAllocAllNodesContext) << '\n';
        out << "IgnoreEmbeddedPointers: " << (StubMsg.IgnoreEmbeddedPointers ? " YES " : "NO  ") << '\n';
        out << "fBufferValid:           " << (StubMsg.fBufferValid ? "YES " : "NO  ") << '\n';
        out << "PointerBufferMark:      " << HexOut(StubMsg.PointerBufferMark) << '\n';        
        }

    out << "uFlags:                 " << HexOut(StubMsg.uFlags) << '\n';

    out << "MaxCount: " << HexOut(StubMsg.MaxCount) << "    ";
    out << "Offset:   " << HexOut(StubMsg.Offset) << "    ";
    out << "ActualCount: " << HexOut(StubMsg.ActualCount) << '\n';   
    
    out << "pfnAllocate:            " << HexOut(StubMsg.pfnAllocate) << '\n';
    out << "pfnFree:                " << HexOut(StubMsg.pfnFree) << '\n';
    out << "StackTop:               " << HexOut(StubMsg.StackTop) << '\n';
    
    if (HIGHVERBOSE)
        {
        out << "pPresentedType:         " << HexOut(StubMsg.pPresentedType) << '\n';
        out << "pTransmitType:          " << HexOut(StubMsg.pTransmitType) << '\n';        
        }

    out << "SavedHandle:            " << HexOut(StubMsg.SavedHandle) << '\n';
    out << "StubDesc:               " << HexOut(StubMsg.StubDesc) << '\n';
    
    if (HIGHVERBOSE)
        {
        out << "FullPtrXlatTables:      " << HexOut(StubMsg.FullPtrXlatTables) << '\n';
        out << "FullPtrRefId:           " << HexOut(StubMsg.FullPtrRefId) << '\n';        
        }
    
    out << "fInDontFree:        " << (StubMsg.fInDontFree ? "YES " : "NO  ");
    out << "fDontCallFreeInst:  " << (StubMsg.fDontCallFreeInst ? "YES " : "NO  ") << '\n';

    out << "fInOnlyParam:       " << (StubMsg.fInOnlyParam ? "YES " : "NO  ");
    out << "fHasReturn:         " << (StubMsg.fHasReturn ? "YES " : "NO  ") << '\n';
    
    out << "fHasNewCorrDesc:    " << (StubMsg.fHasNewCorrDesc ? "YES " : "NO  ") << '\n';          
    
    if (HIGHVERBOSE)
        {
        out << "dwDestContext:          " << HexOut(StubMsg.dwDestContext) << '\n';
        out << "pvDestContext:          " << HexOut(StubMsg.pvDestContext) << '\n';
        out << "SavedContextHandles:    " << HexOut(StubMsg.SavedContextHandles) << '\n';
        out << "ParamNumber:            " << HexOut(StubMsg.ParamNumber) << '\n';
        out << "pRpcChannelBuffer:      " << HexOut(StubMsg.pRpcChannelBuffer) << '\n';
        out << "pArrayInfo:             " << HexOut(StubMsg.pArrayInfo) << '\n';
        out << "SizePtrCountArray:      " << HexOut(StubMsg.SizePtrCountArray) << '\n';
        out << "SizePtrOffsetArray:     " << HexOut(StubMsg.SizePtrOffsetArray) << '\n';
        out << "SizePtrLengthArray:     " << HexOut(StubMsg.SizePtrLengthArray) << '\n';
        out << "pArgQueue:              " << HexOut(StubMsg.pArgQueue) << '\n';
        }

    out << "dwStubPhase:            " << HexOut(StubMsg.dwStubPhase) << '\n';
    out << "pAsyncMsg:              " << HexOut(StubMsg.pAsyncMsg) << '\n';
    
    if (HIGHVERBOSE)
        {
        out << "pCorrInfo:              " << HexOut(StubMsg.pCorrInfo) << '\n';
        out << "pCorrMemory:            " << HexOut(StubMsg.pCorrMemory) << '\n';
        out << "pMemoryList:            " << HexOut(StubMsg.pMemoryList) << '\n';
//        out << "w2kReserved[0]:         " << HexOut(StubMsg.w2kReserved[0]) << '\n';
//        out << "w2kReserved[1]:         " << HexOut(StubMsg.w2kReserved[1]) << '\n';
//        out << "w2kReserved[2]:         " << HexOut(StubMsg.w2kReserved[2]) << '\n';
//        out << "w2kReserved[3]:         " << HexOut(StubMsg.w2kReserved[3]) << '\n';
//        out << "w2kReserved[4]:         " << HexOut(StubMsg.w2kReserved[4]) << '\n';
        }
}

VOID Print(FORMATTED_STREAM_BUFFER & out, PROC_PICKLING_HEADER & ProcHeader, NDREXTS_VERBOSITY VerbosityLevel)
{
    out << "HeaderVersion:                  " << HexOut(ProcHeader.HeaderVersion) << '\n';
    out << "HeaderDataRepresentation:       " << HexOut(ProcHeader.HeaderDataRepresentation) << '\n';
    out << "Filler1:                        " << HexOut(ProcHeader.Filler1) << '\n';
    out << "Transfer Syntax:                " << '\n';
    {
       IndentLevel l1(out);
       Print(out, ProcHeader.TransferSyntax, VerbosityLevel);
    }
    out << "InterfaceId:                    " << '\n';
    {
       IndentLevel l2(out);
       Print(out, ProcHeader.InterfaceId, VerbosityLevel);
    }
    out << "ProcNum:                        " << HexOut(ProcHeader.ProcNum) << '\n';
    out << "DataByteOrdering:               " << HexOut(ProcHeader.DataByteOrdering) << '\n';
    out << "DataCharRepresentation:         " << HexOut(ProcHeader.DataCharRepresentation) << '\n';
    out << "DataFlatingPointRepresentation: " << HexOut(ProcHeader.DataFloatingPointRepresentation) << '\n';
    out << "Filler2:                        " << HexOut(ProcHeader.BufferSize) << '\n';
}

VOID Print(FORMATTED_STREAM_BUFFER & out, TYPE_PICKLING_HEADER & TypeHeader, NDREXTS_VERBOSITY VerbosityLevel)
{
    out << "HeaderVersion:      " << HexOut(TypeHeader.HeaderVersion) << '\n';
    out << "DataRepresentation: " << HexOut(TypeHeader.DataRepresentation) << '\n';
    out << "HeaderSize:         " << HexOut(TypeHeader.HeaderSize) << '\n';
    out << "Filler:             " << HexOut(TypeHeader.Filler) << '\n';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrlib\charconv.cxx ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    charconv.cxx

Abstract:

    Single byte character conversion routines.

Author:

    Donna Liu (DonnaLi) ??-???-19??

Environment:

    This code should execute in all environments supported by RPC
    (DOS, Win 3.X, and Win/NT as well as OS2).

Comments:

    The EBCDIC to ASCII data conversion will not be tested until we
    interoperate with some system which speaks EBCDIC.

Revision history:

    ... (long...)

    Dov Harel   04-24-1992  Added char_array_from_ndr.
    Dov Harel   04-24-1992  Fixed both _from_ndr to do EBCDIC => ASCII
                            conversion.  Changed the EbcdicToAscii
                            table to "unsigned char" array type.
    Donna Liu   07-23-1992  Added LowerIndex parameter to
                            <basetype>_array_from_ndr routines
    Dov Harel   08-19-1992  Added RpcpMemoryCopy ([_f]memcpy)
                            to ..._array_from_ndr routines

--*/

#include <string.h>
#include <sysinc.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <rpcndr.h>
#include <ndrlibp.h>

// Note this is the conversion from IBM 1047 EBCDIC codeset to ANSI 1252 code page.
//
// Also please see a comment in endian.c regarding disputable mapping involving
// EBCDIC 0x15->0x0a and 0x25->0x85.
//
extern const
unsigned char EbcdicToAscii[];

#if !defined(DOS) || defined(WIN)
//
// Due to the DOS NDR1/NDR2 split, this function is now defined for DOS
// in ndr20\dos
//
size_t RPC_ENTRY
MIDL_wchar_strlen (
    IN wchar_t      s[]
    )

{
    size_t i = 0;

    while (s[i] != (wchar_t)0)
        {
        ++i;
        }

    return i;
}
#endif

void RPC_ENTRY
MIDL_wchar_strcpy (
    OUT void *      t,
    IN wchar_t *    s
    )
{
    while ( *(*(wchar_t **)&t)++ = *s++ )
        ;
}

void RPC_ENTRY
char_from_ndr (
    IN OUT PRPC_MESSAGE SourceMessage,
    OUT unsigned char * Target
    )

/*++

Routine Description:

    Unmarshall a single char from an RPC message buffer into
    the target (*Target).  This routine:

    o   Unmarshalls the char (as unsigned char); performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled char.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the char to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the char which was just unmarshalled.

    Target - A pointer to the char to unmarshall the data into.

Return Values:

    None.

--*/

{
    if ( (SourceMessage->DataRepresentation & NDR_CHAR_REP_MASK) ==
          NDR_EBCDIC_CHAR )
        {
        //
        // The sender is an EBCDIC system.  To convert to ASCII:
        // retrieve *(SourceMessage->Buffer) as an unsigned char, and use
        // that value to index into the EbcdicToAscii table.
        //

        *Target = EbcdicToAscii[*(unsigned char *)SourceMessage->Buffer];
        }
    else
        {
        //
        // The sender is an ASCII system.  To unmarshall, just
        // copy an unsigned character from the buffer to the Target.
        //

        *Target = *(unsigned char *)SourceMessage->Buffer;
        }
    //
    // Advance the buffer pointer before returning
    //

    (*(unsigned char**)&SourceMessage->Buffer)++;
}

//
// end char_from_ndr
//

void RPC_ENTRY
char_array_from_ndr (
    IN OUT PRPC_MESSAGE SourceMessage,
    IN unsigned long    LowerIndex,
    IN unsigned long    UpperIndex,
    OUT unsigned char   Target[]
    )

/*++

Routine Description:

    Unmarshall an array of chars from an RPC message buffer into
    the range Target[LowerIndex] .. Target[UpperIndex-1] of the
    target array of shorts (Target[]).  This routine:

    o   Unmarshalls MemberCount chars; performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the last unmarshalled char.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the first char to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the last char which was just unmarshalled.

    LowerIndex - Lower index into the target array.

    UpperIndex - Upper bound index into the target array.

    Target - An array of chars to unmarshall the data into.

Return Values:

    None.

--*/

{

    register unsigned char * MsgBuffer = (unsigned char *)SourceMessage->Buffer;
    unsigned int Index;
    int byteCount = (int)(UpperIndex - LowerIndex);

    if ( (SourceMessage->DataRepresentation & NDR_CHAR_REP_MASK) ==
          NDR_EBCDIC_CHAR )
        {

        for (Index = (int)LowerIndex; Index < UpperIndex; Index++)
            {

            //
            // The sender is an EBCDIC system.  To convert to ASCII:
            // retrieve *(SourceMessage->Buffer) as an unsigned char, and use
            // that value to Index into the EbcdicToAscii table.
            //

            Target[Index] =
                EbcdicToAscii[ MsgBuffer[(Index-LowerIndex)] ];

            }
        }
    else
        {

        RpcpMemoryCopy(
            &Target[LowerIndex],
            MsgBuffer,
            byteCount
            );

        /* Replaced by RpcpMemoryCopy:

        for (Index = LowerIndex; Index < UpperIndex; Index++)
            {

            //
            // The sender is an ASCII system.  To unmarshall, just
            // copy an unsigned character from the buffer to the Target.
            //

            Target[Index] = MsgBuffer[(Index-LowerIndex)];
            }
        */

        }
    //
    // Advance the buffer pointer before returning
    //

    *(unsigned char **)&SourceMessage->Buffer += byteCount;
}

//
// end char_array_from_ndr
//

/*

//
// Changed name to ..._bytecount.  Not currently used.
//

int MIDL_wchar_bytecount (
    unsigned char   s[]
    )

{
    int i = 0;

    while (s[2*i] || s[2*i+1]) ++i;

    return i;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrlib\help.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#ifdef WIN32

#include <memory.h>

void
NDRcopy (
    void *pDest,
    void *pSrc,
    int cb
    )
{
    memcpy(pDest, pSrc, cb);
}

#else // WIN32

void * memcpy(void far *, void far *, int);
#pragma intrinsic(memcpy)

void pascal NDRopy(void far *pDest, void far *pSrc, int cb)
{
    memcpy(pDest, pSrc, cb);
}

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrlib\intconv.cxx ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    intconv.c

Abstract:

    Short and long conversion routines.

Author:

    Dov Harel (DovH) 21-Apr-1992

Environment:

    This code should execute in all environments supported by RPC
    (DOS, Win 3.X, and Win/NT as well as OS2).

Comments:

    Split charconv.cxx into

        charconv.cxx    -   Character related conversion.
        intconv.cxx     -   Integral type conversion.
        dataconv.cxx    -   Interpretation style converstion.

Revision history:

    Donna Liu    07-23-1992  Added LowerIndex parameter to
                            <basetype>_array_from_ndr routines
    Dov Harel    08-19-1992  Added RpcpMemoryCopy ([_f]memcpy)
                            to ..._array_from_ndr routines
    Ryszard Kott 06-15-1993 Added hyper support

--*/

#include <sysinc.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <rpcndr.h>
#include <ndrlibp.h>

//
//  Definitions from rpcndr.h
//
//  Network Computing Architecture (NCA) definition:
//
//  Network Data Representation: (NDR) Label format:
//  An unsigned long (32 bits) with the following layout:
//
//  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
// +---------------+---------------+---------------+-------+-------+
// |   Reserved    |   Reserved    |Floating point | Int   | Char  |
// |               |               |Representation | Rep.  | Rep.  |
// +---------------+---------------+---------------+-------+-------+
//
//  Where
//
//      Reserved:
//
//          Must be zero (0) for NCA 1.5 and NCA 2.0.
//
//      Floating point Representation is:
//
//          0 - IEEE
//          1 - VAX
//          2 - Cray
//          3 - IBM
//
//      Int Rep. is Integer Representation:
//
//          0 - Big Endian
//          1 - Little Endian
//
//      Char Rep. is Character Representation:
//
//          0 - ASCII
//          1 - EBCDIC
//
//  #define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
//  #define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
//  #define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L
//
//  #define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
//  #define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L
//
//  #define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
//  #define NDR_VAX_FLOAT                   (unsigned long)0X00000100L
//
//  #define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
//  #define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L
//
//  #define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
//

//
//  For shorts assume the following 16-bit word layout:
//
//  1 1 1 1 1 1
//  5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
// +---------------+---------------+
// |       A       |       B       |
// +---------------+---------------+
//
// For longs assume the following 32-bit word layout:
//
//  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
// +---------------+---------------+---------------+---------------+
// |      A        |       B       |       C       |       D       |
// +---------------+---------------+---------------+---------------+
//

void RPC_ENTRY
short_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
    OUT unsigned short * Target
    )

/*++

Routine Description:

    Unmarshall a short from an RPC message buffer into the target
    (*Target).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 2) boundary,
    o   Unmarshalls the short (as unsigned short); performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled short.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the short to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the short which was just unmarshalled.

    Target - A pointer to the short to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;

    aBuffer++;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~1);

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        *(unsigned short *)Target = RtlUshortByteSwap(*(unsigned short *)aBuffer);
        }
    else
        {
        *(short *)Target = *((short *)aBuffer);
        }

    //
    // Update SourceMessage->Buffer before returning:
    //

    SourceMessage->Buffer = aBuffer + 2;
}

//
// end short_from_ndr
//

void RPC_ENTRY
short_array_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
    IN unsigned long    LowerIndex,
    IN unsigned long    UpperIndex,
    OUT unsigned short *Target
    )

/*++

Routine Description:

    Unmarshall an array of shorts from an RPC message buffer into
    the range Target[LowerIndex] .. Target[UpperIndex-1] of the
    target array of shorts (Target[]).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 2) boundary,
    o   Unmarshalls MemberCount shorts; performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the last unmarshalled short.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the first short to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the last short which was just unmarshalled.

    LowerIndex - Lower index into the target array.

    UpperIndex - Upper bound index into the target array.

    Target - An array of shorts to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;
    register unsigned int index;

    aBuffer++;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~1);

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        //
        // Big Endian Sender
        //

        for (index = (int)LowerIndex; index < UpperIndex; index++)
            {
            
            Target[index] = RtlUshortByteSwap(*(unsigned short *)aBuffer);
            aBuffer += 2;

            }
        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)aBuffer;

        }
    else
        {

        int byteCount = 2*(int)(UpperIndex - LowerIndex);

        RpcpMemoryCopy(
            &Target[LowerIndex],
            aBuffer,
            byteCount
            );
        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)(aBuffer + byteCount);
        
        }
}

//
// end short_array_from_ndr
//

void RPC_ENTRY
short_from_ndr_temp (
    IN OUT unsigned char ** source,
    OUT unsigned short *    target,
    IN unsigned long        format
    )
{

/*++

Routine Description:

    Unmarshall a short from a given buffer into the target
    (*target).  This routine:

    o   Aligns the *source pointer to the next (0 mod 2) boundary,
    o   Unmarshalls a short (as unsigned short); performs data
        conversion if necessary, and
    o   Advances the *source pointer to the address immediately
        following the unmarshalled short.

Arguments:

    source - A pointer to a pointer to a buffer

        IN - *source points to the address just prior to
            the short to be unmarshalled.
        OUT - *source points to the address just following
            the short which was just unmarshalled.

    target - A pointer to the short to unmarshall the data into.

    format - The sender data representation.

Return Values:

    None.

--*/

    register unsigned char PAPI * aBuffer = *source;

    aBuffer++;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~1);

    if ( (format & NDR_INT_REP_MASK) == NDR_BIG_ENDIAN )
        {
        *(unsigned short *)target = RtlUshortByteSwap(*(unsigned short *)aBuffer);
        }
    else
        {
        *(short *)target = *((short *)aBuffer);
        }

    //
    // Update *source (== aBuffer) before returning:
    //

    *source = aBuffer + 2;
}

//
// end short_from_ndr_temp
//

void RPC_ENTRY
long_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
    OUT unsigned long * Target
    )

/*++

Routine Description:

    Unmarshall a long from an RPC message buffer into the target
    (*Target).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 4) boundary,
    o   Unmarshalls the long (as unsigned long); performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled long.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the short to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the short which was just unmarshalled.

    Target - A pointer to the long to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;

    aBuffer = aBuffer + 3;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~3);

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        *(unsigned long *)Target = RtlUlongByteSwap(*(unsigned long *)aBuffer);
        }
    else
        {
        *(long *)Target = (*(long *)aBuffer);
        }

    //
    // Update SourceMessage->Buffer before returning:
    //

    SourceMessage->Buffer = aBuffer + 4;
}

//
// end long_from_ndr
//

void RPC_ENTRY
long_array_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
    IN unsigned long    LowerIndex,
    IN unsigned long    UpperIndex,
    OUT unsigned long * Target
    )

/*++

Routine Description:

    Unmarshall an array of longs from an RPC message buffer into
    the range Target[LowerIndex] .. Target[UpperIndex-1] of the
    target array of longs (Target[]).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 4) boundary,
    o   Unmarshalls MemberCount longs; performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the last unmarshalled long.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the first long to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the last long which was just unmarshalled.

    LowerIndex - Lower index into the target array.

    UpperIndex - Upper bound index into the target array.

    Target - An array of longs to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;
    register unsigned int index;

    aBuffer = (unsigned char *)aBuffer + 3;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~3);

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        for (index = (int)LowerIndex; index < UpperIndex; index++)
            {
            Target[index] = RtlUlongByteSwap(*(unsigned long *)aBuffer);
            aBuffer += 4;
            }

        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)aBuffer;

        }
    else
        {

        int byteCount = 4*(int)(UpperIndex - LowerIndex);

        RpcpMemoryCopy(
            &Target[LowerIndex],
            aBuffer,
            byteCount
            );
        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)(aBuffer + byteCount);
        
        }
}

//
// end long_array_from_ndr
//

void RPC_ENTRY
long_from_ndr_temp (
    IN OUT unsigned char ** source,
    OUT unsigned long *     target,
    IN unsigned long        format
    )

/*++

Routine Description:

    Unmarshall a long from a given buffer into the target
    (*target).  This routine:

    o   Aligns the *source pointer to the next (0 mod 2) boundary,
    o   Unmarshalls a long (as unsigned long); performs data
        conversion if necessary, and
    o   Advances the *source pointer to the address immediately
        following the unmarshalled long.

Arguments:

    source - A pointer to a pointer to a buffer

        IN - *source points to the address just prior to
            the long to be unmarshalled.
        OUT - *source points to the address just following
            the long which was just unmarshalled.

    target - A pointer to the long to unmarshall the data into.

    format - The sender data representation.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer = *source;

    aBuffer = (unsigned char *)aBuffer + 3;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~3);

    if ( (format & NDR_INT_REP_MASK) == NDR_BIG_ENDIAN )
        {
        *(unsigned long *)target = RtlUlongByteSwap(*(unsigned long *)aBuffer);
        }
    else
        {
        *(long *)target = (*(long *)aBuffer);
        }

    //
    // Update SourceMessage->Buffer before returning:
    //

    *source = aBuffer + 4;
}

//
// end long_from_ndr_temp
//

void RPC_ENTRY
enum_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
    OUT unsigned int * Target
    )

/*++

Routine Description:

    Unmarshall an int from an RPC message buffer into the target
    (*Target).  Note: this is based on the assumption, valid in all
    C compilers we currently support, that "enum" is treated as an
    "int" by the compiler.

    This routine:

    o   Aligns the buffer pointer to the next (0 mod 2) boundary,
    o   Unmarshalls the int (as unsigned int); performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled int.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the int to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the int which was just unmarshalled.

    Target - A pointer to the int to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;

    aBuffer++;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~1);

    //
    // Zeroe *Target to be on the safe side later for 32-bit
    // int systems!
    //

    *Target = 0;

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        *(unsigned short *)Target = RtlUshortByteSwap(*(unsigned short *)aBuffer);
        }
    else
        {
        // The following code will copy two bytes from the wire
        // to the two low order bytes of (*Target) independently of
        // the size of int.
        //

        *(short *)Target = *((short *)aBuffer);
        }

    //
    // Update SourceMessage->Buffer before returning:
    //

    SourceMessage->Buffer = aBuffer + 2;
}

//
// end enum_from_ndr
//

void RPC_ENTRY
hyper_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
//    OUT unsigned hyper * Target
    OUT           hyper * Target
    )

/*++

Routine Description:

    Unmarshall a hyper from an RPC message buffer into the target
    (*Target).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 8) boundary,
    o   Unmarshalls the hyper (as unsigned hyper); performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled hyper.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the hyper to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the hyper which was just unmarshalled.

    Target - A pointer to the hyper to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;

    aBuffer = aBuffer + 7;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~7);

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        *Target = RtlUlonglongByteSwap(*(unsigned hyper *)aBuffer);
        }
    else
        {
        *Target = *(hyper *)aBuffer;
        }

    //
    // Update SourceMessage->Buffer before returning:
    //

    SourceMessage->Buffer = aBuffer + 8;
}

//
// end hyper_from_ndr
//

#if 0

void RPC_ENTRY
hyper_array_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
    IN unsigned long    LowerIndex,
    IN unsigned long    UpperIndex,
//    OUT unsigned hyper  Target[]
    OUT         hyper * Target
    )

/*++

Routine Description:

    Unmarshall an array of hypers from an RPC message buffer into
    the range Target[LowerIndex] .. Target[UpperIndex-1] of the
    target array of hypers (Target[]).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 8) boundary,
    o   Unmarshalls MemberCount hypers; performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the last unmarshalled hyper.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the first hyper to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the last hyper which was just unmarshalled.

    LowerIndex - Lower index into the target array.

    UpperIndex - Upper bound index into the target array.

    Target - An array of hypers to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;
    register unsigned int index;

    aBuffer = (unsigned char *)aBuffer + 7;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~7);

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        for (index = (int)LowerIndex; index < UpperIndex; index++)
            {

            //.. We are doing ABCDEFGH -> HGFEDCBA
            //.. We start with ABCD going as DCBA into second word of Target

            //
            // Swap bytes:
            //
            // First apply the transformation: ABCD => BADC
            //

            *(unsigned long *)Target =
                (*(unsigned long *)aBuffer & MASK_A_C_) >> 8 |
                (*(unsigned long *)aBuffer & MASK__B_D) << 8 ;

            //
            // Now swap the left and right halves of the Target long word
            // achieving full swap: BADC => DCBA
            //
            //.. Put it into second word, without changing Target pointer yet.

            *((unsigned long *)Target + 1) =
                (*(unsigned long *)Target & MASK_AB__) >> 16 |
                (*(unsigned long *)Target & MASK___CD) << 16 ;

            //.. What's left is EFGH going into first word at Target
            //.. Compiler can't do this: ((long *)aBuffer)++;

            aBuffer += 4;

            // Swap bytes:
            //
            // First apply the transformation: EFGH => FEHG
            //

            *(unsigned long *)Target =
                (*(unsigned long *)aBuffer & MASK_A_C_) >> 8 |
                (*(unsigned long *)aBuffer & MASK__B_D) << 8 ;

            //
            // Now swap the left and right halves of the Target long word
            // achieving full swap: FEHG => HGFE
            //
            //.. Put it into first word, at the Target pointer

            *(unsigned long *)Target =
                (*(unsigned long *)Target & MASK_AB__) >> 16 |
                (*(unsigned long *)Target & MASK___CD) << 16 ;

            //.. Loop, advance pointers.

            Target++;
            aBuffer += 4;           //.. ((long *)aBuffer)++;
            }

        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)aBuffer;

        }
    else
        {

        int byteCount = 8*(int)(UpperIndex - LowerIndex);

        RpcpMemoryCopy(
            &Target[LowerIndex],
            aBuffer,
            byteCount
            );
        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)(aBuffer + byteCount);

        }
}

//
// end long_array_from_ndr
//

void RPC_ENTRY
hyper_from_ndr_temp (
    IN OUT unsigned char ** source,
//    OUT unsigned hyper *    Target,
    OUT           hyper *    Target,
    IN unsigned long        format
    )

/*++

Routine Description:

    Unmarshall a hyper from a given buffer into the target
    (*target).  This routine:

    o   Aligns the *source pointer to the next (0 mod 2) boundary,
    o   Unmarshalls a hyper (as unsigned hyper); performs data
        conversion if necessary, and
    o   Advances the *source pointer to the address immediately
        following the unmarshalled hyper.

Arguments:

    source - A pointer to a pointer to a buffer

        IN - *source points to the address just prior to
            the hyper to be unmarshalled.
        OUT - *source points to the address just following
            the hyper which was just unmarshalled.

    Target - A pointer to the hyper to unmarshall the data into.

    format - The sender data representation.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer = *source;

    aBuffer = (unsigned char *)aBuffer + 3;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~3);

    if ( (format & NDR_INT_REP_MASK) == NDR_BIG_ENDIAN )
        {

        //.. We are doing ABCDEFGH -> HGFEDCBA
        //.. We start with ABCD going as DCBA into second word of Target

        //
        // Swap bytes:
        //
        // First apply the transformation: ABCD => BADC
        //

        *(unsigned long *)Target =
            (*(unsigned long *)aBuffer & MASK_A_C_) >> 8 |
            (*(unsigned long *)aBuffer & MASK__B_D) << 8 ;

        //
        // Now swap the left and right halves of the Target long word
        // achieving full swap: BADC => DCBA
        //
        //.. and put it into second word, without changing Target pointer

        *((unsigned long *)Target + 1) =
            (*(unsigned long *)Target & MASK_AB__) >> 16 |
            (*(unsigned long *)Target & MASK___CD) << 16 ;

        //.. What's left is EFGH going into first word at Target
        //.. Compiler can't do this: ((long *)aBuffer)++;

        aBuffer += 4;

        // Swap bytes:
        //
        // First apply the transformation: EFGH => FEHG
        //

        *(unsigned long *)Target =
            (*(unsigned long *)aBuffer & MASK_A_C_) >> 8 |
            (*(unsigned long *)aBuffer & MASK__B_D) << 8 ;

        //
        // Now swap the left and right halves of the Target long word
        // achieving full swap: FEHG => HGFE
        //
        //.. Put it into the first word, at the original Target pointer.

        *(unsigned long *)Target =
            (*(unsigned long *)Target & MASK_AB__) >> 16 |
            (*(unsigned long *)Target & MASK___CD) << 16 ;

        }
    else
        {
        //.. Copy hyper as two longs, don't change Target pointer.
        //.. Advance aBuffer by a long though to get the same as from above.
        //.. Compiler can't do this: ((long *)aBuffer)++;

        *(unsigned long *)Target = (*(unsigned long *)aBuffer);
        aBuffer += 4;
        *((unsigned long *)Target + 1) = (*(unsigned long *)aBuffer);
        }

    //
    // Update SourceMessage->Buffer before returning:
    //

    *source = aBuffer + 4;
}

//
// end hyper_from_ndr_temp
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrlib\ctxcoll.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    CtxColl.cxx

Abstract:

    Implementation of ConTeXt handle COLLection.

Author:

    Kamen Moutafov    [KamenM]

Revision History:

    KamenM      Sep 2000    Created

Notes:

--*/

#include <precomp.hxx>
#include <context.hxx>
#include <SWMR.hxx>
#include <SContext.hxx>
#include <CtxColl.hxx>

ServerContextHandle *
ContextCollection::Find (
    IN WIRE_CONTEXT *WireContext
    )
/*++

Routine Description:

    Finds the server context handle corresponding to the given wire context

Arguments:

    WireContext - the context representation as it arrived on the wire

Return Value:
    The context handle that was found.
    NULL if no matching context handle was found. EEInfo will be added in 
        this case

Notes:
    As a perf optimization, if we search more than 25 elements in the list,
    and find an element, we move it to the front of the list to speed up
    subsequent searches
--*/
{
    LIST_ENTRY *CurrentListEntry;
    ServerContextHandle *CurrentContextHandle;
    int SearchedElements = 0;

    CollectionMutex.VerifyOwned();

    CurrentListEntry = ListHead.Flink;
    while (CurrentListEntry != &ListHead)
        {
        CurrentContextHandle = CONTAINING_RECORD(CurrentListEntry, ServerContextHandle, ContextChain);
        if (RpcpMemoryCompare(&CurrentContextHandle->WireContext, WireContext, sizeof(WIRE_CONTEXT)) == 0)
            {
            if (SearchedElements > 25)
                {
                RpcpfRemoveEntryList(CurrentListEntry);
                RpcpfInsertHeadList(&ListHead, CurrentListEntry);
                }
            return CurrentContextHandle;
            }

        CurrentListEntry = CurrentListEntry->Flink;
        SearchedElements ++;
        }

    return NULL;
}

RPC_STATUS
ContextCollection::AllocateContextCollection (
    OUT ContextCollection **NewColl
    )
/*++

Routine Description:

    Static function that allocates a new context collection.

Arguments:

    NewCol - a placeholder for the new connection. If the function
    fails this parameter is undefined. On success, it contains
    the new collection.

Return Value:
    RPC_S_OK for success or other codes for error.
--*/
{
    ContextCollection *NewCollection;
    RPC_STATUS RpcStatus = RPC_S_OK;

#if defined(SCONTEXT_UNIT_TESTS)
    // once in a great while, fail this
    if ((GetRandomLong() % 9999) == 0)
        return RPC_S_OUT_OF_MEMORY;
#endif

    NewCollection = new ContextCollection(&RpcStatus);
    if (NewCollection == NULL)
        {
        return RPC_S_OUT_OF_MEMORY;
        }
    else if (RpcStatus != RPC_S_OK)
        {
        delete NewCollection;
        return RpcStatus;
        }

    *NewColl = NewCollection;
    return RPC_S_OK;
}

RPC_STATUS
NDRSContextInitializeCollection (
    IN ContextCollection **ContextCollectionPlaceholder
    )
/*++

Routine Description:

    Static function that can initialize the context collection of an
    association in a thread safe manner.

Arguments:

    ContextCollectionPlaceholder - a pointer to the pointer to the context
    collection.

Return Value:
    RPC_S_OK for success or other codes for error.
--*/
{
    ContextCollection *NewCollection;
    ContextCollection *OldCollection;
    RPC_STATUS RpcStatus = RPC_S_OK;

    ASSERT(ContextCollectionPlaceholder);

    RpcStatus = ContextCollection::AllocateContextCollection(&NewCollection);
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    OldCollection = (ContextCollection *)
        InterlockedCompareExchangePointer((PVOID *)ContextCollectionPlaceholder,
        NewCollection,
        NULL);

    if (OldCollection != NULL)
        {
        delete NewCollection;
        }

    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrlib\ndrlibp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ndrlibp.h

Abstract:

    Private header file for ndrlib

Author:

    Mike Zoran (mzoran) 09-Nov-1990

Revision History:

--*/

#if defined(__cplusplus)
extern "C" {
#endif

/****************************************************************************
    Ndr Library helper function prototypes for MIDL 1.0 ndr functions.
 ****************************************************************************/

RPCRTAPI
void
RPC_ENTRY
NDRcopy (
    IN void __RPC_FAR *pTarget,
    IN void __RPC_FAR *pSource,
    IN unsigned int size
    );

RPCRTAPI
size_t
RPC_ENTRY
MIDL_wchar_strlen (
    IN wchar_t __RPC_FAR *   s
    );

RPCRTAPI
void
RPC_ENTRY
MIDL_wchar_strcpy (
    OUT void __RPC_FAR *     t,
    IN wchar_t __RPC_FAR *   s
    );

RPCRTAPI
void
RPC_ENTRY
char_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned char __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
char_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned char __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
short_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned short __RPC_FAR *                target
    );

RPCRTAPI
void
RPC_ENTRY
short_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned short __RPC_FAR *                Target
    );

RPCRTAPI
void
RPC_ENTRY
short_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned short __RPC_FAR *                target,
    IN unsigned long                              format
    );

RPCRTAPI
void
RPC_ENTRY
long_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned long __RPC_FAR *                 target
    );

RPCRTAPI
void
RPC_ENTRY
long_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned long __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
long_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned long __RPC_FAR *                 target,
    IN unsigned long                              format
    );

RPCRTAPI
void
RPC_ENTRY
enum_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned int __RPC_FAR *                  Target
    );

RPCRTAPI
void
RPC_ENTRY
float_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
float_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
double_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
double_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT    hyper __RPC_FAR *                      target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT          hyper __RPC_FAR *                Target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT             hyper __RPC_FAR *             target,
    IN   unsigned   long                          format
    );

RPCRTAPI
void
RPC_ENTRY
data_from_ndr (
    PRPC_MESSAGE                                  source,
    void __RPC_FAR *                              target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
data_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
data_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_peek_ndr (
    PRPC_MESSAGE                                  source,
    unsigned char __RPC_FAR * __RPC_FAR *         buffer,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
midl_allocate (
    size_t      size
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrlib\dataconv.cxx ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    dataconv.cxx

Abstract:

    This file contains routines used by the RPC stubs to assist in marshalling
    and unmarshalling data to and from an RPC message buffer.  Each routine
    receives as a parameter a format string which drives its actions.  The
    valid characters for the format string are :
      c - charater
      b - byte
      w - wide charater or short
      l - long
      f - float
      d - double
      s1, s2, sb - string of chars, wide chars, or bytes
      z - byte string
      )2, )4, )8,
      (2, (4, (8,
      1, 2, 4, 8 - various alignment directives

    For more details consult the Network Computing Architecture documentation
   on Network Data Representation.

Author:

    Donna Liu (donnali) 09-Nov-1990

Revision History:

    26-Feb-1992     donnali

        Moved toward NT coding style.

    09-Jul-1993     DKays

        Made wholesale source level optimizations for speed and size.

--*/

#include <sysinc.h>
#include <rpc.h>
#include <rpcndr.h>
#include <ndrlibp.h>

//
// alignment macros
//

#define  ALIGN(buffer,increment) \
            (((ULONG_PTR)buffer + increment) & ~ increment)

#define  ALIGN2(buffer) \
            (((ULONG_PTR)buffer + 1) & ~1)

#define  ALIGN4(buffer) \
            (((ULONG_PTR)buffer + 3) & ~3)

#define  ALIGN8(buffer) \
            (((ULONG_PTR)buffer + 7) & ~7)

// local routines
static unsigned long NdrStrlenStrcpy ( char *, char * );
static unsigned long NdrWStrlenStrcpy ( wchar_t *, wchar_t * );


void RPC_ENTRY
data_from_ndr (
   PRPC_MESSAGE   source,
   void *         target,
   char *         format,
   unsigned char  MscPak)
/*++

Routine Description:

    This routine copies data from the runtime buffer.

Arguments:

    source - RPC message structure passed from the runtime to the stub.

    target - Buffer to receive the unmarshalled data.

    format - Format of the data.

    MscPak - Packing level.

--*/
{
   unsigned long  valid_lower;
   unsigned long  valid_total;
    register char   *pSource;
    register char   *pTarget;
    unsigned long   pack2, pack4, pack8;
    unsigned long pack, align;

    // pre-compute the possible alignment masks
    if ( MscPak )
        MscPak--;
    pack2 = MscPak & 0x1;
    pack4 = MscPak & 0x3;
    pack8 = MscPak & 0x7;

    pSource = (char *) source->Buffer;

   if ((source->DataRepresentation & (unsigned long)0X0000FFFF) ==
      NDR_LOCAL_DATA_REPRESENTATION)
        {

        pTarget = (char *) target;

      for (;;)
            {
         switch ( *format++ )
                {
            case 'b' :
            case 'c' :
               *((char *)pTarget) = *((char *)pSource);
                    pTarget += 1;
                    pSource += 1;
               break;
            case 'w' :
               pSource = (char *) ALIGN2(pSource);
               pTarget = (char *) ALIGN(pTarget,pack2);

               *((short *)pTarget) = *((short *)pSource);
                    pTarget += 2;
                    pSource += 2;
               break;
            case 'l' :
            case 'f' :
               pSource = (char *) ALIGN4(pSource);
               pTarget = (char *) ALIGN(pTarget,pack4);

               *((long *)pTarget) = *((long *)pSource);
                    pTarget += 4;
                    pSource += 4;
               break;
            case 'h' :
            case 'd' :
               pSource = (char *) ALIGN8(pSource);
               pTarget = (char *) ALIGN(pTarget,pack8);

#if defined(DOS) || defined(WIN)
               *((DWORD *) pTarget) = *((DWORD *) &pSource);
               *(((DWORD *) pTarget) + 1) = *(((DWORD *) &pSource) + 1);
#else
               *((__int64 *)pTarget) = *((__int64 *)pSource);
#endif
                    pTarget += 8;
                    pSource += 8;
               break;
            case 's' :
               pSource = (char *) ALIGN4(pSource);

               valid_lower = *((long *)pSource);
                    pSource += 4;
               valid_total = *((long *)pSource);
                    pSource += 4;

               // double the valid_total if this is a wide char string
               if ( *format++ == '2' )
                        valid_total <<= 1;

               RpcpMemoryCopy(pTarget,
                           pSource,
                           valid_total);
                    pTarget += valid_total;
                    pSource += valid_total;
               break;
            case 'z' :
               pSource = (char *) ALIGN4(pSource);

               valid_total = *((long *)pSource);
                    pSource += 4;

               *((int *)pTarget - 1) = (int) valid_total;

               // double the valid_total if this is a wide char string
               if ( *format++ == '2' )
                        valid_total <<= 1;

               RpcpMemoryCopy(pTarget,
                           pSource,
                           valid_total);
                    pTarget += valid_total;
                    pSource += valid_total;
               break;
            case 'p' :
               pSource = (char *) ALIGN4(pSource);
               pTarget = (char *) ALIGN(pTarget,pack4);

                    pTarget += 4;
                    pSource += 4;
               break;
            case '(' :
               // *format == '2', '4', or '8'; align = 1, 3, or 7
               align = *format - '0' - 1;
               pSource = (char *) ALIGN(pSource,align);
            case ')' :
               switch ( *format++ )
                        {
                  case '8' :
                     pack = pack8;
                     break;
                  case '4' :
                     pack = pack4;
                     break;
                  case '2' :
                     pack = pack2;
                     break;
                  default :
                     continue;
                   }
               pTarget = (char *) ALIGN(pTarget,pack);
               break;
            case '8' :
               pSource = (char *) ALIGN8(pSource);
               break;
            case '4' :
               pSource = (char *) ALIGN4(pSource);
               break;
            case '2' :
               pSource = (char *) ALIGN2(pSource);
               break;
            case '1' :
               break;
            default :
                    source->Buffer = pSource;
               return;
                } // switch
            } // for
        } // if
   else
        {
      for (;;)
            {
         switch ( *format++ )
                {
            case 'b' :
               *((char *)target) = *((char *)source->Buffer);
                    source->Buffer = (void *)((ULONG_PTR)source->Buffer + 1);
                    target = (void *)((ULONG_PTR)target + 1);
               break;
            case 'c' :
               char_from_ndr(source,(unsigned char *)target);
                    target = (void *)((ULONG_PTR)target + 1);
               break;
            case 'w' :
               target = (void *) ALIGN(target,pack2);
               short_from_ndr(source,(unsigned short *)target);
                    target = (void *)((ULONG_PTR)target + 2);
               break;
            case 'l' :
               target = (void *) ALIGN(target,pack4);
               long_from_ndr(source,(unsigned long *)target);
                    target = (void *)((ULONG_PTR)target + 4);
               break;
            case 'f' :
               target = (void *) ALIGN(target,pack4);
               float_from_ndr(source, target);
                    target = (void *)((ULONG_PTR)target + 4);
               break;
            case 'd' :
               target = (void *) ALIGN(target,pack8);
               double_from_ndr(source, target);
                    target = (void *)((ULONG_PTR)target + 8);
               break;
            case 'h' :
               target = (void *) ALIGN(target,pack8);
               hyper_from_ndr(source, (hyper *)target);
                    target = (void *)((ULONG_PTR)target + 8);
               break;
            case 's' :
               long_from_ndr(source, &valid_lower);
               long_from_ndr(source, &valid_total);
               switch ( *format++ )
                  {
                  case '2' :
                     short_array_from_ndr (source,
                                      0,
                                      valid_total,
                                      (unsigned short *)target);
                            valid_total <<= 1;
                     break;
                  case '1' :
                     char_array_from_ndr (source,
                                     0,
                                     valid_total,
                                     (unsigned char *)target);
                     break;
                  case 'b' :
                     byte_array_from_ndr(source,
                                    0,
                                    valid_total,
                                    target);
                     break;
                  default :
                     continue;
                  }
                    target = (void *)((ULONG_PTR)target + valid_total);
               break;
            case 'z' :
               long_from_ndr(source, &valid_total);

               *((int *)target - 1) = (int) valid_total;

               switch ( *format++ )
                  {
                  case '2' :
                     short_array_from_ndr(source,
                                     0,
                                     valid_total,
                                     (unsigned short *)target);
                     valid_total <<= 1;
                     break;
                  case '1' :
                     byte_array_from_ndr(source,
                                    0,
                                    valid_total,
                                    target);
                     break;
                  }
                    target = (void *)((ULONG_PTR)target + valid_total);
               break;
            case 'p' :
               source->Buffer = (void *) ALIGN4(source->Buffer);
               target = (void *) ALIGN(target,pack4);
               source->Buffer = (void *)((ULONG_PTR)source->Buffer + 4);
                    target = (void *)((ULONG_PTR)target + 4);
               break;
            case '(' :
               // *format == '2', '4', or '8'; align = 1, 3, or 7
               align = *format - '0' - 1;
               pSource = (char *) ALIGN(pSource,align);
            case ')' :
               switch (*format++)
                  {
                  case '8' :
                     pack = pack8;
                     break;
                  case '4' :
                     pack = pack4;
                     break;
                  case '2' :
                     pack = pack2;
                     break;
                  default :
                     continue;
                  }
               target = (void *) ALIGN(target,pack);
               break;
            case '8' :
               source->Buffer = (void *)ALIGN8(source->Buffer);
               break;
            case '4' :
               source->Buffer = (void *)ALIGN4(source->Buffer);
               break;
            case '2' :
               source->Buffer = (void *)ALIGN2(source->Buffer);
               break;
                case '1' :
                    break;
            default :
               return;
            } // switch
         } // for
      } // else
}


void RPC_ENTRY
data_into_ndr (
   void *         source,
   PRPC_MESSAGE   target,
   char *         format,
   unsigned char  MscPak)
/*++

Routine Description:

    This routine copies data into the runtime buffer.

Arguments:

    source - Buffer of data to be marshalled into the RPC message.

    target - RPC message structure to be passed to the runtime.

    format - Format of the data.

    MscPak - Packing level.

--*/
{
   unsigned long  valid_total;
    register char   *pSource;
    register char   *pTarget;
    unsigned long   pack2, pack4, pack8;
    unsigned long increment;
    unsigned long pack, align;

    pSource = (char *)source;
    pTarget = (char *)target->Buffer;

    // pre-compute the possible alignment masks
    if ( MscPak )
        MscPak--;
    pack2 = MscPak & 0x1;
    pack4 = MscPak & 0x3;
    pack8 = MscPak & 0x7;

   for (;;)
      {
      switch (*format++)
         {
         case 'b' :
         case 'c' :
            *((char *)pTarget) = *((char *)pSource);
                pTarget += 1;
                pSource += 1;
            break;
         case 'w' :
            pTarget = (char *) ALIGN2(pTarget);
            pSource = (char *) ALIGN(pSource,pack2);

            *((short *)pTarget) = *((short *)pSource);
                pTarget += 2;
                pSource += 2;
            break;
         case 'l' :
         case 'f' :
            pTarget = (char *) ALIGN4(pTarget);
            pSource = (char *) ALIGN(pSource,pack4);

            *((long *)pTarget) = *((long *)pSource);
                pTarget += 4;
                pSource += 4;
            break;
         case 'h' :
         case 'd' :
            pTarget = (char *) ALIGN8(pTarget);
            pSource = (char *) ALIGN(pSource,pack8);

#if defined(DOS) || defined(WIN)
               *((DWORD *) pTarget) = *((DWORD *) &pSource);
               *(((DWORD *) pTarget) + 1) = *(((DWORD *) &pSource) + 1);
#else
               *((__int64 *)pTarget) = *((__int64 *)pSource);
#endif
                pTarget += 8;
                pSource += 8;
            break;
         case 's' :
                pTarget = (char *) ALIGN4(pTarget);

                switch (*format++)
                    {
                    case '2' :
                        valid_total = NdrWStrlenStrcpy((wchar_t *)(pTarget + 8),
                                          (wchar_t *)pSource);
                        increment = valid_total << 1;
                        break;
                    case '1' :
                        valid_total = NdrStrlenStrcpy(pTarget + 8,pSource);
                        increment = valid_total;
                        break;
                    default :
                        continue;
                    }

                *((long *)pTarget) = 0;      // offset
                pTarget += 4;
                *((long *)pTarget) = valid_total;  // count
                pTarget += 4;

                pTarget += increment;
                pSource += increment;
                break;
         case 'z' :
            valid_total = (long) *((int *)pSource - 1);

                pTarget = (char *) ALIGN4(pTarget);

                *((long *)pTarget) = valid_total;
                pTarget += 4;

            if ( *format++ == '2' )
               valid_total <<= 1;

                RpcpMemoryCopy(pTarget,
                        pSource,
                        valid_total);
                pTarget += valid_total;
                pSource += valid_total;
            break;
         case 'p' :
            pTarget = (char *) ALIGN4(pTarget);
            pSource = (char *) ALIGN(pSource,pack4);

                pTarget += 4;
                pSource += 4;
            break;
         case '(' :
            // *format == '2', '4', or '8'; align = 1, 3, or 7
            align = *format - '0' - 1;
            pTarget = (char *) ALIGN(pTarget,align);
         case ')' :
            switch (*format++)
               {
               case '8' :
                  pack = pack8;
                  break;
               case '4' :
                  pack = pack4;
                  break;
               case '2' :
                  pack = pack2;
                  break;
               default :
                  continue;
               }
            pSource = (char *) ALIGN(pSource,pack);
            break;
         case '8' :
            pTarget = (char *) ALIGN8(pTarget);
            break;
         case '4' :
            pTarget = (char *) ALIGN4(pTarget);
            break;
         case '2' :
            pTarget = (char *) ALIGN2(pTarget);
            break;
            case '1' :
                break;
         default :
                target->Buffer = pTarget;
            return;
         } // switch
      } // for
}


void RPC_ENTRY
tree_into_ndr (
   void *         source,
   PRPC_MESSAGE   target,
   char *         format,
   unsigned char  MscPak)
/*++

Routine Description:

    This routine copies data into the runtime buffer.

Arguments:

    source - Buffer of data to be marshalled into the RPC message.

    target - RPC message structure to be passed to the runtime.

    format - Format of the data.

    MscPak - Packing level.

--*/
{
   unsigned long  valid_total;
    register char   *pSource;
    register char   *pTarget;
    unsigned long   pack2, pack4, pack8;
    unsigned long increment;

    pSource = (char *)source;
    pTarget = (char *)target->Buffer;

    // pre-compute the possible alignment masks
    if ( MscPak )
        MscPak--;
    pack2 = MscPak & 0x1;
    pack4 = MscPak & 0x3;
    pack8 = MscPak & 0x7;

   for (;;)
      {
      switch (*format++)
         {
         case 'b' :
         case 'c' :
            pSource += 1;
            break;
         case 'w' :
            pSource = (char *) ALIGN(pSource,pack2);
            pSource += 2;
            break;
         case 'l' :
         case 'f' :
            pSource = (char *) ALIGN(pSource,pack4);
            pSource += 4;
            break;
         case 'h' :
         case 'd' :
            pSource = (char *) ALIGN(pSource,pack8);
            pSource += 8;
            break;
         case 's' :
            pSource = (char *) ALIGN(pSource,pack4);

                if ( ! *(void **)pSource )
                    {
                    pSource += 4;
                    format++;
                    break;
                    }

            pTarget = (char *) ALIGN4(pTarget);

                switch (*format++)
                    {
                    case '2' :
                        valid_total = NdrWStrlenStrcpy((wchar_t *)(pTarget+12),
                                          *(wchar_t **)pSource);
                        increment = valid_total << 1;
                        break;
                    case '1' :
                        valid_total = NdrStrlenStrcpy(pTarget + 12,
                                         *(char **)pSource);
                        increment = valid_total;
                        break;
                    default :
                        continue;
                    }

                *((long *)pTarget) = valid_total;  // max count
                pTarget += 4;
                *((long *)pTarget) = 0;      // offset
                pTarget += 4;
                *((long *)pTarget) = valid_total;  // actual count
                pTarget += 4;

                pSource += 4;
                pTarget += increment;
                break;
         case 'z' :
            pSource = (char *) ALIGN(pSource,pack4);

                if ( ! *(void **)pSource )
                    {
                    pSource += 4;
                    break;
                    }

            valid_total = (long) *(*(int **)pSource - 1);

            pTarget = (char *) ALIGN4(pTarget);

                *((long *)pTarget) = valid_total;  // max count
                pTarget += 4;
                *((long *)pTarget) = valid_total;  // actual count
                pTarget += 4;

            if ( *format++ == '2' )
               valid_total <<= 1;

                RpcpMemoryCopy(pTarget,
                        *(char **)pSource,
                        valid_total);
                pSource += 4;
                pTarget += valid_total;
            break;
         case '(' :
         case ')' :
            switch (*format++)
               {
               case '8' :
                  pSource = (char *) ALIGN(pSource,pack8);
                  break;
               case '4' :
                  pSource = (char *) ALIGN(pSource,pack4);
                  break;
               case '2' :
                  pSource = (char *) ALIGN(pSource,pack2);
                  break;
               default :
                  break;
               }
            break;
         case '8' :
         case '4' :
         case '2' :
         case '1' :
            break;
         default :
                target->Buffer = pTarget;
            return;
         } // switch
      } // for
}


void RPC_ENTRY
data_size_ndr (
   void *         source,
   PRPC_MESSAGE   target,
   char *         format,
   unsigned char  MscPak)
/*++

Routine Description:

    This routine calculates the size of the runtime buffer.

Arguments:

    source - Buffer of data to be marshalled into the RPC message.

    target - RPC message structure to be passed to the runtime.

    format - Format of the data.

    MscPak - Packing level.

--*/
{
   unsigned long         valid_total;
    register char          *pSource;
    register unsigned long targetLength;
    unsigned long        pack2, pack4, pack8;
    unsigned long       pack, align;

    pSource = (char *)source;
    targetLength = target->BufferLength;

    // pre-compute the possible alignment masks
    if ( MscPak )
        MscPak--;
    pack2 = MscPak & 0x1;
    pack4 = MscPak & 0x3;
    pack8 = MscPak & 0x7;

   for (;;)
      {
      switch (*format++)
         {
         case 'b' :
         case 'c' :
            targetLength += 1;
            break;
         case 'w' :
            targetLength = (unsigned long) ALIGN2(targetLength);
            pSource = (char *) ALIGN(pSource,pack2);

            targetLength += 2;
            pSource += 2;
            break;
         case 'l' :
         case 'f' :
            targetLength = (unsigned long) ALIGN4(targetLength);
            pSource = (char *) ALIGN(pSource,pack4);

            targetLength += 4;
            pSource += 4;
            break;
         case 'h' :
         case 'd' :
            targetLength = (unsigned long) ALIGN8(targetLength);
            pSource = (char *) ALIGN(pSource,pack8);

            targetLength += 8;
            pSource += 8;
            break;
         case 's' :
            switch (*format++)
               {
               case '2' :
                  valid_total = MIDL_wchar_strlen((wchar_t *)pSource) + 1;
                        valid_total <<= 1;
                  break;
               case '1' :
                  valid_total = strlen(pSource) + 1;
                  break;
               default :
                  continue;
               }

            targetLength = (unsigned long) ALIGN4(targetLength);

            // add string length plus two longs (for offset and count)
            targetLength += 8 + valid_total;
            break;
         case 'z' :
            targetLength = (unsigned long) ALIGN4(targetLength);

            valid_total = (long) *((int *)pSource - 1);
            if ( *format++ == '2' )
               valid_total <<= 1;

            // add byte string length plus one long (for count)
            targetLength += 4 + valid_total;
            break;
         case 'p' :
            targetLength = (unsigned long) ALIGN4(targetLength);
            pSource = (char *) ALIGN(pSource,pack4);

            target->Buffer = (void *)((ULONG_PTR)target->Buffer + 4);
            pSource += 4;
            break;
         case '(' :
            // *format == '2', '4', or '8'; align = 1, 3, or 7
            align = *format - '0' - 1;
            targetLength = (unsigned long) ALIGN(targetLength,align);
         case ')' :
            switch (*format++)
               {
               case '8' :
                  pack = pack8;
                  break;
               case '4' :
                  pack = pack4;
                  break;
               case '2' :
                  pack = pack2;
                  break;
               default :
                  continue;
               }
            pSource = (char *) ALIGN(pSource,pack);
            break;
         case '8' :
            targetLength = (unsigned long) ALIGN8(targetLength);
            break;
         case '4' :
            targetLength = (unsigned long) ALIGN4(targetLength);
            break;
         case '2' :
            targetLength = (unsigned long) ALIGN2(targetLength);
            break;
         case '1' :
            break;
         default :
                target->BufferLength = targetLength;
            return;
         } // switch
      } // for
}


void RPC_ENTRY
tree_size_ndr (
   void *         source,
   PRPC_MESSAGE   target,
   char *         format,
   unsigned char  MscPak)
/*++

Routine Description:

    This routine calculates the size of the runtime buffer.

Arguments:

    source - Buffer of data to be marshalled into the RPC message.

    target - RPC message structure to be passed to the runtime.

    format - Format of the data.

    MscPak - Packing level.

--*/
{
    unsigned long          valid_total;
    register char          *pSource;
    unsigned long          pack2, pack4, pack8;

    pSource = (char *)source;

    // pre-compute the possible alignment masks
    if ( MscPak )
        MscPak--;
    pack2 = MscPak & 0x1;
    pack4 = MscPak & 0x3;
    pack8 = MscPak & 0x7;

    for (;;)
        {
        switch (*format++)
            {
            case 'b' :
            case 'c' :
                pSource += 1;
                break;
            case 'w' :
            pSource = (char *) ALIGN(pSource,pack2);
                pSource += 2;
                break;
            case 'l' :
            case 'f' :
            pSource = (char *) ALIGN(pSource,pack4);
                pSource += 4;
                break;
         case 'h' :
            case 'd' :
            pSource = (char *) ALIGN(pSource,pack8);
                pSource += 8;
                break;
            case 's' :
            pSource = (char *) ALIGN(pSource,pack4);

                if ( ! *(void __RPC_FAR * __RPC_FAR *)pSource )
                    {
                    pSource += 4;
                    format++;
                    break;
                    }

                switch (*format++)
                    {
                    case '2' :
                        valid_total = MIDL_wchar_strlen(
                                   *(wchar_t __RPC_FAR * __RPC_FAR *)pSource)+1;
                        valid_total <<= 1;
                        break;
                    case '1' :
                        valid_total =
                            strlen (*(char __RPC_FAR * __RPC_FAR *)pSource) + 1;
                        break;
                    default :
                        continue;
                    }

            target->BufferLength = (unsigned int)
                              ALIGN4(target->BufferLength);

            // add string length plus 3 longs (max count, offset, and
            // actual count)
                target->BufferLength += 12 + valid_total;
                pSource += 4;
                break;
         case 'z' :
            pSource = (char *) ALIGN(pSource,pack4);

                if ( ! *(void __RPC_FAR * __RPC_FAR *)pSource )
                    {
                    pSource += 4;
                    break;
                    }

            valid_total = (long) *(*(int **)pSource - 1);
            if ( *format++ == '2' )
               valid_total <<= 1;

            target->BufferLength = (unsigned int)
                              ALIGN4(target->BufferLength);

            // add string length plus 2 longs (max count and actual count)
                target->BufferLength += 8 + valid_total;
                pSource += 4;
            break;
            case '(' :
            case ')' :
                switch (*format++)
                    {
                    case '8' :
                  pSource = (char *) ALIGN(pSource,pack8);
                        break;
                    case '4' :
                  pSource = (char *) ALIGN(pSource,pack4);
                        break;
                    case '2' :
                  pSource = (char *) ALIGN(pSource,pack2);
                        break;
                    default :
                        break;
                    }
                break;
            case '8' :
            case '4' :
            case '2' :
            case '1' :
                break;
            default :
                return;
            }
        }
}


void RPC_ENTRY
tree_peek_ndr (
   PRPC_MESSAGE      source,
   unsigned char **  buffer,
   char *            format,
   unsigned char     MscPak)
/*++

Routine Description:

    This routine peeks the runtime buffer.

Arguments:

    source - RPC message structure passed from the runtime to the stubs.

    target - Buffer to receive the unmarshalled data.

    format - Format of the data.

    MscPak - Packing level.

--*/
{
    unsigned long           valid_total;
    register unsigned char  *pBuffer;
    unsigned long           pack8;
    int                     IsString;

    pBuffer = *buffer;

    // pre-compute the possible alignment masks
    if ( MscPak )
        MscPak--;
    pack8 = MscPak & 0x7;

    IsString = (*format == 's' || *format == 'z');

    for (;;)
        {
        switch (*format++)
            {
            case 'b' :
            case 'c' :
                pBuffer += 1;
                break;
            case 'w' :
            pBuffer = (unsigned char *) ALIGN2(pBuffer);
                pBuffer += 2;
                break;
            case 'l' :
            case 'f' :
            pBuffer = (unsigned char *) ALIGN4(pBuffer);
                pBuffer += 4;
                break;
         case 'h' :
            case 'd' :
            pBuffer = (unsigned char *) ALIGN8(pBuffer);
                pBuffer += 8;
                break;
            case 's' :
                if ( ! IsString )
                    {
               pBuffer = (unsigned char *) ALIGN4(pBuffer);
                    if ( ! *(long *)pBuffer )
                        {
                        pBuffer += 4;
                        format++;
                        break;
                        }
                    pBuffer += 4;
                    long_from_ndr (source, &valid_total);  // max count (ignore)
                    }

                long_from_ndr (source, &valid_total); // offset (ignore)
                long_from_ndr (source, &valid_total); // actual count

            // if it's a wide char string
                if ( *format++ == '2' )
                    {
               // wide char string must be aligned on at least a
               // short boundary
                    if ( ! MscPak )
                        pack8 = 0x1;
                    valid_total <<= 1;
                    }

            source->BufferLength = (unsigned int)
                              ALIGN(source->BufferLength,pack8);

                *((unsigned long *)pBuffer - 1) = source->BufferLength;
                source->BufferLength += valid_total;
                source->Buffer = (void *)((ULONG_PTR)source->Buffer + valid_total);
                break;
         case 'z' :
                if ( ! IsString )
                    {
               pBuffer = (unsigned char *) ALIGN4(pBuffer);
                    if ( ! *(long *)pBuffer )
                        {
                        pBuffer += 4;
                  format++;
                        break;
                        }
                    pBuffer += 4;
                    long_from_ndr (source, &valid_total);  // max count (ignore)
                    }

                long_from_ndr (source, &valid_total); // actual count

            // if it's a wide byte string
                if ( *format++ == '2' )
                    {
               // wide byte string must be aligned on at least a
               // short boundary
                    if ( ! MscPak )
                        pack8 = 0x1;
                    valid_total <<= 1;
                    }

            source->BufferLength = (unsigned int)
                              ALIGN(source->BufferLength,pack8);

                *((unsigned long *)pBuffer - 1) = source->BufferLength;
                source->BufferLength += valid_total;
                source->Buffer = (void *)((ULONG_PTR)source->Buffer + valid_total);
            break;
            case '(' :
                switch (*format++)
                    {
                    case '8' :
                  pBuffer = (unsigned char *) ALIGN8(pBuffer);
                        break;
                    case '4' :
                  pBuffer = (unsigned char *) ALIGN4(pBuffer);
                        break;
                    case '2' :
                  pBuffer = (unsigned char *) ALIGN2(pBuffer);
                        break;
                    default :
                        break;
                    }
                break;
            case ')' :
                format++;
                break;
            case '8' :
            pBuffer = (unsigned char *) ALIGN8(pBuffer);
                break;
            case '4' :
            pBuffer = (unsigned char *) ALIGN4(pBuffer);
                break;
            case '2' :
            pBuffer = (unsigned char *) ALIGN2(pBuffer);
                break;
            case '1' :
                break;
            default :
            *buffer = pBuffer;
                return;
            }
        }
}

static unsigned long NdrStrlenStrcpy ( char *pTarget,
                              char *pSource )
{
    register unsigned int count;

    for ( count = 1; *pTarget++ = *pSource++; count++ )
      ;

   return count;
}

static unsigned long NdrWStrlenStrcpy ( wchar_t *pTarget,
                              wchar_t *pSource )
{
    register unsigned int count;

    for ( count = 1; *pTarget++ = *pSource++; count++ )
      ;

   return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrlib\floatc.cxx ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    floatc.cxx

Abstract:

    Float and double conversion routines.

Author:

    Dov Harel (DovH) 23-Apr-1992

Environment:

    This code should execute in all environments supported by RPC
    (DOS, Win 3.X, and Win/NT as well as OS2).

Comments:

    This file was completely rewritten to incorporate DCE floating
    point conversion.  Currently the only supported DCE interoperation
    is with DEC system.  The vax conversion routines used
    (cvt_vax_f_to_ieee_single, and cvt_vax_g_to_ieee_double)
    were supplied by Digital, and are used for full compatibility with
    DCE RPC.  (See name.map for Digital files used).

    Also added floating point array conversion routines.

Revision history:

    Donna Liu   07-23-1992  Added LowerIndex parameter to
                            <basetype>_array_from_ndr routines
    Dov Harel   08-19-1992  Added RpcpMemoryCopy ([_f]memcpy)
                            to ..._array_from_ndr routines
    Dov Harel   08-25-1992  Added byte swapping for IEEE big endian
                            machines (such as HP).

--*/

#include <sysinc.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <rpcndr.h>
#include <..\..\ndr20\cvt.h>
#include <ndrlibp.h>

//
// For longs assume the following 32-bit word layout:
//
//  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
// +---------------+---------------+---------------+---------------+
// |      A        |       B       |       C       |       D       |
// +---------------+---------------+---------------+---------------+
//
//
// Masks defined for long byte swapping:
//

#define MASK_AB__        (unsigned long)0XFFFF0000L
#define MASK___CD        (unsigned long)0X0000FFFFL
#define MASK_A_C_        (unsigned long)0XFF00FF00L
#define MASK__B_D        (unsigned long)0X00FF00FFL

//
//  #define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
//  #define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
//  #define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L
//
//  #define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
//  #define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L
//
//  #define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
//  #define NDR_VAX_FLOAT                   (unsigned long)0X00000100L
//
//  #define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
//  #define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L
//
//  #define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
//

#define NDR_FLOAT_INT_MASK                  (unsigned long)0X0000FFF0L

#define NDR_BIG_IEEE_REP                    (unsigned long)0X00000000L
#define NDR_LITTLE_IEEE_REP                 (unsigned long)0X00000010L

void RPC_ENTRY
NdrpLongByteSwap(
    IN void PAPI * Source,
    OUT void PAPI * Target
    )

/*++

Routine Description:

    Assuming both Source and Target point to aligned unsigned longs,
    move the bytes of *Source into *Target in reverse oreder.  The value
    of (*Target) following the call is the bate swapped value of
    (*Source).

Arguments:

    Source - A pointer to an aligned unsigned long.

    Target - A pointer to the long to swap the *Source bytes into.

Return Values:

    None.

--*/

{

    //
    // Swap bytes:
    //
    // First apply the transformation: ABCD => BADC
    //

    *(unsigned long *)Target =
        (*(unsigned long *)Source & MASK_A_C_) >> 8 |
        (*(unsigned long *)Source & MASK__B_D) << 8 ;

    //
    // Now swap the left and right halves of the Target long word
    // achieving full swap: BADC => DCBA
    //

    *(unsigned long *)Target =
        (*(unsigned long *)Target & MASK_AB__) >> 16 |
        (*(unsigned long *)Target & MASK___CD) << 16 ;

}

//
// end NdrpLongByteSwap
//

/*

//
// Relevant definitions from cvt.h (Digital):
//

typedef unsigned char CVT_BYTE;
typedef CVT_BYTE *CVT_BYTE_PTR;

typedef CVT_BYTE CVT_VAX_F[4];
typedef CVT_BYTE CVT_VAX_D[8];
typedef CVT_BYTE CVT_VAX_G[8];

typedef CVT_BYTE CVT_IEEE_SINGLE[4];
typedef CVT_BYTE CVT_IEEE_DOUBLE[8];

//
// Relevant definitions from vaxout.c
// (previous floating point conversion test):
//

CVT_VAX_F inputf;
CVT_IEEE_SINGLE outputf;
CVT_VAX_G inputg;
CVT_IEEE_DOUBLE outputg;

cvt_vax_f_to_ieee_single( inputf, 0, outputf );
cvt_vax_g_to_ieee_double( inputg, 0, outputg );

*/


void RPC_ENTRY
float_from_ndr (
    IN OUT PRPC_MESSAGE SourceMessage,
    OUT void * Target
    )

/*++

Routine Description:

    Unmarshall a float from an RPC message buffer into the target
    (*Target).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 4) boundary.
    o   Unmarshalls the float; performs data conversion if necessary
        (only VAX and IEEE Big Endian conversion currently supported).
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled float.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the float to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the float which was just unmarshalled.

    Target - A pointer to the float to unmarshall the data into.
        A (void*) pointer is used, so that the runtime library code
        is not loaded, unless the application code actually uses
        floating point.

Return Values:

    None.

--*/

{
    unsigned char PAPI * F_Input =
        (unsigned char *)SourceMessage->Buffer;

    unsigned char PAPI * F_Output = (unsigned char PAPI *)Target;
    // CVT_IEEE_SINGLE F_Output = (unsigned char PAPI *)Target;

    unsigned long SenderDataRepresentation;

    //
    // Align F_Input to next (0 mod 4) address
    //

    *(unsigned long *)&F_Input += 3;
    *(unsigned long *)&F_Input &= 0XFFFFFFFCL;

    if ( ( (SenderDataRepresentation = SourceMessage->DataRepresentation) &
           NDR_FLOAT_INT_MASK ) == NDR_LITTLE_IEEE_REP )
        //
        // Robust check for little endian IEEE (local data representation)
        //

        {
        *(unsigned long *)Target = *(unsigned long*)F_Input;
        }

    else if ( (SenderDataRepresentation & NDR_FLOAT_REP_MASK) ==
              NDR_VAX_FLOAT )
        {
        cvt_vax_f_to_ieee_single(F_Input, 0, F_Output);
        }

    else if ( (SenderDataRepresentation & NDR_FLOAT_INT_MASK) ==
              NDR_BIG_IEEE_REP )
        //
        // Big endian IEEE sender:
        //

        {
        NdrpLongByteSwap(F_Input, F_Output);
        }

    else
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    //
    // Advance the buffer pointer before returning:
    //

    SourceMessage->Buffer = F_Input + 4;
}

//
// end float_from_ndr
//

void RPC_ENTRY
float_array_from_ndr (
    IN OUT PRPC_MESSAGE SourceMessage,
    IN unsigned long    LowerIndex,
    IN unsigned long    UpperIndex,
    OUT void *          Target
    )

/*++

Routine Description:

    Unmarshall an array of floats from an RPC message buffer into
    the range Target[LowerIndex] .. Target[UpperIndex-1] of the
    target array of floats (Target[]).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 4) boundary,
    o   Unmarshalls MemberCount floats; performs data
        conversion if necessary (Currently VAX format only), and
    o   Advances the buffer pointer to the address immediately
        following the last unmarshalled float.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the first float to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the last float which was just unmarshalled.

    LowerIndex - Lower index into the target array.

    UpperIndex - Upper bound index into the target array.

    Target - A pointer to an array of floats to unmarshall the data into.
        A (void*) pointer is used, so that the runtime library code
        is not loaded, unless the application code actually uses
        floating point.

Return Values:

    None.

--*/

{
    unsigned char PAPI * F_Input =
        (unsigned char PAPI *)SourceMessage->Buffer;

    unsigned char PAPI * F_Output = (unsigned char PAPI *)Target;

    register unsigned int Index;
    unsigned long SenderDataRepresentation;

    //
    // Align F_Input to next (0 mod 4) address
    //

    *(unsigned long *)&F_Input += 3;
    *(unsigned long *)&F_Input &= 0XFFFFFFFCL;

    if ( ( (SenderDataRepresentation = SourceMessage->DataRepresentation) &
           NDR_FLOAT_INT_MASK ) == NDR_LITTLE_IEEE_REP )
        //
        // Robust check for little endian IEEE (local data representation)
        //
        {

        int byteCount = 4*(int)(UpperIndex - LowerIndex);

        RpcpMemoryCopy(
            F_Output,
            F_Input,
            byteCount
            );
        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)(F_Input + byteCount);

        /* Replaced by RpcpMemoryCopy:

        for (Index = LowerIndex; Index < UpperIndex; Index++)
            {
            ((unsigned long *)F_Output)[Index] =
                *(unsigned long *)F_Input;

            F_Input += 4;

            }
        //
        // Advance the buffer pointer before returning:
        //

        SourceMessage->Buffer = F_Input;
        */

        }

    else if ( (SenderDataRepresentation & NDR_FLOAT_REP_MASK) ==
          NDR_VAX_FLOAT )
        {
        F_Output += 4 * LowerIndex;
        for (Index = (int)LowerIndex; Index < UpperIndex; Index++)
            {
            cvt_vax_f_to_ieee_single(F_Input, 0, F_Output);

            F_Input += 4;
            F_Output += 4;
            }
        //
        // Advance the buffer pointer before returning:
        //

        SourceMessage->Buffer = F_Input;
        }

    else if ( (SenderDataRepresentation & NDR_FLOAT_INT_MASK) ==
              NDR_BIG_IEEE_REP )
        //
        // Big endian IEEE sender:
        //

        {
        F_Output += 4 * LowerIndex;
        for (Index = (int)LowerIndex; Index < UpperIndex; Index++)
            {
            NdrpLongByteSwap(F_Input, F_Output);

            F_Input += 4;
            F_Output += 4;
            }
        //
        // Advance the buffer pointer before returning:
        //

        SourceMessage->Buffer = F_Input;
        }

    else
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

}

//
// end float_array_from_ndr
//

void RPC_ENTRY
double_from_ndr (
    IN OUT PRPC_MESSAGE SourceMessage,
    OUT void * Target
    )

/*++

Routine Description:

    Unmarshall a double from an RPC message buffer into the target
    (*Target).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 8) boundary.
    o   Unmarshalls the double; performs data conversion if necessary
        (only VAX conversion currently supported).
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled double.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the double to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the double which was just unmarshalled.

    Target - A pointer to the double to unmarshall the data into.
        A (void*) pointer is used, so that the runtime library code
        is not loaded, unless the application code actually uses
        floating point.

Return Values:

    None.

--*/

{
    unsigned char PAPI * D_Input =
        (unsigned char PAPI *)SourceMessage->Buffer;

    unsigned char PAPI * D_Output = (unsigned char PAPI *)Target;

    unsigned long SenderDataRepresentation;

    //
    // Align D_Input to next (0 mod 8) address
    //

    *(unsigned long *)&D_Input += 7;
    *(unsigned long *)&D_Input &= 0XFFFFFFF8L;

    if ( ( (SenderDataRepresentation = SourceMessage->DataRepresentation) &
           NDR_FLOAT_INT_MASK ) == NDR_LITTLE_IEEE_REP )
        //
        // Robust check for little endian IEEE (local data representation)
        //
        {
        ((unsigned long *)Target)[0] = ((unsigned long*)D_Input)[0];
        ((unsigned long *)Target)[1] = ((unsigned long*)D_Input)[1];
        }

    else if ( (SourceMessage->DataRepresentation & NDR_FLOAT_REP_MASK) ==
          NDR_VAX_FLOAT )
        {
        cvt_vax_g_to_ieee_double(D_Input, 0, D_Output);
        }

    else if ( (SenderDataRepresentation & NDR_FLOAT_INT_MASK) ==
              NDR_BIG_IEEE_REP )
        //
        // Big endian IEEE sender:
        //

        {
        //
        // Swap the low half of D_Input into the high half of D_Output
        //
        NdrpLongByteSwap(
            &((unsigned long*)D_Input)[0],
            &((unsigned long *)Target)[1]
            );

        //
        // Swap the high half of D_Input into the low half of D_Output
        //
        NdrpLongByteSwap(
            &((unsigned long*)D_Input)[1],
            &((unsigned long *)Target)[0]
            );
        }

    else
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    //
    // Advance the buffer pointer before returning:
    //

    SourceMessage->Buffer = D_Input + 8;
}

//
// end double_from_ndr
//

void RPC_ENTRY
double_array_from_ndr (
    IN OUT PRPC_MESSAGE SourceMessage,
    IN unsigned long    LowerIndex,
    IN unsigned long    UpperIndex,
    OUT void *          Target
    )

/*++

Routine Description:

    Unmarshall an array of doubles from an RPC message buffer into
    the range Target[LowerIndex] .. Target[UpperIndex-1] of the
    target array of (Target[]).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 8) boundary,
    o   Unmarshalls MemberCount doubles; performs data
        conversion if necessary (Currently VAX format only), and
    o   Advances the buffer pointer to the address immediately
        following the last unmarshalled double.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the first double to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the last double which was just unmarshalled.

    LowerIndex - Lower index into the target array.

    UpperIndex - Upper bound index into the target array.

    Target - A pointer to an array of doubles to unmarshall the data into.
        A (void*) pointer is used, so that the runtime library code
        is not loaded, unless the application code actually uses
        floating point.

Return Values:

    None.

--*/

{
    unsigned char PAPI * D_Input =
        (unsigned char PAPI *)SourceMessage->Buffer;

    unsigned char PAPI * D_Output = (unsigned char PAPI *)Target;

    register unsigned int Index;
    unsigned long SenderDataRepresentation;

    //
    // Align D_Input to next (0 mod 8) address
    //

    *(unsigned long *)&D_Input += 7;
    *(unsigned long *)&D_Input &= 0XFFFFFFF8L;

    if ( ( (SenderDataRepresentation = SourceMessage->DataRepresentation) &
           NDR_FLOAT_INT_MASK ) == NDR_LITTLE_IEEE_REP )
        //
        // Robust check for little endian IEEE (local data representation)
        //
        {

        int byteCount = 8*(int)(UpperIndex - LowerIndex);

        RpcpMemoryCopy(
            D_Output,
            D_Input,
            byteCount
            );
        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)(D_Input + byteCount);

        /* Replaced by RpcpMemoryCopy:

        for (Index = LowerIndex; Index < UpperIndex; Index++)
            {
            ((unsigned long *)D_Output)[(Index * 2)] =
                *(unsigned long *)D_Input;

            D_Input += 4;

            ((unsigned long *)D_Output)[(Index * 2 + 1)] =
                *((unsigned long *)D_Input) ;

            D_Input += 4;
            }
        //
        // Advance the buffer pointer before returning:
        //

        SourceMessage->Buffer = D_Input;
        */

        }

    else if ( (SourceMessage->DataRepresentation & NDR_FLOAT_REP_MASK) ==
          NDR_VAX_FLOAT )
        {
        for (Index = (int)LowerIndex; Index < UpperIndex; Index++)
            {
            cvt_vax_g_to_ieee_double(D_Input, 0, D_Output);

            D_Input += 8;
            D_Output += 8;
            }
        //
        // Advance the buffer pointer before returning:
        //

        SourceMessage->Buffer = D_Input;
        }

    else if ( (SenderDataRepresentation & NDR_FLOAT_INT_MASK) ==
              NDR_BIG_IEEE_REP )
        //
        // Big endian IEEE sender:
        //

        {
        for (Index = (int)LowerIndex; Index < UpperIndex; Index++)
            {
            NdrpLongByteSwap(
                &((unsigned long PAPI *)D_Input)[0],
                &((unsigned long PAPI *)D_Output)[1]
                );

            NdrpLongByteSwap(
                &((unsigned long PAPI *)D_Input)[1],
                &((unsigned long PAPI *)D_Output)[0]
                );

            D_Input += 8;
            D_Output += 8;
            }
        //
        // Advance the buffer pointer before returning:
        //

        SourceMessage->Buffer = D_Input;
        }

    else
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

}

//
// end double_array_from_ndr
//

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrlib\scontext.cxx ===
/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
           Copyright(c) Microsoft Corp., 1991-2001

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

Description :

Provides RPC server side context handle management

History :

stevez  01-15-91    First bits into the bucket.
Kamen Moutafov [kamenm] Sep 2000    Threw away all of Steve's bits and 
                                    buckets, and rewrote it to fix or pave 
                                    the road for the fixing of the following
                                    design bugs:
                                    - non-serialized context handles are
                                    unusable, and mixing serialized and
                                    non-serialized doesn't work
                                    - stealing context handles
                                    - gradual rundown of context handles
                                    - poor scalability of the context handle
                                    code (high cost of individual context
                                    handles) and contention on the context
                                    list

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <context.hxx>
#include <SContext.hxx>
#include <HndlSvr.hxx>
#include <CtxColl.hxx>
#include <OSFPcket.hxx>

#ifdef SCONTEXT_UNIT_TESTS
#define CODE_COVERAGE_CHECK     ASSERT(_NOT_COVERED_)

inline ServerContextHandle *
AllocateServerContextHandle (
    IN void *CtxGuard
    )
{
    if ((GetRandomLong() % 9999) == 0)
        return NULL;

    return new ServerContextHandle(CtxGuard);
}

#ifdef GENERATE_STATUS_FAILURE
#undef GENERATE_STATUS_FAILURE
#endif // GENERATE_STATUS_FAILURE

#define GENERATE_STATUS_FAILURE(s)  \
    if ((GetRandomLong() % 9999) == 0) \
        s = RPC_S_OUT_OF_MEMORY;

#define GENERATE_ADD_TO_COLLECTION_FAILURE(scall, ctx, status) \
    if ((GetRandomLong() % 9999) == 0) \
        { \
        scall->RemoveFromActiveContextHandles(ctx); \
        status = RPC_S_OUT_OF_MEMORY; \
        } \

#define GENERATE_LOCK_FAILURE(ctx, th, wcptr, status) \
    if ((GetRandomLong() % 9999) == 0) \
        { \
        ctx->Lock.Unlock(wcptr); \
        th->FreeWaiterCache(wcptr); \
        status = RPC_S_OUT_OF_MEMORY; \
        } \

#else
#define CODE_COVERAGE_CHECK

inline ServerContextHandle *
AllocateServerContextHandle (
    IN void *CtxGuard
    )
{
    return new ServerContextHandle(CtxGuard);
}
    
#define GENERATE_STATUS_FAILURE(s)
#define GENERATE_ADD_TO_COLLECTION_FAILURE(scall, ctx, status)
#define GENERATE_LOCK_FAILURE(ctx, th, wcptr, status)

#endif

WIRE_CONTEXT NullContext; // all zeros

// per process variable defining what is the synchronization mode
// for new context handles that don't have NDR level default
unsigned int DontSerializeContext = 0;


inline BOOL
DoesContextHandleNeedExclusiveLock (
    IN unsigned long Flags
    )
/*++

Routine Description:

    Determines if a context handle needs exclusive lock or
    shared lock.

Arguments:

    Flags - the flags given to the runtime by NDR.

Return Value:
    non-zero if the context handle needs exclusive lock. FALSE
    otherwise. There is no failure for this function.

--*/
{
    // make sure exactly one flag is set
    ASSERT((Flags & RPC_CONTEXT_HANDLE_FLAGS) != RPC_CONTEXT_HANDLE_FLAGS);

    switch (Flags & RPC_CONTEXT_HANDLE_FLAGS)
        {
        case RPC_CONTEXT_HANDLE_SERIALIZE:
            // serialize is Exclusive
            return TRUE;

        case RPC_CONTEXT_HANDLE_DONT_SERIALIZE:
            // non-serialized is Shared
            return FALSE;
        }

    return (DontSerializeContext == 0);
}

inline ContextCollection *
GetContextCollection (
    IN RPC_BINDING_HANDLE BindingHandle
    )
/*++

Routine Description:

    Gets the context collection from the call object and
    throws exception if this fails

Arguments:

    BindingHandle - the scall

Return Value:
    The collection. If getting the collection fails, an
    exception is thrown

--*/
{
    RPC_STATUS RpcStatus;
    ContextCollection *CtxCollection;

    RpcStatus = ((SCALL *)BindingHandle)->GetAssociationContextCollection(&CtxCollection);
    if (RpcStatus != RPC_S_OK)
        {
        RpcpRaiseException(RpcStatus);
        }

    return CtxCollection;
}

void
DestroyContextCollection (
    IN ContextCollection *CtxCollection
    )
/*++

Routine Description:

    Destroys all context handles in the collection, regardless
    of guard value. The context handles are rundown before destruction in
    case they aren't used. If they are, the rundown needed flag is set

Arguments:

    CtxCollection - the collection of context handles.

--*/
{
    DestroyContextHandlesForGuard((PVOID)CtxCollection,
        TRUE,   // Rundown context handle
        NULL    // nuke all contexts, regardless of guard value
        );

    delete CtxCollection;
}

void
NDRSRundownContextHandle (
    IN ServerContextHandle *ContextHandle
    )
/*++

Routine Description:
    Runs down a context handle by calling the user's rundown routine

Arguments:
    ContextHandle - the context handle

Notes:
    This routine will only touch the UserRunDown and UserContext members
    of Context. This allows caller to make up ServerContextHandles on the fly
    and just fill in those two members.
--*/

{
    // Only contexts which have a rundown and
    // are valid are cleaned up.
    if ((ContextHandle->UserRunDown != NULL) 
        && ContextHandle->UserContext)
        {
        RpcTryExcept
            {
            (*ContextHandle->UserRunDown)(ContextHandle->UserContext);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
#if DBG
            DbgPrint("Routine %p threw an exception %lu (0x%08lX) - this is illegal\n", ContextHandle->UserRunDown, RpcExceptionCode(), RpcExceptionCode());
            ASSERT(!"The rundown routine is not allowed to throw fatal exceptions")
#endif
            }
        RpcEndExcept
        }
}

void
DestroyContextHandlesForGuard (     
    IN PVOID CtxCollectionPtr,
    IN BOOL RundownContextHandle,
    IN void *CtxGuard OPTIONAL
    ) 
/*++

Routine Description:
    Each context handle in this association with the specified
    guard *and* a zero refcount will be cleaned up in a way 
    determined by RundownContextHandle (see comment for 
    RundownContextHandle below)

Arguments:
    Context - the context for the association
    RundownContextHandle - if non-zero, rundown the context handle
        If zero, just cleanup the runtime part and the app will
        cleanup its part
    CtxGuard - the guard for which to cleanup context handles. If
        NULL, all context handles will be cleaned.

Notes:
    Access to a context handle with lifetime refcount only is implicitly
    synchronized as this function will be called from two places -
    the association rundown, and RpcServerUnregisterIfEx. In the
    former case all connections are gone, and nobody can come
    and start using the context handle. In the second, the interface
    is unregistered, and again nobody can come and start using the
    context handle. Therefore each context handle with lifetime refcount only
    (and for the specified guard) is synrchronized. This is not
    true however for the list itself. In the association rundown
    case some context handles may be used asynchronously for parked
    calls, and we need to synchronize access to the list.
    If this is called from RpcServerUnregisterIfEx, then all context
    handles must have zero refcount as before unregistering the
    interface we must have waited for all calls to complete.
--*/
{
    ContextCollection *CtxCollection = (ContextCollection *)CtxCollectionPtr;
    LIST_ENTRY *NextListEntry;
    ServerContextHandle *CurrentContextHandle;

    // N.B. It may seem like there is a race condition here b/n the two
    // callers of this function - RpcServerUnregisterIfEx & the destructor
    // of the association, as they can be called independently, and start
    // partying on the same list. However, the RpcServerUnregisterIfEx
    // branch will either take the association mutex, or will add a
    // refcount on the association, so that the association can
    // never be destroyed while this function is called by the
    // RpcServerUnregisterIfEx branch, and it is implicitly
    // synchronized as far as destruction is concerned. We still
    // need to synchronize access to the list

    CtxCollection->Lock();

    // for each user created context for this assoication, check
    // whether it fits our criteria for destruction, and if yes,
    // destroy it. This is an abnormal case, so we don't care about
    // performance
    NextListEntry = NULL;
    while ((CurrentContextHandle = CtxCollection->GetNext(&NextListEntry)) != NULL)
        {
        // if we were asked to clean up for a specific context
        // guard, check whether there is a match
        if (CtxGuard && (CtxGuard != CurrentContextHandle->CtxGuard))
            {
            // there is no match - move on to the next
            continue;
            }

        // NextListEntry is valid even after destruction of the current
        // context handle - we don't need to worry about that
        CtxCollection->Remove(CurrentContextHandle);


        ASSERT((CurrentContextHandle->Flags & ServerContextHandle::ContextRemovedFromCollectionMask) == 0);
        CurrentContextHandle->Flags |= ServerContextHandle::ContextRemovedFromCollectionMask
            | ServerContextHandle::ContextNeedsRundown;

        // remove the lifetime reference. If the refcount drops to 0, we can 
        // do the cleanup.
        if (CurrentContextHandle->RemoveReference() == 0)
            {
            if (RundownContextHandle)
                {
                NDRSRundownContextHandle(CurrentContextHandle);
                }

            delete CurrentContextHandle;
            }

        // N.B. Don't touch the CurrentContextHandle below this. We have released
        // our refcount
#if DBG
        // enforce it on checked
        CurrentContextHandle = NULL;
#endif
        }

    CtxCollection->Unlock();
}

void
FinishUsingContextHandle (
    IN SCALL *CallObject,
    IN ServerContextHandle *ContextHandle,
    IN BOOL fUserDeletedContext
    )
/*++

Routine Description:

    Perform functions commonly needed when execution returns
    from the server manager routine - if the context is in
    the list of active context handles, unlock it and remove it.
    Decrease the refcount, and if 0, remove the context from
    the collection, and if rundown as asked for, fire the rundown.

Arguments:

    CallObject - the server-side call object (the scall)
    ContextHandle - the context handle
    fUserDeletedContext - non-zero if the user has deleted the context handle
        (i.e. set UserContext to NULL)
--*/
{
    ServerContextHandle *RemovedContextHandle;
    ContextCollection *CtxCollection = NULL;
    long LocalRefCount;
    RPC_STATUS RpcStatus;
    SWMRWaiter *WaiterCache;
    THREAD *Thread;
    BOOL fRemoveLifeTimeReference;

    RemovedContextHandle = CallObject->RemoveFromActiveContextHandles(ContextHandle);

    if (fUserDeletedContext)
        {
        RpcStatus = CallObject->GetAssociationContextCollection(&CtxCollection);
        // the getting of the collection must succeed here, as we have already
        // created it, and we're simply getting it
        ASSERT(RpcStatus == RPC_S_OK);

        fRemoveLifeTimeReference = FALSE;
        CtxCollection->Lock();
        // if the context is still in the collection, remove it and take 
        // down the lifetime reference
        if ((ContextHandle->Flags & ServerContextHandle::ContextRemovedFromCollectionMask) == 0)
            {
            ContextHandle->Flags |= ServerContextHandle::ContextRemovedFromCollectionMask;
            fRemoveLifeTimeReference = TRUE;
            CtxCollection->Remove(ContextHandle);
            }
        CtxCollection->Unlock();

        // do it outside the lock
        if (fRemoveLifeTimeReference)
            {
            LocalRefCount = ContextHandle->RemoveReference();
            ASSERT(LocalRefCount);
            }
        }

    // if we were able to extract it from the list of active context handles, it must
    // have been active, and thus needs unlocking
    if (RemovedContextHandle)
        {
        WaiterCache = NULL;
        ContextHandle->Lock.Unlock(&WaiterCache);
        Thread = ThreadSelf();
        if (Thread)
            {
            Thread->FreeWaiterCache(&WaiterCache);
            }
        else
            {
            SWMRLock::FreeWaiterCache(&WaiterCache);
            }
        }

    LocalRefCount = ContextHandle->RemoveReference();
    if (LocalRefCount == 0)
        {
        // if we were asked to rundown by the rundown code, do it. 
        if (ContextHandle->Flags & ServerContextHandle::ContextNeedsRundownMask)
            {
            NDRSRundownContextHandle(ContextHandle);
            }

        ASSERT (ContextHandle->Flags & ServerContextHandle::ContextRemovedFromCollectionMask);

        delete ContextHandle;
        }
}

ServerContextHandle *
FindAndAddRefContextHandle (
    IN ContextCollection *CtxCollection,
    IN WIRE_CONTEXT *WireContext,
    IN PVOID CtxGuard,
    OUT BOOL *ContextHandleNewlyCreated
    )
/*++

Routine Description:

    Attempts to find the context handle for the given wire buffer,
    and if found, add a refcount to it, and return it.

Arguments:

    CtxCollection - the context handle collection.
    WireContext - the on-the-wire representation of the context
    CtxGuard - the context guard - if NULL, then any context handle
        matches. If non-NULL, the context handle that matches the
        wire context must have the same context guard in order for it
        to be considered a match.
    ContextHandleNewlyCreated - a pointer to a boolean variable that
        will be set to non-zero if the context handle had the newly 
        created flag set, or to FALSE if it didn't. If the return value
        is NULL, this is undefined.

Return Value:
    The found context handle. NULL if no matching context handle was 
    found.

Notes: 
    The newly created flag is always taken down regardless of other 
    paremeters.

--*/
{
    ServerContextHandle *ContextHandle;
    BOOL LocalContextHandleNewlyCreated = FALSE;

    CtxCollection->Lock();

    ContextHandle = CtxCollection->Find(WireContext);

    // if we have found a context handle, and is from the same interface, or
    // we don't care from what interface it is, get it
    if (ContextHandle
        && (
            (ContextHandle->CtxGuard == CtxGuard)
            ||
            (CtxGuard == NULL)
           )
       )
        {
        ASSERT(ContextHandle->ReferenceCount);
        // the only two flags that can be possibly set here are ContextAllocState and/or
        // ContextNewlyCreated. ContextAllocState *must* be ContextCompletedAlloc.
        // ASSERT that
        ASSERT(ContextHandle->Flags & ServerContextHandle::ContextAllocState);
        ASSERT((ContextHandle->Flags & 
               ~(ServerContextHandle::ContextAllocState | ServerContextHandle::ContextNewlyCreatedMask))
                == 0);
        ContextHandle->AddReference();
        if (ContextHandle->Flags & ServerContextHandle::ContextNewlyCreatedMask)
            {
            LocalContextHandleNewlyCreated = TRUE;
            }
        // take down the ContextNewlyCreated flag. Since we know that the only other
        // flag that can be set at this point is ContextNewlyCreated, a simple assignment
        // is sufficient
        ContextHandle->Flags = ServerContextHandle::ContextCompletedAlloc;
        }
    else
        {
        ContextHandle = NULL;
        }

    CtxCollection->Unlock();

    *ContextHandleNewlyCreated = LocalContextHandleNewlyCreated;
    return ContextHandle;
}

void
NDRSContextHandlePostDispatchProcessing (
    IN SCALL *SCall,
    ServerContextHandle *CtxHandle
    )
/*++

Routine Description:

    Performs post dispatch processing needed for in only context
    handles. If the context handle was NULL on input, just delete
    it. Else, finish using it.

Arguments:

    BindingHandle - the server-side binding handle (the scall)
    CtxHandle - the context handle
--*/
{
    if ((CtxHandle->Flags & ServerContextHandle::ContextAllocState) == ServerContextHandle::ContextPendingAlloc)
        {
        CODE_COVERAGE_CHECK;
        // [in] only context handle that didn't get set
        delete CtxHandle;
        }
    else
        {
        FinishUsingContextHandle(SCall, 
            CtxHandle, 
            FALSE   // fUserDeletedContextHandle
            );
        }
}


void
NDRSContextEmergencyCleanup (
    IN RPC_BINDING_HANDLE BindingHandle,
    IN OUT NDR_SCONTEXT hContext,
    IN NDR_RUNDOWN UserRunDownIn,
    IN PVOID UserContext,
    IN BOOL ManagerRoutineException)
/*++

Routine Description:

    Perform emergency cleanup if the manager routine throws an exception,
    or marshalling fails, or an async call is aborted. In the process,
    if the context handle was actively used, it must finish using it.

Arguments:

    BindingHandle - the server-side binding handle (the scall)
    hContext - the hContext created during unmarshalling.
    UserRunDownIn - if hContext is non-NULL, the user rundown from
        there will be used. This parameter will be used only if
        hContext is NULL.
    UserContext - the user context returned from the user. This will be
        set only in case 9 (see below). For all other cases, it will be 0
    ManagerRoutineException - non-zero if the exception was thrown
        from the manager routine.

Notes:
    Here's the functionality matrix for this function:

NDR will not call runtime in cases 1, 4 and 8

                      User C  Exc Handle         Clea-  Run-   Finish  Further use of 
N   Unm   Mar From:   tx(To:) ept Type    hCtx   nup    down   UsingCH context handle on the client:
--  ----  --- -----   ------- --- ------  ----   -----  -----  ------  -----------------------------
1   N     NA  NA      NA      NA  NA      NA     N      N      N       *As if the call was never made
2a  Y     N   NULL    NA      Y   NA      !NULL  Y      N      N       *As if the call was never made
2b  Y     N   !NULL   NA      Y   NA      !NULL  N      N      Y       *As if the call was never made
4   Y     Y   Any     NULL    N   Any     Any    N      N      N       *New context on the server
5a  Y     Y   NULL    !NULL   N   Any     Marker Y      Y      N       *As if the call was never made
5b  Y     Y   !NULL   !NULL   N   Any     Marker N      N      N       *To: value on the server
6a  Y     N   NULL    NULL    N   !ret    !NULL  Y      N      N       *As if the call was never made
6b  Y     N   !NULL   NULL    N   !ret    !NULL  Y      N      Y       *Invalid context from the server
7a  Y     N   NULL    !NULL   N   !ret    !NULL  Y      Y      N       *As if the call was never made
7b  Y     N   !NULL   !NULL   N   !ret    !NULL  N      N      Y       To: value on the server
8   Y     N   NA      NULL    N   ret     NULL   N      N      N       *NA (i.e. no retval)
9   Y     N   NA      !NULL   N   ret     NULL   N      Y      N       *NA (i.e. no retval)

    N.B. This routine throws exceptions on failure. Only datagram context handles have failure
    paths (aside from claiming critical section failures)
--*/
{
    ServerContextHandle *ContextHandle = (ServerContextHandle *)hContext;
    ContextCollection *CtxCollection;
    SCALL *SCall = (SCALL *)BindingHandle;
    BOOL ContextHandleNewlyCreated;
    DictionaryCursor cursor;
    PVOID Buffer;

    ASSERT(SCall->Type(SCALL_TYPE));

    LogEvent(SU_EXCEPT, EV_DELETE, ContextHandle, UserContext, ManagerRoutineException, 1, 0);

    // N.B. The following code doesn't make sense unless you have gone
    // through the notes in the comments. Please, read the notes before you
    // read this code
    if (ManagerRoutineException)
        {
        ASSERT(ContextHandle != NULL);

        // Cases 2a, 2b
        // Detect case 2a and cleanup runtime stuff for it
        if ((ContextHandle->Flags & ServerContextHandle::ContextAllocState) == ServerContextHandle::ContextPendingAlloc)
            {
            // case 2a started with NULL context handle - no need to call
            // FinishUsingContextHandle
            delete ContextHandle;
            }
        else
            {
            // case 2b - we started with a non-NULL context handle - we need to finish
            // using it
            FinishUsingContextHandle(SCall,
                ContextHandle,
                FALSE       // fUserDeletedContext
                );
            }
        }
    else if (ContextHandle == NULL)
        {
        ServerContextHandle TempItem(NULL);

        // Case 9
        // This must be a return value context handle, which the user has set to !NULL,
        // but we encountered marshalling problems before marshalling it. In this
        // case, simply rundown the user context.

        CODE_COVERAGE_CHECK;
        ASSERT(UserRunDownIn);
        ASSERT(UserContext);

        // create a temp context we can use for rundowns
        TempItem.UserRunDown = UserRunDownIn;
        TempItem.UserContext = UserContext;

        NDRSRundownContextHandle(&TempItem);
        }
    else if (ContextHandle == CONTEXT_HANDLE_AFTER_MARSHAL_MARKER)
        {
        // Cases 5a, 5b.
        // The context handle has been marshalled. Since we have released
        // all reference to the context handle, we cannot touch it. We need
        // to go back and search for the context handle again. It may have
        // been deleted either through a rundown, or by an attacker guessing
        // the context handle. Either way we want to handle it gracefully
        // Once we find the context handle (and get a lock on it), we need
        // to check if it has been used in the meantime, and if not, we
        // can proceed with the cleanup. If yes, just ignore it.

        CtxCollection = GetContextCollection(BindingHandle);
        // this must succeed as we have already obtained the collection once
        // during umarshalling
        ASSERT(CtxCollection);

        // in case 5b, we won't find anything, since we don't put buffers in
        // the collection. In this case, the loop will exit, and we'll be fine
        SCall->ActiveContextHandles.Reset(cursor);
        while ((Buffer = SCall->ActiveContextHandles.Next(cursor)) != 0)
            {
            // if this is not a buffer
            if (((ULONG_PTR)Buffer & SCALL::DictionaryEntryIsBuffer) == 0)
                {
                CODE_COVERAGE_CHECK;
                continue;
                }

            Buffer = (PVOID)((ULONG_PTR)Buffer & (~(SCALL::DictionaryEntryIsBuffer)));

            ContextHandle = FindAndAddRefContextHandle(CtxCollection,
                (WIRE_CONTEXT *)Buffer,
                NULL,    // CtxGuard
                &ContextHandleNewlyCreated
                );

            if (ContextHandle)
                {
                if (ContextHandleNewlyCreated)
                    {
                    // Case 5a
                    // this context handle was newly created - it cannot be used
                    // by anybody, and it cannot be in the active calls collection
                    // Therefore, it is safe to set the flag without holding the
                    // lock and to call FinishUsingContextHandle, which will decrement
                    // the ref count and will rundown & cleanup the context handle
                    ContextHandle->Flags |= ServerContextHandle::ContextNeedsRundown;
                    FinishUsingContextHandle(SCall,
                        ContextHandle,
                        TRUE    // fUserDeletedContext
                        );
                    }
                else
                    {
                    CODE_COVERAGE_CHECK;
                    // somebody managed to use the context handle - just finish off using it
                    FinishUsingContextHandle(SCall,
                        ContextHandle,
                        FALSE       // fUserDeletedContext
                        );
                    }
                }
            }
        }
    else if ((ContextHandle->Flags & ServerContextHandle::ContextAllocState) == ServerContextHandle::ContextPendingAlloc)
        {
        // Cases 6a, 7a

        UserContext = ContextHandle->UserContext;

        if (UserContext)
            {
            // if we're in case 7a
            NDRSRundownContextHandle(ContextHandle);
            }

        // cases 6a, 7a
        delete ContextHandle;
        }
    else if (UserContext == NULL)
        {
        // Case 6b
        // this is the case where we have transition from !NULL to NULL
        // and marshalling hasn't passed yet
        ASSERT((ContextHandle->Flags & ServerContextHandle::ContextAllocState) == ServerContextHandle::ContextCompletedAlloc);

        FinishUsingContextHandle(SCall,
            ContextHandle,
            TRUE       // fUserDeletedContext
            );
        }
    else
        {
        UserContext = ContextHandle->UserContext;

        // Cases 7b
        ASSERT(UserContext != NULL);
        ASSERT((ContextHandle->Flags & ServerContextHandle::ContextAllocState) == ServerContextHandle::ContextCompletedAlloc);

        // the context handle was actively used - finish using it
        FinishUsingContextHandle(SCall,
            ContextHandle,
            FALSE       // fUserDeletedContext
            );
        }
}


void
ByteSwapWireContext(
    IN WIRE_CONTEXT *WireContext,
    IN unsigned char *DataRepresentation
    )
/*++

Routine Description:

    If necessary, the wire context will be byte swapped in place.

Arguments:

    WireContext - Supplies the wire context be byte swapped and returns the
        resulting byte swapped context.

    DataRepresentation - Supplies the data representation of the supplied wire
        context.

Notes:
    The wire context is guaranteed only 4 byte alignment.
--*/
{
    if (   ( DataConvertEndian(DataRepresentation) != 0 )
        && ( WireContext != 0 ) )
        {
        WireContext->ContextType = RpcpByteSwapLong(WireContext->ContextType);
        ByteSwapUuid((class RPC_UUID *)&WireContext->ContextUuid);
        }
}


NDR_SCONTEXT RPC_ENTRY
NDRSContextUnmarshall (     
    IN void *pBuff,         
    IN unsigned long DataRepresentation 
    )
{
    return(NDRSContextUnmarshall2(I_RpcGetCurrentCallHandle(),
                                  pBuff,
                                  DataRepresentation,
                                  RPC_CONTEXT_HANDLE_DEFAULT_GUARD, 
                                  RPC_CONTEXT_HANDLE_DEFAULT_FLAGS));
}

NDR_SCONTEXT RPC_ENTRY
NDRSContextUnmarshallEx(
    IN RPC_BINDING_HANDLE BindingHandle,
    IN void *pBuff,         
    IN unsigned long DataRepresentation
    )
{
    return(NDRSContextUnmarshall2(BindingHandle,
                                  pBuff,
                                  DataRepresentation,
                                  RPC_CONTEXT_HANDLE_DEFAULT_GUARD, 
                                  RPC_CONTEXT_HANDLE_DEFAULT_FLAGS));
}

// make sure the public structure and our private ones agree on where is the user context
C_ASSERT(FIELD_OFFSET(ServerContextHandle, UserContext) == ((LONG)(LONG_PTR)&(((NDR_SCONTEXT)0)->userContext)));



NDR_SCONTEXT RPC_ENTRY
NDRSContextUnmarshall2 (
    IN RPC_BINDING_HANDLE BindingHandle,
    IN void *pBuff,         
    IN unsigned long DataRepresentation,
    IN void *CtxGuard, 
    IN unsigned long Flags
    ) 
/*++

Routine Description:
    Translate a NDR context to a handle
    The stub calls this routine to lookup a NDR wire format context into
    a context handle that can be used with the other context functions
    provided for the stubs use.

Arguments:

    BindingHandle - the server side binding handle (scall)
    pBuff - pointer to the on-the-wire represenation of the context handle
    DataRepresentation - specifies the NDR data representation
    CtxGuard - non-NULL and interface unique id for strict context handles. NULL
        for non-strict context handles
    Flags - the flags for this operation.

Return Value:
    A handle usable by NDR. Failures are reported by throwing exceptions.
--*/

{
    ServerContextHandle *ContextHandle;
    ServerContextHandle *TempContextHandle;
    ContextCollection *CtxCollection;
    WIRE_CONTEXT *WireContext;
    THREAD * Thread;
    RPC_STATUS RpcStatus;
    BOOL fFound;
    SCALL *SCall;
    SWMRWaiter *WaiterCache;
    BOOL Ignore;

    ByteSwapWireContext((WIRE_CONTEXT *) pBuff,
                        (unsigned char *) &DataRepresentation);

    // even if we don't put it in the collection, make sure that
    // we call this function to force creating the collection
    // if it isn't there. If it fails, it will throw an exception
    CtxCollection = GetContextCollection(BindingHandle);

    WireContext = (WIRE_CONTEXT *)pBuff;
    if (!WireContext || WireContext->IsNullContext())
        {
        // Allocate a new context
        ContextHandle = AllocateServerContextHandle(CtxGuard);
        if (ContextHandle == NULL)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                RPC_S_OUT_OF_MEMORY,
                EEInfoDLNDRSContextUnmarshall2_30,
                sizeof(ServerContextHandle));

            RpcRaiseException(RPC_S_OUT_OF_MEMORY);
            }

#if DBG
        if (CtxGuard == RPC_CONTEXT_HANDLE_DEFAULT_GUARD)
            RpcpInterfaceForCallDoesNotUseStrict(BindingHandle);
#endif

        // we don't put it in the active context handle list, because
        // non of the APIs work on newly created context handles.
        // We don't put it in the context collection either, allowing
        // us to put it on unmarshalling only if it is non-zero.
        }
    else
        {        
        SCall = (SCALL *)BindingHandle;

        // Currently, passing duplicate context handles to a method is not permited.
        // Here we enforce this rule by verifying that the wire context we are unmarshalling
        // isn't already in our list of unmarshaled context handles.  If it is, we return
        // CONTEXT_MISMATCH.
        if (SCall->ActiveContextHandles.Size()){
            DictionaryCursor cursor;
            ServerContextHandle *CtxHandle = NULL;
            SCall->ActiveContextHandles.Reset(cursor);
            while ((CtxHandle = SCall->ActiveContextHandles.Next(cursor)) != 0){
                if (RpcpMemoryCompare(WireContext, &(CtxHandle->WireContext), sizeof(WIRE_CONTEXT)) == 0){
                    RpcpErrorAddRecord(EEInfoGCRuntime, 
                        RPC_X_SS_CONTEXT_MISMATCH,
                        EEInfoDLNDRSContextUnmarshall2_60,
                        WireContext->GetDebugULongLong1(),
                        WireContext->GetDebugULongLong2()
                        );
                    RpcpRaiseException(RPC_X_SS_CONTEXT_MISMATCH);
                    }
                }
            }
        
        ContextHandle = FindAndAddRefContextHandle(CtxCollection,
            WireContext,
            CtxGuard,
            &Ignore     // ContextHandleNewlyCreated
            );

        if (!ContextHandle)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                RPC_X_SS_CONTEXT_MISMATCH,
                EEInfoDLNDRSContextUnmarshall2_10,
                WireContext->GetDebugULongLong1(),
                WireContext->GetDebugULongLong2()
                );
            RpcpRaiseException(RPC_X_SS_CONTEXT_MISMATCH);
            }

        RpcStatus = SCall->AddToActiveContextHandles(ContextHandle);
        GENERATE_ADD_TO_COLLECTION_FAILURE(SCall, ContextHandle, RpcStatus)
        if (RpcStatus != RPC_S_OK)
            {
            // remove the refcount and kill if it is the last one
            // Since this is not in the collection, no unlock
            // attempt will be made
            FinishUsingContextHandle(SCall, 
                ContextHandle, 
                FALSE       // fUserDeletedContext
                );

            RpcpErrorAddRecord(EEInfoGCRuntime, 
                RpcStatus,
                EEInfoDLNDRSContextUnmarshall2_50);

            RpcpRaiseException(RpcStatus);
            }

        Thread = RpcpGetThreadPointer();
        ASSERT(Thread);

        // here it must have been found. Find out what mode do we want this locked
        // in.
        if (DoesContextHandleNeedExclusiveLock(Flags))
            {
            Thread->GetWaiterCache(&WaiterCache, SCall, swmrwtWriter);
            RpcStatus = ContextHandle->Lock.LockExclusive(&WaiterCache);
            }
        else
            {
            Thread->GetWaiterCache(&WaiterCache, SCall, swmrwtReader);
            RpcStatus = ContextHandle->Lock.LockShared(&WaiterCache);
            }

        // in rare cases the lock operation may yield a cached waiter.
        // Make sure we handle it
        Thread->FreeWaiterCache(&WaiterCache);

        GENERATE_LOCK_FAILURE(ContextHandle, Thread, &WaiterCache, RpcStatus)

        if (RpcStatus != RPC_S_OK)
            {
            // first, we need to remove the context handle from the active calls
            // collection. This is necessary so that when we finish using it, it
            // doesn't attempt to unlock the handle (which it will attempt if the
            // handle is in the active contexts collection).
            TempContextHandle = SCall->RemoveFromActiveContextHandles(ContextHandle);
            ASSERT(TempContextHandle);

            FinishUsingContextHandle(SCall, 
                ContextHandle, 
                FALSE       // fUserDeletedContext
                );

            RpcpErrorAddRecord(EEInfoGCRuntime, 
                RpcStatus,
                EEInfoDLNDRSContextUnmarshall2_40);

            RpcpRaiseException(RpcStatus);
            }

        // did we pick a deleted context? Since we have a refcount, it can't go away
        // but it may very well have been marked deleted while we were waiting to get a lock
        // on the context handle. Check, and bail out if this is the case. This can
        // happen either if we encountered a rundown while waiting for the context
        // handle lock, or if an exclusive user before us deleted the context handle
        if (ContextHandle->Flags & ServerContextHandle::ContextRemovedFromCollection)
            {
            CODE_COVERAGE_CHECK;
            // since the context handle is in the active contexts collection,
            // this code will unlock it
            FinishUsingContextHandle(SCall, 
                ContextHandle, 
                FALSE       // fUserDeletedContext
                );

            RpcpErrorAddRecord(EEInfoGCRuntime, 
                RPC_X_SS_CONTEXT_MISMATCH,
                EEInfoDLNDRSContextUnmarshall2_20,
                WireContext->GetDebugULongLong1(),
                WireContext->GetDebugULongLong2()
                );
            RpcpRaiseException(RPC_X_SS_CONTEXT_MISMATCH);
            }
        }

    return ((NDR_SCONTEXT) ContextHandle);
}


void RPC_ENTRY
NDRSContextMarshallEx (      
    IN RPC_BINDING_HANDLE BindingHandle,
    IN OUT NDR_SCONTEXT hContext,   
    OUT void *pBuffer,   
    IN NDR_RUNDOWN userRunDownIn    
    )
{
    NDRSContextMarshall2(BindingHandle,
                         hContext,
                         pBuffer,
                         userRunDownIn,
                         RPC_CONTEXT_HANDLE_DEFAULT_GUARD, 
                         RPC_CONTEXT_HANDLE_DEFAULT_FLAGS);
}

void RPC_ENTRY
NDRSContextMarshall (      
    IN OUT NDR_SCONTEXT hContext,   
    OUT void *pBuff,        
    IN NDR_RUNDOWN userRunDownIn    
    )
{
    NDRSContextMarshall2(I_RpcGetCurrentCallHandle(),
                         hContext,
                         pBuff,
                         userRunDownIn,
                         RPC_CONTEXT_HANDLE_DEFAULT_GUARD, 
                         RPC_CONTEXT_HANDLE_DEFAULT_FLAGS);
}


void RPC_ENTRY
NDRSContextMarshall2(
    IN RPC_BINDING_HANDLE BindingHandle,
    IN OUT NDR_SCONTEXT hContext,   
    OUT void *pBuff,        
    IN NDR_RUNDOWN UserRunDownIn,
    IN void *CtxGuard, 
    IN unsigned long
    )
/*++

Routine Description:
    Marshall the context handle. If set to NULL, it will be destroyed.

Arguments:

    BindingHandle - the server side binding handle (the scall)
    hContext - the NDR handle of the context handle
    pBuff - buffer to marshell to
    UserRunDownIn - user function to be called when the rundown occurs
    CtxGuard - the magic id used to differentiate contexts created on
        different interfaces

--*/
{
    RPC_STATUS RpcStatus;
    ServerContextHandle *ContextHandle = (ServerContextHandle *)hContext;
    ContextCollection *CtxCollection;
    SCALL *SCall;
    BOOL fUserDeletedContextHandle;
    WIRE_CONTEXT *WireContext;

    SCall = (SCALL *)BindingHandle;

    // 0 for the flags is ContextPendingAlloc. If this is a new context, it 
    // cannot have ContextNeedsRundown, because it's not in the collection. 
    // It cannot have ContextRemovedFromCollection for the same reason. 
    // Therefore, testing for 0 is sufficient to determine if this is a new 
    // context
    if (ContextHandle->Flags == 0)
        {
        if (ContextHandle->UserContext == NULL)
            {
            // NULL to NULL - just delete the context handle
            ContextHandle->WireContext.CopyToBuffer(pBuff);
            delete ContextHandle;
            }
        else
            {
            // the context handle was just created - initialize the members that 
            // weren't initialized before and insert it in the list
            ContextHandle->Flags = ServerContextHandle::ContextNewlyCreated
                | ServerContextHandle::ContextCompletedAlloc;
            // UserContext was already set by NDR
            ContextHandle->UserRunDown = UserRunDownIn;
            ASSERT(CtxGuard == ContextHandle->CtxGuard);

            // create the UUID
            RpcStatus = UuidCreate((UUID *)&ContextHandle->WireContext.ContextUuid);

            GENERATE_STATUS_FAILURE(RpcStatus);

            if (RpcStatus == RPC_S_OK)
                {
                RpcStatus = SCall->AddToActiveContextHandles(
                    (ServerContextHandle *) ((ULONG_PTR) pBuff | SCALL::DictionaryEntryIsBuffer));
                GENERATE_ADD_TO_COLLECTION_FAILURE(SCall, (ServerContextHandle *)((ULONG_PTR) pBuff & SCALL::DictionaryEntryIsBuffer), RpcStatus);
                }

            if ((RpcStatus != RPC_S_OK)
                && (RpcStatus != RPC_S_UUID_LOCAL_ONLY))
                {
                // run down the context handle
                NDRSRundownContextHandle(ContextHandle);
                // in a sense, marshalling failed
                delete ContextHandle;

                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RpcStatus,
                    EEInfoDLNDRSContextMarshall2_10);
                RpcpRaiseException(RpcStatus);
                }

            ContextHandle->WireContext.CopyToBuffer(pBuff);

            CtxCollection = GetContextCollection(BindingHandle);
            // the context collection must have been created during
            // marshalling. This cannot fail here
            ASSERT(CtxCollection);
            CtxCollection->Lock();
            CtxCollection->Add(ContextHandle);
            CtxCollection->Unlock();
            }

        return;
        }

    fUserDeletedContextHandle = (ContextHandle->UserContext == NULL);

    if (fUserDeletedContextHandle)
        {
        WireContext = (WIRE_CONTEXT *)pBuff;
        WireContext->SetToNull();
        }
    else
        {
        ContextHandle->WireContext.CopyToBuffer(pBuff);
        }

    FinishUsingContextHandle(SCall, ContextHandle, fUserDeletedContextHandle);
}


void RPC_ENTRY
I_RpcSsDontSerializeContext (
    void
    )
/*++

Routine Description:

    By default, context handles are serialized at the server.  One customer
    who doesn't like that is the spooler. They make use of a single context 
    handle by two threads at a time.  This API is used to turn off serializing 
    access to context handles for the process. It has been superseded by
    shared/exclusive access to the context, and must not be used anymore.

--*/
{
    DontSerializeContext = 1;
}

ServerContextHandle *
NDRSConvertUserContextToContextHandle (
    IN SCALL *SCall,
    IN PVOID UserContext
    )
/*++

Routine Description:

    Finds the context handle corresponding to the specified
        UserContext and returns it.

Arguments:

    SCall - the server side call object (the SCall)

    UserContext - the user context as given to the user by NDR. For
        in/out parameters, this will be a pointer to the UserContext
        field in the ServerContextHandle. For in parameters, this will
        be a value equal to the UserContext field in the 
        ServerContextHandle. We don't know what type of context handle
        is this, so we have to search both, giving precedence to in/out
        as they are more precise.

Return Value:

    NULL if the UserContext couldn't be matched to any context handle.
        The context handle pointer otherwise.

--*/
{
    DictionaryCursor cursor;
    ServerContextHandle *CurrentCtxHandle = NULL;
    ServerContextHandle *UserContextMatchingCtxHandle = NULL;

    if (SCall->InvalidHandle(SCALL_TYPE))
        return (NULL);

    SCall->ActiveContextHandles.Reset(cursor);
    while ((CurrentCtxHandle = SCall->ActiveContextHandles.Next(cursor)) != 0)
        {
        // make sure this is not a buffer pointer for some reason
        ASSERT (((ULONG_PTR)CurrentCtxHandle & SCALL::DictionaryEntryIsBuffer) == 0);
        
        if (&CurrentCtxHandle->UserContext == UserContext)
            {
            return CurrentCtxHandle;
            }

        if (CurrentCtxHandle->UserContext == UserContext)
            {
            UserContextMatchingCtxHandle = CurrentCtxHandle;
            }
        }

    // if we didn't find anything, this will be NULL and this is what we will
    // return
    return UserContextMatchingCtxHandle;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsContextLockExclusive (
    IN RPC_BINDING_HANDLE ServerBindingHandle,
    IN PVOID UserContext
    )
/*++

Routine Description:

    Lock the specified context for exclusive use.

Arguments:

    ServerBindingHandle - the server side binding handle (the SCall)

    UserContext - the user context as given to the user by NDR. For
        in/out parameters, this will be a pointer to the UserContext
        field in the ServerContextHandle. For in parameters, this will
        be a value equal to the UserContext field in the 
        ServerContextHandle. We don't know what type of context handle
        is this, so we have to search both, giving precedence to in/out
        as they are more precise.

Return Value:

    RPC_S_OK, ERROR_INVALID_HANDLE if the ServerBindingHandle or the
    UserContext are invalid, a Win32 error if the locking failed,
    or ERROR_MORE_WRITES if two readers attempted to upgrade to Exclusive
    and one was evicted from its read lock (see the comment in 
    SWMR::ConvertToExclusive)

--*/
{
    ServerContextHandle *ContextHandle;
    SCALL *SCall = (SCALL *)ServerBindingHandle;
    SWMRWaiter *WaiterCache;
    THREAD *ThisThread;
    RPC_STATUS RpcStatus;

    if (SCall == NULL)
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        // if there is still no context, it will be handled by
        // NDRSConvertUserContextToContextHandle below.
        }

    ContextHandle = NDRSConvertUserContextToContextHandle(SCall,
        UserContext);

    if (ContextHandle == NULL)
        return ERROR_INVALID_HANDLE;

    // try to get a waiter for the locking
    ThisThread = ThreadSelf();
    if (ThisThread == NULL)
        return RPC_S_OUT_OF_MEMORY;

    WaiterCache = NULL;

    // we cannot allocate a waiter from the thread,
    // because by definition we already have a lock, and
    // the waiter for this lock may come from the thread.
    // Since the thread tends to overwrite the previous
    // waiter on recursive allocation, we don't want to
    // do that.

    RpcStatus = ContextHandle->Lock.ConvertToExclusive(&WaiterCache);

    // if a waiter was produced, store it. Conversion
    // operations can produce spurious waiters because of
    // race conditions
    ThisThread->FreeWaiterCache(&WaiterCache);

    return RpcStatus;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsContextLockShared (
    IN RPC_BINDING_HANDLE ServerBindingHandle,
    IN PVOID UserContext
    )
/*++

Routine Description:

    Lock the specified context for shared use.

Arguments:

    ServerBindingHandle - the server side binding handle (the SCall)

    UserContext - the user context as given to the user by NDR. For
        in/out parameters, this will be a pointer to the UserContext
        field in the ServerContextHandle. For in parameters, this will
        be a value equal to the UserContext field in the 
        ServerContextHandle. We don't know what type of context handle
        is this, so we have to search both, giving precedence to in/out
        as they are more precise.

Return Value:

    RPC_S_OK, ERROR_INVALID_HANDLE if the ServerBindingHandle or the
    UserContext are invalid, a Win32 error if the locking failed

--*/
{
    ServerContextHandle *ContextHandle;
    SCALL *SCall = (SCALL *)ServerBindingHandle;
    SWMRWaiter *WaiterCache;
    THREAD *ThisThread;
    RPC_STATUS RpcStatus;

    if (SCall == NULL)
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        // if there is still no context, it will be handled by
        // NDRSConvertUserContextToContextHandle below.
        }

    ContextHandle = NDRSConvertUserContextToContextHandle(SCall,
        UserContext);

    if (ContextHandle == NULL)
        return ERROR_INVALID_HANDLE;

    // try to get a waiter for the locking
    ThisThread = ThreadSelf();
    if (ThisThread == NULL)
        return RPC_S_OUT_OF_MEMORY;

    WaiterCache = NULL;
    // we cannot allocate a waiter from the thread,
    // because by definition we already have a lock, and
    // the waiter for this lock may come from the thread.
    // Since the thread tends to overwrite the previous
    // waiter on recursive allocation, we don't want to
    // do that.

    RpcStatus = ContextHandle->Lock.ConvertToShared(&WaiterCache, 
        TRUE    // fSyncCacheUsed
        );

    // if a waiter was produced, store it. Conversion
    // operations can produce spurious waiters because of
    // race conditions
    ThisThread->FreeWaiterCache(&WaiterCache);

    return RpcStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrlib\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1989


Revision History:

!ENDIF

TARGETNAME=RpcNdrp
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..;..\..\runtime\mtrt;..\..\runtime\rtifs\$(O)

C_DEFINES=$(RPCENV) -D_RPCRT4_

MSC_WARNING_LEVEL=/WX /W3

SOURCES=             \
        ..\ccontext.cxx \
        ..\CtxColl.cxx  \
        ..\scontext.cxx

# Need to use this method since build will not 
# allow ifdefs for sources

i386_SOURCES=             \
             ..\charconv.cxx \
             ..\dataconv.cxx \
             ..\intconv.cxx  \
             ..\floatc.cxx   \
             ..\help.c

ALPHA_SOURCES=$(i386_SOURCES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndrlib\daytona\makefile.inc ===
# Copyright (c) 1993-1999 Microsoft Corporation

!ifndef LIB386
LIB386=\rpc\import\c700\bin\lib
!endif

..\linklist.cxx : ..\..\runtime\mtrt\linklist.cxx
    copy ..\..\runtime\mtrt\linklist.cxx ..

..\..\runtime\lib\i386\ndromf.lib: $(386_OBJECTS)
	@-del $*.lib 2> nul
	$(LIB386) $*.lib $(?: =+);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\rpccfg\rpccfg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       rpccfg.cxx
//
//--------------------------------------------------------------------------

#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include<stdio.h>
#include<string.h>
#include<memory.h>
#include<malloc.h>
#include<stdlib.h>
#include <windows.h>
#include <winsock2.h>
extern "C" {
#include <iphlpapi.h>
};

#include <selbinding.hxx>

#define IF_INFO_DESC_LENGTH 256
#define MAX_REG_BUFFER 1024
#define MAX_SUBNETS 256;

#define RPC_PORT_SETTINGS "Software\\Microsoft\\Rpc\\Internet"

typedef struct _IF_INFO
{
    struct _IF_INFO *Next;
    DWORD   dwIndex;
    CHAR    szDesc[IF_INFO_DESC_LENGTH];
}IF_INFO,*PIF_INFO;

typedef struct _SUBNET_INFO
{
    struct _SUBNET_INFO* Next;
    DWORD       dwSubnet;
    DWORD       dwIfCount;
    PIF_INFO    pIfList;
}SUBNET_INFO,*PSUBNET_INFO;


#define FREE(x) if(x!=NULL){free(x);x=NULL;}

VOID
DoHttpCommandA(
    IN CHAR Command,
    IN LPSTR Arguments[],
    IN ULONG ArgCount
    );
    
void
FreeSubnetList(
    IN OUT PSUBNET_INFO *ppSubnetList
    )
/*++
 
Routine Description:

    Walks the linked list of adapters (and also each linked list of interfaces
    within each adapter) and frees the memory.  The input pointer is set too NULL
    on return.

Arguments:
    
    ppSubnetList - Pointer to the head pointer of the list which is to be deleted.
                   This will be set to NULL when the function returns.

Return Value:
    
--*/
{   
    if(*ppSubnetList==NULL)
        {
        return;
        }
    PSUBNET_INFO pCurr,pNext;
    for(pCurr=*ppSubnetList; pCurr!=NULL; pCurr=pNext)
        {
            pNext=pCurr->Next;

            PIF_INFO pIfCurr,pIfNext;
            for(pIfCurr=pCurr->pIfList; pIfCurr!=NULL; pIfCurr=pIfNext)
                {
                pIfNext = pIfCurr->Next;
                free(pIfCurr);
                }
            free(pCurr);
        }
    ppSubnetList = NULL;
}

BOOL
GetSubnetList(
    OUT PSUBNET_INFO *ppSubnetList,
    OUT PULONG pSubnetCount
    )
/*++
 
Routine Description:

    Creates a linked list of subnets for every individual subnet on the
    machine.  Each subnet contains a linked list of interfaces, one for each
    interface listening on that subnet.  The subnet count is also filled in.

Arguments:

    ppSubnetList - This is filled in with a pointer to the head of the subnet
                   linked list.

    pSubnetCount - The number of subnets, which means the number of nodes.  Note that
                   the number of Interfaces does not necissarily equal the number of subnets.

Return Value:
    
--*/
{   
    // Get the IP Address table
    PMIB_IPADDRTABLE pMib;
    MIB_IFROW IfRow;
    DWORD Size = 20*sizeof(MIB_IPADDRROW)+sizeof(DWORD);
    unsigned int i;
    DWORD Status,dwSubnet;
    PSUBNET_INFO pTmpSubnetInfo;
    PIF_INFO pTmpIfInfo;
    for (i = 0; i < 2; i++)
        {
        pMib = (PMIB_IPADDRTABLE) malloc(Size);
        if (pMib == 0)
            {
            goto cleanup;
            }

        memset(pMib, 0, Size);

        Status = GetIpAddrTable(pMib, &Size, TRUE);
        if (Status == 0)
            {
            break;
            }

        free(pMib);
        }

    *ppSubnetList = NULL;
    *pSubnetCount = 0;
    // Create the subnets, link them together
    for(i=0; i < pMib->dwNumEntries; i++)
        {
        (*pSubnetCount)++;
        //Allocate a new subnet, or link to the previous one
        if(*ppSubnetList==NULL)
            {
            *ppSubnetList = (PSUBNET_INFO) malloc(sizeof(SUBNET_INFO));
            pTmpSubnetInfo = *ppSubnetList;
            if(!pTmpSubnetInfo)
                {
                goto cleanup;
                }
            }
        else 
            {
            pTmpSubnetInfo->Next = (PSUBNET_INFO) malloc(sizeof(SUBNET_INFO));
            if(!pTmpSubnetInfo)
                {
                goto cleanup;
                }
            pTmpSubnetInfo = pTmpSubnetInfo->Next;
            }
        //Fill in the subnet
        memset(pTmpSubnetInfo,0,sizeof(SUBNET_INFO));

        pTmpSubnetInfo->dwSubnet = pMib->table[i].dwAddr & pMib->table[i].dwMask;
        pTmpSubnetInfo->dwIfCount = 1;
        pTmpSubnetInfo->pIfList = (PIF_INFO)malloc(sizeof(IF_INFO));

        pTmpIfInfo = pTmpSubnetInfo->pIfList;
        if(!pTmpIfInfo)
            {
            goto cleanup;
            }
        memset(pTmpIfInfo,0,sizeof(IF_INFO));
        //Fill in the new interface
        pTmpIfInfo->dwIndex = pMib->table[i].dwIndex;
        //Get the description 
        memset(&IfRow,0,sizeof(MIB_IFROW));
        IfRow.dwIndex = pMib->table[i].dwIndex;
        GetIfEntry(&IfRow);
        strcpy(pTmpIfInfo->szDesc,(char*)IfRow.bDescr);

        //Add any additional interfaces to the subnet
        for(i=i+1; i < pMib->dwNumEntries; i++)
            {
                dwSubnet = pMib->table[i].dwAddr & pMib->table[i].dwMask;
                if(pTmpSubnetInfo->dwSubnet != dwSubnet)
                    {
                    break;
                    }
                //Increment the interface count for this subnet
                pTmpSubnetInfo->dwIfCount++;
                
                //Create a new interface
                pTmpIfInfo->Next = (PIF_INFO) malloc(sizeof(IF_INFO));
                pTmpIfInfo = pTmpIfInfo->Next;
                if(!pTmpIfInfo)
                    {
                    goto cleanup;
                    }
                memset(pTmpIfInfo,0,sizeof(IF_INFO));

                //Fill in the new interface
                pTmpIfInfo->dwIndex = pMib->table[i].dwIndex;
 
                //Get the description 
                memset(&IfRow,0,sizeof(MIB_IFROW));
                IfRow.dwIndex = pMib->table[i].dwIndex;
                GetIfEntry(&IfRow);
                strcpy(pTmpIfInfo->szDesc,(char*)IfRow.bDescr);
            }
        i=i-1;

    }
    
    FREE(pMib);
    return TRUE;

cleanup:
    FREE(pMib);
    FreeSubnetList(ppSubnetList);
    return FALSE;
}

void
DisplaySubnet(
    IN SUBNET_INFO Info,
    int idx
    )
/*++
 
Routine Description:

    Prints out the subnet info and the info for each interface in that subnet.

Arguments:
    
    Info - This is the Subnet_info structure which you want to display,
                  it is a node in the list formed from GetSubnetList

Return Value:
   
--*/
{   
    unsigned int rightcol = 55;
    unsigned int leftcol = 24;
    unsigned int linewidth = rightcol+leftcol;
    char *linebuff = (char*)malloc(linewidth+2); //width + /n + /0

    if (linebuff == NULL)
        {
        return;
        }
    memset(linebuff,' ',linewidth);

    struct in_addr inaddr;
    inaddr.S_un.S_addr = Info.dwSubnet;
    char szSubnet[16];
    sprintf(szSubnet,"%d.%d.%d.%d", inaddr.S_un.S_un_b.s_b1,
                                    inaddr.S_un.S_un_b.s_b2,
                                    inaddr.S_un.S_un_b.s_b3,
                                    inaddr.S_un.S_un_b.s_b4);
    
    sprintf(linebuff,"%-5d%-16s%-3d",idx,szSubnet,Info.dwIfCount);
    
    PIF_INFO pCurrInfo;
    for(pCurrInfo=Info.pIfList;pCurrInfo!=NULL;pCurrInfo = pCurrInfo->Next)
        {
        char *currstr = pCurrInfo->szDesc;
        if(strlen(currstr)>=(rightcol))
            {
            memcpy(&linebuff[leftcol],currstr,(rightcol));
            currstr+=(rightcol);
            linebuff[linewidth]='\n';
            linebuff[linewidth+1]=0;
            }
        else if(strlen(currstr)>0)
            {
            sprintf(&linebuff[leftcol],"%s\n",currstr);
            currstr+=strlen(currstr);
            }

        printf("%s",linebuff);    
        memset(linebuff,' ',leftcol);
        while(strlen(currstr)>0)
            {
            if(strlen(currstr)>=rightcol)
                {
                memcpy(&linebuff[leftcol],currstr,rightcol);
                currstr+=rightcol;
                linebuff[linewidth]='\n';
                linebuff[linewidth+1]=0;
                }
            else if(strlen(currstr)>0)
                {
                sprintf(&linebuff[leftcol],"%s\n",currstr);
                currstr+=strlen(currstr);
                }

            printf("%s",linebuff);
            }
            printf("\n");
        }
}

void
GetSubnetArray(
    IN PSUBNET_INFO pHead,
    OUT PULONG Subnets
    )
/*++
 
Routine Description:

    Fills the array in with the subnet values in the subnet list.  The array
    pointed to must be long enough to hold all the values.  The length can be taken
    from the output parameter in GetSubnetList

Arguments:
    
    pHead - Pointer to the head of the list of subnets which are to be written to the
            array.

    Subnets - pointer to an array which is long enough to hold all the subnets.

Return Value:
   
--*/

{
    int i;
    for(i=0;pHead!=NULL;pHead=pHead->Next,i++)
        {
            Subnets[i] = pHead->dwSubnet;
        }
}

void
SetSubnets (
    IN BOOL bAdmit,
    IN LPDWORD lpIndexArray,
    IN DWORD dwIndexCount
    )
/*++
 
Routine Description:

    Writes the input subnets to the registry.
    FORMAT:
        
          DWORD  DWORD  DWORD          DWORD       DWORD    
          '4vPI' Flag   Subnet Count   Subnet 1    Subnet 2 ...
    
    Flag = 1 for admit list
           0 for deny list
    Subnets stored in host byte order.


Arguments:

    bAdmit - TRUE for admit list FALSE for block list.

    plSubnets - Array of indexes provided by the user into our array of subnets.

    Count - Number of indexes in the array

Return Value:

--*/
{    
    DWORD   dwStatus = ERROR_SUCCESS;
    PSUBNET_INFO pHead;
    
    DWORD   dwInSubnetCount;
    DWORD   dwInSubnetIdx = 0;
    LPDWORD pInSubnetArray = NULL;

    DWORD   dwOutSubnetCount= 0;
    LPDWORD pOutSubnetArray = NULL;

    

    //Get the IPv4 address table, in assending order of IP address
    GetSubnetList(&pHead,&dwInSubnetCount);
    if (pHead == NULL)
        {
        return;
        }

    pInSubnetArray = new DWORD[dwInSubnetCount];
    if (pInSubnetArray == NULL)
        {
        FreeSubnetList(&pHead);
        return;
        }

    // The number of subnets we write out won't be larger than the number of
    // indicies the user specifies
    pOutSubnetArray = new DWORD[dwIndexCount];
    if (pOutSubnetArray == NULL)
        {
        delete pInSubnetArray;
        FreeSubnetList(&pHead);
        return;
        }
    
    GetSubnetArray(pHead, pInSubnetArray);

    for (dwInSubnetIdx = 0; dwInSubnetIdx < dwInSubnetCount; dwInSubnetIdx++)
        {
        DWORD dwIndexArrayIdx;
        for (dwIndexArrayIdx = 0; dwIndexArrayIdx < dwIndexCount; dwIndexArrayIdx++)
            {
            if (lpIndexArray[dwIndexArrayIdx] == (dwInSubnetIdx + 1))
                {
                pOutSubnetArray[dwOutSubnetCount++] = pInSubnetArray[dwInSubnetIdx];
                }
            }
        }
        

    FreeSubnetList(&pHead);

    if (dwOutSubnetCount != 0)
        {
        //Write the settings
        (void ) SetSelectiveBindingSubnets(dwOutSubnetCount, pOutSubnetArray, bAdmit);
        }
    
    delete pOutSubnetArray;
    
}

void
DisplaySubnetList(
    IN PSUBNET_INFO pHead
    )
/*++
 
Routine Description:

    Walks the subnet list and prints out info on each node using DisplaySubnet

Arguments:
    
    pHead - Pointer to the head of the subnet list which is to be displayed.

Return Value:
   
--*/
{   
    if(pHead == NULL)
        {
        return;
        }
    int i=1;
    for(; pHead!=NULL; pHead=pHead->Next,i++)
        {
        DisplaySubnet(*pHead,i);
        }
}


void
FilterSubnetListSubnets(
    IN OUT PSUBNET_INFO *ppSubnetList,
    IN ULONG *Subnets,
    IN ULONG SubnetCount
    )
/*++
 
Routine Description:

  After this function returns, the Subnetlist only contains entries for subnets which 
  are in the input array.  No new entries are added to the list, but any entry in the list
  which does not match one of the input subnets is removed.

Arguments:
    
    ppSubnetList - This value may change if the head node is not a matching subnet.  It
                   may be NULL if none of the subnets in the list are matching.

    Subnets - An array of subnet values which will be used to match up with entries in the subnet list

    SubnetCount - Contains the number of subnets in the subnet array.

Return Value:
   
--*/
{

    PSUBNET_INFO pCurr,pPrev,pTmp;
    pCurr=*ppSubnetList;
    pPrev=NULL;
    while(pCurr!=NULL)
        {
        //Check each subnet to see if it matches anyone
        //on the subnet list
        ULONG i;
        BOOL bMatches = FALSE;
        for(i=0; i<SubnetCount; i++)
            {
            if(pCurr->dwSubnet == Subnets[i])
                {
                bMatches = TRUE;
                break;
                }
            }
        if(!bMatches)
            {
            //Doesnt match any of the subnets so remove it
            pTmp = pCurr;
            pCurr = pCurr->Next;
            if(pPrev == NULL)
                {
                *ppSubnetList = pCurr;
                }
            else
                {
                pPrev->Next = pCurr;
                }
            pTmp->Next = NULL;
            FreeSubnetList(&pTmp);
            }
        else
            {
            pPrev = pCurr;
            pCurr = pCurr->Next;
            }
        }
}

void
FilterSubnetListIndices(
    IN OUT PSUBNET_INFO *ppSubnetList,
    IN DWORD *IndexTable,
    IN DWORD IndexCount
    )

/*++
 
Routine Description:

    This function steps through each subnet and each interface within each subnet and
    eliminates any interface whose index is not a memeber of the input index array.  If
    all the interfaces of a particular subnet entry are removed, than the subnet is also removed.

Arguments:
    
    ppSubnetList - This value may change if the head node does not contain a valid interface.  It
                   may be NULL if all of the interfaces are removed.

    IndexTable - An array of device index values which will be used to match up with interface entries.

    IndexCount - Contains the number of indices in the index table.

Return Value:
   
--*/
{

    PSUBNET_INFO pCurr,pPrev,pTmp;
    pCurr=*ppSubnetList;
    pPrev=NULL;
    while(pCurr!=NULL)
        {
        //Go through and check each interface in this subnet
        //against each device index
        PIF_INFO pIfCurr,pIfPrev,pIfTmp;
        pIfCurr=pCurr->pIfList;
        pIfPrev=NULL;
        while(pIfCurr!=NULL)
            {
            ULONG i;
            BOOL bMatches = FALSE;
            for(i=0;i<IndexCount;i++)
                {
                if(pIfCurr->dwIndex==IndexTable[i])
                    {
                    bMatches = TRUE;
                    break;
                    }
                }
            if(!bMatches)
                {
                //Doesn't match anyone in the device list
                //so remove it
                pIfTmp = pIfCurr;
                pIfCurr=pIfCurr->Next;
                if(pIfPrev==NULL)
                    {
                    pCurr->pIfList = pIfCurr;
                    }
        
                else
                    {
                    pIfPrev=pIfCurr;
                    pIfCurr=pIfCurr->Next;
                    }
                free(pIfTmp);
                pCurr->dwIfCount--;
                }
            else
                {
                pIfPrev = pIfCurr;
                pIfCurr = pIfCurr->Next;
                }
            }    
        //If all the interfaces for this subnet were removed
        //than remove the subnet
        if(pCurr->dwIfCount==0)
            {
            pTmp = pCurr;
            pCurr = pCurr->Next;
            if(pPrev == NULL)
                {
                *ppSubnetList = pCurr;
                }
            else
                {
                pPrev->Next = pCurr;
                }
            free(pTmp);
            }
        else
            {
            pPrev = pCurr;
            pCurr = pCurr->Next;
            }
        }
}

BOOL
ListInterfaces()
/*++
 
Routine Description:

    This lists all the interfaces, grouped by subnet, on the machine.

Arguments:

Return Value:
   
--*/
{
    
    PSUBNET_INFO pInfo;
    DWORD dwTmp;
    int count = 1;
    GetSubnetList(&pInfo,&dwTmp);
    if(!pInfo)
        {
        return FALSE;
        }

    printf("      Subnet             Description\n");
    
    DisplaySubnetList(pInfo);
    FreeSubnetList(&pInfo);
    return TRUE;
}
        


void ResetState (
    )
{
    DWORD Status;
    HKEY hKey;

    //
    // Reset interface state to default
    //
    Status = DeleteSelectiveBinding();
    if (Status != ERROR_SUCCESS)
        {
        if (Status == ERROR_ACCESS_DENIED)
            {
            printf("RPCCFG: Access denied to HKLM\\%s\n",RPC_SELECTIVE_BINDING_KEY_PATH);
            }
        else 
            {
            printf("RPCCFG: Error occured while removing selective binding settings :[0x%x]\n",Status);
            }
        }

    //
    // Reset Port state to default
    //
    Status =
    RegOpenKeyExA(
              HKEY_LOCAL_MACHINE,
              "Software\\Microsoft\\Rpc",
              0,
              KEY_ALL_ACCESS,
              &hKey);
    if ((Status != ERROR_SUCCESS) && (Status != ERROR_FILE_NOT_FOUND))
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        }
    else
        {
        Status = RegDeleteKeyA(hKey, "Internet");
        if (!((Status == ERROR_FILE_NOT_FOUND) || (Status == ERROR_SUCCESS)))
           {
           printf("RPCCFG: Could not perform operation (%d)\n", Status);
           }
        }
    RegCloseKey(hKey);
}

BOOL
ListCurrentInterfaces(
    )
/*++
 
Routine Description:

    Lists all interfaces, grouped by subnet, which are currently being either
    admited or denyed.  This function bases the display on the registry settings
    and will output the same wheither the registry entry is in the old or new format.

Arguments:


Return Value:

--*/
{
    
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwSize = 0;
    DWORD   dwDummy = 0;
    LPVOID lpSettings = NULL;
    PSUBNET_INFO pSubnetList = NULL;
    BOOL    bAdmit = TRUE;
    SB_VER  sbVer = SB_VER_UNKNOWN;

    dwStatus = GetSelectiveBindingSettings(&sbVer, &dwSize, &lpSettings);
    if (dwStatus != ERROR_SUCCESS)
        {
        printf("RPCCFG: Error occured while retrieving selective binding settings :[0x%x]\n",dwStatus);
        return FALSE;
        }

    if (sbVer == SB_VER_DEFAULT)
        {
        printf("RPCCFG: Using default selective binding settings\n");
        return TRUE;
        }

    if (sbVer == SB_VER_UNKNOWN)
        {
        printf("RPCCFG: Corrupt selective binding settings\n");
        return FALSE;
        }

    if (!GetSubnetList(&pSubnetList,&dwDummy))
        {
        delete lpSettings;
        printf("RPCCFG: Unexpected error, cannot list the selective binding settings \n");
        return FALSE;
        }

    //Filter the subnets appropriatly based on the type of settings we have, 
    if (sbVer == SB_VER_SUBNETS)
        {
        VER_SUBNETS_SETTINGS *pSubnetSettings = (VER_SUBNETS_SETTINGS*)lpSettings;
        FilterSubnetListSubnets(&pSubnetList, pSubnetSettings->dwSubnets, pSubnetSettings->dwCount);
        bAdmit = pSubnetSettings->bAdmit;
        }
    else if (sbVer == SB_VER_INDICES)
        {
        VER_INDICES_SETTINGS *pIndexSettings = (VER_INDICES_SETTINGS*)lpSettings;
        FilterSubnetListIndices(&pSubnetList, pIndexSettings->dwIndices, pIndexSettings->dwCount);
        }
    else
        {
        printf("RPCCFG: Error, selective binding settings are corrupt, use 'rpccfg -r' to reset them\n");
        delete lpSettings;
        return FALSE;
        }
    delete lpSettings;

    printf("%s\n",(bAdmit?"Admit List":"Deny List"));
    printf("      Subnet             Description\n");
    //Display the list
    DisplaySubnetList(pSubnetList);
    //Free the SubnetList
    FreeSubnetList(&pSubnetList);
    return TRUE;
}

char *
NextPortRange(
    char **Ptr
    )
{
    char *Port = *Ptr ;
    if (*Port == 0)
        {
        return 0;
        }

    while (**Ptr) (*Ptr)++ ;
    (*Ptr)++ ;

    return Port ;
}

void
ListCurrentPortSettings (
    )
{
    HKEY hKey;
    DWORD Size ;
    DWORD Type;
    char *Buffer;
    DWORD Status;

    Status =
    RegOpenKeyExA(
                  HKEY_LOCAL_MACHINE,
                  RPC_PORT_SETTINGS,
                  0,
                  KEY_READ,
                  &hKey);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        printf("RPCCFG: Using default port settings\n");
        return;
        }

    if (Status != ERROR_SUCCESS)
        {
        return;
        }

    Size = 2048;
    Buffer = (char *) malloc(Size) ;
    if (Buffer == 0)
        {
        RegCloseKey(hKey);
        return;
        }

    while(TRUE)
        {
        Status =
        RegQueryValueExA(
            hKey,
            "Ports",
            0,
            &Type,
            (unsigned char *) Buffer,
            &Size);

        if (Status == ERROR_SUCCESS)
            {
            break;
            }

        if (Status == ERROR_MORE_DATA)
            {
            free(Buffer) ;
            Buffer = (char *) malloc(Size) ;
            if (Buffer == 0)
                {
                RegCloseKey(hKey);
                printf("RPCCFG: Could not perform operation, out of memory\n");
                return;
                }
            continue;
            }

        if (Status == ERROR_FILE_NOT_FOUND)
            {
            free(Buffer) ;
            printf("RPCCFG: Using default port settings\n");
            RegCloseKey(hKey);
            return;
            }

        printf("RPCCFG: Could not perform operation\n");
        free(Buffer) ;
        RegCloseKey(hKey);
        return;
        }

    if (*Buffer == 0)
        {
        printf("RPCCFG: Bad settings\n");
        RegCloseKey(hKey);

        ResetState();
        return;
        }

    char *PortRange;
    char Flags[32];

    Size = 32;

    Status =
    RegQueryValueExA(
        hKey,
        "PortsInternetAvailable",
        0,
        &Type,
        (unsigned char *) Flags,
        &Size);

    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        RegCloseKey(hKey);
        return;
        }

    printf("The following ports/port ranges will be used for ");

    if (Flags[0] == 'Y')
        {
        printf("Internet ports\n");
        }
    else
        {
        printf("Intranet ports\n");
        }

    while ((PortRange = NextPortRange(&Buffer)) != 0)
        {
        printf("\t%s\n", PortRange);
        }

    Size = 32;

    Status =
    RegQueryValueExA(
        hKey,
        "UseInternetPorts",
        0,
        &Type,
        (unsigned char *) Flags,
        &Size);

    printf("\nDefault port allocation is from ");
    if ((Status != ERROR_SUCCESS) || (Flags[0] != 'Y'))
        {
        printf("Intranet ports\n");
        }
    else
        {
        printf("Internet ports\n");
        }

    RegCloseKey(hKey);
}

void
SetPortRange(
    char **PortRangeTable,
    int NumEntries,
    char *InternetAvailable
    )
{
    int i;
    DWORD Status;
    DWORD disposition;
    HKEY hKey;

    Status =
    RegCreateKeyExA(
                  HKEY_LOCAL_MACHINE,
                  RPC_PORT_SETTINGS,
                  0,
                  "",
                  REG_OPTION_NON_VOLATILE,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hKey,
                  &disposition);
    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    int cbPorts = 0;

    char *lpPorts = (char *) malloc(257*NumEntries+1);
    if (lpPorts == 0)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    char *current = lpPorts;

    for (i = 0; i < NumEntries; i++)
        {
        strcpy(current, PortRangeTable[i]);

        int length = strlen(current)+1;

        current += length;
        cbPorts += length;
        }

    *current = 0;
    cbPorts++;

    Status = RegSetValueExA(hKey,
                            "Ports",
                            0,
                            REG_MULTI_SZ,
                            (unsigned char *) lpPorts,
                            cbPorts);
    free(lpPorts);

    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    Status = RegSetValueExA(hKey,
                        "PortsInternetAvailable",
                        0,
                        REG_SZ,
                        (unsigned char *) InternetAvailable,
                        strlen(InternetAvailable)+1);
    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }
}

void
SetDefaultPortSetting (
    char *PortSetting
    )
{
    int i;
    HKEY hKey;
    DWORD Status;
    DWORD disposition;

    Status =
    RegCreateKeyExA(
                  HKEY_LOCAL_MACHINE,
                  RPC_PORT_SETTINGS,
                  0,
                  "",
                  REG_OPTION_NON_VOLATILE,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hKey,
                  &disposition);
    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    if (PortSetting[0] == '0')
        {
        PortSetting = "Y";
        }
    else
        {
        PortSetting = "N";
        }

    Status = RegSetValueExA(hKey,
                            "UseInternetPorts",
                            0,
                            REG_SZ,
                            (unsigned char *) PortSetting,
                            strlen(PortSetting)+1);

    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    RegCloseKey(hKey);
}


BOOL
IsNewVersion()
/*++
 
Routine Description:

    Determines what version and service pack this os is.

Arguments:

Return Value:
    
    True if Windows server or WinXP SP1 or greater

--*/
{
    OSVERSIONINFOEX osvi;
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx((OSVERSIONINFO*)&osvi);

    if(
      (osvi.dwMajorVersion > 5) || 
      ((osvi.dwMajorVersion == 5) && (osvi.dwMinorVersion >=2))
      )
    {
        // Check if it is Windows Server 2003 or a DC
        if(osvi.wProductType > VER_NT_WORKSTATION){
            return TRUE;
        }
    }
    return FALSE;
}

VOID
GetDeviceIndiciesFromSubnetIndicies(
    IN ULONG  *alIndex,
    IN ULONG count,
    OUT ULONG  **ppIndex,
    OUT ULONG *pIndexCount)
/*++
 
Routine Description:
    
    This maps subnet indicies (the ones that the user supplies to the -a and -b options)
    to a set of device indicies which are the device indicies for each interface in one
    of the subnets specified by the subnet indicies.

Arguments:

   alIndex - The array of subnet indicies (user supplied indicies).
   
   count - The number of user supplied indices in alIndex

   ppIndex - This is the output parameter which points to the allocated array which contains
             the device indices generated by this function.

   pIndexCount - Output parameter which holds the count of device indices.  May be greater than
                 or equal to the input parameter 'count'.

   NOTE:  This function is not currently called by anyone, Originally it was written to map
          user indices to device indices so that we could maintain backwards compatibility with the
          old version of rpcrt4.dll.  Instead, we now block users from creating admit lists using this
          version of rpccfg if they are on a pre Win XP SP1 or pre Windows 2003 system

--*/
{
    PSUBNET_INFO pSubnetList = NULL;
    ULONG SubnetCount = 0;
    GetSubnetList(&pSubnetList,&SubnetCount);

    //figure out how many device indices we have
    *pIndexCount = 0;
    PSUBNET_INFO pSubnet;
    for(UINT i=0;i<count;i++)
        {
        //Get the subnet entry for this index
        //GetSubnetEntry(alIndex[i],&pSubnet);
        pSubnet = pSubnetList;
        for(UINT j=0 ; j<SubnetCount ;j++)
            {
            if(j+1 == alIndex[i])
                {
                break;
                }
            else
                {
                pSubnet = pSubnet->Next;
                }
            }

        if(pSubnet!=NULL)
            {
            *pIndexCount += pSubnet->dwIfCount;
            }
        }
    //allocate space for the device indicies
    *ppIndex = NULL;
    if(*pIndexCount!=0)
        {
        *ppIndex = (ULONG*)malloc(sizeof(ULONG)*(*pIndexCount));
        if (*ppIndex == NULL)
            {
            return;
            }
        }

    //step through the input indicies (i)
    UINT idx = 0;
    for(i = 0; (i < count) && (idx < *pIndexCount); i++)
        { 
        
        //Get the subnet entry for this index
        //GetSubnetEntry(alIndex[i],&pSubnet);
        pSubnet = pSubnetList;
        for(UINT j=0 ; j<SubnetCount ;j++)
            {
            if(j+1 == alIndex[i])
                {
                break;
                }
            else
                {
                pSubnet = pSubnet->Next;
                }
            }
        if(pSubnet!=NULL)
            {
            //step through each interface in this subnet
            PIF_INFO pIf;
            pIf = pSubnet->pIfList;
            while(pIf!=NULL)
                {
                (*ppIndex)[idx++] = pIf->dwIndex;
                pIf = pIf->Next;
                }
            }
        }

    FreeSubnetList(&pSubnetList);
}

void
Help (
    )
{
    printf("usage: RPCCFG [/l] [/a ifindex1 [ifindex2 ...]] [/r] [/q] [/d 0|1] \n");
    printf("              [/pi port|port-range ...] [/pe port|port-range ...] \n");
    printf("\t/?: This help message\n");
    printf("\t/l: List all the subnets and associated interfaces\n");
    printf("\t/q: List the subnet admit or deny list and our port usage settings\n");
    printf("\t/r: Reset the interface and port settings to default\n");
    printf("\t/a: Admit the listed subnets (eg: /a 1 3 5)\n");
    printf("\t    this will cause RPC servers to listen on the listed subnets\n");
    printf("\t    by default.\n");
    printf("\t/b: Block the listed subnets (eg: /b 1 3 5)\n");
    printf("\t    this will cause RPC servers to listen on all but the listed subnets\n");
    printf("\t    by default.\n");
    printf("\t/pi:Specify the intranet available ports, the ports may be single\n");
    printf("\t    values or ranges (eg: /pi 555 600-700 900), this option may not be\n");
    printf("\t    used with the /pe option\n");
    printf("\t/pe:Specify the internet available ports, the ports may be single\n");
    printf("\t    values or ranges this option may not be used with the /pi option\n");
    printf("\t/d: Specify the default port usage\n");
    printf("\t    0: Use internet available ports by default\n");
    printf("\t    1: Use intranet available ports by default\n");
    printf("\n");
    printf("\tRPC HTTP Proxy \"Valid Ports\" configuration commands\n");
    printf("\n");
    printf("\t/ha: Sets port ranges for a given server\n");
    printf("\t     Usage: /ha [machine-name] [port-range ...]\n");
    printf("\t       ex /ha server1 2000\n");
    printf("\t       ex /ha server1 2000-3000\n");
    printf("\t       ex /ha server1 2000-3000 3050 4000-4050\n");
    printf("\n");
    printf("\t/hr: Removes all port range settings for a given server\n");
    printf("\t     Usage: /hr [machine-name]\n");
    printf("\t       ex /hr server1\n");
    printf("\n");
    printf("\t/hd: Display current port range settings\n");
    printf("\t     Usage: /hd\n");
    printf("\n");
    printf("\t/hs: Stores the current settings to the specified file\n");
    printf("\t     Usage: /hs [filename]\n");
    printf("\t       ex /hs settings.txt\n");
    printf("\n");
    printf("\t/hl: Loads port range settings from a file\n");
    printf("\t     Usage: /hl [filename]\n");
    printf("\t       ex /hl settings.txt\n");
    
}

void
__cdecl main (int argc, char *argv[])
{
    int argscan;
    ULONG alIndex[512];
    char *PortRangeTable[512];
    int i;
    BOOL fPortChanged = 0;
    BOOL fInterfaceChanged = 0;
    BOOL bAdmit = 0;
    

    if (argc == 1)
        {
        Help();
        }

    for (argscan = 1; argscan < argc;argscan++)
        {
        if ((strcmp(argv[argscan], "-l") == 0) || (strcmp(argv[argscan], "/l") == 0))
            {
            ListInterfaces();
            }
        else if ((strcmp(argv[argscan], "-?") == 0) || (strcmp(argv[argscan], "/?") == 0))
            {
            Help();
            }
        else if ((strcmp(argv[argscan], "-r") == 0) || (strcmp(argv[argscan], "/r") == 0))
            {
            ResetState();
            }
        else if ((strcmp(argv[argscan], "-q") == 0) || (strcmp(argv[argscan], "/q") == 0))
            {
            ListCurrentInterfaces();
            printf("\n");
            ListCurrentPortSettings();
            }
        else if ( (strcmp(argv[argscan], "-a") == 0) || (strcmp(argv[argscan], "-b") == 0) ||
                  (strcmp(argv[argscan], "/a") == 0) || (strcmp(argv[argscan], "/b") == 0) )
            {
            int count = 0;
            
            if((strcmp(argv[argscan], "-a") == 0) || (strcmp(argv[argscan], "/a") == 0))
            {
                bAdmit = TRUE;
            } else {
                bAdmit = FALSE;
            }

            for (i = 0; i < 512; i++)
                {
                argscan++;
                if (argscan == argc)
                    {
                    break;
                    }

                if (argv[argscan][0] == '-')
                    {
                    argscan--;
                    break;
                    }

                count++;

                alIndex[i] = atol(argv[argscan]);
                if (alIndex[i] == 0)
                    {
                    printf("RPCCFG: Bad interface index\n");
                    return;
                    }
                }

            if (i == 512)
                {
                printf("RPCCFG: Too many interfaces\n");
                return;
                }

            if (count)
                {
                if (bAdmit == TRUE)
                    {
                    //If it is an old version of the rpc runtime, then
                    //we will use the old method of writing the indices
                    if(IsNewVersion())
                        {
                        //It is a new version, so write the subnets out instead
                        SetSubnets(TRUE, alIndex, (USHORT)count);
                        fInterfaceChanged = 1;
                        }
                    else
                        {
//                        Need to map the indices entered by the user into a set of device indicies.
//                        ULONG *pIndex;
//                        ULONG IndexCount;
//                        GetDeviceIndiciesFromSubnetIndicies(alIndex,count,&pIndex,&IndexCount);
//                        ListenOnInterfaces(pIndex,IndexCount);
//                        if(pIndex!=NULL) free(pIndex);
//                        fInterfaceChanged = 1;
                        /* Need to put this in untill the bug in TCP_ServerListenEx is fixed*/
                        printf("This version of Windows does not support accept lists\n");
                        return;
                        }
                    }
                else 
                    {
                    if(IsNewVersion())
                        {
                        SetSubnets(FALSE, alIndex, (USHORT)count);
                        fInterfaceChanged = 1;
                        }
                    else
                        {
                        printf("This version of Windows does not support deny lists\n");
                        return;
                        }
                    }
                }
            }
        else if ((strncmp(argv[argscan], "-p", 2) == 0) || (strncmp(argv[argscan], "/p", 2) == 0))
            {
            int count = 0;
            char *option = argv[argscan];

            for (i = 0; i < 512; i++)
                {
                argscan++;
                if (argscan == argc)
                    {
                    break;
                    }

                if (argv[argscan][0] == '-')
                    {
                    argscan--;
                    break;
                    }

                count++;

                //Make sure there aren't any comma delimiters                
                if(strchr(argv[argscan],',')!=NULL)
                    {
                    printf("Comma separators not permited\n");
                    return;
                    }
                PortRangeTable[i] = argv[argscan];
                }

            if (i == 512)
                {
                printf("Too many ports\n");
                return;
                }

            if ((strcmp(option, "-pi") == 0) || (strcmp(option, "/pi") == 0))
                {
                SetPortRange(PortRangeTable, count, "N");
                }
            else
                {
                SetPortRange(PortRangeTable, count, "Y");
                }
            fPortChanged = 1;
            }
        else if ((strcmp(argv[argscan], "-d") == 0) || (strcmp(argv[argscan], "/d") == 0))
            {
            argscan++;
            if (argscan == argc)
                {
                break;
                }
            SetDefaultPortSetting(argv[argscan]);
            fPortChanged = 1;
            }
        else if ((strncmp(argv[argscan], "-h", 2) == 0) || (strncmp(argv[argscan], "/h", 2) == 0))
            {
            if(strlen(argv[argscan]) !=3)
                {
                printf("Error: The command was not recognized, please enter rpccfg /? for a list of valid commands.\n");
                return;
                }
            char *Command = argv[argscan];
            LPSTR *Arguments;
            Command+=2;

            argscan++;
            if (argscan == argc){
                Arguments = NULL;
                }
            else{
                Arguments = &(argv[argscan]);
                }
            DoHttpCommandA(*Command, Arguments, argc - argscan);
            return;
            }
        }

    if (fInterfaceChanged)
        {
        ListCurrentInterfaces();
        printf("\n");
        }

    if (fPortChanged)
        {
        ListCurrentPortSettings();
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\rpcnsh\handlers.cxx ===
#include <windows.h>
#include <stdlib.h>
//#include <assert.h>
#include <stdio.h>
#include <netsh.h>
#include <Iphlpapi.h>
#include <Winsock2.h>

#include <selbinding.hxx>
#include <skeleton.h>
#include <handlers.hxx>

extern HANDLE g_hModule;



#define MIN(x, y) ( ((x) >= (y)) ? y:x )

#define HandleErrorGeneric(_dwStatus) \
    {\
    switch (_dwStatus)\
        {\
        case ERROR_SUCCESS:\
        break;\
        case ERROR_ACCESS_DENIED:\
        PrintError(g_hModule, ERRORMSG_ACCESSDENIED);\
        break;\
        case ERROR_OUTOFMEMORY:\
        PrintError(g_hModule, ERRORMSG_ACCESSDENIED);\
        break;\
        case ERROR_INVALID_DATA:\
        PrintError(g_hModule, ERRORMSG_INVALIDDATA);\
        default:\
        PrintError(g_hModule, ERRORMSG_UNKNOWN);\
        }\
    }

BOOL WINAPI CheckServerOrGreater(
  IN UINT CIMOSType,
  IN UINT CIMOSProductSuite,
  IN LPCWSTR CIMOSVersion,
  IN LPCWSTR CIMOSBuildNumber,
  IN LPCWSTR CIMServicePackMajorVersion,
  IN LPCWSTR CIMServicePackMinorVersion,
  IN UINT CIMProcessorArchitecture,
  IN DWORD dwReserved
)
{
    if (_wtoi(CIMOSBuildNumber) > 3000)
        {
        return TRUE;
        }
    return FALSE;
}

DWORD
HandleShowSettings()
{
    DWORD dwStatus = ERROR_SUCCESS;
    SB_VER sbVer = SB_VER_UNKNOWN;
    LPVOID lpSettings = NULL;
    DWORD dwSize = 0;
    VER_SUBNETS_SETTINGS *pSubnetSettings = NULL;


    dwStatus = GetSelectiveBindingSettings(&sbVer, &dwSize, &lpSettings);
    if (dwStatus != ERROR_SUCCESS)
        {
        HandleErrorGeneric(dwStatus);
        return dwStatus;
        }

    if (sbVer == SB_VER_DEFAULT)
        {
        PrintMessage(L"Default\n");
        return ERROR_SUCCESS;
        }

    switch (sbVer)
        {
        case SB_VER_SUBNETS:
            pSubnetSettings = (VER_SUBNETS_SETTINGS *) lpSettings;
            if (pSubnetSettings->bAdmit)
                {
                PrintMessage(L"Add List\n");
                }
            else 
                {
                PrintMessage(L"Delete List\n");
                }
            for (DWORD idx = 0; idx < pSubnetSettings->dwCount; idx++)
                {
                PrintMessage(L"%1!S!\n",inet_ntoa(*((struct in_addr*)&(pSubnetSettings->dwSubnets[idx]))));
                }
            break;

        case SB_VER_INDICES:
        case SB_VER_UNKNOWN:
            PrintMessage(L"Unknown selective binding format\n");
            break;
        default:
            //assert(0);
            PrintMessage(L"Unknown selective binding format\n");
        }

    delete [] lpSettings;
    return ERROR_SUCCESS;
}

DWORD
HandleShowInterfaces()
{
    DWORD dwStatus = ERROR_SUCCESS;
    SB_VER sbVer = SB_VER_UNKNOWN;
    LPVOID lpSettings = NULL;
    DWORD dwDummy = 0;
    VER_SUBNETS_SETTINGS *pSubnetSettings = NULL;
    PMIB_IPADDRTABLE pIpAddrTable = NULL;
    DWORD dwSize = 0;


    dwStatus = GetSelectiveBindingSettings(&sbVer, &dwDummy, &lpSettings);
    if (dwStatus != ERROR_SUCCESS)
        {
        HandleErrorGeneric(dwStatus);
        return dwStatus;
        }

    if ((sbVer != SB_VER_SUBNETS)&&(lpSettings != NULL))
        {
        PrintMessage(L"Unknown selective binding format\n");
        return -1;
        }
    pSubnetSettings = (VER_SUBNETS_SETTINGS *) lpSettings;

    // Query for size
    dwStatus = GetIpAddrTable(NULL,  
                              &dwSize,
                              TRUE);

    if (dwStatus != ERROR_INSUFFICIENT_BUFFER)
        {
        //assert(0);
        HandleErrorGeneric(dwStatus);
        return dwStatus;
        }
    
    pIpAddrTable = (PMIB_IPADDRTABLE) new char [dwSize];
    if (pIpAddrTable == NULL)
        {
        PrintError(g_hModule, ERRORMSG_OOM);
        return -1;
        }

    // Get the interfaces for the machine
    dwStatus = GetIpAddrTable(pIpAddrTable,  
                              &dwSize,
                              TRUE);
    if (dwStatus != ERROR_SUCCESS)
        {
        HandleErrorGeneric(dwStatus);
        delete [] pIpAddrTable;
        return -1;
        }
    

    // Print out the table header
    PrintMessage(L"\nSubnet          Interface       Status    Description\n\n");

    
    // Iterate over the interfaces on the system
    for (DWORD idx = 0; idx < pIpAddrTable->dwNumEntries; idx++)
        {
        PMIB_IPADDRROW pRow = &pIpAddrTable->table[idx];
        struct in_addr addr;
        addr.S_un.S_addr = pRow->dwAddr & pRow->dwMask;
        PrintMessage(L"%1!-16S!",inet_ntoa(addr));
        addr.S_un.S_addr = pRow->dwAddr;
        PrintMessage(L"%1!-16S!",inet_ntoa(addr));
        // Check if its enabled or disabled, if we have default settings, we know its enabled
        BOOL bEnabled;
        if (pSubnetSettings == NULL)
            {    
            bEnabled = TRUE;
            }
        else
            {
            bEnabled = !pSubnetSettings->bAdmit;  
            for (DWORD idx2 = 0; idx2 < pSubnetSettings->dwCount; idx2++)
                {
                DWORD dwSubnet = pRow->dwAddr & pRow->dwMask;
                if (dwSubnet == pSubnetSettings->dwSubnets[idx2])
                    {
                    bEnabled = !bEnabled;
                    break;
                    }
                }
            }
        if (bEnabled)
            {
            PrintMessage(L"%1!-9s!",L"Enabled");
            }
        else
            {
            PrintMessage(L"%1!-9s!",L"Disabled");
            }
        
        // Print the description 

        MIB_IFROW IfRow;
        memset(&IfRow,0,sizeof(MIB_IFROW));
        IfRow.dwIndex = pRow->dwIndex;
        GetIfEntry(&IfRow);

        CHAR szBuff[40];
        memset(szBuff,0,40);
        DWORD dwDescIdx = 0;
        DWORD dwLenToCopy = 0;
        BOOL  bFirst = TRUE;

        while(dwDescIdx < IfRow.dwDescrLen)
            {
            dwLenToCopy = MIN(38,IfRow.dwDescrLen);
            memcpy(szBuff, &(IfRow.bDescr[dwDescIdx]), dwLenToCopy);
            dwDescIdx += dwLenToCopy;
            if (bFirst)
                {
                bFirst = FALSE;
                PrintMessage(L" %1!S!\n",szBuff);
                }
            else
                {
                PrintMessage(L"                                          %1!S!\n",szBuff);
                }
            }

        PrintMessage(L"\n");
        }

    return ERROR_SUCCESS;
}

DWORD WINAPI
HandleAddOrDelete(
    IN      LPWSTR  *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      BOOL    bAdd
    )
{
    // Check the validity of the arguments passed:
    // 1 Must set at least one subnet
    // 2 Each subnet must be a valid dotted decimal string

    DWORD   idx;
    DWORD   dwStatus = ERROR_SUCCESS;
    LPDWORD lpAddr = NULL;
    DWORD   dwAddrCount = dwArgCount - dwCurrentIndex;

    if (dwAddrCount == 0)
        {
        PrintError(g_hModule, ERRORMSG_ADD_1);
        return -1; 
        }

    // Allocate an array to put all this addresses in, just go
    // straight for the heap, don't bother trying to fit it in a
    // stack based array first
    lpAddr = new DWORD[dwAddrCount];
    if (!lpAddr)
        {
        PrintError(g_hModule, ERRORMSG_OOM);
        return -1;
        }

    for (idx = 0; idx < dwAddrCount; idx++)
        {
        // create a single byte char string from this wc string (for inet_addr).
        DWORD dwLen = wcslen(ppwcArguments[idx+dwCurrentIndex]);
        CHAR *pTmp = new char[dwLen+1];
        if (pTmp == NULL)
            {
            PrintError(g_hModule, ERRORMSG_OOM);
            delete [] lpAddr;
            return -1;
            }

        _snprintf(pTmp, dwLen+1, "%S", ppwcArguments[idx+dwCurrentIndex]);
        lpAddr[idx] = inet_addr(pTmp);

        if (lpAddr[idx] == INADDR_NONE)
            {
            PrintError(g_hModule, ERRORMSG_ADD_2, pTmp);
            delete [] lpAddr;
            delete [] pTmp;
            return -1;
            }
        delete [] pTmp;
        }

    // Write this selective binding setting to the registry.  Note: the
    // user can specify any subnets they want, we don't verify that they exist by design
    dwStatus = SetSelectiveBindingSubnets(dwAddrCount, lpAddr, bAdd);
    HandleErrorGeneric(dwStatus);

    delete [] lpAddr;
    return dwStatus;
}

DWORD WINAPI
HandleAdd(
IN      LPCWSTR pwszMachine,
IN      LPWSTR  *ppwcArguments,
IN      DWORD   dwCurrentIndex,
IN      DWORD   dwArgCount,
IN      DWORD   dwFlags,
IN      LPCVOID pvData,
OUT     BOOL    *pbDone)
{
    return HandleAddOrDelete(ppwcArguments, dwCurrentIndex, dwArgCount, TRUE);
}

DWORD WINAPI
HandleDelete(
IN      LPCWSTR pwszMachine,
IN OUT  LPWSTR  *ppwcArguments,
IN      DWORD   dwCurrentIndex,
IN      DWORD   dwArgCount,
IN      DWORD   dwFlags,
IN      LPCVOID pvData,
OUT     BOOL    *pbDone)
{
    return HandleAddOrDelete(ppwcArguments, dwCurrentIndex, dwArgCount, FALSE);
}

DWORD WINAPI
HandleReset(
IN      LPCWSTR pwszMachine,
IN OUT  LPWSTR  *ppwcArguments,
IN      DWORD   dwCurrentIndex,
IN      DWORD   dwArgCount,
IN      DWORD   dwFlags,
IN      LPCVOID pvData,
OUT     BOOL    *pbDone)
{
    // All we do is delete the selective binding key to reset to default settings
    DWORD dwStatus;

    dwStatus = DeleteSelectiveBinding();
    HandleErrorGeneric(dwStatus);

    return dwStatus;
}


DWORD WINAPI
HandleShow(
IN      LPCWSTR pwszMachine,
IN      LPWSTR  *ppwcArguments,
IN      DWORD   dwCurrentIndex,
IN      DWORD   dwArgCount,
IN      DWORD   dwFlags,
IN      LPCVOID pvData,
OUT     BOOL    *pbDone)
{

    if ((dwArgCount - dwCurrentIndex) != 1)
        {
        PrintError(g_hModule, HLP_SHOW);
        return -1;
        }
    
    if (MatchToken(ppwcArguments[dwCurrentIndex], L"settings"))
        {
        return HandleShowSettings();
        }
    else if (MatchToken(ppwcArguments[dwCurrentIndex], L"interfaces"))
        {
        return HandleShowInterfaces();
        }
        
    PrintError(g_hModule, HLP_SHOW);
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\rpcnsh\skeleton.h ===
#define UNICODE
			 
#define RPCNSH_VERSION				1

const GUID g_RPCNSHGuid 	=   {0x592852f7, 0x5f6f, 0x470b, {0x90, 0x97, 0xc5, 0xd3, 0x3b, 0x61, 0x29, 0x75}};   

DWORD WINAPI
StartHelpers(
    IN CONST GUID * pguidParent,
    IN DWORD        dwVersion
    );

NS_OSVERSIONCHECK CheckServerOrGreater;

//
// These are context names.
//
#define TOKEN_RPC                       L"rpc"

//
// These are all command names, group or otherwise.
//
#define TOKEN_ADD                       L"add"
#define TOKEN_DELETE                    L"delete"
#define TOKEN_DUMP                      L"dump"
#define TOKEN_RESET                     L"reset"
#define TOKEN_SHOW                      L"show"

#define HLP_BASE                        10000

#define ADD_BASE                        0
#define DELETE_BASE                     100
#define DUMP_BASE                       200
#define RESET_BASE                      300
#define SHOW_BASE                       400
#define MISC_BASE                       500


#define CMD_ADD                         TOKEN_ADD
#define HLP_ADD                         HLP_BASE + ADD_BASE + 10
#define HLP_ADD_EX                      HLP_BASE + ADD_BASE + 11

#define CMD_DELETE                      TOKEN_DELETE
#define HLP_DELETE                      HLP_BASE + DELETE_BASE + 10
#define HLP_DELETE_EX                   HLP_BASE + DELETE_BASE + 11

#define CMD_DUMP                        TOKEN_DUMP
#define HLP_DUMP                        HLP_BASE + DUMP_BASE + 10
#define HLP_DUMP_EX                     HLP_BASE + DUMP_BASE + 11

#define CMD_RESET                       TOKEN_RESET
#define HLP_RESET                       HLP_BASE + RESET_BASE + 10
#define HLP_RESET_EX                    HLP_BASE + RESET_BASE + 11

#define CMD_SHOW                        TOKEN_SHOW
#define HLP_SHOW                        HLP_BASE + SHOW_BASE + 10
#define HLP_SHOW_EX                     HLP_BASE + SHOW_BASE + 11


#define ERRORMSG_BASE                   20000

#define ERRORMSG_ADD_1                  ERRORMSG_BASE + ADD_BASE + 1
#define ERRORMSG_ADD_2                  ERRORMSG_BASE + ADD_BASE + 2

#define ERRORMSG_UNKNOWN                ERRORMSG_BASE + MISC_BASE + 1
#define ERRORMSG_OOM                    ERRORMSG_BASE + MISC_BASE + 2
#define ERRORMSG_ACCESSDENIED           ERRORMSG_BASE + MISC_BASE + 3
#define ERRORMSG_INVALIDDATA            ERRORMSG_BASE + MISC_BASE + 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\charconv\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Revision History:

!ENDIF

TARGETNAME=CharConv
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..;$(BASEDIR)\private\inc;..\..\mtrt

#
# Setup for application developer to set breakpoints with windbg
#

MSC_WARNING_LEVEL=/W3 /WX

#NTDEBUG=ntsd
#NTDEBUGTYPE=windbg
#MSC_OPTIMIZATION=/Od

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_CXX=1

SOURCES=             \
        ..\CharConv.cxx

RPCENV= $(RPCENV) -DNTENV -DWIN32RPC -DNTWIN32RPC -D_RPCRT4_

C_DEFINES=$(RPCENV) $(RPCTARGETENV) /DMSWMSG -D_RPCRT4_

# Used only for unit tests
USE_MSVCRT=1

UMTEST=ConvBVT
UMTYPE=console
UMLIBS= \
    $(SDK_LIB_PATH)\ntdll.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(O)\charconv.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\rpccfg\httpcfg.cxx ===
#define _UNICODE
#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <strsafe.h>


#define  REG_PROXY_PATH_STR         _T("Software\\Microsoft\\Rpc\\RpcProxy")
#define  REG_PROXY_VALID_PORTS_STR  _T("ValidPorts")
#define MIN(x, y) ( ((x) >= (y)) ? y:x )


BOOL
GetHttpSettingsString(
    OUT LPTSTR *HttpSettings
    )
    
/*++

Routine Description:

    This retrives any existing http settings string, allocates a string to hold it and passes
    the string back to the caller.  If the RpcProxy key doesn't exist, we return success and
    HttpSettings == NULL.  We also print out a warning message.  If RpcProxy exists, but ValidPorts
    does not, we return success, but we set HttpSettings equal to an empty string.  The caller treats
    this the same as if ValidPorts exists but contains an empty string.

Arguments:

    HttpSettings - This will point to the existing http settings or NULL if none exist.

Return Value:

    ERROR_SUCCESS
    ERROR_OUTOFMEMORY
    ERROR_ACCESS_DENIED

    If not ERROR_SUCCESS, then HttpSettings is undefined.  

--*/

{

    ULONG Status;
    HKEY hKey;
    *HttpSettings = NULL;

    //
    // See if RpcProxy exists.
    //
    Status = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REG_PROXY_PATH_STR,
                0,
                KEY_QUERY_VALUE,
                &hKey
                );

    if (Status == ERROR_FILE_NOT_FOUND){
        _tprintf(_T("Error: RpcProxy is not installed on this system.\n"));
        return FALSE;
        }
    else if (Status){
        return Status;
        }

    //
    // Query the ValidPorts.  The first RegQueryValue gets the size, the second retrieves
    // the data.
    //
    LPTSTR TmpStr = NULL;
    ULONG TmpStrLen = 0;
    Status = RegQueryValueEx(
                hKey,
                REG_PROXY_VALID_PORTS_STR,
                NULL,
                NULL,
                NULL,
                &TmpStrLen
                );

    if (Status){
        CloseHandle(hKey);
        if (Status == ERROR_FILE_NOT_FOUND){
            //
            // Treat a non-existant ValidPorts as if it existed but contained no data,
            // return success and an empty string.
            //
            *HttpSettings = new TCHAR[1];
            if (*HttpSettings == NULL){
                return FALSE;
                }
            **HttpSettings = _T('\0');
            return TRUE;
            }
        return FALSE;
        }

    if (TmpStrLen == 0){
        //
        // If ValidPorts contains no data, return an empty string
        // 
        CloseHandle(hKey);
        *HttpSettings = new TCHAR[1];
        if (*HttpSettings == NULL){
            return FALSE;
            }
        **HttpSettings = _T('\0');        
        return TRUE;
        }

    //
    // TmpStrLen includes the terminating NULL
    //
    TmpStr = new TCHAR[TmpStrLen];
    if (TmpStr == NULL){
        CloseHandle(hKey);
        return FALSE;
        }

    //
    // Retrieve the data, this will NULL terminate the string.
    //
    Status = RegQueryValueEx(
                hKey,
                REG_PROXY_VALID_PORTS_STR,
                NULL,
                NULL,
                (LPBYTE)TmpStr,
                &TmpStrLen
                );

    CloseHandle(hKey);
    if (Status){
        delete [] TmpStr;
        return FALSE;
        }

    *HttpSettings = TmpStr;
    return TRUE;
    
}

BOOL
SetHttpSettingsString(
    IN LPTSTR HttpSettings
    )

/*++

Routine Description:

    Replace the http settings in the registry with the input string.

Arguments:

    HttpSettings - The string to write to the registry.
    
Return Value:

    ERROR_SUCCESS
    ERROR_ACCESS_DENIED

    If not ERROR_SUCESS, then the http settings in the registry will remain unchanged.

--*/

{
    ULONG Status;
    HKEY hKey;
    Status = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REG_PROXY_PATH_STR,
                0,
                KEY_WRITE,
                &hKey
                );

    if (Status == ERROR_FILE_NOT_FOUND){
        _tprintf(_T("Error: RpcProxy is not installed on this system.\n"));
        return FALSE;
        }
    
    Status = RegSetValueEx(
                hKey,
                REG_PROXY_VALID_PORTS_STR,
                0,
                REG_SZ,
                (LPBYTE)HttpSettings,
                (_tcslen(HttpSettings)+1)*sizeof(TCHAR)
                );
    
    CloseHandle(hKey);   
    if (Status){
        return FALSE;
        }
    return TRUE;
}

BOOL
AppendHttpSettingsString(
    IN LPTSTR HttpSettings
    )
    
/*++

Routine Description:

    This takes the input string and appends it to the existing http_settings in the registry.
    The string passed in is a valid http settings string.  If there is already settings present
    in the registry then this input string will be appended after a _T(';') is appended to the existing
    string.
    
Arguments:

    HttpSettings - The string which is to be appended to the existing settings.

Return Value:

    ERROR_SUCCESS
    ERROR_OUTOFMEMORY
    ERROR_ACCESS_DENIED
--*/

{
    BOOL bStatus;
    LPTSTR OldHttpSettings = NULL;
    HRESULT hr;

    bStatus = GetHttpSettingsString(&OldHttpSettings);
    if (!bStatus){
        return bStatus;
        }

    // If GetHttpSettingsString has succeeded, it has allocated OldHttpSettings.
    ASSERT(OldHttpSettings != NULL);

    //
    // The ValidPorts contains an emtpy string, so to append the new settings we just
    // write them to ValidPorts.
    //
    if (_tcslen(OldHttpSettings) == 0){
        bStatus = SetHttpSettingsString(HttpSettings);
        delete OldHttpSettings;
        return bStatus;
        }

    //
    // The len of the new settings is the old len + new len + _T(';') + _T('\0')
    //
    ULONG Len = _tcslen(OldHttpSettings) + _tcslen(HttpSettings) + 2;
    LPTSTR NewSettings = new TCHAR[Len];
    if (NewSettings == NULL){
        delete [] OldHttpSettings;
        return FALSE;
        }
    hr = StringCchCopy(NewSettings, Len, OldHttpSettings);
    ASSERT(hr == S_OK);
    hr = StringCchCat(NewSettings, Len, _T(";"));
    ASSERT(hr == S_OK);
    hr = StringCchCat(NewSettings, Len, HttpSettings);
    ASSERT(hr == S_OK);

    bStatus = SetHttpSettingsString(NewSettings);
    delete [] NewSettings;
    delete [] OldHttpSettings;
    return bStatus;
}


struct PORT_RANGE
{
    BOOL  IsRange;  
    int   Lower;    
    int   Upper;    // Only valid if IsRange is TRUE
};

struct MACHINE_SETTINGS
{
    LPTSTR MachineName;       
    ULONG  PortRangeCount;
    PORT_RANGE *PortRanges;
};

struct HTTP_SETTINGS
{
    ULONG MachineSettingsCount;
    MACHINE_SETTINGS *MachineSettings;
};

VOID
InitializeMachineSettings(
    IN OUT MACHINE_SETTINGS *M
    )

/*++

Routine Description:

    This initializes the members of MACHINE_SETTINGS.  This should be the first
    operation performed on a MACHINE_SETTINGS object. 
    
Arguments:

    M - A pointer to the MACHINE_SETTINGS to initialize.

--*/

{
    M->MachineName = NULL;
    M->PortRangeCount = 0;
    M->PortRanges = NULL;
}

VOID
FreeMachineSettings(
    IN OUT MACHINE_SETTINGS *M
    )

/*++

Routine Description:

    Cleans up all memory assocaited with this MACHINE_SETTINGS object.  
    
Arguments:

    M - A pointer to the MACHINE_SETTINGS to clean up.

--*/

{
    delete [] M->MachineName;
    delete [] M->PortRanges;
}

BOOL
CreateMachineSettings(
    IN MACHINE_SETTINGS *M,
    IN LPTSTR MachineName,
    IN LPTSTR *PortRanges,
    IN ULONG  PortRangeCount    
    )

/*++

Routine Description:

    Poplulates the internal members of the MACHINE_SETTINGS object based off of
    the parameters passed in.  
    
Arguments:

    M - A pointer to the MACHINE_SETTINGS to fill in.

    MachineName - The name which these port settings are associated with.

    PortRanges - An array of strings, each one containing a port range "100" or "100-300"

    PortRangeCount - The number of port ranges provided in PortRanges.

Return Value:

    ERROR_SUCCESS
    ERROR_OUTOFMEMORY
    ERROR_INVALID_DATA
    
    If the return value is not ERROR_SUCCESS, the MACHINE_SETTINGS structure is left in an 
    undetermined state and should be re-initialized before reuse (calling 
    FreeMachineSettings is unnessisary).
    
--*/

{
    HRESULT hr;

    ASSERT(PortRangeCount != 0);
    ASSERT(_tcslen(MachineName) != 0);
    
    //
    // Attempt all the memory allocations needed, one allocation for the MachienName,
    // another for the array of PORT_RANGE objects.  
    //
    M->MachineName = new TCHAR[_tcslen(MachineName)+1];
    if (M->MachineName == NULL)
        return FALSE;
    
    if (PortRangeCount == 0)
        M->PortRanges = NULL;
    else{
        M->PortRanges = new PORT_RANGE[PortRangeCount];
        if (M->PortRanges == NULL){
            delete [] M->MachineName;
            return FALSE;
            }
        }

    M->PortRangeCount = PortRangeCount;

    //
    // Copy the machine name and parse the port range strings to fill
    // in the PORT_RANGE array. Print out error messages for poorly formed ranges.
    //
    hr = StringCchCopy(M->MachineName,_tcslen(MachineName)+1, MachineName);
    ASSERT(hr == S_OK);

    for (ULONG i = 0; i < PortRangeCount; i++){
        if (_tcslen(PortRanges[i]) == 0){
            _tprintf(_T("Error: Invalid port range for machine \'%s\'.\n"), MachineName);
            delete [] M->MachineName;
            delete [] M->PortRanges;
            return FALSE;
            }
        M->PortRanges[i].IsRange = FALSE;
        M->PortRanges[i].Lower = _ttoi(PortRanges[i]);
        if (M->PortRanges[i].Lower <= 0){ 
            _tprintf(_T("Error: Invalid port range for machine \'%s\'.\n"), MachineName);
            delete [] M->MachineName;
            delete [] M->PortRanges;
            return FALSE;
            }            
        if (_tcschr(PortRanges[i],_T('-')) != NULL){
            LPTSTR c;
            M->PortRanges[i].IsRange = TRUE;
            c = _tcschr(PortRanges[i],_T('-'));
            M->PortRanges[i].Upper = _ttoi(++c);
            if (M->PortRanges[i].Upper <= 0){
                _tprintf(_T("Error: Invalid port range for machine \'%s\'.\n"), MachineName);                
                delete [] M->MachineName;
                delete [] M->PortRanges;
                return FALSE;
                }                
            }
        }

    //
    // Sort the port ranges by Lower in ascending order, bubble sort.
    //
    int End;
    for (End = PortRangeCount; End != 0; End--){
        int Max = 0;
        for (int i = 0; i< End; i++){
            if (M->PortRanges[i].Lower >= Max){
                Max = M->PortRanges[i].Lower;
                }
            else{
                PORT_RANGE Tmp;
                memcpy(&Tmp, &(M->PortRanges[i]), sizeof(PORT_RANGE));
                memcpy(&(M->PortRanges[i]), &(M->PortRanges[i-1]), sizeof(PORT_RANGE));
                memcpy(&(M->PortRanges[i-1]), &Tmp, sizeof(PORT_RANGE));
                }
            }
        }
         
    return TRUE;
}

BOOL
StringFromMachineSettings(
    IN MACHINE_SETTINGS *M,
    OUT LPTSTR *Str
    )

/*++

Routine Description:

    Creates a valid <http_settings> string based off of the MACHINE_SETTINGS structure.
    
Arguments:

    M - A pointer to the MACHINE_SETTINGS to use.

    Str - This will point to the htt_settings string.  This must be freed by the caller.
          On failure, this will point to NULL.

Return Value:

    TRUE - Success
    FALSE - We ran out of memory
    
--*/

{

    ULONG Len;
    LPTSTR TmpStr, TmpStrStart;
    *Str = NULL;
    HRESULT hr;

    //
    // Calculate the length of the string.  We will assume that a given port range
    // including the prefix _T(':') and a possible suffix _T(';') in total will be 32 charaters.
    // 
    Len = (_tcslen(M->MachineName)+32)  // Each entry is machine name + _T(':') + port range + _T(';')
          * M->PortRangeCount          // Number of entries
          + 1                          // Trailing NULL;
          ;
    
    TmpStr = new TCHAR[Len];
    if (TmpStr == NULL)
        return FALSE;

    TmpStrStart = TmpStr;

    *Str = TmpStr;

    //
    // Convert each port range into a string, add the _T('-') if needed.  This loop creates
    // the actual http_settings string
    //
    for (ULONG i = 0; i < M->PortRangeCount; i++){
        hr = StringCchCopy(TmpStr, Len, M->MachineName);
        ASSERT(hr == S_OK);
        TmpStr = _tcschr(TmpStr, _T('\0'));
        *(TmpStr++) = _T(':');
        _ltot(M->PortRanges[i].Lower, TmpStr, 10);
        TmpStr = _tcschr(TmpStr, _T('\0'));
        if (TmpStr == NULL)
            {
            ASSERT(TmpStr != NULL);
            delete [] TmpStrStart;
            return FALSE;
            }
        if (M->PortRanges[i].IsRange){
            *(TmpStr++) = _T('-');
            _ltot(M->PortRanges[i].Upper, TmpStr, 10);
            TmpStr = _tcschr(TmpStr, _T('\0'));
            }
        *(TmpStr++) = _T(';');            
        }
    //
    // Replace the last _T(';') with a NULL to end the string (there should be no trailing _T(';'))
    //
    *(--TmpStr) = _T('\0');    

    return TRUE;
}


VOID
InitializeHttpSettings(
    IN OUT HTTP_SETTINGS *H
    )

/*++

Routine Description:

    This initializes the members of HTTP_SETTINGS.  This should be the first
    operation performed on a HTTP_SETTINGS object.  
    
Arguments:

    M - A pointer to the HTTP_SETTINGS to initialize.

--*/

{
    H->MachineSettingsCount = 0;
    H->MachineSettings = NULL;
}

VOID
FreeHttpSettings(
    IN OUT HTTP_SETTINGS *H
    )

/*++

Routine Description:

    Cleans up all memory assocaited with this HTTP_SETTINGS object.  
    
Arguments:

    M - A pointer to the HTTP_SETTINGS to clean up.

--*/

{
    for (ULONG i = 0; i < H->MachineSettingsCount; i++)
        FreeMachineSettings(&(H->MachineSettings[i]));

    delete [] H->MachineSettings;
        
}   

BOOL
StringToHttpSettings(
    IN LPTSTR HttpSettings,
    OUT HTTP_SETTINGS *H
    )

/*++

Routine Description:

    This fills in an initialized HTTP_SETTINGS structure with the settings
    supplied in the HttpSettings string.  
Arguments:

    HttpSettings - A valid HttpSettings string.  If this string is not valid,
                   this function will return failure.

    H - Pointer to the initilized HTTP_SETTINGS structure to fill in.

Return Value:

    ERROR_SUCCESS
    ERROR_OUTOFMEMORY
    ERROR_INVALID_DATA

    If not ERROR_SUCCESS, the HTTP_SETTINGS strucutre is in an undefined state and should be
    initialized before using again.  You should not call FreeHttpSettings if on
    the object if this function fails.

--*/
    
{
    //
    // Count the number of entries (semicolons + 1 since there is no trailing semicolon)
    // allocate enough MACHINE_SETTINGS for all of them.  We actually may need less since 
    // there can be repeat entries, but this is simpler.
    //
    BOOL bStatus;
    LPTSTR c;
    LPTSTR Current;
    ULONG ProxySettingsCount = 1;
    
    for (c = _tcschr(HttpSettings,_T(';')); 
         c != NULL; 
         c = _tcschr(++c, _T(';')), ProxySettingsCount++);

    //
    // Allocate the MACHINE_SETTINGS, and initialize each.  Fill in the machine settings
    // using a O(N^2) algorithm.  This is a simple way to do it, and as long as the number of
    // settings stays reasonable then we should be fine.
    //

    H->MachineSettings = new MACHINE_SETTINGS[ProxySettingsCount];
    if (H->MachineSettings == NULL)
        return FALSE;
    
    for (ULONG i = 0; i < ProxySettingsCount; i++)
        InitializeMachineSettings(&(H->MachineSettings[i]));

    //
    // First, create an array of pointers, each one pointing to a settings
    // string within the HttpSettings (machine name:port range).  We need to
    // fill in NULL for the semi-colins and colins to separate the strings.
    //
    LPTSTR *ProxySettings = new LPTSTR[ProxySettingsCount];
    if (ProxySettings == NULL){
        delete [] H->MachineSettings;
        return FALSE;
        }

    //
    // Replace the _T(':') and _T(';') for each setting with null, print out error messages
    // if a poorly formed setting is encountered.
    //
    ProxySettings[0] = HttpSettings;
    c = HttpSettings;
    for (ULONG i = 1; i < ProxySettingsCount; i++){
        Current = c;
        c = _tcschr(Current, _T(':'));
        if (c == NULL){
            _tprintf(_T("Error: Expected ':' in string \'%s\'.\n"),Current);
            delete [] H->MachineSettings;
            return FALSE;
            }
        *c++ = _T('\0');

        Current = c;
        c = _tcschr(Current, _T(';'));
        if (c == NULL){
            _tprintf(_T("Error: Expected ';' in string \'%s\'.\n"),Current);
            delete [] H->MachineSettings;
            return FALSE;
            }
        *c++ = _T('\0');
        ProxySettings[i] = c;
        }
    //
    // Set the final _T(':') to \0, there is no trailing _T(';')
    //
    Current = c;
    c = _tcschr(Current, _T(':'));
    if (c == NULL){
        _tprintf(_T("Error: Expected ':' in string \'%s\'.\n"),Current);
        delete [] H->MachineSettings;
        return FALSE;
        }
    *c = _T('\0');

    //
    // Here is the actual O(N^2) algorithm.  Each time through the outer loop,
    // we will have consumed a number of proxy settings (all with the same machine name).
    // These consumed settings are converted to MACHINE_SETTINGS which is recorded in our
    // HTTP_SETTINGS object.  The inner loop first gets a machine name to group by, and then
    // loops through the un-consumed (non-NULL) proxy settings matching them with the machine name.
    // These are grouped into another array of string pointers and passed to CreateMachineSettings.
    //
    ULONG ProxySettingsConsumed = 0;
    ULONG MachineSettingsCount = 0;
    LPTSTR *PortRanges = new LPTSTR[ProxySettingsCount];
    if (PortRanges == NULL){
        delete [] H->MachineSettings;
        delete [] ProxySettings;
        return FALSE;
        }
    
    while (ProxySettingsConsumed < ProxySettingsCount){
        LPTSTR MachineName = NULL;
        ULONG PortRangeCount = 0;
        for (ULONG i = 0; i < ProxySettingsCount; i++){
            if (ProxySettings[i] != NULL){
                if (MachineName == NULL)
                    MachineName = ProxySettings[i];
                if (_tcsicmp(MachineName, ProxySettings[i]) == 0){
                    c = _tcschr(ProxySettings[i], _T('\0'));
                    PortRanges[PortRangeCount++] = ++c;
                    ProxySettings[i] = NULL;
                    ProxySettingsConsumed++;
                    }
                }
            }

        //
        // Do some validation befor passing the machine name and port settings to CreateMachineSettings
        //
        if (_tcslen(MachineName) == 0){
            _tprintf(_T("Error: Zero length machine name after entry %d.\n"), MachineSettingsCount);
            delete [] H->MachineSettings;
            delete [] ProxySettings;
            delete [] PortRanges;
            return FALSE;
            }
        if (PortRangeCount <= 0 ){
            _tprintf(_T("Error: No port settings for machine name %s.\n"), MachineName);
            delete [] H->MachineSettings;
            delete [] ProxySettings;
            delete [] PortRanges;
            return FALSE;
            }
        
        bStatus = CreateMachineSettings(
                    &(H->MachineSettings[MachineSettingsCount++]),
                    MachineName,
                    PortRanges,
                    PortRangeCount
                    );

        if (!bStatus){
            delete [] H->MachineSettings;
            delete [] ProxySettings;
            delete [] PortRanges;
            return bStatus;
            }
        }

    //
    // Sort the machine settings, bubble sort.
    //    
    int End;
    for (End = MachineSettingsCount; End != 0; End--){
        LPTSTR MaxString = H->MachineSettings[0].MachineName;
        for (int i = 0; i< End; i++){
            if (_tcsicmp(MaxString, H->MachineSettings[i].MachineName) < 0){
                MaxString = H->MachineSettings[i].MachineName;
                }
            else if (i > 0){
                MACHINE_SETTINGS Tmp;
                memcpy(&Tmp, &(H->MachineSettings[i]), sizeof(MACHINE_SETTINGS));
                memcpy(&(H->MachineSettings[i]), &(H->MachineSettings[i-1]), sizeof(MACHINE_SETTINGS));
                memcpy(&(H->MachineSettings[i-1]), &Tmp, sizeof(MACHINE_SETTINGS));
                }
            }
        }
         

    H->MachineSettingsCount = MachineSettingsCount;
    delete [] PortRanges;
    delete [] ProxySettings;

    return TRUE;
}

BOOL 
StringFromHttpSettings(
    IN HTTP_SETTINGS *H,
    OUT LPTSTR *HttpSettings
    )

/*++

Routine Description:

    This function creates a valid http settings string from a filled-in HttpSettings structure.

Arguments:

    HttpSettings - Set to point to the settings string which must be freed by the caller.

    H - Pointer to the filled-in HTTP_SETTINGS structure from which we will derive the settings string

Return Value:

    ERROR_SUCCESS
    ERROR_OUTOFMEMORY
--*/

{
    HRESULT hr;

    //
    // Loop through and create strings for each machine settings, calculate
    // the total length needed for them and concatenate
    //
    LPTSTR *MachineSettingsStrings = new LPTSTR[H->MachineSettingsCount];
    if (MachineSettingsStrings == NULL){
        return FALSE;
        }

    //
    // This loop fills in the array of machine settings and adds up the length
    //
    LPTSTR Str = NULL;
    ULONG TotalStrLen = 0;
    for (ULONG i = 0; i < H->MachineSettingsCount; i++){
        if (StringFromMachineSettings(&(H->MachineSettings[i]), &(MachineSettingsStrings[i])) == TRUE)
            {
            TotalStrLen += _tcslen(MachineSettingsStrings[i]);
            }
        else
            {
            for (; i>0; i--)
                {
                delete [] MachineSettingsStrings[i];
                }
            delete [] MachineSettingsStrings;
            return FALSE;
            }
        }

    //
    // This loop concatenates the strings stored in the MachineSettingsStrings array into the final
    // string which will be returned to the caller.
    //
    ULONG Len = TotalStrLen + H->MachineSettingsCount + 1;
    Str = new TCHAR[Len];
    *Str = _T('\0');
    *HttpSettings = Str;
    for (ULONG i = 0; i < H->MachineSettingsCount; i++){
        hr = StringCchCat(Str, Len, MachineSettingsStrings[i]);
        ASSERT(hr == S_OK);
        if (i != H->MachineSettingsCount-1){
            hr =StringCchCat(Str, Len, _T(";"));
            ASSERT(hr == S_OK);
            }
        delete [] MachineSettingsStrings[i];
        }

    return TRUE;
}

BOOL
RemoveMachineFromHttpSettings(
    IN LPTSTR MachineName,
    IN HTTP_SETTINGS *H
    )

/*++

Routine Description:

    Given a name, this function removes all port settings for that machine from
    the HTTP_SETTINGS structure.

Arguments:

    MachineName - Name for which all settings should be removed.

    H - Pointer to the filled-in HTTP_SETTINGS structure from which we will remove the specified settings

Return Value:

    True if there was a matching machine name.
--*/

{
    //
    // Find a matching machine entry, free it, copy the rest of the entries to 
    // keep the array contiguous.
    //

    for (ULONG i = 0; i < H->MachineSettingsCount; i++){
        if (_tcsicmp(MachineName, H->MachineSettings[i].MachineName) == 0){
            FreeMachineSettings(&(H->MachineSettings[i]));
            break;
            }
        }

    //
    // We didn't find a match, indicate by returning FALSE
    //
    if (i == H->MachineSettingsCount)
        return FALSE;

    //
    // This does the actual copy.  No need to copy if we deleted the end entry in the array.
    //
    if (i < (H->MachineSettingsCount-1))
        memcpy(&(H->MachineSettings[i]),
               &(H->MachineSettings[i+1]), 
               sizeof(MACHINE_SETTINGS)*((H->MachineSettingsCount - 1) - i)
               ); 

    H->MachineSettingsCount--;
    return TRUE;
}
            
BOOL 
HttpHandleAdd(
    IN OUT  LPTSTR  Arguments[],
    IN      ULONG   ArgCount
    )

/*++

Routine Description:

    This handler is called when the user enters 
    rpc http add <machine_name> <port_range> <port_range>...
    These settings are converted then converted to the appropriate
    set of <http_settings> string which is then concatenated to any
    <http_settings> string which is already present in the registry.
    So basic validation is done on the user input.  
    
Arguments:

    See the NetShell documentation for a description of the arguments.
    
Return Value:

    See the NetShell documentation for a description of the return value.

--*/

{
    MACHINE_SETTINGS M;
    LPTSTR HttpSettings = NULL;
    BOOL bStatus;
    //
    // Parse the input commands (array of strings, starting at dwCurrentIndex).
    // The first string is the machine name, subsequent strings are port ranges.
    // Initialize a MACHINE_SETTINGS structure, pull the machine name out of the arguments
    // and fill in the MACHINE_SETTINGS strucutre based off of the Machine name and remaing
    // arguments (port ranges).
    //
    if ( ArgCount < 2){
        _tprintf(_T("Error: Please enter rpccfg /? to see the proper syntax for this command.\n"));
        return FALSE;
        }
    
    InitializeMachineSettings(&M);
    bStatus = CreateMachineSettings(
                &M, 
                Arguments[0],      // First arg is machine name
                &(Arguments[1]),    // Remaining args are port settings
                ArgCount - 1   // -1 to account for machine name
                );
    if (!bStatus){
        return FALSE;
        }
    //    
    // Convert the MACHINE_SETTINGS to a valid <http_settings> string and
    // concatenate that to the existing settings and clean up.
    //
    bStatus = StringFromMachineSettings(&M, &HttpSettings);
    if (!bStatus){
        return FALSE;
        }

    bStatus = AppendHttpSettingsString(HttpSettings);
    delete [] HttpSettings;      
    if (!bStatus){ 
        return FALSE;
        }
    
    return TRUE;
}

BOOL 
HttpHandleDelete(
    IN OUT  LPTSTR  Arguments[],
    IN      ULONG   ArgCount
    )

/*++

Routine Description:

    This handler is called when the user enters 'rpc http delete <machine_name>')
    We get the current <http_settings> string from the registry, convert it to
    a HTTP_SETTINGS object, delete the MACHINE_SETTINGS for the specified <machine_name>,
    convert the HTTP_SETTINGS object back to an <http_settings> string and commit it to
    the registry.
    
Arguments:

    See the NetShell documentation for a description of the arguments.
    
Return Value:

    See the NetShell documentation for a description of the return value.

--*/

{
    BOOL bStatus;
    LPTSTR MachineName = NULL,
           HttpSettings = NULL;
    HTTP_SETTINGS H;
    
    //
    // We should be passed one argument, the machine name.  If there are no settings currently
    // for this machine name, return an error to the user.  Otherwise, remove the settings for
    // this machine name and write the new settings back to the registry.
    //
    if (ArgCount != 1){
        _tprintf(_T("Error: Please enter rpccfg /? to see the proper syntax for this command.\n"));
        return FALSE;
        }
    
    MachineName = Arguments[0]; 
    bStatus = GetHttpSettingsString(&HttpSettings);
    if (!bStatus){
        return FALSE;
        }
    // 
    // If there are no settings, then the machine name passed in couldn't possibly match anything
    // so return failure.
    //
    if ((HttpSettings == NULL) || (_tcslen(HttpSettings) == 0)){
        _tprintf(_T("Error: There are no settings for the specified machine name: \"%s\".\n"),MachineName);            
        return FALSE;
        }
    
    //
    // Convert the string to an HTTP_SETTINGS structure which we can manipulate
    //
    InitializeHttpSettings(&H);
    bStatus = StringToHttpSettings(HttpSettings, &H);
    delete [] HttpSettings;
    if (!bStatus){
        return FALSE;
        }
    
    //
    // Remove all instances of this machine name which exist in the HttpSettings.
    // If no match, return error.  If failure, return error.
    //
    bStatus = RemoveMachineFromHttpSettings(MachineName, &H);

    if (!bStatus){
        _tprintf(_T("Error: There are no settings for machine name: \"%s\".\n"),MachineName);    
        FreeHttpSettings(&H);
        return FALSE;
        }
    
    //
    // Get the new string from the HTTP_SETTINGS structure and commit it to the registry
    //
    bStatus = StringFromHttpSettings(&H, &HttpSettings); 
    if (!bStatus){
        return FALSE;
        }
    FreeHttpSettings(&H);
    
    bStatus = SetHttpSettingsString(HttpSettings);
    delete [] HttpSettings;
    if (!bStatus){
        return FALSE;
        }
    return TRUE;
}

BOOL
FormatColumns(
    IN ULONG Columns,
    IN ULONG *ColumnWidth,
    IN ULONG *Margins,
    IN LPTSTR *Strings,
    OUT LPTSTR *FormatedString,
    OUT ULONG *LinesCount
    )

/*++

Routine Description:

    This routine takes various parameters defining a column display and an array
    of strings (one for each column).  Based off this, a new string is created, and returned
    to the user (who is responsible for freeing it).  This string contains the input strings
    formated into columns.
    
Arguments:

    Columns - The number of columns.
    ColumnWidth - An array conatinaing on entry per column which specifies the number of charters
                  contained in the associated column.
    Margins - This contains the size of the right margin for each column, except for the last.  This 
              contains Columns-1 entries.

    Strings - An array of pointers to strings.  Each string is formated into its associated column.

    FormatedString - This holds the formated string composed of the input strings.

    Lines - The number of lines which the formated string spans (number of _T('\n')).

   
Return Value:

    ERROR_SUCCESS
    ERROR_OUTOFMEMORY
    
--*/
    
{

    //
    // Calculate the total length of the final output string.  First calculate the length of each string,
    // then calculate the total number of lines needed (max of the number of lines needed for each column).
    // The total length is (Sum of columns + Sum of margins + _T('\n')) * number of lines + _T('\0').  
    //
    ULONG *StrLengths = new ULONG[Columns];
    if (StrLengths == NULL){
        return FALSE;
        }
    ULONG MaxLines = 1;
    ULONG ColumnLenSum = 0;
    ULONG MarginLengthSum = 0;
    for (ULONG i = 0; i < Columns; i++){
        ULONG TmpLen = _tcslen(Strings[i]);
        StrLengths[i] = TmpLen;
        ULONG Lines = (TmpLen + ColumnWidth[i] - 1) / ColumnWidth[i];
        if (Lines > MaxLines){
            MaxLines = Lines;
            }
        if (i < Columns -1){
            MarginLengthSum += Margins[i];
            }
        ColumnLenSum += ColumnWidth[i];
        }


    ULONG TotalStrLen = (ColumnLenSum + MarginLengthSum +1)*MaxLines +1;                       
    LPTSTR Str = new TCHAR[TotalStrLen];
    if (Str == NULL){
        delete [] StrLengths;
        return FALSE;
        }
#ifdef UNICODE
    wmemset(Str, ' ', TotalStrLen);
#else
    memset(Str, ' ', TotalStrLen);
#endif
    
    //
    // Walk through the formated string and copy in the appropriate portion of each string per
    // column.  The margins are set using the width option in StringCchPrintf.  Each itteration
    // through the outer loop adds one formated line (and one \n) to the format string.  The inner
    // loop walks through each column.
    //
    ULONG NewLines = 0;
    LPTSTR TmpStrPtr = Str;
    ULONG *TmpColumnStringOffset = new ULONG[Columns];
    if (TmpColumnStringOffset == NULL){
        delete [] StrLengths;
        delete [] Str;
        return FALSE;
        }
        
    memset(TmpColumnStringOffset, 0x00, Columns * sizeof(ULONG));    
    for (ULONG Lines = 0; Lines < MaxLines; Lines++){
        for (ULONG i = 0; i < Columns; i++){    
            LPTSTR TmpColumnString = Strings[i];
            TmpColumnString = &(TmpColumnString[TmpColumnStringOffset[i]]);
            ULONG TmpColumnStringRemaining = StrLengths[i] - TmpColumnStringOffset[i];
            ULONG TmpColumnStringLenToCopy = MIN(TmpColumnStringRemaining, ColumnWidth[i]);
            if (TmpColumnStringLenToCopy != 0){
                _tcsncpy(TmpStrPtr, TmpColumnString, TmpColumnStringLenToCopy);
                TmpColumnStringOffset[i] += TmpColumnStringLenToCopy;
                }
            TmpStrPtr += ColumnWidth[i];
            if (i < Columns - 1){
                TmpStrPtr += Margins[i];
                }
            }
        *TmpStrPtr++ = _T('\n');
        NewLines++;
        }
    *TmpStrPtr = _T('\0');                                   

    *FormatedString = Str;
    delete [] StrLengths;
    delete [] TmpColumnStringOffset;

    *LinesCount = NewLines;
    return TRUE;
}

BOOL
PrintColumns(
    IN LPTSTR Str1,
    IN LPTSTR Str2
    )

/*++

Routine Description:

    This is just a wrapper around FormatColumns which passes in the correct parameters
    so that we print two columns, width 34, 43 with two spaces between them.  We also
    print out an empty line if the formated columns are multi-line.
    
Arguments:

    Str1 - Strings to be printed in columns 1 and 2 respectively.
    Str2 -
    
--*/

{
    BOOL bStatus;
    ULONG ColumnWidths[2];
    ULONG ColumnMargins;
    LPTSTR Strings[2];
    LPTSTR OutputString;
    ULONG Lines = 0;
    ColumnWidths[0] = 34;
    ColumnWidths[1] = 43;
    ColumnMargins = 2;
    Strings[0] = Str1;
    Strings[1] = Str2;
    bStatus = FormatColumns(
                2,
                ColumnWidths,
                &ColumnMargins,
                Strings,
                &OutputString,
                &Lines
                );
    if (!bStatus){
        return FALSE;
        }
    _tprintf(_T("%s"),OutputString);
    if (Lines > 1){
        _tprintf(_T("\n"));
        }

    delete [] OutputString;

    return TRUE;
}

BOOL 
HttpHandleShow(
    IN OUT  LPTSTR  Arguments[],
    IN      ULONG   ArgCount
    )

/*++

Routine Description:

    This handler retreives any existing http settings and displays them like this.
    

    Server Name                         Port Settings
    --------------------------------------------------------------------------------
    grigorik-dev1                       200 220-240
    yongqu                              200

    The server name will wrap as will the port settings.  Both will wrap within 
    there own column.  If any wrapping occurs, there will be a blank line after 
    the wrapped entry before the next entry.
    
Arguments:

    See the NetShell documentation for a description of the arguments.
    
Return Value:

    See the NetShell documentation for a description of the return value.

--*/

{

    //
    // Initialize the HTTP_SETTINGS struct, get the HttpSettings string, fill in
    // the HTTP_SETTINGS struct from the string and then display.
    //
    HTTP_SETTINGS H;
    LPTSTR HttpSettings = NULL;
    BOOL bStatus;
    HRESULT hr;

    InitializeHttpSettings(&H);
    bStatus = GetHttpSettingsString(&HttpSettings);
    if (!bStatus){
        return FALSE;
        }

    // If GetHttpSettingsString has succeeded, it has allocated HttpSettings.
    ASSERT(HttpSettings != NULL);

    if (_tcslen(HttpSettings) == 0){
        _tprintf(_T("There are no settings to display.\n"));
        return TRUE;
        }

    bStatus = StringToHttpSettings(HttpSettings, &H);
    if (!bStatus){
        return FALSE;
        }
    //
    // Display the settings.  First print the header than loop through and print each
    // MACHINE_SETTINGS.  The inner loop generates the PortSettings string for the current
    // MachineName.  Each itteration through the outer loop prints one potentially multi-lined
    // MACHINE_SETTINGS entry.
    //
    _tprintf(_T("Server Name                         Port Settings\n"));
    _tprintf(_T("-------------------------------------------------------------------------------\n"));

    for (ULONG i = 0; i < H.MachineSettingsCount; i++){
        MACHINE_SETTINGS *M = &(H.MachineSettings[i]);
        ULONG PortSettingsLen = (M->PortRangeCount * 32) +1;
        LPTSTR PortSettings = new TCHAR[PortSettingsLen]; // Approx max size of two dwords in decimal + space + hyphen
        if (PortSettings == NULL){
            delete HttpSettings;
            return FALSE;
            }
        *PortSettings = _T('\0');
        for (ULONG j = 0; j < M->PortRangeCount; j++){
            TCHAR PortString[16];
            _ltot(M->PortRanges[j].Lower, PortString, 10);
            hr = StringCchCat(PortSettings, PortSettingsLen, PortString);
            ASSERT(hr == S_OK);
            if (M->PortRanges[j].IsRange){
                hr = StringCchCat(PortSettings,PortSettingsLen, _T("-"));
                ASSERT(hr == S_OK);
                _ltot(M->PortRanges[j].Upper, PortString, 10);
                hr = StringCchCat(PortSettings, PortSettingsLen, PortString);
                ASSERT(hr == S_OK);
                }
            hr = StringCchCat(PortSettings, PortSettingsLen, _T(" "));            
            ASSERT(hr == S_OK);
            }       
        //
        // Print the machine name and port settings in a two column format
        //
        PrintColumns(M->MachineName, PortSettings);        
        delete [] PortSettings;
        }
               
    return TRUE;
}

BOOL 
HttpHandleSave(
    IN OUT  LPTSTR  Arguments[],
    IN      ULONG   ArgCount
    )

/*++

Routine Description:

    This handler retrieves the proxy settings from the registry and saves it to the
    specified file.
        
Arguments:

    See the NetShell documentation for a description of the arguments.
    
Return Value:

    See the NetShell documentation for a description of the return value.

--*/

{

    BOOL bStatus;
    //
    // We should be passed one argument, the file name.  
    //
    if ( ArgCount != 1){
        _tprintf(_T("Error: Please enter rpccfg /? to see the proper syntax for this command.\n"));
        return FALSE;
        }
    
    // 
    // Get the registry settings string and write its contents to a file.
    //

    LPTSTR HttpSettings;
    bStatus = GetHttpSettingsString(&HttpSettings);
    if (!bStatus){
        return FALSE;
        }
  
    // If GetHttpSettingsString has succeeded, it has allocated OldHttpSettings.
    ASSERT(HttpSettings != NULL);

    if (_tcslen(HttpSettings) == 0){
        _tprintf(_T("Error: No settings exist, the file will not be created.\n"));
        return FALSE;
        }

    HANDLE h;
    h = CreateFile(
            Arguments[0],  // file name
            GENERIC_WRITE,                   // access mode
            0,                              // share mode
            NULL,                           // SD
            CREATE_ALWAYS,                  // how to create
            FILE_ATTRIBUTE_NORMAL,          // file attributes
            NULL                            // handle to template file
            );
    
    if (h == INVALID_HANDLE_VALUE){
           _tprintf(_T("Error: Either the file could not be found or you do not have permission to write to the file.\n"));
           return FALSE;
        }

    ULONG Len = _tcslen(HttpSettings);
    Len = Len*sizeof(TCHAR);
    

    ULONG Dummy;
    bStatus = WriteFile(
                h,
                (LPCVOID)HttpSettings,
                Len,
                &Dummy,
                NULL
                );
    delete [] HttpSettings;

    CloseHandle(h);
    if (!bStatus){
        _tprintf(_T("Error: Either the file could not be found or you do not have permission to write to the file.\n"));
        return FALSE;
        }
    
    return TRUE;
}

BOOL 
HttpHandleLoad(
    IN OUT  LPTSTR  Arguments[],
    IN      ULONG   ArgCount
    )

/*++

Routine Description:

    This handler reads settings from the specified file and commits them to the registry.
        
Arguments:

    See the NetShell documentation for a description of the arguments.
    
Return Value:

    See the NetShell documentation for a description of the return value.

--*/

{
    //
    // Open the file, get its length and read the contents into a string.  Write
    // the string to the registry.
    //
    BOOL bStatus;
    HANDLE h;
    h = CreateFile(
            Arguments[0],  // file name
            GENERIC_READ,                   // access mode
            0,                              // share mode
            NULL,                           // SD
            OPEN_EXISTING,                  // how to create
            FILE_ATTRIBUTE_NORMAL,          // file attributes
            NULL                            // handle to template file
            );
    if (h == INVALID_HANDLE_VALUE){
           _tprintf(_T("Error: Either the file could not be found or you do not have permission to read the file.\n"));
           return FALSE;
        }

    ULONG FileSize = GetFileSize(h, NULL);

    LPVOID HttpSettings = new BYTE[FileSize+sizeof(TCHAR)];
    if (HttpSettings == NULL){
        CloseHandle(h);
        return FALSE;
        }

    memset(HttpSettings, 0x00, FileSize+sizeof(TCHAR));
    
    ULONG Dummy;
    bStatus = ReadFile(
                h,
                HttpSettings,
                FileSize,
                &Dummy,
                NULL
                );

    CloseHandle(h);
    if (!bStatus){
        _tprintf(_T("Error: Either the file could not be found or you do not have permission to read the file.\n"));
        delete [] HttpSettings;
        return FALSE;
        }

    bStatus = SetHttpSettingsString((LPTSTR)HttpSettings);
    delete [] HttpSettings;
    
    return bStatus;
}

VOID
DoHttpCommand(
    IN TCHAR Command,
    IN LPTSTR Arguments[],
    IN ULONG ArgCount
    )
/*++

Routine Description:

    This is the interface which rpccfg uses to execute an httpcfg command.  This function 
    just forwards the arguments and the argcount to the correct handler based on the command
    character passed in.  If the command is not recognized, then an error message is displayed.

Arguments:

    Command - This is used to specify which handler to execute, valid values are 'a' 'r' 'd' 'l' 's'
    Arguments[] - These are the argument strings to be passed to the handler, they are command specific.
    ArgCount - The number of argument strings contained in the arguments array.

--*/
{

    BOOL bResult;

    switch (Command)
        {
        case _T('a'):
            bResult = HttpHandleAdd(Arguments, ArgCount);
            break;

        case _T('r'):
            bResult = HttpHandleDelete(Arguments, ArgCount);
            break;

        case _T('d'):
            bResult = HttpHandleShow(Arguments, ArgCount);
            break;

        case _T('l'):
            bResult = HttpHandleLoad(Arguments, ArgCount);
            break;

        case _T('s'):
            bResult = HttpHandleSave(Arguments, ArgCount);
            break;

        default:
            _tprintf(_T("Error: The command was not recognized, please enter rpccfg /? for a list of valid commands.\n"));
            return;
        }

    if (!bResult){
        _tprintf(_T("The command did not complete successfully.\n"));
        }
        
    return;
}

VOID
DoHttpCommandA(
    IN CHAR Command,
    IN LPSTR Arguments[],
    IN ULONG ArgCount
    )
{
#ifdef UNICODE
    WCHAR CommandW = Command;
    LPWSTR *ArgumentsW = NULL;
    HRESULT hr;

    if (ArgCount != 0){
        ArgumentsW = new LPWSTR[ArgCount];
        if (ArgumentsW == NULL)
            {
            _tprintf(_T("Error: Out of memory.\n"));
            return;
            }
        }
    for (ULONG i = 0; i < ArgCount; i++){
        ULONG Len = strlen(Arguments[i]) + 1;
        ArgumentsW[i] = new WCHAR[Len];
        if (ArgumentsW[i] == NULL)
            {
            _tprintf(_T("Error: Out of memory.\n"));
            for (; i>0; i--)
                {
                delete [] ArgumentsW[i];
                }
            delete [] ArgumentsW;
            return;
            }
        hr = StringCchPrintf(ArgumentsW[i], Len, _T("%S"), Arguments[i]);
        ASSERT(hr == S_OK);
        }
    DoHttpCommand(CommandW, ArgumentsW, ArgCount);

    for (ULONG i = 0; i < ArgCount; i++){
        ULONG Len = strlen(Arguments[i]) + 1;
        delete [] ArgumentsW[i];
        }

#else
    DoHttpCommand(Command, Arguments, ArgCount);
#endif

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\rpcnsh\skeleton.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2002
//
//  File:       skeleton.cxx
//
//  History:
//         March 19th, 2002     mauricf     Created
//
//
//  This file defines the boiler plate implementation.  We define:
//      - our top level commands and command groups
//      - implement our context functions (start,stop commit etc)
//      - implement InitHelperDll (the one function we export directly)
//--------------------------------------------------------------------------


#include <windows.h>
#include <guiddef.h>
#include <stdlib.h>
#include <netsh.h>
#include <skeleton.h>
#include <handlers.hxx>


//Define all our top level commands (commands with no options)
static CMD_ENTRY g_TopLevelCmdTable[] =
{
    CREATE_CMD_ENTRY_EX_VER(ADD,       HandleAdd, (CMD_FLAG_LOCAL|CMD_FLAG_ONLINE|CMD_FLAG_PRIVATE),CheckServerOrGreater),
    CREATE_CMD_ENTRY_EX_VER(DELETE,    HandleDelete, (CMD_FLAG_LOCAL|CMD_FLAG_ONLINE|CMD_FLAG_PRIVATE),CheckServerOrGreater),
    CREATE_CMD_ENTRY_EX_VER(RESET,     HandleReset, (CMD_FLAG_LOCAL|CMD_FLAG_ONLINE|CMD_FLAG_PRIVATE),CheckServerOrGreater),
    CREATE_CMD_ENTRY_EX_VER(SHOW,      HandleShow, (CMD_FLAG_LOCAL|CMD_FLAG_ONLINE|CMD_FLAG_PRIVATE),CheckServerOrGreater)
};

const ULONG g_TopLevelCmdCount = 4;

HANDLE g_hModule = NULL; //Need this to print error messages and get
                         //string table strings

DWORD WINAPI
InitHelperDll(
    IN  DWORD     dwNetshVersion
    )
/*++
 
Routine Description:

    The InitHelperDll function is called by NetShell to perform an initial 
    loading of a helper.

Arguments:

Return Value:
    
--*/
{
    DWORD dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;


    // Attributes of this helper
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));
    attMyAttributes.guidHelper      = g_RPCNSHGuid; // GUID of this helper
    attMyAttributes.dwVersion       = RPCNSH_VERSION;
    attMyAttributes.pfnStart        = StartHelpers;
    attMyAttributes.pfnStop         = NULL;

    dwErr = RegisterHelper(NULL,
                           &attMyAttributes);

    g_hModule = GetModuleHandle("rpcnsh.dll");

    return dwErr;
}


DWORD WINAPI
StartHelpers(
    IN CONST GUID * pguidParent,
    IN DWORD        dwVersion
    )
/*++
 
Routine Description:

    The NS_HELPER_START_FN command is the start function for helpers. The start
    function provides an opportunity for helpers to register contexts, and is 
    registered in the RegisterContext function. 

Arguments:

Return Value:
    
--*/
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));
    attMyAttributes.pwszContext   = L"rpc";
    attMyAttributes.guidHelper    = g_RPCNSHGuid;
    attMyAttributes.dwVersion     = RPCNSH_VERSION;
    attMyAttributes.dwFlags       = CMD_FLAG_LOCAL;
    attMyAttributes.ulNumTopCmds  = g_TopLevelCmdCount;
    attMyAttributes.pTopCmds      = (CMD_ENTRY (*)[])&g_TopLevelCmdTable;
    attMyAttributes.ulNumGroups   = 0; 
    attMyAttributes.pCmdGroups    = NULL;
    attMyAttributes.pfnCommitFn   = NULL;
    attMyAttributes.pfnDumpFn     = NULL;
    attMyAttributes.pfnConnectFn  = NULL;

    dwErr = RegisterContext( &attMyAttributes );
    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\charconv\convbvt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       convbvt.cxx
//
//--------------------------------------------------------------------------

#include <precomp.hxx>
#include "CharConv.hxx"

int main()
{
	WCHAR wt1[] = L"Hello world!";
	WCHAR we[] = L"";
	char at1[] = "Hello world!";
	char ae[] = "";
	char abuf[100];
	WCHAR wbuf[100];
	CHeapUnicode hu;
	CHeapAnsi ha;
	CNlUnicode nu;
	CNlAnsi na;
	CStackUnicode su;
	CStackAnsi sa;
	USES_CONVERSION;

	// test heap conversions
	ATTEMPT_HEAP_W2A(ha, wt1);
	ASSERT(lstrcmpA(ha, at1) == 0);
	ATTEMPT_HEAP_A2W(hu, at1);
	ASSERT(lstrcmpW(hu, wt1) == 0);

	// test Nl conversions
	ATTEMPT_NL_W2A(na, wt1);
	ASSERT(lstrcmpA(na, at1) == 0);
	ATTEMPT_NL_A2W(nu, at1);
	ASSERT(lstrcmpW(nu, wt1) == 0);

	// test stack conversions
	ATTEMPT_STACK_W2A(sa, wt1);
	ASSERT(lstrcmpA(sa, at1) == 0);
	ATTEMPT_STACK_A2W(su, at1);
	ASSERT(lstrcmpW(su, wt1) == 0);
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\charconv\charconv.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       charconv.cxx
//
//--------------------------------------------------------------------------

#include <precomp.hxx>
#include "Charconv.hxx"

RPC_STATUS A2WAttachHelper(char *pszAnsi, WCHAR **ppUnicode)
{
	int nAnsiLength;
	ASSERT(pszAnsi != NULL);
	nAnsiLength = lstrlenA(pszAnsi) + 1;

	*ppUnicode = new WCHAR[nAnsiLength];
	if (*ppUnicode == NULL)
		return(RPC_S_OUT_OF_MEMORY);
	RtlMultiByteToUnicodeN(*ppUnicode, nAnsiLength * 2, NULL, pszAnsi, nAnsiLength);

	return(RPC_S_OK);
}

RPC_STATUS W2AAttachHelper(WCHAR *pUnicode, char **ppAnsi)
{
    int nUnicodeLength;
    ASSERT(pUnicode != NULL);

    NTSTATUS status;
    status = RtlUnicodeToMultiByteSize((unsigned long *)&nUnicodeLength, 
        pUnicode, lstrlenW(pUnicode) * 2);
    if (status)
        return RPC_S_INVALID_ARG;
    nUnicodeLength ++;

    *ppAnsi = new char[nUnicodeLength];
    if (*ppAnsi == NULL)
        return(RPC_S_OUT_OF_MEMORY);
    RtlUnicodeToMultiByteN(*ppAnsi, nUnicodeLength, NULL, pUnicode, nUnicodeLength * 2);

    return(RPC_S_OK);
}

RPC_STATUS CHeapUnicode::Attach(char *pszAnsi)
{
    ANSI_STRING AnsiString;
    NTSTATUS NtStatus;

    RtlInitAnsiString(&AnsiString, (PSZ)pszAnsi);
    NtStatus = RtlAnsiStringToUnicodeString(&m_UnicodeString, &AnsiString, TRUE);
    if (!NT_SUCCESS(NtStatus))
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}

RPC_STATUS CHeapAnsi::Attach(WCHAR *pszUnicode)
{
    UNICODE_STRING UnicodeString;
    NTSTATUS NtStatus;

    RtlInitUnicodeString(&UnicodeString, pszUnicode);
    NtStatus = RtlUnicodeStringToAnsiString(&m_AnsiString, &UnicodeString, TRUE);
    if (!NT_SUCCESS(NtStatus))
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\dbgcmd\dbgrpc.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    RpcDbg.cxx

Abstract:

    RPC Extended Debugging Utility

Author:

    Kamen Moutafov (kamenm)   11-30-99

Revision History:

--*/

#include <sysinc.h>

#include <CellDef.hxx>

// Usage

const char *USAGE = "-s <server> -p <protseq> -C <CallID> -I <IfStart>\n"
                    "-N <ProcNum> -P <ProcessID> -L <CellID1.CellID2>\n"
                    "-E <EndpointName> -T <ThreadID> -r <radix> -c -l -e -t -a\n"
                    "Exactly one of -c, -l, -e, -t, or -a have to be specified.\n"
                    "The valid combinations are:\n"
                    "-c [-C <CallID>] [-I <IfStart>] [-N <ProcNum>] [-P <ProcessID>]\n"
                    "-l -P <ProcessID> -L <CellID1.CellID2>\n"
                    "-e [-E <EndpointName>]\n"
                    "-t -P <ProcessID> [-T <ThreadID>]\n"
                    "-a [-C <CallID>] [-I <IfStart>] [-N <ProcNum>] [-P <ProcessID>]\n"
                    "-s, -p and -r are independent to the other options. -r affects\n"
                    "only options after it on the command line. Default is 16 (hex)";


// Error stuff

#define CHECK_RET(status, string) if (status)\
        {  printf("%s failed -- %lu (0x%08X)\n", string,\
                      (unsigned long)status, (unsigned long)status);\
        return (status); }

DWORD CallID = 0;
DWORD IfStart = 0;
DWORD ProcNum = RPCDBG_NO_PROCNUM_SPECIFIED;
DWORD ProcessID = 0;
DebugCellID CellID = {0, 0};
char *EndpointName = NULL;
DWORD ThreadID = 0;
char *Protseq = "ncacn_np";
char *NetworkAddr = NULL;
int radix = 16;
char *BindingEndpoint = 0;

enum tagChosenDebugAction
{
    cdaInvalid,
    cdaCallInfo,
    cdaDebugCellInfo,
    cdaEndpointInfo,
    cdaThreadInfo,
    cdaClientCallInfo
} ChosenDebugAction;

int Action = cdaInvalid;

BOOL CheckForCellID(void)
{
    if ((CellID.SectionID != 0) || (CellID.CellID != 0))
        {
        printf("A cell ID cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

BOOL CheckForEndpointName(void)
{
    if (EndpointName)
        {
        printf("An endpoint name cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

BOOL CheckForThreadID(void)
{
    if (ThreadID)
        {
        printf("A thread ID cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

BOOL CheckForCallID(void)
{
    if (CallID)
        {
        printf("A call ID cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

BOOL CheckForIfStart(void)
{
    if (IfStart)
        {
        printf("An interface UUID start cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

BOOL CheckForProcNum(void)
{
    if (ProcNum != RPCDBG_NO_PROCNUM_SPECIFIED)
        {
        printf("A procedure number cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

BOOL CheckForProcessID(void)
{
    if (ProcessID)
        {
        printf("A process ID cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

void __cdecl DumpToConsole(PCSTR lpFormat, ...)
{
    va_list arglist;

    va_start(arglist, lpFormat);
    vfprintf(stdout, lpFormat, arglist);
    va_end(arglist);
}


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t  Size)
{
    void PAPI * pvBuf;

    pvBuf = new char [Size];

    return(pvBuf);
}

void __RPC_API MIDL_user_free (void __RPC_FAR *Buf)
{
    delete (Buf);
}

const char *ValidProtocolSequences[] = {"ncacn_np", "ncacn_ip_tcp"};
const char *ValidEnpoints[] = {"epmapper", "135"};

#define ARRAY_SIZE_OF(a)    (sizeof(a) / sizeof(a[0]))

void ParseArgv(int argc, char **argv)
{
    int fMissingParm = 0;
    char *Name = *argv;
    char option;
    char *TempString;
    char *Delimiter;
    char *Ignored;
    BOOL fInvalidArg;
    int i;

    argc--;
    argv++;
    while(argc)
        {
        if (**argv != '/' &&
            **argv != '-')
            {
            printf("Invalid switch: %s\n", *argv);
            argc--;
            argv++;
            }
        else
            {
            option = argv[0][1];
            argc--;
            argv++;

            // Most switches require a second command line arg.
            if (argc < 1)
                fMissingParm = 1;

            switch(option)
                {
                case 'C':
                    // Requires a parameter.
                    if (fMissingParm)
                        {
                        break;
                        }
                    CallID = strtoul(*argv, &Ignored, radix);
                    argc--;
                    argv++;
                    break;
                case 'p':
                    // Requires a parameter.
                    if (fMissingParm)
                        {
                        break;
                        }
                    Protseq = *argv;
                    for (i = 0; i < ARRAY_SIZE_OF(ValidProtocolSequences); i ++)
                        {
                        if (_strcmpi(Protseq, ValidProtocolSequences[i]) == 0)
                            {
                            break;
                            }
                        }
                    if (i < ARRAY_SIZE_OF(ValidProtocolSequences))
                        {
                        BindingEndpoint = (char *) ValidEnpoints[i];
                        argc--;
                        argv++;
                        break;
                        }
                    else
                        {
                        printf("Invalid protocol sequence: %s\n", Protseq);
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                case 's':
                    // Requires a parameter.
                    if (fMissingParm)
                        {
                        break;
                        }
                    NetworkAddr = *argv;
                    argc--;
                    argv++;
                    break;
                case 'I':
                    // Requires a parameter.
                    if (fMissingParm)
                        {
                        break;
                        }
                    IfStart = strtoul(*argv, &Ignored, radix);
                    argc--;
                    argv++;
                    break;
                case 'N':
                    // Requires a parameter.
                    if (fMissingParm)
                        {
                        break;
                        }
                    ProcNum = strtoul(*argv, &Ignored, radix);
                    argc--;
                    argv++;
                    break;
                case 'L':
                    // Requires a parameter.
                    if (fMissingParm)
                        {
                        break;
                        }
                    TempString = *argv;
                    Delimiter = strchr(TempString, '.');
                    if (Delimiter == NULL)
                        {
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                    *Delimiter = 0;
                    Delimiter ++;
                    CellID.SectionID = (unsigned short)strtoul(TempString, &Ignored, radix);
                    CellID.CellID = (unsigned short)strtoul(Delimiter, &Ignored, radix);
                    argc--;
                    argv++;
                    break;
                case 'E':
                    // Requires a parameter.
                    if (fMissingParm)
                        {
                        break;
                        }
                    EndpointName = *argv;
                    argc--;
                    argv++;
                    break;
                case 'T':
                    // Requires a parameter.
                    if (fMissingParm)
                        {
                        break;
                        }
                    ThreadID = strtoul(*argv, &Ignored, radix);
                    argc--;
                    argv++;
                    break;
                case 'P':
                    // Requires a parameter.
                    if (fMissingParm)
                        {
                        break;
                        }
                    ProcessID = strtoul(*argv, &Ignored, radix);
                    argc--;
                    argv++;
                    break;
                case 'c':
                    if (Action != cdaInvalid)
                        {
                        printf("The action to be performed can be specified only once on the command line\n");
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                    Action = cdaCallInfo;
                    fMissingParm = 0;
                    break;
                case 'l':
                    if (Action != cdaInvalid)
                        {
                        printf("The action to be performed can be specified only once on the command line\n");
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                    Action = cdaDebugCellInfo;
                    fMissingParm = 0;
                    break;
                case 'e':
                    if (Action != cdaInvalid)
                        {
                        printf("The action to be performed can be specified only once on the command line\n");
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                    Action = cdaEndpointInfo;
                    fMissingParm = 0;
                    break;
                case 't':
                    if (Action != cdaInvalid)
                        {
                        printf("The action to be performed can be specified only once on the command line\n");
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                    Action = cdaThreadInfo;
                    fMissingParm = 0;
                    break;
                case 'a':
                    if (Action != cdaInvalid)
                        {
                        printf("The action to be performed can be specified only once on the command line\n");
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                    Action = cdaClientCallInfo;
                    fMissingParm = 0;
                    break;
                case 'r':
                    // Requires a parameter.
                    if (fMissingParm)
                        {
                        break;
                        }
                    radix = atoi(*argv);
                    argc--;
                    argv++;
                    break;
                default:
                    fMissingParm = 0;
                    printf("Usage: %s: %s\n", Name, USAGE);
                    exit(2);
                    break;
                }

            if (fMissingParm)
                {
                printf("Switch %s, missing required parameter\n", *(argv-1));
                exit(2);
                }
            }
        } // while argc

    // verify that the options are consistent
    fInvalidArg = FALSE;
    switch (Action)
        {
        case cdaInvalid:
            printf("The action to be performed should be specified exactly once on the command line\n");
            printf("Usage: %s: %s\n", Name, USAGE);
            exit(2);

        case cdaCallInfo:
        case cdaClientCallInfo:
            fInvalidArg = CheckForCellID();
            fInvalidArg |= CheckForEndpointName();
            fInvalidArg |= CheckForThreadID();

            if (fInvalidArg)
                {
                printf("Usage: %s: %s\n", Name, USAGE);
                exit(2);
                }
            break;

        case cdaDebugCellInfo:
            if ((CellID.SectionID == 0) && (CellID.CellID == 0))
                {
                printf("A cell ID must be specified for this action\n");
                fInvalidArg = TRUE;
                }

            if (ProcessID == 0)
                {
                printf("A process ID must be specified for this action\n");
                fInvalidArg = TRUE;
                }

            fInvalidArg |= CheckForEndpointName();
            fInvalidArg |= CheckForThreadID();
            fInvalidArg |= CheckForCallID();
            fInvalidArg |= CheckForIfStart();
            fInvalidArg |= CheckForProcNum();

            if (fInvalidArg)
                {
                printf("Usage: %s: %s\n", Name, USAGE);
                exit(2);
                }
            break;

        case cdaEndpointInfo:

            fInvalidArg |= CheckForCellID();
            fInvalidArg |= CheckForThreadID();
            fInvalidArg |= CheckForCallID();
            fInvalidArg |= CheckForIfStart();
            fInvalidArg |= CheckForProcNum();
            fInvalidArg |= CheckForProcessID();

            if (fInvalidArg)
                {
                printf("Usage: %s: %s\n", Name, USAGE);
                exit(2);
                }
            break;

        case cdaThreadInfo:
            if (ProcessID == 0)
                {
                printf("A process ID must be specified for this action\n");
                fInvalidArg = TRUE;
                }

            fInvalidArg |= CheckForCellID();
            fInvalidArg |= CheckForCallID();
            fInvalidArg |= CheckForIfStart();
            fInvalidArg |= CheckForProcNum();
            if (fInvalidArg)
                {
                printf("Usage: %s: %s\n", Name, USAGE);
                exit(2);
                }
            break;

        default:
            printf("Internal error. Chosen action is %d\n", Action);
            exit(2);
        }
}

/*
RPC_STATUS DoRpcBindingSetAuthInfo(handle_t Binding)
{
    if (AuthnLevel != RPC_C_AUTHN_LEVEL_NONE)
        return RpcBindingSetAuthInfo(Binding,
                                     NULL,
                                     AuthnLevel,
                                     ulSecurityPackage,
                                     NULL,
                                     RPC_C_AUTHZ_NONE);
    else
        return(RPC_S_OK);
}

unsigned long Worker(unsigned long l)
{
    unsigned long status;
    unsigned long Test;
    unsigned long ClientId;
    unsigned long InSize, OutSize;
    unsigned long Time, Calls;
    char __RPC_FAR *pBuffer;
    char __RPC_FAR *stringBinding;
    handle_t binding;
    RPC_STATUS RpcErr;
    int Retries;

    pBuffer = MIDL_user_allocate(128*1024L);
    if (pBuffer == 0)
        {
        PrintToConsole("Out of memory!");
        return 1;
        }

    status =
    RpcStringBindingComposeA(0,
                            Protseq,
                            NetworkAddr,
                            Endpoint,
                            0,
                            &stringBinding);
    CHECK_RET(status, "RpcStringBindingCompose");

    status =
    RpcBindingFromStringBindingA(stringBinding, &binding);
    CHECK_RET(status, "RpcBindingFromStringBinding");

    status =
    DoRpcBindingSetAuthInfo(binding);
    CHECK_RET(status, "RpcBindingSetAuthInfo");

    RpcStringFreeA(&stringBinding);

    Retries = 15;

    do
        {
        status = BeginTest(binding, &ClientId, &Test, &InSize, &OutSize);

        if (status == PERF_TOO_MANY_CLIENTS)
            {
            PrintToConsole("Too many clients, I'm exiting\n");
            goto Cleanup ;
            }

        Retries --;
        if ((status == RPC_S_SERVER_UNAVAILABLE) && (Retries > 0))
            {
            PrintToConsole("Server too busy - retrying ...\n");
            }
        }
    while ((status == RPC_S_SERVER_UNAVAILABLE) && (Retries > 0));

    CHECK_RET(status, "ClientConnect");

    if (InSize > IN_ADJUSTMENT)
        {
        InSize -= IN_ADJUSTMENT;
        }
    else
        {
        InSize = 0;
        }

    if (OutSize > OUT_ADJUSTMENT)
        {
        OutSize -= OUT_ADJUSTMENT;
        }
    else
        {
        OutSize = 0;
        }

    gInSize = InSize;
    gOutSize = OutSize;

    PrintToConsole("Client %ld connected\n", ClientId);

    Retries = 15;

    do
        {
        RpcTryExcept
            {
            RpcErr = RPC_S_OK;

            Time = GetTickCount();

            Calls = ( (TestTable[Test])(binding, ClientId, pBuffer) );

            Time = GetTickCount() - Time;
       
            Dump("Completed %d calls in %d ms\n"
                   "%d T/S or %3d.%03d ms/T\n\n",
                   Calls,
                   Time,
                   (Calls * 1000) / Time,
                   Time / Calls,
                   ((Time % Calls) * 1000) / Calls
                   );
            }
        RpcExcept(1)
            {
            RpcErr = (unsigned long)RpcExceptionCode();
            PrintToConsole("\nException %lu (0x%08lX)\n",
                       RpcErr, RpcErr);
            }
        RpcEndExcept
        Retries --;
        if ((RpcErr == RPC_S_SERVER_UNAVAILABLE) && (Retries > 0))
            {
            PrintToConsole("Server too busy - retrying ...\n");
            }
        }
    while ((RpcErr == RPC_S_SERVER_UNAVAILABLE) && (Retries > 0));

Cleanup:
    RpcBindingFree(&binding);
    return status;
}
*/

////////////////////////////////////////////////////////////////////
/// Local representation to wire representation translation routines
////////////////////////////////////////////////////////////////////
BOOL TranslateRemoteCallInfoToLocalCallInfo(IN RemoteDebugCallInfo *RemoteCallInfo, 
                                            OUT DebugCallInfo *LocalDebugInfo)
{
    LocalDebugInfo->Type = RemoteCallInfo->Type;
    LocalDebugInfo->Status = RemoteCallInfo->Status;
    LocalDebugInfo->ProcNum = RemoteCallInfo->ProcNum;
    LocalDebugInfo->InterfaceUUIDStart = RemoteCallInfo->InterfaceUUIDStart;
    LocalDebugInfo->ServicingTID = RemoteCallInfo->ServicingTID;
    LocalDebugInfo->CallFlags = RemoteCallInfo->CallFlags;
    LocalDebugInfo->CallID = RemoteCallInfo->CallID;
    LocalDebugInfo->LastUpdateTime = RemoteCallInfo->LastUpdateTime;
    if (RemoteCallInfo->ConnectionType == crtLrpcConnection)
        {
        ASSERT(LocalDebugInfo->CallFlags & DBGCELL_LRPC_CALL);
        LocalDebugInfo->Connection = RemoteCallInfo->connInfo.Connection;
        }
    else if (RemoteCallInfo->ConnectionType == crtOsfConnection)
        {
        LocalDebugInfo->PID = RemoteCallInfo->connInfo.Caller.PID;
        LocalDebugInfo->TID = RemoteCallInfo->connInfo.Caller.TID;
        }
    else
        {
        PrintToConsole("Invalid type for call info connection type: %d\n", 
            RemoteCallInfo->ConnectionType);
        return FALSE;
        }
    return TRUE;
}

void TranslateRemoteEndpointInfoToLocalEndpointInfo(IN RemoteDebugEndpointInfo *RemoteEndpointInfo, 
                                                    OUT DebugEndpointInfo *LocalDebugInfo)
{
    LocalDebugInfo->Type = RemoteEndpointInfo->Type;
    LocalDebugInfo->ProtseqType = RemoteEndpointInfo->ProtseqType;
    LocalDebugInfo->Status = RemoteEndpointInfo->Status;

    if (RemoteEndpointInfo->EndpointName)
        {
        memcpy(LocalDebugInfo->EndpointName,
            RemoteEndpointInfo->EndpointName,
            DebugEndpointNameLength);
        MIDL_user_free(RemoteEndpointInfo->EndpointName);
        RemoteEndpointInfo->EndpointName = 0;
        }
    else
        LocalDebugInfo->EndpointName[0] = 0;
}

void TranslateRemoteThreadInfoToLocalThreadInfo(IN RemoteDebugThreadInfo *RemoteThreadInfo, 
                                                OUT DebugThreadInfo *LocalDebugInfo)
{
    LocalDebugInfo->Type = RemoteThreadInfo->Type;
    LocalDebugInfo->Status = RemoteThreadInfo->Status;
    LocalDebugInfo->LastUpdateTime = RemoteThreadInfo->LastUpdateTime;
    LocalDebugInfo->TID = RemoteThreadInfo->TID;
    LocalDebugInfo->Endpoint = RemoteThreadInfo->Endpoint;
}

void TranslateRemoteClientCallInfoToLocalClientCallInfo(IN RemoteDebugClientCallInfo *RemoteClientCallInfo, 
                                                        OUT DebugClientCallInfo *LocalDebugInfo)
{
    LocalDebugInfo->Type = RemoteClientCallInfo->Type;
    LocalDebugInfo->ProcNum = RemoteClientCallInfo->ProcNum;
    LocalDebugInfo->ServicingThread = RemoteClientCallInfo->ServicingThread;
    LocalDebugInfo->IfStart = RemoteClientCallInfo->IfStart;
    LocalDebugInfo->CallID = RemoteClientCallInfo->CallID;
    LocalDebugInfo->CallTargetID = RemoteClientCallInfo->CallTargetID;

    if (RemoteClientCallInfo->Endpoint)
        {
        memcpy(LocalDebugInfo->Endpoint,
            RemoteClientCallInfo->Endpoint,
            ClientCallEndpointLength);
        MIDL_user_free(RemoteClientCallInfo->Endpoint);
        RemoteClientCallInfo->Endpoint = 0;
        } 
    else
        LocalDebugInfo->Endpoint[0] = 0;
}

void TranslateRemoteConnectionInfoToLocalConnectionInfo(IN RemoteDebugConnectionInfo *RemoteConnectionInfo, 
                                                        OUT DebugConnectionInfo *LocalDebugInfo)
{
    LocalDebugInfo->Type = RemoteConnectionInfo->Type;
    LocalDebugInfo->Flags = RemoteConnectionInfo->Flags;
    LocalDebugInfo->LastTransmitFragmentSize = 
        RemoteConnectionInfo->LastTransmitFragmentSize;
    LocalDebugInfo->Endpoint = RemoteConnectionInfo->Endpoint;
    LocalDebugInfo->ConnectionID[0] = ULongToPtr(RemoteConnectionInfo->ConnectionID[0]);
    LocalDebugInfo->ConnectionID[1] = ULongToPtr(RemoteConnectionInfo->ConnectionID[1]);
    LocalDebugInfo->LastSendTime = RemoteConnectionInfo->LastSendTime;
    LocalDebugInfo->LastReceiveTime = RemoteConnectionInfo->LastReceiveTime;
}

void TranslateRemoteCallTargetInfoToLocalCallTargetInfo(IN RemoteDebugCallTargetInfo *RemoteCallTargetInfo, 
                                                        OUT DebugCallTargetInfo *LocalDebugInfo)
{
    LocalDebugInfo->Type = RemoteCallTargetInfo->Type;
    LocalDebugInfo->ProtocolSequence = RemoteCallTargetInfo->ProtocolSequence;
    LocalDebugInfo->LastUpdateTime = RemoteCallTargetInfo->LastUpdateTime;

    if (RemoteCallTargetInfo->TargetServer)
        {
        memcpy(LocalDebugInfo->TargetServer, RemoteCallTargetInfo->TargetServer,
            TargetServerNameLength);
        MIDL_user_free(RemoteCallTargetInfo->TargetServer);
        RemoteCallTargetInfo->TargetServer = 0;
        }
}

BOOL TranslateRemoteDebugCellInfoToLocalDebugCellInfo(RemoteDebugCellUnion *RemoteCellInfo, 
                                                      DebugCellUnion *Container)
{
    switch (RemoteCellInfo->UnionType)
        {
        case dctCallInfo:
            return TranslateRemoteCallInfoToLocalCallInfo(&RemoteCellInfo->debugInfo.callInfo,
                &Container->callInfo);
            break;

        case dctThreadInfo:
            TranslateRemoteThreadInfoToLocalThreadInfo(&RemoteCellInfo->debugInfo.threadInfo,
                &Container->threadInfo);
            break;

        case dctEndpointInfo:
            TranslateRemoteEndpointInfoToLocalEndpointInfo(&RemoteCellInfo->debugInfo.endpointInfo,
                &Container->endpointInfo);
            break;

        case dctClientCallInfo:
            TranslateRemoteClientCallInfoToLocalClientCallInfo(&RemoteCellInfo->debugInfo.clientCallInfo,
                &Container->clientCallInfo);
            break;

        case dctConnectionInfo:
            TranslateRemoteConnectionInfoToLocalConnectionInfo(&RemoteCellInfo->debugInfo.connectionInfo,
                &Container->connectionInfo);
            break;

        case dctCallTargetInfo:
            TranslateRemoteCallTargetInfoToLocalCallTargetInfo(&RemoteCellInfo->debugInfo.callTargetInfo,
                &Container->callTargetInfo);
            break;

        default:
            PrintToConsole("Invalid debug cell type: %d\n", RemoteCellInfo->UnionType);
            return FALSE;
        }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
/// Helper routines for enumerating remote information
//////////////////////////////////////////////////////////////////////////////
void GetAndPrintRemoteCallInfo(IN handle_t Binding)
{
    RemoteDebugCallInfo *RemoteCallInfo;
    DebugCellID CellID;
    DbgCallEnumHandle rh;
    DebugCallInfo LocalCallInfo;
    RPC_STATUS Status;

    RemoteCallInfo = NULL;
    DumpToConsole("Getting remote call info ...\n");

    RpcTryExcept
        {
        Status = RemoteOpenRPCDebugCallInfoEnumeration(Binding, &rh, CallID, IfStart, ProcNum, ProcessID);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    if (Status != RPC_S_OK)
        {
        DumpToConsole("RemoteOpenRPCDebugCallInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintCallInfoHeader(DumpToConsole);
    do
        {
        RemoteCallInfo = NULL;
        RpcTryExcept
            {
            Status = RemoteGetNextRPCDebugCallInfo(rh, &RemoteCallInfo, &CellID, &ProcessID);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            Status = RpcExceptionCode();
            }
        RpcEndExcept
        if (Status == RPC_S_OK)
            {
            TranslateRemoteCallInfoToLocalCallInfo(RemoteCallInfo, &LocalCallInfo);
            MIDL_user_free(RemoteCallInfo);
            PrintCallInfoBody(ProcessID, CellID, &LocalCallInfo, DumpToConsole);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        DumpToConsole("Enumeration aborted with error %d\n", Status);
        }

    RpcTryExcept
        {
        RemoteFinishRPCDebugCallInfoEnumeration(&rh);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
}

void GetAndPrintRemoteEndpointInfo(IN handle_t Binding)
{
    DWORD CurrentPID;
    RPC_STATUS Status;
    DebugEndpointInfo EndpointInfo;
    RemoteDebugEndpointInfo *RemoteEndpointInfo;
    DbgEndpointEnumHandle rh;
    DebugCellID CellID;

    DumpToConsole("Getting remote endpoint info ...\n");
    RpcTryExcept
        {
        Status = RemoteOpenRPCDebugEndpointInfoEnumeration(Binding, &rh, 
            (EndpointName != NULL) ? (strlen(EndpointName) + 1) : 0, 
            (unsigned char *) EndpointName);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    if (Status != RPC_S_OK)
        {
        DumpToConsole("RemoteOpenRPCDebugEndpointInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintEndpointInfoHeader(DumpToConsole);
    do
        {
        RemoteEndpointInfo = NULL;
        RpcTryExcept
            {
            Status = RemoteGetNextRPCDebugEndpointInfo(rh, &RemoteEndpointInfo, &CellID, &CurrentPID);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            Status = RpcExceptionCode();
            }
        RpcEndExcept
        if (Status == RPC_S_OK)
            {
            TranslateRemoteEndpointInfoToLocalEndpointInfo(RemoteEndpointInfo, &EndpointInfo);
            MIDL_user_free(RemoteEndpointInfo);
            PrintEndpointInfoBody(CurrentPID, CellID, &EndpointInfo, DumpToConsole);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        DumpToConsole("Enumeration aborted with error %d\n", Status);
        }

    RpcTryExcept
        {
        RemoteFinishRPCDebugEndpointInfoEnumeration(&rh);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
}

void GetAndPrintRemoteThreadInfo(IN handle_t Binding)
{
    RPC_STATUS Status;
    DbgThreadEnumHandle rh;
    RemoteDebugThreadInfo *RemoteThreadInfo;
    DebugThreadInfo LocalThreadInfo;
    DebugCellID CellID;
    DWORD CurrentPID;

    DumpToConsole("Getting remote thread info ...\n");
    RpcTryExcept
        {
        Status = RemoteOpenRPCDebugThreadInfoEnumeration(Binding, &rh, ProcessID, ThreadID);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    if (Status != RPC_S_OK)
        {
        DumpToConsole("RemoteOpenRPCDebugThreadInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintThreadInfoHeader(DumpToConsole);
    do
        {
        RemoteThreadInfo = NULL;
        RpcTryExcept
            {
            Status = RemoteGetNextRPCDebugThreadInfo(rh, &RemoteThreadInfo, &CellID, &CurrentPID);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            Status = RpcExceptionCode();
            }
        RpcEndExcept
        if (Status == RPC_S_OK)
            {
            TranslateRemoteThreadInfoToLocalThreadInfo(RemoteThreadInfo, &LocalThreadInfo);
            MIDL_user_free(RemoteThreadInfo);
            PrintThreadInfoBody(CurrentPID, CellID, &LocalThreadInfo, DumpToConsole);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        DumpToConsole("Enumeration aborted with error %d\n", Status);
        }

    RpcTryExcept
        {
        RemoteFinishRPCDebugThreadInfoEnumeration(&rh);    
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
}

void GetAndPrintRemoteClientCallInfo(IN handle_t Binding)
{
    DWORD CurrentPID;
    DebugCellID CellID;

    DebugClientCallInfo LocalClientCall;
    DebugCallTargetInfo LocalCallTarget;

    RemoteDebugClientCallInfo *RemoteClientCallInfo;
    RemoteDebugCallTargetInfo *RemoteCallTargetInfo;

    RPC_STATUS Status;
    DbgClientCallEnumHandle rh;

    DumpToConsole("Getting remote call info ...\n");
    RpcTryExcept
        {
        Status = RemoteOpenRPCDebugClientCallInfoEnumeration(Binding, &rh, CallID, IfStart, ProcNum, ProcessID);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    if (Status != RPC_S_OK)
        {
        DumpToConsole("RemoteOpenRPCDebugClientCallInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintClientCallInfoHeader(DumpToConsole);
    do
        {
        RemoteClientCallInfo = NULL;
        RemoteCallTargetInfo = NULL;

        RpcTryExcept
            {
            Status = RemoteGetNextRPCDebugClientCallInfo(rh, &RemoteClientCallInfo, &RemoteCallTargetInfo, 
                &CellID, &CurrentPID);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            Status = RpcExceptionCode();
            }
        RpcEndExcept
        if (Status == RPC_S_OK)
            {
            if ((RemoteCallTargetInfo != NULL) && (RemoteCallTargetInfo->Type != dctCallTargetInfo))
                {
                DumpToConsole("Inconsistent information detected - skipping ...\n");
                MIDL_user_free(RemoteClientCallInfo);
                MIDL_user_free(RemoteCallTargetInfo);
                continue;
                }

            TranslateRemoteClientCallInfoToLocalClientCallInfo(RemoteClientCallInfo, &LocalClientCall);
            MIDL_user_free(RemoteClientCallInfo);
            TranslateRemoteCallTargetInfoToLocalCallTargetInfo(RemoteCallTargetInfo, &LocalCallTarget);
            MIDL_user_free(RemoteCallTargetInfo);
            PrintClientCallInfoBody(CurrentPID, CellID, &LocalClientCall, &LocalCallTarget,
                DumpToConsole);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        DumpToConsole("Enumeration aborted with error %d\n", Status);
        }

    RpcTryExcept
        {
        RemoteFinishRPCDebugClientCallInfoEnumeration(&rh);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
}

int __cdecl
main (int argc, char **argv)
{
    unsigned long Status, i;
    unsigned char *StringBinding;
    handle_t Binding;
    RemoteDebugCellUnion *RemoteDebugCell;
    DebugCellUnion Container;
    DebugCellUnion EndpointContainer;
    DebugCellUnion *EndpointContainerPointer;
    BOOL fResult;

    ParseArgv(argc, argv);

    // by now, we must have all valid arguments. Depending on local/remote
    // case and on action chosen, we actually do the work
    if (NetworkAddr == NULL)
        {
        // in local case, just do the work
        switch (Action)
            {
            case cdaCallInfo:
                GetAndPrintCallInfo(CallID, IfStart, ProcNum, ProcessID, DumpToConsole);
                break;

            case cdaClientCallInfo:
                GetAndPrintClientCallInfo(CallID, IfStart, ProcNum, ProcessID, DumpToConsole);
                break;

            case cdaDebugCellInfo:
                GetAndPrintDbgCellInfo(ProcessID, CellID, DumpToConsole);
                break;

            case cdaEndpointInfo:
                GetAndPrintEndpointInfo(EndpointName, DumpToConsole);
                break;

            case cdaThreadInfo:
                GetAndPrintThreadInfo(ProcessID, ThreadID, DumpToConsole);
                break;

            }
        }
    else
        {
        Status = RpcStringBindingComposeA(0, (unsigned char *)Protseq, 
            (unsigned char *)NetworkAddr, (unsigned char *)BindingEndpoint, 0, &StringBinding);
        CHECK_RET(Status, "RpcStringBindingCompose");

        Status = RpcBindingFromStringBindingA(StringBinding, &Binding);
        CHECK_RET(Status, "RpcBindingFromStringBinding");

        RpcStringFreeA(&StringBinding);

        Status = RpcBindingSetAuthInfo(Binding, NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_AUTHN_GSS_NEGOTIATE,
                                     NULL, RPC_C_AUTHZ_NONE);
        CHECK_RET(Status, "RpcBindingSetAuthInfo");

        // in remote case, call the remote RPCSS
        switch (Action)
            {
            case cdaCallInfo:
                GetAndPrintRemoteCallInfo(Binding);
                break;

            case cdaClientCallInfo:
                GetAndPrintRemoteClientCallInfo(Binding);
                break;

            case cdaDebugCellInfo:
                RemoteDebugCell = NULL;
                DumpToConsole("Getting remote cell info ...\n");
                RpcTryExcept
                    {
                    Status = RemoteGetCellByDebugCellID(Binding, ProcessID, CellID, &RemoteDebugCell);
                    }
                RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
                    {
                    Status = RpcExceptionCode();
                    }
                RpcEndExcept

                if (Status != RPC_S_OK)
                    {
                    DumpToConsole("Remote call failed with error %d\n", Status);
                    break;
                    }

                // get back the idl representation into a DbgCell representation
                fResult = TranslateRemoteDebugCellInfoToLocalDebugCellInfo(RemoteDebugCell, &Container);

                MIDL_user_free(RemoteDebugCell);

                // if FALSE is returned, error info should have already been printed out
                if (!fResult)
                    break;

                if (Container.genericCell.Type == dctConnectionInfo)
                    {
                    RemoteDebugCell = NULL;

                    DumpToConsole("Getting remote endpoint info for connection ...\n");

                    RpcTryExcept
                        {
                        Status = RemoteGetCellByDebugCellID(Binding, ProcessID, 
                            Container.connectionInfo.Endpoint, &RemoteDebugCell);
                        }
                    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
                        {
                        Status = RpcExceptionCode();
                        }
                    RpcEndExcept

                    if (Status != RPC_S_OK)
                        {
                        DumpToConsole("Remote call failed with error %d\n", Status);
                        break;
                        }

                    fResult = TranslateRemoteDebugCellInfoToLocalDebugCellInfo(RemoteDebugCell,
                        &EndpointContainer);

                    MIDL_user_free(RemoteDebugCell);

                    if (!fResult)
                        break;

                    EndpointContainerPointer = &EndpointContainer;
                    }
                else
                    EndpointContainerPointer = NULL;

                PrintDbgCellInfo(&Container, EndpointContainerPointer, DumpToConsole);
                break;

            case cdaEndpointInfo:
                GetAndPrintRemoteEndpointInfo(Binding);
                break;

            case cdaThreadInfo:
                GetAndPrintRemoteThreadInfo(Binding);
                break;

            }

        RpcBindingFree(&Binding);
        }

    /*
    PrintToConsole("Authentication Level is: %s\n", AuthnLevelStr);

    if (Options[0] < 0)
        Options[0] = 1;

    pClientThreads = MIDL_user_allocate(sizeof(HANDLE) * Options[0]);

    for(i = 0; i < (unsigned long)Options[0]; i++)
        {
        pClientThreads[i] = CreateThread(0,
                                         0,
                                         (LPTHREAD_START_ROUTINE)Worker,
                                         0,
                                         0,
                                         &status);
        if (pClientThreads[i] == 0)
            ApiError("CreateThread", GetLastError());
        }


    status = WaitForMultipleObjects(Options[0],
                                    pClientThreads,
                                    TRUE,  // Wait for all client threads
                                    INFINITE);
    if (status == WAIT_FAILED)
        {
        ApiError("WaitForMultipleObjects", GetLastError());
        }
        */
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\dbglib\cellutil.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CellUtil.cxx

Abstract:

    Utility functions for manipulating cells

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>
#include <DbgLib.hxx>

DebugCellUnion *GetCellByIndex(IN OpenedDbgSection *pSection, IN DWORD CellIndex)
{
    DWORD LocalPageSize = GetPageSize();
    DebugCellGeneric *LastCellForSection;
    DebugCellGeneric *CurrentCell;

    ASSERT(pSection != NULL);
    ASSERT(pSection->SectionCopy != NULL);

#ifdef _WIN64
    if (CellIndex <= 1)
        return NULL;
#else
    if (CellIndex == 0)
        return NULL;
#endif

    LastCellForSection = GetLastCellForSection(pSection, LocalPageSize);
    CurrentCell = GetCellForSection(pSection, CellIndex);

    // Check if we we were asked to retrieve a cell that is
    // outside the range of the section.
    if (CurrentCell <= LastCellForSection)
        {
        return (DebugCellUnion *) CurrentCell;
        }
    else
        {
        ASSERT(0);
        return NULL;
        }
}

DebugCellUnion *GetCellByDebugCellID(IN CellEnumerationHandle CellEnumHandle, IN DebugCellID CellID)
{
    SectionsSnapshot *Snapshot;
    OpenedDbgSection *CurrentSection;
    DebugCellUnion *Cell = NULL;

    Snapshot = (SectionsSnapshot *)CellEnumHandle;

    ASSERT(Snapshot != NULL);

    CurrentSection = Snapshot->FirstOpenedSection;
    while (TRUE)
        {
        if (CurrentSection->SectionID == CellID.SectionID)
            {
            Cell = GetCellByIndex(CurrentSection, CellID.CellID);
            break;
            }

        if (CurrentSection->SectionsList.Flink == NULL)
            break;

        CurrentSection = CONTAINING_RECORD(CurrentSection->SectionsList.Flink, OpenedDbgSection, SectionsList);
        }

    return Cell;
}

RPC_STATUS GetCellByDebugCellID(IN DWORD ProcessID, IN DebugCellID CellID, OUT DebugCellUnion *Container)
{
    RPC_STATUS Status;
    CellEnumerationHandle CellEnumHandle;
    DebugCellUnion *Cell;

    ASSERT(Container != NULL);
    Status = OpenRPCServerDebugInfo(ProcessID, &CellEnumHandle);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    Cell = GetCellByDebugCellID(CellEnumHandle, CellID);
    if (Cell)
        {
        memcpy(Container, Cell, sizeof(DebugCellUnion));
        }
    else
        Status = ERROR_FILE_NOT_FOUND;

    CloseRPCServerDebugInfo(&CellEnumHandle);
    return Status;
}

/////////////////////////////////////////////////////
typedef struct tagRPCDebugCallInfoEnumState
{
    DWORD CallID;
    DWORD IfStart;
    int ProcNum;
    DWORD ProcessID;
    union
        {
        // if ProcessID != 0, cellEnum is used (i.e. we have process wide enumeration
        // otherwise, systemWideEnum is used - we have system wide enumeration
        RPCSystemWideCellEnumerationHandle systemWideEnum;
        CellEnumerationHandle cellEnum;
        };
} RPCDebugCallInfoEnumState;

RPC_STATUS OpenRPCDebugCallInfoEnumeration(IN DWORD CallID OPTIONAL, IN DWORD IfStart OPTIONAL, 
                                           IN int ProcNum OPTIONAL,
                                           IN DWORD ProcessID OPTIONAL, 
                                           OUT CallInfoEnumerationHandle *pHandle)
{
    RPCDebugCallInfoEnumState *pCallEnumeration;
    RPC_STATUS Status;

    *pHandle = NULL;
    pCallEnumeration = new RPCDebugCallInfoEnumState;
    if (pCallEnumeration == NULL)
        return RPC_S_OUT_OF_MEMORY;

    pCallEnumeration->CallID = CallID;
    pCallEnumeration->IfStart = IfStart;
    pCallEnumeration->ProcessID = ProcessID;
    pCallEnumeration->ProcNum = ProcNum;

    if (ProcessID != 0)
        {
        Status = OpenRPCServerDebugInfo(ProcessID, &pCallEnumeration->cellEnum);
        if (Status == ERROR_FILE_NOT_FOUND)
            {
            delete pCallEnumeration;
            return RPC_S_DBG_NOT_AN_RPC_SERVER;
            }
        else if (Status != RPC_S_OK)
            {
            delete pCallEnumeration;
            return Status;
            }
        }
    else
        {
        Status = OpenRPCSystemWideCellEnumeration(&pCallEnumeration->systemWideEnum);
        if (Status != RPC_S_OK)
            {
            delete pCallEnumeration;
            return Status;
            }
        }

    *pHandle = (CallInfoEnumerationHandle) pCallEnumeration;
    return RPC_S_OK;
}

RPC_STATUS GetNextRPCDebugCallInfo(IN CallInfoEnumerationHandle handle, OUT DebugCallInfo **NextCall,
                                   OUT DebugCellID *CellID, OUT DWORD *ServerPID)
{
    RPCDebugCallInfoEnumState *pCallEnumeration = (RPCDebugCallInfoEnumState *)handle;
    RPC_STATUS Status;
    DebugCallInfo *CallInfo;
    DebugCellUnion *NextCell;

    ASSERT(pCallEnumeration != NULL);
    ASSERT(NextCall != NULL);
    ASSERT(ServerPID != NULL);

    // loop until we find something or run out of cells/servers
    while (TRUE)
        {
        if (pCallEnumeration->ProcessID != 0)
            {
            *ServerPID = pCallEnumeration->ProcessID;
            NextCell = GetNextDebugCellInfo(pCallEnumeration->cellEnum, CellID);
            if (NextCell == NULL)
                return RPC_S_DBG_ENUMERATION_DONE;
            }
        else
            {
            Status = GetNextRPCSystemWideCell(pCallEnumeration->systemWideEnum, &NextCell, CellID, ServerPID);
            if (Status == RPC_S_INVALID_BOUND)
                return RPC_S_DBG_ENUMERATION_DONE;
            if (Status != RPC_S_OK)
                return Status;
            }
        // NextCell must be non-NULL here, or we have a bug
        ASSERT(NextCell != NULL);

        if (NextCell->callInfo.Type != dctCallInfo)
            continue;

        CallInfo = &NextCell->callInfo;

        if ((pCallEnumeration->CallID != 0) && (CallInfo->CallID != pCallEnumeration->CallID))
            continue;

        if ((pCallEnumeration->IfStart != 0) && (CallInfo->InterfaceUUIDStart != pCallEnumeration->IfStart))
            continue;

        if (((USHORT)pCallEnumeration->ProcNum != (USHORT)RPCDBG_NO_PROCNUM_SPECIFIED) 
            && (CallInfo->ProcNum != pCallEnumeration->ProcNum))
            continue;

        // if we have survived all checks until now, we have found it - return it
        *NextCall = CallInfo;
        return RPC_S_OK;
        }
}

void FinishRPCDebugCallInfoEnumeration(IN OUT CallInfoEnumerationHandle *pHandle)
{
    RPCDebugCallInfoEnumState *pCallEnumeration;

    ASSERT(pHandle != NULL);
    pCallEnumeration = (RPCDebugCallInfoEnumState *)*pHandle;
    ASSERT(pCallEnumeration != NULL);

    if (pCallEnumeration->ProcessID != 0)
        {
        CloseRPCServerDebugInfo(&pCallEnumeration->cellEnum);
        }
    else
        {
        FinishRPCSystemWideCellEnumeration(&pCallEnumeration->systemWideEnum);
        }
}

RPC_STATUS ResetRPCDebugCallInfoEnumeration(IN CallInfoEnumerationHandle handle)
{
    RPCDebugCallInfoEnumState *pCallEnumeration = (RPCDebugCallInfoEnumState *)handle;

    ASSERT(pCallEnumeration != NULL);
    if (pCallEnumeration->ProcessID != 0)
        {
        ResetRPCServerDebugInfo(pCallEnumeration->cellEnum);
        return RPC_S_OK;
        }
    else
        {
        return ResetRPCSystemWideCellEnumeration(pCallEnumeration->systemWideEnum);
        }
}


////////////////////////////////////
typedef struct tagRPCDebugEndpointInfoEnumState
{
    char *Endpoint;
    RPCSystemWideCellEnumerationHandle systemWideEnum;
} RPCDebugEndpointInfoEnumState;

RPC_STATUS OpenRPCDebugEndpointInfoEnumeration(IN char *Endpoint OPTIONAL, 
                                               OUT EndpointInfoEnumerationHandle *pHandle)
{
    RPCDebugEndpointInfoEnumState *pEndpointEnumeration;
    RPC_STATUS Status;
    int EndpointLength;

    *pHandle = NULL;
    pEndpointEnumeration = new RPCDebugEndpointInfoEnumState;
    if (pEndpointEnumeration == NULL)
        return RPC_S_OUT_OF_MEMORY;

    if (ARGUMENT_PRESENT(Endpoint))
        {
        EndpointLength = strlen(Endpoint);
        pEndpointEnumeration->Endpoint = new char [EndpointLength + 1];
        if (pEndpointEnumeration->Endpoint == NULL)
            {
            delete pEndpointEnumeration;
            return RPC_S_OUT_OF_MEMORY;
            }
        memcpy(pEndpointEnumeration->Endpoint, Endpoint, EndpointLength + 1);
        }
    else
        {
        pEndpointEnumeration->Endpoint = NULL;
        }

    Status = OpenRPCSystemWideCellEnumeration(&pEndpointEnumeration->systemWideEnum);
    if (Status != RPC_S_OK)
        {
        delete pEndpointEnumeration;
        return Status;
        }

    *pHandle = (EndpointInfoEnumerationHandle) pEndpointEnumeration;
    return RPC_S_OK;
}

RPC_STATUS GetNextRPCDebugEndpointInfo(IN CallInfoEnumerationHandle handle, OUT DebugEndpointInfo **NextEndpoint,
                                       OUT DebugCellID *CellID, OUT DWORD *ServerPID)
{
    RPCDebugEndpointInfoEnumState *pEndpointEnumeration = (RPCDebugEndpointInfoEnumState *)handle;
    RPC_STATUS Status;
    DebugEndpointInfo *EndpointInfo;
    DebugCellUnion *NextCell;

    ASSERT(pEndpointEnumeration != NULL);
    ASSERT(NextEndpoint != NULL);
    ASSERT(ServerPID != NULL);

    // loop until we find something or run out of cells/servers
    while (TRUE)
        {
        Status = GetNextRPCSystemWideCell(pEndpointEnumeration->systemWideEnum, &NextCell, CellID, ServerPID);
        if (Status == RPC_S_INVALID_BOUND)
            return RPC_S_DBG_ENUMERATION_DONE;

        if (Status != RPC_S_OK)
            return Status;

        // NextCell must be non-NULL here, or we have a bug
        ASSERT(NextCell != NULL);

        if (NextCell->callInfo.Type != dctEndpointInfo)
            continue;

        EndpointInfo = &NextCell->endpointInfo;

        if (pEndpointEnumeration->Endpoint != NULL) 
            {
            if (strncmp(EndpointInfo->EndpointName, pEndpointEnumeration->Endpoint, sizeof(EndpointInfo->EndpointName)) != 0)
                continue;
            }

        // if we have survived all checks until now, we have found it - return it
        *NextEndpoint = EndpointInfo;
        return RPC_S_OK;
        }
}

void FinishRPCDebugEndpointInfoEnumeration(IN OUT EndpointInfoEnumerationHandle *pHandle)
{
    RPCDebugEndpointInfoEnumState *pEndpointEnumeration;

    ASSERT(pHandle != NULL);
    pEndpointEnumeration = (RPCDebugEndpointInfoEnumState *)*pHandle;
    ASSERT(pEndpointEnumeration != NULL);

    FinishRPCSystemWideCellEnumeration(&pEndpointEnumeration->systemWideEnum);
}

RPC_STATUS ResetRPCDebugEndpointInfoEnumeration(IN EndpointInfoEnumerationHandle handle)
{
    RPCDebugEndpointInfoEnumState *pEndpointEnumeration = (RPCDebugEndpointInfoEnumState *)handle;

    ASSERT(pEndpointEnumeration != NULL);
    return ResetRPCSystemWideCellEnumeration(pEndpointEnumeration->systemWideEnum);
}


////////////////////////////////////////////////
typedef struct tagRPCDebugThreadInfoEnumState
{
    DWORD ProcessID;
    DWORD ThreadID;
    CellEnumerationHandle cellEnum;
} RPCDebugThreadInfoEnumState;

RPC_STATUS OpenRPCDebugThreadInfoEnumeration(IN DWORD ProcessID, 
                                             IN DWORD ThreadID OPTIONAL,
                                             OUT ThreadInfoEnumerationHandle *pHandle)
{
    RPCDebugThreadInfoEnumState *pThreadEnumeration;
    RPC_STATUS Status;

    ASSERT(ProcessID != 0);

    *pHandle = NULL;
    pThreadEnumeration = new RPCDebugThreadInfoEnumState;
    if (pThreadEnumeration == NULL)
        return RPC_S_OUT_OF_MEMORY;

    pThreadEnumeration->ProcessID = ProcessID;
    pThreadEnumeration->ThreadID = ThreadID;

    Status = OpenRPCServerDebugInfo(ProcessID, &pThreadEnumeration->cellEnum);
    if (Status == ERROR_FILE_NOT_FOUND)
        {
        delete pThreadEnumeration;
        return RPC_S_DBG_NOT_AN_RPC_SERVER;
        }
    else if (Status != RPC_S_OK)
        {
        delete pThreadEnumeration;
        return Status;
        }

    *pHandle = (ThreadInfoEnumerationHandle) pThreadEnumeration;
    return RPC_S_OK;
}

RPC_STATUS GetNextRPCDebugThreadInfo(IN ThreadInfoEnumerationHandle handle, OUT DebugThreadInfo **NextThread,
                                     OUT DebugCellID *CellID, OUT DWORD *ServerPID)
{
    RPCDebugThreadInfoEnumState *pThreadEnumeration = (RPCDebugThreadInfoEnumState *)handle;
    RPC_STATUS Status;
    DebugThreadInfo *ThreadInfo;
    DebugCellUnion *NextCell;

    ASSERT(pThreadEnumeration != NULL);
    ASSERT(NextThread != NULL);
    ASSERT(ServerPID != NULL);

    // loop until we find something or run out of cells/servers
    while (TRUE)
        {
        *ServerPID = pThreadEnumeration->ProcessID;
        NextCell = GetNextDebugCellInfo(pThreadEnumeration->cellEnum, CellID);

        if (NextCell == NULL)
            return RPC_S_DBG_ENUMERATION_DONE;

        if (NextCell->callInfo.Type != dctThreadInfo)
            continue;

        ThreadInfo = &NextCell->threadInfo;

        if ((pThreadEnumeration->ThreadID != 0) && (ThreadInfo->TID != pThreadEnumeration->ThreadID))
            continue;

        // if we have survived all checks until now, we have found it - return it
        *NextThread = ThreadInfo;
        return RPC_S_OK;
        }
}

void FinishRPCDebugThreadInfoEnumeration(IN OUT ThreadInfoEnumerationHandle *pHandle)
{
    RPCDebugThreadInfoEnumState *pThreadEnumeration;

    ASSERT(pHandle != NULL);
    pThreadEnumeration = (RPCDebugThreadInfoEnumState *)*pHandle;
    ASSERT(pThreadEnumeration != NULL);

    CloseRPCServerDebugInfo(&pThreadEnumeration->cellEnum);
}


RPC_STATUS ResetRPCDebugThreadInfoEnumeration(IN ThreadInfoEnumerationHandle handle)
{
    RPCDebugThreadInfoEnumState *pThreadEnumeration = (RPCDebugThreadInfoEnumState *)handle;

    ASSERT(pThreadEnumeration != NULL);
    ResetRPCServerDebugInfo(pThreadEnumeration->cellEnum);
    return RPC_S_OK;
}

/////////////////////////////////////////////////////
typedef struct tagRPCDebugClientCallInfoEnumState
{
    DWORD CallID;
    DWORD IfStart;
    int ProcNum;
    DWORD ProcessID;
    union
        {
        // if ProcessID != 0, cellEnum is used (i.e. we have process wide enumeration
        // otherwise, systemWideEnum is used - we have system wide enumeration
        RPCSystemWideCellEnumerationHandle systemWideEnum;
        CellEnumerationHandle cellEnum;
        };
} RPCDebugClientCallInfoEnumState;

RPC_STATUS OpenRPCDebugClientCallInfoEnumeration(IN DWORD CallID OPTIONAL, IN DWORD IfStart OPTIONAL, 
                                                 IN int ProcNum OPTIONAL,
                                                 IN DWORD ProcessID OPTIONAL, 
                                                 OUT ClientCallInfoEnumerationHandle *pHandle)
{
    RPCDebugClientCallInfoEnumState *pCallEnumeration;
    RPC_STATUS Status;

    *pHandle = NULL;
    pCallEnumeration = new RPCDebugClientCallInfoEnumState;
    if (pCallEnumeration == NULL)
        return RPC_S_OUT_OF_MEMORY;

    pCallEnumeration->CallID = CallID;
    pCallEnumeration->IfStart = IfStart;
    pCallEnumeration->ProcessID = ProcessID;
    pCallEnumeration->ProcNum = ProcNum;

    if (ProcessID != 0)
        {
        Status = OpenRPCServerDebugInfo(ProcessID, &pCallEnumeration->cellEnum);
        if (Status == ERROR_FILE_NOT_FOUND)
            {
            delete pCallEnumeration;
            return RPC_S_DBG_NOT_AN_RPC_SERVER;
            }
        else if (Status != RPC_S_OK)
            {
            delete pCallEnumeration;
            return Status;
            }
        }
    else
        {
        Status = OpenRPCSystemWideCellEnumeration(&pCallEnumeration->systemWideEnum);
        if (Status != RPC_S_OK)
            {
            delete pCallEnumeration;
            return Status;
            }
        }

    *pHandle = (ClientCallInfoEnumerationHandle) pCallEnumeration;
    return RPC_S_OK;
}

RPC_STATUS GetNextRPCDebugClientCallInfo(IN ClientCallInfoEnumerationHandle handle, 
                                         OUT DebugClientCallInfo **NextCall,
                                         OUT DebugCallTargetInfo **NextCallTarget,
                                         OUT DebugCellID *CellID, OUT DWORD *ServerPID)
{
    RPCDebugClientCallInfoEnumState *pCallEnumeration = (RPCDebugClientCallInfoEnumState *)handle;
    RPC_STATUS Status;
    DebugClientCallInfo *CallInfo;
    DebugCallTargetInfo *CallTargetInfo;
    DebugCellUnion *NextCell;

    ASSERT(pCallEnumeration != NULL);
    ASSERT(NextCall != NULL);
    ASSERT(ServerPID != NULL);

    // loop until we find something or run out of cells/servers
    while (TRUE)
        {
        if (pCallEnumeration->ProcessID != 0)
            {
            *ServerPID = pCallEnumeration->ProcessID;
            NextCell = GetNextDebugCellInfo(pCallEnumeration->cellEnum, CellID);
            if (NextCell == NULL)
                return RPC_S_DBG_ENUMERATION_DONE;
            }
        else
            {
            Status = GetNextRPCSystemWideCell(pCallEnumeration->systemWideEnum, &NextCell, CellID, ServerPID);
            if (Status == RPC_S_INVALID_BOUND)
                return RPC_S_DBG_ENUMERATION_DONE;
            if (Status != RPC_S_OK)
                return Status;
            }
        // NextCell must be non-NULL here, or we have a bug
        ASSERT(NextCell != NULL);

        if (NextCell->callInfo.Type != dctClientCallInfo)
            continue;

        CallInfo = &NextCell->clientCallInfo;

        if ((pCallEnumeration->CallID != 0) && (CallInfo->CallID != pCallEnumeration->CallID))
            continue;

        if ((pCallEnumeration->IfStart != 0) && (CallInfo->IfStart != pCallEnumeration->IfStart))
            continue;

        if (((USHORT)pCallEnumeration->ProcNum != (USHORT)RPCDBG_NO_PROCNUM_SPECIFIED) 
            && (CallInfo->ProcNum != pCallEnumeration->ProcNum))
            continue;

        if (pCallEnumeration->ProcessID != 0)
            {
            CallTargetInfo = (DebugCallTargetInfo *) GetCellByDebugCellID(pCallEnumeration->cellEnum, 
                NextCell->clientCallInfo.CallTargetID);
            }
        else
            {
            CallTargetInfo = (DebugCallTargetInfo *) GetRPCSystemWideCellFromCellID(pCallEnumeration->systemWideEnum,
                NextCell->clientCallInfo.CallTargetID);
            }

        // if we have survived all checks until now, we have found it - return it
        *NextCall = CallInfo;
        *NextCallTarget = CallTargetInfo;
        return RPC_S_OK;
        }
}

void FinishRPCDebugClientCallInfoEnumeration(IN OUT ClientCallInfoEnumerationHandle *pHandle)
{
    RPCDebugClientCallInfoEnumState *pCallEnumeration;

    ASSERT(pHandle != NULL);
    pCallEnumeration = (RPCDebugClientCallInfoEnumState *)*pHandle;
    ASSERT(pCallEnumeration != NULL);

    if (pCallEnumeration->ProcessID != 0)
        {
        CloseRPCServerDebugInfo(&pCallEnumeration->cellEnum);
        }
    else
        {
        FinishRPCSystemWideCellEnumeration(&pCallEnumeration->systemWideEnum);
        }
}

RPC_STATUS ResetRPCDebugClientCallInfoEnumeration(IN CallInfoEnumerationHandle handle)
{
    RPCDebugClientCallInfoEnumState *pCallEnumeration = (RPCDebugClientCallInfoEnumState *)handle;

    ASSERT(pCallEnumeration != NULL);
    if (pCallEnumeration->ProcessID != 0)
        {
        ResetRPCServerDebugInfo(pCallEnumeration->cellEnum);
        return RPC_S_OK;
        }
    else
        {
        return ResetRPCSystemWideCellEnumeration(pCallEnumeration->systemWideEnum);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\dbglib\dbginit.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    DbgInit.cxx

Abstract:

    Initialization and utility functions for the debug library

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>

static DWORD gPageSize = 0;
BOOL g_fDbgLibInitialized = FALSE;

DWORD GetPageSize(void)
{
    return gPageSize;
}

RPC_STATUS InitializeDbgLib(void)
{
    SYSTEM_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;

    if (g_fDbgLibInitialized)
        return RPC_S_OK;

    Status = NtQuerySystemInformation(
                            SystemBasicInformation,
                            &BasicInfo,
                            sizeof(BasicInfo),
                            NULL
                            );
    if ( !NT_SUCCESS(Status) )
        {
        DbgPrint("RPCDBGLIG: NtQuerySystemInformation failed: %x\n", Status);
        return RPC_S_INTERNAL_ERROR;
        }

    gPageSize = BasicInfo.PageSize;
    g_fDbgLibInitialized = TRUE;
    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\dbglib\secname.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    SecName.cxx

Abstract:

    Function(s) for manipulating the section name

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>

void GenerateSectionName(OUT RPC_CHAR *Buffer, IN int BufferLength, 
    IN DWORD ProcessID, IN DWORD *pSectionNumbers OPTIONAL)
{
    RPC_CHAR *CurrentPosition;
    
    ASSERT(BufferLength >= RpcSectionNameMaxSize);

    RpcpStringCopy(Buffer, RpcSectionPrefix);
    CurrentPosition = Buffer + RpcSectionPrefixSize;

    // add the PID
    _ultow(ProcessID, CurrentPosition, 16);

    if (pSectionNumbers)
        {
        // find the end of the conversion
        while (*CurrentPosition != 0)
            CurrentPosition ++;

        // add the first portion of the section number
        _ultow(pSectionNumbers[0], CurrentPosition, 16);
        // find the end of the conversion
        while (*CurrentPosition != 0)
            CurrentPosition ++;

        // add the second portion of the section number
        _ultow(pSectionNumbers[1], CurrentPosition, 16);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\dbglib\secutil.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    SecUtil.cxx

Abstract:

    Utility functions for manipulating cell sections

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>

RPC_STATUS OpenDbgSection(OUT HANDLE *pHandle, OUT PVOID *pSection, 
    IN DWORD ProcessID, IN DWORD *pSectionNumbers OPTIONAL)
{
    UNICODE_STRING SectionNameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS NtStatus;
    RPC_CHAR SectionName[RpcSectionNameMaxSize];

    GenerateSectionName(SectionName, sizeof(SectionName)/sizeof(RPC_CHAR), ProcessID, pSectionNumbers);
    RtlInitUnicodeString(&SectionNameString, SectionName);

    InitializeObjectAttributes(&ObjectAttributes,
        &SectionNameString,
        OBJ_CASE_INSENSITIVE,
        0,
        0);

    NtStatus = NtOpenSection(pHandle, FILE_MAP_READ, &ObjectAttributes);
    if (!NT_SUCCESS(NtStatus))
        {
        if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else if (NtStatus == STATUS_ACCESS_DENIED)
            return ERROR_ACCESS_DENIED;
        return RPC_S_OUT_OF_MEMORY;
        }

    *pSection = MapViewOfFileEx(*pHandle, FILE_MAP_READ, 0, 0, 0, NULL);
    if (*pSection == NULL)
        {
        CloseHandle(*pHandle);
        *pHandle = NULL;
        return RPC_S_OUT_OF_MEMORY;
        }

    return RPC_S_OK;
}

void CloseDbgSection(IN HANDLE SecHandle, PVOID SecPointer)
{
    BOOL fResult;

    ASSERT(SecHandle != NULL);
    ASSERT(SecPointer != NULL);

    fResult = UnmapViewOfFile(SecPointer);
    ASSERT(fResult);

    fResult = CloseHandle(SecHandle);
    ASSERT(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\dbglib\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Revision History:

!ENDIF

TARGETNAME=RpcDbg
TARGETTYPE=LIBRARY
# TARGETPATH in daytona\sources and wow6432\sources.

INCLUDES=..\;..\..\mtrt;..\..\inc;..\..\CharConv;$(INCLUDES);..\..\rtifs\$(O)

BLDCRT=1

#
# Setup for application developer to set breakpoints with windbg
#

MSC_WARNING_LEVEL=/W3 /WX

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_CXX=1

SOURCES=$(SOURCES)   \
        CellUtil.cxx \
        DbgInit.cxx  \
        DbgPrint.cxx \
        SecName.cxx  \
        SecUtil.cxx  \
        SvrUtil.cxx

RPCENV= $(RPCENV) -DWIN32RPC -DNTWIN32RPC -D_RPCRT4_

C_DEFINES=$(RPCENV) $(RPCTARGETENV) /DMSWMSG -D_RPCRT4_

# Used only for unit tests
#USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\dbglib\dbgprint.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    DbgPrint.cxx

Abstract:

    Functions for printing debug information

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>
#include <wincrypt.h>
#include <rpctrans.hxx>

void PrintTimeInSeconds(RPC_CHAR *HeaderString, DWORD TimeInMilliseconds, 
                        PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("%S (in seconds since boot):%d.%d (0x%X.%X)\n", HeaderString,
        TimeInMilliseconds / 1000, TimeInMilliseconds % 1000,
        TimeInMilliseconds / 1000, TimeInMilliseconds % 1000);
}

void PrintDebugCellID(RPC_CHAR *HeaderString, DebugCellID CellID,
                      PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("%S: 0x%X.%X\n", HeaderString, CellID.SectionID, CellID.CellID);    
}

const RPC_CHAR *CallStatusStrings[] = {L"Allocated", L"Active", L"Dispatched"};
#define UnknownValueLiteral (L"Unknown/Invalid")
const RPC_CHAR *UnknownValue = UnknownValueLiteral;

const RPC_CHAR *ConnectionAuthLevelStrings[] = {L"Default", L"None", L"Connect", L"Call", L"Packet",
            L"Packet Integrity", L"Packet Privacy", UnknownValueLiteral, UnknownValueLiteral};

const RPC_CHAR *ConnectionAuthServiceStrings[] = {L"None", L"NTLM", L"Kerberos/Snego", L"Other"};

const RPC_CHAR *ProtocolSequenceStrings[] = {L"TCP", L"UDP", L"LRPC", UnknownValueLiteral, UnknownValueLiteral,
    L"SPX", UnknownValueLiteral, L"IPX", L"NMP", UnknownValueLiteral, UnknownValueLiteral, L"NB", 
    UnknownValueLiteral, UnknownValueLiteral, UnknownValueLiteral, L"DSP", L"DDP", UnknownValueLiteral, 
    UnknownValueLiteral, L"SPP", UnknownValueLiteral, UnknownValueLiteral, 
    L"MQ", UnknownValueLiteral, L"HTTP"};

const int FirstProtocolSequenceTowerID = TCP_TOWER_ID;
const int LastProtocolSequenceTowerID = HTTP_TOWER_ID;

RPC_CHAR *GetProtocolSequenceString(int ProtocolSequenceID)
{
    RPC_CHAR *CurrentString;

    if ((ProtocolSequenceID < FirstProtocolSequenceTowerID) 
        || (ProtocolSequenceID > LastProtocolSequenceTowerID))
        {
        CurrentString = (RPC_CHAR *) UnknownValue;
        }
    else
        {
        CurrentString = (RPC_CHAR *) ProtocolSequenceStrings[
            ProtocolSequenceID - FirstProtocolSequenceTowerID];
        }

    ASSERT(CurrentString != NULL);
    return CurrentString;
}

void PrintCallInfoHeader(PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("PID  CELL ID   ST PNO IFSTART  THRDCELL  CALLFLAG CALLID   LASTTIME CONN/CLN\n");
    PrintRoutine("----------------------------------------------------------------------------\n");
}

void PrintCallInfoBody(IN DWORD ProcessID, IN DebugCellID CellID, 
                       IN DebugCallInfo *CallInfo, PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("%04x %04x.%04x %02x %03x %08lx %04x.%04x %08lx %08lx %08lx ",
        ProcessID, CellID.SectionID, CellID.CellID, CallInfo->Status, 
        CallInfo->ProcNum, CallInfo->InterfaceUUIDStart,
        CallInfo->ServicingTID.SectionID, CallInfo->ServicingTID.CellID,
        CallInfo->CallFlags, CallInfo->CallID, CallInfo->LastUpdateTime);
    if (CallInfo->CallFlags & DBGCELL_LRPC_CALL)
        {
        PrintRoutine("%04x.%04x\n", (DWORD)CallInfo->PID, (DWORD)CallInfo->TID);
        }
    else
        {
        PrintRoutine("%04x.%04x\n", (DWORD)CallInfo->Connection.SectionID, 
            (DWORD)CallInfo->Connection.CellID);
        }
}

void GetAndPrintCallInfo(IN DWORD CallID OPTIONAL, IN DWORD IfStart OPTIONAL, 
                         IN int ProcNum OPTIONAL, IN DWORD ProcessID OPTIONAL,
                         PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    CallInfoEnumerationHandle h;
    RPC_STATUS Status;
    DebugCallInfo *NextCall;
    DebugCellID CellID;
    DWORD CurrentPID;

    PrintRoutine("Searching for call info ...\n");
    Status = OpenRPCDebugCallInfoEnumeration(CallID, IfStart, ProcNum, ProcessID, &h);
    if (Status != RPC_S_OK)
        {
        PrintRoutine("OpenRPCDebugCallInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintCallInfoHeader(PrintRoutine);
    do
        {
        Status = GetNextRPCDebugCallInfo(h, &NextCall, &CellID, &CurrentPID);
        if (Status == RPC_S_OK)
            {
            PrintCallInfoBody(CurrentPID, CellID, NextCall, PrintRoutine);
            /*
            // print the information we obtained
            PrintRoutine("%04x %04x.%04x %02x %03x %08lx %04x.%04x %08lx %08lx %08lx ",
                CurrentPID, CellID.SectionID, CellID.CellID, NextCall->Status, 
                NextCall->ProcNum, NextCall->InterfaceUUIDStart,
                NextCall->ServicingTID.SectionID, NextCall->ServicingTID.CellID,
                NextCall->CallFlags, NextCall->CallID, NextCall->LastUpdateTime);
            if (NextCall->CallFlags & DBGCELL_LRPC_CALL)
                {
                PrintRoutine("%04x.%04x\n", (DWORD)NextCall->PID, (DWORD)NextCall->TID);
                }
            else
                {
                PrintRoutine("%04x.%04x\n", (DWORD)NextCall->Connection.SectionID, 
                    (DWORD)NextCall->Connection.CellID);
                }
                */
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        PrintRoutine("Enumeration aborted with error %d\n", Status);
        }

    FinishRPCDebugCallInfoEnumeration(&h);    
}

void PrintDbgCellInfo(IN DebugCellUnion *Container, IN DebugCellUnion *EndpointContainer OPTIONAL,
                      PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    RPC_CHAR *CurrentString;
    DWORD LocalFlags;
    BOOL fFirstTime;
    char EndpointString[DebugEndpointNameLength + 1];
    int ConnectionAuthLevel;
    int ConnectionAuthService;
    HANDLE LocalIPAddress;
    HANDLE LocalIPAddress2;
    int i;
    HANDLE LocalIPAddressElement;
    HANDLE LocalSessionID;

    switch(Container->genericCell.Type)
        {
        case dctFree:
            PrintRoutine("Free cell\n");
            break;

        case dctCallInfo:
            PrintRoutine("Call\n");
            if ((Container->callInfo.Status < CallStatusFirst)
                || (Container->callInfo.Status > CallStatusLast))
                {
                CurrentString = (RPC_CHAR *)UnknownValue;
                }
            else
                {
                CurrentString = (RPC_CHAR *)CallStatusStrings[Container->callInfo.Status];
                }
            PrintRoutine("Status: %S\n", CurrentString);
            PrintRoutine("Procedure Number: %d\n", Container->callInfo.ProcNum);
            PrintRoutine("Interface UUID start (first DWORD only): %X\n", Container->callInfo.InterfaceUUIDStart);
            PrintRoutine("Call ID: 0x%x (%d)\n", Container->callInfo.CallID, Container->callInfo.CallID);
            PrintDebugCellID(L"Servicing thread identifier", Container->callInfo.ServicingTID, PrintRoutine);
            PrintRoutine("Call Flags:");
            LocalFlags = Container->callInfo.CallFlags;
            fFirstTime = TRUE;
            if (LocalFlags & DBGCELL_CACHED_CALL)
                {
                PrintRoutine(" cached");
                fFirstTime = FALSE;
                }

            if (LocalFlags & DBGCELL_ASYNC_CALL)
                {
                if (fFirstTime == FALSE)
                    {
                    PrintRoutine(", ");
                    }
                PrintRoutine("async");
                fFirstTime = FALSE;
                }

            if (LocalFlags & DBGCELL_PIPE_CALL)
                {
                if (fFirstTime == FALSE)
                    {
                    PrintRoutine(", ");
                    }
                PrintRoutine("pipe");
                fFirstTime = FALSE;
                }

            if (LocalFlags & DBGCELL_LRPC_CALL)
                {
                if (fFirstTime == FALSE)
                    {
                    PrintRoutine(", ");
                    }
                PrintRoutine("LRPC");
                fFirstTime = FALSE;
                }

            if (fFirstTime == TRUE)
                {
                PrintRoutine("none");
                }
            PrintRoutine("\n");

            PrintTimeInSeconds(L"Last update time", Container->callInfo.LastUpdateTime, PrintRoutine);

            if (LocalFlags & DBGCELL_LRPC_CALL)
                {
                PrintRoutine("Caller (PID/TID) is: %x.%x (%d.%d)\n", Container->callInfo.PID, 
                    Container->callInfo.TID, Container->callInfo.PID, Container->callInfo.TID);
                }
            else
                PrintDebugCellID(L"Owning connection identifier", Container->callInfo.Connection, PrintRoutine);

            break;

        case dctThreadInfo:
            PrintRoutine("Thread\n");
            PrintRoutine("Status: ");
            switch (Container->threadInfo.Status)
                {
                case dtsProcessing:
                    PrintRoutine("Processing\n");
                    break;

                case dtsDispatched:
                    PrintRoutine("Dispatched\n");
                    break;

                case dtsAllocated:
                    PrintRoutine("Allocated\n");
                    break;

                case dtsIdle:
                    PrintRoutine("Idle\n");
                    break;

                default:
                    PrintRoutine("Unknown (%d)\n", Container->threadInfo.Status);
                }
            PrintRoutine("Thread ID: 0x%X (%d)\n", Container->threadInfo.TID, Container->threadInfo.TID);
            if ((Container->threadInfo.Endpoint.CellID == 0) && (Container->threadInfo.Endpoint.SectionID == 0))
                {
                PrintRoutine("Thread is an IO completion thread\n");
                }
            else
                {
                PrintDebugCellID(L"Associated Endpoint:", Container->threadInfo.Endpoint, PrintRoutine);
                }
            PrintTimeInSeconds(L"Last update time", Container->threadInfo.LastUpdateTime, PrintRoutine);
            break;

        case dctEndpointInfo:
            PrintRoutine("Endpoint\n");
            PrintRoutine("Status: ");
            switch (Container->endpointInfo.Status)
                {
                case desAllocated:
                    PrintRoutine("Allocated\n");
                    break;

                case desActive:
                    PrintRoutine("Active\n");
                    break;

                case desInactive:
                    PrintRoutine("Inactive\n");
                    break;

                default:
                    PrintRoutine("Unknown (%d)\n", Container->endpointInfo.Status);

                }

            CurrentString = GetProtocolSequenceString(Container->endpointInfo.ProtseqType);
            PrintRoutine("Protocol Sequence: %S\n", CurrentString);
            memcpy(EndpointString, Container->endpointInfo.EndpointName, 
                sizeof(Container->endpointInfo.EndpointName));
            EndpointString[DebugEndpointNameLength] = 0;
            PrintRoutine("Endpoint name: %s\n", EndpointString);
            break;

        case dctClientCallInfo:
            PrintRoutine("Client call info\n");
            PrintRoutine("Procedure number: %d\n", Container->clientCallInfo.ProcNum);
            PrintRoutine("Interface UUID start (first DWORD only): %X\n", Container->clientCallInfo.IfStart);
            PrintRoutine("Call ID: 0x%x (%d)\n", Container->clientCallInfo.CallID, 
                Container->clientCallInfo.CallID);
            PrintDebugCellID(L"Calling thread identifier", Container->clientCallInfo.ServicingThread, 
                PrintRoutine);
            PrintDebugCellID(L"Call target identifier", Container->clientCallInfo.CallTargetID, PrintRoutine);

            ASSERT(sizeof(Container->clientCallInfo.Endpoint) < sizeof(EndpointString));

            memcpy(EndpointString, Container->clientCallInfo.Endpoint, sizeof(Container->clientCallInfo.Endpoint));
            EndpointString[ClientCallEndpointLength] = 0;
            PrintRoutine("Call target endpoint: %s\n", EndpointString);
            break;

        case dctCallTargetInfo:
            PrintRoutine("Call target info\n");
            CurrentString = GetProtocolSequenceString(Container->callTargetInfo.ProtocolSequence);
            PrintRoutine("Protocol Sequence: %S\n", CurrentString);
            PrintTimeInSeconds(L"Last update time", Container->callTargetInfo.LastUpdateTime, PrintRoutine);
            
            ASSERT(sizeof(Container->callTargetInfo.TargetServer) < sizeof(EndpointString));

            memcpy(EndpointString, Container->callTargetInfo.TargetServer, 
                sizeof(Container->callTargetInfo.TargetServer));
            EndpointString[sizeof(Container->callTargetInfo.TargetServer)] = 0;
            PrintRoutine("Target server is: %s\n", EndpointString);
            break;

        case dctConnectionInfo:
            PrintRoutine("Connection\n");
            LocalFlags = Container->connectionInfo.Flags;
            fFirstTime = TRUE;
            PrintRoutine("Connection flags: ");

            if (LocalFlags & 1)
                {
                PrintRoutine("Exclusive\n");
                }
            else
                {
                PrintRoutine("None\n");
                }

            ConnectionAuthLevel = 
                (Container->connectionInfo.Flags & ConnectionAuthLevelMask) >> ConnectionAuthLevelShift;
            ConnectionAuthService = 
                (Container->connectionInfo.Flags & ConnectionAuthServiceMask) >> ConnectionAuthServiceShift;

            PrintRoutine("Authentication Level: %S\n", ConnectionAuthLevelStrings[ConnectionAuthLevel]);

            PrintRoutine("Authentication Service: %S\n", ConnectionAuthServiceStrings[ConnectionAuthService]);

            PrintRoutine("Last Transmit Fragment Size: %d (0x%X)\n", 
                Container->connectionInfo.LastTransmitFragmentSize);

            PrintDebugCellID(L"Endpoint for the connection", Container->connectionInfo.Endpoint, PrintRoutine);

            PrintTimeInSeconds(L"Last send time", Container->connectionInfo.LastSendTime, PrintRoutine);
            PrintTimeInSeconds(L"Last receive time", Container->connectionInfo.LastReceiveTime, PrintRoutine);
            PrintRoutine("Getting endpoint info ...\n");

            switch(EndpointContainer->endpointInfo.ProtseqType)
                {
                case TCP_TOWER_ID:
                case UDP_TOWER_ID:
                case HTTP_TOWER_ID:
                    // IP address of some sort
                    PrintRoutine("Caller is");
                    LocalIPAddress = Container->connectionInfo.ConnectionID[1];
                    LocalIPAddress2 = Container->connectionInfo.ConnectionID[0];
                    if (LocalIPAddress2 == 0)
                        {
                        PrintRoutine("(IPv4): ");
                        for (i = 0; i < 4; i ++)
                            {
                            LocalIPAddressElement = (HANDLE)((ULONGLONG)LocalIPAddress & 0xFF);
                            LocalIPAddress = (HANDLE)((ULONGLONG)LocalIPAddress >> 8);
                            PrintRoutine("%d", HandleToUlong(LocalIPAddressElement));
                            if (i < 3)
                                {
                                PrintRoutine(".");
                                }
                            else
                                {
                                PrintRoutine("\n");
                                }
                            }
                        }
                    else
                        {
                        PrintRoutine("(IPv6 - last two DWORDS): ");
                        PrintRoutine("%d::%d\n", HandleToUlong(LocalIPAddress2), HandleToULong(LocalIPAddress));
                        }
                    break;

                case NMP_TOWER_ID:
                    LocalSessionID = Container->connectionInfo.ConnectionID[0];
                    if (LocalSessionID)
                        {
                        PrintRoutine("Cannot determine caller for remote named pipes\n");
                        }
                    else
                        {
                        LocalSessionID = Container->connectionInfo.ConnectionID[1];
                        PrintRoutine("Process object for caller is 0x%X\n", LocalSessionID);
                        }
                    break;

                default:
                    CurrentString = GetProtocolSequenceString(EndpointContainer->endpointInfo.ProtseqType);
                    PrintRoutine("Cannot determine caller for this type of protocol sequence %S (%d)\n", 
                        CurrentString, EndpointContainer->endpointInfo.ProtseqType);
                }
            break;

        case dctUsedGeneric:
            break;

        default:
            PrintRoutine("Invalid cell type: %d\n", Container->genericCell.Type);

        }
}

void GetAndPrintDbgCellInfo(DWORD ProcessID, DebugCellID CellID,
                            PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    DebugCellUnion Container;
    DebugCellUnion EndpointContainer;
    RPC_STATUS Status;

    PrintRoutine("Getting cell info ...\n");
    Status = GetCellByDebugCellID(ProcessID, CellID, &Container);
    if (Status != RPC_S_OK)
        {
        PrintRoutine("Getting cell info failed with error %d\n", Status);
        return;
        }

    if (Container.genericCell.Type == dctConnectionInfo)
        {
        Status = GetCellByDebugCellID(ProcessID, Container.connectionInfo.Endpoint, &EndpointContainer);
        if (Status != RPC_S_OK)
            {
            PrintRoutine("Getting endpoint info failed with error %d\n", Status);
            return;
            }
        }

    PrintDbgCellInfo(&Container, &EndpointContainer, PrintRoutine);
}

void PrintEndpointInfoHeader(PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("PID  CELL ID   ST PROTSEQ        ENDPOINT                    \n");
    PrintRoutine("-------------------------------------------------------------\n");
}

void PrintEndpointInfoBody(IN DWORD ProcessID, IN DebugCellID CellID, 
                           IN DebugEndpointInfo *EndpointInfo, PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    RPC_CHAR *ProtseqName;
    char CurrentEndpoint[DebugEndpointNameLength + 1];

    ProtseqName = GetProtocolSequenceString(EndpointInfo->ProtseqType);
    CurrentEndpoint[DebugEndpointNameLength] = 0;
    memcpy(CurrentEndpoint, EndpointInfo->EndpointName, DebugEndpointNameLength);
    // print the information we obtained
    PrintRoutine("%04x %04x.%04x %02x %14S %s\n",
        ProcessID, CellID.SectionID, CellID.CellID, EndpointInfo->Status, 
        ProtseqName, CurrentEndpoint);
}

void GetAndPrintEndpointInfo(IN char *Endpoint OPTIONAL, PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    DWORD CurrentPID;
    RPC_STATUS Status;
    DebugEndpointInfo *NextEndpoint;
    EndpointInfoEnumerationHandle h;
    DebugCellID CellID;

    PrintRoutine("Searching for endpoint info ...\n");
    Status = OpenRPCDebugEndpointInfoEnumeration(Endpoint, &h);
    if (Status != RPC_S_OK)
        {
        PrintRoutine("OpenRPCDebugEndpointInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintEndpointInfoHeader(PrintRoutine);
    do
        {
        Status = GetNextRPCDebugEndpointInfo(h, &NextEndpoint, &CellID, &CurrentPID);
        if (Status == RPC_S_OK)
            {
            PrintEndpointInfoBody(CurrentPID, CellID, NextEndpoint, PrintRoutine);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        PrintRoutine("Enumeration aborted with error %d\n", Status);
        }

    FinishRPCDebugEndpointInfoEnumeration(&h);    
}

void PrintThreadInfoHeader(PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("PID  CELL ID   ST TID      ENDPOINT  LASTTIME\n");
    PrintRoutine("---------------------------------------------\n");
}

void PrintThreadInfoBody(IN DWORD ProcessID, IN DebugCellID CellID, 
                         IN DebugThreadInfo *ThreadInfo, PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    // print the information we obtained
    PrintRoutine("%04x %04x.%04x %02x %08x %04x.%04x %08x\n",
        ProcessID, CellID.SectionID, CellID.CellID, ThreadInfo->Status, 
        ThreadInfo->TID, ThreadInfo->Endpoint.SectionID,
        ThreadInfo->Endpoint.CellID, ThreadInfo->LastUpdateTime);
}

void GetAndPrintThreadInfo(DWORD ProcessID, DWORD ThreadID OPTIONAL, PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    DebugThreadInfo *NextThread;
    RPC_STATUS Status;
    ThreadInfoEnumerationHandle h;
    DebugCellID CellID;
    DWORD CurrentPID;

    PrintRoutine("Searching for thread info ...\n");
    Status = OpenRPCDebugThreadInfoEnumeration(ProcessID, ThreadID, &h);
    if (Status != RPC_S_OK)
        {
        PrintRoutine("OpenRPCDebugThreadInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintThreadInfoHeader(PrintRoutine);
    do
        {
        Status = GetNextRPCDebugThreadInfo(h, &NextThread, &CellID, &CurrentPID);
        if (Status == RPC_S_OK)
            {
            PrintThreadInfoBody(CurrentPID, CellID, NextThread, PrintRoutine);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        PrintRoutine("Enumeration aborted with error %d\n", Status);
        }

    FinishRPCDebugThreadInfoEnumeration(&h);    
}

void PrintClientCallInfoHeader(PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("PID  CELL ID   PNO  IFSTART  TIDNUMBER CALLID   LASTTIME PS CLTNUMBER ENDPOINT\n");
    PrintRoutine("------------------------------------------------------------------------------\n");
}

void PrintClientCallInfoBody(IN DWORD ProcessID, IN DebugCellID CellID, 
                             IN DebugClientCallInfo *ClientCallInfo, 
                             IN DebugCallTargetInfo *CallTargetInfo,
                             PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    char TempString[DebugEndpointNameLength + 1];

    ASSERT(sizeof(TempString) > sizeof(CallTargetInfo->TargetServer));
    ASSERT(sizeof(TempString) > sizeof(ClientCallInfo->Endpoint));

    memcpy(TempString, ClientCallInfo->Endpoint, sizeof(ClientCallInfo->Endpoint));
    TempString[sizeof(ClientCallInfo->Endpoint)] = 0;

    // print the information we obtained
    PrintRoutine("%04x %04x.%04x %04x %08lx %04x.%04x %08lx %08lx %02x %04x.%04x %s\n",
        ProcessID, CellID.SectionID, CellID.CellID, ClientCallInfo->ProcNum, 
        ClientCallInfo->IfStart, ClientCallInfo->ServicingThread.SectionID,
        ClientCallInfo->ServicingThread.CellID, ClientCallInfo->CallID,
        CallTargetInfo->LastUpdateTime, CallTargetInfo->ProtocolSequence, 
        ClientCallInfo->CallTargetID.SectionID, ClientCallInfo->CallTargetID.CellID,
        TempString);

}

void GetAndPrintClientCallInfo(IN DWORD CallID OPTIONAL, IN DWORD IfStart OPTIONAL, 
                         IN int ProcNum OPTIONAL, IN DWORD ProcessID OPTIONAL,
                         PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    DWORD CurrentPID;
    DebugCellID CellID;

    DebugClientCallInfo *NextClientCall;
    DebugCallTargetInfo *NextCallTarget;

    RPC_STATUS Status;
    CallInfoEnumerationHandle h;

    PrintRoutine("Searching for call info ...\n");
    Status = OpenRPCDebugClientCallInfoEnumeration(CallID, IfStart, ProcNum, ProcessID, &h);
    if (Status != RPC_S_OK)
        {
        PrintRoutine("OpenRPCDebugClientCallInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintClientCallInfoHeader(PrintRoutine);
    do
        {
        Status = GetNextRPCDebugClientCallInfo(h, &NextClientCall, &NextCallTarget, &CellID, &CurrentPID);
        if (Status == RPC_S_OK)
            {
            if ((NextCallTarget != NULL) && (NextCallTarget->Type != dctCallTargetInfo))
                {
                PrintRoutine("Inconsistent information detected - skipping ...\n");
                continue;
                }

            PrintClientCallInfoBody(CurrentPID, CellID, NextClientCall, NextCallTarget,
                PrintRoutine);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        PrintRoutine("Enumeration aborted with error %d\n", Status);
        }

    FinishRPCDebugClientCallInfoEnumeration(&h);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\dll\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Revision History:

!ENDIF

TARGETNAME=rpcrt4
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLDEF=$(O)\rpcrt4.def

MSC_WARNING_LEVEL=/WX /W3

SOURCES=             \
        ..\rpcrt4.rc

RPCENV=$(RPCENV) -DNTENV -DWIN32RPC -DNTWIN32RPC

C_DEFINES= $(C_DEFINES) $(RPCENV) $(RPCTARGETENV) /DMSWMSG -DEXPORT_RT -DEXPORT_NDR

!if $(IA64) || $(AMD64)
BUILD_NDR64=1
!endif

!ifdef BUILD_NDR64FAKE
BUILD_NDR64=1
!endif


!ifdef BUILD_NDR64
C_DEFINES= $(C_DEFINES) -DEXPORT_NDR64
!endif

DLLENTRY=InitializeDLL
TARGETLIBS= $(TARGETLIBS) \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(DS_LIB_PATH)\rsa32.lib       \
            $(DS_LIB_PATH)\randlib.lib  \
            $(RPCRUNTIME)\..\selbinding\$(O)\selbinding.lib \
            $(SDK_LIB_PATH)\netlib.lib \
            $(DS_LIB_PATH)\secur32p.lib

RPCRUNTIME=..\..

LINKLIBS= \
         $(LINKLIBS) \
         $(RPCRUNTIME)\mtrt\$(ALT_PROJECT)\$(O)\rpcmtrt.lib    \
         $(PROJECT_ROOT)\lib\$(O)\RpcDbg.lib \
         $(RPCRUNTIME)\rtifs\$(O)\rtifs.lib     \
         $(RPCRUNTIME)\..\ndrlib\daytona\$(O)\rpcndrp.lib \
         $(RPCRUNTIME)\..\ndr20\daytona\$(O)\rpcndr20.lib \
         $(RPCRUNTIME)\CharConv\$(CHARCONV_DIR)\$(O)\CharConv.lib \
         $(RPCRUNTIME)\trans\common\$(CHARCONV_DIR)\$(O)\rpctrans.lib \
         $(RPCRUNTIME)\unpickle\$(O)\unpickle.lib

!ifdef BUILD_NDR64
LINKLIBS=$(LINKLIBS) \
         $(RPCRUNTIME)\..\ndr64\ndr64\$(O)\rpcndr64.lib
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\dbglib\svrutil.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    SvrUtil.cxx

Abstract:

    Utility functions for querying RPC Server debug data

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>
#include <DbgLib.hxx>

typedef struct tagServerEnumerationState
{
    int CurrentPosition;
    int NumberOfProcesses;
    // the actual size is NumberOfProcesses
    ULONG ProcessUniqueId[1];
} ServerEnumerationState;

RPC_STATUS StartServerEnumeration(ServerEnumerationHandle *pHandle)
{
    ServerEnumerationState *pNewState;
    void *pProcessDataBuffer = NULL;
    NTSTATUS NtStatus;
    int CurrentAllocatedSize = 0x6000;
    SYSTEM_PROCESS_INFORMATION *pCurrentProcessInfo;
    unsigned char *pCurrentPos;
    int NumberOfProcesses;
    int i;
    BOOL fResult;

    do
        {
        if (pProcessDataBuffer)
            {
            fResult = VirtualFree(pProcessDataBuffer, 0, MEM_RELEASE);
            ASSERT(fResult);
            }

        CurrentAllocatedSize += 4096 * 2;
        pProcessDataBuffer = VirtualAlloc(NULL, CurrentAllocatedSize, MEM_COMMIT, PAGE_READWRITE);
        if (pProcessDataBuffer == NULL)
            return RPC_S_OUT_OF_MEMORY;

        NtStatus = NtQuerySystemInformation(SystemProcessInformation, pProcessDataBuffer,
            CurrentAllocatedSize, NULL);
        }
    while (NtStatus == STATUS_INFO_LENGTH_MISMATCH);

    if (!NT_SUCCESS(NtStatus))
        return RPC_S_OUT_OF_MEMORY;

    // walk the buffer - on first pass, we just count the entries
    pCurrentPos = (unsigned char *)pProcessDataBuffer;
    pCurrentProcessInfo = (SYSTEM_PROCESS_INFORMATION *)pCurrentPos;
    NumberOfProcesses = 0;
    while (TRUE)
        {
        // we skip idle process and zombie processes
        if (pCurrentProcessInfo->UniqueProcessId != NULL)
            {
            NumberOfProcesses ++;
            }
        // is there a place to advance to?
        if (pCurrentProcessInfo->NextEntryOffset == 0)
            break;
        pCurrentPos += pCurrentProcessInfo->NextEntryOffset;
        pCurrentProcessInfo = (SYSTEM_PROCESS_INFORMATION *)pCurrentPos;
        }

    pNewState = (ServerEnumerationState *) new char [
        sizeof(ServerEnumerationState) + (NumberOfProcesses - 1) * sizeof(ULONG)];
    // implicit placement
//    pNewState = new ((NumberOfProcesses - 1) * sizeof(ULONG)) ServerEnumerationState;
    if (pNewState == NULL)
        {
        fResult = VirtualFree(pProcessDataBuffer, 0, MEM_RELEASE);
        ASSERT(fResult);
        return RPC_S_OUT_OF_MEMORY;
        }

    new (pNewState) ServerEnumerationState;
    // make the second pass - actual copying of data
    pCurrentPos = (unsigned char *)pProcessDataBuffer;
    pCurrentProcessInfo = (SYSTEM_PROCESS_INFORMATION *)pCurrentPos;
    i = 0;
    while (TRUE)
        {
        // we skip idle process and zombie processes
        if (pCurrentProcessInfo->UniqueProcessId != NULL)
            {
            pNewState->ProcessUniqueId[i] = PtrToUlong(pCurrentProcessInfo->UniqueProcessId);
            i ++;
            }
        // is there a place to advance to?
        if (pCurrentProcessInfo->NextEntryOffset == 0)
            break;
        pCurrentPos += pCurrentProcessInfo->NextEntryOffset;
        pCurrentProcessInfo = (SYSTEM_PROCESS_INFORMATION *)pCurrentPos;
        }

    ASSERT(i == NumberOfProcesses);

    fResult = VirtualFree(pProcessDataBuffer, 0, MEM_RELEASE);
    ASSERT(fResult);

    // make the data available to the user
    pNewState->CurrentPosition = 0;
    pNewState->NumberOfProcesses = NumberOfProcesses;
    *pHandle = pNewState;
    return RPC_S_OK;
}

RPC_STATUS OpenNextRPCServer(IN ServerEnumerationHandle Handle, OUT CellEnumerationHandle *pHandle)
{
    ServerEnumerationState *ServerState = (ServerEnumerationState *)Handle;
    int CurrentPosition;
    RPC_STATUS RpcStatus;
    
    ASSERT(ServerState != NULL);
    ASSERT(pHandle != NULL);

    do
        {
        CurrentPosition = ServerState->CurrentPosition;

        if (CurrentPosition >= ServerState->NumberOfProcesses)
            return RPC_S_INVALID_BOUND;

        ServerState->CurrentPosition ++;
    
        RpcStatus = OpenRPCServerDebugInfo(ServerState->ProcessUniqueId[CurrentPosition], pHandle);
        }
    while(RpcStatus == ERROR_FILE_NOT_FOUND);

    return RpcStatus;
}

void ResetServerEnumeration(IN ServerEnumerationHandle Handle)
{
    ServerEnumerationState *ServerState = (ServerEnumerationState *)Handle;
    
    ASSERT(ServerState != NULL);
    ServerState->CurrentPosition = 0;
}

void FinishServerEnumeration(ServerEnumerationHandle *pHandle)
{
    ServerEnumerationState *ServerState;

    ASSERT (pHandle != NULL);
    ServerState = *(ServerEnumerationState **)pHandle;
    ASSERT(ServerState != NULL);
    delete ServerState;
    *pHandle = NULL;
}

DWORD GetCurrentServerPID(IN ServerEnumerationHandle Handle)
{
    ServerEnumerationState *ServerState = (ServerEnumerationState *)Handle;
    
    ASSERT(ServerState != NULL);
    // -1, because the CurrentPosition points to the next server
    return (DWORD)ServerState->ProcessUniqueId[ServerState->CurrentPosition - 1];
}

// a helper function
// whenever we detect an inconsistency in one of the lists,
// we can call this function, which will determine what to do
// with the current section, and will transfer sections between
// the OpenedSections list and the InconsistentSections list
void InconsistencyDetected(IN LIST_ENTRY *OpenedSections, IN LIST_ENTRY *InconsistentSections,
                           IN LIST_ENTRY *CurrentListEntry, IN OpenedDbgSection *pCurrentSection,
                           BOOL fExceptionOccurred)
{
    LIST_ENTRY *NextEntry;
    LIST_ENTRY *LastEntry;

    // if an exception occurred, throw away this section altogether
    if (fExceptionOccurred)
        {
        // save the next entry before we delete this one
        NextEntry = CurrentListEntry->Flink;
        RemoveEntryList(CurrentListEntry);
        CloseDbgSection(pCurrentSection->SectionHandle, pCurrentSection->SectionPointer);
        delete pCurrentSection;

        CurrentListEntry = NextEntry;
        pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);

        // if the bad section was the last on the list,
        // there is nothing to add to the grab bag - just
        // return
        if (CurrentListEntry == OpenedSections)
            {
            return;
            }
        }

    // the chain is broken - we need to throw the rest of the list in
    // the grab bag
    // unchain this segment from the opened sections list
    LastEntry = OpenedSections->Blink;
    OpenedSections->Blink = CurrentListEntry->Blink;
    CurrentListEntry->Blink->Flink = OpenedSections;
    // chain the segment to the inconsistent sections list
    CurrentListEntry->Blink = InconsistentSections->Blink;
    InconsistentSections->Blink->Flink = CurrentListEntry;
    InconsistentSections->Blink = LastEntry;
    LastEntry->Flink = InconsistentSections;
}

RPC_STATUS OpenRPCServerDebugInfo(IN DWORD ProcessID, OUT CellEnumerationHandle *pHandle)
{
    RPC_STATUS RpcStatus;
    HANDLE SecHandle;
    PVOID SecPointer;
    int Retries = 10;
    BOOL fConsistentSnapshotObtained = FALSE;
    BOOL fNeedToRetry;
    CellSection *CurrentSection;
    DWORD SectionNumbers[2];
    OpenedDbgSection *pCurrentSection;
    // each section as it is opened, is linked on one of those lists
    // if the view of the sections is consistent, we link it to opened
    // sections. Otherwise, we link it to InconsistentSections
    LIST_ENTRY OpenedSections;
    LIST_ENTRY InconsistentSections;
    LIST_ENTRY *CurrentListEntry;
    DWORD *pActualSectionNumbers;
    BOOL fExceptionOccurred;
    LIST_ENTRY *LastEntry;
    BOOL fFound;
    int NumberOfCommittedPages;
    BOOL fConsistencyPass = FALSE;
    DWORD LocalPageSize;
    SectionsSnapshot *LocalSectionsSnapshot;
    BOOL fResult;

    RpcStatus = InitializeDbgLib();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    LocalPageSize = GetPageSize();

    // loop until we obtain a consistent snapshot or we are out of 
    // retry attempts. We declare a snapshot to be consistent
    // if we manage to:
    //   - open all sections
    //   - copy their contents to a private memory location
    //   - verify that the section chain is still consistent after the copying
    // For this purpose, when we copy all the sections, we make one more
    // pass at the section chain to verify it is consistent using the special
    // flag fConsistencyPass.
    InconsistentSections.Blink = InconsistentSections.Flink = &InconsistentSections;
    OpenedSections.Blink = OpenedSections.Flink = &OpenedSections;

    while (Retries > 0)
        {
        // on entry to the loop, the state will be this - OpenSections will
        // contain a consistent view of the sections. Inconsistent sections
        // will be a grab bag of sections we could not bring into
        // consistent view. It's used as a cache to facilitate quick
        // recovery

        // we are just starting, or we are recovering from an inconsistency
        // found somewhere. As soon as somebody detects an inconsistency,
        // they will jump here. First thing is to try to establish what
        // part of the chain is consistent. Walk the open sections for
        // this purpose. We walk as far as we can, and then we declare
        // the rest of the sections inconsistent, and we throw them in
        // the grab bag
        SectionNumbers[0] = SectionNumbers[1] = 0;
        CurrentListEntry = OpenedSections.Flink;
        fNeedToRetry = FALSE;
        while (CurrentListEntry != &OpenedSections)
            {
            pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
            if ((SectionNumbers[0] != pCurrentSection->SectionNumbers[0])
                || (SectionNumbers[1] != pCurrentSection->SectionNumbers[1]))
                {
                fNeedToRetry = TRUE;
                }
            else
                {
                __try
                    {
                    // attempt to read the numbers of the next section
                    // we do this within try/except since server may free this
                    // memory and we will get toast
                    SectionNumbers[0] = pCurrentSection->SectionPointer->NextSectionId[0];
                    SectionNumbers[1] = pCurrentSection->SectionPointer->NextSectionId[1];

                    fExceptionOccurred = FALSE;

                    // note that the SectionNumbers array will be used after the end of
                    // the loop - make sure we don't whack them
                    }
                __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                    fExceptionOccurred = TRUE;
                    fNeedToRetry = TRUE;
                    }
                }

            if (fNeedToRetry)
                {
                // if this is the first section, the server went down. There is no
                // legal way for the server to have inconsistent first section
                if (CurrentListEntry == OpenedSections.Flink)
                    {
                    RpcStatus = ERROR_FILE_NOT_FOUND;
                    goto CleanupAndExit;
                    }

                InconsistencyDetected(&OpenedSections, &InconsistentSections, CurrentListEntry,
                    pCurrentSection, fExceptionOccurred);

                fNeedToRetry = TRUE;
                break;
                }

            CurrentListEntry = CurrentListEntry->Flink;
            }

        // walking is complete. Did we detect inconsistency?
        if (fNeedToRetry)
            {
            Retries --;
            fConsistencyPass = FALSE;
            continue;
            }
        else if (fConsistencyPass)
            {
            // this is the only place we break out of the loop -
            // the consistency pass has passed
            break;
            }

        // whatever we have in the opened sections list is consistent
        // if there was something in the list keep reading,
        // otherwise, start reading
        if (IsListEmpty(&OpenedSections))
            {
            pActualSectionNumbers = NULL;
            }
        else
            {
            pCurrentSection = CONTAINING_RECORD(OpenedSections.Blink, OpenedDbgSection, SectionsList);
            // we re-use the section numbers from the loop above. They can be 0 at
            // this point if the last section got dropped
            pActualSectionNumbers = SectionNumbers;
            }

        // make a pass over the sections, opening each one, but only if
        // case we're missing parts of the chain or this is the first time. 
        // Otherwise, skip this step
        while ((SectionNumbers[0] != 0) || (SectionNumbers[1] != 0) || (pActualSectionNumbers == NULL))
            {
            // we know which section we're looking for
            // first, search the grab bag. We can only do this for a non-first
            // section. The first section never goes to the grab bag
            // pActualSectionNumbers will contain the section we're looking for
            fFound = FALSE;
            if (pActualSectionNumbers)
                {
                CurrentListEntry = InconsistentSections.Flink;
                while (CurrentListEntry != &InconsistentSections)
                    {
                    pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
                    // it is impossible that a well behaving server will have
                    // opened a different section with the same numbers, because we
                    // keep the section object opened.
                    if ((pActualSectionNumbers[0] == pCurrentSection->SectionNumbers[0])
                        && (pActualSectionNumbers[1] == pCurrentSection->SectionNumbers[1]))
                        {
                        // found something
                        RemoveEntryList(CurrentListEntry);

                        // if we had already made a copy of this one, free it, as it is
                        // probably inconsistent
                        if (pCurrentSection->SectionCopy)
                            {
                            fResult = VirtualFree(pCurrentSection->SectionCopy, 0, MEM_RELEASE);
                            ASSERT(fResult);
                            pCurrentSection->SectionCopy = NULL;
                            }
                        fFound = TRUE;
                        break;
                        }
                    CurrentListEntry = CurrentListEntry->Flink;
                    }
                }

            if (fFound == FALSE)
                {
                // nothing in the grab bag - try to open it the normal way
                RpcStatus = OpenDbgSection(&SecHandle, &SecPointer, ProcessID, pActualSectionNumbers);
                if (RpcStatus == ERROR_FILE_NOT_FOUND)
                    {
                    // if this is the first time, this is not a server - bail out
                    if (pActualSectionNumbers == NULL)
                        {
                        goto CleanupAndExit;
                        }

                    // not the first time - we have an inconsistent view - need to retry
                    fNeedToRetry = TRUE;
                    break;
                    }
                else if (RpcStatus != RPC_S_OK)
                    {
                    goto CleanupAndExit;
                    }

                pCurrentSection = new OpenedDbgSection;
                if (pCurrentSection == NULL)
                    {
                    RpcStatus = RPC_S_OUT_OF_MEMORY;
                    CloseDbgSection(SecHandle, SecPointer);
                    goto CleanupAndExit;
                    }

                pCurrentSection->SectionHandle = SecHandle;
                if (pActualSectionNumbers)
                    {
                    pCurrentSection->SectionNumbers[0] = pActualSectionNumbers[0];
                    pCurrentSection->SectionNumbers[1] = pActualSectionNumbers[1];
                    }
                else
                    {
                    pCurrentSection->SectionNumbers[0] = pCurrentSection->SectionNumbers[1] = 0;
                    }
                pCurrentSection->SectionPointer = (CellSection *) SecPointer;
                pCurrentSection->SectionCopy = NULL;
                }

            // either we have found this in the grab bag, or we have just opened it
            // both ways, try to get the section numbers we expect for the next section
            __try
                {
                // load the section numbers that we expect for the next iteration of the
                // loop
                SectionNumbers[0] = pCurrentSection->SectionPointer->NextSectionId[0];
                SectionNumbers[1] = pCurrentSection->SectionPointer->NextSectionId[1];
                pActualSectionNumbers = SectionNumbers;
                fExceptionOccurred = FALSE;
                }
            __except (EXCEPTION_EXECUTE_HANDLER)
                {
                fExceptionOccurred = TRUE;
                }

            if (fExceptionOccurred)
                {
                delete pCurrentSection;
                CloseDbgSection(SecHandle, SecPointer);
                fNeedToRetry = TRUE;
                break;
                }

            InsertTailList(&OpenedSections, &pCurrentSection->SectionsList);
            }

        if (fNeedToRetry)
            {
            Retries --;
            fConsistencyPass = FALSE;
            continue;
            }

        // at this point, we have opened all the sections
        // now we need to allocate memory for the snapshots and to do the copying
        CurrentListEntry = OpenedSections.Flink;
        while (CurrentListEntry != &OpenedSections)
            {
            pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
            __try
                {
                // do all the allocation and copying only if it hasn't been done yet
                if (pCurrentSection->SectionCopy == NULL)
                    {
                    NumberOfCommittedPages = pCurrentSection->SectionPointer->LastCommittedPage;
                    pCurrentSection->SectionCopy = (CellSection *)VirtualAlloc(NULL, 
                        NumberOfCommittedPages * LocalPageSize, MEM_COMMIT, PAGE_READWRITE);
                    if (pCurrentSection->SectionCopy == NULL)
                        {
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        goto CleanupAndExit;
                        }
                    memcpy(pCurrentSection->SectionCopy, pCurrentSection->SectionPointer, 
                        NumberOfCommittedPages * LocalPageSize);
                    pCurrentSection->SectionID = pCurrentSection->SectionPointer->SectionID;
                    pCurrentSection->CommittedPagesInSection = NumberOfCommittedPages;
                    }
                fExceptionOccurred = FALSE;
                }
            __except (EXCEPTION_EXECUTE_HANDLER)
                {
                fExceptionOccurred = TRUE;
                }

            if (fExceptionOccurred)
                {
                if (pCurrentSection->SectionCopy)
                    {
                    fResult = VirtualFree(pCurrentSection->SectionCopy, 0, MEM_RELEASE);
                    ASSERT(fResult);
                    pCurrentSection->SectionCopy = NULL;
                    }

                // the section got out of sync
                InconsistencyDetected(&OpenedSections, &InconsistentSections, CurrentListEntry,
                    pCurrentSection, fExceptionOccurred);
                fNeedToRetry = TRUE;
                break;
                }

            CurrentListEntry = CurrentListEntry->Flink;
            }

        if (fNeedToRetry)
            {
            Retries --;
            fConsistencyPass = FALSE;
            continue;
            }
        else
            {
            fConsistencyPass = TRUE;
            }
        }

        // if we managed to get a consistent view, unmap the shared sections and 
        // save the opened section list
        if (Retries != 0)
            {
            ASSERT(fConsistencyPass == TRUE);
            ASSERT(fNeedToRetry == FALSE);
            ASSERT(!IsListEmpty(&OpenedSections));

            CurrentListEntry = OpenedSections.Flink;
            while (CurrentListEntry != &OpenedSections)
                {
                pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);

                CloseDbgSection(pCurrentSection->SectionHandle, pCurrentSection->SectionPointer);
                pCurrentSection->SectionHandle = NULL;
                pCurrentSection->SectionPointer = NULL;
                pCurrentSection->SectionNumbers[0] = pCurrentSection->SectionNumbers[1] = 0;

                CurrentListEntry = CurrentListEntry->Flink;
                }

            // save the opened section list
            CurrentListEntry = OpenedSections.Flink;
            pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
            LocalSectionsSnapshot = new SectionsSnapshot;
            if (LocalSectionsSnapshot != NULL)
                {
                LocalSectionsSnapshot->CellIndex = 0;
                LocalSectionsSnapshot->FirstOpenedSection = pCurrentSection;
                LocalSectionsSnapshot->CurrentOpenedSection = pCurrentSection;

                // unchain the opened sections
                // terminate the chain with NULL
                OpenedSections.Blink->Flink = NULL;
                OpenedSections.Blink = OpenedSections.Flink = &OpenedSections;

                // that's the only place where we return success
                *pHandle = (CellEnumerationHandle)LocalSectionsSnapshot;
                RpcStatus = RPC_S_OK;
                }
            else
                {
                // let the CleanupAndExit code destroy the lists
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                }
            }
        else
            {
            // we couldn't get a consistent snapshot of the server and
            // we ran out of retries
            RpcStatus = RPC_S_CANNOT_SUPPORT;
            }

CleanupAndExit:

    // walk the two lists, and free all sections on them
    CurrentListEntry = OpenedSections.Flink;
    while (CurrentListEntry != &OpenedSections)
        {
        pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
        // advance the pointer while we haven't freed the stuff
        CurrentListEntry = CurrentListEntry->Flink;
        if (pCurrentSection->SectionCopy)
            {
            fResult = VirtualFree(pCurrentSection->SectionCopy, 0, MEM_RELEASE);
            ASSERT(fResult);
            }
        if (pCurrentSection->SectionHandle)
            {
            ASSERT(pCurrentSection->SectionPointer);
            CloseDbgSection(pCurrentSection->SectionHandle, pCurrentSection->SectionPointer);
            }
        delete pCurrentSection;
        }

    CurrentListEntry = InconsistentSections.Flink;
    while (CurrentListEntry != &InconsistentSections)
        {
        pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
        // advance the pointer while we haven't freed the stuff
        CurrentListEntry = CurrentListEntry->Flink;
        if (pCurrentSection->SectionCopy)
            {
            fResult = VirtualFree(pCurrentSection->SectionCopy, 0, MEM_RELEASE);
            ASSERT(fResult);
            }
        if (pCurrentSection->SectionHandle)
            {
            ASSERT(pCurrentSection->SectionPointer);
            CloseDbgSection(pCurrentSection->SectionHandle, pCurrentSection->SectionPointer);
            }
        delete pCurrentSection;
        }
    return RpcStatus;
}

DebugCellUnion *GetNextDebugCellInfo(IN CellEnumerationHandle Handle, OUT DebugCellID *CellID)
{
    SectionsSnapshot *Snapshot = (SectionsSnapshot *)Handle;
    OpenedDbgSection *CurrentSection, *NextSection;
    DebugCellGeneric *CurrentCell;
    int CurrentCellIndex;
    DebugCellGeneric *LastCellForCurrentSection;
    DWORD LocalPageSize = GetPageSize();

    ASSERT(Handle != NULL);

    CurrentSection = Snapshot->CurrentOpenedSection;
    LastCellForCurrentSection = GetLastCellForSection(CurrentSection, LocalPageSize);
    if (Snapshot->CellIndex == 0)
        {
#ifdef _WIN64
        Snapshot->CellIndex = 2;
#else
        Snapshot->CellIndex = 1;
#endif
        }
    CurrentCell = GetCellForSection(CurrentSection, Snapshot->CellIndex);

    while (TRUE)
        {
        // did we exhaust the current section?
        if (CurrentCell > LastCellForCurrentSection)
            {
            // try to advance to the next one
            if (CurrentSection->SectionsList.Flink)
                {
                CurrentSection = CONTAINING_RECORD(CurrentSection->SectionsList.Flink, 
                    OpenedDbgSection, SectionsList);
                Snapshot->CurrentOpenedSection = CurrentSection;
#ifdef _WIN64
                Snapshot->CellIndex = 2;
#else
                Snapshot->CellIndex = 1;
#endif
                LastCellForCurrentSection = GetLastCellForSection(CurrentSection, LocalPageSize);

                CurrentCell = GetCellForSection(CurrentSection, Snapshot->CellIndex);
                continue;
                }
            return NULL;
            }
        CellID->CellID = (USHORT) Snapshot->CellIndex;
        Snapshot->CellIndex ++;
        if ((CurrentCell->Type == dctCallInfo) || (CurrentCell->Type == dctThreadInfo) 
            || (CurrentCell->Type == dctEndpointInfo) || (CurrentCell->Type == dctClientCallInfo))
            {
            CellID->SectionID = (USHORT)CurrentSection->SectionID;
            return (DebugCellUnion *)CurrentCell;
            }
        CurrentCell = (DebugCellGeneric *)((unsigned char *)CurrentCell + sizeof(DebugFreeCell));
        }

    return NULL;
}

void ResetRPCServerDebugInfo(IN CellEnumerationHandle Handle)
{
    SectionsSnapshot *LocalSnapshot = (SectionsSnapshot *)Handle;

    ASSERT(Handle != NULL);
    LocalSnapshot->CellIndex = 0;
    LocalSnapshot->CurrentOpenedSection = LocalSnapshot->FirstOpenedSection;
}

void CloseRPCServerDebugInfo(IN CellEnumerationHandle *pHandle)
{
    SectionsSnapshot *LocalSnapshot;
    OpenedDbgSection *DbgSection;
    LIST_ENTRY *CurrentListEntry;

    ASSERT(pHandle != NULL);
    LocalSnapshot = (SectionsSnapshot *)*pHandle;
    ASSERT(LocalSnapshot != NULL);
    ASSERT(LocalSnapshot->FirstOpenedSection != NULL);

    DbgSection = LocalSnapshot->FirstOpenedSection;

    do
        {
        // advance while we can
        CurrentListEntry = DbgSection->SectionsList.Flink;

        // free the section
        ASSERT(DbgSection->SectionCopy);
        VirtualFree(DbgSection->SectionCopy, 0, MEM_RELEASE);
        delete DbgSection;

        // calculate next record. Note that this will not AV even if 
        // CurrentListEntry is NULL - this is just offset calculation
        DbgSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
        }
    while (CurrentListEntry != NULL);

    delete LocalSnapshot;

    *pHandle = NULL;
}

typedef struct tagRPCSystemWideCellEnumeration
{
    ServerEnumerationHandle serverHandle;
    CellEnumerationHandle cellHandle;
} RPCSystemWideCellEnumeration;

RPC_STATUS OpenRPCSystemWideCellEnumeration(OUT RPCSystemWideCellEnumerationHandle *pHandle)
{
    RPCSystemWideCellEnumeration *cellEnum;
    RPC_STATUS Status;
    DebugCellUnion *NextCell;

    ASSERT(pHandle != NULL);
    *pHandle = NULL;
    cellEnum = new RPCSystemWideCellEnumeration;
    if (cellEnum == NULL)
        return RPC_S_OUT_OF_MEMORY;

    cellEnum->cellHandle = NULL;
    cellEnum->serverHandle = NULL;

    Status = StartServerEnumeration(&cellEnum->serverHandle);
    if (Status != RPC_S_OK)
        {
        delete cellEnum;
        return Status;
        }

    Status = OpenNextRPCServer(cellEnum->serverHandle, &cellEnum->cellHandle);

    // if we're done, we will get RPC_S_SERVER_INVALID_BOUND - ok to 
    // just return to caller
    if (Status != RPC_S_OK)
        {
        FinishServerEnumeration(&cellEnum->serverHandle);
        delete cellEnum;
        return Status;
        }

    *pHandle = (RPCSystemWideCellEnumerationHandle) cellEnum;
    return RPC_S_OK;
}

RPC_STATUS GetNextRPCSystemWideCell(IN RPCSystemWideCellEnumerationHandle handle, OUT DebugCellUnion **NextCell,
                                    OUT DebugCellID *CellID, OUT DWORD *ServerPID OPTIONAL)
{
    RPCSystemWideCellEnumeration *cellEnum = (RPCSystemWideCellEnumeration *)handle;
    RPC_STATUS Status;

    ASSERT(cellEnum != NULL);

    // loop skipping empty servers
    do
        {
        *NextCell = GetNextDebugCellInfo(cellEnum->cellHandle, CellID);

        // this server is done - move on to the next
        if (*NextCell == NULL)
            {
            CloseRPCServerDebugInfo(&cellEnum->cellHandle);
            Status = OpenNextRPCServer(cellEnum->serverHandle, &cellEnum->cellHandle);

            // if we're done with all servers, we will get RPC_S_SERVER_INVALID_BOUND - ok to 
            // just return to caller. Caller needs to call us back to finish enumeration
            if (Status != RPC_S_OK)
                {
                // remember that this failed so that we don't try to clean it up
                // when finishing the enumeration
                cellEnum->cellHandle = NULL;
                return Status;
                }
            }
        } 
    while(*NextCell == NULL);

    if (ServerPID && (*NextCell != NULL))
        {
        *ServerPID = GetCurrentServerPID(cellEnum->serverHandle);
        }

    return RPC_S_OK;
}

DebugCellUnion *GetRPCSystemWideCellFromCellID(IN RPCSystemWideCellEnumerationHandle handle, 
                                               IN DebugCellID CellID)
{
    RPCSystemWideCellEnumeration *cellEnum = (RPCSystemWideCellEnumeration *)handle;

    return GetCellByDebugCellID(cellEnum->cellHandle, CellID);
}

void FinishRPCSystemWideCellEnumeration(IN OUT RPCSystemWideCellEnumerationHandle *pHandle)
{
    RPCSystemWideCellEnumeration *cellEnum;

    ASSERT(pHandle != NULL);
    cellEnum = (RPCSystemWideCellEnumeration *)*pHandle;
    ASSERT(cellEnum != NULL);

    if (cellEnum->cellHandle)
        {
        CloseRPCServerDebugInfo(&cellEnum->cellHandle);
        }
    FinishServerEnumeration(&cellEnum->serverHandle);
    delete cellEnum;
    *pHandle = NULL;
}

RPC_STATUS ResetRPCSystemWideCellEnumeration(IN RPCSystemWideCellEnumerationHandle handle)
{
    RPCSystemWideCellEnumeration *cellEnum = (RPCSystemWideCellEnumeration *)handle;
    RPC_STATUS Status;

    ASSERT(cellEnum != NULL);

    if (cellEnum->cellHandle)
        {
        CloseRPCServerDebugInfo(&cellEnum->cellHandle);
        cellEnum->cellHandle = NULL;
        }

    ResetServerEnumeration(cellEnum->serverHandle);

    Status = OpenNextRPCServer(cellEnum->serverHandle, &cellEnum->cellHandle);
    if (Status != RPC_S_OK)
        {
        // remember that this failed so that we don't try to clean it up
        // when finishing the enumeration
        cellEnum->cellHandle = NULL;
        }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\epmap\dbgsvr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    DbgSvr.cxx

Abstract:

    The debugging support interfaces in RPCSS

Author:

    Kamen Moutafov    [KamenM]


Revision History:

    KamenM     Dec 99           Creation

--*/

#include <sysinc.h>

#include <wincrypt.h>
#include <wtypes.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <rpcerrp.h>
#include <rpctrans.hxx>
#include <objidl.h>
#include <CellDef.hxx>
#include <DbgIdl.h>

START_C_EXTERN

RPC_STATUS RPC_ENTRY
DebugServerSecurityCallback (
    IN RPC_IF_HANDLE  InterfaceUuid,
    IN void *Context
    )
{
    RPC_STATUS Status, TempStatus;
    HANDLE TempHandle;
    PVOID SectionPointer;

    // Context is an SCALL
    Status = RpcImpersonateClient(Context);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    // try to open our own section - this is protected by ACL for admins & local system
    // only, so this should filter out unauthorized access
    Status = OpenDbgSection(&TempHandle, &SectionPointer, GetCurrentProcessId(), NULL);
    if (Status == RPC_S_OK)
        {
        CloseDbgSection(TempHandle, SectionPointer);
        }

    TempStatus = RpcRevertToSelfEx(Context);
    ASSERT(TempStatus == RPC_S_OK);
    return Status;
}

////////////////////////////////////////////////////////////////////
/// Local representation to wire representation translation routines
////////////////////////////////////////////////////////////////////

void TranslateLocalCallInfoToRemoteCallInfo(IN DebugCallInfo *LocalDebugInfo, 
                                            OUT RemoteDebugCallInfo *RemoteCallInfo)
{
    RemoteCallInfo->Type = LocalDebugInfo->Type;
    RemoteCallInfo->Status = LocalDebugInfo->Status;
    RemoteCallInfo->ProcNum = LocalDebugInfo->ProcNum;
    RemoteCallInfo->InterfaceUUIDStart = LocalDebugInfo->InterfaceUUIDStart;
    RemoteCallInfo->ServicingTID = LocalDebugInfo->ServicingTID;
    RemoteCallInfo->CallFlags = LocalDebugInfo->CallFlags;
    RemoteCallInfo->CallID = LocalDebugInfo->CallID;
    RemoteCallInfo->LastUpdateTime = LocalDebugInfo->LastUpdateTime;
    if (LocalDebugInfo->CallFlags & DBGCELL_LRPC_CALL)
        {
        RemoteCallInfo->ConnectionType = crtLrpcConnection;
        RemoteCallInfo->connInfo.Connection = LocalDebugInfo->Connection;
        }
    else
        {
        RemoteCallInfo->ConnectionType = crtOsfConnection;
        RemoteCallInfo->connInfo.Caller.PID = LocalDebugInfo->PID;
        RemoteCallInfo->connInfo.Caller.TID = LocalDebugInfo->TID;
        }
}

void TranslateLocalEndpointInfoToRemoteEndpointInfo(IN DebugEndpointInfo *LocalDebugInfo, 
                                                    OUT RemoteDebugEndpointInfo *RemoteEndpointInfo)
{
    RemoteEndpointInfo->Type = LocalDebugInfo->Type;
    RemoteEndpointInfo->ProtseqType = LocalDebugInfo->ProtseqType;
    RemoteEndpointInfo->Status = LocalDebugInfo->Status;

    // the endpoint name in the debug cell is not null terminated - process it specially
    RemoteEndpointInfo->EndpointNameLength = 0;
    RemoteEndpointInfo->EndpointName 
        = (unsigned char *)MIDL_user_allocate(DebugEndpointNameLength + 1);
    if (RemoteEndpointInfo->EndpointName != NULL)
        {
        memcpy(RemoteEndpointInfo->EndpointName, 
            LocalDebugInfo->EndpointName, DebugEndpointNameLength);
        RemoteEndpointInfo->EndpointName[DebugEndpointNameLength] = 0;
        RemoteEndpointInfo->EndpointNameLength 
            = strlen((const char *) RemoteEndpointInfo->EndpointName) + 1;
        }
}

void TranslateLocalThreadInfoToRemoteThreadInfo(IN DebugThreadInfo *LocalDebugInfo, 
                                                OUT RemoteDebugThreadInfo *RemoteThreadInfo)
{
    RemoteThreadInfo->Type = LocalDebugInfo->Type;
    RemoteThreadInfo->Status = LocalDebugInfo->Status;
    RemoteThreadInfo->LastUpdateTime = LocalDebugInfo->LastUpdateTime;
    RemoteThreadInfo->TID = LocalDebugInfo->TID;
    RemoteThreadInfo->Endpoint = LocalDebugInfo->Endpoint;
}

void TranslateLocalClientCallInfoToRemoteClientCallInfo(IN DebugClientCallInfo *LocalDebugInfo, 
                                                        OUT RemoteDebugClientCallInfo *RemoteClientCallInfo)
{
    RemoteClientCallInfo->Type = LocalDebugInfo->Type;
    RemoteClientCallInfo->ProcNum = LocalDebugInfo->ProcNum;
    RemoteClientCallInfo->ServicingThread = LocalDebugInfo->ServicingThread;
    RemoteClientCallInfo->IfStart = LocalDebugInfo->IfStart;
    RemoteClientCallInfo->CallID = LocalDebugInfo->CallID;
    RemoteClientCallInfo->CallTargetID = LocalDebugInfo->CallTargetID;

    // the endpoint in the debug cell is not null terminated - process it specially
    RemoteClientCallInfo->EndpointLength = 0;
    RemoteClientCallInfo->Endpoint 
        = (unsigned char *)MIDL_user_allocate(ClientCallEndpointLength + 1);
    if (RemoteClientCallInfo->Endpoint != NULL)
        {
        memcpy(RemoteClientCallInfo->Endpoint, 
            LocalDebugInfo->Endpoint, ClientCallEndpointLength);
        RemoteClientCallInfo->Endpoint[ClientCallEndpointLength] = 0;
        RemoteClientCallInfo->EndpointLength 
            = strlen((const char *) RemoteClientCallInfo->Endpoint) + 1;
        }
}

void TranslateLocalConnectionInfoToRemoteConnectionInfo(IN DebugConnectionInfo *LocalDebugInfo, 
                                                        OUT RemoteDebugConnectionInfo *RemoteConnectionInfo)
{
    RemoteConnectionInfo->Type = LocalDebugInfo->Type;
    RemoteConnectionInfo->Flags = LocalDebugInfo->Flags;
    RemoteConnectionInfo->LastTransmitFragmentSize 
        = LocalDebugInfo->LastTransmitFragmentSize;
    RemoteConnectionInfo->Endpoint = LocalDebugInfo->Endpoint;
    RemoteConnectionInfo->ConnectionID[0] 
        = HandleToUlong(LocalDebugInfo->ConnectionID[0]);
    RemoteConnectionInfo->ConnectionID[1] 
        = HandleToUlong(LocalDebugInfo->ConnectionID[1]);
    RemoteConnectionInfo->LastSendTime = LocalDebugInfo->LastSendTime;
    RemoteConnectionInfo->LastReceiveTime = LocalDebugInfo->LastReceiveTime;
}

void TranslateLocalCallTargetInfoToRemoteCallTargetInfo(IN DebugCallTargetInfo *LocalDebugInfo, 
                                                        OUT RemoteDebugCallTargetInfo *RemoteCallTargetInfo)
{
    RemoteCallTargetInfo->Type = LocalDebugInfo->Type;
    RemoteCallTargetInfo->ProtocolSequence = LocalDebugInfo->ProtocolSequence;
    RemoteCallTargetInfo->LastUpdateTime = LocalDebugInfo->LastUpdateTime;

    // the target server name in the debug cell is not null terminated - process it specially
    RemoteCallTargetInfo->TargetServerLength = 0;
    RemoteCallTargetInfo->TargetServer 
        = (unsigned char *)MIDL_user_allocate(TargetServerNameLength + 1);
    if (RemoteCallTargetInfo->TargetServer != NULL)
        {
        memcpy(RemoteCallTargetInfo->TargetServer, 
            LocalDebugInfo->TargetServer, TargetServerNameLength);
        RemoteCallTargetInfo->TargetServer[TargetServerNameLength] = 0;
        RemoteCallTargetInfo->TargetServerLength
            = strlen((const char *) RemoteCallTargetInfo->TargetServer) + 1;
        }
}

////////////////////////////////////////////////////////////////////
/// Remote get cell info routine
////////////////////////////////////////////////////////////////////

/* [fault_status][comm_status] */ error_status_t RemoteGetCellByDebugCellID( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD ProcessID,
    /* [in] */ DebugCellID CellID,
    /* [in, out, unique] */ RemoteDebugCellUnion __RPC_FAR *__RPC_FAR *debugInfo)
{
    DebugCellUnion Container;
    RemoteDebugCellUnion *ActualDebugInfo;
    RPC_STATUS Status;

    if (debugInfo == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    *debugInfo = NULL;
    ActualDebugInfo = (RemoteDebugCellUnion *) MIDL_user_allocate(sizeof(RemoteDebugCellUnion));

    if (ActualDebugInfo == NULL)
        return RPC_S_OUT_OF_MEMORY;

    Status = GetCellByDebugCellID(ProcessID, CellID, &Container);
    if (Status != RPC_S_OK)
        {
        MIDL_user_free(ActualDebugInfo);
        return Status;
        }

    ActualDebugInfo->UnionType = Container.callInfo.Type;
    if ((ActualDebugInfo->UnionType < dctFirstEntry) || (ActualDebugInfo->UnionType > dctLastEntry) 
        || (ActualDebugInfo->UnionType == dctInvalid) || (ActualDebugInfo->UnionType == dctFree)
        || (ActualDebugInfo->UnionType == dctUsedGeneric))
        {
        MIDL_user_free(ActualDebugInfo);
        return RPC_S_OBJECT_NOT_FOUND;
        }

    switch(ActualDebugInfo->UnionType)
        {
        case dctCallInfo:
            TranslateLocalCallInfoToRemoteCallInfo(&Container.callInfo, 
                &ActualDebugInfo->debugInfo.callInfo);
            break;

        case dctThreadInfo:
            TranslateLocalThreadInfoToRemoteThreadInfo(&Container.threadInfo,
                &ActualDebugInfo->debugInfo.threadInfo);
            break;

        case dctEndpointInfo:
            TranslateLocalEndpointInfoToRemoteEndpointInfo(&Container.endpointInfo, 
                &ActualDebugInfo->debugInfo.endpointInfo);
            break;

        case dctClientCallInfo:
            TranslateLocalClientCallInfoToRemoteClientCallInfo(&Container.clientCallInfo,
                &ActualDebugInfo->debugInfo.clientCallInfo);
            break;

        case dctConnectionInfo:
            TranslateLocalConnectionInfoToRemoteConnectionInfo(&Container.connectionInfo,
                &ActualDebugInfo->debugInfo.connectionInfo);
            break;

        case dctCallTargetInfo:
            TranslateLocalCallTargetInfoToRemoteCallTargetInfo(&Container.callTargetInfo,
                &ActualDebugInfo->debugInfo.callTargetInfo);
            break;

        default:
            ASSERT(0);

        }
    *debugInfo = ActualDebugInfo;
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////
/// Remote call enumeration routines
////////////////////////////////////////////////////////////////////

typedef enum tagRemoteEnumerationHandleType
{
    rehtCallInfo,
    rehtEndpointInfo,
    rehtThreadInfo,
    rehtClientCallInfo
} RemoteEnumerationHandleType;

typedef struct tagRemoteCallInfoEnumerationHandle
{
    RemoteEnumerationHandleType ThisHandleType;
    CallInfoEnumerationHandle h;
} RemoteCallInfoEnumerationHandle;

error_status_t RemoteOpenRPCDebugCallInfoEnumeration( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ DbgCallEnumHandle __RPC_FAR *h,
    /* [in] */ DWORD CallID,
    /* [in] */ DWORD IfStart,
    /* [in] */ int ProcNum,
    /* [in] */ DWORD ProcessID)
{
    RemoteCallInfoEnumerationHandle *rh;
    RPC_STATUS Status;

    *h = NULL;

    rh = new RemoteCallInfoEnumerationHandle;
    if (rh == NULL)
        return RPC_S_OUT_OF_MEMORY;

    rh->ThisHandleType = rehtCallInfo;
    Status = OpenRPCDebugCallInfoEnumeration(CallID, IfStart, ProcNum, ProcessID, &rh->h);
    if (Status != RPC_S_OK)
        {
        delete rh;
        return Status;
        }

    *h = rh;

    return RPC_S_OK;
}

error_status_t RemoteGetNextRPCDebugCallInfo( 
    /* [in] */ DbgCallEnumHandle h,
    /* [unique][out][in] */ RemoteDebugCallInfo __RPC_FAR *__RPC_FAR *debugInfo,
    /* [out] */ DebugCellID __RPC_FAR *CellID,
    /* [out] */ DWORD __RPC_FAR *ProcessID)
{
    RemoteCallInfoEnumerationHandle *rh;
    RPC_STATUS Status;
    DebugCallInfo *NextCall;

    if (debugInfo == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    *debugInfo = NULL;
    CellID->SectionID = 0;
    CellID->CellID = 0;
    
    rh = (RemoteCallInfoEnumerationHandle *)h;
    if (rh->ThisHandleType != rehtCallInfo)
        return ERROR_INVALID_HANDLE;

    Status = GetNextRPCDebugCallInfo(rh->h, &NextCall, CellID, ProcessID);
    if (Status == RPC_S_OK)
        {
        *debugInfo = (RemoteDebugCallInfo *) MIDL_user_allocate(sizeof(RemoteDebugCallInfo));
        if (*debugInfo != NULL)
            {
            TranslateLocalCallInfoToRemoteCallInfo(NextCall, *debugInfo);
            }
        else
            Status = RPC_S_OUT_OF_MEMORY;
        }
    return Status;
}

error_status_t RemoteFinishRPCDebugCallInfoEnumeration( 
    /* [out][in] */ DbgCallEnumHandle __RPC_FAR *h)
{
    RemoteCallInfoEnumerationHandle *rh;

    rh = (RemoteCallInfoEnumerationHandle *)*h;

    if (rh == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    if (rh->ThisHandleType != rehtCallInfo)
        return ERROR_INVALID_HANDLE;

    DbgCallEnumHandle_rundown(*h);

    *h = NULL;
    return RPC_S_OK;
}

void __RPC_USER DbgCallEnumHandle_rundown(DbgCallEnumHandle h)
{
    RemoteCallInfoEnumerationHandle *rh;

    rh = (RemoteCallInfoEnumerationHandle *)h;

    FinishRPCDebugCallInfoEnumeration(&rh->h);
    delete rh;
}


////////////////////////////////////////////////////////////////////
/// Remote endpoint enumeration routines
////////////////////////////////////////////////////////////////////

typedef struct tagRemoteEndpointInfoEnumerationHandle
{
    RemoteEnumerationHandleType ThisHandleType;
    EndpointInfoEnumerationHandle h;
} RemoteEndpointInfoEnumerationHandle;

error_status_t RemoteOpenRPCDebugEndpointInfoEnumeration( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ DbgEndpointEnumHandle __RPC_FAR *h,
    /* [in] */ short EndpointSize,
    /* [size_is][in] */ unsigned char __RPC_FAR *Endpoint)
{
    RemoteEndpointInfoEnumerationHandle *rh;
    RPC_STATUS Status;

    *h = NULL;

    rh = new RemoteEndpointInfoEnumerationHandle;
    if (rh == NULL)
        return RPC_S_OUT_OF_MEMORY;

    rh->ThisHandleType = rehtEndpointInfo;
    Status = OpenRPCDebugEndpointInfoEnumeration((EndpointSize > 0) ? (char *)Endpoint : NULL, &rh->h);
    if (Status != RPC_S_OK)
        {
        delete rh;
        return Status;
        }

    *h = rh;

    return RPC_S_OK;
}

error_status_t RemoteGetNextRPCDebugEndpointInfo( 
    /* [in] */ DbgEndpointEnumHandle h,
    /* [unique][out][in] */ RemoteDebugEndpointInfo __RPC_FAR *__RPC_FAR *debugInfo,
    /* [out] */ DebugCellID __RPC_FAR *CellID,
    /* [out] */ DWORD __RPC_FAR *ProcessID)
{
    RemoteEndpointInfoEnumerationHandle *rh;
    RPC_STATUS Status;
    DebugEndpointInfo *NextEndpoint;

    if (debugInfo == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    *debugInfo = NULL;
    CellID->SectionID = 0;
    CellID->CellID = 0;
    
    rh = (RemoteEndpointInfoEnumerationHandle *)h;
    if (rh->ThisHandleType != rehtEndpointInfo)
        return ERROR_INVALID_HANDLE;

    Status = GetNextRPCDebugEndpointInfo(rh->h, &NextEndpoint, CellID, ProcessID);
    if (Status == RPC_S_OK)
        {
        *debugInfo = (RemoteDebugEndpointInfo *) MIDL_user_allocate(sizeof(RemoteDebugEndpointInfo));
        if (*debugInfo != NULL)
            {
            TranslateLocalEndpointInfoToRemoteEndpointInfo(NextEndpoint, *debugInfo);
            }
        else
            Status = RPC_S_OUT_OF_MEMORY;
        }
    return Status;
}

error_status_t RemoteFinishRPCDebugEndpointInfoEnumeration( 
    /* [out][in] */ DbgEndpointEnumHandle __RPC_FAR *h)
{
    RemoteEndpointInfoEnumerationHandle *rh;

    rh = (RemoteEndpointInfoEnumerationHandle *)*h;

    if (rh == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    if (rh->ThisHandleType != rehtEndpointInfo)
        return ERROR_INVALID_HANDLE;

    DbgEndpointEnumHandle_rundown(*h);

    *h = NULL;
    return RPC_S_OK;
}

void __RPC_USER DbgEndpointEnumHandle_rundown(DbgEndpointEnumHandle h)
{
    RemoteEndpointInfoEnumerationHandle *rh;

    rh = (RemoteEndpointInfoEnumerationHandle *)h;

    FinishRPCDebugEndpointInfoEnumeration(&rh->h);
    delete rh;
}


////////////////////////////////////////////////////////////////////
/// Remote thread enumeration routines
////////////////////////////////////////////////////////////////////

typedef struct tagRemoteThreadInfoEnumerationHandle
{
    RemoteEnumerationHandleType ThisHandleType;
    ThreadInfoEnumerationHandle h;
} RemoteThreadInfoEnumerationHandle;

error_status_t RemoteOpenRPCDebugThreadInfoEnumeration( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ DbgThreadEnumHandle __RPC_FAR *h,
    /* [in] */ DWORD ProcessID,
    /* [in] */ DWORD ThreadID)
{
    RemoteThreadInfoEnumerationHandle *rh;
    RPC_STATUS Status;

    *h = NULL;

    rh = new RemoteThreadInfoEnumerationHandle;
    if (rh == NULL)
        return RPC_S_OUT_OF_MEMORY;

    rh->ThisHandleType = rehtThreadInfo;
    Status = OpenRPCDebugThreadInfoEnumeration(ProcessID, ThreadID, &rh->h);
    if (Status != RPC_S_OK)
        {
        delete rh;
        return Status;
        }

    *h = rh;

    return RPC_S_OK;
}

error_status_t RemoteGetNextRPCDebugThreadInfo( 
    /* [in] */ DbgThreadEnumHandle h,
    /* [unique][out][in] */ RemoteDebugThreadInfo __RPC_FAR *__RPC_FAR *debugInfo,
    /* [out] */ DebugCellID __RPC_FAR *CellID,
    /* [out] */ DWORD __RPC_FAR *ProcessID)
{
    RemoteThreadInfoEnumerationHandle *rh;
    RPC_STATUS Status;
    DebugThreadInfo *NextThread;

    if (debugInfo == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    *debugInfo = NULL;
    CellID->SectionID = 0;
    CellID->CellID = 0;
    
    rh = (RemoteThreadInfoEnumerationHandle *)h;
    if (rh->ThisHandleType != rehtThreadInfo)
        return ERROR_INVALID_HANDLE;

    Status = GetNextRPCDebugThreadInfo(rh->h, &NextThread, CellID, ProcessID);
    if (Status == RPC_S_OK)
        {
        *debugInfo = (RemoteDebugThreadInfo *) MIDL_user_allocate(sizeof(RemoteDebugThreadInfo));
        if (*debugInfo != NULL)
            {
            TranslateLocalThreadInfoToRemoteThreadInfo(NextThread, *debugInfo);
            }
        else
            Status = RPC_S_OUT_OF_MEMORY;
        }
    return Status;
}

error_status_t RemoteFinishRPCDebugThreadInfoEnumeration( 
    /* [out][in] */ DbgThreadEnumHandle __RPC_FAR *h)
{
    RemoteThreadInfoEnumerationHandle *rh;

    rh = (RemoteThreadInfoEnumerationHandle *)*h;

    if (rh == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    if (rh->ThisHandleType != rehtThreadInfo)
        return ERROR_INVALID_HANDLE;

    DbgThreadEnumHandle_rundown(*h);

    *h = NULL;
    return RPC_S_OK;
}

void __RPC_USER DbgThreadEnumHandle_rundown(DbgThreadEnumHandle h)
{
    RemoteThreadInfoEnumerationHandle *rh;

    rh = (RemoteThreadInfoEnumerationHandle *)h;

    FinishRPCDebugThreadInfoEnumeration(&rh->h);
    delete rh;
}

////////////////////////////////////////////////////////////////////
/// Remote client call enumeration routines
////////////////////////////////////////////////////////////////////

typedef struct tagRemoteClientCallInfoEnumerationHandle
{
    RemoteEnumerationHandleType ThisHandleType;
    ClientCallInfoEnumerationHandle h;
} RemoteClientCallInfoEnumerationHandle;

error_status_t RemoteOpenRPCDebugClientCallInfoEnumeration( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ DbgClientCallEnumHandle __RPC_FAR *h,
    /* [in] */ DWORD CallID,
    /* [in] */ DWORD IfStart,
    /* [in] */ int ProcNum,
    /* [in] */ DWORD ProcessID)
{
    RemoteClientCallInfoEnumerationHandle *rh;
    RPC_STATUS Status;

    *h = NULL;

    rh = new RemoteClientCallInfoEnumerationHandle;
    if (rh == NULL)
        return RPC_S_OUT_OF_MEMORY;

    rh->ThisHandleType = rehtClientCallInfo;
    Status = OpenRPCDebugClientCallInfoEnumeration(CallID, IfStart, ProcNum, ProcessID, &rh->h);
    if (Status != RPC_S_OK)
        {
        delete rh;
        return Status;
        }

    *h = rh;

    return RPC_S_OK;
}

error_status_t RemoteGetNextRPCDebugClientCallInfo( 
    /* [in] */ DbgClientCallEnumHandle h,
    /* [unique][out][in] */ RemoteDebugClientCallInfo __RPC_FAR *__RPC_FAR *debugInfo,
    /* [unique][out][in] */ RemoteDebugCallTargetInfo __RPC_FAR *__RPC_FAR *CallTargetDebugInfo,
    /* [out] */ DebugCellID __RPC_FAR *CellID,
    /* [out] */ DWORD __RPC_FAR *ProcessID)
{
    RemoteClientCallInfoEnumerationHandle *rh;
    RPC_STATUS Status;
    DebugClientCallInfo *NextClientCall;
    DebugCallTargetInfo *NextCallTarget;

    if (debugInfo == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    if (CallTargetDebugInfo == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    *debugInfo = NULL;
    *CallTargetDebugInfo = NULL;
    CellID->SectionID = 0;
    CellID->CellID = 0;
    
    rh = (RemoteClientCallInfoEnumerationHandle *)h;
    if (rh->ThisHandleType != rehtClientCallInfo)
        return ERROR_INVALID_HANDLE;

    Status = GetNextRPCDebugClientCallInfo(rh->h, &NextClientCall, &NextCallTarget, 
        CellID, ProcessID);
    if (Status == RPC_S_OK)
        {
        *debugInfo = (RemoteDebugClientCallInfo *) MIDL_user_allocate(sizeof(RemoteDebugClientCallInfo));
        if (*debugInfo != NULL)
            {
            TranslateLocalClientCallInfoToRemoteClientCallInfo(NextClientCall, *debugInfo);

            *CallTargetDebugInfo 
                = (RemoteDebugCallTargetInfo *)MIDL_user_allocate(sizeof(RemoteDebugCallTargetInfo));
            if (*CallTargetDebugInfo != NULL)
                {
                if ((NextCallTarget != NULL) && (NextCallTarget->Type != dctCallTargetInfo))
                    {
                    // inconsistent info - return NULL for call target
                    MIDL_user_free(*CallTargetDebugInfo);
                    *CallTargetDebugInfo = NULL;
                    NextCallTarget = NULL;
                    }
                else
                    {
                    TranslateLocalCallTargetInfoToRemoteCallTargetInfo(NextCallTarget, *CallTargetDebugInfo);
                    }
                }
            // else - don't care - this is a best effort. We will return what we
            // can. Client is prepared to handle NULL in the call target
            }
        else
            Status = RPC_S_OUT_OF_MEMORY;
        }
    return Status;
}

error_status_t RemoteFinishRPCDebugClientCallInfoEnumeration( 
    /* [out][in] */ DbgClientCallEnumHandle __RPC_FAR *h)
{
    RemoteClientCallInfoEnumerationHandle *rh;

    rh = (RemoteClientCallInfoEnumerationHandle *)*h;

    if (rh == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    if (rh->ThisHandleType != rehtClientCallInfo)
        return ERROR_INVALID_HANDLE;

    DbgClientCallEnumHandle_rundown(*h);

    *h = NULL;
    return RPC_S_OK;
}

void __RPC_USER DbgClientCallEnumHandle_rundown(DbgClientCallEnumHandle h)
{
    RemoteClientCallInfoEnumerationHandle *rh;

    rh = (RemoteClientCallInfoEnumerationHandle *)h;

    FinishRPCDebugClientCallInfoEnumeration(&rh->h);
    delete rh;
}

END_C_EXTERN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\epmap\epmap.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    epmap.c

Abstract:

    This file contains the EP Mapper startup code and process wide globals.

Author:

    Bharat Shah  (barats) 17-2-92

Revision History:

    06-16-95    MarioGo     Much of the code replaced by ..\wrapper\start.c
                            Renamed from server.c
    Jan 2000    KamenM      Add debugging support

--*/

#include <sysinc.h>
#include <wincrypt.h>
#include <rpc.h>
#include <winsvc.h>
#include "epmp.h"
#include "eptypes.h"
#include "local.h"
#include <DbgComn.h>
#include <DbgIdl.h>
#include <DbgSvr.hxx>

#if DBG && !defined(DEBUGRPC)
#define DEBUGRPC
#endif

//
// Endpoint Mapper Functions
//

extern RPC_STATUS InitializeIpPortManager();

extern RPC_STATUS RPC_ENTRY
LocalEpmpSecurityCallback (
    IN RPC_IF_HANDLE InterfaceUuid,
    IN void *Context
    );

//
// Endpoint Mapper Globals
//

HANDLE           hEpMapperHeap;
CRITICAL_SECTION EpCritSec;
PIFOBJNode       IFObjList = NULL;
PSAVEDCONTEXT    GlobalContextList = NULL;
unsigned long    cTotalEpEntries = 0L;
unsigned long    GlobalIFOBJid = 0xFFL;
unsigned long    GlobalEPid    = 0x00FFFFFFL;
UUID             NilUuid = { 0L, 0, 0, {0, 0, 0, 0, 0, 0, 0, 0} };


DWORD
StartEndpointMapper(
    void
    )
/*++

Routine Description:

    Called during dcomss startup.  Should call Updatestatus()
    if something will take very long.

Arguments:

    None

Return Value:

    0 - success

    non-0 - will cause the service to fail.

--*/
{
    extern void RPC_ENTRY UpdateAddresses( PVOID arg );

    RPC_STATUS status = RPC_S_OK;
    BOOL fAuthInfoNotRegistered = FALSE;

    InitializeCriticalSectionAndSpinCount(&EpCritSec, PREALLOCATE_EVENT_MASK);

    hEpMapperHeap = GetProcessHeap();

    if (hEpMapperHeap == 0)
        {
        ASSERT(GetLastError() != 0);
        return(GetLastError());
        }

    // register snego & kerberos. During clean install, this code can
    // legally fail, as Rpcss is started before there are any
    // security providers. Therefore, we cannot fail Rpcss init if this
    // fails - we just don't register the debug interface, who is the
    // only user of this
    status = RpcServerRegisterAuthInfo(NULL, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, NULL);

    if (status != RPC_S_OK)
        {
        fAuthInfoNotRegistered = TRUE;
        }

    status = RpcServerRegisterAuthInfo(NULL, RPC_C_AUTHN_GSS_KERBEROS, NULL, NULL);

    if (status != RPC_S_OK)
        {
        fAuthInfoNotRegistered = TRUE;
        }

    status = RpcServerRegisterIf2(epmp_ServerIfHandle,
                                  0,
                                  0,
                                  0,
                                  RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                  epmp_MaxRpcSize,
                                  NULL);

    if (status != RPC_S_OK)
        {
        return(status);
        }

    status = RpcServerRegisterIf2(localepmp_ServerIfHandle,
                                  0,
                                  0,                              
                                  0,
                                  RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                  localepmp_MaxRpcSize,
                                  LocalEpmpSecurityCallback);
    if (status != RPC_S_OK)
        {
        return(status);
        }

    if (fAuthInfoNotRegistered == FALSE)
        {
        status = RpcServerRegisterIf2(DbgIdl_ServerIfHandle,
                                      0,
                                      0,
                                      0,
                                      RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                      DbgIdl_MaxRpcSize,
                                      DebugServerSecurityCallback);
        if (status != RPC_S_OK)
            {
            return(status);
            }
        }

    status = I_RpcServerRegisterForwardFunction( GetForwardEp );

#ifndef DOSWIN32RPC
    if (status == RPC_S_OK)
        {
        status = InitializeIpPortManager();
        ASSERT(status == RPC_S_OK);
        }
#endif

    status = I_RpcServerSetAddressChangeFn( UpdateAddresses );

    ASSERT( 0 == status );

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\epmap\local.h ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    local.h

Abstract:

    Header file for Server side EP

Author:

    Bharat Shah  2/22/92

Revision History:

    06-03-97    gopalp      Added code to cleanup stale EP Mapper entries.

--*/

#ifndef __LOCAL_H__
#define __LOCAL_H__

//#define DBG_DETAIL

#define EP_TABLE_ENTRIES  12

#define CLEANUP_MAGIC_VALUE     0xDECAFBAD
#define PROCESS_MAGIC_VALUE     ((CLEANUP_MAGIC_VALUE)+1)


extern  HANDLE              hEpMapperHeap;
extern  CRITICAL_SECTION    EpCritSec;
extern  CRITICAL_SECTION    TableMutex;
extern  PIFOBJNode          IFObjList;
extern  unsigned long       cTotalEpEntries;
extern  unsigned long       GlobalIFOBJid;
extern  unsigned long       GlobalEPid;
extern  PSAVEDCONTEXT       GlobalContextList;
extern  UUID                NilUuid;
extern  ProtseqEndpointPair EpMapperTable[EP_TABLE_ENTRIES];



//
// Global thread locking functions
//

#ifdef NTENV
#define CheckInSem() \
    ASSERT(EpCritSec.OwningThread == ULongToPtr(GetCurrentThreadId()))
#else
#define CheckInSem()
#endif

#define  EnterSem()  EnterCriticalSection(&EpCritSec)
#define  LeaveSem()  LeaveCriticalSection(&EpCritSec)


//
// Allocation routines.
//


_inline void *
AllocMem(
    size_t Size
    )
{
    return (HeapAlloc(hEpMapperHeap, 0, Size));
}


_inline void
FreeMem(
    void * pvMem
    )
{
    HeapFree(hEpMapperHeap, 0, pvMem);
}




//
// Forward definitions
//

PIENTRY
Link(
    PIENTRY *ppHead,
    PIENTRY pNode
    );

PIENTRY
UnLink(
    PIENTRY *ppHead,
    PIENTRY pNode
    );

PIFOBJNode
FindIFOBJVer(
    PIFOBJNode *pList,
    I_EPENTRY *ep
    );

RPC_STATUS
IsNullUuid(
    UUID * Uuid
    );

RPC_STATUS
GetEntries(
    UUID *ObjUuid,
    UUID *IFUuid,
    ulong ver,
    char * pseq,
    PSID pSID,
    ept_lookup_handle_t *map_lookup_handle,
    char * binding,
    ulong calltype,
    ulong maxrequested,
    ulong *returned,
    ulong InqType,
    ulong VersOpts,
    PFNPointer Match
    );

RPC_STATUS
PackDataIntoBuffer(
    char * * buffer,
    PIFOBJNode pNode, PPSEPNode pPSEP,
    ulong fType,
    BOOL fPatchTower,
    int PatchTowerAddress
    );

RPC_STATUS
ExactMatch(
    PIFOBJNode pNode,
    UUID * Obj,
    UUID *If,
    unsigned long Ver,
    PSID pSID,
    unsigned long InqType,
    unsigned long Options
    );

RPC_STATUS
WildCardMatch(
    PIFOBJNode pNode,
    UUID * Obj,
    UUID * If,
    unsigned long Vers,
    PSID pSID,
    unsigned long InqType,
    unsigned long Options
    );

RPC_STATUS
SearchIFObjNode(
    PIFOBJNode pNode,
    UUID * Obj,
    UUID * If,
    unsigned long Vers,
    PSID pSID,
    unsigned long InqType,
    unsigned long Options
    );

RPC_STATUS
StartServer(
    );

VOID
LinkAtEnd(
    PIFOBJNode *Head,
    PIFOBJNode Node
    );

RPC_STATUS RPC_ENTRY
GetForwardEp(
    UUID *IfId,
    RPC_VERSION * IFVersion,
    UUID * Object,
    unsigned char* Protseq,
    void * * EpString
    );



//
// Link list manipulation rountines
//

RPC_STATUS
EnLinkOnIFOBJList(
    PEP_CLEANUP ProcessCtxt,
    PIFOBJNode NewNode
    );

RPC_STATUS
UnLinkFromIFOBJList(
    PEP_CLEANUP ProcessCtxt,
    PIFOBJNode DeleteMe
    );

#define EnLinkOnPSEPList(x,p)                   \
                                                \
            (PPSEPNode)                         \
            Link(                               \
                (PIENTRY *)(x),                 \
                (PIENTRY)(p)                    \
                )

#define EnLinkContext(p)                        \
                                                \
            (PSAVEDCONTEXT)                     \
            Link(                               \
                (PIENTRY *)(&GlobalContextList),\
                (PIENTRY)(p)                    \
                )

#define UnLinkContext(p)                        \
                                                \
            (PSAVEDCONTEXT)                     \
            UnLink(                             \
                (PIENTRY *)&GlobalContextList,  \
                (PIENTRY) (p)                   \
                )

#define UnLinkFromPSEPList(x,p)                 \
                                                \
            (PPSEPNode)                         \
            UnLink(                             \
                (PIENTRY *)(x),                 \
                (PIENTRY)(p)                    \
                )

#define MatchByIFOBJKey(x, p)                   \
                                                \
            (PIFOBJNode)                        \
            MatchByKey(                         \
                (PIENTRY)(x),                   \
                (ulong)(p)                      \
                )

#define MatchByPSEPKey(x, p)                    \
                                                \
            (PPSEPNode)                         \
            MatchByKey(                         \
                (PIENTRY)(x),                   \
                (ulong)(p)                      \
                )



#define MAXIFOBJID            (256L)
#define MAKEGLOBALIFOBJID(x)  ( ( ((x-1) % MAXIFOBJID) << 24 ) & 0xFF000000L )
#define MAKEGLOBALEPID(x,y)   ( ( ((x) &0xFF000000L) | ((y) & 0x00FFFFFFL) ) )

#define IFOBJSIGN             (0x49464F42L)
#define PSEPSIGN              (0x50534550L)
#define FREE                  (0xBADDC0DEL)


//
// Error Codes Here ??
//

#define  EP_LOOKUP                          0x00000001L
#define  EP_MAP                             0x00000002L

#define  RPC_C_EP_ALL_ELTS                  0
#define  RPC_C_EP_MATCH_BY_IF               1
#define  RPC_C_EP_MATCH_BY_OBJ              2
#define  RPC_C_EP_MATCH_BY_BOTH             3

#define  I_RPC_C_VERS_UPTO_AND_COMPATIBLE   6

#define VERSION(x,y)  ( ((0x0000FFFFL & x)<<16) | (y) )


//
//  States of listening..
//

#define NOTSTARTED        0
#define STARTINGTOLISTEN  1
#define STARTED           2




//
// IP Port Management stuff
//


// Each server process connected to the endpoint mapper
// keeps on an open context handle so that rpcss can
// clean up the database when a process dies.
// The PROCESS struct is the context handle.

typedef struct _IP_PORT
{
    struct _IP_PORT *pNext;
    USHORT Type;
    USHORT Port;
} IP_PORT;

typedef struct _PROCESS
{
    DWORD MagicVal;
    //
    // Zero if the process doesn't own any reserved IP ports.
    //
    IP_PORT *pPorts;

} PROCESS;

typedef struct _PORT_RANGE
{
    struct _PORT_RANGE *pNext;
    USHORT Max;  // Inclusive
    USHORT Min;  // Inclusive
} PORT_RANGE;


#ifdef DBG
void CountProcessContextList(EP_CLEANUP *pProcessContext, unsigned long nExpectedCount);
#define ASSERT_PROCESS_CONTEXT_LIST_COUNT(p, c) \
	CountProcessContextList(p, c)
#else
#define ASSERT_PROCESS_CONTEXT_LIST_COUNT(p, c)
#endif

#endif // __LOCAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\epmap\mqcommon.h ===
//----------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  Module Name:  mqcommon.h
//
//
//  Abstract:
//
//  This is the Message Queue (Falcon) datagram client dll.
//
//  Author:
//
//  Edward Reus (edwardr) 17-Jun-1996
//
//  Revision History:
//
//----------------------------------------------------------------


#ifndef MQCOMMON_H
#define MQCOMMON_H

#define UNICODE      // Use unicode API

// Use the following define to turn on verbose debug messages:
// #define MAJOR_DEBUG


//----------------------------------------------------------------
//  Constants:
//----------------------------------------------------------------

#define DG_MQ_TRANSPORT_VERSION    1    // Not used.
#define MAX_PATHNAME_LEN         256
#define MAX_FORMAT_LEN           128
#define MAX_COMPUTERNAME_LEN      32
#define MAX_VAR                   20
#define MAX_SEND_VAR              20
#define MAX_RECV_VAR              20
#define MAX_SID_SIZE             256    // A typical SID is 20-30 bytes...
#define MAX_USERNAME_SIZE        256
#define MAX_DOMAIN_SIZE          256
#define UUID_LEN                  40

#define TRANSPORTID             0x1D    // Not official yet...
#define TRANSPORTHOSTID         0x1E
#define PROTSEQ                "ncadg_mq"
#define ENDPOINT_MAPPER_EP     "EpMapper"

#define WS_SEPARATOR               TEXT("\\")
#define WS_PRIVATE_DOLLAR          TEXT("\\PRIVATE$\\")

// These constants are use for temporary queue management:
#define Q_SVC_PROTSEQ              TEXT("ncalrpc")
#define Q_SVC_ENDPOINT             TEXT("epmapper")

// These are the MQ Queue Type UUIDs for RPC:
#define SVR_QTYPE_UUID_STR         TEXT("bbd97de0-cb4f-11cf-8e62-00aa006b4f2f")
#define CLNT_QTYPE_UUID_STR        TEXT("8e482920-cead-11cf-8e68-00aa006b4f2f")
#define CLNT_ADMIN_QTYPE_UUID_STR  TEXT("c87ca5c0-ff67-11cf-8ebd-00aa006b4f2f")

// Packet sizes:
#define BASELINE_PDU_SIZE       65535
#define PREFERRED_PDU_SIZE      65535
#define MAX_PDU_SIZE            65535
#define MAX_PACKET_SIZE         65535
                             // was: 0x7fffffff
#define DEFAULT_BUFFER_SIZE         0

#define DEFAULT_PRIORITY            3


//----------------------------------------------------------------
//  Types:
//----------------------------------------------------------------

typedef struct _MQ_INFO
  {
    WCHAR       wsMachine[MAX_COMPUTERNAME_LEN];
    WCHAR       wsQName[MQ_MAX_Q_NAME_LEN];
    WCHAR       wsQPathName[MAX_PATHNAME_LEN];
    WCHAR       wsQFormat[MAX_FORMAT_LEN];
    WCHAR       wsAdminQFormat[MAX_FORMAT_LEN];
    UUID        uuidQType;
    QUEUEHANDLE hQueue;
    QUEUEHANDLE hAdminQueue;          // Sometimes used by the client.
    DWORD       dwBufferSize;
    DWORD       cThreads;             // Used by server.
    BOOL        fInitialized;
    // How to send this call message:
    BOOL        fAck;
    ULONG       ulDelivery;
    ULONG       ulPriority;
    ULONG       ulJournaling;
    ULONG       ulTimeToReachQueue;   // Seconds.
    ULONG       ulTimeToReceive;      // Seconds.
    BOOL        fAuthenticate;
    BOOL        fEncrypt;
  } MQ_INFO;


typedef struct _MQ_ADDRESS
  {
    WCHAR  wsMachine[MAX_COMPUTERNAME_LEN];
    WCHAR  wsQName[MQ_MAX_Q_NAME_LEN];
    WCHAR  wsQFormat[MAX_FORMAT_LEN];
    QUEUEHANDLE hQueue;
    BOOL   fConnectionFailed;
    BOOL   fAuthenticated;            // Server security tracking.
    ULONG  ulPrivacyLevel;            // Server security tracking.
    ULONG  ulAuthenticationLevel;     // Server security tracking.
    UCHAR  aSidBuffer[MAX_SID_SIZE];  // Server security tracking.
  } MQ_ADDRESS;

typedef struct _MQ_OPTIONS
  {
    BOOL   fAck;
    ULONG  ulDelivery;
    ULONG  ulPriority;
    ULONG  ulJournaling;
    ULONG  ulTimeToReachQueue;
    ULONG  ulTimeToReceive;
    BOOL   fAuthenticate;
    BOOL   fEncrypt;
  } MQ_OPTIONS;

//----------------------------------------------------------------
//  Prototypes:
//----------------------------------------------------------------

extern HRESULT CreateQueue( IN  UUID  *pQueueUuid,
                            IN  WCHAR *pwsPathName,
                            IN  WCHAR *pwsQueueLabel,
                            IN  ULONG  ulQueueFlags,
                            OUT WCHAR *pwsFormat,
                            IN OUT DWORD *pdwFormatSize );


extern BOOL    ConstructQueuePathName( IN  WCHAR *pwsMachineName,
                                       IN  WCHAR *pwsQueueName,
                                       OUT WCHAR *pwsPathName,
                                       IN OUT DWORD *pdwSize  );


extern BOOL    ConstructPrivateQueuePathName( IN  WCHAR *pwsMachineName,
                                              IN  WCHAR *pwsQueueName,
                                              OUT WCHAR *pwsPathName,
                                              IN OUT DWORD *pdwSize  );


extern HRESULT ClearQueue( QUEUEHANDLE hQueue );


extern BOOL    ParseQueuePathName(
                    IN  WCHAR *pwsPathName,
                    OUT WCHAR  wsMachineName[MAX_COMPUTERNAME_LEN],
                    OUT WCHAR  wsQueueName[MQ_MAX_Q_NAME_LEN]  );

#ifdef MAJOR_DEBUG

extern void    DbgPrintPacket( unsigned char *pPacket );

#endif

//
// The Svr... functions are defined in ..\falcons\mqsvr.c

extern HRESULT SvrSetupQueue( IN MQ_INFO *pEP,
                              IN WCHAR   *pwsSvrMachine,
                              IN WCHAR   *pwsEndpoint,
                              IN unsigned long ulEndpointFlags );


extern HRESULT SvrPeekQueue( IN  MQ_INFO *pInfo,
                             IN  DWORD    timeoutMsec,
                             OUT ULONG   *pdwBufferSize );

extern HRESULT SvrReceiveFromQueue( IN  MQ_INFO    *pInfo,
                                    IN  DWORD       timeoutMsec,
                                    OUT MQ_ADDRESS *pAddress,
                                    OUT UCHAR      *pBuffer,
                                    IN OUT DWORD   *pdwBufferSize );



extern HRESULT SvrSendToQueue( IN MQ_INFO    *pInfo,
                               IN MQ_ADDRESS *pAddress,
                               IN UCHAR      *pBuffer,
                               IN DWORD       dwBufferSize );


extern HRESULT SvrShutdownQueue( IN MQ_INFO *pInfo );


extern HRESULT SvrInitializeHandleMap();


extern HRESULT SvrCloseAllHandles();

//
// The Clnt... functions are defined in mqclnt.c

extern HRESULT ClntSetupQueue( MQ_INFO *pEP,
                               WCHAR   *pwsSvrMachine,
                               WCHAR   *pwsEndpoint    );


extern HRESULT ClntSetupAdminQueue( MQ_INFO *pEP );


extern HRESULT ClntReceiveFromQueue( IN  MQ_INFO    *pInfo,
                                     IN  DWORD       timeoutMsec,
                                     OUT MQ_ADDRESS *pAddress,
                                     OUT UCHAR      *pBuffer,
                                     IN OUT DWORD   *pdwBufferSize );


extern HRESULT ClntPeekQueue( IN  MQ_INFO *pInfo,
                              IN  DWORD    timeoutMsec,
                              OUT DWORD   *pdwBufferSize );


extern HRESULT ClntSendToQueue( IN MQ_INFO    *pInfo,
                                IN MQ_ADDRESS *pAddress,
                                IN UCHAR      *pBuffer,
                                IN DWORD       dwBufferSize );


extern HRESULT ClntShutdownQueue( IN MQ_INFO *pInfo );


extern RPC_STATUS MQ_MapStatusCode( IN HRESULT    hr,
                                    IN RPC_STATUS defStatus );


#if FALSE
NOTE: These functions are not currently being used...

extern HRESULT LocateQueueViaQType( IN     UUID  *pQueueUuid,
                                    OUT    WCHAR *pwsFormat,
                                    IN OUT DWORD *pdwFormatSize );


extern HRESULT LocateQueueViaQTypeAndMachine( IN     UUID  *pQueueUuid,
                                              IN     WCHAR *pwsMachine,
                                              OUT    WCHAR *pwsFormat,
                                              IN OUT DWORD *pdwFormatSize );


extern HRESULT LocateQueueViaQName( IN     WCHAR *pwsQueueName,
                                    OUT    WCHAR *pwsFormat,
                                    IN OUT DWORD *pdwFormatSize );


extern HRESULT LocateQueueViaQNameAndMachine( IN  WCHAR *pwsQName,
                                              IN  WCHAR *pwsMachine,
                                              OUT WCHAR *pwsFormat,
                                              IN OUT DWORD *pdwFormatSize );


extern BOOL    FormatNameDirect( IN  WCHAR *pwsMachineName,
                                 IN  WCHAR *pwsQueueName,
                                 OUT WCHAR *pwsFormatName,
                                 IN OUT DWORD *pdwSize );
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\epmap\mqmgr.cxx ===
//-------------------------------------------------------------------
// Copyright (C) Microsoft Corporation, 1991 - 1999
//
// mqmgr.c
//
// Abstract:
//
//   Functions to manage temporary Falcon message queues for RPC. The
//   RPC support of Falcon as a transport allows for temporary queues
//   which exist only as long as the process. These functions manage
//   these temporary queues.
//
// Author:
//
//   Edward Reus (edwardr)
//
// Revision History:
//
//-------------------------------------------------------------------


#include <sysinc.h>

#define FD_SETSIZE 1

#include <wtypes.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <rpcerrp.h>
#include <rpctrans.hxx>
#include <stdlib.h>
#include <objidl.h>
#include <mq.h>
#include "mqmgr.h"

#define  MAX_FORMAT_LEN   128

//-------------------------------------------------------------------
//  Local Types:
//-------------------------------------------------------------------

typedef struct _MqTempQueue
   {
   struct _MqTempQueue *pNext;
   WCHAR         wsQFormat[MAX_FORMAT_LEN];
   } MqTempQueue;

typedef struct _MqTempQueueList
   {
   HANDLE       hToken;   // For impersonation of the client.
   MqTempQueue *pQueues;
   } MqTempQueueList;


typedef HRESULT (APIENTRY *MQ_DELETE_QUEUE_FN)( WCHAR *pwsQFormat );

#define MQRT_DLL_NAME      TEXT("MQRT.DLL")
#define MQ_DELETE_FN_NAME  "MQDeleteQueue"

//-------------------------------------------------------------------
//  Globals:
//-------------------------------------------------------------------

static HINSTANCE           g_hMqDll = 0;
static MQ_DELETE_QUEUE_FN  g_pMqDeleteQueue = 0;

//-------------------------------------------------------------------
//  MqGetContext()
//
//  Establishs a context handle to manage temporary queues. Once the
//  context handle is created, the RPC client and server processes
//  will automatically register temporary queues.
//-------------------------------------------------------------------
unsigned long MqGetContext( handle_t         hBind,
                            PCONTEXT_HANDLE *pphContext )
{
   RPC_STATUS  Status = RPC_S_OK;
   HANDLE      hToken = 0;
   HANDLE      hThread = 0;
   MqTempQueueList  *pqList;

   // First, check to see if the MQ runtime DLL has been loaded. If not,
   // then load it and resolve the entry for the function to delete queues.
   if (!g_hMqDll)
      {
      g_hMqDll = LoadLibrary(MQRT_DLL_NAME);
      if (g_hMqDll)
         {
         g_pMqDeleteQueue = (MQ_DELETE_QUEUE_FN)GetProcAddress(g_hMqDll,MQ_DELETE_FN_NAME);
         if (!g_pMqDeleteQueue)
            {
            Status = GetLastError();
            FreeLibrary(g_hMqDll);
            g_hMqDll = 0;
            return Status;
            }
         }
      else
         {
         // The LoadLibrary() call failed.
         Status = GetLastError();
         *pphContext = NULL;
         return Status;
         }
      }

   // Ok, create a context for this connection. Also, grab the 
   // client's security token for later use when deleting the 
   // queue.
   *pphContext = pqList = (MqTempQueueList*)I_RpcAllocate(sizeof(MqTempQueueList));
   if (!*pphContext)
      {
      Status = RPC_S_OUT_OF_MEMORY;
      }
   else
      {
      ZeroMemory( pqList, sizeof(MqTempQueueList) );

      Status = RpcImpersonateClient(hBind);
      if (RPC_S_OK == Status)
         {
         if (  (hThread=GetCurrentThread())
            && (OpenThreadToken(hThread,TOKEN_IMPERSONATE,FALSE,&hToken)) )
            {
            pqList->hToken = hToken;
            }
         else
            {
            Status = GetLastError();
            }

         if (hThread)
            {
            CloseHandle(hThread);
            }

         Status = RpcRevertToSelf();
         }
      else
         {
         // If the impersonation failed, then plow ahead anyway. We
         // can still keep the list of queues and "maybe" delete them.
         Status = RPC_S_OK;
         }
      }

   #ifdef DBG
   DbgPrint("MqGetContext(): hToken: 0x%x\n",hToken);
   #endif
   
   return Status;
}

//-------------------------------------------------------------------
//  MqRegisterQueue()
//
//  Register the specified queue as a temporary queue that will
//  need to be deleted by the context rundown routine when the 
//  client exits. The registration is actually done by the MQ RPC
//  client and server transport DLLs.
//-------------------------------------------------------------------
unsigned long MqRegisterQueue( PCONTEXT_HANDLE phContext,
                               wchar_t        *pwsQFormat    )
{
   RPC_STATUS       Status = RPC_S_OK;
   MqTempQueue     *pTempQueue;
   MqTempQueueList *pqList = (MqTempQueueList*)phContext;


   pTempQueue = (MqTempQueue*)I_RpcAllocate(sizeof(MqTempQueue));
   if (!pTempQueue)
      {
      return RPC_S_OUT_OF_MEMORY;
      }

   memset(pTempQueue,0,sizeof(MqTempQueue));

   ASSERT(pwsQFormat);
   ASSERT(wcslen(pwsQFormat) < MAX_FORMAT_LEN);

   wcscpy(pTempQueue->wsQFormat,pwsQFormat);

   // Ok, put the queue on the list to delete.
   pTempQueue->pNext = pqList->pQueues;
   pqList->pQueues = pTempQueue;

   return Status;
}

//-------------------------------------------------------------------
//  MqDeregisterQueue()
//
//  Remove the specified message queue from the list of queues to
//  be deleted by the context rundown routine. This would be done
//  if a queue (which is initially temporary) was turned into a 
//  permanent queue.
//-------------------------------------------------------------------
unsigned long MqDeregisterQueue( PCONTEXT_HANDLE phContext,
                                 wchar_t        *pwsQFormat )
{
   RPC_STATUS       Status = RPC_S_OK;
   MqTempQueueList *pqList = (MqTempQueueList*)phContext;
   MqTempQueue     *pTempQueue;
   MqTempQueue     *pTempToFree;

   if (!pqList)
      {
      return RPC_X_SS_IN_NULL_CONTEXT;
      }

   pTempQueue = pqList->pQueues;
   if (!lstrcmpiW(pTempQueue->wsQFormat,pwsQFormat))
      {
      pqList->pQueues = pTempQueue->pNext;
      I_RpcFree(pTempQueue);
      return RPC_S_OK;
      }

   while (pTempQueue->pNext)
      {
      if (!lstrcmpiW(pTempQueue->pNext->wsQFormat,pwsQFormat))
         {
         pTempToFree = pTempQueue->pNext;
         pTempQueue->pNext = pTempQueue->pNext->pNext;
         I_RpcFree(pTempToFree);
         break;
         }
      }

   return Status;
}

//-------------------------------------------------------------------
//  MqFreeContext()
//
//  Called to remove all of the queues registered for automatic
//  deletion and to close and free the context handle.
//-------------------------------------------------------------------
unsigned long MqFreeContext( PCONTEXT_HANDLE *pphContext,
                             long             fFreeContext )
{
   RPC_STATUS  Status = RPC_S_OK;
   HRESULT     hr;
   BOOL        fImpersonate = FALSE;
   MqTempQueueList *pqList = (MqTempQueueList*)*pphContext;
   MqTempQueue     *pTemp;
   MqTempQueue     *pToFree;

   // First, impersonate the client who registered these queues
   // to delete.
   if (pqList->hToken)
      {
      fImpersonate = SetThreadToken(NULL,pqList->hToken);
      #ifdef DBG
      if (!fImpersonate)
         {
         Status = GetLastError();
         }
      #endif
      }

   // Run through the list of queues deleting each one as
   // we go.
   pTemp = pqList->pQueues;
   while (pTemp)
      {
      pToFree = pTemp;
      pTemp = pTemp->pNext;

      hr = g_pMqDeleteQueue(pToFree->wsQFormat);
      #ifdef FALSE
      DbgPrint("Delete Queue: %S (hr: 0x%x)\n", pToFree->wsQFormat, hr );
      #endif
      I_RpcFree(pToFree);
      }

   // Stop the impersonation:
   if (fImpersonate)
      {
      if (!SetThreadToken(NULL,NULL))
         {
         Status = GetLastError();
         }
      }


   // Do we need to free up the context?
   if (pqList->hToken)
      {
      if (!CloseHandle(pqList->hToken))
         {
         Status = GetLastError();
         #ifdef DBG
         DbgPrint("MqFreeContext(): CloseHandle() Failed: Status: %d (0x%x)\n",Status,Status);
         #endif
         }
      }

   if (fFreeContext)
      {
      I_RpcFree(pqList);
      *pphContext = NULL;
      }
   else
      {
      pqList->hToken = 0;
      pqList->pQueues = NULL;
      }

   return Status;
}

//-------------------------------------------------------------------
//  PCONTEX_HANDLE_rundown()
//
//  This is the context rundown routine. It will delete all of the
//  Falcon message queues that are currently associated with the
//  specified context handle.
//-------------------------------------------------------------------
void __RPC_USER PCONTEXT_HANDLE_rundown( PCONTEXT_HANDLE phContext )
{
   RPC_STATUS  Status;

   Status = MqFreeContext(&phContext,FALSE);
}


//-------------------------------------------------------------------
//  StartMqManagement()
//
//  Called in dcomss\warpper\start.cxx by RPCSS to initialize the
//  MQ Management interface.
//-------------------------------------------------------------------
extern "C"
DWORD StartMqManagement()
{
   RPC_STATUS  Status;

   Status = RpcServerRegisterIf(MqMgr_ServerIfHandle,0,0);

   return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\epmap\eptypes.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    eptypes.h

Abstract:

    This file contains the internal data structure defn for the EP mapper.

Author:

    Bharat Shah  (barat) 17-2-92

Revision History:

    06-03-97    gopalp      Added code to cleanup stale EP Mapper entries.

--*/


#ifndef __EPTYPES_H__
#define __EPTYPES_H__


//
// The various EP Mapper Data structures and how they relate to each other
//
//
// ----------------
// DATA STRUCTURES
// ----------------
//
// IFOBJNode        PSEPNode        EP_CLEANUP
//
// |---|            (---)           /////
// |   |            (   )           /   /
// |   |            (---)           /////
// |   |
// |   |
// |   |
// |---|
//
//
// ---------------------------------------------------------------
// Global list of IFOBJNode and it's relation to EP_CLEANUP Nodes
// ---------------------------------------------------------------
//
// a. Next member of IFOBJNode is denoted by   --->
// b. Prev member of IFOBJNode is denoted by   <---
// c. Each EP_CLEANUP is a linked list of IFOBJNodes belonging
//    to a process.
//
//
// IFObjList
//   |
//   |
//   |
//   V
// |---|    |---|    |---|    |---|    |---|    |---|    |---|    |---|
// |   |    |   |    |   |    |   |    |   |    |   |    |   |    |   |
// |   |<---|   |<---|   |<---|   |<---|   |<---|   |<---|   |<---|   |
// |   |    |   |    |   |    |   |    |   |    |   |    |   |    |   |
// |   |--->|   |--->|   |--->|   |--->|   |--->|   |--->|   |--->|   |---|
// |   |    |   |    |   |    |   |    |   |    |   |    |   |    |   |   |
// |---|    |---|    |---| |->|---|    |---|    |---|    |---| |->|---|   |
//   ^                     |                                   |         ---
//   |                     |                                   |          -
//   |                     |                                   |
//   |                     |                                   |
// /////                 /////                               /////
// /   /                 /   /                               /   /
// /////                 /////                               /////
//
//
//
// ----------------------------------------------------------
// Each IFOBJNOde has linked list of PSEPNodes related to it
// ----------------------------------------------------------
//
// |---|     (---)     (---)     (---)     (---)     (---)
// |   |---->(   )---->(   )---->(   )---->(   )---->(   )--|
// |   |     (---)     (---)     (---)     (---)     (---)  |
// |   |                                                    |
// |   |                                                   ---
// |   |                                                    -
// |---|
//
//
//
//

//
// Cleanup context
//

struct _IFOBJNode;

typedef struct _EP_CLEANUP
{
    unsigned long MagicVal;
    unsigned long cEntries;         // Number of entries in the list.
    struct _IFOBJNode * EntryList;  // Pointer to the begining of entries
                                    // for this process.
} EP_CLEANUP, *PEP_CLEANUP, **PPEP_CLEANUP;


typedef struct _IENTRY {
    struct _IENTRY * Next;
    unsigned long Signature;
    unsigned long Cb;
    unsigned long  Id;
} IENTRY;

typedef IENTRY * PIENTRY;

typedef struct _PSEPNode {
    struct _PSEPNode * Next;
    unsigned long Signature;
    unsigned long Cb;
    unsigned long PSEPid;
    char * Protseq;
    char * EP;
    twr_t * Tower;
} PSEPNode;

typedef PSEPNode * PPSEPNode;


typedef struct _IFOBJNode {
    struct _IFOBJNode * Next;
    unsigned long Signature;
    unsigned long Cb;
    unsigned long IFOBJid;
    PSID pSID;
    PSEPNode * PSEPlist;
    EP_CLEANUP * OwnerOfList;
    struct _IFOBJNode * Prev;
    UUID ObjUuid;
    UUID IFUuid;
    unsigned long IFVersion;
    char * Annotation;
} IFOBJNode;

typedef IFOBJNode * PIFOBJNode;

typedef struct _SAVEDCONTEXT {
    struct _SAVEDCONTEXT *Next;
    unsigned long Signature;
    unsigned long Cb;
    unsigned long CountPerBlock;
    unsigned long Type;
    void * List;
} SAVEDCONTEXT;

typedef SAVEDCONTEXT * PSAVEDCONTEXT;

typedef struct _SAVEDTOWER {
    struct _SAVEDTOWER * Next;
    unsigned long Signature;
    unsigned long Cb;
    twr_t * Tower;
} SAVEDTOWER;

typedef SAVEDTOWER * PSAVEDTOWER;


typedef struct _EP_T  {
        UUID ObjUuid;
        UUID IFUuid;
        unsigned long IFVersion;
} EP_T;

typedef EP_T * PEP_T;

typedef struct _I_EPENTRY {
   UUID Object;
   UUID Interface;
   unsigned long IFVersion;
   twr_t *Tower;
   char __RPC_FAR * Annotation;
} I_EPENTRY;

typedef struct _SAVED_EPT {
   struct _SAVED_EPT * Next;
   unsigned long Signature;
   unsigned long Cb;
   UUID Object;
   twr_t * Tower;
   char  * Annotation;
} SAVED_EPT;

typedef SAVED_EPT * PSAVED_EPT;

typedef unsigned long (* PFNPointer)(
                        void *,         // pNode
                        void *,         // ObjUuid
                        void *,         // IfUuid
                        unsigned long,  // IfVer
                        PSID,           // pSID
                        unsigned long,  // InqType
                        unsigned long   // VersOpt
                        );

typedef unsigned long (* PFNPointer2)(
                        void *,         // PSEPNode
                        void *,         // Protseq
                        void *,         // Endpoint
                        unsigned long   // Version
                        );

// Endpoint Mapper Table
typedef struct _ProtseqEndpointPair {
  char  __RPC_FAR * Protseq;
  char  __RPC_FAR * Endpoint;
  unsigned long      State;
} ProtseqEndpointPair;



#endif // __EPTYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\exts\nttrans.cxx ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 2001

    Module Name:

        NtTrans.cxx

    Abstract:

        NTSD/KD extensions for debugging Windows NT transport interface
        data structures.

    Author:

        Mario Goertzel    [MarioGo]

    Revision History:

        MarioGo     3/21/1997    Bits 'n pieces

        GrigoriK    Mar 2001     Added support for type info.

--*/

#undef _RPCRT4_

#define KDEXT_64BIT

#define private     public

#include "..\trans\Common\precomp.hxx"
#include "..\mtrt\precomp.hxx"
#include <stddef.h>
#include <wdbgexts.h>
#include <rpcexts.hxx>

VOID do_trans(ULONG64);
VOID do_protocols(ULONG64);
VOID do_overlap(ULONG64);
VOID do_addrvect(ULONG64);

MY_DECLARE_API(trans);
MY_DECLARE_API(overlap);
MY_DECLARE_API(addrvect);

const char *Protocols[] =
{
    "INVALID",
    "TCP/IP",
#ifdef SPX_ON
    "SPX",
#else
    "Invalid",
#endif
    "Named pipes",
#ifdef NETBIOS_ON
    "NetBEUI",
    "Netbios(TCP)",
    "Netbios(IPX)",
#else
    "Invalid",
    "Invalid",
    "Invalid",
#endif
#ifdef APPLETALK_ON
    "Appletalk DSP",
#else
    "Invalid",
#endif
    "Invalid",      // former "Vines SPP",
    "HTTP",
    "UDP/IP",
#ifdef IPX_ON
    "IPX",
#else
    "Invalid",
#endif
    "CDP",
#ifdef NCADG_MQ_ON
    "MSMQ",
#else
    "Invalid",
#endif
    "TCP/IPv6"
};
const INT cProtocols = sizeof(Protocols)/sizeof(char *);


VOID
do_trans(
    ULONG64 qwAddr
    )
{
    char const *pszProtocol;

    ULONG64 tmp1;
    ULONG tmp2;

    DWORD protocol;

    ULONG64 id;
    ULONG64 type;

    GET_MEMBER(qwAddr, BASE_ASYNC_OBJECT, RPCRT4!BASE_ASYNC_OBJECT, id, id);
    GET_MEMBER(qwAddr, BASE_ASYNC_OBJECT, RPCRT4!BASE_ASYNC_OBJECT, type, type);

    // Display protocol
    if ((ULONG)id <= 0 ||
        (ULONG)id >= cProtocols)
        {
        dprintf("Invalid protocol ID %d\n", id);
        return;
        }
    protocol = (ULONG)id;
    pszProtocol = Protocols[protocol];

    dprintf("Object (0x%p), protocol\t - %s\n", qwAddr, pszProtocol);

    switch(type & PROTO_MASK)
        {
        case CONNECTION:
            {

            if ((type & TYPE_MASK) == CLIENT)
                {
                dprintf("Client-side connection\t\t - (%p)\n", type);
                }
            else if (type & SERVER)
                {
                dprintf("Server-side connection\t\t - (%p)\n", type);
                }
            else
                {
                dprintf("Unknown type %d\n", type);
                break;
                }

            PRINT_ADDRESS_OF(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, Conn, tmp2);
            PRINT_MEMBER_BOOLEAN(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, fAborted, tmp1);
            PRINT_MEMBER(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, StartingReadIo, tmp1);
            PRINT_MEMBER(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, StartingWriteIo, tmp1);
            PRINT_MEMBER(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, iPostSize, tmp1);
            
            ULONG64 Read;
            GET_ADDRESS_OF(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, Read, Read, tmp2);

            do_overlap(Read);

            PRINT_MEMBER(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, pReadBuffer, tmp1);
            PRINT_MEMBER(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, maxReadBuffer, tmp1);
            PRINT_MEMBER(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, iLastRead, tmp1);

            ULONG64 pAddress;

            if (protocol == NMP)
                {
                GET_MEMBER(qwAddr, NMP_CONNECTION, RPCRT4!NMP_CONNECTION, pAddress, pAddress);
                dprintf("Associated address\t\t - 0x%I64x\n", pAddress);
                }
            else if (protocol == TCP)
                {
                GET_MEMBER(qwAddr, WS_CONNECTION, RPCRT4!WS_CONNECTION, pAddress, pAddress);
                dprintf("Associated address\t\t - 0x%I64x\n", pAddress);
                }
            else
                {
                GET_MEMBER(qwAddr, WS_CONNECTION, RPCRT4!WS_CONNECTION, saClientAddress, pAddress);

                dprintf("Winsock sockaddr (server)\t - 0x%I64x\n", pAddress);

#ifdef NETBIOS_ON
                if (    protocol == NBF
                     || protocol == NBT
                     || protocol == NBI)
                    {
                    ULONG64 SequenceNumber;
                    GET_MEMBER(qwAddr, NB_CONNECTION, RPCRT4!NB_CONNECTION, SequenceNumber, SequenceNumber);
                    // Netbios based connection has more state
                    dprintf("Netbios sequence number\t\t - %d\n", (ULONG)SequenceNumber);
                    }
                else
#endif
                    if ((type & TYPE_MASK) == CLIENT)
                    {
                    // Client-side non-netbios connections have more state
                    PRINT_MEMBER(qwAddr, WS_CLIENT_CONNECTION, RPCRT4!WS_CLIENT_CONNECTION, fCallStarted, tmp1);
                    PRINT_MEMBER(qwAddr, WS_CLIENT_CONNECTION, RPCRT4!WS_CLIENT_CONNECTION, fShutdownReceived, tmp1);
                    PRINT_MEMBER(qwAddr, WS_CLIENT_CONNECTION, RPCRT4!WS_CLIENT_CONNECTION, fReceivePending, tmp1);
                    PRINT_MEMBER(qwAddr, WS_CLIENT_CONNECTION, RPCRT4!WS_CLIENT_CONNECTION, dwLastCallTime, tmp1);
                    }
                }

            break;
            }

        case ADDRESS:
        case DATAGRAM|ADDRESS:
            {
            dprintf("Address type\t\t\t - (%p)", type);

            if (type & ~(PROTO_MASK | TYPE_MASK | IO_MASK))
                {
                dprintf(" unknown bits 0x%lx\n", type & ~(PROTO_MASK | TYPE_MASK | IO_MASK));
                }
            else
                {
                if (type & DATAGRAM)
                    dprintf(" d/g");
                else
                    dprintf(" c/o");

                if (type & SERVER)
                    dprintf(" server");
                else
                    dprintf(" client or bit not set");

                dprintf("\n");
                }

            ULONG64 Endpoint;
            GET_MEMBER(qwAddr, BASE_ADDRESS, RPCRT4!BASE_ADDRESS, Endpoint, Endpoint);

            if (Endpoint)
                {
                dprintf("Endpoint\t\t\t - %ws\n", ReadProcessRpcChar(Endpoint));
                }
            else
                {
                dprintf("Endpoint\t\t\t - (null)\n");
                }

            ULONG64 pAddressVector;
            GET_MEMBER(qwAddr, BASE_ADDRESS, RPCRT4!BASE_ADDRESS, pAddressVector, pAddressVector);

            if (pAddressVector)
                {
                do_addrvect(pAddressVector);
                }
            else
                {
                dprintf("No address vector\n");
                }

            ULONG64 SubmitListen;
            GET_MEMBER(qwAddr, BASE_ADDRESS, RPCRT4!BASE_ADDRESS, SubmitListen, SubmitListen);

            dprintf("SubmitListen (pfn)\t\t - 0x%I64x %s\n", SubmitListen,
                                                     MapSymbol(SubmitListen));

            PRINT_MEMBER_WITH_LABEL(qwAddr, BASE_ADDRESS, RPCRT4!BASE_ADDRESS, pNext, "Next\t\t\t\t", tmp1);

            if (   
#ifdef IPX_ON
                   protocol != IPX &&
#endif
                   protocol != UDP &&
                   protocol != CDP)
                {
                GET_OFFSET_OF(CO_ADDRESS, RPCRT4!CO_ADDRESS, Listen, &tmp2);
                do_overlap(qwAddr+tmp2);

                ULONG64 NewConnection;
                GET_MEMBER(qwAddr, CO_ADDRESS, RPCRT4!CO_ADDRESS, NewConnection, NewConnection);

                dprintf("NewConnection (pfn)\t\t - 0x%I64x %s\n", NewConnection, MapSymbol(NewConnection));
                }

#ifdef NETBIOS_ON
            BOOL fNetbios = FALSE;
#endif

            switch(protocol)
                {
#ifdef NETBIOS_ON
                case NBI:
                case NBT:
                case NBF:
                    fNetbios = TRUE;
                    // Fall into winsock case
#endif

                case TCP:
#ifdef SPX_ON
                case SPX:
#endif

#ifdef APPLETALK_ON
                case DSP:
#endif
                    {
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_ADDRESS, RPCRT4!WS_ADDRESS, pFirstAddress, "Real address\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_ADDRESS, RPCRT4!WS_ADDRESS, pNextAddress, "Next address\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_ADDRESS, RPCRT4!WS_ADDRESS, ListenSocket, "Listen socket\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_ADDRESS, RPCRT4!WS_ADDRESS, ConnectionSocket, "Connect socket\t\t\t", tmp1);

#ifdef NETBIOS_ON
                    ULONG64 dwProtocolMultiplier;
                    GET_MEMBER(qwAddr, WS_ADDRESS, RPCRT4!WS_ADDRESS, dwProtocolMultiplier, dwProtocolMultiplier);

                    if (dwProtocolMultiplier != 1
                        && !fNetbios)
                        {

                        dprintf("Invalid protocol multipler (%d) for winsock address\n", (ULONG)dwProtocolMultiplier);
                        }
                    else
                        {
                        dprintf("Multipler\t\t\t - %d\n", (ULONG)dwProtocolMultiplier);
                        }
#endif
                    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, WS_ADDRESS, RPCRT4!WS_ADDRESS, AcceptBuffer, "AcceptBuffer\t\t\t", tmp2);
                    break;
                    }

                case NMP:
                    {
                    PRINT_MEMBER_WITH_LABEL(qwAddr, NMP_ADDRESS, RPCRT4!NMP_ADDRESS, hConnectPipe, "Connect pipe\t\t\t", tmp1);
                    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, NMP_ADDRESS, RPCRT4!NMP_ADDRESS, sparePipes, "Spare pipes\t\t\t", tmp2);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, NMP_ADDRESS, RPCRT4!NMP_ADDRESS, SecurityDescriptor, "Security descriptor\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, NMP_ADDRESS, RPCRT4!NMP_ADDRESS, LocalEndpoint, "Local Endpoint\t\t\t", tmp1);
                    break;
                    }

                case UDP:
#ifdef IPX_ON
                case IPX:
#endif
                case CDP:
                    {
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM_ENDPOINT, RPCRT4!WS_DATAGRAM_ENDPOINT, Socket, "The socket\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM_ENDPOINT, RPCRT4!WS_DATAGRAM_ENDPOINT, cPendingIos, "Pending recvs\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM_ENDPOINT, RPCRT4!WS_DATAGRAM_ENDPOINT, cMinimumIos, "Min recvs\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM_ENDPOINT, RPCRT4!WS_DATAGRAM_ENDPOINT, cMaximumIos, "Max recvs\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM_ENDPOINT, RPCRT4!WS_DATAGRAM_ENDPOINT, aDatagrams, "Array of datagrams\t\t", tmp1);
                    }
                default:
                    {
                    dprintf("ERROR: Invalid/unknown protocol\n");
                    }
                }

            break;
            }

        case DATAGRAM:
            {
            dprintf("Datagram\t\t\t - (%p)\n", type);

            PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM, RPCRT4!WS_DATAGRAM, pEndpoint, "Pointer to owning address\t", tmp1);
            PRINT_MEMBER_BOOLEAN_WITH_LABEL(qwAddr, WS_DATAGRAM, RPCRT4!WS_DATAGRAM, Busy, "Busy\t\t\t\t", tmp1);
            PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM, RPCRT4!WS_DATAGRAM, AddressPair, "AddrPair\t\t\t", tmp1);
            PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, WS_DATAGRAM, RPCRT4!WS_DATAGRAM, Packet, "Packet", tmp2);

            GET_OFFSET_OF(WS_DATAGRAM, RPCRT4!WS_DATAGRAM, Read, &tmp2)

            do_overlap(qwAddr + tmp2);

            break;
            }

        default:
            dprintf("Unknown type %d\n", type);
            break;
        }

    dprintf("\n");

    return;
}

char *strtok(char *String);

DECLARE_API( protocols )
{
    ULONG64 qwAddr;
    BOOL fArgNotSpecified = FALSE;
    ULONG64 ProtocolArrayAddress;

    LPSTR lpArgumentString = (LPSTR)args;

    if (0 == strtok(lpArgumentString))
        {
        lpArgumentString = "rpcrt4!TransportProtocolArray";
        fArgNotSpecified = TRUE;
        }

    qwAddr = GetExpression(lpArgumentString);
    if ( !qwAddr )
        {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
        }

    if (fArgNotSpecified)
        {
        if (!ReadPointer(qwAddr, &ProtocolArrayAddress))
            {
            dprintf("couldn't read memory at address %I64x\n", qwAddr);
            return;
            }
        }
    else
        ProtocolArrayAddress = qwAddr;

    do_protocols(ProtocolArrayAddress);
}

const char *ProtocolStateNames[] = {"ProtocolNotLoaded", "ProtocolLoadedWithoutAddress" ,
                                    "ProtocolWasLoadedOrNeedsAct.", "ProtocolLoaded", 
                                    "ProtocolWasLoadedOrNAWithoutAddr",
                                    "ProtocolLoadedAndMonitored"};

VOID
do_protocols(
    ULONG64 qwAddr
    )
{
    ULONG64 pTransportProtocol;
    const char *pProtStateName;
    ULONG64 ListHead;
    ULONG64 ObjectEntry;
    ULONG64 pCurrentObject;
    int i;
    BOOL fFirstObject;
    BOOL b;

    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("     Protocol                          State   AddrChngSock  AddrChngOl\n");
    dprintf("-----------------------------------------------------------------------\n");

    pTransportProtocol = qwAddr;

    for (i = 1; i < MAX_PROTOCOLS; i++)
        {
        fFirstObject = TRUE;
        
        ULONG64 State;
        ULONG64 addressChangeSocket;
        ULONG64 addressChangeOverlapped;

        GET_MEMBER(pTransportProtocol, TransportProtocol, RPCRT4!TransportProtocol, State, State);
        GET_ADDRESS_OF(pTransportProtocol, TransportProtocol, RPCRT4!TransportProtocol, addressChangeSocket, addressChangeSocket, tmp2);
        GET_ADDRESS_OF(pTransportProtocol, TransportProtocol, RPCRT4!TransportProtocol, addressChangeOverlapped, addressChangeOverlapped, tmp2);

        if ((ULONG)State >= sizeof(ProtocolStateNames)/sizeof(ProtocolStateNames[0]))
            pProtStateName = "INVALID";
        else
            pProtStateName = ProtocolStateNames[(ULONG)State];

        dprintf("%13s%31s%15I64x%12I64x\n", Protocols[i], pProtStateName,
            addressChangeSocket, addressChangeOverlapped);

        GET_OFFSET_OF(TransportProtocol, RPCRT4!TransportProtocol, ObjectList, &tmp2);
        ListHead = pTransportProtocol;
        ListHead += tmp2;

        ULONG64 ObjectList;
        GET_ADDRESS_OF(pTransportProtocol, TransportProtocol, RPCRT4!TransportProtocol, ObjectList, ObjectList, tmp2);
        ULONG64 Flink;
        GET_MEMBER(ObjectList, _LIST_ENTRY, RPCRT4!_LIST_ENTRY, Flink, Flink);

        ObjectEntry = Flink;

        while (ObjectEntry != ListHead)
            {
            GET_OFFSET_OF(BASE_ASYNC_OBJECT, RPCRT4!BASE_ASYNC_OBJECT, ObjectList, &tmp2);
            pCurrentObject = ObjectEntry;
            pCurrentObject -= tmp2;

            if (fFirstObject)
                {
                dprintf("Object List:\n");
                fFirstObject = FALSE;
                }
            dprintf("%8lX\n", pCurrentObject);
            // move to the next element in the list
            GET_ADDRESS_OF(pCurrentObject, BASE_ASYNC_OBJECT, RPCRT4!BASE_ASYNC_OBJECT, ObjectList, ObjectList, tmp2);
            GET_MEMBER(ObjectList, _LIST_ENTRY, RPCRT4!_LIST_ENTRY, Flink, Flink);
            }

        pTransportProtocol += GET_TYPE_SIZE(TransportProtocol, RPCRT4!TransportProtocol);
        }
}

VOID
do_overlap(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, BASE_OVERLAPPED, RPCRT4!BASE_OVERLAPPED, pAsyncObject, "Overlapped\t\t\t", tmp2);

    ULONG64 ol;
    GET_ADDRESS_OF(qwAddr, BASE_OVERLAPPED, RPCRT4!BASE_OVERLAPPED, ol, ol, tmp2);

    PRINT_MEMBER_WITH_LABEL(ol, _OVERLAPPED, RPCRT4!_OVERLAPPED, Pointer, "Overlapped, containing object\t", tmp1);

    PRINT_MEMBER_WITH_LABEL(ol, _OVERLAPPED, RPCRT4!_OVERLAPPED, Internal, "ol.Internal (status)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(ol, _OVERLAPPED, RPCRT4!_OVERLAPPED, InternalHigh, "ol.InternalHigh\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(ol, _OVERLAPPED, RPCRT4!_OVERLAPPED, hEvent, "ol.hEvent\t\t\t", tmp1);

    return;
}

VOID
do_addrvect(
    ULONG64 qwAddr
    )
{
    DWORD count;
    BOOL b;
    ULONG64 p;

    GetData(qwAddr, &count, sizeof(count));

    dprintf("Address vector entries\t\t - %d\n", count);
    for (unsigned i = 0; i < count; i++)
        {
        ULONG64 tmp;
        tmp = qwAddr + (i + 1) * AddressSize;
        ReadPointer(tmp, &p);
        dprintf("NetworkAddress[%d]\t\t - (0x%I64x) %ws\n",
                i,
                p,
                ReadProcessRpcChar(p));
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\epmap\worker.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    worker.c

Abstract:

    This file contains the real stuff for the EP Mapper.

Author:

    Bharat Shah  (barat) 17-2-92

Revision History:

    06-03-97    gopalp      Added code to cleanup stale EP Mapper entries.

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sysinc.h>
#include <wincrypt.h>
#include <rpc.h>
#include <rpcndr.h>
#include "epmp.h"
#include "eptypes.h"
#include "local.h"
#include "twrproto.h"
#include <winsock2.h>

#define StringCompareA lstrcmpiA
#define StringLengthA lstrlenA

#define EP_S_DUPLICATE_ENTRY                 0x16c9a0d8
RPC_IF_ID LocalNullUuid = {0};

UUID MgmtIf = {
              0xafa8bd80,
              0x7d8a,
              0x11c9,
              {0xbe, 0xf4, 0x08, 0x00, 0x2b, 0x10, 0x29, 0x89}
              };

const int IP_ADDR_OFFSET = 0x4b;

void
PatchTower(
    IN OUT twr_t *Tower,
    IN int address)
{
    int UNALIGNED *pIPAddr;

    pIPAddr = (int UNALIGNED *) (((char *) Tower) + IP_ADDR_OFFSET);

    //
    // Patch the tower
    //
    *pIPAddr = address;
}

//
// Forward definitions
//

USHORT
GetProtseqIdAnsi(
    PSTR Protseq
    );

RPC_STATUS
DelayedUseProtseq(
    USHORT id
    );

VOID
CompleteDelayedUseProtseqs(
    void
    );

void
DeletePSEP(
    PIFOBJNode Node,
    char * Protseq,
    char * Endpoint
    );

void
PurgeOldEntries(
    PIFOBJNode Node,
    PPSEPNode  List,
    BOOL       StrictMatch
    );

RPC_STATUS
MatchPSAndEP (
    PPSEPNode Node,
    void *Pseq,
    void * Endpoint,
    unsigned long Version
    );

PPSEPNode
FindPSEP (
    register PPSEPNode List,
    char * Pseq,
    char * Endpoint,
    unsigned long Version,
    PFNPointer2 Compare
    );

PIFOBJNode
FindIFOBJNode(
    register PIFOBJNode List,
    UUID * Obj,
    UUID * IF,
    unsigned long Version,
    PSID pSID,
    unsigned long Inq,
    unsigned long VersOpts,
    PFNPointer Compare
    );



PIENTRY
MatchByKey(
    register PIENTRY pList,
    unsigned long key
    )
/*++

Routine Description:

    This routine Seqrches the Link-list of IF-OBJ nodes based on
    key supplied.

Arguments:

    List  - The Linked list [head] - to be searched

    key   - The Id

Return Value:

    Returns a pointer to the matching IFObj node in the list or returns NULL.

--*/
{
    CheckInSem();

     for (; pList && pList->Id < key; pList = pList->Next)
        {
        ;   // Empty body
        }

    return(pList);
}




RPC_STATUS RPC_ENTRY
GetForwardEp(
    UUID *IfId,
    RPC_VERSION * IFVersion,
    UUID *Object,
    unsigned char * Protseq,
    void * * EpString
    )
/*++

Routine Description:

    Server rutime has received a pkt destined for a dynamically
    declared endpoint. Epmapper must return the servers endpoint
    to enable the runtime to correctly forward the pkt.

Arguments:

    IF -  Server Interface UUID

    IFVersion - Version of the Interface

    Obj - UUID of the Object

    Protseq - Ptotocol sequence the interface is using.

    EpString - Place to store the endpoint structure.

Return Value:

    Returns a pointer to a string containing the server's endpoint.

    RPC_S_OUT_OF_MEMORY
    EPT_S_NOT_REGISTERED

---*/
{

    PIFOBJNode     pNode;
    PPSEPNode      pPSEPNode;
    unsigned short len;
    char *         String;
    PFNPointer     Match;
    unsigned long InqType;
    unsigned long Version = VERSION(IFVersion->MajorVersion,
                                    IFVersion->MinorVersion);

    if (memcmp((char *)IfId, (char *)&MgmtIf, sizeof(UUID)) == 0)
        {
        InqType =   RPC_C_EP_MATCH_BY_OBJ;
        Match   =   SearchIFObjNode;
        }
    else
        {
        InqType = 0;
        Match   = WildCardMatch;
        }

    *EpString = 0;

    EnterSem();

    pNode = IFObjList;

    if (pNode == 0)
        {
        LeaveSem();
        return(EPT_S_NOT_REGISTERED);
        }

    while (pNode != 0)
        {
        // We do not have support for registrant SID matching for DG.
        pNode = FindIFOBJNode(
                    pNode,
                    Object,
                    IfId,
                    Version,
                    NULL,
                    InqType,
                    0,
                    Match
                    );

        if (pNode == 0)
            {
            LeaveSem();
            return(EPT_S_NOT_REGISTERED);
            }

        pPSEPNode = pNode->PSEPlist;

        pPSEPNode = FindPSEP(
                        pPSEPNode,
                        Protseq,
                        NULL,
                        0L,
                        MatchPSAndEP
                        );

        if (pPSEPNode == 0)
            {
            pNode = pNode->Next;
            if (pNode == 0)
                {
                LeaveSem();
                return(EPT_S_NOT_REGISTERED);
                }
            continue;
            }


        // We now have a PSEPNode. We just ought to return the first one!

        // Use I_RpcAllocate To Allocate because runtime will free this!
        String = I_RpcAllocate( len = (strlen(pPSEPNode->EP) + 1) );
        if (String == 0)
            {
            LeaveSem();
            return(RPC_S_OUT_OF_MEMORY);
            }

        memcpy(String, pPSEPNode->EP, len);

        *EpString = String;
        LeaveSem();

        return(RPC_S_OK);
        } // while loop

    // we never go through here.
    return(EPT_S_NOT_REGISTERED);
}




RPC_STATUS
SearchIFObjNode(
    PIFOBJNode pNode,
    UUID *Object,
    UUID *IfUuid,
    unsigned long Version,
    PSID pSID,
    unsigned long InqType,
    unsigned long VersOption
    )
/*++

Routine Description:

    This routine Seqrches the Link-list of IF-OBJ nodes based on
    Obj, IFUuid, IFVersion, Inqtype [Ignore OBJ, IgnoreIF, etc],
    and VersOption [Identical Ver, Compatible Vers. etc]

Arguments:

    List - The Linked list head - to be searched

    Obj - UUID of the Object

    IF - Interface UUID

    Version - Version of the Interface

    pSID - SID of the registering principal.  NULL will match any principal's entry.

    InqType - Type of Inquiry  [Filter options based on IF/Obj/Both

    VersOpts - Filter options based on Version

Return Value:

    Returns a pointer to the matching IFObj node in the list or returns NULL.

--*/
{
    switch (InqType)
        {
        default:
        case RPC_C_EP_ALL_ELTS:
            return 0;

        case RPC_C_EP_MATCH_BY_BOTH:
            if (memcmp(
                    (char *)&pNode->ObjUuid,
                    (char *)Object,
                    sizeof(UUID))
                ||
                // !(pSID -> EqualSid (pNode->pSID, pSID))
                !(!pSID || EqualSid (pNode->pSID, pSID))
               )
                return(1);
                // Intentionally Fall through ..

        case RPC_C_EP_MATCH_BY_IF:
            return(!(
                        (
                        !memcmp(
                            (char *)&pNode->IFUuid,
                            (char *)IfUuid,
                            sizeof(UUID)
                            )
                        )
                    &&
                        (
                            (  (VersOption == RPC_C_VERS_UPTO)
                            && pNode->IFVersion <= Version)
                        ||  (  (VersOption == RPC_C_VERS_COMPATIBLE)
                            && ((pNode->IFVersion & 0xFFFF0000) ==
                                      (Version & 0xFFFF0000))
                            && (pNode->IFVersion >= Version)
                            )
                        ||  (  (VersOption == RPC_C_VERS_EXACT)
                            && (pNode->IFVersion == Version)
                            )
                        ||  (VersOption == RPC_C_VERS_ALL)
                        ||  (  (VersOption == RPC_C_VERS_MAJOR_ONLY)
                            && ((pNode->IFVersion & 0xFFFF0000L)
                                       == (Version & 0xFFFF0000L))
                            )
                        ||  (  (VersOption ==
                                         I_RPC_C_VERS_UPTO_AND_COMPATIBLE)
                            && ((pNode->IFVersion & 0xFFFF0000L)
                                       == (Version & 0xFFFF0000L))
                            && (pNode->IFVersion <= Version)
                            )
                        )
                    )
                   ||
                   !(!pSID || EqualSid (pNode->pSID, pSID))
                  ); // return(

        case RPC_C_EP_MATCH_BY_OBJ:
            return(
                memcmp(
                    (char *)&pNode->ObjUuid,
                    (char *)Object,
                    sizeof(UUID)
                    )
                ||
                !(!pSID || EqualSid (pNode->pSID, pSID))
                );
        } // switch

}





PIFOBJNode
FindIFOBJNode(
    register PIFOBJNode List,
    UUID * Obj,
    UUID * IF,
    unsigned long Version,
    PSID pSID,
    unsigned long Inq,
    unsigned long VersOpts,
    PFNPointer Compare
    )
/*++

Routine Description:

    This routine Searches the Linked list of IFOBJ nodes based on
    Obj, IF, and the SID of the registering principal.

Arguments:

    List  - The Linked list head - to be searched

    Obj   - UUID of the Object

    IF    - Interface UUID

    Version - Version of the Interface

    pSID - The SID of the registering principal

    Inq - Type of Inquiry [Filter based on IF/OB/Both]

    VersOpt - Filter based on version [<=, >=, == etc]

    Compare() - A pointer to function used for searching.
                WildCardMatch or ExactMatch.

Return Value:

    Returns a pointer to the matching IFObj node in the list or returns NULL.

--*/
{
    CheckInSem();

    for (; (List !=NULL) && (*Compare)(List, Obj, IF, Version, pSID, Inq, VersOpts);
        List = List->Next)
        {
        ;   // Empty body
        }

    return (List);
}




PPSEPNode
FindPSEP (
    register PPSEPNode List,
    char * Pseq,
    char * Endpoint,
    unsigned long Version,
    PFNPointer2 Compare
    )
/*++

Routine Description:

    This routine Searches the Link-list of PSEP nodes based on
    Protocol sequence and Endpoint specified.

Arguments:

    List  - The Linked list head - to be searched

    Pseq  - Protocol sequence string specified

    Endpoint - Endpoint string specified

    Version - Version of the Interface

    Compare() - A pointer to function used for searching.

Return Value:

    Returns a pointer to the matching PSEP node in the list or returns NULL.

--*/
{
    CheckInSem();

    for (; List && (*Compare)(List, Pseq, Endpoint, Version); List = List->Next)
        {
        ;   // Empty body
        }

    return (List);

    if (Version);   // May need this if we overload FindNode and collapse
                    // FindPSEP and FindIFOBJ
}


RPC_STATUS
ExactMatch(
    PIFOBJNode Node,
    UUID *Obj,
    UUID *IF,
    unsigned long Version,
    PSID pSID,
    unsigned long InqType,
    unsigned long VersOptions
    )
/*++

Routine Description:

    This routine compares a Node in the IFOBJList to [Obj, IF, Version] triple
    and returns 0 if there is an exact match else returns 1

Arguments:

    Node  - An IFOBJ node

    Obj   - UUID of the Object

    IF    - Interface UUID

    Version - Version of the Interface

Return Value:

    Returns 0 if there is an exact match; 1 otherwise

--*/
{
    return(( memcmp(&Node->ObjUuid, Obj,sizeof(UUID))
          || memcmp(&Node->IFUuid, IF, sizeof(UUID))
          || (Node->IFVersion != Version))
          ||
          // !(pSID -> EqualSid (pNode->pSID, pSID))
          !(!pSID || EqualSid (Node->pSID, pSID))
          );
}




RPC_STATUS
WildCardMatch (
    PIFOBJNode Node,
    UUID *Obj,
    UUID *IF,
    unsigned long Version,
    PSID pSID,
    unsigned long InqType,
    unsigned long VersOptions
    )
/*++

Routine Description:

    This routine compares a Node in the IFOBJList to [Obj, IF, Version] triple
    and returns 0 if there is an exact match or if registered IF-Obj node
    has a NULL Obj UUid and version of the registed IF_Obj is >= that
    supplied

Arguments:

    Node - An IFOBJ node

    Obj - UUID of the Object

    IF - Interface UUID

    Version - Version of the Interface

Return Value:

    Returns 0 if there is a wild card match ; 1 otherwise

--*/
{
    if (   (!memcmp(&Node->IFUuid, IF, sizeof(UUID)))
        && ((Node->IFVersion & 0xFFFF0000L) ==  (Version & 0xFFFF0000L))
        && (Node->IFVersion >= Version)
        && ((!memcmp(&Node->ObjUuid, Obj, sizeof(UUID))) ||
            (IsNullUuid(&Node->ObjUuid)) )
        &&
           // pSID -> EqualSid (Node->pSID, pSID)  
           (!pSID || EqualSid (Node->pSID, pSID)) )
        {
        return(0);
        }

    return(1);
}



RPC_STATUS
MatchPSAndEP (
    PPSEPNode Node,
    void *Pseq,
    void * Endpoint,
    unsigned long Version
    )
/*++

Routine Description:

    This routine Matches A Node on PSEP list with given Protseq and Endpoint
    If Pseq is given pseqs are matched, if Endpoint is given Endpoints
    are matched, if neither is given returns true, if both are given
    both are matched.

Arguments:

    Node - A PSEP node on PSEP list.

    Pseq - Protocol Sequence string

    Endpoint - Endpoint string

Return Value:

    Returns 0 if Matched successfully, 1 otherwise.

--*/
{
    return (  (Pseq && RpcpStringCompareA(Node->Protseq, Pseq))
           || (Endpoint && RpcpStringCompareA(Node->EP, Endpoint)) );
}




void
PurgeOldEntries(
    PIFOBJNode Node,
    PPSEPNode List,
    BOOL StrictMatch
    )
{
    PPSEPNode Tmp, DeleteMe;
    char * Endpoint = 0;

    CheckInSem();

    Tmp = Node->PSEPlist;

    while (Tmp != 0)
        {
        if (StrictMatch == TRUE)
            Endpoint = Tmp->EP;

        if (DeleteMe = FindPSEP(List, Tmp->Protseq,  Endpoint, 0L, MatchPSAndEP))
            {
            DeleteMe = Tmp;
            Tmp = Tmp->Next;
            UnLinkFromPSEPList(&Node->PSEPlist, DeleteMe);
            DeleteMe->Signature = FREE;
            FreeMem(DeleteMe);
            }
        else
            {
            Tmp = Tmp->Next;
            }
        }
}




RPC_STATUS
IsNullUuid (
    UUID * Uuid
    )
/*++

Routine Description:

    This routine checks if a UUID is Nil

Arguments:

    Uuid - UUID to be tested

Return Value:

   Returns 1 if it is a Nil UUID
           0 otherwise.

--*/
{
    unsigned long PAPI * Vector;

    Vector = (unsigned long PAPI *) Uuid;

    if (   (Vector[0] == 0)
        && (Vector[1] == 0)
        && (Vector[2] == 0)
        && (Vector[3] == 0))
        return(1);

    return(0);
}



twr_p_t
NewTower(
    twr_p_t Tower
    )
/*++

Routine Description:

    This routine returns a New, Duplicated tower

Arguments:

    Tower - The tower that needs to be duplicated.

Return Value:

    Retunes a pointer to a new tower if successful else returns
    NULL

--*/
{
    unsigned short len;
    twr_p_t NewTower;

    len =  (unsigned short)(sizeof(Tower->tower_length) + Tower->tower_length);

    if ((NewTower = MIDL_user_allocate(len)) != NULL)
        {
        memcpy((char *)NewTower, (char *)Tower, len);
        }

    return(NewTower);
}


const unsigned long EPLookupHandleSignature = 0xFAFAFAFA;


PSAVEDCONTEXT
GetNewContext(
    unsigned long Type
    )
/*++

Routine Description

++*/
{
    PSAVEDCONTEXT Context;

    if ( ((Context = AllocMem(sizeof(SAVEDCONTEXT))) == 0) )
        return 0;

    memset(Context, 0, sizeof(SAVEDCONTEXT));

    Context->Cb = sizeof(SAVEDCONTEXT);
    Context->Type = Type;
    Context->Signature = EPLookupHandleSignature;
    EnLinkContext(Context);

    return(Context);
}

const unsigned int EPMapSignature = 0xCBBCCBBC;
const unsigned int EPLookupSignature = 0xABBAABBA;


RPC_STATUS
AddToSavedContext(
    PSAVEDCONTEXT Context,
    PIFOBJNode Node,
    PPSEPNode  Psep,
    unsigned long Calltype,
    BOOL fPatchTower,
    int PatchTowerAddress
    )
{
    void * NewNode;
    PSAVEDTOWER SavedTower;
    PSAVED_EPT SavedEndpoint;
    unsigned long Size;
    unsigned long TowerSize;

    ASSERT(Calltype == Context->Type);

    switch (Calltype)
        {
        case EP_MAP:
            Size = sizeof(SAVEDTOWER) ;
            if ((NewNode = AllocMem(Size)) == 0)
                return(RPC_S_OUT_OF_MEMORY);

            SavedTower = (PSAVEDTOWER) NewNode;
            memset(SavedTower, 0, Size);
            SavedTower->Cb          = Size;
            SavedTower->Signature   = EPMapSignature;
            SavedTower->Tower       = NewTower(Psep->Tower);

            if (SavedTower->Tower == 0)
                {
                FreeMem(NewNode);
                return(RPC_S_OUT_OF_MEMORY);
                }

            if (fPatchTower)
                {
                PatchTower(SavedTower->Tower, PatchTowerAddress);
                }
            break;

        case EP_LOOKUP:
            Size =  sizeof(SAVED_EPT) + strlen(Node->Annotation) + 1;

            if ((NewNode = AllocMem(Size)) == 0)
                return(RPC_S_OUT_OF_MEMORY);

            SavedEndpoint = (PSAVED_EPT) NewNode;
            memset(SavedEndpoint, 0, Size);
            SavedEndpoint->Cb           = Size;
            SavedEndpoint->Signature    = EPLookupSignature;
            SavedEndpoint->Tower        = NewTower(Psep->Tower);
            SavedEndpoint->Annotation   = (char *)NewNode +
                                                  sizeof(SAVED_EPT);
            memcpy( (char *) &SavedEndpoint->Object,
                               (char *)&Node->ObjUuid,
                               sizeof(UUID)
                               );
            strcpy(SavedEndpoint->Annotation, Node->Annotation);

            if (SavedEndpoint->Tower == 0)
                {
                FreeMem(NewNode);
                return(RPC_S_OUT_OF_MEMORY);
                }
            if (fPatchTower)
                {
                PatchTower(SavedEndpoint->Tower, PatchTowerAddress);
                }
            break;

        default:
            ASSERT(!"Unknown lookup type\n");
    	    return(RPC_S_INTERNAL_ERROR);
            break;

    }

    Link((PIENTRY *)(&Context->List), NewNode);

    return(RPC_S_OK);
}




RPC_STATUS
GetEntriesFromSavedContext(
    PSAVEDCONTEXT Context,
    char * Buffer,
    unsigned long Requested,
    unsigned long *Returned
    )
{

    PIENTRY SavedEntry = (PIENTRY)Context->List;
    PIENTRY TmpEntry;
    unsigned long Type = Context->Type;

    while ( (*Returned < Requested) && (SavedEntry != 0) )
        {
        switch (Type)
            {
            case EP_MAP:
                ((I_Tower *)Buffer)->Tower = ((PSAVEDTOWER)SavedEntry)->Tower;
                Buffer = Buffer + sizeof(I_Tower);
                break;

            case EP_LOOKUP:
                ((ept_entry_t *)Buffer)->tower = ((PSAVED_EPT)SavedEntry)->Tower;
                strcpy(((ept_entry_t *)Buffer)->annotation,
                       ((PSAVED_EPT)SavedEntry)->Annotation);
                memcpy(Buffer,(char *)&((PSAVED_EPT)SavedEntry)->Object,
                       sizeof(UUID));
                Buffer = Buffer + sizeof(ept_entry_t);
                break;

            default:
                ASSERT(!"Unknown Inquiry Type");
                break;
            }

        (*Returned)++;
        TmpEntry = SavedEntry;
        SavedEntry = SavedEntry->Next;
        UnLink((PIENTRY *)&Context->List, TmpEntry);
        FreeMem(TmpEntry);
        }

    return(RPC_S_OK);
}




RPC_STATUS
GetEntries(
    UUID *ObjUuid,
    UUID *IFUuid,
    unsigned long Version,
    char * Pseq,
    PSID pSID,
    ept_lookup_handle_t *key,
    char * Buffer,
    unsigned long Calltype,
    unsigned long Requested,
    unsigned long *Returned,
    unsigned long InqType,
    unsigned long VersOptions,
    PFNPointer Match
    )
/*++

Routine Description:

    This is a generic routine for retreiving a series [as spec. by Requested]
    of Towers (in case of Map) or ept_entry_t's in case of Lookup.

Arguments:

    ObjUuid - Object Uuid

    IfUuid - Interface Uuid

    Version - InterfaceVersion [hi ushort = VerMajor, lo ushort VerMinor]

    Pseq - An ascii string specifying the protocol seq.

    pSID - SID of the registering principal.  NULL will retrieve without regard to SID.

    key - A resume key - If NULL, search is started from the beginning
        if non-null, represents an encoding from where the epmapper
        supposed to start searching. It is an opaque value as far
        as the client is concerned.

    Buffer - A buffer of entries returned

    Calltype - A flag to indicate whether Ep_entries or string bindings
        are to be returned.

    Requested - Max no. of entries requested

    Returned - Actual no of entroes returned

Return Value:

    RPC_S_OUT_OF_MEMORY

    RPC_S_OK

    EP_S_NOT_REGISTERED

--*/
{
    PIFOBJNode pNode=NULL, pList = IFObjList;
    unsigned long err=0, fResumeNodeFound=0;
    PPSEPNode pPSEPNode;
    char * buffer = Buffer;
    PSAVEDCONTEXT Context = (PSAVEDCONTEXT) *key;
    ept_lookup_handle_t LOOKUP_FINISHED = (ept_lookup_handle_t) LongToPtr(0xffffffff);
    int UNALIGNED *pIPAddr;
    BOOL fPatchTower;
    int PatchTowerAddress;
    SOCKADDR_STORAGE SockAddr;
    ULONG BufferSize;
    int FormatType;
    RPC_STATUS RpcStatus;

    *Returned = 0;

    EnterSem();

    if (*key)
        {
        if (*key == LOOKUP_FINISHED)
            {
            *key = 0;
            LeaveSem();
            return(EP_S_NOT_REGISTERED);
            }

        if (Context->Signature != EPLookupHandleSignature)
            {
            LeaveSem();
            return EP_S_CANT_PERFORM_OP;
            }

        err = GetEntriesFromSavedContext(Context, Buffer, Requested, Returned);
        if (Context->List == 0)
            {
            UnLink((PIENTRY *)&GlobalContextList, (PIENTRY)Context);
            FreeMem(Context);

            // Setting the Key To FFFFFFFFL is a hack for down level
            // Version 1.0 Ep Clients who never expected getting a key 0
            // and Success!
            if (Requested <= 1)
                *key = LOOKUP_FINISHED;
            else
                *key = 0L;

            LeaveSem();
            return(err);
            }

        LeaveSem();
        return(err);
        }

    *key = 0;
    while ((!err))
        {
        if ((pNode = FindIFOBJNode(
                        pList,
                        ObjUuid,
                        IFUuid,
                        Version,
                        pSID,
                        InqType,
                        VersOptions,
                        Match)) == 0)
            {
            break;
            }

        pPSEPNode = pNode->PSEPlist;

        while (pPSEPNode != 0)
            {
            if ((pPSEPNode = FindPSEP(pPSEPNode, Pseq, NULL, 0L,
                              MatchPSAndEP)) == 0)
                break;

            fPatchTower = FALSE;
            if (StringCompareA(pPSEPNode->Protseq, "ncacn_ip_tcp") == 0
                || StringCompareA(pPSEPNode->Protseq, "ncadg_ip_udp") == 0
                || StringCompareA(pPSEPNode->Protseq, "ncacn_http") == 0)
                {
                pIPAddr = (int UNALIGNED *) ((char *) pPSEPNode->Tower + IP_ADDR_OFFSET);

                if (*pIPAddr == 0)
                    {
                    BufferSize = sizeof(SockAddr);

                    RpcStatus = I_RpcServerInqLocalConnAddress(NULL,
                        &SockAddr,
                        &BufferSize,
                        &FormatType);

                    if (RpcStatus == RPC_S_OK)
                        {
                        // IPv6 towers don't exist yet - they are not defined
                        // by DCE. Do patching for IPv4 only
                        if (FormatType == RPC_P_ADDR_FORMAT_TCP_IPV4)
                            {
                            PatchTowerAddress = ((SOCKADDR_IN *)&SockAddr)->sin_addr.S_un.S_addr;
                            fPatchTower = TRUE;
                            }
                        }

                    }
                }

            if (*Returned < Requested)
                {
                err = PackDataIntoBuffer(&buffer, pNode, pPSEPNode, Calltype, fPatchTower, PatchTowerAddress);
                if (err == RPC_S_OK)
                    {
                    (*Returned)++;
                    }
                else
                    {
                    ASSERT(err == RPC_S_OUT_OF_MEMORY);
                    break;
                    }
                }
            else
                {
                if (Context == 0)
                    {
                    *key = (ept_lookup_handle_t) (Context = GetNewContext(Calltype));
                    if (Context == 0)
                        {
                        err = RPC_S_OUT_OF_MEMORY;
                        break;
                        }
                    }
                AddToSavedContext(Context, pNode, pPSEPNode, Calltype, fPatchTower, PatchTowerAddress);
                }

            pPSEPNode = pPSEPNode->Next;
            } // while - over PSEPList

        pList = pNode->Next;
        } // while - over IFOBJList


    LeaveSem();

    if ((*Returned == 0) && Requested  && (!err))
        {
        err = EP_S_NOT_REGISTERED;
        }

    if ((*Returned <= Requested) &&  (Context == 0))
        {
        if (Requested <= 1)
            *key = LOOKUP_FINISHED;
        else
            *key = 0L;
        }

    return(err);
}




RPC_STATUS
PackDataIntoBuffer(
    char * * Buffer,
    PIFOBJNode Node,
    PPSEPNode PSEP,
    unsigned long Type,
    BOOL fPatchTower,
    int PatchTowerAddress
    )
/*++

Routine Description:

    This routine copies 1 entry [Either a Tower or ept_entry]
    in the Buffer, increments buffer appropriately.

Arguments:

    BindingHandle - An explicit binding handle to the EP.

    Node - IFOBJNode

    PSEP - PSEPNode

    Type - Type of entry to be copied

    PatchTower - if TRUE, the newly created tower needs to be patched. If
        FALSE, the tower doesn't need to be patched

    PatchTowerAddress - an IPv4 representation of the address to be put
        in the tower. The IPv4 address must be in network byte order

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    I_Tower * Twr;
    ept_entry_t *p;

    switch (Type)
        {
        case EP_MAP:
            Twr = (I_Tower *)(* Buffer);
            Twr->Tower = NewTower(PSEP->Tower);
            if (Twr->Tower == 0)
                {
                return(RPC_S_OUT_OF_MEMORY);
                }
            if (fPatchTower)
                PatchTower(Twr->Tower, PatchTowerAddress);
            *Buffer += sizeof(I_Tower);
            break;

        case EP_LOOKUP:
            p = (ept_entry_t *)(*Buffer);
            p->tower = NewTower(PSEP->Tower);
            if (p->tower == 0)
                {
                return(RPC_S_OUT_OF_MEMORY);
                }
            if (fPatchTower)
                PatchTower(p->tower, PatchTowerAddress);
            memcpy( *Buffer, (char *)&Node->ObjUuid, sizeof(UUID) );
            strcpy(p->annotation, Node->Annotation);
            *Buffer += sizeof(ept_entry_t);
            break;

        default:
            ASSERT(!"Unknown type");
            break;
        }

    return(RPC_S_OK);
}




void
ept_cleanup_handle_t_rundown(
    ept_cleanup_handle_t hEpCleanup
    )
/*++

Routine Description:

    This routine cleans up the entries registered by the process
    associated with this context handle hEpCleanup.

Arguments:

    hEpCleanup - The context handle for which the rundown is
        being done.

Return Value:

    None.

--*/
{
    PIFOBJNode NodesListToDelete = NULL;
    PIFOBJNode pIterator, DeleteMe, pPreviousNode;
    PPSEPNode pTempPSEP, pDeletePSEP;
    PEP_CLEANUP ProcessCtxt = (PEP_CLEANUP) hEpCleanup;
#ifdef DBG_DETAIL
    PIFOBJNode pTemp, pLast;
#endif // DBG_DETAIL

    if (ProcessCtxt == NULL)
        {
        return;
        }

    EnterSem();

    ASSERT(IFObjList);
    ASSERT(cTotalEpEntries > 0);
    ASSERT(ProcessCtxt->EntryList);
    ASSERT(ProcessCtxt->cEntries > 0);
    ASSERT(ProcessCtxt->EntryList->OwnerOfList == ProcessCtxt);
    ASSERT_PROCESS_CONTEXT_LIST_COUNT(ProcessCtxt, ProcessCtxt->cEntries);

#ifdef DBG_DETAIL
    DbgPrint("RPCSS: Entered Cleanup Rundown for [%p] with (%d) entries\n",
             hEpCleanup, ProcessCtxt->cEntries);
    DbgPrint("RPCSS: Dump of IFOBJList\n");
    pTemp = IFObjList;
    pLast = IFObjList;
    while (pTemp)
        {
        DbgPrint("RPCSS: \t\t[%p]\n", pTemp);
        pLast = pTemp;
        pTemp = pTemp->Next;
        }
    DbgPrint("RPCSS: --------------------\n");
    while (pLast)
        {
        DbgPrint("RPCSS: \t\t\t[%p]\n", pLast);
        pLast = pLast->Prev;
        }
#endif // DBG_DETAIL

    // Save the previous Node.
    pPreviousNode = ProcessCtxt->EntryList->Prev;

    pIterator = ProcessCtxt->EntryList;
    while ((pIterator != NULL) && (pIterator->OwnerOfList == ProcessCtxt))
        {
        ProcessCtxt->cEntries--;
        cTotalEpEntries--;
#ifdef DBG_DETAIL
        DbgPrint("RPCSS: cTotalEpEntries-- [%p] (%d) - Cleanup\n", hEpCleanup, cTotalEpEntries);
#endif // DBG_DETAIL

        DeleteMe = pIterator;
        pIterator = pIterator->Next;

        // Add to a list that will be deleted later.
        DeleteMe->Next = NodesListToDelete;
        NodesListToDelete = DeleteMe;

        DeleteMe->Signature = FREE;
        }

    ASSERT(ProcessCtxt->cEntries == 0);

    //
    // Adjust the links
    //
    if (pPreviousNode)
        {
        // Adjust forward link
        pPreviousNode->Next = pIterator;
        }
    else
        {
        ASSERT(ProcessCtxt->EntryList == IFObjList);
        }

    if (pIterator)
        {
        // Adjust backward link
        pIterator->Prev = pPreviousNode;
        }

    //
    // Empty the EP Mapper table, if necessary.
    //
    if (ProcessCtxt->EntryList == IFObjList)
        {
        if (pIterator)
            {
            ASSERT(cTotalEpEntries > 0);

            // New Head for Ep Mapper list
            IFObjList = pIterator;
            }
        else
            {
            ASSERT(cTotalEpEntries == 0);

            // Memory for this node is already freed in the while loop above.
            IFObjList = NULL;
            }
        }
    else
        {
        ASSERT(cTotalEpEntries > 0);
        }

    LeaveSem();

    //
    // Free entities outside the lock.
    //
    FreeMem(ProcessCtxt);

    while (NodesListToDelete != NULL)
        {
        DeleteMe = NodesListToDelete;
        NodesListToDelete = NodesListToDelete->Next;
        // Delete the PSEP list.
        pTempPSEP = DeleteMe->PSEPlist;
        while (pTempPSEP != NULL)
            {
            pDeletePSEP = pTempPSEP;
            pTempPSEP = pTempPSEP->Next;
            FreeMem(pDeletePSEP);
            }

        I_RpcFree(DeleteMe->pSID);
        FreeMem(DeleteMe);
        }
}




void
ept_insert(
    handle_t h,
    unsigned32 NumEntries,
    ept_entry_t Entries[],
    unsigned long Replace,
    error_status  *Status
    )
/*++

Routine Description:

    This function is no longer supported by EpMapper. RPC Runtime does not
    call this function anymore. And, no one else should be...

--*/
{
    if (Status == NULL)
        RpcRaiseException(EPT_S_CANT_PERFORM_OP);

    *Status = EPT_S_CANT_PERFORM_OP;
}




RPC_STATUS GetCurrentUserSid(
    IN BOOL fImpersonating,
    OUT PSID *ppSid
    )
/*++

Routine Description:

    Returns the SID of the thread if thread token could be queried, or the process.
    It is the responsibility of the caller to free the SID.

Return Value:

    RPC_S_OK on sucess

--*/
{
    HANDLE hUserToken;
    HANDLE hThread = GetCurrentThread(); // We don't need to close this handle.
    DWORD dwStatus = 0;
    DWORD dwSizeNeeded = 0;
    TOKEN_USER *pTokenData;
    BOOL b;
    DWORD cbSid;

    // First, try to get the access token from the thread, in case
    // we are impersonating.
    if (!hThread)
       {
       return RPC_S_OUT_OF_RESOURCES;
       }

    b = OpenThreadToken(hThread,
                        TOKEN_READ,
                        FALSE, // Use context of the thread...
                        &hUserToken);

    // We could not get the thread's token
    if (!b)
        {
        dwStatus = GetLastError();
        
        // If we are getting an impersonation token we have to fail
        // since retrieving the process token would be incorrect.
        if (fImpersonating)
            {
            ASSERT(dwStatus != ERROR_NO_TOKEN);
            return RPC_S_OUT_OF_RESOURCES;
            }

        if (dwStatus == ERROR_NO_TOKEN)
            {
            // Try to get the process' access token.
            HANDLE hProcess = GetCurrentProcess(); // This never fails.
            ASSERT(hProcess);

            // Reset the status since we are trying again to get the token.
            dwStatus = NO_ERROR;
            b = OpenProcessToken(hProcess,
                                 TOKEN_READ,
                                 &hUserToken);
            if (!b)
                {
                dwStatus = GetLastError();
                }
            }
        }

    // Both ways of getting the token failed.
    if (dwStatus)
       {
       return RPC_S_OUT_OF_RESOURCES;
       }

    // We have a token.
    ASSERT(hUserToken);

    // Query for the size of user information.
    b = GetTokenInformation( hUserToken,
                             TokenUser,
                             0,
                             0,
                             &dwSizeNeeded
                             );
    // Query should have failed.
    ASSERT(!b && (GetLastError() == ERROR_INSUFFICIENT_BUFFER));

    // Allocate and retrieve the user info.
    pTokenData = (TOKEN_USER*)_alloca(dwSizeNeeded);
    if (!GetTokenInformation( hUserToken,
                              TokenUser,
                              pTokenData,
                              dwSizeNeeded,
                              &dwSizeNeeded ))
        {
        CloseHandle(hUserToken);
        return RPC_S_OUT_OF_RESOURCES;
        }

    CloseHandle(hUserToken);

    // Copy out the SID to be returned.
	cbSid = GetLengthSid(pTokenData->User.Sid);
	*ppSid = (PSID) I_RpcAllocate(cbSid);
    if (*ppSid == NULL)
        {
        return RPC_S_OUT_OF_RESOURCES;
        }
  	CopySid(cbSid, *ppSid, pTokenData->User.Sid);

    // The caller will have to free the copy.

    return RPC_S_OK;
}




void
ept_insert_ex(
    IN handle_t h,
    IN OUT ept_cleanup_handle_t *hEpCleanup,
    IN unsigned32 NumEntries,
    IN ept_entry_t Entries[],
    IN unsigned long Replace,
    OUT error_status  *Status
    )
/*++

Routine Description:

    This is the exposed rpc interface routine that adds a series of
    endpoints to the Endpoint Mapper database.

Arguments:

    h - An explicit binding handle to the EP.

    hEpCleanup - A context handle used to purge the Endpoint Mapper
        database of stale entries.

    NumEntries - Number of Entries to be added.

    Entries  - An array of ept_entry_t entries.

    Replace -  TRUE => Replace existing entries.
               FALSE=> Just add.

Return Value:

    RPC_S_OK - The endpoint was successfully deleted.

    RPC_S_OUT_OF_MEMORY - There is no memory to perform the op.

    EPT_S_CANT_PERFORM - Invalid entry.

--*/
{
    ept_entry_t * Ep;
    unsigned short i, j;
    unsigned int TransType = 0x0;
    unsigned long err = 0;
    unsigned long Version;
    unsigned char protseqid;
    char *Protseq, *Endpoint;
    RPC_IF_ID IfId;
    PPSEPNode List = 0;
    PPSEPNode pPSEPNode, TmpPsep, pTempPSEP, pDeletePSEP;
    unsigned long cb;
    twr_t * Tower;
    BOOL bIFNodeFound = FALSE;
    PIFOBJNode NodesListToDelete = NULL;
    PIFOBJNode Node, NewNode, DeleteMe = NULL;
    UUID * Object;
    char * Annotation;
    RPC_STATUS Err;
    SECURITY_DESCRIPTOR SecurityDescriptor, * PSecurityDesc;
    BOOL Bool;

    // SID of the principal registering the endpoint.
    PSID pSID;

    if (Status == NULL)
        RpcRaiseException(EPT_S_CANT_PERFORM_OP);

    // Security callback for the local epmp interface ensures that
    // the function may be called over lpc only.

    //
    // Create a temporary PSEP list from the Tower entries.
    //
    for (Ep = &Entries[0], i = 0; i < NumEntries; Ep++,i++)
        {
        err = TowerExplode(
                  Ep->tower,
                  &IfId,
                  NULL,
                  &Protseq,
                  &Endpoint,
                  0
                  );

        if (err == RPC_S_OUT_OF_MEMORY)
            break;

        if (err)
            {
            err = RPC_S_OK;
            continue;
            }

        Object = &Ep->object;
        Annotation = (char *)&Ep->annotation;
        Tower = Ep->tower;

        cb = sizeof(PSEPNode) +
             strlen(Protseq)  +
             strlen(Endpoint) +
             2 +                // for the 2 null terminators
             Tower->tower_length +
             sizeof(Tower->tower_length) +
             4;                 // We need to align tower on DWORD

        if ( (pPSEPNode = AllocMem(cb)) == NULL )
            {
            I_RpcFree(Protseq);
            I_RpcFree(Endpoint);

            err = RPC_S_OUT_OF_MEMORY;
            break;
            }

        // Mark this protseq to start listening if needed.
        protseqid = (unsigned char) GetProtseqIdAnsi(Protseq);
        DelayedUseProtseq(protseqid);

        //
        // Add a node to the temporary PSEP list
        //
        memset(pPSEPNode, 0, cb);

        pPSEPNode->Signature            = PSEPSIGN;
        pPSEPNode->Cb                   = cb;

        // Protseq
        //
        // Protseq is located after the PPSEPNode structure in the block at address pPSEPNode
        // allocated above. We created the block so that it would contain enough space for
        // Protseq, Endpoint, and Tower so that we would not allocate them separately.
        pPSEPNode->Protseq = (char *) (pPSEPNode + 1);
        strcpy(pPSEPNode->Protseq, Protseq);

        // Endpoint
        //
        // Similarly to Protseq, EP is located in the same heap block following the Protseq.
        pPSEPNode->EP = pPSEPNode->Protseq + strlen(pPSEPNode->Protseq) + 1;
        strcpy(pPSEPNode->EP, Endpoint);

        // Tower. We add necessary pad so that Tower is aligned to a DWORD.
        pPSEPNode->Tower = (twr_t PAPI *)(pPSEPNode->EP +
                                          strlen(pPSEPNode->EP) + 1);
        (char PAPI*)(pPSEPNode->Tower) += 4 - ((ULONG_PTR)
                                               (pPSEPNode->Tower) & 3);
        memcpy((char PAPI *)pPSEPNode->Tower,
               Tower,
               Tower->tower_length + sizeof(Tower->tower_length)
               );

        // Finally, add.
        EnterSem();
        EnLinkOnPSEPList(&List, pPSEPNode);
        LeaveSem();

        I_RpcFree(Protseq);
        I_RpcFree(Endpoint);
        }

    if ((err == RPC_S_OUT_OF_MEMORY) || (List == 0))
        {
        *Status = err;
        return;
        }


    CompleteDelayedUseProtseqs();


    Version = VERSION(IfId.VersMajor, IfId.VersMinor);

    // Get the SID of the caller to be included in the IFOBJ structure.
    Err = RpcImpersonateClient(NULL);
    if (Err != RPC_S_OK)
        {
        RpcRaiseException(Err);
        }

    Err = GetCurrentUserSid(TRUE, &pSID);
    if (Err != RPC_S_OK)
        {
        Err = RpcRevertToSelf();
        ASSERT(Err == RPC_S_OK);
        RpcRaiseException(Err);
        }
    ASSERT(pSID != NULL);

    Err = RpcRevertToSelf();
    ASSERT(Err == RPC_S_OK);

    //
    // Find if a compatible Endpoint Mapper entry is already present.
    //

    if (*hEpCleanup != NULL)
        {
        //
        // The requesting process has previously registered entries
        // with the Endpoint Mapper.
        //

        ASSERT_PROCESS_CONTEXT_LIST_COUNT((PEP_CLEANUP)*hEpCleanup, ((PEP_CLEANUP)*hEpCleanup)->cEntries);
        ASSERT(((PEP_CLEANUP)*hEpCleanup)->MagicVal == CLEANUP_MAGIC_VALUE);
        ASSERT(((PEP_CLEANUP)*hEpCleanup)->cEntries != 0);

        if (   (((PEP_CLEANUP)*hEpCleanup)->MagicVal != CLEANUP_MAGIC_VALUE)
            || (((PEP_CLEANUP)*hEpCleanup)->cEntries == 0))
            {
            *Status = EPT_S_CANT_PERFORM_OP;
            I_RpcFree(pSID);
            return;
            }

        EnterSem();

        if (Replace == TRUE)    // Common case
            {
            //
            // If we find a compatible entry, we just replace its PSEP list
            // with the temporary list that we just created.
            //
            Node = ((PEP_CLEANUP)*hEpCleanup)->EntryList;

            while (Node != 0)
                {
                Node = FindIFOBJNode(
                            Node,
                            Object,
                            &IfId.Uuid,
                            Version,
                            pSID,
                            RPC_C_EP_MATCH_BY_BOTH,
                            I_RPC_C_VERS_UPTO_AND_COMPATIBLE,
                            SearchIFObjNode
                            );

                if ((Node == 0) || (Node->OwnerOfList != *hEpCleanup))
                    break;

                // Matching Endpoint Mapper entry found.

                PurgeOldEntries(Node, List, FALSE);

                if (Node->IFVersion == Version)
                    {
                    bIFNodeFound = TRUE;

                    // Seek to the end of Tmp and then Link
                    TmpPsep = List;
                    while (TmpPsep->Next != 0)
                        TmpPsep = TmpPsep->Next;

                    TmpPsep->Next = Node->PSEPlist;
                    Node->PSEPlist  = List;
                    }

                if (Node->PSEPlist == 0)
                    {
                    DeleteMe = Node;
                    Node = Node->Next;
                    err = UnLinkFromIFOBJList((PEP_CLEANUP)*hEpCleanup, DeleteMe);
                    ASSERT(err == RPC_S_OK);

                    // Add to a list that will be deleted later...
                    DeleteMe->Next = NodesListToDelete;
                    NodesListToDelete = DeleteMe;

                    DeleteMe->Signature = FREE;
                    }
                else
                    {
                    Node = Node->Next;
                    }
                } // while loop
            }
        else    // (Replace != TRUE)
            {
            //
            // If we find an entry with an exact match, we append
            // the temporary PSEP list to the entry's PSEP list.
            //
            Node = ((PEP_CLEANUP)*hEpCleanup)->EntryList;

            NewNode = FindIFOBJNode(
                          Node,
                          Object,
                          &IfId.Uuid,
                          Version,
                          pSID,
                          0,
                          0,
                          ExactMatch
                          );

            if (NewNode && (NewNode->OwnerOfList == *hEpCleanup))
                {
                bIFNodeFound = TRUE;

                PurgeOldEntries(NewNode, List, TRUE);

                // Seek to the end of Tmp and then Link
                TmpPsep = List;
                while (TmpPsep->Next != 0)
                    TmpPsep = TmpPsep->Next;

                TmpPsep->Next = NewNode->PSEPlist;
                NewNode->PSEPlist = List;
                }
            } // if (Replace == TRUE)

        LeaveSem();

        } // if (*hpCleanup != NULL)


    //
    // Free the list outside the lock.
    //
    while (NodesListToDelete != NULL)
        {
        DeleteMe = NodesListToDelete;
        NodesListToDelete = NodesListToDelete->Next;
        // Delete the PSEP list.
        pTempPSEP = DeleteMe->PSEPlist;
        while (pTempPSEP != NULL)
            {
            pDeletePSEP = pTempPSEP;
            pTempPSEP = pTempPSEP->Next;
            FreeMem(pDeletePSEP);
            }
        FreeMem(DeleteMe);
        }

    if (bIFNodeFound == FALSE)
        {
        //
        // One of the following is TRUE:
        // a. The process is registering with EP Mapper for the first time.
        // b. No compatible Ep entry was found.
        //

        //
        // Allocate a new EP Mapper entry.
        //
        cb = sizeof(IFOBJNode);
        // We will put Annotation in the same heap block after IFOBJNode.
        cb += strlen(Annotation) + 1;

        if ((NewNode = AllocMem(cb)) == NULL)
            {
            *Status =  RPC_S_OUT_OF_MEMORY;
            I_RpcFree(pSID);
            return;
            }

        //
        // Fill-in the new entry
        //
        memset(NewNode, 0, cb);

        NewNode->Cb         = cb;
        NewNode->Signature  = IFOBJSIGN;
        NewNode->IFVersion  = Version;

        memcpy((char *)&NewNode->ObjUuid, (char *)Object, sizeof(UUID));
        memcpy((char *)&NewNode->IFUuid, (char *)&IfId.Uuid, sizeof(UUID));

        // Put Annotation in the IFOBJNode's heap block after the structure.
        strcpy((NewNode->Annotation=(char *)(NewNode+1)), Annotation);

        // The SID now migrated to the IFOBJNode.
        NewNode->pSID = pSID;

        if (IsNullUuid(Object))
            NewNode->IFOBJid = MAKEGLOBALIFOBJID(MAXIFOBJID);
        else
            NewNode->IFOBJid = MAKEGLOBALIFOBJID(GlobalIFOBJid--);

        //
        // Create a new context for this process, if necessary
        //
        if (*hEpCleanup == NULL)
            {
            *hEpCleanup = AllocMem(sizeof(EP_CLEANUP));
            if (*hEpCleanup == NULL)
                {
                FreeMem(NewNode);
                I_RpcFree(NewNode->pSID);
                *Status = RPC_S_OUT_OF_MEMORY;
                return;
                }

            memset(*hEpCleanup, 0x0, sizeof(EP_CLEANUP));

            ((PEP_CLEANUP)*hEpCleanup)->MagicVal = CLEANUP_MAGIC_VALUE;
            }

        //
        // Insert the new entry into the EP Mapper table.
        //
        EnterSem();

        err = EnLinkOnIFOBJList((PEP_CLEANUP)*hEpCleanup, NewNode);
        ASSERT(err == RPC_S_OK);

        NewNode->PSEPlist = List;

        LeaveSem();
        }

    *Status = err;
}




void
ept_delete(
    handle_t h,
    unsigned32 NumEntries,
    ept_entry_t Entries[],
    error_status *Status
    )
/*++

Routine Description:

    This function is no longer supported by EpMapper. RPC Runtime does not
    call this function anymore. And, no one else should be...

--*/
{
    if (Status == NULL)
        RpcRaiseException(EPT_S_CANT_PERFORM_OP);

    *Status = EPT_S_CANT_PERFORM_OP;
}




RPC_STATUS
ept_delete_ex_helper(
    IN ept_cleanup_handle_t hEpCleanup,
    IN UUID *Object,
    IN UUID *Interface,
    IN unsigned long  IFVersion,
    IN char PAPI * Protseq,
    IN char PAPI * Endpoint
    )
/*++

Routine Description:

    This routine deletes an Endpoint registered with the EP Mapper

Arguments:

    hEpCleanup - A context handle used to purge the Endpoint Mapper
        database of stale entries.

    Object - Object Uuid.

    Interface - If Uuid

    IFVersion - Version of the IF [Hi ushort=Major, Lo ushort=Minor]

    Protseq - Protocol Sequence

    Endpoint - Endpoint string

Notes:

    a. This routine has to be called by holding a mutex.

Return Value:

    RPC_S_OK - The endpoint was successfully deleted

    EPT_S_NOT_REGISTERED - No matching entries were found

--*/
{
    PIFOBJNode  pNode;
    PPSEPNode   pPSEPNode = NULL;
    unsigned long cb, err = 0;
    PEP_T p;
    PEP_CLEANUP ProcessCtx;

    if (!Protseq || !Endpoint)
        {
        return(EPT_S_NOT_REGISTERED);
        }

    CheckInSem();

    ProcessCtx = (PEP_CLEANUP)hEpCleanup;

    if (ProcessCtx->EntryList == NULL)
        return EPT_S_NOT_REGISTERED;

    // Search without regard to the registrant's SID.
    pNode = FindIFOBJNode(
                ProcessCtx->EntryList,
                Object,
                Interface,
                IFVersion,
                NULL,
                0L,
                0L,
                ExactMatch
                );

    if ((pNode != NULL) && (pNode->PSEPlist != NULL))
        {
        pPSEPNode = FindPSEP(
                        pNode->PSEPlist,
                        Protseq,
                        Endpoint,
                        0L,
                        MatchPSAndEP
                        );
        }

    if (pPSEPNode != NULL)
        {
        UnLinkFromPSEPList(&pNode->PSEPlist, pPSEPNode);

        if (pNode->PSEPlist == NULL)
            {
            err = UnLinkFromIFOBJList((PEP_CLEANUP)hEpCleanup, pNode);
            ASSERT(err == RPC_S_OK);

            if (err != RPC_S_OK)
                {
                // Restore the PSEPList
                EnLinkOnPSEPList(&pNode->PSEPlist, pPSEPNode);
                return err;
                }

            pNode->Signature = FREE;
            I_RpcFree(pNode->pSID);
            FreeMem(pNode);
            }

        pPSEPNode->Signature = FREE;
        FreeMem(pPSEPNode);
        }
    else
        {
        err = EPT_S_NOT_REGISTERED;
        }

    return(err);
}




void
ept_delete_ex(
    IN handle_t h,
    IN OUT ept_cleanup_handle_t *hEpCleanup,
    IN unsigned32 NumEntries,
    IN ept_entry_t Entries[],
    OUT error_status *Status
    )
/*++

Routine Description:

    This routine deletes the specified Endpoints

Arguments:

    BindingHandle - An explicit binding handle to the EP.

    NumEntries - #of entries in the Bunffer that need to be deleted.

    Entries[] - Buffer of #NumEntries of ept_entry_t structures

Return Value:

    RPC_S_OK - The endpoint was successfully deleted

    EPT_S_NOT_REGISTERED - No matching entries were found

--*/
{
    ept_entry_t * Ep;
    unsigned short i;
    unsigned int TransType = 0x0;
    RPC_STATUS err;
    RPC_STATUS DeleteStatus;
    unsigned long Version;
    char *Protseq, *Endpoint;
    RPC_IF_ID IfId;
    RPC_TRANSFER_SYNTAX XferId;

    if (Status == NULL)
        RpcRaiseException(EPT_S_CANT_PERFORM_OP);

    // Security callback for the local epmp interface ensures that
    // the function may be called over lpc only.

    if ( !(  (*hEpCleanup)
          && (((PEP_CLEANUP)*hEpCleanup)->MagicVal == CLEANUP_MAGIC_VALUE)
          && (((PEP_CLEANUP)*hEpCleanup)->cEntries != 0)
          )
       )
        {
        //
        // Cannot ASSERT here. This is possible. (ep1-26, ep2-3)
        //

        //ASSERT(*hEpCleanup);
        //ASSERT(((PEP_CLEANUP)*hEpCleanup)->MagicVal == CLEANUP_MAGIC_VALUE);
        //ASSERT(((PEP_CLEANUP)*hEpCleanup)->cEntries != 0);

        *Status = EPT_S_CANT_PERFORM_OP;
        return;
        }

    *Status = EPT_S_NOT_REGISTERED;
    DeleteStatus = RPC_S_OK;

    for (Ep = &Entries[0], i = 0; i < NumEntries; Ep++,i++)
        {
        err = TowerExplode(
                  Ep->tower,
                  &IfId,
                  &XferId,
                  &Protseq,
                  &Endpoint,
                  0
                  );

        if (err == RPC_S_OUT_OF_MEMORY)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            break;
            }

        if (err)
            {
            continue;
            }

        Version = VERSION(IfId.VersMajor, IfId.VersMinor);

        EnterSem();

        //
        // NOTE:
        //
        // If even one call to ept_delete_ex_helper() fails, we want to return
        // failure from ept_delete_ex(). This is different from the past where
        // if one call succeeded, then the function returned success.
        //
        err = ept_delete_ex_helper(
                   *hEpCleanup,
                   &Ep->object,
                   &IfId.Uuid,
                   Version,
                   Protseq,
                   Endpoint
                   );

        if (err)
            {
            // Save the last failure status.
            DeleteStatus = err;
            }

        if (((PEP_CLEANUP)*hEpCleanup)->cEntries == 0)
            {
            //
            // No entry left in this process's list. Time to zero out this
            // process's context handle.
            //
            //ASSERT(((PEP_CLEANUP)*hEpCleanup)->EntryList == NULL);

            FreeMem(*hEpCleanup);
            *hEpCleanup = NULL;
            }

        LeaveSem();

        if (Protseq)
            I_RpcFree(Protseq);

        if (Endpoint)
            I_RpcFree(Endpoint);
        }

    if (err)
        {
        // RPC_S_OUT_OF_MEMORY OR the last call to
        // ept_delete_ex_helper() failed.
        *Status = err;
        }
    else
        {
        // RPC_S_OK OR one of the calls to ept_delete_ex_helper() (but
        // not the last one) failed.
        *Status = DeleteStatus;
        }
}




void
ept_lookup(
    handle_t hEpMapper,
    unsigned32 InquiryType,
    UUID   * Object,
    RPC_IF_ID * Ifid,
    unsigned32 VersOptions,
    ept_lookup_handle_t *LookupHandle,
    unsigned32 MaxRequested,
    unsigned32 *NumEntries,
    ept_entry_t Entries[],
    error_status *Status
    )
/*++

Routine Description:

    This routine returns upto MaxRequested, ept_entry(s) currently
    registered with the Endpoint mapper based on the
    Obj, Interface, Protocol sequence  and filters VersOptions and
    InqType

Arguments:

    hEpMapper - An explicit binding handle to the EP.

    InquiryType - Search Filter [Seach based on IF, Obj or Both]

    Object - Object Uuid. specified by the client

    Ifid - Interface Uuid spec. by the client.

    InId - The If Specification [IF Uuid+IfVersion]

    VersOptions - Search Filter based on Versions [Versins <, >, ==]

    LookupHandle - A resume key - If NULL, search is started from the beginning
        if non-null, represents an encoding from where the epmapper is
        is supposed to start searching. It is an opaque value as far as the
        as far as the client is concerned.

    MaxRequested - Max number of entries requested by the client.

    NumEntries - The actual number of entries returned by the mapper.

    Entries - Buffer of ept_entries returned.

Return Value:

    RPC_S_OUT_OF_MEMORY

    RPC_S_OK - At least one matching entry is being returned.

    EP_S_NOT_REGISTERED - No matching entries were found

    EPT_S_CANT_PERFORM_OP - MaxRequested value exceed  ep_max_lookup_results

--*/

{
    unsigned long Version;

    if (Status == NULL)
        RpcRaiseException(EPT_S_CANT_PERFORM_OP);

    if (Ifid == NULL)
        {
        Ifid = &LocalNullUuid;
        }
    else
        {
        // Multiple full pointers in one method might point to the same memory.
        // We need to check for pointer values being the same in the manager routine
        // because reading these is unsafe and may case read-AVs.
        if ((void *)Ifid == (void *)Object)
            {
            RpcRaiseException(EPT_S_CANT_PERFORM_OP); 
            }
        }

    if (Object == NULL)
        {
        Object = (UUID *) &LocalNullUuid;
        }

    switch (VersOptions)
        {
        case RPC_C_VERS_ALL:
                Version = 0;
                break;

        case RPC_C_VERS_COMPATIBLE:
        case RPC_C_VERS_EXACT:
        case RPC_C_VERS_UPTO:
                Version  = VERSION(Ifid->VersMajor, Ifid->VersMinor);
                break;

        case RPC_C_VERS_MAJOR_ONLY:
                Version = VERSION(Ifid->VersMajor, 0);
                break;

        default:
                break;
        }

    *Status = GetEntries(
                  Object,
                  &Ifid->Uuid,
                  Version,
                  NULL,
                  NULL,
                  LookupHandle,
                  (char *)Entries,
                  EP_LOOKUP,
                  MaxRequested,
                  NumEntries,
                  InquiryType,
                  VersOptions,
                  SearchIFObjNode
                  );
}




void
ept_map_auth(
    handle_t h,
    UUID *Obj OPTIONAL,
    twr_p_t MapTower,
    PISID pSID,
    ept_lookup_handle_t *MapHandle,
    unsigned32 MaxTowers,
    unsigned32 *NumTowers,
    twr_p_t *ITowers,
    error_status *Status
    )
/*++

Routine Description:

    This routine returns a fully-resolved string binding, for a given
    Obj, Interface, and Protocol sequence if an appropriate entry is
    found. Else returns EP_S_NOT_REGISTERED.

Arguments:

    h - An explicit binding handle to the EP.

    Obj - Object Uuid specified by the client.

    MapTower - The input tower containing the protseq to query.

    pSID - The SID specified by the client.  If non-NULL, only entries registered
        by the principal with this SID will be returned.  If NULL, any matching entry
        will be returned without regard to the registering SID.

    MapHandle - A resume key - If NULL, search is started from the beginning
        if non-null, represents an encoding from where the epmapper is
        supposed to start searching. It is an opaque value as far as the
        client is concerned.

    MaxTowers - Max number of entries requested by the client.
    
    NumTowers - The actual number of entries returned by the mapper.

    ITowers - The fully resolved bindings.

Return Value:

    RPC_S_OUT_OF_MEMORY

    RPC_S_OK

    EP_S_NOT_REGISTERED

--*/
{

    RPC_IF_ID Ifid;
    RPC_TRANSFER_SYNTAX Xferid;
    char *Protseq;
    unsigned long Version;
    char * String = 0;

    if (Status == NULL)
        RpcRaiseException(EPT_S_CANT_PERFORM_OP);

    if (pSID != NULL && !IsValidSid(pSID))
        RpcRaiseException(EPT_S_CANT_PERFORM_OP);

    if (Obj == 0)
        {
        Obj = (UUID *) &LocalNullUuid;
        }
    else
        {
        // Multiple full pointers in one method might point to the same memory.
        // We need to check for pointer values being the same in the manager routine
        // because reading these is unsafe and may case read-AVs.
        if ((void *)Obj == (void *)MapTower)
            {
            RpcRaiseException(EPT_S_CANT_PERFORM_OP); 
            }
        }

    *Status = TowerExplode(
                  MapTower,
                  &Ifid,
                  &Xferid,
                  &Protseq,
                  NULL,
                  0
                  );

    if (*Status)
		{
		*NumTowers = 0;
        return;
		}

    Version = VERSION(Ifid.VersMajor,Ifid.VersMinor);

    if (memcmp((char *)&Ifid.Uuid, (char *)&MgmtIf, sizeof(UUID)) == 0)
        {
        if ((Obj == 0) || IsNullUuid(Obj))
            {
            *NumTowers = 0;
            *Status = RPC_S_BINDING_INCOMPLETE;
            }
        else
            {
            *Status = GetEntries(
                          Obj,
                          &Ifid.Uuid,
                          Version,
                          Protseq,
                          pSID,
                          MapHandle,
                          (char *)ITowers,
                          EP_MAP,
                          MaxTowers,
                          NumTowers,
                          RPC_C_EP_MATCH_BY_OBJ,
                          RPC_C_VERS_ALL,
                          SearchIFObjNode
                          );
            }
        }
    else
        {
        *Status = GetEntries(
                      Obj,
                      &Ifid.Uuid,
                      Version,
                      Protseq,
                      pSID,
                      MapHandle,
                      (char *)ITowers,
                      EP_MAP,
                      MaxTowers,
                      NumTowers,
                      0L,
                      0L,
                      WildCardMatch
                      );
        }

    if (Protseq)
        I_RpcFree(Protseq);
}




void
ept_map(
    handle_t h,
    UUID *Obj OPTIONAL,
    twr_p_t MapTower,
    ept_lookup_handle_t *MapHandle,
    unsigned32 MaxTowers,
    unsigned32 *NumTowers,
    twr_p_t *ITowers,
    error_status *Status
    )
/*++

Routine Description:

    This routine returns a fully-resolved string binding, for a given
    Obj, Interface, and Protocol sequence if an appropriate entry is
    found.  The funciton does not verify the SID of the registering principal.
    If an entry is not found returns EP_S_NOT_REGISTERED.

Arguments:

    Idenitcal to those of ept_map_auth

Return Value:

    Idenitcal to those of ept_map_auth

--*/
{
    ept_map_auth(h,
                 Obj,
                 MapTower,
                 NULL,
                 MapHandle,
                 MaxTowers,
                 NumTowers,
                 ITowers,
                 Status);
}



void
ept_inq_object(
    handle_t BindingHandle,
    UUID *Object,
    error_status *status
    )
/*++

Routine Description:

    Not supported

Arguments:

    BindingHandle - An explicit binding handle to the EP.

    Object _ No idea whose UUID this is.

Return Value:

    EPT_S_CANT_PERFORM_OP

--*/
{
    if (status == NULL)
        RpcRaiseException(EPT_S_CANT_PERFORM_OP);

    *status = EPT_S_CANT_PERFORM_OP;
}




void
DeletePSEP(
     PIFOBJNode Node,
     char * Protseq,
     char * Endpoint
     )
{

    PSEPNode *Psep, *Tmp;

    if (Node == 0)
        return;

    Psep = Node->PSEPlist;

    while (Psep  != 0)
        {
        Psep = FindPSEP(
                   Psep,
                   Protseq,
                   Endpoint,
                   0L,
                   MatchPSAndEP
                   );

        if (Psep != 0)
            {
            Tmp = Psep;
            Psep = Psep->Next;
            UnLinkFromPSEPList(&Node->PSEPlist, Tmp);
            Tmp->Signature = FREE;
            FreeMem(Tmp);
            }
        }
}




void
ept_mgmt_delete(
    handle_t BindingHandle,
    boolean32 ObjectSpecd,
    UUID * Object,
    twr_p_t Tower,
    error_status *Error
    )
/*++

Routine Description:

    Not supported

Arguments:

    BindingHandle - An explicit binding handle to the EP.

    Object _ ObjUUid

    Tower - Tower specifying the Endpoints to be deleted.

Return Value:

    EPT_S_CANT_PERFORM_OP

--*/
{
    if (Error == NULL)
        RpcRaiseException(EPT_S_CANT_PERFORM_OP);

    *Error = EP_S_CANT_PERFORM_OP;
}




void ept_lookup_handle_t_rundown (ept_lookup_handle_t h)
{

    PSAVEDCONTEXT Context = (PSAVEDCONTEXT) h;
    PIENTRY       Entry;
    unsigned long Type;
    PIENTRY       Tmp;
    twr_t         * Tower;


    ASSERT (Context != 0);

    if ( (PtrToUlong(Context)) == 0xFFFFFFFF)
        return;

    Type = Context->Type;

    EnterSem();

    Entry = (PIENTRY)Context->List;

    while (Entry != 0)
        {
        switch (Type)
            {
            case EP_MAP:
                Tower =  ((PSAVEDTOWER)Entry)->Tower;
                break;

            case EP_LOOKUP:
                Tower = ((PSAVED_EPT)Entry)->Tower;
                break;

            default:
                ASSERT(!"Unknown Inquiry Type");
                break;
            }

        MIDL_user_free(Tower);
        Tmp = Entry;
        Entry = Entry->Next;
        FreeMem(Tmp);
        }

    // Now free The Context
    UnLink((PIENTRY *)&GlobalContextList, (PIENTRY)Context);

    LeaveSem();

    FreeMem(Context);
}




void
ept_lookup_handle_free(
    handle_t h,
    ept_lookup_handle_t * ept_context_handle,
    error_status * status
    )
{
    if ( (ept_context_handle != 0) && (*ept_context_handle != 0))
        {
        ept_lookup_handle_t_rundown( *ept_context_handle );
        *ept_context_handle = 0;
        }

    *status = 0;
}



#define MAX(x,y) ((x) < (y)) ? (y) : (x)
#define MIN(x,y) ((x) > (y)) ? (y) : (x)

#ifdef DEBUGRPC
#define DEBUG_MIN(x,y) MIN((x),(y))
#else
#define DEBUG_MIN(x,y) MAX((x),(y))
#endif




error_status_t
OpenEndpointMapper(
    IN handle_t hServer,
    OUT HPROCESS *pProcessHandle
    )
{
    PROCESS *pProcess = MIDL_user_allocate(sizeof(PROCESS));

    if (!pProcess)
        {
        *pProcessHandle = 0;
        return(RPC_S_OUT_OF_MEMORY);
        }

    pProcess->MagicVal = PROCESS_MAGIC_VALUE;
    pProcess->pPorts = 0;
    *pProcessHandle = (PVOID)pProcess;

    return(RPC_S_OK);
}



//
// Port Management stuff
//



//
// Port Management Globals
//

const RPC_CHAR *PortConfigKey = RPC_CONST_STRING("Software\\Microsoft\\Rpc\\Internet");
const RPC_CHAR *DefaultPortType = RPC_CONST_STRING("UseInternetPorts");
const RPC_CHAR *ExplictPortType = RPC_CONST_STRING("PortsInternetAvailable");
const RPC_CHAR *PortRanges = RPC_CONST_STRING("Ports");

CRITICAL_SECTION PortLock;

BOOL fValidConfiguration = FALSE;
BOOL fPortRestrictions = FALSE;
PORT_TYPE SystemDefaultPortType = 0;

IP_PORT *pFreeInternetPorts = 0;
IP_PORT *pFreeIntranetPorts = 0;

PORT_RANGE *InternetPorts = 0;
PORT_RANGE *IntranetPorts = 0;



//
// Port management APIs
//


RPC_STATUS
InitializeIpPortManager(
    void
    )
{
    HKEY hkey;
    RPC_STATUS status;
    DWORD size, type, value;
    RPC_CHAR *pstr;
    PORT_RANGE *pSet;
    PORT_RANGE *pLast;
    PORT_RANGE *pCurrent;
    PORT_RANGE *pComplement;
    PORT_RANGE *pNew;

    LONG min, max;


    InitializeCriticalSectionAndSpinCount(&PortLock, PREALLOCATE_EVENT_MASK);

    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           PortConfigKey,
                           0,
                           KEY_READ,
                           &hkey);

    if (status != RPC_S_OK)
        {
        if (status != ERROR_FILE_NOT_FOUND)
            {
#if DBG
            PrintToDebugger("RPCSS: Unable to open port config key: %d\n", status);
#endif
            }
        ASSERT(status == ERROR_FILE_NOT_FOUND);

        fValidConfiguration = TRUE;
        return(RPC_S_OK);
        }

    size = sizeof(value);
    status = RegQueryValueEx(hkey,
                              DefaultPortType,
                              0,
                              &type,
                              (PBYTE)&value,
                              &size);

    if (   status != RPC_S_OK
        || type != REG_SZ
        || (    *(RPC_CHAR *)&value != 'Y'
             && *(RPC_CHAR *)&value != 'y'
             && *(RPC_CHAR *)&value != 'N'
             && *(RPC_CHAR *)&value != 'n') )
        {
        RegCloseKey(hkey);
        ASSERT(fValidConfiguration == FALSE);
        return(RPC_S_OK);
        }

    if (   *(RPC_CHAR *)&value == 'Y'
        || *(RPC_CHAR *)&value == 'y')
        {
        SystemDefaultPortType = PORT_INTERNET;
        }
    else
        {
        SystemDefaultPortType = PORT_INTRANET;
        }

    size = sizeof(value);
    status = RegQueryValueEx(hkey,
                              ExplictPortType,
                              0,
                              &type,
                              (PBYTE)&value,
                              &size);

    if (   status != RPC_S_OK
        || type != REG_SZ
        || (    *(RPC_CHAR *)&value != 'Y'
             && *(RPC_CHAR *)&value != 'y'
             && *(RPC_CHAR *)&value != 'N'
             && *(RPC_CHAR *)&value != 'n') )
        {
        RegCloseKey(hkey);
        ASSERT(fValidConfiguration == FALSE);
        return(RPC_S_OK);
        }

    if (   *(RPC_CHAR *)&value == 'Y'
        || *(RPC_CHAR *)&value == 'y')
        {
        value = PORT_INTERNET;
        }
    else
        {
        value = PORT_INTRANET;
        }

    size = DEBUG_MIN(1, 100);

    do
        {
        ASSERT(size);
        pstr = alloca(size);
        ASSERT(pstr);

        status = RegQueryValueEx(hkey,
                                  PortRanges,
                                  0,
                                  &type,
                                  (PBYTE)pstr,
                                  &size);
        }
    while (status == ERROR_MORE_DATA);

    RegCloseKey(hkey);

    if (   status != RPC_S_OK
        || type != REG_MULTI_SZ)
        {
        ASSERT(fValidConfiguration == FALSE);
        return(RPC_S_OK);
        }

    //
    // The user is going to specify a range of ports in the registery
    // with a flag indicating if these ports are internet or intranet.
    //
    // ie, 500-550
    //     560
    //     559
    //     2000-2048
    //     2029-2049
    //
    // Note that order (in the REG_MULTI_SZ) and overlapping sets
    // are ok.  We must handle creating a port range list for this
    // array and for the complement BUT NOT INCLUDING <=1024 by default.
    //
    // completment set to above is:
    //
    //     1025-1999
    //     2050-32767
    //

    #define MIN_PORT 1025    // Only important for complement sets.
    #define MAX_PORT 65535

    pSet = 0;
    pLast = 0;

    while(*pstr)
        {
        RPC_CHAR *t;

#ifdef UNICODE
        min = wcstol(pstr, &t, 10);
#else
        min = strtol(pstr, &t, 10);
#endif

        if (min > MAX_PORT || min < 0)
            {
            status = RPC_S_INVALID_ARG;
            break;
            }

        if (   *t != 0
#ifdef UNICODE
            && *t != L'-')
#else
            && *t != '-')
#endif
            {
            status = RPC_S_INVALID_ARG;
            break;
            }

        if (*t == 0)
            {
            max = min;
            }
        else
            {
#ifdef UNICODE
            max = wcstol(t + 1, &t, 10);
#else
            min = strtol(t + 1, &t, 10);
#endif

            if (max > MAX_PORT || max < 0 || max < min)
                {
                status = RPC_S_INVALID_ARG;
                break;
                }
            }

        ASSERT(min <= max);

        // Ok, got some ports, allocate a structure for them..

        pNew = MIDL_user_allocate(sizeof(PORT_RANGE));
        if (0 == pNew)
            {
            status = RPC_S_OUT_OF_MEMORY;
            break;
            }

        pNew->pNext = 0;

        pNew->Min = (unsigned short) min;
        pNew->Max = (unsigned short) max;

        // We can to maintain the set of ranges in order.  As we insert
        // we'll fix any ranges which overlap.

        pCurrent = pSet;
        pLast = 0;

        for (;;)
            {
            if (0 == pSet)
                {
                pSet = pNew;
                break;
                }

            if (   pNew->Min <= (pCurrent->Max + 1)
                && pNew->Max >= (pCurrent->Min - 1) )
                {
                // The ranges overlap or touch.  We'll merge them now..

                pCurrent->Min = MIN(pNew->Min, pCurrent->Min);
                pCurrent->Max = MAX(pCurrent->Max, pNew->Max);

                MIDL_user_free(pNew);

                // Since the new larger range may overlap another existing
                // range we just insert the larger range as if it was new...
                pNew = pCurrent;

                // Take current out of the list.
                if (pLast)
                    {
                    pLast->pNext = pCurrent->pNext;
                    }

                if (pSet == pNew)
                    {
                    pSet = pSet->pNext;
                    }

                // Restart
                pCurrent = pSet;
                pLast = 0;
                continue;
                }

            if (pNew->Min < pCurrent->Min)
                {
                // Found the spot
                if (pLast)
                    {
                    pLast->pNext = pNew;
                    pNew->pNext = pCurrent;
                    }
                else
                    {
                    ASSERT(pCurrent == pSet);
                    pNew->pNext = pCurrent;
                    pSet = pNew;
                    }

                break;
                }

            // Continue the search
            pLast = pCurrent;
            pCurrent = pCurrent->pNext;

            if (0 == pCurrent)
                {
                // Reached the end of the list, insert it here.
                pLast->pNext = pNew;
                ASSERT(pNew->pNext == 0);
                break;
                }
            }

        ASSERT(pSet);

        // Advance to the next string of the final null.
        pstr = RpcpCharacter(pstr, 0) + 1;
        }

    if (pSet == 0)
        {
        status = RPC_S_INVALID_ARG;
        }

    if (value == PORT_INTERNET)
        {
        InternetPorts = pSet;
        }
    else
        {
        IntranetPorts = pSet;
        }

    if (status == RPC_S_OK)
        {
        // We've constructed the set of ports in the registry,
        // now we need to compute the complement set.

        pComplement = 0;
        pCurrent = 0;
        min = MIN_PORT;

        while(pSet)
            {
            if (min < pSet->Min)
                {
                max = pSet->Min - 1;
                ASSERT(max >= min);

                pNew = MIDL_user_allocate(sizeof(PORT_RANGE));
                if (0 == pNew)
                    {
                    status = RPC_S_OUT_OF_MEMORY;
                    break;
                    }

                pNew->pNext = 0;
                pNew->Min = (unsigned short) min;
                pNew->Max = (unsigned short) max;

                if (pComplement == 0)
                    {
                    pComplement = pCurrent = pNew;
                    }
                else
                    {
                    ASSERT(pCurrent);
                    pCurrent->pNext = pNew;
                    pCurrent = pNew;
                    }
                }

            min = MAX(MIN_PORT, pSet->Max + 1);

            pSet = pSet->pNext;
            }

        if (status == RPC_S_OK && min < MAX_PORT)
            {
            // Final port in orginal set less then max, allocate final
            // range for the set complement.
            pNew = MIDL_user_allocate(sizeof(PORT_RANGE));
            if (0 != pNew)
                {
                pNew->Min = (unsigned short) min;
                pNew->Max = MAX_PORT;
                pNew->pNext = 0;
                if (pCurrent)
                    {
                    pCurrent->pNext = pNew;
                    }
                else
                    {
                    ASSERT(min == MIN_PORT);
                    pComplement = pNew;
                    }
                }
            else
                {
                status = RPC_S_OUT_OF_MEMORY;
                }
            }

        // Even if we failed assign the pointer, it's either
        // null or needs to be freed.

        if (value == PORT_INTERNET)
            {
            ASSERT(IntranetPorts == 0);
            IntranetPorts = pComplement;
            }
        else
            {
            ASSERT(InternetPorts == 0);
            InternetPorts = pComplement;
            }
        }

    if (status != RPC_S_OK)
        {
        ASSERT(fValidConfiguration == FALSE);
        while(InternetPorts)
            {
            PORT_RANGE *pT = InternetPorts;
            InternetPorts = InternetPorts->pNext;
            MIDL_user_free(pT);
            }

        while(IntranetPorts)
            {
            PORT_RANGE *pT = IntranetPorts;
            IntranetPorts = IntranetPorts->pNext;
            MIDL_user_free(pT);
            }
        return(RPC_S_OK);
        }

    fValidConfiguration = TRUE;
    fPortRestrictions = TRUE;
    return(RPC_S_OK);
}




BOOL
AllocatePort(
    OUT IP_PORT **ppPort,
    IN OUT IP_PORT **ppPortFreeList,
    IN PORT_RANGE *pPortList
    )
/*++

Routine Description:

    Allocates a port object for a specific process.  It first tries
    to use any ports in the free list.  If there's nothing in the
    port this then it tries to find a free port in the PortList
    which is one of the sets computed during startup.

Arguments:

    ppPort - Will contain the allocated port object if successful.

    ppPortFreeList - Pointer to the head of the free list associated
        with this type of port.  Maybe modified during this call.

    pPortList - Port ranges associated with this type of port.

Return Value:

    TRUE - Port allocated
    FALSE - Port not allocated

--*/
{
    IP_PORT *pPort = 0;

    // First see if there is free port to reuse.

    if (*ppPortFreeList)
        {
        EnterCriticalSection(&PortLock);
        if (*ppPortFreeList)
            {
            pPort = *ppPortFreeList;
            *ppPortFreeList = pPort->pNext;
            pPort->pNext = 0;
            }
        LeaveCriticalSection(&PortLock);
        }

    if (pPort == 0)
        {
        // No port in the free list, try to allocate one
        // Assume we'll find a free port..

        pPort = MIDL_user_allocate(sizeof(IP_PORT));

        if (0 != pPort)
            {
            pPort->pNext = 0;

            EnterCriticalSection(&PortLock);

            while (   pPortList
                   && pPortList->Min > pPortList->Max)
                {
                pPortList = pPortList->pNext;
                }

            if (pPortList)
                {
                ASSERT(pPortList->Min <= pPortList->Max);

                pPort->Port = pPortList->Min;
                pPortList->Min++;

                // We could remove empty ranges from the list.
                }

            LeaveCriticalSection(&PortLock);

            if (0 == pPortList)
                {
                MIDL_user_free(pPort);
                pPort = 0;
                #ifdef DEBUGRPC
                DbgPrint("RPC: Out of reserved ports\n");
                #endif
                }
            }
        }

    // REVIEW: Post SUR we should look at adding events for
    // allocation and failure to allocate IP ports

    *ppPort = pPort;

    return(pPort != 0);
}




error_status_t
AllocateReservedIPPort(
    IN HPROCESS hProcess,
    IN PORT_TYPE PortType,
    OUT long *pAllocationStatus,
    OUT unsigned short *pAllocatedPort
    )
/*++

Routine Description:

    Remote manager for RPC runtime to call locally to allocate
    a local port.  The call and process parameters must be valid
    and called only locally.  Based on the PortType paramet a
    IP port maybe allocated for the calling process.  The
    allocationstatus contains the result of the port allocation
    step.

Arguments:

    hProcess - Valid process context handle allocated with
        a call to OpenEndpointMapper.
    PortType - One of
        PORT_INTERNET
        PORT_INTRANET
        PORT_DEFAULT
        Used to determine which port range to allocate from.
    pAllocationStatus -
        RPC_S_OK - successfully allocated a port.
        RPC_S_OUT_OF_RESOURES - no ports available.
    pAllocatePort - If allocation status is RPC_S_OK then
        this contains the value of the port allocated.
        If zero it means that there are no port restrictions
        and any port maybe used.

Return Value:

    RPC_S_OK
    RPC_S_INVALID_ARG - configuration error or PortType out of range.
    RPC_S_ACCESS_ DENIED - not called locally.

--*/
{
    PROCESS *pProcess = (PROCESS *)hProcess;
    IP_PORT *pPort;
    BOOL b;

    *pAllocatedPort = 0;
    *pAllocationStatus = RPC_S_OK;

    ASSERT(pProcess);

    if (!fValidConfiguration)
        {
        return(RPC_S_INVALID_ARG);
        }

    // Security callback for the local epmp interface ensures that
    // the function may be called over lpc only.

    if ( (0 == pProcess) || (pProcess->MagicVal != PROCESS_MAGIC_VALUE ) )
        {
        return(RPC_S_ACCESS_DENIED);
        }

    if (PortType > PORT_DEFAULT || PortType < PORT_INTERNET)
        {
        return(RPC_S_INVALID_ARG);
        }

    if (fPortRestrictions == FALSE)
        {
        // No port restrictions on this machine, just use zero.
        // This is the common case.
        ASSERT(*pAllocatedPort == 0);
        ASSERT(*pAllocationStatus == 0);
        return(RPC_S_OK);
        }

    // Need to actually allocate a unique port for this process.

    if (PortType == PORT_DEFAULT)
        {
        // Allocate using default policy
        PortType = SystemDefaultPortType;
        }

    ASSERT(PortType == PORT_INTERNET || PortType == PORT_INTRANET);


    pPort = 0;

    if (PortType == PORT_INTERNET)
        {
        b = AllocatePort(&pPort,
                         &pFreeInternetPorts,
                         InternetPorts
                         );
        }
    else
        {
        b = AllocatePort(&pPort,
                         &pFreeIntranetPorts,
                         IntranetPorts);
        }

    if (!b)
        {
        ASSERT(pPort == 0);
        // REVIEW: Do we want a unique error code if no ports
        // are available?
        *pAllocationStatus = RPC_S_OUT_OF_RESOURCES;
        return(RPC_S_OK);
        }

    ASSERT(pPort);
    ASSERT(pPort->pNext == 0);

    pPort->Type = (unsigned short) PortType;

    pPort->pNext = pProcess->pPorts;
    pProcess->pPorts = pPort;

    *pAllocatedPort = pPort->Port;

    ASSERT(*pAllocationStatus == RPC_S_OK);

    return(RPC_S_OK);
}




void
HPROCESS_rundown(
    HPROCESS hProcess
    )
{
    PROCESS *pProcess = (PROCESS *)hProcess;
    IP_PORT *pCurrent;
    IP_PORT *pSave;

    ASSERT(pProcess);
    ASSERT(pProcess->MagicVal == PROCESS_MAGIC_VALUE);

    pCurrent = pProcess->pPorts;
    if (pCurrent)
        {
        EnterCriticalSection(&PortLock);

        do
            {
            pSave = pCurrent->pNext;

            if (pCurrent->Type == PORT_INTERNET)
                {
                pCurrent->pNext = pFreeInternetPorts;
                pFreeInternetPorts = pCurrent;
                }
            else
                {
                ASSERT(pCurrent->Type == PORT_INTRANET);
                pCurrent->pNext = pFreeIntranetPorts;
                pFreeIntranetPorts = pCurrent;
                }

            pCurrent = pSave;
            }
        while(pCurrent);

        LeaveCriticalSection(&PortLock);
        }

    MIDL_user_free(pProcess);

    return;
}

RPC_STATUS RPC_ENTRY
LocalEpmpSecurityCallback (
    IN RPC_IF_HANDLE InterfaceUuid,
    IN void *Context
    )
/*++

Routine Description:

    Security callback for the localepmp interface.
    The interface may only be called by local clients.
    For local protseqs we will return RPC_S_OK and RPC_S_ACCESS_DENIED
    otherwise.

Arguments:

    InterfaceUuid - Interface for which the callback is being issued.

    Context - The client binding handle.

Return Value:

    RPC_S_OK - the client is calling over lrpc
    RPC_S_ACCESS_DENIED - not called over lrpc

--*/
{
    RPC_STATUS Status;
    unsigned int TransportType;

    Status = I_RpcBindingInqTransportType(Context, &TransportType);

    ASSERT(Status == RPC_S_OK);

    if (Status != RPC_S_OK || TransportType != TRANSPORT_TYPE_LPC)
        {
        return(RPC_S_ACCESS_DENIED);
        }

    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\exts\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Mark Lucovsky (markl) 18-Sep-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

DLLBASE=0x1000000

MAJORCOMP=ntsd
MINORCOMP=ntsdexts

TARGETNAME=rpcexts
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=\
         $(SDK_LIB_PATH)\kernel32.lib

DLLDEF = ..\rpcdbg.def
MSC_WARNING_LEVEL=/W3 /WX

USE_NTDLL=1

INCLUDES=..\..\mtrt\;.;..;..\..\trans\Common;..\..\..\ndr20;   \
         ..\..\..\midl\inc;$(BASE_INC_PATH);..\..\rtifs\$(O);  \
		 $(PROJECT_ROOT)\inc\ndrshared

C_DEFINES=-DNTENV -DWIN32RPC -DNTWIN32RPC -DMSWMSG -D_RPCRT4_

SOURCES=..\rpcdbg.cxx     \
        ..\nttrans.cxx    \
        ..\rpcdbg.rc

RPCRUNTIME=..\..

LINKLIBS= \
         $(LINKLIBS) \
         $(PROJECT_ROOT)\lib\$(O)\RpcDbg.lib

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\exts\rpcdbg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 2001
//
//  File:       rpcdbg.cxx
//
//--------------------------------------------------------------------------

/*++

Module Name:

    rpcdbg.cxx

Abstract:



Author:

    Jeff Roberts (jroberts)  13-May-1996

Revision History:

     13-May-1996     jroberts           Created this module.

    Mazhar Mohammed (mazharm) 3-20-97 - changed it all for async RPC,
                                        added some cool stuff
                                        single dll for ntsd and kd

    KamenM                  Dec 99      Added debugging support and multiple
                                        ntsd-through-kd sessions support

    GrigoriK                Mar 2001    Added support for type info.

--*/

#define KDEXT_64BIT

#include <stddef.h>
#include <limits.h>

#define DG_LOGGING
#define private public
#define protected public
#include <sysinc.h>
#include <wincrypt.h>
#include <rpc.h>
#include <rpcndr.h>
#include <ndrp.h>
#include <wdbgexts.h>
#include <rpcdcep.h>
#include <rpcerrp.h>
#define SECURITY_WIN32
#include <rpcssp.h>
#include <authz.h>
#include <align.h>
#include <util.hxx>
#include <rpcuuid.hxx>
#include <interlck.hxx>
#include <mutex.hxx>
#include <CompFlag.hxx>
#include <sdict.hxx>
#include <sdict2.hxx>
#include <rpctrans.hxx>
#include <CellDef.hxx>
#include <CellHeap.hxx>
#include <EEInfo.h>
#include <EEInfo.hxx>
#include <SWMR.hxx>
#include <bcache.hxx>
#include <threads.hxx>
#include <queue.hxx>
#include <gc.hxx>
#include <handle.hxx>
#include <binding.hxx>
#include <osfpcket.hxx>
#include <bitset.hxx>
#include <secclnt.hxx>
#include <CompFlag.hxx>
#include <ProtBind.hxx>
#include <osfclnt.hxx>
#include <hndlsvr.hxx>
#include <osfsvr.hxx>
#include <rpccfg.h>
#include <epmap.h>
#include <delaytab.hxx>
#include <memory.hxx>
#include <dgpkt.hxx>
#include <locks.hxx>
#include <dgclnt.hxx>
#include <delaytab.hxx>
#include <hashtabl.hxx>
#include <dgsvr.hxx>
#include <lpcpack.hxx>
#include <lpcsvr.hxx>
#include <lpcclnt.hxx>
#include <ntverp.h>

#include "rpcexts.hxx"

HANDLE ProcessHandle = 0;
BOOL fKD = 0;

// is debuggee a CHK build?
BOOL ChkTarget;

EXT_API_VERSION        ApiVersion = { VER_PRODUCTVERSION_W >> 8,
                                      VER_PRODUCTVERSION_W & 0xff,
                                      EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOL                   bDebuggingChecked;

int AddressSize = 0;

BOOL bUnextend = FALSE;

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    KDDEBUGGER_DATA64 KdDebuggerData;

    ExtensionApis = *lpExtensionApis ;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;

    KdDebuggerData.Header.OwnerTag = KDBG_TAG;
    KdDebuggerData.Header.Size = sizeof( KdDebuggerData );

    if (Ioctl( IG_GET_DEBUGGER_DATA, &KdDebuggerData, sizeof( KdDebuggerData ) ))
        {
        fKD = 1;
        }

    if (IsPtr64())
        {
        AddressSize = 8;
        bUnextend = FALSE;
        }
    else
        {
        AddressSize = 4;
        bUnextend = TRUE;
        }
}

// By default we use the type information in extensins.
// This flag can be reset with !rpcexts.typeinfo off which will
// disable the use of type information.  !typeinfo on will
// enable it.
BOOL fUseTypeInfo = TRUE;

// If not set, the _NOSPEW macros will not print debugger spew.
// It is set to FALSE after the spew is printed by one of thise macros.
BOOL fSpew = TRUE;

char *
BoolString(
    BOOL Value
    )
{
    switch (Value)
        {
        case TRUE:  return "True";
        case FALSE: return "False";
        default:    return "?????";
        }
}

ULONG GetTypeSize(PUCHAR TypeName)
    {
    SYM_DUMP_PARAM Sym = {
        sizeof (SYM_DUMP_PARAM),
        TypeName, 
        DBG_DUMP_NO_PRINT, 0,
        NULL,
        NULL,
        NULL,
        NULL
    };

    return Ioctl(IG_GET_TYPE_SIZE, &Sym, Sym.size);
    }

ULONG64 GetVar(PCSTR VarName) {
    ULONG64 Var = 0;
    ULONG64 VarAddr = GetExpression(VarName);

    if (!VarAddr)
        {
        dprintf("Failure to get address of %s\n", VarName);
        return NULL;
        }

    if (ReadPtrUnextend(VarAddr, &Var))
        return NULL;

    return Var;
}

void do_dcebinding  (ULONG64 qwAddr);
void do_dgep        (ULONG64 qwAddr);
void do_dgsc        (ULONG64 qwAddr);
void do_dgsn        (ULONG64 qwAddr);
void do_osfbh       (ULONG64 qwAddr);
void do_osfca       (ULONG64 qwAddr);
void do_osfcconn    (ULONG64 qwAddr);
void do_osfccall    (ULONG64 qwAddr);
void do_osfaddr     (ULONG64 qwAddr);
void do_osfsconn    (ULONG64 qwAddr);
void do_osfscall    (ULONG64 qwAddr);
void do_osfsa       (ULONG64 qwAddr);
void do_rpcsvr      (ULONG64 qwAddr);
void do_lpcaddr     (ULONG64 qwAddr);
void do_lpcsa       (ULONG64 qwAddr);
void do_lpcscall    (ULONG64 qwAddr);
void do_lpcccall    (ULONG64 qwAddr);
void do_lpcbh       (ULONG64 qwAddr);
void do_lpcca       (ULONG64 qwAddr);
void do_rpcmem      (ULONG64 qwAddr, long lDisplay, long lVerbose);
void do_rpcmsg      (ULONG64 qwAddr);
void do_pasync      (ULONG64 qwAddr);
void do_authinfo    (ULONG64 qwAddr);
void do_error       (ULONG64 qwAddr);
void do_dict        (ULONG64 qwAddr);
void do_dict2       (ULONG64 qwAddr);
void do_queue       (ULONG64 qwAddr);
void do_stubmsg     (ULONG64 qwAddr);
void do_thread      (ULONG64 qwAddr);
void do_copacket    (ULONG64 qwAddr);
void do_obj         (ULONG64 qwAddr);
void do_transinfo   (ULONG64 qwAddr);
void do_lpcpacket   (ULONG64 qwAddr);
void do_IF          (ULONG64 qwAddr);
void do_assoctable  (ULONG64 qwAddr);
void do_eerecord    (ULONG64 qwAddr);
void do_eeinfo      (ULONG64 qwAddr);
void do_dgaddr      (ULONG64 qwAddr);
void do_dgca        (ULONG64 qwAddr);
void do_dgbh        (ULONG64 qwAddr);
void do_dgag        (ULONG64 qwAddr);
void do_dgcn        (ULONG64 qwAddr);
void do_typeinfo    (ULONG64 qwAddr);
void do_pipestate   (ULONG64 qwAddr);
void do_pipedesc    (ULONG64 qwAddr);
void do_pipearg     (ULONG64 qwAddr);
void do_pipemsg     (ULONG64 qwAddr);
void do_dgpe        (ULONG64 qwAddr);
void do_dgcc        (ULONG64 qwAddr);
void do_packet      (ULONG64 qwAddr);
void do_packet_header (ULONG64 qwAddr);
void do_trans       (ULONG64 qwAddr);
void do_dgpkt       (ULONG64 qwAddr);
void do_dgpkthdr    (ULONG64 qwAddr);
void do_asyncdcom   (ULONG64 qwAddr);
void do_asyncmsg    (ULONG64 qwAddr);
void do_asyncrpc    (ULONG64 qwAddr);
void do_listcalls   (ULONG64 qwAddr);

MY_DECLARE_API( assoctable )
MY_DECLARE_API( dgep )
MY_DECLARE_API( dgca )
MY_DECLARE_API( dgcn )
MY_DECLARE_API( dgsn )
MY_DECLARE_API( dgsc )
MY_DECLARE_API( osfbh )
MY_DECLARE_API( osfca )
MY_DECLARE_API( osfaddr )
MY_DECLARE_API( osfscall )
MY_DECLARE_API( osfsconn )
MY_DECLARE_API( dcebinding )
MY_DECLARE_API( osfccall )
MY_DECLARE_API( osfcconn )
MY_DECLARE_API( osfsa )
MY_DECLARE_API( rpcmsg )
MY_DECLARE_API( lpcaddr )
MY_DECLARE_API( lpcsa );
MY_DECLARE_API( lpcscall );
MY_DECLARE_API( lpcccall );
MY_DECLARE_API( lpcbh );
MY_DECLARE_API( lpcca );
MY_DECLARE_API( pasync);
MY_DECLARE_API( authinfo );
MY_DECLARE_API( error );
MY_DECLARE_API( dict );
MY_DECLARE_API( dict2 );
MY_DECLARE_API( queue );
MY_DECLARE_API( stubmsg );
MY_DECLARE_API( thread );
MY_DECLARE_API( copacket );
MY_DECLARE_API( obj );
MY_DECLARE_API( transinfo );
MY_DECLARE_API( lpcpacket );
MY_DECLARE_API( IF );
MY_DECLARE_API( eerecord );
MY_DECLARE_API( eeinfo );
MY_DECLARE_API( dgcc );
MY_DECLARE_API( dgpe );
MY_DECLARE_API( pipestate );
MY_DECLARE_API( pipedesc );
MY_DECLARE_API( pipearg );
MY_DECLARE_API( pipemsg );
MY_DECLARE_API( dgpkt );
MY_DECLARE_API( dgpkthdr );
MY_DECLARE_API( asyncdcom );
MY_DECLARE_API( asyncmsg );
MY_DECLARE_API( asyncrpc );

// define our own operators new and delete, so that we do not have to include the crt

void * __cdecl
::operator new(size_t dwBytes)
{
    void *p;
    p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes);
    return (p);
}


void __cdecl
::operator delete (void *p)
{
    HeapFree(GetProcessHeap(), 0, p);
}

// Returns 1 on failure.
BOOL ReadPtrUnextend(ULONG64 Addr, PULONG64 pVal) {

    *pVal = 0;

    if (!ReadPointer(Addr, pVal))
        return 1;

    if (bUnextend)
      *pVal = (ULONG64) (ULONG) *pVal;

    return 0;
}

BOOL
GetData(IN ULONG64 qwAddress, IN LPVOID ptr, IN ULONG size)
{
    BOOL b;
    ULONG BytesRead = 0;

    b = ReadMemory(qwAddress, ptr, size, &BytesRead );

    if (!b || BytesRead != size )
        {
        return FALSE;
        }
    return TRUE;
}

#define MAX_MESSAGE_BLOCK_SIZE 1024
#define BLOCK_SIZE 16

RPC_CHAR *
ReadProcessRpcChar(
    ULONG64 qwAddr
    )
{
    char block[BLOCK_SIZE];
    RPC_CHAR *RpcBlock  = (RPC_CHAR *)block;

    RPC_CHAR *RpcString = (RPC_CHAR *) new char[MAX_MESSAGE_BLOCK_SIZE];
    if (RpcString == NULL) {
        dprintf("couldn't allocate %d memory\n", MAX_MESSAGE_BLOCK_SIZE);
        return (NULL);
    }

    int length = 0;
    int i = 0;
    BOOL b;
    BOOL end = FALSE;

    if (qwAddr == NULL) {
        delete [] RpcString;
        return (NULL);
    }

    for (length = 0; length < MAX_MESSAGE_BLOCK_SIZE/2; ) {
        b = GetData(qwAddr, block, BLOCK_SIZE);
        if (b == FALSE) {
            dprintf("couldn't read address %I64xx\n", qwAddr);
            delete [] RpcString;
            return (NULL);
        }
        for (i = 0; i < BLOCK_SIZE/2; i++) {
            if (RpcBlock[i] == L'\0') {
                end = TRUE;
            }
            RpcString[length] = RpcBlock[i];
            length++;
        }
        if (end == TRUE) {
            break;
        }
        qwAddr += BLOCK_SIZE;
    }
   
    return (RpcString);
}

long
myatol(char *string)
{
    int  i         = 0;
    BOOL minus     = FALSE;
    long number    = 0;
    long tmpnumber = 0 ;
    long chknum = LONG_MAX;

    if (string[0] == '-') {
        minus = TRUE;
        i++;
    }
    else
    if (string[0] == '+') {
        i++;
    }
    for (; string[i] != '\0'; i++) {
        if ((string[i] >= '0')&&(string[i] <= '9')) {
            tmpnumber = string[i] - '0';
            if (number != 0)
                {
                chknum = LONG_MAX/number;
                }
            if (chknum > 11) {
                number = number*10 + tmpnumber;
            }
        }
        else
            return 0;
    }
    if (minus == TRUE) {
        number = 0 - number;
    }
    return number;
}

PCHAR
MapSymbol(ULONG64 qwAddr)
{
    static CHAR Name[256];
    ULONG64 Displacement;

    GetSymbol(qwAddr, Name, &Displacement);

    if (strcmp(Name, "") != 0) {
        if (Displacement)
            strcat(Name, "+");

        PCHAR p = strchr(Name, '\0');

        if (Displacement)
          _ui64toa(Displacement, p, 16);

        return(Name);
    }
    else {
        return NULL;
    }
}

// checks if the uuid is null, prints the uuid
void
PrintUuidLocal(UUID *Uuid)
{
    unsigned long PAPI * Vector;

    Vector = (unsigned long PAPI *) Uuid;
    if (    (Vector[0] == 0)
         && (Vector[1] == 0)
         && (Vector[2] == 0)
         && (Vector[3] == 0))
    {
        dprintf("(Null Uuid)");
    }
    else
    {
        dprintf("%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                Uuid->Data1, Uuid->Data2, Uuid->Data3, Uuid->Data4[0], Uuid->Data4[1],
                Uuid->Data4[2], Uuid->Data4[3], Uuid->Data4[4], Uuid->Data4[5],
                Uuid->Data4[6], Uuid->Data4[7] );
    }
    return;
}

// prints the uuid at a given address within the process
void
PrintUuid(ULONG64 Uuid)
{
    UUID UuidStore;

    GetData(Uuid, &UuidStore, sizeof(UUID));

    PrintUuidLocal(&UuidStore);
}

// Returns a string for the symbol that matches the value at
// address dwAddr, or "".
PCHAR SymbolAtAddress(ULONG64 Addr)
{
    CHAR Symbol[128];
    ULONG64 Displacement = 0;
    static CHAR Name[256];
    ULONG64 Val;

    if (ReadPtrUnextend(Addr, &Val))
        return "";

    GetSymbol(Val, Symbol, &Displacement);

    if (strcmp(Symbol, "") != 0) {
        sprintf(Name, "%s+%x", Symbol, Displacement);
        return Name;
    }
    else
        return "";
}

// Returns a string for the symbol that matches the value at
// address dwAddr, without the offset, or "".
PCHAR SymbolAtAddressNoOffset(ULONG64 Addr)
{
    CHAR Symbol[128];
    ULONG64 Displacement = 0;
    static CHAR Name[256];
    ULONG64 Val;

    if (ReadPtrUnextend(Addr, &Val))
        return "";

    GetSymbol(Val, Symbol, &Displacement);

    if (strcmp(Symbol, "") != 0) {
        strcpy(Name, Symbol);
        return Name;
    }
    else
        return "";
}

void
do_securitycontext (
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    if (qwAddr == 0)
        {
        return;
        }

    do_authinfo(qwAddr);

    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, AuthContextId,
    "     AuthContextId           ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, Flags,
    "     Flags                   ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, ContextAttributes,
    "     ContextAttributes       ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, fFullyConstructed,
    "     fFullyConstructed       ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, DontForgetToDelete,
    "     DontForgetToDelete      ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, fDatagram,
    "     fDatagram               ", tmp1);

    ULONG64 SecurityContext;
    GET_ADDRESS_OF(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, SecurityContext, SecurityContext, tmp2);
    ULONG64 dwUpper, dwLower;
    GET_MEMBER(SecurityContext, _SecHandle, RPCRT4!_SecHandle, dwUpper, dwUpper);
    GET_MEMBER(SecurityContext, _SecHandle, RPCRT4!_SecHandle, dwLower, dwLower);
    dprintf(
    "     SecurityContext(0x%I64x, 0x%I64x) - 0x%I64x\n", dwUpper, dwLower, SecurityContext);

    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, MaxHeaderLength,
    "     MaxHeaderLength         ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, MaxSignatureLength,
    "     MaxSignatureLength      ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, cbBlockSize,
    "     cbBlockSize             ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, RpcSecurityInterface,
    "     RpcSecurityInterface    ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, FailedContext,
    "     FailedContext           ", tmp1);
}

VOID
do_sizes(
    )
{
    PRINT_RPC_TYPE_SIZE(ASSOCIATION_HANDLE);
    dprintf("BIND_NAK_PICKLE_BUFFER_OFFSET - 0x%x\n", BIND_NAK_PICKLE_BUFFER_OFFSET);
    PRINT_RPC_TYPE_SIZE(BINDING_HANDLE);
    PRINT_RPC_TYPE_SIZE(BITSET);
    PRINT_RPC_TYPE_SIZE(CALL);
    PRINT_RPC_TYPE_SIZE(CCALL);
    PRINT_RPC_TYPE_SIZE(CLIENT_AUTH_INFO);
    PRINT_RPC_TYPE_SIZE(CLIENT_ID);
    PRINT_RPC_TYPE_SIZE(DCE_BINDING);
    PRINT_RPC_TYPE_SIZE(DCE_SECURITY_INFO);
    PRINT_RPC_TYPE_SIZE(EVENT);
    PRINT_RPC_TYPE_SIZE(GENERIC_OBJECT);
    PRINT_RPC_TYPE_SIZE(INTERLOCKED_INTEGER);
    PRINT_RPC_TYPE_SIZE(LOADABLE_TRANSPORT);
    PRINT_RPC_TYPE_SIZE(LRPC_ADDRESS);
    PRINT_RPC_TYPE_SIZE(LRPC_BIND_EXCHANGE);
    PRINT_RPC_TYPE_SIZE(LRPC_BINDING_HANDLE);
    PRINT_RPC_TYPE_SIZE(LRPC_CASSOCIATION);
    PRINT_RPC_TYPE_SIZE(LRPC_CCALL);
    PRINT_RPC_TYPE_SIZE(LRPC_MESSAGE);
    PRINT_RPC_TYPE_SIZE(LRPC_FAULT_MESSAGE);
    PRINT_RPC_TYPE_SIZE(LRPC_FAULT2_MESSAGE);
    PRINT_RPC_TYPE_SIZE(LRPC_RPC_HEADER);
    PRINT_RPC_TYPE_SIZE(LRPC_SASSOCIATION);
    PRINT_RPC_TYPE_SIZE(LRPC_SCALL);
    PRINT_RPC_TYPE_SIZE(LRPC_SERVER);
    dprintf("MAX_BIND_NAK - 0x%x\n", MAX_BIND_NAK);
    dprintf("MAXIMUM_FAULT_MESSAGE - 0x%x\n", MAXIMUM_FAULT_MESSAGE);
    dprintf("MAXIMUM_MESSAGE_BUFFER - 0x%x\n", MAXIMUM_MESSAGE_BUFFER);
    PRINT_RPC_TYPE_SIZE(MESSAGE_OBJECT);
    PRINT_RPC_TYPE_SIZE(MUTEX);
    PRINT_RPC_TYPE_SIZE(OSF_ADDRESS);
    PRINT_RPC_TYPE_SIZE(OSF_ASSOCIATION);
    PRINT_RPC_TYPE_SIZE(OSF_BINDING);
    PRINT_RPC_TYPE_SIZE(OSF_BINDING_HANDLE);
    PRINT_RPC_TYPE_SIZE(OSF_CASSOCIATION);
    PRINT_RPC_TYPE_SIZE(OSF_CCALL);
    PRINT_RPC_TYPE_SIZE(OSF_CCONNECTION);
    PRINT_RPC_TYPE_SIZE(OSF_SBINDING);
    PRINT_RPC_TYPE_SIZE(OSF_SCALL);
    PRINT_RPC_TYPE_SIZE(OSF_SCONNECTION);
    dprintf("PORT_MAXIMUM_MESSAGE_LENGTH - 0x%x\n", PORT_MAXIMUM_MESSAGE_LENGTH);
    PRINT_RPC_TYPE_SIZE(PORT_MESSAGE);
    PRINT_RPC_TYPE_SIZE(QUEUE);
    PRINT_RPC_TYPE_SIZE(RPC_ADDRESS);
    PRINT_RPC_TYPE_SIZE(RPC_APC_INFO);
    PRINT_RPC_TYPE_SIZE(RPC_CLIENT_INTERFACE);
    PRINT_RPC_TYPE_SIZE(RPC_CLIENT_PROCESS_IDENTIFIER);
    PRINT_RPC_TYPE_SIZE(rpcconn_alter_context);
    PRINT_RPC_TYPE_SIZE(rpcconn_alter_context_resp);
    PRINT_RPC_TYPE_SIZE(rpcconn_bind);
    PRINT_RPC_TYPE_SIZE(rpcconn_bind_ack);
    PRINT_RPC_TYPE_SIZE(rpcconn_common);
    PRINT_RPC_TYPE_SIZE(rpcconn_fault);
    PRINT_RPC_TYPE_SIZE(rpcconn_request);
    PRINT_RPC_TYPE_SIZE(rpcconn_response);
    PRINT_RPC_TYPE_SIZE(RPC_INTERFACE);
    PRINT_RPC_TYPE_SIZE(RPC_INTERFACE_MANAGER);
#if DBG
    PRINT_RPC_TYPE_SIZE(RPC_MEMORY_BLOCK);
#endif
    PRINT_RPC_TYPE_SIZE(RPC_MESSAGE);
    PRINT_RPC_TYPE_SIZE(RPC_SERVER);
    PRINT_RPC_TYPE_SIZE(RPC_SERVER_INTERFACE);
    PRINT_RPC_TYPE_SIZE(RPC_SYNTAX_IDENTIFIER);
    PRINT_RPC_TYPE_SIZE(RPC_UUID);
    PRINT_RPC_TYPE_SIZE(SCALL);
    PRINT_RPC_TYPE_SIZE(SECURITY_CONTEXT);
    PRINT_RPC_TYPE_SIZE(sec_trailer);
    PRINT_RPC_TYPE_SIZE(SIMPLE_DICT);
    PRINT_RPC_TYPE_SIZE(SIMPLE_DICT2);
    PRINT_RPC_TYPE_SIZE(THREAD);
    PRINT_RPC_TYPE_SIZE(TRANS_INFO);
}

DECLARE_API( sizes )
{
   do_sizes();
}

char *
GetError (DWORD dwError)
{
    DWORD   dwFlag = FORMAT_MESSAGE_FROM_SYSTEM;
    static CHAR   szErrorMessage[1024];
    static HANDLE  hSource = NULL;

    if ((dwError >= 2100) && (dwError < 6000))
    {
        if (hSource == NULL)
            {
            hSource = LoadLibrary("netmsg.dll");
            }

        if (hSource == NULL)
        {
            sprintf (szErrorMessage,
                      "Unable to load netmsg.dll. Error %d occured.\n",
                      dwError);
            return(szErrorMessage);
        }

        dwFlag = FORMAT_MESSAGE_FROM_HMODULE;
    }

    if (!FormatMessage (dwFlag,
                        hSource,
                        dwError,
                        0,
                        szErrorMessage,
                        1024,
                        NULL))
       {
        sprintf (szErrorMessage,
                  "An unknown error occured: 0x%x \n",
                  dwError);
       }

    return(szErrorMessage);
}

VOID
do_error (
    ULONG64 Error
    )
{
    dprintf("%x: %s\n", (unsigned long)Error, GetError((unsigned long) Error));
}

VOID
do_IF (
    ULONG64 rpcif
    )
{
    ULONG64 tmp0;
    ULONG64 tmp1;
    ULONG tmp2;
    dprintf("RPC_INTERFACE at 0x%I64x\n\n", rpcif);

    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, Server, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, NullManagerEpv, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, NullManagerFlag, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, ManagerCount, tmp0);
    GET_ADDRESS_OF(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, NullManagerActiveCallCount, tmp0, tmp2);
    PRINT_MEMBER_WITH_LABEL(tmp0, INTERLOCKED_INTEGER, RPCRT4!INTERLOCKED_INTEGER, Integer, "NullManagerActiveCallCount", tmp1);
    GET_ADDRESS_OF(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, AutoListenCallCount, tmp0, tmp2);
    PRINT_MEMBER_WITH_LABEL(tmp0, INTERLOCKED_INTEGER, RPCRT4!INTERLOCKED_INTEGER, Integer, "AutoListenCallCount", tmp1);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, Flags, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, MaxCalls, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, CallbackFn, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, PipeInterfaceFlag, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, fReplace, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, fBindingsExported, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, UuidVector, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, SequenceNumber, tmp0);
#if DBG
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, Strict, tmp0);
#endif
    PRINT_ADDRESS_OF(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, RpcInterfaceInformation, tmp2);
    PRINT_ADDRESS_OF(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, InterfaceManagerDictionary, tmp2);
    PRINT_ADDRESS_OF(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, Annotation, tmp2);
    PRINT_ADDRESS_OF(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, NsEntries, tmp2);
}

VOID
do_obj (
    ULONG64 qwAddr
    )
{
    BOOL b;

    ULONG64 MagicValue;
    ULONG64 ObjectType;

    if (ReadPtrUnextend(qwAddr+AddressSize, &MagicValue)) {
        dprintf("Bad or deleted object at %p\n", qwAddr);
        return;
    }

    if(ReadPtrUnextend(qwAddr+AddressSize+4, &ObjectType)) {
        dprintf("Bad or deleted object at %p\n", qwAddr);
        return;
    }

    if ((ULONG)MagicValue != MAGICLONG) {
        dprintf("Bad or deleted object at %p\n", qwAddr);
        return;
    }

    switch (((ULONG)ObjectType) & (~OBJECT_DELETED))
        {
        case DG_CALLBACK_TYPE:
            dprintf("this is a DG_CLIENT_CALLBACK object\n");
            break;
        case DG_CCALL_TYPE:
            {
            dprintf("Dumping DG_CCALL...\n");
            do_dgcc(qwAddr);
            break;
            }
        case DG_SCALL_TYPE:
            {
            dprintf("Dumping DG_SCALL...\n");
            do_dgsc(qwAddr);
            break;
            }
        case DG_BINDING_HANDLE_TYPE:
            {
            dprintf("dumping DG_BINDING_HANDLE...\n");
            do_dgbh(qwAddr);
            break;
            }
        case DG_CCONNECTION_TYPE:
            {
            dprintf("Dumping DG_CCONNECTION...\n");
            do_dgcn(qwAddr);
            break;
            }
        case DG_SCONNECTION_TYPE:
            {
            dprintf("Dumping DG_SCONNECTION...\n");
            do_dgsn(qwAddr);
            break;
            }
        case DG_ADDRESS_TYPE:
            {
            dprintf("dumping DG_ADDRESS\n");
            do_dgaddr(qwAddr);
            break;
            }
        case DG_CASSOCIATION_TYPE:
            {
            dprintf("a DG_CASSOCIATION\n");
            do_dgca(qwAddr);
            break;
            }
        case DG_SASSOCIATION_TYPE:
            {
            dprintf("a datagram ASSOCIATION_GROUP\n");
            do_dgag(qwAddr);
            break;
            }
        case OSF_BINDING_HANDLE_TYPE:
            dprintf("Dumping OSF_BINDING_HANDLE...\n");
            do_osfbh(qwAddr);
            break;
        case OSF_CCALL_TYPE:
            dprintf("Dumping OSF_CCALL...\n");
            do_osfccall(qwAddr);
            break;
        case OSF_SCALL_TYPE:
            dprintf("Dumping OSF_SCALL...\n");
            do_osfscall(qwAddr);
            break;
        case OSF_CCONNECTION_TYPE:
            dprintf("Dumping OSF_CCONNECTION...\n");
            do_osfcconn(qwAddr);
            break;
        case OSF_SCONNECTION_TYPE:
            dprintf("Dumping OSF_SCONNECTION...\n");
            do_osfsconn(qwAddr);
            break;
        case OSF_CASSOCIATION_TYPE:
            dprintf("Dumping OSF_CASSOCIATION...\n");
            do_osfca(qwAddr);
            break;
        case OSF_ASSOCIATION_TYPE:
            dprintf("Dumping OSF_ASSOCIATION...\n");
            do_osfsa(qwAddr);
            break;
        case OSF_ADDRESS_TYPE:
            dprintf("Dumping OSF_ADDRESS...\n");
            do_osfaddr(qwAddr);
            break;
        case LRPC_CCALL_TYPE:
            dprintf("Dumping LRPC_CCALL ...\n");
            do_lpcccall(qwAddr);
            break;
        case LRPC_SCALL_TYPE:
            dprintf("Dumping LRPC_SCALL ...\n");
            do_lpcscall(qwAddr);
            break;
        case LRPC_CASSOCIATION_TYPE:
            dprintf("Dumping LRPC_CASSOCIATION...\n");
            do_lpcca(qwAddr);
            break;
        case LRPC_SASSOCIATION_TYPE:
            dprintf("Dumping LRPC_SASSOCIATION...\n");
            do_lpcsa(qwAddr);
            break;
        case LRPC_BINDING_HANDLE_TYPE:
            dprintf("Dumping LRPC_BINDING_HANDLE...\n");
            do_lpcbh(qwAddr);
            break;
        case LRPC_ADDRESS_TYPE:
            dprintf("Dumping LRPC_ADDRESS...\n");
            do_lpcaddr(qwAddr);
            break;
        default:
            dprintf("The RPC object type is 0x%lx and I don't recognize it.\n", (ObjectType) & ~(OBJECT_DELETED));
        }
}

void
do_secinfo (
    )
{
    ULONG64 List;
    ULONG64 ProviderList;
    int NumberOfPackages;
    int LoadedProviders;
    int AvailableProviders;
    int i, Index;
    BOOL b;
    ULONG64 qwAddr;
    ULONG tmp;

    LoadedProviders = (int) GetVar("RPCRT4!LoadedProviders");

    dprintf("LoadedProviders = %d\n", LoadedProviders);

    AvailableProviders = (int) GetVar("RPCRT4!AvailableProviders");

    dprintf("AvailableProviders = %d\n", AvailableProviders);

    ProviderList = GetVar("RPCRT4!ProviderList");

    dprintf("ProviderList = 0x%I64x\n", ProviderList);

    List = ProviderList;

    for (i = 0; i < LoadedProviders; i ++)
        {
        ULONG64 Count;
        ULONG64 SecurityPackages;

        GET_MEMBER(List, SECURITY_PROVIDER_INFO, RPCRT4!SECURITY_PROVIDER_INFO, Count, Count);

        NumberOfPackages = (int)Count;

        GET_MEMBER(List, SECURITY_PROVIDER_INFO, RPCRT4!SECURITY_PROVIDER_INFO, SecurityPackages, SecurityPackages);

        dprintf("Provider: %d\n", i);
        for (Index = 0;Index < NumberOfPackages;Index++)
            {
            ULONG64 SecurityPackageInfo = SecurityPackages + Index * AddressSize;
            ULONG64 wRPCID;
            ULONG64 PackageInfoAddr;

            GET_ADDRESS_OF(SecurityPackageInfo, SECURITY_PACKAGE_INFO, RPCRT4!SECURITY_PACKAGE_INFO, PackageInfo, PackageInfoAddr, tmp);
            GET_MEMBER(PackageInfoAddr, _SecPkgInfoA, RPCRT4!_SecPkgInfoA, wRPCID, wRPCID);

            dprintf("PackageId :%d\n", (ULONG) wRPCID);
            }
        dprintf("\n");
        List+=GET_TYPE_SIZE(SECURITY_PROVIDER_INFO, RPCRT4!SECURITY_PROVIDER_INFO);
        } //For over all packages in one provider(dll)
}

DECLARE_API( secinfo )
{
   do_secinfo();
}

VOID
do_authinfo(
    ULONG64 authInfo
    )
{
    RPC_CHAR *ServerPrincipalName;
    ULONG64 tmp1;
    ULONG tmp2;

    if (authInfo == 0)
        {
        return;
        }

    ULONG64 ServerPrincipalNameAddr;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, ServerPrincipalName, ServerPrincipalNameAddr);

    ServerPrincipalName = ReadProcessRpcChar(ServerPrincipalNameAddr);
    if (ServerPrincipalName) {
        dprintf("     ServerPrincipalName      - %ws (Address: 0x%I64x)\n", ServerPrincipalName, ServerPrincipalNameAddr);
        delete ServerPrincipalName;
    }

    ULONG64 AuthenticationLevel;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, AuthenticationLevel, AuthenticationLevel);

    switch ((ULONG)AuthenticationLevel) {
        case RPC_C_AUTHN_LEVEL_DEFAULT:
            dprintf("     AuthenticationLevel      - default\n");
            break;
        case RPC_C_AUTHN_LEVEL_NONE:
            dprintf("     AuthenticationLevel      - none\n");
            break;
        case RPC_C_AUTHN_LEVEL_CONNECT:
            dprintf("     AuthenticationLevel      - connect\n");
            break;
        case RPC_C_AUTHN_LEVEL_CALL:
            dprintf("     AuthenticationLevel      - call\n");
            break;
        case RPC_C_AUTHN_LEVEL_PKT:
            dprintf("     AuthenticationLevel      - pkt\n");
            break;
        case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:
            dprintf("     AuthenticationLevel      - pkt integrity\n");
            break;
        case RPC_C_AUTHN_LEVEL_PKT_PRIVACY:
            dprintf("     AuthenticationLevel      - pkt privacy\n");
            break;
        default:
            dprintf("     AuthenticationLevel      - %ul\n", (ULONG)AuthenticationLevel);
            break;
    }

    ULONG64 AuthenticationService;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, AuthenticationService, AuthenticationService);

    switch ((ULONG)AuthenticationService) {
        case RPC_C_AUTHN_NONE:
            dprintf("     AuthenticationService    - none\n");
            break;
        case RPC_C_AUTHN_DCE_PRIVATE:
            dprintf("     AuthenticationService    - DCE private\n");
            break;
        case RPC_C_AUTHN_DCE_PUBLIC:
            dprintf("     AuthenticationService    - DCE public\n");
            break;
        case RPC_C_AUTHN_DEC_PUBLIC:
            dprintf("     AuthenticationService    - DEC public\n");
            break;
        case RPC_C_AUTHN_WINNT:
            dprintf("     AuthenticationService    - WINNT\n");
            break;
        case RPC_C_AUTHN_DEFAULT:
            dprintf("     AuthenticationService    - default\n");
            break;
        default:
            dprintf("     AuthenticationService    - %ul\n", (ULONG)AuthenticationService);
            break;
    }

    ULONG64 AuthIdentity;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, AuthIdentity, AuthIdentity);

    dprintf("     AuthIdentity             - %08x\n", (ULONG)AuthIdentity);

    ULONG64 AuthorizationService;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, AuthorizationService, AuthorizationService);

    switch ((ULONG)AuthorizationService) {
        case RPC_C_AUTHZ_NONE:
            dprintf("     AuthorizationService     - none\n");
            break;
        case RPC_C_AUTHZ_NAME:
            dprintf("     AuthorizationService     - name\n");
            break;
        case RPC_C_AUTHZ_DCE:
            dprintf("     AuthorizationService     - DCE\n");
            break;
        default:
            dprintf("     AuthorizationService     - %ul\n", (ULONG)AuthorizationService);
            break;
    }

    ULONG64 IdentityTracking;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, IdentityTracking, IdentityTracking);

    switch ((ULONG)IdentityTracking)
        {
        case RPC_C_QOS_IDENTITY_STATIC:
            dprintf("     IdentityTracking         - Static\n");
            break;
        case RPC_C_QOS_IDENTITY_DYNAMIC:
            dprintf("     IdentityTracking         - Dynamic\n");
            break;
        default:
            dprintf("     IdentityTracking         - %08x\n", (ULONG)IdentityTracking);
            break;
        }

    ULONG64 ImpersonationType;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, ImpersonationType, ImpersonationType);

    switch ((ULONG)ImpersonationType)
        {
        case RPC_C_IMP_LEVEL_ANONYMOUS:
            dprintf("     ImpersonationType        - Anonymous\n");
            break;
        case RPC_C_IMP_LEVEL_IDENTIFY:
            dprintf("     ImpersonationType        - Identify\n");
            break;
        case RPC_C_IMP_LEVEL_IMPERSONATE:
            dprintf("     ImpersonationType        - Impersonate\n");
            break;
        case RPC_C_IMP_LEVEL_DELEGATE:
            dprintf("     ImpersonationType        - Delegate\n");
            break;
        default:
            dprintf("     ImpersonationType        - %08x\n", (ULONG)ImpersonationType);
            break;
        }

    ULONG64 Capabilities;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, Capabilities, Capabilities);

    switch ((ULONG)Capabilities)
        {
        case RPC_C_QOS_CAPABILITIES_DEFAULT:
            dprintf("     Capabilities             - Default\n");
            break;
        case RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH:
            dprintf("     Capabilities             - Mutual Auth\n");
            break;
        default:
            dprintf("     Capabilities             - %08x\n", (ULONG)Capabilities);
            break;
        }

    ULONG64 ModifiedId, LowPart, HighPart;
    GET_ADDRESS_OF(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, ModifiedId, ModifiedId, tmp2);
    GET_MEMBER(ModifiedId, _LUID, RPCRT4!_LUID, LowPart, LowPart);
    GET_MEMBER(ModifiedId, _LUID, RPCRT4!_LUID, HighPart, HighPart);
    dprintf("     ModifiedId               - %08x, %08x\n", (ULONG)LowPart, (ULONG)HighPart);

    PRINT_MEMBER_WITH_LABEL(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, DefaultLogonId, "     DefaultLogonId          ", tmp1);
    PRINT_MEMBER_WITH_LABEL(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, Credentials, "     Credentials             ", tmp1);

    if (ServerPrincipalName) {
        delete[] ServerPrincipalName;
    }
}

void do_dict (
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 cDictSize;
    ULONG64 cDictSlots;
    GET_MEMBER(qwAddr, SIMPLE_DICT, RPCRT4!SIMPLE_DICT, cDictSize, cDictSize);
    GET_MEMBER(qwAddr, SIMPLE_DICT, RPCRT4!SIMPLE_DICT, cDictSlots, cDictSlots);

    if ((ULONG)cDictSize > (ULONG)cDictSlots)
        {
        dprintf("Bad dictionary\t\t- %I64p\n", qwAddr);
        return;
        }

    ULONG64 DictSlots;
    GET_MEMBER(qwAddr, SIMPLE_DICT, RPCRT4!SIMPLE_DICT, DictSlots, DictSlots);

    dprintf("\n");
    dprintf("Printing %d items in dictionary: %I64p with %d slots\n\n", (ULONG)cDictSize, qwAddr, (ULONG)cDictSlots);

    int i;

    for (i = 0; i < MIN((int)cDictSize, MAX_ITEMS_IN_DICTIONARY); i++) {
        ULONG64 DictSlot;

        if (!ReadPtrUnextend(DictSlots + i * AddressSize, &DictSlot)) {
            dprintf ("(%d): 0x%I64x\n", i, DictSlot);
        }
        else {
            dprintf ("Could not read dict entry at 0x%I64x\n", DictSlots + i * AddressSize);
	}
   
        dprintf("\n");
    }
}

void do_dict2 (
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 DictKeys;
    ULONG64 DictItems;
    GET_MEMBER(qwAddr, SIMPLE_DICT2, RPCRT4!SIMPLE_DICT2, DictKeys, DictKeys);
    GET_MEMBER(qwAddr, SIMPLE_DICT2, RPCRT4!SIMPLE_DICT2, DictItems, DictItems);

    ULONG64 cDictSlots;
    GET_MEMBER(qwAddr, SIMPLE_DICT2, RPCRT4!SIMPLE_DICT2, cDictSlots, cDictSlots);

    dprintf("\n");

    dprintf("Printing dictionary at %I64p with %d slots\n\n", qwAddr, (ULONG) cDictSlots);

    int i;

    for (i = 0; i < MIN((int)cDictSlots, MAX_ITEMS_IN_DICTIONARY); i++)
        {
        ULONG64 DictKey;

        if (!ReadPtrUnextend(DictKeys + i * AddressSize, &DictKey))
            {
            if (DictKey != 0)
                {
                ULONG64 DictItem;
                if (!ReadPtrUnextend(DictItems + i * AddressSize, &DictItem))
		    {
                    dprintf ("(Key: 0x%I64p): 0x%I64p\n", DictKey, DictItem);
                    dprintf("\n");
                    }
                }
            }
        }
}

void
do_queue (
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    int i;

    ULONG64 EndOfQueue;
    ULONG64 QueueSlots;
    GET_MEMBER(qwAddr, QUEUE, RPCRT4!QUEUE, EndOfQueue, EndOfQueue);
    GET_MEMBER(qwAddr, QUEUE, RPCRT4!QUEUE, QueueSlots, QueueSlots);

    dprintf("\n");
    dprintf("Printing %d items in queue at %I64p\n", (ULONG)EndOfQueue, qwAddr);

    dprintf("TAIL:\n");
    for (i = 0; i < (int)EndOfQueue; i++)
        {
        ULONG64 QueueSlot;
        if (!ReadPtrUnextend(QueueSlots + i * AddressSize, &QueueSlot))
            {
            ULONG64 Buffer;
            GET_MEMBER(QueueSlot, QUEUE_ITEM, RPCRT4!QUEUE_ITEM, Buffer, Buffer);

            dprintf ("(%d): %I64p\n", i, Buffer);
            dprintf("\n");
            }
	}
    dprintf("HEAD:\n");
}


void do_thread (
    ULONG64 Addr
    )
{
    ULONG64 RpcThread;
    ULONG64 tmp;
    ULONG offset;

    GET_MEMBER(Addr, TEB, TEB, ReservedForNtRpc, RpcThread);

    dprintf("RPC TLS at 0x%I64x\n\n", RpcThread);

    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, HandleToThread, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, SavedProcedure, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, SavedParameter, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, ActiveCall, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, Context, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, CancelTimeout, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, SecurityContext, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, ExtendedStatus, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, ThreadEEInfo, tmp);

    GET_OFFSET_OF(THREAD, RPCRT4!THREAD, ThreadEvent, &offset);
    dprintf("ThreadEvent at - 0x%I64x\n", RpcThread + offset);
 
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, Flags, tmp);

    GET_OFFSET_OF(THREAD, RPCRT4!THREAD, BufferCache, &offset);
    dprintf("buffer cache array at - 0x%I64x\n", RpcThread + offset);

    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, fAsync, tmp);
    
    dprintf("\n");
}

char *osf_ptype[]  =
{
    "rpc_request",
    "bad packet",
    "rpc_response",
    "rpc_fault",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "rpc_bind",
    "rpc_bind_ack",
    "rpc_bind_nak",
    "rpc_alter_context",
    "rpc_alter_context_resp",
    "rpc_auth_3",
    "rpc_shutdown",
    "rpc_cancel",
    "rpc_orphaned"
};

void do_copacket (
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 StubData;

    //
    // Dump the common header first
    //
    dprintf("\n");

    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, rpc_vers, tmp1);
    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, rpc_vers_minor, tmp1);

    ULONG64 PTYPE;
    GET_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, PTYPE, PTYPE);
    dprintf ("PTYPE - 0x%x, %s\n",
             (ULONG)PTYPE, osf_ptype[(ULONG)PTYPE]);

    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, pfc_flags, tmp1);
    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, drep, tmp1);
    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, frag_length, tmp1);
    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, auth_length, tmp1);
    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, call_id, tmp1);

    //
    // Dump the packet specific stuff
    //
    switch ((ULONG)PTYPE)
        {
        case rpc_request:

            PRINT_MEMBER(qwAddr, rpcconn_request, RPCRT4!rpcconn_request, alloc_hint, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_request, RPCRT4!rpcconn_request, p_cont_id, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_request, RPCRT4!rpcconn_request, opnum, tmp1);

            ULONG64 pfc_flags;
            GET_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, pfc_flags, pfc_flags);

            if ((ULONG)pfc_flags & PFC_OBJECT_UUID)
                {
                dprintf("UUID -\n");
                ULONG64 UUID = qwAddr;
                UUID += GET_TYPE_SIZE(rpcconn_common, RPCRT4!rpcconn_common);
                PrintUuid(UUID);
                dprintf("\n");

                StubData = qwAddr;
                StubData += GET_TYPE_SIZE(rpcconn_request, RPCRT4!rpcconn_request);
                StubData += GET_TYPE_SIZE(UUID, RPCRT4!UUID);
                dprintf ("Stub Data - 0x%I64x\n", StubData);
                }
            else
                {
                StubData = qwAddr;
                StubData += GET_TYPE_SIZE(rpcconn_request, RPCRT4!rpcconn_request);
                dprintf ("Stub Data - 0x%I64x\n", StubData);
                }
            break;

        case rpc_response:
            PRINT_MEMBER(qwAddr, rpcconn_response, RPCRT4!rpcconn_response, alloc_hint, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_response, RPCRT4!rpcconn_response, p_cont_id, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_response, RPCRT4!rpcconn_response, alert_count, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_response, RPCRT4!rpcconn_response, reserved, tmp1);

            StubData = qwAddr;
            StubData += GET_TYPE_SIZE(rpcconn_response, RPCRT4!rpcconn_response);

            dprintf ("Stub Data - 0x%I64x\n", StubData);
            break;

        case rpc_fault:
            PRINT_MEMBER(qwAddr, rpcconn_fault, RPCRT4!rpcconn_fault, alloc_hint, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_fault, RPCRT4!rpcconn_fault, p_cont_id, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_fault, RPCRT4!rpcconn_fault, alert_count, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_fault, RPCRT4!rpcconn_fault, reserved, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_fault, RPCRT4!rpcconn_fault, status, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_fault, RPCRT4!rpcconn_fault, reserved2, tmp1);
            break;

        case rpc_bind:
        case rpc_alter_context:
            PRINT_MEMBER(qwAddr, rpcconn_bind, RPCRT4!rpcconn_bind, max_xmit_frag, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_bind, RPCRT4!rpcconn_bind, max_recv_frag, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_bind, RPCRT4!rpcconn_bind, assoc_group_id, tmp1);
            break;

        case rpc_bind_ack:
            PRINT_MEMBER(qwAddr, rpcconn_bind_ack, RPCRT4!rpcconn_bind_ack, max_xmit_frag, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_bind_ack, RPCRT4!rpcconn_bind_ack, max_recv_frag, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_bind_ack, RPCRT4!rpcconn_bind_ack, assoc_group_id, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_bind_ack, RPCRT4!rpcconn_bind_ack, sec_addr_length, tmp1);
            break;

        case rpc_bind_nak:
            PRINT_MEMBER(qwAddr, rpcconn_bind_nak, RPCRT4!rpcconn_bind_nak, provider_reject_reason, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_bind_nak, RPCRT4!rpcconn_bind_nak, versions, tmp1);
            break;

        case rpc_alter_context_resp:
            PRINT_MEMBER(qwAddr, rpcconn_alter_context_resp, RPCRT4!rpcconn_alter_context_resp, max_xmit_frag, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_alter_context_resp, RPCRT4!rpcconn_alter_context_resp, max_recv_frag, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_alter_context_resp, RPCRT4!rpcconn_alter_context_resp, assoc_group_id, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_alter_context_resp, RPCRT4!rpcconn_alter_context_resp, sec_addr_length, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_alter_context_resp, RPCRT4!rpcconn_alter_context_resp, pad, tmp1);
            break;

        case rpc_auth_3:
        case rpc_shutdown:
        case rpc_cancel:
        case rpc_orphaned:
            break;

        default:
            dprintf ("Bad Packet\n");
            break;
        }

    //
    // Dump the security trailer
    //
    ULONG64 auth_length;
    ULONG64 frag_length;
    GET_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, auth_length, auth_length);
    GET_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, frag_length, frag_length);

    if ((ULONG)auth_length)
        {
        ULONG64 SecurityTrailer = qwAddr;
        SecurityTrailer += frag_length-auth_length-GET_TYPE_SIZE(sec_trailer, RPCRT4!sec_trailer);
        dprintf("\nSecurity trailer: 0x%I64x\n", SecurityTrailer);

        PRINT_MEMBER(SecurityTrailer, sec_trailer, RPCRT4!sec_trailer, auth_type, tmp1);
        PRINT_MEMBER(SecurityTrailer, sec_trailer, RPCRT4!sec_trailer, auth_level, tmp1);
        PRINT_MEMBER(SecurityTrailer, sec_trailer, RPCRT4!sec_trailer, auth_pad_length, tmp1);
        PRINT_MEMBER(SecurityTrailer, sec_trailer, RPCRT4!sec_trailer, auth_reserved, tmp1);
        PRINT_MEMBER(SecurityTrailer, sec_trailer, RPCRT4!sec_trailer, auth_context_id, tmp1);
        dprintf ("trailer - 0x%I64x\n", SecurityTrailer+1);
        }
}

char *lpc_ptype[]  =
{
"LRPC_MSG_BIND",
"LRPC_MSG_REQUEST",
"LRPC_MSG_RESPONSE",
"LRPC_MSG_CALLBACK",
"LRPC_MSG_FAULT",
"LRPC_MSG_CLOSE",
"LRPC_MSG_ACK",
"LRPC_BIND_ACK",
"LRPC_MSG_COPY",
"LRPC_MSG_PUSH",
"LRPC_MSG_CANCEL",
"LRPC_MSG_BIND_BACK",
"LRPC_ASYNC_REQUEST",
"LRPC_PARTIAL_REQUEST",
"LRPC_CLIENT_SEND_MORE",
"LRPC_SERVER_SEND_MORE",
"LRPC_MSG_FAULT2"
};

VOID
do_lpcpacket(
    ULONG64 qwAddr
    )
{
    if (fUseTypeInfo) {
        ULONG64 LpcHeader;
        ULONG64 RpcHeader;
        ULONG64 Buffer;
        ULONG64 tmp1;
        ULONG tmp2;

        GET_ADDRESS_OF(qwAddr, LRPC_RPC_MESSAGE, RPCRT4!LRPC_RPC_MESSAGE, LpcHeader, LpcHeader, tmp2);
        GET_ADDRESS_OF(qwAddr, LRPC_RPC_MESSAGE, RPCRT4!LRPC_RPC_MESSAGE, RpcHeader, RpcHeader, tmp2);

        dprintf("\n");

        //
        // dump the LPC header
        //
        PRINT_ADDRESS_OF_WITH_LABEL(LpcHeader, _PORT_MESSAGE, RPCRT4!_PORT_MESSAGE, u1, "&u1\t\t\t", tmp2);
        PRINT_ADDRESS_OF_WITH_LABEL(LpcHeader, _PORT_MESSAGE, RPCRT4!_PORT_MESSAGE, u2, "&u2\t\t\t", tmp2);
        PRINT_ADDRESS_OF_WITH_LABEL(LpcHeader, _PORT_MESSAGE, RPCRT4!_PORT_MESSAGE, ClientId, "&CLIENT_ID\t\t", tmp2);
        PRINT_MEMBER_WITH_LABEL(LpcHeader, _PORT_MESSAGE, RPCRT4!_PORT_MESSAGE, MessageId, "MessageId\t\t", tmp1);
        PRINT_MEMBER_WITH_LABEL(LpcHeader, _PORT_MESSAGE, RPCRT4!_PORT_MESSAGE, CallbackId, "CallbackId\t\t", tmp1);

        //
        // dump the LRPC header
        //
        ULONG64 MessageType;
        GET_MEMBER(RpcHeader, _LRPC_RPC_HEADER, RPCRT4!_LRPC_RPC_HEADER, MessageType, MessageType);
        dprintf("MessageType\t\t - %s\n", lpc_ptype[(long)MessageType]);
        PRINT_MEMBER_WITH_LABEL(RpcHeader, _LRPC_RPC_HEADER, RPCRT4!_LRPC_RPC_HEADER, PresentContext, "PresentationContext\t", tmp1);
        PRINT_MEMBER_WITH_LABEL(RpcHeader, _LRPC_RPC_HEADER, RPCRT4!_LRPC_RPC_HEADER, Flags, "Flags\t\t\t", tmp1);
        PRINT_MEMBER_WITH_LABEL(RpcHeader, _LRPC_RPC_HEADER, RPCRT4!_LRPC_RPC_HEADER, ProcedureNumber, "ProcedureNumber\t\t", tmp1);
        PRINT_MEMBER_WITH_LABEL(RpcHeader, _LRPC_RPC_HEADER, RPCRT4!_LRPC_RPC_HEADER, CallId, "CallId\t\t\t", tmp1);

        ULONG64 ObjectUuid;
        GET_ADDRESS_OF(RpcHeader, _LRPC_RPC_HEADER, RPCRT4!_LRPC_RPC_HEADER, ObjectUuid, ObjectUuid, tmp2);
        dprintf("ObjectUuid\t\t - ");
        PrintUuid(ObjectUuid);

        dprintf("\n\n");
    }
    else {
        BOOL b;
        char block[sizeof(LRPC_RPC_MESSAGE)];
        LRPC_RPC_MESSAGE *m = (LRPC_RPC_MESSAGE *)block;

        b = GetData(qwAddr, block, sizeof(LRPC_RPC_MESSAGE));
        if ( !b ) {
          dprintf("couldn't read address %p\n", qwAddr);
          return;
        }

        dprintf("\n");
        //
        // dump the LPC header
        //
        dprintf("DataLength\t\t- 0x%x\n", (long) m->LpcHeader.u1.s1.DataLength);
        dprintf("TotalLength\t\t- 0x%x\n", (long) m->LpcHeader.u1.s1.TotalLength);
        dprintf("Type\t\t\t- 0x%x\n", (long) m->LpcHeader.u2.s2.Type);
        dprintf("DataInfoOffset\t\t- 0x%x\n", (long) m->LpcHeader.u2.s2.DataInfoOffset);
        dprintf("CLIENT_ID: \t\t- Process(0x%x), Thread(0x%x)\n",
                m->LpcHeader.ClientId.UniqueProcess, m->LpcHeader.ClientId.UniqueThread);
        dprintf("MessageId\t\t- 0x%x\n", m->LpcHeader.MessageId);
        dprintf("CallbackId\t\t- 0x%x\n", m->LpcHeader.CallbackId);

        //
        // dump the LRPC header
        //
        dprintf("MessageType\t\t- %s\n", lpc_ptype[(long) m->RpcHeader.MessageType]);
        dprintf("PresentationContext\t- 0x%x\n", (long) m->RpcHeader.PresentContext);
        dprintf("Flags\t\t\t- 0x%x\n", (unsigned long) m->RpcHeader.Flags);
        dprintf("ProcedureNumber\t\t- 0x%x\n", (long) m->RpcHeader.ProcedureNumber);
        dprintf("CallId\t\t\t- 0x%x\n", (long) m->RpcHeader.CallId);
        dprintf("ObjectUuid\t\t- ");
        PrintUuidLocal((UUID *) &(m->RpcHeader.ObjectUuid));

        dprintf("\nStubData\t\t- 0x%x\n", m+1);
        dprintf("\n");
    }
}

VOID
do_bh(
    ULONG64 qwAddr
    )
{
    RPC_CHAR *EntryName;

    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 EntryNameAddr;
    ULONG64 ObjectUuidAddr;

    GET_ADDRESS_OF(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, EntryName, EntryNameAddr, tmp2);
    GET_ADDRESS_OF(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, ObjectUuid, ObjectUuidAddr, tmp2);

    dprintf("\n");

    PRINT_MEMBER(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, Timeout, tmp1);

    dprintf("ObjectUuid\t\t- ");
    PrintUuid(ObjectUuidAddr); dprintf("\n");

    PRINT_MEMBER(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, NullObjectUuidFlag, tmp1);
    PRINT_MEMBER(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, EntryNameSyntax, tmp1);

    EntryName = ReadProcessRpcChar(EntryNameAddr);
    if (EntryName) {
        dprintf("EntryName\t\t- %ws (Address: 0x%x)\n", EntryName ? EntryName : L"(null)", EntryNameAddr);
        delete EntryName;
    }

    PRINT_MEMBER(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, EpLookupHandle, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, BindingMutex, "&BindingMutex(MUTEX)", tmp2);
    PRINT_MEMBER(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, pvTransportOptions, tmp1);
    PRINT_ADDRESS_OF(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, ClientAuthInfo, tmp2);

    do_authinfo(qwAddr+tmp2);
}

VOID
do_osfbh(
    ULONG64 qwAddr
    )
{
    BOOL b;
 
    ULONG64 tmp1;
    ULONG tmp2;

    do_bh(qwAddr);

    PRINT_MEMBER(qwAddr, OSF_BINDING_HANDLE, RPCRT4!OSF_BINDING_HANDLE, Association, tmp1);
    PRINT_MEMBER(qwAddr, OSF_BINDING_HANDLE, RPCRT4!OSF_BINDING_HANDLE, DceBinding, tmp1);

    do_dcebinding(tmp1);

    PRINT_MEMBER(qwAddr, OSF_BINDING_HANDLE, RPCRT4!OSF_BINDING_HANDLE, TransInfo, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_BINDING_HANDLE, RPCRT4!OSF_BINDING_HANDLE, RecursiveCalls, "&RecursiveCalls(OSF_ACTIVE_ENTRY_DICT)", tmp2);
    PRINT_MEMBER(qwAddr, OSF_BINDING_HANDLE, RPCRT4!OSF_BINDING_HANDLE, ReferenceCount, tmp1);
    PRINT_MEMBER(qwAddr, OSF_BINDING_HANDLE, RPCRT4!OSF_BINDING_HANDLE, pToken, tmp1);

    dprintf("\n");
}

VOID
do_osfca(
    ULONG64 qwAddr
    )
{
    BOOL b;
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, DceBinding, "DceBinding(DCE_BINDING)", tmp1);
    do_dcebinding(tmp1);

    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, BindHandleCount, tmp1);
    PRINT_ADDRESS_OF(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, Bindings, tmp2);
    PRINT_ADDRESS_OF(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, ActiveConnections, tmp2);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, AssocGroupId, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, TransInfo, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, SecondaryEndpoint, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, Key, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, OpenConnectionCount, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, CallIdCounter, tmp1);
    PRINT_ADDRESS_OF(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, AssociationMutex, tmp2);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, AssociationValid, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, FailureCount, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, fMultiplex, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, SavedDrep, tmp1);

    dprintf("\n");
}

VOID
do_dcebinding(
    ULONG64 qwAddr
    )
{
    RPC_STATUS RpcStatus;
    BOOL b;

    ULONG tmp2;

    ULONG64 RpcProtocolSequenceAddr;
    ULONG64 NetworkAddressAddr;
    ULONG64 EndpointAddr;
    ULONG64 OptionsAddr;
    ULONG64 ObjectUuidAddr;

    RPC_CHAR *RpcProtocolSequence;
    RPC_CHAR *NetworkAddress;
    RPC_CHAR *Endpoint;
    RPC_CHAR *Options;

    GET_MEMBER(qwAddr, DCE_BINDING, RPCRT4!DCE_BINDING, RpcProtocolSequence, RpcProtocolSequenceAddr);
    GET_MEMBER(qwAddr, DCE_BINDING, RPCRT4!DCE_BINDING, NetworkAddress, NetworkAddressAddr);
    GET_MEMBER(qwAddr, DCE_BINDING, RPCRT4!DCE_BINDING, Endpoint, EndpointAddr);
    GET_MEMBER(qwAddr, DCE_BINDING, RPCRT4!DCE_BINDING, Options, OptionsAddr);
    GET_ADDRESS_OF(qwAddr, DCE_BINDING, RPCRT4!DCE_BINDING, ObjectUuid, ObjectUuidAddr, tmp2);

    dprintf("\tObjectUuid:\t");
    PrintUuid(ObjectUuidAddr); dprintf("\n");

    RpcProtocolSequence = ReadProcessRpcChar( RpcProtocolSequenceAddr);
    if (RpcProtocolSequence) {
        dprintf("\tprotseq: \t\"%ws\"\t(Address: %p)\n", RpcProtocolSequence, RpcProtocolSequenceAddr);
        delete RpcProtocolSequence;
    }

    NetworkAddress = ReadProcessRpcChar( NetworkAddressAddr);
    if (NetworkAddress) {
        dprintf("\tNetworkAddress:\t\"%ws\"\t(Address: %p)\n", NetworkAddress, NetworkAddressAddr);
        delete NetworkAddress;
    }

    Endpoint = ReadProcessRpcChar( EndpointAddr);
    if (Endpoint) {
        dprintf("\tEndpoint:\t\"%ws\" \t(Address: %p)\n", Endpoint, EndpointAddr);
        delete Endpoint;
    }

    Options = ReadProcessRpcChar( OptionsAddr);
    if (Options) {
        dprintf("\tOptions:\t\"%ws\" \t(Address: %p)\n", Options, OptionsAddr);
        delete Options;
    }

    dprintf("\n");
}

VOID
do_osfcconn(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, Association, "pAssociation(OSF_CASSOCIATION)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, CurrentCall, "CurrentCall (OSF_CCALL)\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ConnectionKey, "ConnectionKey\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, State, "State\t\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, MaxFrag, "MaxFrag\t\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ThreadId, "ThreadId\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, CachedCCall, "CachedCCall\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, CachedCCallAvailable, "CachedCCallAvailable\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, MaxSavedHeaderSize, "MaxSavedHeaderSize\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, SavedHeaderSize, "SavedHeaderSize\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, SavedHeader, "SavedHeader\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, AdditionalLegNeeded, "AdditionalLegNeeded\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, LastTimeUsed, "LastTimeUsed\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, TokenLength, "TokenLength\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, AdditionalSpaceForSecurity, "AdditionalSpaceForSecurity\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, fIdle, "fIdle\t\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, fExclusive, "fExclusive\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, fConnectionAborted, "fConnectionAborted\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, RefCount, "RefCount\t\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, Bindings, "&Bindings(BITSET)\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, CallQueue, "&CallQueue\t\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ConnMutex, "&ConnMutex\t\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ActiveCalls, "&ActiveCalls\t\t\t\t", tmp2);

    ULONG64 ClientSecurityContext;
    GET_ADDRESS_OF(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ClientSecurityContext, ClientSecurityContext, tmp2);
    dprintf("&ClientSecurityContext(CSECURITY_CONTEXT)- 0x%I64x\n", ClientSecurityContext);
    do_securitycontext(ClientSecurityContext);


    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ClientInfo, "ClientInfo (RPC_CONNECTION_TRANSPORT)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ComTimeout, "ComTimeout\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, u, "ConnSendContext\t\t\t\t", tmp1);


    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, DceSecurityInfo, "&DceSecurityInfo(DCE_SECURITY_INFO)\t", tmp2);

    ULONG64 DceSecurityInfo;
    GET_ADDRESS_OF(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, DceSecurityInfo, DceSecurityInfo, tmp2);
    PRINT_MEMBER_WITH_LABEL(DceSecurityInfo, _DCE_SECURITY_INFO, RPCRT4!_DCE_SECURITY_INFO, SendSequenceNumber, "     SendSequenceNumber\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(DceSecurityInfo, _DCE_SECURITY_INFO, RPCRT4!_DCE_SECURITY_INFO, ReceiveSequenceNumber, "     ReceiveSequenceNumber\t", tmp1);

    ULONG64 AssociationUuid;
    GET_ADDRESS_OF(DceSecurityInfo, _DCE_SECURITY_INFO, RPCRT4!_DCE_SECURITY_INFO, AssociationUuid, AssociationUuid, tmp2);
    dprintf("     AssociationUuid\t\t - ");
    PrintUuid(AssociationUuid);
    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, BufferToFree, "BufferToFree\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ConnectionReady, "ConnectionReady\t\t\t", tmp1);

    dprintf("\n");

    ULONG64 TransConnection = qwAddr;
    TransConnection += GET_TYPE_SIZE(OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION);

    dprintf("TransConnection\t\t\t - 0x%I64x\n", TransConnection);

    do_trans(TransConnection);
}

struct CallStateMap {
    OSF_CCALL_STATE State;
    char *StateString;
};

struct CallStateMap CCall_States[] =
{
    NeedOpenAndBind, "NeedOpenAndBind",
    NeedAlterContext, "NeedAlterContext",
    WaitingForAlterContext, "WaitingForAlterContext",
    SendingFirstBuffer, "SendingFirstBuffer",
    SendingMoreData, "SendingMoreData",
    WaitingForReply, "WaitingForReply",
    InCallbackRequest, "InCallbackRequest",
    InCallbackReply, "InCallbackReply",
    Receiving, "Receiving",
    Aborted, "Aborted",
    Complete, "Complete",
};

char *
GetCallState (
    OSF_CCALL_STATE State
    )
{
    int i;

    for (i = 0; i < sizeof(CCall_States)/sizeof(CallStateMap); i++)
        {
        if (State == CCall_States[i].State)
            {
            return CCall_States[i].StateString;
            }
        }

    return "Unknown State";
}

VOID
do_osfccall(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, AsyncStatus, "AsyncStatus\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CachedAPCInfo, "pCachedAPCInfo\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CachedAPCInfoAvailable, "CachedAPCInfoAvailable\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, pAsync, "pAsync\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CallingThread, "CallingThread\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, NotificationIssued, "NotificationIssued\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, Connection, "Connection\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, BindingHandle, "BindingHandle\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, Bindings, "Binding\t\t\t", tmp1);

    ULONG64 CurrentState;
    GET_MEMBER(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CurrentState, CurrentState);
    dprintf("CurrentState\t\t - 0x%x, %s\n",
            (ULONG)CurrentState, GetCallState((OSF_CCALL_STATE)CurrentState));

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CurrentBuffer, "CurrentBuffer\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CurrentOffset, "CurrentOffset\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CurrentBufferLength, "CurrentBufferLength\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CallId, "CallId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, RcvBufferLength, "RcvBufferLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, FirstSend, "FirstSend\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, DispatchTableCallback, "DispatchTableCallback\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, MaximumFragmentLength, "MaximumFragmentLength\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, MaxSecuritySize, "MaxSecuritySize\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, MaxDataLength, "MaxDataLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, ReservedForSecurity, "ReservedForSecurity\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, SecBufferLength, "SecBufferLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, HeaderSize, "HeaderSize\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, SavedHeaderSize, "SavedHeaderSize\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, SavedHeader, "SavedHeader\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, LastBuffer, "LastBuffer\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, ProcNum, "ProcNum\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, SyncEvent, "SyncEvent\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, ActualBufferLength, "ActualBufferLength\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, NeededLength, "NeededLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CallSendContext, "CallSendContext\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, RefCount, "RefCount\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, RecursiveCallsKey, "RecursiveCallsKeyF\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CallStack, "CallStack\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, fCallCancelled, "fCallCancelled\t\t", tmp1);

    ULONG64 CancelState;
    GET_MEMBER(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CancelState, CancelState);

    switch ((ULONG)CancelState)
        {
        case CANCEL_NOTREGISTERED:
            dprintf("fEnableCancels\t\t - CANCEL_NOTREGISTERED\n");
            break;

        case CANCEL_INFINITE:
            dprintf("fEnableCancels\t\t - CANCEL_INFINITE\n");
            break;

        case CANCEL_NOTINFINITE:
            dprintf("fEnableCancels\t\t - CANCEL_NOTINFINITE\n");
            break;
        }

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CallMutex, "&CallMutex\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, BufferQueue, "&BufferQueue\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, InReply, "InReply\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, fChoked, "fChoked\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, fPeerChoked, "fPeerChoked\t\t", tmp1);

    dprintf("\n");
}

VOID
do_rpcaddr(
    ULONG64 qwAddr
    )
{
    RPC_CHAR *Endpoint;
    RPC_CHAR *RpcProtocolSequence;

    ULONG64 EndpointAddr;
    ULONG64 RpcProtocolSequenceAddr;

    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    GET_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, Endpoint, EndpointAddr);
    GET_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, RpcProtocolSequence, RpcProtocolSequenceAddr);

    Endpoint = ReadProcessRpcChar(EndpointAddr);
    if (Endpoint != NULL) {
        dprintf("Endpoint - \"%ws\"\n", Endpoint);
        delete Endpoint;
    }

    RpcProtocolSequence = ReadProcessRpcChar(RpcProtocolSequenceAddr);
    if (RpcProtocolSequence != NULL) {
        dprintf("RpcProtocolSequence - \"%ws\"\n", RpcProtocolSequence);
        delete RpcProtocolSequence;
    }

    PRINT_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, StaticEndpointFlag, tmp1);
    PRINT_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, ActiveCallCount, tmp1);

    PRINT_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, EndpointFlags, tmp1);
    PRINT_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, NICFlags, tmp1);

    PRINT_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, Server, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, AddressMutex, "AddressMutex at", tmp2);
    PRINT_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, DictKey, tmp1);

    delete Endpoint;
    delete RpcProtocolSequence;
}

VOID
do_osfaddr(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 TransAddr = qwAddr;

    do_rpcaddr(qwAddr);

    dprintf("\n");

    PRINT_ADDRESS_OF(qwAddr, OSF_ADDRESS, RPCRT4!OSF_ADDRESS, Associations, tmp2);
    PRINT_MEMBER(qwAddr, OSF_ADDRESS, RPCRT4!OSF_ADDRESS, SetupAddressOccurred, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ADDRESS, RPCRT4!OSF_ADDRESS, TransInfo, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ADDRESS, RPCRT4!OSF_ADDRESS, ServerInfo, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ADDRESS, RPCRT4!OSF_ADDRESS, ServerListeningFlag, tmp1);

    TransAddr += GET_TYPE_SIZE(OSF_ADDRESS, RPCRT4!OSF_ADDRESS);

    dprintf("\n");

    dprintf("TransAddr 0x%I64x\n", TransAddr);

    do_trans(TransAddr);
}

VOID
do_osfsconn(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    ULONG64 AuthInfo;
    GET_ADDRESS_OF(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, AuthInfo, AuthInfo, tmp2);
    dprintf("&AuthInfo(CLIENT_AUTH_INFO)\t - 0x%p\n", AuthInfo);
    do_authinfo(AuthInfo );

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, Association, "Association(OSF_ASSOCIATION)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, Address, "Address(OSF_ADDRESS)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, MaxFrag, "MaxFrag\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, DataRep, "DataRep\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, AuthContextId, "AuthContextId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, SecurityContextAltered, "SecurityContextAltered\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, RpcSecurityBeingUsed, "RpcSecurityBeingUsed\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, CurrentSecurityContext, "pCurrentSecurityContext(SSECURITY_CONTEXT)", tmp1);

    do_authinfo(tmp1);

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, SecurityContextDict, "&SecurityContextDict(SSECURITY_CONTEXT_DICT)", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, AdditionalSpaceForSecurity, "AdditionalSpaceForSecurity\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, SavedHeaderSize, "SavedHeaderSize\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, SavedHeader, "pSavedHeader(VOID)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, CurrentCallId, "CurrentCallId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, CachedSCallAvailable, "CachedSCallAvailable\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, AuthContinueNeeded, "AuthContinueNeeded\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, InitSecurityInfo, "&InitSecurityInfo\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, CallDict, "&CallDict\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, Bindings, "&Bindings(OSF_SBINDING_DICT)\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, ConnMutex, "&ConnMutex\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, CachedSCall, "CachedSCall\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, ServerInfo, "ServerInfo\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, ConnectionClosedFlag, "ConnectionClosedFlag\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, DceSecurityInfo, "&DceSecurityInfo\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, fExclusive, "fExclusive\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, fDontFlush, "fDontFlush\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, fFirstCall, "fFirstCall\t\t\t", tmp1);

    dprintf("\n");

    ULONG64 TransConnection = qwAddr;
    TransConnection += GET_TYPE_SIZE(OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION);

    dprintf("TransConnection\t\t\t - 0x%I64x\n", TransConnection);

    do_trans(TransConnection);
}

char *SCall_States[] =
{
    "NewRequest",
    "CallCancelled",
    "CallAborted",
    "CallCompleted",
    "ReceivedCallback",
    "ReceivedCallbackReply",
    "ReceivedFault"
};

VOID
do_osfscall(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, AsyncStatus, "AsyncStatus\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CachedAPCInfo, "pCachedAPCInfo\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CachedAPCInfoAvailable, "CachedAPCInfoAvailable\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, pAsync, "pAsync\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CallingThread, "CallingThread\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, NotificationIssued, "NotificationIssued\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CurrentBinding, "CurrentBinding\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, Connection, "Connection\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, Address, "Address\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CallId, "CallId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CallStack, "CallStack\t\t", tmp1);

    ULONG64 ObjectUuid;
    GET_ADDRESS_OF(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, ObjectUuid, ObjectUuid, tmp2);
    dprintf("ObjectUuid\t\t - ");
    PrintUuid(ObjectUuid); dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, ObjectUuidSpecified, "ObjectUuidSpecified\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CurrentBuffer, "CurrentBuffer\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CurrentBufferLength, "CurrentBufferLength\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CurrentOffset, "CurrentOffset\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, FirstFrag, "FirstFrag\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, FirstSend, "FirstSend\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, fPipeCall, "fPipeCall\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, fCallDispatched, "fCallDispatched\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, DispatchBuffer, "DispatchBuffer\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, LastBuffer, "LastBuffer\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, SendContext, "SendContext\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, DispatchBufferOffset, "DispatchBufferOffset\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, ProcNum, "ProcNum\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, AllocHint, "AllocHint\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, SavedHeaderSize, "SavedHeaderSize\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, SavedHeader, "SavedHeader\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, RcvBufferLength, "RcvBufferLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, NeededLength, "NeededLength\t\t", tmp1);

    ULONG64 CurrentState;
    GET_MEMBER(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CurrentState, CurrentState);
    dprintf("CurrentState\t\t - 0x%x, %s\n", (ULONG)CurrentState, SCall_States[(ULONG)CurrentState]);

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CallMutex, "&CallMutex\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, SyncEvent, "&SyncEvent\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, BufferQueue, "&BufferQueue\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, Thread, "Thread\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CallOrphaned, "CallOrphaned\t\t", tmp1);

    ULONG64 RefCount;
    GET_MEMBER(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, RefCount, RefCount);
    dprintf("RefCount\t\t - 0x%x\n", (ULONG)RefCount);

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, MaxSecuritySize, "MaxSecuritySize\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, FirstCallRpcMessage, "&FirstCallRpcMessage\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, FirstCallRuntimeInfo, "&FirstCallRuntimeInfo\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, MaximumFragmentLength, "MaximumFragmentLength\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, ActualBufferLength, "ActualBufferLength\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, fChoked, "fChoked\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, fPeerChoked, "fPeerChoked\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, DispatchFlags, "DispatchFlags\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, fSecurityFailure, "fSecurityFailure\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CancelPending, "CancelPending\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, fChoked, "fChoked\t\t\t", tmp1);

    dprintf("\n");
}

VOID
do_osfsa(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, CtxCollection, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, AssociationID, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, ConnectionCount, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, AssociationGroupId, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, AssociationDictKey, tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, Address, "pAddress(OSF_ADDRESS)", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, ClientProcess, "&ClientProcess(RPC_CLIENT_PROCESS_IDENTIFIER)", tmp2);

    dprintf("\n");
}


DECLARE_API( rpcsvr )
{
    ULONG64 qwAddr;
    BOOL fArgSpecified = FALSE;
    ULONG64 ServerAddress;

    LPSTR lpArgumentString = (LPSTR)args;

    if (0 == strtok(lpArgumentString))
        {
        lpArgumentString = "rpcrt4!GlobalRpcServer";
        fArgSpecified = TRUE;
        }

    qwAddr = GetExpression(lpArgumentString);

    if ( !qwAddr )
        {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
        }

    if (fArgSpecified)
        {
        if (ReadPtrUnextend(qwAddr, &ServerAddress))
            {
            dprintf("couldn't read memory at address 0x%I64x\n", qwAddr);
            return;
            }
        }
    else
        ServerAddress = qwAddr;

    do_rpcsvr(ServerAddress);
}


VOID
do_rpcsvr(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp0;
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, pRpcForwardFunction, "pRpcForwardFunction(RPC_FORWARD_FUNCTION)", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, RpcInterfaceDictionary, "&RpcInterfaceDictionary(RPC_SIMPLE_DICT)", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, ServerMutex, "&ServerMutex(MUTEX)", tmp2);

    GET_ADDRESS_OF(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, AvailableCallCount, tmp1, tmp2);
    PRINT_MEMBER_WITH_LABEL(tmp1, INTERLOCKED_INTEGER, RPCRT4!INTERLOCKED_INTEGER, Integer, "AvailableCallCount", tmp0);

    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, ServerListeningFlag, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, RpcAddressDictionary, "&RpcAddressDictionary(RPC_SIMPLE_DICT)", tmp2);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, ListeningThreadFlag, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, StopListeningEvent, "&StopListeningEvent(EVENT)", tmp2);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, MaximumConcurrentCalls, tmp1);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, MinimumCallThreads, tmp1);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, IncomingRpcCount, tmp1);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, OutgoingRpcCount, tmp1);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, ReceivedPacketCount, tmp1);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, SentPacketCount, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, AuthenticationDictionary, "&AuthenticationDictionary(RPC_SIMPLE_DICT)", tmp2);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, WaitingThreadFlag, tmp1);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, ThreadCache, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, ThreadCacheMutex, "&ThreadCacheMutex(MUTEX)", tmp2);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, fAccountForMaxCalls, tmp1);

    dprintf("\n");
}

struct SizeTable {
    int Size;
    int Count;
};

struct SizeTable *Stats = NULL;
int MaxSize = 1048*10;
int CurrentSize = 0;

void
AddToStats (
    int Size
    )
{
    int i;

    for (i = 0; i < CurrentSize; i++)
        {
        if (Stats[i].Size == Size)
            {
            Stats[i].Count++;
            return;
            }
        }

    Stats[CurrentSize].Size = Size;
    Stats[CurrentSize].Count = 1;
    CurrentSize++;
}

int __cdecl compare( const void *arg1, const void *arg2 )
{
   return  ((struct SizeTable *) arg2)->Count - ((struct SizeTable *) arg1)->Count;
}

void
PrintStats (
    )
{
    int i;
    int Total = 0;

    qsort(&Stats[0], CurrentSize, sizeof(SizeTable), compare);

    dprintf("\n\nSummary:\n");
    for (i = 0; i < CurrentSize; i++)
        {
        dprintf("Size: %08x Count: %d\n",
                Stats[i].Size,
                Stats[i].Count
                );
        Total += Stats[i].Count;
        }

    dprintf("Total Count: %d\n", Total);
}

VOID
do_rpcmem(
    ULONG64 qwAddr,
    long Count,
    long Verbose,
    BOOL Summary,
    long Size
    )
{
    BOOL b;
    BOOL forwards = TRUE;
    BOOL doAll    = FALSE;
    DWORD t;

    ULONG64 tmp1;
    ULONG tmp2;

    unsigned Data[16];

    unsigned char RearGuardBlock[4];

#if DBG
    if (Count < 0) {
        forwards = FALSE;
    }
    else
    if (Count == 0) {
        doAll = TRUE;
    }

    if (Stats == NULL)
        {
        Stats = (struct SizeTable *) RpcpFarAllocate(MaxSize * sizeof(struct SizeTable));
        if (Stats == NULL)
            {
            return;
            }
        }

    RpcpMemorySet(Stats, 0, MaxSize);

    dprintf("\n");

    do
        {
        if ((CheckControlC)())
            {
            return;
            }

        ULONG64 size;
        GET_MEMBER(qwAddr, RPC_MEMORY_BLOCK, RPCRT4!RPC_MEMORY_BLOCK, size, size);

        AddToStats((int)size);

        if ((Size == 0 || Size == (long) size) && !Summary)
            {
            ULONG64 rearguard;
            GET_ADDRESS_OF(qwAddr, RPC_MEMORY_BLOCK, RPCRT4!RPC_MEMORY_BLOCK, rearguard, rearguard, tmp2);

            dprintf("-------- size (%08x) block: 0x%I64x contains: %s",
                (ULONG)size,
                qwAddr,
                SymbolAtAddressNoOffset(rearguard)
                );

            if (Verbose)
                {
                b = GetData(rearguard,
                        Data,
                        min((ULONG)size, sizeof(Data)));
                if ( !b )
                    {
                    dprintf("can't read block data at 0x%I64x\n", rearguard);
                    return;
                    }

                for (t = 0; t < min(((ULONG)size)/4, sizeof(Data)/4); t++)
                    {
                    if (t % 4 == 0)
                        {
                        dprintf("\n%I64p  ",
                                rearguard + t*4);
                        }
                    dprintf("%08x ", Data[t]);
                    }
                }
            dprintf("\n");

            }

        ULONG64 frontguardAddr;
        ULONG64 rearguardAddr;
        GET_ADDRESS_OF(qwAddr, RPC_MEMORY_BLOCK, RPCRT4!RPC_MEMORY_BLOCK, frontguard, frontguardAddr, tmp2);
        GET_ADDRESS_OF(qwAddr+size, RPC_MEMORY_BLOCK, RPCRT4!RPC_MEMORY_BLOCK, rearguard, rearguardAddr, tmp2);
        unsigned char frontguardVal[4];
        unsigned char rearguardVal[4];
        GetData(frontguardAddr, frontguardVal, sizeof(frontguardVal));
        GetData(rearguardAddr, rearguardVal, sizeof(rearguardVal));

        if ( (frontguardVal[0] != RPC_GUARD) ||
             (frontguardVal[1] != RPC_GUARD) ||
             (frontguardVal[2] != RPC_GUARD) ||
             (frontguardVal[3] != RPC_GUARD) )
            {
            dprintf("     RPC: BAD FRONTGUARD %x-%x-%x-%x\n", frontguardVal[0], frontguardVal[1], frontguardVal[2], frontguardVal[3]);
            }

        if ( (rearguardVal[0] != RPC_GUARD) ||
             (rearguardVal[1] != RPC_GUARD) ||
             (rearguardVal[2] != RPC_GUARD) ||
             (rearguardVal[3] != RPC_GUARD) )
            {
            dprintf("     RPC: BAD REARGUARD %x-%x-%x-%x\n", rearguardVal[0], rearguardVal[1], rearguardVal[2], rearguardVal[3]);
            }

        ULONG64 next;
        ULONG64 previous;
        GET_MEMBER(qwAddr, RPC_MEMORY_BLOCK, RPCRT4!RPC_MEMORY_BLOCK, next, next);
        GET_MEMBER(qwAddr, RPC_MEMORY_BLOCK, RPCRT4!RPC_MEMORY_BLOCK, previous, previous);

        if (forwards == TRUE)
            {
            qwAddr =  next;
            Count--;
            }
        else
            {
            qwAddr =  previous;
            Count++;
            }

        }
    while (qwAddr && (Count || doAll) );

    PrintStats();

#endif
    dprintf("\n");
}

VOID
do_rpcmsg(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, Handle, "Handle(RPC_BINDING_HANDLE)            ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, DataRepresentation, "DataRepresentation                    ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, Buffer, "pBuffer(void)                         ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, BufferLength, "BufferLength                          ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, ProcNum, "ProcNum                               ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, TransferSyntax, "TransferSyntax(RPC_SYNTAX_IDENTIFIER) ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, RpcInterfaceInformation, "pRpcInterfaceInformation(void)        ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, ReservedForRuntime, "pReservedForRuntime(void)             ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, ManagerEpv, "pManagerEpv(RPC_MGR_EPV)              ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, ImportContext, "pImportContext(void)                  ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, RpcFlags, "RpcFlags                              ", tmp1);

    dprintf("\n");
}

VOID
do_transinfo(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;
    ULONG64 LoadableTrans;

    GET_MEMBER(qwAddr, TRANS_INFO, RPCRT4!TRANS_INFO, LoadableTrans, LoadableTrans);

    dprintf("\n");

    PRINT_MEMBER(qwAddr, TRANS_INFO, RPCRT4!TRANS_INFO, pTransportInterface, tmp1);
    PRINT_MEMBER(qwAddr, TRANS_INFO, RPCRT4!TRANS_INFO, LoadableTrans, tmp1);
    PRINT_MEMBER(LoadableTrans, LOADABLE_TRANSPORT, RPCRT4!LOADABLE_TRANSPORT, ThreadsStarted, tmp1);
    PRINT_MEMBER(LoadableTrans, LOADABLE_TRANSPORT, RPCRT4!LOADABLE_TRANSPORT, NumThreads, tmp1);
    PRINT_MEMBER(LoadableTrans, LOADABLE_TRANSPORT, RPCRT4!LOADABLE_TRANSPORT, ProcessCallsFunc, tmp1);
    PRINT_MEMBER(LoadableTrans, LOADABLE_TRANSPORT, RPCRT4!LOADABLE_TRANSPORT, LoadedDll, tmp1);
    PRINT_ADDRESS_OF(LoadableTrans, LOADABLE_TRANSPORT, RPCRT4!LOADABLE_TRANSPORT, ProtseqDict, tmp2);
    PRINT_ADDRESS_OF(LoadableTrans, LOADABLE_TRANSPORT, RPCRT4!LOADABLE_TRANSPORT, DllName, tmp2);
    PRINT_MEMBER(qwAddr, TRANS_INFO, RPCRT4!TRANS_INFO, RpcProtocolSequence, tmp1);

    dprintf("\n");
}

DECLARE_API( help )
{
    LPSTR lpArgumentString = (LPSTR)args;

    if (lpArgumentString[0] == '\0') {
        dprintf( "\n");
        dprintf( "rpcdbg help:\n\n");
        dprintf( "\n");
        dprintf( "!obj      <address>  - Dumps an RPC object \n");
        dprintf( "\n");
        dprintf( "!sizes - Prints sizes of the data structures\n");
        dprintf( "!error - Translates and error value into the error message\n");
        dprintf( "!symbol    (<address>|<symbol name>) - Returns symbol name/address\n");
        dprintf( "!rpcheap [-a <address>][-d <num display>] - Dumps RPC_MEMORY_BLOCK linked list\n");
        dprintf( "\n");
        dprintf( "!pasync     <address>  - Dumps RPC_ASYNC_STATE\n");
        dprintf( "!rpcmsg     <address>  - Dumps RPC_MESSAGE\n");
        dprintf( "!stubmsg    <address>  - Dumps MIDL_STUB_MESSAGE\n");
        dprintf( "!authinfo    <address> - Dumps CLIENT_AUTH_INFO\n");
        dprintf( "!rpcsvr    <address>   - Dumps RPC_SERVER \n");
        dprintf( "!secinfo               - Dumps security provider/package info\n");
        dprintf( "!dict      <address>   - Dumps SDICT \n");
        dprintf( "!dict2     <address>   - Dumps SDICT2 \n");
        dprintf( "!queue     <address>   - Dumps QUEUE \n");
        dprintf( "!thread     <teb>      - Dumps THREAD \n");
        dprintf( "!copacket  <address>   - Dumps CO packet \n");
        dprintf( "!lpcpacket  <address>   - Dumps LRPC packet \n");
        dprintf( "!transinfo  <address>   - Dumps TRANS_INFO \n");
        dprintf( "\n");
        dprintf( "!scan       [options]  - Dumps the event log, add '-?' for help\n");
        dprintf( "!dgcc       <address>  - Dumps DG_CCALL \n");
        dprintf( "!dgsc       <address>  - Dumps DG_SCALL \n");
        dprintf( "!dgpe       <address>  - Dumps DG_PACKET_ENGINE\n");
        dprintf( "!dgpkt      <address>  - Dumps DG_PACKET \n");
        dprintf( "!dgpkthdr   <address>  - Dumps dg packet header (NCA_PACKET_HEADER)\n");
        dprintf( "!dgep       <address>  - Dumps DG_ENDPOINT \n");
        dprintf( "\n");
        dprintf( "!asyncmsg   <address>  - Dumps NDR_ASYNC_MESSAGE\n");
        dprintf( "!asyncrpc   <address>  - Dumps RPC_ASYNC_STATE\n");
        dprintf( "!asyncdcom  <address>  - Dumps CAsyncManager\n");
        dprintf( "\n");
        dprintf( "!pipemsg    <address>  - Dumps NDR_PIPE_MESSAGE\n");
        dprintf( "!pipedesc   <address>  - Dumps NDR_PIPE_DESC\n");
        dprintf( "!pipestate  <address>  - Dumps NDR_PIPE_STATE\n");
        dprintf( "\n");
        dprintf( "!trans      <address>  - Dumps most NT RPC transport objects\n");
        dprintf( "!overlap    <address>  - Dumps object associated with OVERLAPPED pointer\n");
        dprintf( "!wsaddr     <address>  - Dumps sockaddr structure\n");
        dprintf( "!protocols  <address>  - Dumps PnP protocols map & related objects\n");
        dprintf( "\n");
        dprintf( "!rpctime               - Displays current system time\n");
        dprintf( "!getcallinfo [options] - Searches the system for call info, add '-?' for help\n");
        dprintf( "!getendpointinfo [options] - Searches the system for endpoint info, add '-?' for help\n");
        dprintf( "!getdbgcell  <processID> <cellID1>.<cellID2> - Gets info for the specified cell\n");
        dprintf( "!getthreadinfo [options] - Searches the system for thread info, add '-?' for help\n");
        dprintf( "!getclientcallinfo [options] - Searches the system for client call info, add '-?' for help\n");
        dprintf( "!checkrpcsym - Checks whether RPC symbols are correct\n");
        dprintf( "!rpcreadstack - Reads an RPC client side stack and retrieves the call info\n");
        dprintf( "!rpcverbosestack - toggles the state of the verbose spew when reading the stack\n");
        dprintf( "!eerecord - prints an extended error info record\n");
        dprintf( "!eeinfo - prints the extended error info chain\n");
        dprintf( "!typeinfo - turns on/off the use of type information\n");
        dprintf( "!stackmatch start_addr [depth] matches stack symbols and target addresses\n");
        dprintf( "!listcalls <address>  - Dumps addresses, associations, and calls active within the RPC_SERVER at address\n");
        dprintf( "!rpcverifier - Dumps the RPC verifier settings\n\n");
    }
}

void do_symbol(ULONG64 qwAddr)
{
    CHAR Symbol[128];
    ULONG64 Displacement = 0;

    GetSymbol(qwAddr, Symbol, &Displacement);

    dprintf("%I64x %s+%I64x\n", qwAddr, Symbol, Displacement);
}

DECLARE_API( symbol )
{
    ULONG64 qwAddr;
    LPSTR lpArgumentString = (LPSTR)args;

    qwAddr = GetExpression(lpArgumentString);
    if ( !qwAddr )
        {
        return;
        }
    do_symbol(qwAddr);
}

#define MAX_ARGS 4

DECLARE_API( rpcheap )
{
    ULONG64  qwAddr      = 0;
    ULONG64  dwTmpAddr   = 0;
    long   lDisplay    = 0;
    long   lVerbose    = 1;
    BOOL Summary = 0;
    int    argc        = 0;
    int    i;
    long lSize = 0;

    CurrentSize = 0;

    char   **argv      = new char*[MAX_ARGS];
    if (argv == NULL)
        return;

    LPSTR lpArgumentString = (LPSTR)args;

    //#ifdef DEBUGRPC
    for (i = 0; ; ) {
        while (lpArgumentString[i] == ' ') {
            lpArgumentString[i] = '\0';
            i++;
        }
        if (lpArgumentString[i] == '\0') {
            break;
        }

        argv[argc] = &(lpArgumentString[i]);
        argc++;

        if (argc > MAX_ARGS) {
            dprintf("\nToo many arguments. Extra args ignored.\n\n");
            break;
        }
        while ((lpArgumentString[i] != ' ')&&
               (lpArgumentString[i] != '\0')) {
              i++;
        }
    }
    for (i = 0; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/') || (*argv[i] == '+')) {
            switch (*(argv[i]+1)) {
                case 'A':
                case 'a':
                    qwAddr = GetExpression(argv[++i]);
                    if (!qwAddr) {
                        dprintf("Error: Failure to get address of RPC memory list\n");
                        return;
                    }
                    break;

                case 'D':
                case 'd':
                    lDisplay = (long)myatol(argv[++i]);
                    break;

                case 's':
                    Summary = 1;
                    break;

                case 'z':
                    lSize = (long) GetExpression(argv[++i]);
                    break;

                case 'q':
                case 'Q':
                    lVerbose = FALSE;
                    break;

                case '?':
                default:
                    dprintf("rpcheap \n");
                    dprintf("     -a <address> (default:starts at head of linked list)\n");
                    dprintf("     -d <number of mem blks to display> (default: to end)\n");
                    dprintf("     -s display summary only (default: full dump)\n");
                    dprintf("     -z <size> display blocks of size <size> only (default: all)\n");
                    dprintf("     -q quiet (default: verbose)\n");
                    break;
            }
        }
        else {
            dprintf("rpcheap \n");
            dprintf("     -a <address> (default:starts at head of linked list)\n");
            dprintf("     -d <number of mem blks to display> (default: to end)\n");
        }
    }

    if (!qwAddr) {
        dwTmpAddr = GetExpression("rpcrt4!AllocatedBlocks");
        dprintf("Address of AllocatedBlocks - 0x%I64x\n", dwTmpAddr);
        if (!ReadPtrUnextend(dwTmpAddr, &qwAddr))
            dprintf("Contents of AllocatedBlocks - 0x%I64x\n", qwAddr);
    }
    do_rpcmem(qwAddr, lDisplay, lVerbose, Summary, lSize);
    //#else  // DEBUGRPC
    //dprintf("This extension command is not supported on a free build!\n");
    //#endif // DEBUGRPC
    if (argv) {
        delete[] argv;
    }
    return;
}

VOID
do_lpcaddr(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    do_rpcaddr( qwAddr );

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, LpcAddressPort, "LpcAddressPort(HANDLE)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, CallThreadCount, "CallThreadCount\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, MinimumCallThreads, "MinimumCallThreads\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, AssociationDictionary, "&Associations(LRPC_ASSOCIATION_DICT)", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, AssociationCount, "AssociationCount\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, ServerListeningFlag, "ServerListeningFlag\t\t", tmp1);

    dprintf("\n");
    }


VOID
do_lpcsa(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, AssociationReferenceCount, "AssociationReferenceCount\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, DictionaryKey, "DictionaryKey\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, LpcServerPort, "LpcServerPort(HANDLE)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, LpcReplyPort, "LpcReplyPort\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, Address, "Address\t\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, Bindings, "&Bindings(LRPC_SBINDING_DICT)\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, Aborted, "Aborted\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, Deleted, "Deleted\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, CachedSCall, "CachedSCall\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, CachedSCallAvailable, "CachedSCallAvailable\t\t", tmp1);

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, Buffers, "&Buffers(LRPC_CLIENT_BUFFER_DICT)", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, AssociationMutex, "&AssociationMutex\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, FreeSCallQueue, "&FreeSCallQueue\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, ClientThreadDict, "&ClientThreadDict\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, SContextDict, "&SContextDict\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, SCallDict, "&SCallDict\t\t\t", tmp2);

    dprintf("\n");
}

VOID
do_lpcscall(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, AsyncStatus, "AsyncStatus\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CachedAPCInfo, "pCachedAPCInfo\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CachedAPCInfoAvailable, "CachedAPCInfoAvailable\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, pAsync, "pAsync\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CallingThread, "CallingThread\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, NotificationIssued, "NotificationIssued\t\t", tmp1);

    ULONG64 AuthInfo;
    GET_ADDRESS_OF(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, AuthInfo, AuthInfo, tmp2);
    dprintf("&ClientAuthInfo\t\t\t - 0x%I64x\n", AuthInfo);
    do_authinfo(AuthInfo );

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, ActiveContextHandles, "&ActiveContextHandles(ServerContextHandle_DICT)\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, DispatchBuffer, "DispatchBuffer\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, Association, "pAssociation(LRPC_ASSOCIATION)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, LrpcRequestMessage, "pLrpcMessage(LRPC_MESSAGE)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, LrpcReplyMessage, "pLrpcReplyMessage(LRPC_MESSAGE)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, SBinding, "pSBinding(LRPC_SBINDING)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, ObjectUuidFlag, "ObjectUuidFlag\t\t\t", tmp1);


    ULONG64 ObjectUuid;
    GET_ADDRESS_OF(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, ObjectUuid, ObjectUuid, tmp2);
    dprintf("ObjectUuid\t\t\t - ");
    PrintUuid(ObjectUuid); dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CallId, "CallId\t\t\t\t", tmp1);

    ULONG64 ClientId;
    GET_ADDRESS_OF(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, ClientId, ClientId, tmp2);
    PRINT_MEMBER_WITH_LABEL(ClientId, CLIENT_ID, RPCRT4!CLIENT_ID, UniqueProcess, "ClientId.UniqueProcess(CLIENT_ID.HANDLE)", tmp1);
    PRINT_MEMBER_WITH_LABEL(ClientId, CLIENT_ID, RPCRT4!CLIENT_ID, UniqueThread, "ClientId.UniqueThread (CLIENT_ID.HANDLE)", tmp1);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, MessageId, "MessageId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, PushedResponse, "pPushedResponse(VOID)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CurrentBufferLength, "CurrentBuffferLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, BufferComplete, "BufferComplete\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, Flags, "Flags\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, FirstSend, "FirstSend\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, PipeSendCalled, "PipeSendCalled\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, Deleted, "Deleted\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, ReceiveEvent, "ReceiveEvent\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CallMutex, "CallMutex\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, RcvBufferLength, "RcvBufferLength\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, AsyncReply, "AsyncReply\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, NextSCall, "NextSCall\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, NeededLength, "NeededLength\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, fSyncDispatch, "fSyncDispatch\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, Choked, "Choked\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CancelPending, "CancelPending\t\t\t", tmp1);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, RefCount, "RefCount\t\t\t", tmp1);

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, BufferQueue, "&BufferQueue\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, SContext, "SContext\t\t\t", tmp1);

    dprintf("\n");
}

VOID
do_lpcbh(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp0;
    ULONG tmp1;

    do_bh(qwAddr);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, CurrentAssociation, "pCurrentAssociation(LRPC_CASSOCIATION)", tmp0);
    PRINT_ADDRESS_OF(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, SecAssociation, tmp1);
    PRINT_MEMBER(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, DceBinding, tmp0);

    GET_ADDRESS_OF(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, DceBinding, tmp0, tmp1);
    do_dcebinding(tmp0);

    PRINT_MEMBER(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, BindingReferenceCount, tmp0);
    PRINT_ADDRESS_OF(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, RecursiveCalls, tmp1);
    PRINT_MEMBER(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, AuthInfoInitialized, tmp0);
}

VOID
do_lpcca(
    ULONG64 qwAddr
    )
{
    dprintf("\n");

    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 DceBinding;
    GET_MEMBER(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, DceBinding, DceBinding);
    dprintf("pDceBinding(DCE_BINDING)\t- 0x%I64x\n", DceBinding);
    do_dcebinding(DceBinding);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, AssociationDictKey, "AssociationDictKey\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, Bindings, "&Bindings(LRPC_BINDING_DICT)\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, FreeCCalls, "&FreeCCalls\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, ActiveCCalls, "&ActiveCCalls\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, LpcClientPort, "LpcClientPort\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, LpcReceivePort, "LpcReceivePort\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, AssociationMutex, "&AssociationMutex(MUTEX)\t", tmp2);

    ULONG64 AssocAuthInfo;
    GET_ADDRESS_OF(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, AssocAuthInfo, AssocAuthInfo, tmp2);
    do_authinfo(AssocAuthInfo);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, BackConnectionCreated, "BackConnectionCreated\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, CachedCCall, "pCachedCCall(LRPC_CCALL)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, CachedCCallFlag, "CachedCCallFlag\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, CallIdCounter, "CallIdCounter\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, SecurityContextDict, "&SecurityContextDict\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, LastSecContextTrimmingTimestamp, "Timestamp\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, BindingHandleReferenceCount, "BindingHAndleReferenceCount\t", tmp1);

    dprintf("\n");
}

VOID
do_lpcccall(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, AsyncStatus, "AsyncStatus\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CachedAPCInfo, "pCachedAPCInfo\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CachedAPCInfoAvailable, "CachedAPCInfoAvailable\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, pAsync, "pAsync\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CallingThread, "CallingThread\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, NotificationIssued, "NotificationIssued\t\t", tmp1);

    ULONG64 AuthInfo; 
    GET_ADDRESS_OF(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, AuthInfo, AuthInfo, tmp2);
    dprintf("AuthInfo\t\t\t- 0x%I64x\n", AuthInfo);
    do_authinfo(AuthInfo);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CurrentBindingHandle, "pCurrentBindingHandle(LRPC_BINDING_HANDLE)", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, Association, "pAssociation(LRPC_CASSOCIATION)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, LrpcMessage, "pLrpcMessage(LRPC_MESSAGE)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, RpcReplyMessage, "RpcReplyMessage\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, LpcReplyMessage, "LpcReplyMessage\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, RcvBufferLength, "RcvBufferLength\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, Choked, "Choked\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, RecursiveCallsKey, "RecursiveCallsKey\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, FreeCallKey, "FreeCallKey\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CallId, "CallId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, MessageId, "MessageId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CallbackId, "CallbackId\t\t\t", tmp1);

    ULONG64 ClientId;
    GET_ADDRESS_OF(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, ClientId, ClientId, tmp2);
    PRINT_MEMBER_WITH_LABEL(ClientId, CLIENT_ID, RPCRT4!CLIENT_ID, UniqueProcess, "ClientId.UniqueProcess(CLIENT_ID.HANDLE)", tmp1);
    PRINT_MEMBER_WITH_LABEL(ClientId, CLIENT_ID, RPCRT4!CLIENT_ID, UniqueThread, "ClientId.UniqueThread (CLIENT_ID.HANDLE)", tmp1);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, DataInfoOffset, "DataInfoOffset\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CallAbortedFlag, "CallAbortedFlag\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, Thread, "Thread(THREAD_IDENTIFIER)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, Binding, "Binding(LRPC_BINDING)", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, RecursionCount, "RecursionCount\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, SyncEvent, "SyncEvent\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, MsgFlags, "MsgFlags\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CallMutex, "CallMutex\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CallStack, "CallStack\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CachedLrpcMessage, "CachedLrpcMessage\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, FirstFrag, "FirstFrag\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CurrentBufferLength, "CurrentBufferLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, NeededLength, "NeededLength\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, BufferQueue, "BufferQueue\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, fSendComplete, "fSendcomplete\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CurrentSecurityContext, "CurrentSecurityContext\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, EEInfo, "Extended Error Info\t\t", tmp1);

    dprintf("\n");
}


VOID
do_pasync(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Size, "Size\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Signature, "Signature\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Lock, "Lock\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Flags, "Flags\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, StubInfo, "StubInfo\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, UserInfo, "UserInfo\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, RuntimeInfo, "RuntimeInfo\t\t", tmp1);

    ULONG64 Event;
    GET_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Event, Event);
    dprintf("Event\t\t\t - ");
    switch ((ULONG)Event)
        {
        case RpcCallComplete:
            dprintf("RpcCallComplete\n");
            break;
        case RpcSendComplete:
            dprintf("RpcSendComplete\n");
            break;
        case RpcReceiveComplete:
            dprintf("RpcReceiveComplete\n");
            break;
        default:
            dprintf("(unknown) 0x%I64x\n", Event);
            break;
        }

    ULONG64 NotificationType;
    GET_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, NotificationType, NotificationType);
    dprintf("NotificationType\t - ");

    BOOL b;
    char block[sizeof(RPC_ASYNC_STATE)];
    PRPC_ASYNC_STATE pa = (PRPC_ASYNC_STATE)block;

    if (!fUseTypeInfo) {
        b = GetData(qwAddr, block, sizeof(RPC_ASYNC_STATE));
        if ( !b ) {
            dprintf("can't read %p\n", qwAddr);
            return;
        }
    }

    switch ((ULONG)NotificationType)
        {
        case RpcNotificationTypeNone:
            dprintf("RpcNotificationTypeNone\n");
            break;

        case RpcNotificationTypeEvent:
            dprintf("RpcNotificationTypeEvent\n");

            if (!fUseTypeInfo)
                dprintf("\thEvent\t\t - 0x%p\n", pa->u.hEvent);
            break;

        case RpcNotificationTypeApc:
            dprintf("RpcNotificationTypeApc\n");

            if (!fUseTypeInfo) {
                dprintf("\tNotificationRoutine\t - 0x%p\n", pa->u.APC.NotificationRoutine);
                dprintf("\thThread\t\t\t - 0x%p\n", pa->u.APC.hThread);
            }
            break;

        case RpcNotificationTypeIoc:
            dprintf("RpcNotificationTypeIoc\n");

            if (!fUseTypeInfo) {
                dprintf("\thIOPort\t\t\t - 0x%p\n", pa->u.IOC.hIOPort);
                dprintf("\tdwNumberOfBytesTransferred - 0x%x\n",
                        pa->u.IOC.dwNumberOfBytesTransferred);
                dprintf("\tdwCompletionKey\t\t - 0x%p\n", pa->u.IOC.dwCompletionKey);
                dprintf("\tlpOverlapped\t\t - 0x%x\n", pa->u.IOC.lpOverlapped);
            }
            break;

        case RpcNotificationTypeHwnd:
            dprintf("RpcNotificationTypeHwnd\n");

            if (!fUseTypeInfo) {
                dprintf("\thWnd\t\t - 0x%p\n", pa->u.HWND.hWnd);
                dprintf("\tMsg\t\t - 0x%x\n", pa->u.HWND.Msg);
            }
            break;

        case RpcNotificationTypeCallback:
            dprintf("RpcNotificationTypeCallback\n");

            if (!fUseTypeInfo) {
                dprintf("NotificationRoutine\t - 0x%p\n", pa->u.NotificationRoutine);
            }
            break;

        default:
            dprintf("Bad notification type\n");
        }

    dprintf("\n");
}

char *
ReceiveStates[] =
{
    "START",
    "COPY_PIPE_ELEM",
    "RETURN_PARTIAL",
    "READ_PARTIAL"
};

void
do_stubmsg(
    ULONG64 msg
    )
{
    ULONG64 tmp0;

    dprintf("MIDL_STUB_MESSAGE at 0x%I64x\n\n", msg);

    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, Buffer, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, BufferStart, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, BufferEnd, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, BufferMark, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, MemorySize, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, Memory, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, BufferLength, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, pAllocAllNodesContext, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, RpcMsg, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, SavedHandle, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, StubDesc, tmp0);
    PRINT_MEMBER_BOOLEAN(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, IsClient, tmp0);
    PRINT_MEMBER_BOOLEAN(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, ReuseBuffer, tmp0);
    PRINT_MEMBER_BOOLEAN(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, IgnoreEmbeddedPointers, tmp0);
    PRINT_MEMBER_BOOLEAN(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, fBufferValid, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, MaxCount, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, ActualCount, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, Offset, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, StackTop, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, pPresentedType, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, pTransmitType, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, pRpcChannelBuffer, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, pAsyncMsg, tmp0);
}

VOID
do_dgaddr(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp0;
    ULONG tmp1;

    dprintf("DG_ADDRESS at 0x%I64x\n\n", qwAddr);

    do_rpcaddr(qwAddr);

    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, TransInfo, tmp0);
    PRINT_MEMBER_SYMBOL(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, TransInfo, tmp0);
    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, ActiveCallCount, tmp0);
    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, CachedConnections, tmp0);

    dprintf("\nendpoint data:\n");

    GET_ADDRESS_OF(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, Endpoint, tmp0, tmp1);
    do_dgep(tmp0);

    dprintf("\nobsolete data:\n");

    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, TotalThreadsThisEndpoint, tmp0);
    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, ThreadsReceivingThisEndpoint, tmp0);
    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, MinimumCallThreads, tmp0);
    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, MaximumConcurrentCalls, tmp0);
    PRINT_ADDRESS_OF(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, ScavengerTimer, tmp1);
}

VOID
do_dgbh(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    do_bh(qwAddr);

    dprintf("DCE_BINDING:\n");
    ULONG64 pDceBinding;
    GET_MEMBER(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, pDceBinding, pDceBinding);
    do_dcebinding(pDceBinding);

    PRINT_MEMBER(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, EndpointFlags, tmp1);
    PRINT_MEMBER(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, Association, tmp1);
    PRINT_MEMBER(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, ReferenceCount, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, fDynamicEndpoint, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, fContextHandle, tmp1);
    PRINT_MEMBER(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, TransportObject, tmp1);
    PRINT_MEMBER(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, TransportInterface, tmp1);
}

VOID
do_dgpe(
    ULONG64 qwAddr
    )
{
    DG_PACKET_ENGINE *dgpe;
    char block[sizeof(DG_PACKET_ENGINE)];
    dgpe = (DG_PACKET_ENGINE *) block;

    ULONG64 tmp1;
    ULONG tmp;

    if (!fUseTypeInfo) {
        GetData(qwAddr, block, sizeof(DG_PACKET_ENGINE));
    }

    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SequenceNumber, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, ReferenceCount, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, PacketType,tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, ActivityHint, tmp1);

    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, TimeoutCount, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, CurrentPduSize, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, MaxFragmentSize, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SecurityTrailerSize, tmp1);

    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, pSavedPacket, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SourceEndpoint, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, RemoteAddress, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, BaseConnection, tmp1);

    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, pReceivedPackets, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, ReceiveFragmentBase, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, LastReceiveBuffer, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, pLastConsecutivePacket, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, LastReceiveBufferLength, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, ConsecutiveDataBytes, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, fReceivedAllFragments, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, Buffer, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SendWindowBase, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, FinalSendFrag, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, BufferLength, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SendWindowBits, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, FackSerialNumber, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, BufferFlags,tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SendWindowSize, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, fRetransmitted, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, FirstUnsentOffset, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SendBurstLength, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, QueuedBufferHead, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, FirstUnsentFragment, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, QueuedBufferTail, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, RingBufferBase, tmp1);

    if (!fUseTypeInfo) {
        dprintf("  Frag  Offset    Length  Serial # |  Frag  Offset    Length  Serial #\n"
            "  ----  --------  ------  -------- |  ----  --------  ------  --------\n"
            );
    }

    ULONG64 RingBufferBase;
    ULONG64 SendWindowBase;
    GET_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, RingBufferBase, RingBufferBase);
    GET_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SendWindowBase, SendWindowBase);

    unsigned short i;
    for (i=1; i <= MAX_WINDOW_SIZE/2; ++i)
        {
        unsigned Index1 = (i + (ULONG)RingBufferBase) % MAX_WINDOW_SIZE;
        unsigned Frag1 = (ULONG)SendWindowBase+i;

        if (Frag1 >= MAX_WINDOW_SIZE)
            {
            Frag1 -= MAX_WINDOW_SIZE;
            }

        if (!fUseTypeInfo) {
            dprintf("  %4x: %8lx  %5hx     %4hx   |",
                    Frag1,
                    dgpe->FragmentRingBuffer[Index1].Offset,
                    dgpe->FragmentRingBuffer[Index1].Length,
                    dgpe->FragmentRingBuffer[Index1].SerialNumber
                    );
        }

        unsigned Index2 = (i+MAX_WINDOW_SIZE/2 + (ULONG)RingBufferBase) % MAX_WINDOW_SIZE;
        unsigned Frag2 = (ULONG)SendWindowBase+i+MAX_WINDOW_SIZE/2;

        if (Frag2 >= MAX_WINDOW_SIZE)
            {
            Frag2 -= MAX_WINDOW_SIZE;
            }

        if (!fUseTypeInfo) {
            dprintf("  %4x: %8lx  %5hx     %4hx   \n",
                    Frag2,
                    dgpe->FragmentRingBuffer[Index2].Offset,
                    dgpe->FragmentRingBuffer[Index2].Length,
                    dgpe->FragmentRingBuffer[Index2].SerialNumber
                    );
        }
    }
    dprintf("\n");
}

char *
ClientState(
    DG_CCALL::DG_CLIENT_STATE State
    )
{
    switch (State)
        {
        case DG_CCALL::CallInit:          return "init";
        case DG_CCALL::CallQuiescent:     return "quiescent";
        case DG_CCALL::CallSend:          return "sending";
        case DG_CCALL::CallSendReceive:   return "sendreceive";
        case DG_CCALL::CallReceive:       return "receiving";
        case DG_CCALL::CallCancellingSend:return "cancel send";
        case DG_CCALL::CallComplete:      return "complete";
        default:
            {
            static char scratch[40];

            sprintf(scratch, "0x%lx", State);
            return scratch;
            }
        }
}

char *
ServerState(
    DG_SCALL::CALL_STATE State
    )
{
    switch (State)
        {
        case DG_SCALL::CallInit:            return "init";
        case DG_SCALL::CallBeforeDispatch:  return "receiving";
        case DG_SCALL::CallDispatched:      return "dispatched";
        case DG_SCALL::CallAfterDispatch:   return "after stub";
        case DG_SCALL::CallSendingResponse: return "sending";
        case DG_SCALL::CallComplete:        return "complete";
        default:
            {
            static char scratch[40];

            sprintf(scratch, "0x%lx", State);
            return scratch;
            }
        }
}

char *
PipeOp(
    PENDING_OPERATION Op
    )
{
    switch (Op)
        {
        case PWT_NONE:          return "none";
        case PWT_RECEIVE:       return "receive";
        case PWT_SEND:          return "send";
        case PWT_SEND_RECEIVE:  return "send/recv";
        default:
            {
            static char scratch[40];

            sprintf(scratch, "0x%lx", Op);
            return scratch;
            }
        }
}

VOID
do_dgcc(
    ULONG64 dgcc
    )
{
    ULONG64 State, PreviousState;
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    GET_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, State, State);
    GET_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, PreviousState, PreviousState);

    dprintf("state %-14s  prev  %-14s\n\n",
            ClientState((DG_CCALL::DG_CLIENT_STATE)State),
            ClientState((DG_CCALL::DG_CLIENT_STATE)PreviousState));

    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, TimeStamp, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, TimeoutLimit, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, LastReceiveTime, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, AsyncStatus, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, CancelTime, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, EEInfo, tmp1);

    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, ReceiveTimeout, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, WorkingCount, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, UnansweredRequestCount, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, PipeReceiveSize, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, Previous, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, Next, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, pAsync, tmp1);

    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, StaticArgsSent, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, DelayedSendPending, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, AllArgsSent, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, LastSendTimedOut, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, CancelComplete, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, ForceAck, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, CancelPending, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, AutoReconnectOk, tmp1);

    dprintf("\n");

    ULONG64 ActivityHint;
    GET_ADDRESS_OF(dgcc, DG_CCALL, RPCRT4!DG_CCALL, ActivityHint, ActivityHint, tmp2);

    do_dgpe(ActivityHint-AddressSize);
}

VOID
do_dgep(
        ULONG64 ep
        )
{
    ULONG64 tmp0;
    ULONG tmp1;
    ULONG64 Stats;

    PRINT_MEMBER_BOOLEAN(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, Async, tmp0);
    PRINT_MEMBER(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, TimeStamp, tmp0);
    PRINT_MEMBER(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, Next, tmp0);
    PRINT_MEMBER(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, NumberOfCalls, tmp0);

    PRINT_MEMBER(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, TransportInterface, tmp0);
    PRINT_MEMBER_SYMBOL(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, TransportInterface, tmp0);

    GET_ADDRESS_OF(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, Stats, Stats, tmp1);
    PRINT_MEMBER(Stats, DG_ENDPOINT_STATS, RPCRT4!DG_ENDPOINT_STATS, PreferredPduSize, tmp0);
    PRINT_MEMBER(Stats, DG_ENDPOINT_STATS, RPCRT4!DG_ENDPOINT_STATS, MaxPduSize, tmp0);
    PRINT_MEMBER(Stats, DG_ENDPOINT_STATS, RPCRT4!DG_ENDPOINT_STATS, MaxPacketSize, tmp0);
    PRINT_MEMBER(Stats, DG_ENDPOINT_STATS, RPCRT4!DG_ENDPOINT_STATS, ReceiveBufferSize, tmp0);
}

VOID
do_dgccn(
         ULONG64 qwAddr
         )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\nbase:\n");

    ULONG64 ActivityNode;
    GET_ADDRESS_OF(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, ActivityNode, ActivityNode, tmp2);

    ULONG64 Uuid;
    ULONG64 pPrev, pNext;
    GET_ADDRESS_OF(ActivityNode, UUID_HASH_TABLE_NODE, RPCRT4!UUID_HASH_TABLE_NODE, Uuid, Uuid, tmp2);
    GET_MEMBER(ActivityNode, UUID_HASH_TABLE_NODE, RPCRT4!UUID_HASH_TABLE_NODE, pPrev, pPrev);
    GET_MEMBER(ActivityNode, UUID_HASH_TABLE_NODE, RPCRT4!UUID_HASH_TABLE_NODE, pNext, pNext);

    dprintf("  activity ID "); PrintUuid(Uuid);
    dprintf("  next %I64x prev %I64x\n", pNext, pPrev );

    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, TimeStamp, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, TransportInterface, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, ActiveSecurityContext, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, ReferenceCount, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, TransportInterface, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, LowestActiveSequence, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, LowestUnusedSequence, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, CurrentPduSize, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, RemoteWindowSize, tmp1);
}

VOID
do_dgcn(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    do_dgccn(qwAddr);

    dprintf("\nclient:\n");

    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, ActiveCallHead, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, CurrentCall, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, ActiveCallTail, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, CachedCalls, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, CachedCallCount, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, ThreadId, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, BindingHandle, tmp1);

    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, ServerResponded, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, CallbackCompleted, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, fServerSupportsAsync, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, fSecurePacketReceived, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, fBusy, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, InConnectionTable, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, AckPending, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, AckOrphaned, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, PossiblyRunDown, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, fAutoReconnect,tmp1);

    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, Association, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, AssociationKey, tmp1);
    PRINT_ADDRESS_OF(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, AuthInfo, tmp2);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, SecurityContextId, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, TimeStamp, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, LastScavengeTime, tmp1);
    PRINT_ADDRESS_OF(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, DelayedAckTimer, tmp2);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, Next, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, fError, tmp1);
    PRINT_ADDRESS_OF(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, Mutex, tmp2);
}

char *
CallbackState(
    DG_SCONNECTION::CALLBACK_STATE State
    )
{
    switch (State)
        {
        case DG_SCONNECTION::NoCallbackAttempted:    return "NoCallbackAttempted";
        case DG_SCONNECTION::SetupInProgress:        return "SetupInProgress";
        case DG_SCONNECTION::MsConvWayAuthInProgress:return "MsConvWayAuthInProgress";
        case DG_SCONNECTION::  ConvWayAuthInProgress:return "  ConvWayAuthInProgress";
        case DG_SCONNECTION::MsConvWay2InProgress:   return "MsConvWay2InProgress";
        case DG_SCONNECTION::  ConvWay2InProgress:   return "  ConvWay2InProgress";
        case DG_SCONNECTION::  ConvWayInProgress:    return "  ConvWayInProgress";
        case DG_SCONNECTION::CallbackSucceeded:      return "CallbackSucceeded";
        case DG_SCONNECTION::CallbackFailed:         return "CallbackFailed";
        default:
            {
            static char scratch[40];

            sprintf(scratch, "0x%lx", State);
            return scratch;
            }
        }
}


VOID
do_dgsn(
        ULONG64 qwAddr
        )
{
    ULONG64 tmp1;
    ULONG tmp2;

    do_dgccn(qwAddr);

    dprintf("\nserver:\n");

    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, ActiveCalls, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, CurrentCall, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, CachedCalls, tmp1);

    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, pAddress, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, LastInterface, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, pAssocGroup, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, Next, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, ActivityHint, tmp1);
    PRINT_ADDRESS_OF(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, AuthInfo, tmp2);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, MaxKeySeq, tmp1);
    PRINT_ADDRESS_OF(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, SecurityContextDict, tmp2);
    PRINT_ADDRESS_OF(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, Callback, tmp2);

    if (!fUseTypeInfo) {

        uchar buff[sizeof(DG_SCONNECTION)];
        GetData(qwAddr, buff, sizeof(DG_SCONNECTION));
        DG_SCONNECTION * cn = (DG_SCONNECTION *) buff;

        dprintf(                                            "\n"
            "  status        %-8lx  binding     %p   datarep   %-8lx   \n"
            "  scall         %p  client seq  %-8lx   \n"
            "\n"
            "  token buffer  %p  token len    %-8lx  async state offset %x  \n"
            "  response buf  %p  response len %-8lx  ThirdLegNeeded    %s\n"
            "  sec cxt       %p  credentials  %p  ksno              %-8lx \n"
            "  data index    %-8lx \n",

            cn->Callback.Status,            cn->Callback.Binding,           cn->Callback.DataRep,
            cn->Callback.Call,              cn->Callback.ClientSequence,

            cn->Callback.TokenBuffer,       cn->Callback.TokenLength,       offsetof(DG_SCONNECTION, Callback.AsyncState),
            cn->Callback.ResponseBuffer,    cn->Callback.ResponseLength,    BoolString(cn->Callback.ThirdLegNeeded),
            cn->Callback.SecurityContext,   cn->Callback.Credentials,       cn->Callback.KeySequence,
            cn->Callback.DataIndex
            );
    }
}

VOID
do_dgca(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, ReferenceCount, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, BindingHandleReferences, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, InternalTableIndex, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, LastScavengeTime, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, CurrentPduSize, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, RemoteWindowSize, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, TransportInterface, tmp1);

    dprintf("\n");

    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, ServerAddress, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, ServerBootTime, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, ServerDataRep, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, AssociationFlag, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, fServerSupportsAsync, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, fLoneBindingHandle, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, fErrorFlag, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, LastReceiveTime, tmp1);

    PRINT_ADDRESS_OF(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, Mutex, tmp2);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, ResolvedEndpoint, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, KeepAliveHandle, tmp1);
    PRINT_ADDRESS_OF(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, ActiveConnections, tmp2);
    PRINT_ADDRESS_OF(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, InactiveConnections, tmp2);
    PRINT_ADDRESS_OF(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, InterfaceAndObjectDict, tmp2);

    ULONG64 pDceBinding;
    GET_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, pDceBinding, pDceBinding);
    dprintf("DCE_BINDING:\n");
    do_dcebinding(pDceBinding);
}

VOID
do_dgsc(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    ULONG64 State;
    GET_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, State, State);
    dprintf("state - %-14s\n", ServerState((DG_SCALL::CALL_STATE)State));

    ULONG64 PreviousState;
    GET_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, PreviousState, PreviousState);
    dprintf("prev state - %-14s\n", ServerState((DG_SCALL::CALL_STATE)State));

    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, TimeStamp, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, DispatchBuffer, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, AsyncStatus, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, pAsync, tmp1);

    ULONG64 PipeWaitType;
    GET_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, PipeWaitType, PipeWaitType);
    dprintf("pipe op - %-10s\n", PipeOp((PENDING_OPERATION)PipeWaitType));

    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, PipeWaitLength, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, PipeThreadId, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, Previous, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, Next, tmp1);

    PRINT_MEMBER_BOOLEAN(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, CallInProgress, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, CallWasForwarded, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, KnowClientAddress, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, TerminateWhenConvenient, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, AuthorizationService, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, Privileges, tmp1);

    dprintf("\n");

    ULONG64 ActivityHint;
    GET_ADDRESS_OF(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, ActivityHint, ActivityHint, tmp2);

    do_dgpe(ActivityHint-AddressSize);
}


VOID
do_dgag(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;
    ULONG64 Node;
    GET_ADDRESS_OF(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, Node, Node, tmp2);
    ULONG64 Uuid;
    GET_ADDRESS_OF(Node, UUID_HASH_TABLE_NODE, UUID_HASH_TABLE_NODE, Uuid, Uuid, tmp2);

    dprintf("\n"
            "    CAG UUID:   ");   PrintUuid(Uuid);

    ULONG64 ReferenceCount;
    ULONG64 CurrentPduSize;
    ULONG64 RemoteWindowSize;
    ULONG64 AssociationID;
    ULONG64 CtxCollection;
    ULONG64 MutexAddr;
    GET_MEMBER(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, ReferenceCount, ReferenceCount);
    GET_MEMBER(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, CurrentPduSize, CurrentPduSize);
    GET_MEMBER(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, RemoteWindowSize, RemoteWindowSize);
    GET_MEMBER(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, AssociationID, AssociationID);
    GET_MEMBER(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, CtxCollection, CtxCollection);
    GET_ADDRESS_OF(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, Mutex, MutexAddr, tmp2);

    dprintf("                  \n"
            "    refs:       %8.8x             mutex at  %p    \n"
            "    pdu length: %8.8x             assoc ID: %x    \n"
            "    send window %8.8x             CtxColl : %I64p    \n",
            (ULONG)ReferenceCount,             MutexAddr,
            (ULONG)CurrentPduSize,             (ULONG)AssociationID,
            (ULONG)RemoteWindowSize,           CtxCollection);
}

// Do some arm twisting to include pipendr.h and asyncndr.

#define _NEWINTRP_
typedef unsigned char   uchar;
typedef unsigned short  ushort;
typedef unsigned long   ulong;
typedef unsigned int    uint;
#include "..\..\ndr20\pipendr.h"

typedef void            IAsyncManager;
#define MAX_CONTEXT_HNDL_NUMBER     8
#include "..\..\ndr20\mulsyntx.h"
#include "..\..\ndr20\asyncndr.h"


char *
PipeState(
    int State
    )
{
    static char buf[40];

    if (State <= 3)
        {
        return ReceiveStates[State];
        }

    sprintf(buf, "0x%x", State);

    return buf;
}

char *
PipeFlags(
    unsigned short Flags
    )
{
    static char buf[80];

    buf[0] = 0;

    if (Flags & NDR_IN_PIPE)
        {
        strcat(buf, "I ");
        }

    if (Flags & NDR_OUT_PIPE)
        {
        strcat(buf, "O ");
        }

    if (Flags & NDR_LAST_IN_PIPE)
        {
        strcat(buf, "LI ");
        }

    if (Flags & NDR_LAST_OUT_PIPE)
        {
        strcat(buf, "LO ");
        }

    if (Flags & NDR_OUT_ALLOCED)
        {
        strcat(buf, "ALLOC ");
        }

    if (Flags & 0xffe0)
        {
        char Excess[10];
        sprintf(Excess, "%hx ", Flags & 0xffe0);
        strcat(buf, Excess);
        }

    return buf;
}

char *
PipeStatusStrings[] =
{
    "QUIET",
    "IN",
    "OUT",
    "DRAIN"
};

char *
PipeStatus(
    unsigned short Status
    )
{
    static char buf[40];

    if (Status <= 3)
        {
        return PipeStatusStrings[Status];
        }

    sprintf(buf, "0x%x", Status);

    return buf;
}

void
do_pipestate(
    ULONG64 qwAddr
    )
{
    ULONG64 ElemsInChunk;
    ULONG64 ElemAlign;
    ULONG64 ElemWireSize;
    ULONG64 ElemMemSize;
    ULONG64 PartialBufferSize;
    ULONG64 PartialElem;
    ULONG64 PartialElemSize;
    ULONG64 PartialOffset;
    ULONG64 CurrentState;
    ULONG64 EndOfPipe;

    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, ElemsInChunk, ElemsInChunk);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, ElemAlign, ElemAlign);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, ElemWireSize, ElemWireSize);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, ElemMemSize, ElemMemSize);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, PartialBufferSize, PartialBufferSize);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, PartialElem, PartialElem);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, PartialElemSize, PartialElemSize);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, PartialOffset, PartialOffset);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, CurrentState, CurrentState);

    ULONG tmp2;
    GET_ADDRESS_OF(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, PartialOffset, EndOfPipe, tmp2);
    EndOfPipe += 4;

    dprintf("\n");
    dprintf(" elems in chunk %8lx   partial buf size  %8lx   state %s\n",
             (ULONG)ElemsInChunk,    (ULONG)PartialBufferSize, PipeState((ULONG)CurrentState) );
    dprintf(" elem align     %8lx   partial element   %8lx   end of pipe bits %I64x\n",
             (ULONG)ElemAlign,       (ULONG)PartialElem,     EndOfPipe );
    dprintf(" elem wire size %8lx   partial elem size %8lx   \n",
             (ULONG)ElemWireSize,    (ULONG)PartialElemSize  );
    dprintf(" elem mem  size %8lx   partial offset    %8lx   \n",
             (ULONG)ElemMemSize,     (ULONG)PartialOffset    );
}

void
do_pipedesc(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, CurrentPipe, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, InPipes, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, OutPipes, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, TotalPipes, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, Flags, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, PipeVersion, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, pPipeMsg, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, DispatchBuffer, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, ChainingBuffer, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, DispatchBufferLength, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, ChainingBufferSize, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, LastPartialBuffer, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, BufferSave, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, LastPartialSize, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, LengthSave, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, LeftoverSize, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, RuntimeState, tmp1);
    PRINT_ADDRESS_OF(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, Leftover, tmp2);

    do_pipestate(tmp1);
}

void
do_pipearg(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;

    dprintf("\n");

    PRINT_MEMBER(qwAddr, GENERIC_PIPE_TYPE, RPCRT4!GENERIC_PIPE_TYPE, pfnPull, tmp1);
    PRINT_MEMBER(qwAddr, GENERIC_PIPE_TYPE, RPCRT4!GENERIC_PIPE_TYPE, pfnPush, tmp1);
    PRINT_MEMBER(qwAddr, GENERIC_PIPE_TYPE, RPCRT4!GENERIC_PIPE_TYPE, pfnAlloc, tmp1);
    PRINT_MEMBER(qwAddr, GENERIC_PIPE_TYPE, RPCRT4!GENERIC_PIPE_TYPE, pState, tmp1);
}

void
do_pipemsg(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, Signature, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, PipeId, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, pPipeObject, tmp1);
    ULONG64 pPipeObject = tmp1;

    PRINT_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, pStubMsg, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, pTypeFormat, tmp1);

    ULONG64 PipeStatusVal;
    ULONG64 PipeFlagsVal;
    GET_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, PipeStatus, PipeStatusVal);
    GET_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, PipeFlags, PipeFlagsVal);
    dprintf("pipe status %5s\n", PipeStatus((unsigned short)PipeStatusVal));
    dprintf("pipe flags  %s\n", PipeFlags((unsigned short)PipeStatusVal));

    do_pipearg(pPipeObject );
}

void
async_flags(
    NDR_ASYNC_CALL_FLAGS flags
    )
{
    dprintf("   flags %4x: ", *(unsigned short *)&flags );
    if ( flags.ValidCallPending )
        dprintf(" call pending, " );
    if ( flags.ErrorPending )
        dprintf(" err pending, " );
    if ( flags.BadStubData )
        dprintf(" BSD, " );
    if ( flags.RuntimeCleanedUp )
        dprintf(" rt cleaned, " );
    if ( flags.HandlelessObjCall )
        dprintf(" autocomplete, " );
    if ( flags.Unused )
        dprintf(" Unused %4x ", flags.Unused );
    dprintf("-\n" );

}

char * AsyncPhaseString[5] =
    {
    "zero",
    "prep : initialized",
    "set :  (cl) after get buffer and ( cl | srv) register call",
    "call : cl after marshaling, calling send",
    "error : exception taken"
    };

void
async_stub_phase(
    unsigned short phase
    )
{
    dprintf("   phase %4x: ", phase );
    if ( 0 <= phase  &&  phase < 5 )
        dprintf(" %s\n", AsyncPhaseString[ phase ] );
    else
        dprintf(" unknown??\n" );
}

typedef struct _NDR_ASYNC_OBJ_HANDLE
{
    void *              pIAMvtble;
    void *              pICMvtble;
    NDR_ASYNC_MESSAGE * _pAsyncMsg;
    unsigned long       _Lock;
    unsigned long       _Signature;
    GUID                _iid;
    void *              _InnerUnknown;
    unsigned long       _iRef;
    void *              _pParent;
    void *              _pControl;
    void *              _pSyncInner;
    unsigned long       _fAutoComplete;
} NDR_ASYNC_OBJ_HANDLE;


void
do_asyncdcom(
    ULONG64 qwAddr
    )
{
    if (fUseTypeInfo) {
      dprintf("Can't dump NDR_ASYNC_OBJ_HANDLE when using type info\n");
    }
    else {
        BOOL b;
        char block[sizeof(NDR_ASYNC_OBJ_HANDLE)];

        b = GetData(qwAddr, block, sizeof(block));
        if ( !b ) {
          dprintf("can't read %p\n", qwAddr);
          return;
        }

        NDR_ASYNC_OBJ_HANDLE * msg = (NDR_ASYNC_OBJ_HANDLE *) block;

        dprintf("\n");
        dprintf(" pIAMvtble %p  pICMvtble %p   asyncmsg %p  lock     %8lx\n",
                msg->pIAMvtble, msg->pICMvtble,  msg->_pAsyncMsg, msg->_Lock );
        dprintf(" innerpUnk %p  iref      %8lx   pParent  %p  pControl %p\n",
                msg->_InnerUnknown,msg->_iRef,   msg->_pParent,msg->_pControl );
        dprintf(" Signature %8lx  iid       ", msg->_Signature ); PrintUuidLocal( & msg->_iid );dprintf("\n");
        dprintf(" innerSync %p  autocompl %d\n",
                msg->_pSyncInner,msg->_fAutoComplete );
    }
}

void
do_asyncrpc(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;

    dprintf("\n");

    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Size, tmp1); 
    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Signature, tmp1); 
    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Lock, tmp1); 
    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Flags, tmp1); 
    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, StubInfo, tmp1); 
    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, UserInfo, tmp1); 
    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, RuntimeInfo, tmp1); 
}

void
do_asyncmsg(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, Signature, tmp1);
    PRINT_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, Version, tmp1);
    PRINT_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, AsyncHandle, tmp1);
    PRINT_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, ProcContext, tmp1);

    ULONG64 Flags;
    GET_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, Flags, Flags);
    async_flags( *((NDR_ASYNC_CALL_FLAGS*)&Flags) );

    ULONG64 StubPhase;
    GET_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, StubPhase, StubPhase);
    async_stub_phase( (unsigned short) StubPhase );

    ULONG64 StubMsg;
    GET_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, StubMsg, StubMsg);
    do_stubmsg( StubMsg );
}

//
// Datagram stuff
//

char * PacketFlagStrings[8] =
{
    "forwarded ",
    "lastfrag ",
    "frag ",
    "nofack ",
    "maybe ",
    "idem ",
    "broadcast ",
    "flags-0x80 "
};

char * PacketFlag2Strings[8] =
{
    "fragmented ",
    "cancel-pending ",
    "flags2-0x04 ",
    "flags2-0x08 ",
    "flags2-0x10 ",
    "flags2-0x20 ",
    "flags2-0x40 ",
    "flags2-0x80 "
};

char *
PrintPacketFlags(
    unsigned char PacketFlags1,
    unsigned char PacketFlags2
    )
{
    static char buf[160];
    unsigned char Flags;
    unsigned i;

    buf[0] = 0;

    Flags = PacketFlags1;
    for (i=0; i < 8; i++)
        {
        if (Flags & 1)
            {
            strcat(buf, PacketFlagStrings[i]);
            }

        Flags >>= 1;
        }

    Flags = PacketFlags2;
    for (i=0; i < 8; i++)
        {
        if (Flags & 1)
            {
            strcat(buf, PacketFlag2Strings[i]);
            }

        Flags >>= 1;
        }

    return buf;
}

char * PacketTypes[] =
{
    "REQ ",
    "PING",
    "RESP",
    "FLT ",
    "WORK",
    "NOCA",
    "REJ ",
    "ACK ",
    "QUIT",
    "FACK",
    "QACK"
};

char *
PrintPacketType(
    unsigned char PacketType
    )
{
    static char buf[40];

    if (PacketType < sizeof(PacketTypes)/sizeof(PacketTypes[0]))
        {
        return PacketTypes[PacketType];
        }

    sprintf(buf, "illegal packet type %x ", PacketType);

    return buf;
}

VOID
do_dgpkt(
    ULONG64 p
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER(p, DG_PACKET, RPCRT4!DG_PACKET, MaxDataLength, tmp1);
    PRINT_MEMBER(p, DG_PACKET, RPCRT4!DG_PACKET, TimeReceived, tmp1);
    PRINT_MEMBER(p, DG_PACKET, RPCRT4!DG_PACKET, DataLength, tmp1);
    PRINT_MEMBER(p, DG_PACKET, RPCRT4!DG_PACKET, pNext, tmp1);
    PRINT_MEMBER(p, DG_PACKET, RPCRT4!DG_PACKET, pPrevious, tmp1);

    ULONG64 Header;
    GET_ADDRESS_OF(p, DG_PACKET, RPCRT4!DG_PACKET, Header, Header, tmp2);

    do_dgpkthdr(Header);
}

VOID
do_dgpkthdr(
    ULONG64 h
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, PacketType, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, RpcVersion, tmp1);

    ULONG64 PacketFlags;
    ULONG64 PacketFlags2;
    GET_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, PacketFlags, PacketFlags);
    GET_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, PacketFlags2, PacketFlags2);
    dprintf("flags: %s\n", PrintPacketFlags((unsigned char)PacketFlags, (unsigned char)PacketFlags2));

    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, FragmentNumber, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, PacketBodyLen, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, SerialLo, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, DataRep, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, ServerBootTime, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, AuthProto, tmp1);

    dprintf("  activity  ");
    ULONG64 ActivityId;
    GET_ADDRESS_OF(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, ActivityId, ActivityId, tmp2);
    PrintUuid(ActivityId);
    dprintf("\n");

    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, ActivityHint, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, SequenceNumber, tmp1);

    dprintf("  interface ");
    ULONG64 InterfaceId;
    GET_ADDRESS_OF(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, InterfaceId, InterfaceId, tmp2);
    PrintUuid(InterfaceId);
    dprintf("\n");

    ULONG64 InterfaceVersion;
    GET_ADDRESS_OF(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, InterfaceVersion, InterfaceVersion, tmp2);
    PRINT_MEMBER(h, _RPC_VERSION, RPCRT4!_RPC_VERSION, MajorVersion, tmp1);
    PRINT_MEMBER(h, _RPC_VERSION, RPCRT4!_RPC_VERSION, MinorVersion, tmp1);

    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, InterfaceHint, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, OperationNumber, tmp1);

    PRINT_ADDRESS_OF(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, ObjectId, tmp2);

    dprintf("\n");
}

void
do_assoctable(
      ULONG64 qwAddr
      )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("DG_ASSOCIATION_TABLE at 0x%I64x:\n", qwAddr);

    ULONG64 CasUuid;
    ULONG64 fCasUuidReady;
    GET_MEMBER(qwAddr, DG_ASSOCIATION_TABLE, RPCRT4!DG_ASSOCIATION_TABLE, CasUuid, CasUuid);
    GET_MEMBER(qwAddr, DG_ASSOCIATION_TABLE, RPCRT4!DG_ASSOCIATION_TABLE, fCasUuidReady, fCasUuidReady);

    dprintf("  CAS: ");  PrintUuid( CasUuid );
    dprintf(", %svalid\n", (ULONG)fCasUuidReady ? "" : "not ");

    dprintf("\n");

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, DG_ASSOCIATION_TABLE, RPCRT4!DG_ASSOCIATION_TABLE, Mutex, "&Mutex (CSharedLock)", tmp2);

    ULONG64 Associations;
    ULONG64 AssociationsLength;
    GET_MEMBER(qwAddr, DG_ASSOCIATION_TABLE, RPCRT4!DG_ASSOCIATION_TABLE, Associations, Associations);
    GET_MEMBER(qwAddr, DG_ASSOCIATION_TABLE, RPCRT4!DG_ASSOCIATION_TABLE, AssociationsLength, AssociationsLength); 
    dprintf("association array at 0x%I64x, %x elements\n", Associations, AssociationsLength);
}


char *
strtok(
    char *String
    )
{
    char * Word;
    static char * End;

    if (String)
        {
        Word = String;
        }
    else if (!End)
        {
        return 0;
        }
    else
        {
        Word = End+1;
        }

    while (*Word == ' ' || *Word == '\t')
        {
        ++Word;
        }

    if (!*Word)
        {
        End = 0;
        return 0;
        }

    End = Word;
    while (*End && *End != ' ' && *End != '\t')
        {
        ++End;
        }

    if (!*End)
        {
        End = 0;
        }
    else
        {
        *End = 0;
        }

    return Word;
}

BOOL
IsMember(
         char Item,
         char * List
         )
{
    BOOL Mask = FALSE;
    if (List[0] == '~')
        {
        Mask = TRUE;
        }

    while (*List)
        {
        if (Item == *List)
            {
            return TRUE ^ Mask;
            }
        ++List;
        }

    return FALSE ^ Mask;
}

BOOL
FetchEvent(
    IN ULONG_PTR RpcEvents,
    IN unsigned Index,
    IN struct RPC_EVENT * Entry
    )
{
    return GetData(RpcEvents + Index * sizeof(struct RPC_EVENT), Entry, sizeof(struct RPC_EVENT));
}

BOOL
FetchEventAddress(
    IN ULONG64 RpcEvents,
    IN int Index,
    IN PULONG64 EntryAddress
    )
{
    static ULONG EntrySize = 0;

    if (EntrySize == 0) {
        EntrySize = GetTypeSize("RPCRT4!RPC_EVENT");
        if (EntrySize == 0) {
            return FALSE;
        }
    }

    *EntryAddress = RpcEvents + Index * EntrySize;

    return TRUE;
}

BOOL
DoesEntryMatch(
    IN struct RPC_EVENT * Entry,
    IN char * Subjects,
    IN char * verbs,
    IN DWORD thread,
    IN ULONG_PTR addr,
    IN ULONG_PTR obj_addr
    )
{
    if (!Entry->Subject)
        {
        return FALSE;
        }

    if (Subjects && !IsMember(Entry->Subject, Subjects))
        {
        return FALSE;
        }

    if (verbs && !IsMember(Entry->Verb, verbs))
        {
        return FALSE;
        }

    if (thread && Entry->Thread != (unsigned short) thread)
        {
        return FALSE;
        }

    if (addr && Entry->SubjectPointer != (void *) addr)
        {
        return FALSE;
        }

    if (obj_addr && Entry->ObjectPointer != (void *) obj_addr)
        {
        return FALSE;
        }

    return TRUE;
}

BOOL
DoesEntryAddressMatch(
    IN ULONG64 Entry,
    IN char * Subjects,
    IN char * verbs,
    IN DWORD thread,
    IN ULONG64 addr,
    IN ULONG64 obj_addr
    )
{
    ULONG64 tmp;
    char item;

    GET_MEMBER_NORET_NOSPEW(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Subject, tmp);

    if (!tmp)
        {
        return FALSE;
        }

    if (Subjects && !IsMember((char)tmp, Subjects))
        {
        return FALSE;
        }

    GET_MEMBER_NORET_NOSPEW(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Verb, tmp);

    if (verbs && !IsMember((char)tmp, verbs))
        {
        return FALSE;
        }

    GET_MEMBER_NORET_NOSPEW(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Thread, tmp);

    if (thread && tmp != (unsigned short) thread)
        {
        return FALSE;
        }

    GET_MEMBER_NORET_NOSPEW(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, SubjectPointer, tmp);

    if (addr && tmp != addr)
        {
        return FALSE;
        }

    GET_MEMBER_NORET_NOSPEW(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, ObjectPointer, tmp);

    if (obj_addr && tmp != obj_addr)
        {
        return FALSE;
        }

    return TRUE;
}

char * DgPacketTypes[] =
{
    "REQ",
    "PING",
    "RESP",
    "FAULT",

    "WORKING",
    "NOCALL",
    "REJECT",
    "ACK",

    "QUIT",
    "FACK",
    "QUACK",
    "BIND",
    "BIND-ACK",

    "BIND_NAK",
    "ALTER-CXT",
    "ALTER-RESP",
    "AUTH-3",
    "SHUTDOWN",

    "CANCEL",
    "ORPHAN"
};

char * ScallStates[] =
{
    "Init",
    "BeforeDispatch",
    "Dispatched",
    "DispatchedWithCompleteData",
    "AfterDispatch",
    "SendingResponse",
    "Complete"
};

char * CcallStates[] =
{
    "Init",
    "Quiescent",
    "Send",
    "SendReceive",
    "Receive",
    "CancellingSend",
    "Complete"
};

char * HandleTypeStrings[] =
{
    "wmsg_cas     ",
    "wmsg_handle  ",
    "dg_ccall     ",
    "dg_scall     ",
    "dg_binding   ",
    "osf_ccall    ",
    "osf_scall    ",
    "osf_cconn    ",
    "osf_sconn    ",
    "osf_cassoc   ",
    "osf_assoc    ",
    "osf_address  ",
    "lrpc_ccall   ",
    "lrpc_scall   ",
    "lrpc_cassoc  ",
    "lrpc_sassoc  ",
    "lrpc_binding ",
    "svr_binding  ",
    "dg_cconn     ",
    "dg_sconn     ",
    "osf_binding  ",
    "dg_callback  ",
    "dg_address   ",
    "lrpc_address ",
    "dg_assoc     "
};

char *
GetHandleType(
    void * Value
    )
{
    int i;

    for (i=0; i < sizeof(HandleTypeStrings)/sizeof(char *); ++i)
        {
        if ((1UL << i) == PtrToUlong(Value))
            {
            return HandleTypeStrings[i];
            }
        }

    static char scratch[40];

    sprintf(scratch, "refobj %p", Value);
    return scratch;
}

char *
GetHandleTypeAddr(
    ULONG64 Pointer
    )
{
    int i;

    for (i=0; i < sizeof(HandleTypeStrings)/sizeof(char *); ++i)
        {
        if ((1UL << i) == Pointer)
            {
            return HandleTypeStrings[i];
            }
        }

    static char scratch[40];

    sprintf(scratch, "refobj %.6x", Pointer);
    return scratch;
}

int
PrintEntry(
    IN struct RPC_EVENT * Entry,
    IN ULONG index,
    IN BOOL ShowStack
    )
{
    char * Subject;
    char * Verb;
    BOOL Printed = FALSE;

    switch (Entry->Subject)
        {
        case SU_HANDLE   : Subject = "binding     "; break;
        case SU_CCONN    : Subject = "cconn       "; break;
        case SU_SCONN    : Subject = "sconn       "; break;
        case SU_CASSOC   : Subject = "cassoc      "; break;
        case SU_SASSOC   : Subject = "sassoc      "; break;
        case SU_CCALL    : Subject = "ccall       "; break;
        case SU_SCALL    : Subject = "scall       "; break;
        case SU_PACKET   : Subject = "packet      "; break;
        case SU_CENDPOINT: Subject = "endpnt      "; break;
        case SU_ENGINE   : Subject = " call       "; break;
        case SU_ASSOC    : Subject = " assoc      "; break;
        case SU_MUTEX    : Subject = "mutex       "; break;
        case SU_STABLE   : Subject = "sc tabl     "; break;
        case SU_BCACHE   : Subject = "bcache      "; break;
        case SU_HEAP     : Subject = "heap        "; break;
        case SU_THREAD   : Subject = "thread      "; break;
        case SU_EVENT    : Subject = "event       "; break;
        case SU_TRANS_CONN:Subject = "trans conn  "; break;
        case SU_ADDRESS  : Subject = "address     "; break;
        case SU_EXCEPT   : Subject = "exception   "; break;
        case SU_REFOBJ   :
            {
            Subject = GetHandleType(Entry->ObjectPointer);
            break;
            }
        case SU_CTXHANDLE: Subject = "ctx handle  "; break;
        default:
            {
            static char string[4];
            Subject = string;

            Subject[0] = '\"';
            Subject[1] = Entry->Subject;
            Subject[2] = '\"';
            Subject[3] = '\0';
            break;
            }
        }

    dprintf("%5x: %06.6d.%03.3d/%-4x  %s %p ", index, Entry->Time /1000, Entry->Time % 1000, Entry->Thread, Subject, Entry->SubjectPointer);

    Verb = "(extension bug)";

    switch (Entry->Verb)
        {
        case EV_CREATE    : Verb = "create   "; break;
        case EV_DELETE    : Verb = "delete   "; break;
        case EV_START     : Verb = "active   "; break;
        case EV_STOP      : Verb = "inactive "; break;
        case EV_INC       : Verb = "ref++    "; break;
        case EV_DEC       : Verb = "ref--    "; break;
        case EV_ACK       : Verb = "ack sent "; break;
        case EV_NOTIFY    : Verb = "notify   "; break;
        case EV_APC       : Verb = "APC fired"; break;
        case EV_RESOLVED  : Verb = "resolved "; break;
        case EV_REMOVED   : Verb = "removed  "; break;
        case EV_CLEANUP   : Verb = "cleanup  "; break;
        case EV_SEC_INIT1   : Verb = "init SC 1"; break;
        case EV_SEC_INIT3   : Verb = "init SC 3"; break;
        case EV_SEC_ACCEPT1 : Verb = "accptSC 1"; break;
        case EV_SEC_ACCEPT3 : Verb = "accptSC 3"; break;
        case EV_STATUS:
            {
            if (Entry->Subject != SU_EXCEPT)
                {
                if (Entry->ObjectPointer)
                    {
                    dprintf("status %lx, location %d", Entry->Data, Entry->ObjectPointer);
                    }
                else
                    {
                    dprintf("status %lx", Entry->Data);
                    }
                Printed = TRUE;
                break;
                }
            else
                {
                dprintf("exception info: %lx, %lx, %lx", Entry->SubjectPointer, Entry->ObjectPointer, Entry->Data);
                Printed = TRUE;
                break;
                }
            }
        case EV_DISASSOC  : Verb = "disassoc "; break;
        case EV_STATE:
            {
            char * state = "----";

            if (Entry->Subject == SU_CCALL)
                {
                if (Entry->Data < DG_CCALL::CallInit     ||
                    Entry->Data > DG_CCALL::CallComplete )
                    {
                    dprintf("unknown state 0x%x", Entry->Data);
                    Printed = TRUE;
                    }
                else
                    {
                    state = CcallStates[Entry->Data - DG_CCALL::CallInit];
                    }
                }
            else
                {
                if (Entry->Data < DG_SCALL::CallInit     ||
                    Entry->Data > DG_SCALL::CallComplete )
                    {
                    dprintf("unknown state 0x%x", Entry->Data);
                    Printed = TRUE;
                    }
                else
                    {
                    state = ScallStates[Entry->Data - DG_SCALL::CallInit];
                    }
                }

            if (!Printed)
                {
                dprintf("state %s", state);
                Printed = TRUE;
                }

            break;
            }
        case EV_POP       : Verb = "pop      "; break;
        case EV_PUSH      : Verb = "push     "; break;
        case EV_PKT_IN:
            {
            unsigned short frag  = (unsigned short) (Entry->Data);
            unsigned short ptype = (unsigned short) (Entry->Data >> 16);
            char * ptypestring;

            if (ptype >= sizeof(DgPacketTypes)/sizeof(DgPacketTypes[0]))
                {
                dprintf("recv pkt unknown type 0x%hx", ptype);
                Printed = TRUE;
                }
            else
                {
                ptypestring = DgPacketTypes[ptype];
                }

            if (!Printed)
                {
                if (Entry->ObjectPointer)
                    {
                    dprintf("recv pkt %s frag %hx, location %d", ptypestring, frag, Entry->ObjectPointer);
                    }
                else
                    {
                    dprintf("recv pkt %s frag/len %hx", ptypestring, frag);
                    }
                Printed = TRUE;
                }
            break;
            }

        case EV_BUFFER_IN : Verb = "buf    in"; break;
        case EV_BUFFER_OUT: Verb = "buf   out"; break;
        case EV_TRANSFER:   Verb = "xfer call"; break;
        case EV_DROP:       Verb = "dropped  "; break;
        case EV_DELAY:      Verb = "delayed  "; break;
        case EV_CALLBACK:   Verb = "callback "; break;

        default:
            {
            static char string[4];
            Verb = string;

            Verb[0] = '\"';
            Verb[1] = Entry->Verb;
            Verb[2] = '\"';
            Verb[3] = '\0';
            break;
            }
        case 'p':
            {
            if (Entry->Subject == SU_STABLE)
                {
                Verb = "prune    ";
                }
            else
                {
                DWORD buf[2];
                buf[0] = (DWORD) Entry->Data;
                buf[1] = 0;

                dprintf("proc %s  %p", (char *) buf, Entry->ObjectPointer);

                Printed = TRUE;
                }
            break;
            }
        case EV_PKT_OUT:
            {
            unsigned short frag  = (unsigned short) (Entry->Data);
            unsigned short ptype = (unsigned short) (Entry->Data >> 16);
            char * ptypestring;

            if (ptype >= sizeof(DgPacketTypes)/sizeof(DgPacketTypes[0]))
                {
                ptypestring = "???";
                }
            else
                {
                ptypestring = DgPacketTypes[ptype];
                }

            dprintf("sent pkt %s frag/len %hx", ptypestring, frag);
            Printed = TRUE;
            break;
            }
        }

    if (!Printed)
        {
        dprintf("%s  %p %p", Verb, Entry->ObjectPointer, Entry->Data);
        }

    dprintf("\n");

    int LinesPrinted = 1;

    if (ShowStack && Entry->EventStackTrace[0])
        {
        int i;

        for (i = 0; Entry->EventStackTrace[i] && i < STACKTRACE_DEPTH; i++)
            {
            dprintf("        ");
            do_symbol((ULONG_PTR) Entry->EventStackTrace[i]);
            ++LinesPrinted;
            }
        }

    return LinesPrinted;
}

int
PrintEntryAddress(
    IN ULONG64 Entry,
    IN int index,
    IN BOOL ShowStack
    )
{
    char * Subject;
    char * Verb;
    BOOL Printed = FALSE;

    ULONG tmp;

    ULONG64 Time = 0;
    ULONG64 Thread = 0;
    ULONG64 SubjectPointer = 0;
    ULONG64 ObjectPointer = 0;
    ULONG64 SubjectData = 0;
    ULONG64 VerbData = 0;
    ULONG64 Data = 0;
    ULONG64 EventStackTraceAddress =0 ;
    ULONG64 EventStackTrace_0 = 0;

    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Time, Time);
    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Thread, Thread);
    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, SubjectPointer, SubjectPointer);
    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Subject, SubjectData);
    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, ObjectPointer, ObjectPointer);
    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Verb, VerbData);
    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Data, Data);
    GET_ADDRESS_OF(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, EventStackTrace, EventStackTraceAddress, tmp);

    ReadPtrUnextend(EventStackTraceAddress, &EventStackTrace_0);

    switch ((char)SubjectData)
        {
        case SU_HANDLE   : Subject = "binding      "; break;
        case SU_CCONN    : Subject = "cconn        "; break;
        case SU_SCONN    : Subject = "sconn        "; break;
        case SU_CASSOC   : Subject = "cassoc       "; break;
        case SU_SASSOC   : Subject = "sassoc       "; break;
        case SU_CCALL    : Subject = "ccall        "; break;
        case SU_SCALL    : Subject = "scall        "; break;
        case SU_PACKET   : Subject = "packet       "; break;
        case SU_CENDPOINT: Subject = "endpnt       "; break;
        case SU_ENGINE   : Subject = " call        "; break;
        case SU_ASSOC    : Subject = " assoc       "; break;
        case SU_MUTEX    : Subject = "mutex        "; break;
        case SU_STABLE   : Subject = "sc tabl      "; break;
        case SU_BCACHE   : Subject = "bcache       "; break;
        case SU_HEAP     : Subject = "heap         "; break;
        case SU_THREAD   : Subject = "thread       "; break;
        case SU_EVENT    : Subject = "event        "; break;
        case SU_TRANS_CONN:Subject = "trans conn   "; break;
        case SU_ADDRESS  : Subject = "address      "; break;
        case SU_EXCEPT   : Subject = "exception    "; break;
        case SU_REFOBJ   :
            {
            Subject = GetHandleTypeAddr(ObjectPointer);
            break;
            }
        case SU_CTXHANDLE: Subject = "ctx handle   "; break;
        case SU_EEINFO   : Subject = "EEInfo       "; break;

        default:
            {
            static char string[4];
            Subject = string;
            Subject[0] = '\"';
            Subject[1] = (char)SubjectData;
            Subject[2] = '\"';
            Subject[3] = '\0';

            break;
            }
        }

    dprintf("%5x: %06.6d.%03.3d/%-4x %s %I64p ", index, (ULONG)Time / 1000, (ULONG)Time % 1000, (ULONG)Thread, Subject, SubjectPointer);

    if (SubjectData != SU_EEINFO)
        {
        Verb = "(extension bug)";

        switch ((char)VerbData)
            {
            case EV_CREATE    : Verb = "create   "; break;
            case EV_DELETE    : Verb = "delete   "; break;
            case EV_START     : Verb = "active   "; break;
            case EV_STOP      : Verb = "inactive "; break;
            case EV_INC       : Verb = "ref++    "; break;
            case EV_DEC       : Verb = "ref--    "; break;
            case EV_ACK       : Verb = "ack sent "; break;
            case EV_NOTIFY    : Verb = "notify   "; break;
            case EV_APC       : Verb = "APC fired"; break;
            case EV_RESOLVED  : Verb = "resolved "; break;
            case EV_REMOVED   : Verb = "removed  "; break;
            case EV_CLEANUP   : Verb = "cleanup  "; break;
            case EV_SEC_INIT1   : Verb = "init SC 1"; break;
            case EV_SEC_INIT3   : Verb = "init SC 3"; break;
            case EV_SEC_ACCEPT1 : Verb = "accptSC 1"; break;
            case EV_SEC_ACCEPT3 : Verb = "accptSC 3"; break;
            case EV_STATUS:
                {
                if ((ULONG)SubjectData != SU_EXCEPT)
                    {
                    if (VerbData)
                        {
                        dprintf("status %lx, location %d", (ULONG)Data, (ULONG)ObjectPointer);
                        }
                    else
                        {
                        dprintf("status %lx", (ULONG)Data);
                        }
                    Printed = TRUE;
                    break;
                    }
                else
                    {
                    dprintf("exception info: %lx, %lx, %lx", (ULONG)SubjectPointer, (ULONG)ObjectPointer, (ULONG)Data);
                    Printed = TRUE;
                    break;
                    }
                }
            case EV_DISASSOC  : Verb = "disassoc "; break;
            case EV_STATE:
                {
                char * state = "----";

                if ((ULONG)SubjectData == SU_CCALL)
                    {
                    if (Data < GetExpression("rpcrt4!DG_CCALL__CallInit") ||
                        Data > GetExpression("rpcrt4!DG_CCALL__CallComplete"))
                        {
                        dprintf("unknown state 0x%x", Data);
                        Printed = TRUE;
                        }
                    else
                        {
                        state = CcallStates[Data - GetExpression("rpcrt4!DG_CCALL__CallInit")];
                        }
                    }
                else
                    {
                    if (Data < GetExpression("RPCRT4!DG_SCALL__CallInit") ||
                        Data > GetExpression("RPCRT4!DG_SCALL__CallComplete"))
                        {
                        dprintf("unknown state 0x%x", Data);
                        Printed = TRUE;
                        }
                    else
                        {
                        state = ScallStates[Data - GetExpression("RPCRT4!DG_SCALL__CallInit")];
                        }
                    }

                if (!Printed)
                    {
                    dprintf("state %s", state);
                    Printed = TRUE;
                    }

                break;
                }
            case EV_POP       : Verb = "pop      "; break;
            case EV_PUSH      : Verb = "push     "; break;
            case EV_PKT_IN:
                {
                unsigned short frag  = (unsigned short) (Data);
                unsigned short ptype = (unsigned short) (Data >> 16);
                char * ptypestring;

                if (ptype >= sizeof(DgPacketTypes)/sizeof(DgPacketTypes[0]))
                    {
                    dprintf("recv pkt unknown type 0x%hx", ptype);
                    Printed = TRUE;
                    }
                else
                    {
                    ptypestring = DgPacketTypes[ptype];
                    }

                if (!Printed)
                    {
                    if (ObjectPointer)
                        {
                        dprintf("recv pkt %s frag %hx, location %d", ptypestring, frag, (ULONG)ObjectPointer);
                        }
                    else
                        {
                        dprintf("recv pkt %s frag/len %hx", ptypestring, frag);
                        }
                    Printed = TRUE;
                    }
                break;
                }

            case EV_BUFFER_IN : Verb = "buf    in"; break;
            case EV_BUFFER_OUT: Verb = "buf   out"; break;
            case EV_TRANSFER:   Verb = "xfer call"; break;
            case EV_DROP:       Verb = "dropped  "; break;
            case EV_DELAY:      Verb = "delayed  "; break;
            case EV_CALLBACK:   Verb = "callback "; break;

            default:
                {
                static char string[10];
                Verb = string;
                Verb[0] = '\"';
                Verb[1] = (char)VerbData;
                Verb[2] = '\"';
                Verb[3] = '\0';

                break;
                }

            case 'p':
                {
                if (SubjectData == SU_STABLE)
                    {
                    Verb = "prune    ";
                    }
                else
                    {
                    DWORD buf[2];
                    buf[0] = (DWORD) Data;
                    buf[1] = 0;

                    dprintf("proc %s  %I64x", (char *) buf, ObjectPointer);

                    Printed = TRUE;
                    }
                break;
                }

            case EV_PKT_OUT:
                {
                unsigned short frag  = (unsigned short) (Data);
                unsigned short ptype = (unsigned short) ((Data >> 16) & 0xFF);
                unsigned short opnum = (unsigned short) (Data >> 24);
                ULONG CallId = (ULONG)ObjectPointer;
                char * ptypestring;

                if (ptype >= sizeof(DgPacketTypes)/sizeof(DgPacketTypes[0]))
                    {
                    ptypestring = "???";
                    }
                else
                    {
                    ptypestring = DgPacketTypes[ptype];
                    }

                if (opnum)
                    {
                    dprintf("sent p %s fr/len %hx op# %d cid %d", ptypestring, frag, opnum, CallId);
                    }
                else
                    {
                    dprintf("sent p %s fr/len %hx cid %d", ptypestring, frag, CallId);
                    }
                Printed = TRUE;
                break;
                }
            }
        }
    else
        {
        // this is an eeinfo record
        dprintf("GC %d St %d DL %d P#1 %d", (ULONG)VerbData, (ULONG)SubjectPointer, (ULONG)ObjectPointer, (ULONG)Data);
        Printed = TRUE;
        }

    if (!Printed)
        {
        dprintf("%s  %I64p %I64p", Verb, ObjectPointer, Data);
        }

    dprintf("\n");

    int LinesPrinted = 1;

    if (ShowStack && EventStackTrace_0) {
        int i = 0;
        ULONG64 StackEntry = 0;

        do {
            if (!ReadPtrUnextend(EventStackTraceAddress + i * AddressSize, &StackEntry)) {

                dprintf("        ");
                do_symbol(StackEntry);
                ++LinesPrinted;
                ++i;
            }
        }
        while (StackEntry && i < STACKTRACE_DEPTH);
    }

    return LinesPrinted;
}

void scan_usage()
{
    dprintf("options:\n"
            "\n"
            "    -sXYZ          print entries with subject character == X or Y or Z\n"
            "    -vXYZ          print entries with verb    character == X or Y or Z\n"
            "    -s~XYZ         print entries with subject character != X or Y or Z\n"
            "    -v~XYZ         print entries with verb    character != X or Y or Z\n"
            "    -t NNNN        print entries for thread NNNN            \n"
            "    -a NNNN        print entries for subject at address NNNN \n"
            "    -o NNNN        print entries for  object at address NNNN \n"
            "    -k or -k+      show stack traces if available\n"
            "    -k-            don't show stack traces (default)\n"
            "    -b NNNN1 NNNN2 NNNN3  \n"
            "                   (if symbols are broken) RpcEvents is at NNNN1"
            "                   and NextEvent is NNNN2\n"
            "                   and event array length is NNNN3\n"
            "    -NNNN          print the NNNN entries ending with NextEvent (or specified base)\n"
            "    +NNNN          print the NNNN entries starting with NextEvent (or specified base)\n"
            "    NNNN           the base index is NNNN"
            "    -f filename    reads a binary version of the log and displays it as text\n"
            "\n"
            "e.g. '!scan -40 -sN' would print the last 40 DG_SCONNECTION events\n"
            "     '!scan +30 200' would print 30 entries starting at index 200\n"
            );
}

char VerbsToDisplay[40];
char SubjectsToDisplay[40];

DECLARE_API( scan )
{
    char * Subject = 0;
    char * verb = 0;
    ULONG64 addr = 0;
    ULONG64 obj_addr = 0;
    DWORD thread = 0;

    static ULONG64 RpcEvents = 0;
    static LONG EventArrayLength = 0;

    static LONG NextEvent = 0;

    int   RequestCount = 30;
    int   NextEventToPrint = 0;
    BOOL  ForwardSearch = FALSE;
    BOOL  ShowStackTraces = FALSE;

    BOOL Wrapped = FALSE;
    int BaseIndex = -1;
    int MatchCount = 0;
    int index;
    int i;

    BOOL fFileInput = FALSE;
    HANDLE hFile;

    struct RPC_EVENT Entry;

    ULONG64 EntryAddress;
    ULONG64 tmp;

    //
    // Interpret options.
    //
    char * arg;

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        if (arg[0] == '-')
            {
            ++arg;

            switch (arg[0])
                {
                case 's':
                    {
                    if (!arg[1])
                        {
                        scan_usage();
                        return;
                        }

                    if (strlen(arg+1) >= sizeof(SubjectsToDisplay))
                        {
                        dprintf("-s: too many subject types proposed\n");
                        return;
                        }

                    strcpy(SubjectsToDisplay, arg+1);
                    Subject = SubjectsToDisplay;
                    if (Subject[0] == '*')
                        {
                        Subject = 0;
                        }
                    break;
                    }

                case 'v':
                    {
                    if (!arg[1])
                        {
                        scan_usage();
                        return;
                        }

                    if (strlen(arg+1) >= sizeof(VerbsToDisplay))
                        {
                        dprintf("-v: too many verbs proposed\n");
                        return;
                        }

                    strcpy(VerbsToDisplay, arg+1);
                    verb = VerbsToDisplay;
                    if (verb[0] == '*')
                        {
                        verb = 0;
                        }
                    break;
                    }

                case 'a':
                    {
                    if (arg[1])
                        {
                        scan_usage();
                        return;
                        }

                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-a: no object address specified\n");
                        return;
                        }

                    addr = GetExpression(arg);

                    if (!addr)
                        {
                        dprintf("-a: can't evaluate %s\n", arg);
                        return;
                        }

                    break;
                    }

                case 'o':
                    {
                    if (arg[1])
                        {
                        scan_usage();
                        return;
                        }

                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-o: no object address specified\n");
                        return;
                        }

                    obj_addr = GetExpression(arg);

                    if (!obj_addr)
                        {
                        dprintf("-o: can't evaluate %s\n", arg);
                        return;
                        }

                    break;
                    }

                case 't':
                    {
                    if (arg[1])
                        {
                        scan_usage();
                        return;
                        }

                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-t: no thread ID specified\n");
                        return;
                        }

                    thread = (DWORD) GetExpression(arg);

                    if (!thread)
                        {
                        dprintf("-t: can't evaluate %s\n", arg);
                        return;
                        }
                    break;
                    }

                case 'b':
                    {
                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-b: no base address specified\n");
                        return;
                        }

                    RpcEvents = GetExpression(arg);

                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-b: no NextEvent specified\n");
                        return;
                        }

                    NextEvent = (LONG) GetExpression(arg);

                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-b: no event array length specified\n");
                        return;
                        }

                    EventArrayLength = (long) GetExpression(arg);

                    break;
                    }

                case 'k':
                    {
                    if (arg[1] == '+' ||
                        arg[1] == '\0')
                        {
                        ShowStackTraces = TRUE;
                        }
                    else if (arg[1] == '-')
                        {
                        ShowStackTraces = FALSE;
                        }
                    else
                        {
                        dprintf("-k:  use '-k' or '-k+' for stack traces, '-k-' for none\n");
                        return;
                        }
                    break;
                    }

                case 'f':
                    {
                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-f: no file name specified\n");
                        return;
                        }

                    hFile = CreateFileA(arg, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL);
                    if (hFile == INVALID_HANDLE_VALUE)
                        {
                        dprintf("-f: Couldn't open file name %s - error %d\n", arg, GetLastError());
                        return;
                        }

                    fFileInput = TRUE;
                    }
                    break;

                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    {
                    ForwardSearch = FALSE;
                    RequestCount = myatol(arg);

                    if (!RequestCount)
                        {
                        dprintf("-%s: zero lines specified\n", arg);
                        return;
                        }
                    break;
                    }

                default:
                    {
                    dprintf("unknown option %s\n", arg);
                    scan_usage();
                    return;
                    }
                }
            }
        else if (arg[0] == '+')
            {
            ++arg;
            RequestCount = myatol(arg);

            if (!RequestCount)
                {
                dprintf("+%s: zero lines specified\n", arg);
                return;
                }

            MatchCount = RequestCount;
            ForwardSearch = TRUE;
            }
        else
            {
            BaseIndex = (int) GetExpression(arg);
            }
        }

    if (fFileInput)
        {
        BOOL Result;
        DWORD NumberOfBytesRead;
        index = 1;

        while (1)
            {
            Result = ReadFile(hFile, &Entry, sizeof(Entry), &NumberOfBytesRead, NULL);
            if (!Result)
                {
                dprintf("-f: Error reading file: %d\n", GetLastError());
                break;
                }

            if (NumberOfBytesRead < sizeof(Entry))
                {
                dprintf("-f: EOF reached\n");
                break;
                }

            PrintEntry(&Entry, index, ShowStackTraces);

            index ++;

            if ((CheckControlC)())
                {
                CloseHandle(hFile);
                return;
                }
            }

        CloseHandle(hFile);
        return;
        }

    ULONG64 NextEventAddress = GetExpression("rpcrt4!NextEvent");
    ULONG64 EventLengthAddress = GetExpression("rpcrt4!EventArrayLength");

    //
    // Find the current event.
    //
    if (!RpcEvents)
        {
        RpcEvents = GetExpression("rpcrt4!RpcEvents");

        if (!RpcEvents || !NextEventAddress)
            {
            dprintf("I can't find rpcrt4!RpcEvents or rpcrt4!NextEvent; use -b\n");
            return;
            }

        if (!ReadMemory(NextEventAddress, &NextEvent, sizeof(DWORD), 0))
            {
            dprintf("I can't read NextEvent from 0x%I64x\n", NextEventAddress);
            return;
            }

        if (EventLengthAddress)
            {
            if (!ReadMemory(EventLengthAddress, &EventArrayLength, sizeof(DWORD), 0))
                {
                dprintf("I can't read EventArrayLength from 0x%I64x\n", EventLengthAddress);
                return;
                }

            if (!ReadMemory(RpcEvents, &tmp, sizeof(ULONG64), 0))
                {
                dprintf("I can't read rpcrt4!RpcEvents at 0x%I64x\n", RpcEvents);
                return;
                }

            RpcEvents = tmp;
            }
        else
            {
            dprintf("rpcrt4!EventArrayLength isn't defined; probably an older build\n");

            EventArrayLength = 4096;
            }

        dprintf("RpcEvents at 0x%I64x; array has %u entries; NextEvent = %lx, %s\n",
                RpcEvents, EventArrayLength, NextEvent, Wrapped ? "wrapped around" : "");
        }

    if (FALSE == FetchEventAddress(RpcEvents, 0, &EntryAddress))
        {
        dprintf("I can't read memory at 0x%I64x \n", RpcEvents);
        return;
        }
    
    GET_MEMBER(EntryAddress, RPC_EVENT, RPCRT4!RPC_EVENT, Subject, tmp);
    if (tmp)
        {
        Wrapped = TRUE;
        }

    if (thread || Subject || verb || addr || obj_addr)
        {
        dprintf("filter: ");
        }
    else
        {
        dprintf("no filter");
        }

    if (thread)
        {
        dprintf("thread %x ", thread);
        }
    if (Subject)
        {
        dprintf("subjects '%s' ", Subject);
        }
    if (verb)
        {
        dprintf("verbs '%s' ", verb);
        }
    if (addr)
        {
        dprintf("address %x ", addr);
        }
    if (obj_addr)
        {
        dprintf("direct-object address 0x%I64x ", obj_addr);
        }

    dprintf(", base index = %x\n", BaseIndex);

    // Allow one set of debug spew to be printed if some data can't 
    // be properly read or fields extracted.
    fSpew = TRUE;

    //
    // Scan backwards until we have enough matching events.
    //
    if (NextEvent > EventArrayLength)
        {
        NextEvent %= EventArrayLength;
        }

    if (ForwardSearch)
        {
        if (BaseIndex == -1)
            {
            BaseIndex = NextEventToPrint;
            }

        if (!Wrapped && BaseIndex + MatchCount > NextEvent+1)
            {
            MatchCount = NextEvent+1 - BaseIndex;
            }
        }
    else
        {
        if (BaseIndex == -1)
            {
            BaseIndex = NextEvent;
            }

        LONG Point = BaseIndex;

        for (index = Point; index >= 0 && MatchCount < RequestCount; --index )
            {
            if (FALSE == FetchEventAddress(RpcEvents, index, &EntryAddress))
                {
                dprintf("I can't read memory at index %x\n", index);
                return;
                }

            if (DoesEntryAddressMatch(EntryAddress, Subject, verb, thread, addr, obj_addr))
                {
                ++MatchCount;
                BaseIndex = index;
                }
            }

        if (Wrapped && MatchCount < RequestCount)
            {
            for (index = EventArrayLength-1; index > Point && MatchCount < RequestCount; --index )
                {
                if (FALSE == FetchEventAddress(RpcEvents, index, &EntryAddress))
                    {
                    dprintf("I can't read memory at index %d\n", index);
                    return;
                    }

                if (DoesEntryAddressMatch(EntryAddress, Subject, verb, thread, addr, obj_addr))
                    {
                    ++MatchCount;
                    BaseIndex = index;
                    }
                }
            }
        }

    //
    // Print matching events.
    //
    index = BaseIndex;

    do
        {
        if (FALSE == FetchEventAddress(RpcEvents, index, &EntryAddress))
            {
            dprintf("I can't read memory at index %x\n", index);
            return;
            }

        if (DoesEntryAddressMatch(EntryAddress, Subject, verb, thread, addr, obj_addr))
            {
            PrintEntryAddress(EntryAddress, index, ShowStackTraces);
            --MatchCount;
            }

        ++index;
        index = index % EventArrayLength;

        if ((CheckControlC)())
            {
            return;
            }
        }
    while (MatchCount && index != BaseIndex);

    NextEventToPrint = index;
}

DECLARE_API( rpctime )
{
    DWORD dwCurrentTime;

    if (fKD)
        {
        dprintf("Cannot dump time in kd\n");
        return;
        }

    dwCurrentTime = GetTickCount();
    dprintf("Current time is: %06.6d.%03.3d (0x%06.6x.%03.3x)\n", dwCurrentTime / 1000, dwCurrentTime % 1000,
        dwCurrentTime / 1000, dwCurrentTime % 1000);
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    if (fKD)
        {
        dprintf(
                "%s RPC Extension dll for Build %d debugging %s kernel for Build %d\n",
                kind,
                VER_PRODUCTBUILD,
                SavedMajorVersion == 0x0c ? "Checked" : "Free",
                SavedMinorVersion
                );
        }
    else
        {
        dprintf(
                "%s RPC Extension dll for Build %d\n",
                kind,
                VER_PRODUCTBUILD
                );
        }
}

DECLARE_API( bcache )
{
    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 StateArray = 0;

    // For process cache
    ULONG64 Cache;
    ULONG64 CacheAddress;

    BOOL b, fGuardPageMode = FALSE;

    //
    // Interpret options.
    //
    char * arg1;
    char * arg2;

    LPSTR lpArgumentString = (LPSTR)args;

    arg1 = strtok(lpArgumentString);
    arg2 = strtok(0);

    if (arg2)
        {
        dprintf("usage:  \n"
                "        !bcache <TEB-address>  for a thread's cache\n"
                "        !bcache                for the process cache\n"
                "\n");
        return;
        }

    if (arg1)
        {
        ULONG64 RpcThread;

        ULONG64 pTeb = GetExpression(arg1);

        GET_MEMBER(pTeb, TEB, TEB, ReservedForNtRpc, RpcThread);

        GET_ADDRESS_OF(RpcThread, THREAD, RPCRT4!THREAD, BufferCache, StateArray, tmp2);
        }
    else
        {
        ULONG64 CachePointerAddress = GetExpression("rpcrt4!gBufferCache");

        if (!CachePointerAddress)
            {
            dprintf("can't find rpcrt4!gBufferCache\n");
            return;
            }

        b = GetData(CachePointerAddress, &CacheAddress, sizeof(PVOID));
        if ( !b )
            {
            dprintf("couldn't read process buffer cache pointer at %x\n", CacheAddress);
            return;
            }

        dprintf("process-wide buffer cache:\n");

        ULONG64 GuardPageMode = GetExpression("rpcrt4!fGuardPageMode");

        if(GuardPageMode)
            b = GetData(GuardPageMode, &fGuardPageMode, sizeof(fGuardPageMode));

        if (!b)
            {
            dprintf("couldn't read guard page mode flag at address %p\n", GuardPageMode);
            return;
            }

        if (fGuardPageMode)
            {
            dprintf("---> GUARD PAGE mode enabled!\n");
            }

        GET_ADDRESS_OF(CacheAddress, BCACHE, RPCRT4!BCACHE, _bcGlobalState, StateArray, tmp2);
        }

    //
    // Load the size hints.
    //
    ULONG64 HintAddress;

    HintAddress = GetExpression("rpcrt4!pHints");

    ReadPtrUnextend(HintAddress, &HintAddress);

    //
    // Dump the buffer states.
    //
    int i;
    ULONG64 State = StateArray;
    ULONG64 Hint = HintAddress;
    ULONG64 cBlocks;
    ULONG64 pList;
    ULONG64 cSize;

    for (i=0; i < 4; ++i)
        {
        GET_MEMBER(State, BCACHE_STATE, RPCRT4!BCACHE_STATE, cBlocks, cBlocks);
        GET_MEMBER(State, BCACHE_STATE, RPCRT4!BCACHE_STATE, pList, pList);
        GET_MEMBER(Hint, BUFFER_CACHE_HINTS, RPCRT4!BUFFER_CACHE_HINTS, cSize, cSize);

        dprintf("   count %5u    head %I64x     size %5x\n",
                (ULONG)cBlocks,
                pList,
                (ULONG)cSize);

        State += GET_TYPE_SIZE(BCACHE_STATE, RPCRT4!BCACHE_STATE);
        Hint += GET_TYPE_SIZE(BUFFER_CACHE_HINTS, RPCRT4!BUFFER_CACHE_HINTS);
        }

    if (!arg1)
        {
        ULONG64  _bcGlobalStats;
        GET_ADDRESS_OF(CacheAddress, BCACHE, RPCRT4!BCACHE, _bcGlobalStats, _bcGlobalStats, tmp2);

        // Dump out the bcache cache stats
        dprintf("\nGlobal Stats:\n     cap   hits misses\n");
        for (i = 0; i < ((fGuardPageMode) ? 2 : 4); i++)
            {
            ULONG64 cBufferCacheCap;
            ULONG64 cAllocationHits;
            ULONG64 cAllocationMisses;
            GET_MEMBER(_bcGlobalStats, BCACHE_STATS, RPCRT4!BCACHE_STATS, cBufferCacheCap, cBufferCacheCap);
            GET_MEMBER(_bcGlobalStats, BCACHE_STATS, RPCRT4!BCACHE_STATS, cAllocationHits, cAllocationHits);
            GET_MEMBER(_bcGlobalStats, BCACHE_STATS, RPCRT4!BCACHE_STATS, cAllocationMisses, cAllocationMisses);

            dprintf("   %5d  %5d  %5d\n",
                    cBufferCacheCap,
                    cAllocationHits,
                    cAllocationMisses);

            _bcGlobalStats += GET_TYPE_SIZE(BCACHE_STATS, RPCRT4!BCACHE_STATS);
            }
        }
}


VOID
CheckVersion(
    VOID
    )
{
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

void PrintGetCallInfoUsage(void)
{
    dprintf("Usage: \n\tgetcallinfo [CallID|0 [IfStart|0 [ProcNum|FFFF [ProcessID|0]]]]\n");
}

DECLARE_API( getcallinfo )
{
    ULONG CallID = 0;
    ULONG IfStart = 0;
    USHORT ProcNum = RPCDBG_NO_PROCNUM_SPECIFIED;
    ULONG ProcessID = 0;
    int ArgumentNo = 0;

    //
    // Interpret options.
    //
    char * arg;

    if (fKD != 0)
        {
        dprintf("This extension command does not work under kd\n");
        return;
        }

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        switch(ArgumentNo)
            {
            case 0:
                // either help or CallID
                if ((arg[0] == '?') || ((arg[0] == '-') && (arg[1] == '?')))
                    {
                    PrintGetCallInfoUsage();
                    return;
                    }
                else
                    {
                    CallID = (ULONG)GetExpression(arg);
                    }
                break;

            case 1:
                IfStart = (ULONG)GetExpression(arg);
                break;

            case 2:
                ProcNum = (unsigned short) GetExpression(arg);
                break;

            case 3:
                ProcessID = (ULONG)GetExpression(arg);
                break;

            default:
                dprintf("Too many arguments\n");
                PrintGetCallInfoUsage();

            }
        ArgumentNo ++;
        }

    GetAndPrintCallInfo(CallID, IfStart, ProcNum, ProcessID, dprintf);
}

void PrintGetDbgCellUsage(void)
{
    dprintf("Usage: \n\tgetdbgcell ProcessID CellID1.CellID2\n");
}

DECLARE_API( getdbgcell )
{
    ULONG ProcessID = 0;
    int ArgumentNo = 0;
    DebugCellID CellID;
    char *DotSeparator;

    CellID.SectionID = 0;
    CellID.CellID = 0;

    //
    // Interpret options.
    //
    char * arg;

    if (fKD != 0)
        {
        dprintf("This extension command does not work under kd\n");
        return;
        }

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        switch(ArgumentNo)
            {
            case 0:
                // either help or ProcessID
                if ((arg[0] == '?') || ((arg[0] == '-') && (arg[1] == '?')))
                    {
                    PrintGetDbgCellUsage();
                    return;
                    }
                else
                    {
                    ProcessID = (ULONG)GetExpression(arg);
                    }
                break;

            case 1:
                DotSeparator = strchr(arg, '.');
                if (DotSeparator == NULL)
                    {
                    PrintGetCallInfoUsage();
                    return;
                    }
                *DotSeparator = 0;
                DotSeparator ++;
                CellID.SectionID = (USHORT)GetExpression(arg);
                CellID.CellID = (USHORT)GetExpression(DotSeparator);
                break;

            default:
                dprintf("Too many arguments\n");
                PrintGetDbgCellUsage();

            }
        ArgumentNo ++;
        }

    GetAndPrintDbgCellInfo(ProcessID, CellID, dprintf);
}

void PrintGetEndpointInfoUsage(void)
{
    dprintf("Usage: \n\tgetendpointinfo [EndpointName]\n");
}

DECLARE_API( getendpointinfo )
{
    int ArgumentNo = 0;
    char *EndpointName = NULL;

    //
    // Interpret options.
    //
    char * arg;

    if (fKD != 0)
        {
        dprintf("This extension command does not work under kd\n");
        return;
        }

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        switch(ArgumentNo)
            {
            case 0:
                // either help or EndpointName
                if ((arg[0] == '?') || ((arg[0] == '-') && (arg[1] == '?')))
                    {
                    PrintGetEndpointInfoUsage();
                    return;
                    }
                else
                    {
                    EndpointName = arg;
                    }
                break;

            default:
                dprintf("Too many arguments\n");
                PrintGetCallInfoUsage();

            }
        ArgumentNo ++;
        }

    GetAndPrintEndpointInfo(EndpointName, dprintf);
}

void PrintGetThreadInfoUsage(void)
{
    dprintf("Usage: \n\tgetthreadinfo ProcessID [ThreadID]\n");
}

DECLARE_API( getthreadinfo )
{
    DWORD ProcessID = 0;
    DWORD ThreadID = 0;

    int ArgumentNo = 0;
    BOOL fFirstTime = TRUE;

    //
    // Interpret options.
    //
    char * arg;

    if (fKD != 0)
        {
        dprintf("This extension command does not work under kd\n");
        return;
        }

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        switch(ArgumentNo)
            {
            case 0:
                // either help or EndpointName
                if ((arg[0] == '?') || ((arg[0] == '-') && (arg[1] == '?')))
                    {
                    PrintGetThreadInfoUsage();
                    return;
                    }
                else
                    {
                    ProcessID = (DWORD)GetExpression(arg);
                    }
                fFirstTime = FALSE;
                break;

            case 1:
                ThreadID = (DWORD)GetExpression(arg);
                break;

            default:
                dprintf("Too many arguments\n");
                PrintGetThreadInfoUsage();

            }
        ArgumentNo ++;
        }

    if (fFirstTime)
        {
        dprintf("You must specify at least a process id\n");
        PrintGetThreadInfoUsage();
        return;
        }

    GetAndPrintThreadInfo(ProcessID, ThreadID, dprintf);
}

void PrintGetClientCallInfoUsage(void)
{
    dprintf("Usage: \n\tgetclientcallinfo [CallID|0 [IfStart|0 [ProcNum|FFFF [ProcessID|0]]]]\n");
}

DECLARE_API( getclientcallinfo )
{
    ULONG CallID = 0;
    ULONG IfStart = 0;
    USHORT ProcNum = RPCDBG_NO_PROCNUM_SPECIFIED;
    ULONG ProcessID = 0;
    int ArgumentNo = 0;

    //
    // Interpret options.
    //
    char * arg;

    if (fKD != 0)
        {
        dprintf("This extension command does not work under kd\n");
        return;
        }

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        switch(ArgumentNo)
            {
            case 0:
                // either help or CallID
                if ((arg[0] == '?') || ((arg[0] == '-') && (arg[1] == '?')))
                    {
                    PrintGetClientCallInfoUsage();
                    return;
                    }
                else
                    {
                    CallID = (ULONG)GetExpression(arg);
                    }
                break;

            case 1:
                IfStart = (ULONG)GetExpression(arg);
                break;

            case 2:
                ProcNum = (USHORT)GetExpression(arg);
                break;

            case 3:
                ProcessID = (ULONG)GetExpression(arg);
                break;

            default:
                dprintf("Too many arguments\n");
                PrintGetCallInfoUsage();

            }
        ArgumentNo ++;
        }

    GetAndPrintClientCallInfo(CallID, IfStart, ProcNum, ProcessID, dprintf);
}


DECLARE_API( checkrpcsym )
{
    PVOID FunctionPtr;
    DWORD Data;
    BOOL b;
    BOOL fUnsure = FALSE;

    const int FunctionNamesSize = 2;
    const int ExpectedDataSize = 3;

    DWORD ExpectedData_x86[2][3] = {{0x55, 0x8B, 0xEC},{0x55, 0x8B, 0xEC}};
    DWORD ExpectedData_ia64[2][3] = {{0x00, 0xa8, 0x85},{0x00, 0x20, 0x2d}};

    const char *FunctionNames[2] = {"RPCRT4!WS_NewConnection", "RPCRT4!OSF_ADDRESS__NewConnection"};
    int i, FunctionNo;

    BOOL fNoSpew = FALSE;

    for (FunctionNo = 0; FunctionNo < FunctionNamesSize; FunctionNo ++)
        {
        FunctionPtr = (PVOID)GetExpression(FunctionNames[FunctionNo]);
        if (FunctionPtr == NULL)
            {
            dprintf("Cannot find address of %s - RPC symbols are wrong\n",
                FunctionNames[FunctionNo]);
            return;
            }

        b = GetData(HandleToUlong(FunctionPtr), &Data, sizeof(DWORD));
        if (!b)
            {
            // under UM debugger this is bad symbols
            if (fKD == 0)
                {
                dprintf("Cannot access address %x - RPC symbols are wrong\n", FunctionPtr);
                return;
                }
            // in kd this is possible even with valid symbols
            fUnsure = TRUE;
            }
        else
            {
            for (i = 0; i < ExpectedDataSize; i ++)
                {
                if (((IsPtr64() && ((Data & 0xFF) != ExpectedData_ia64[FunctionNo][i]) ||
                     (!IsPtr64()) && ((Data & 0xFF) != ExpectedData_x86[FunctionNo][i])))
                    && fNoSpew == FALSE)
                    {
                    dprintf("Function %s does not have expected\n"
                        "contents - debugger and debuggee have\n"
                        "different versions or architectures or the RPC\n"
                        "symbols are wrong\n\n",
                        FunctionNames[FunctionNo]);
                    fUnsure = TRUE;
                    fNoSpew = TRUE;
                    }
                Data >>= 8;
                }
            }
        }

    if (fUnsure)
        {
        dprintf("The correctness of RPC symbols could not be determined conclusively\n");
        }
    else
        {
        dprintf("RPC symbols are correct\n");
        }
}

typedef struct tagCallStackPatternMatch
{
    const char *FunctionBase;
    int ValueOffset;    // 0 if the value is not relative to this symbols, or
                        // any positive/negative if the value is relative to
                        // this symbol
} CallStackPatternMatch;

typedef struct tagStackGroupPattern
{
    CallStackPatternMatch *StackPattern;
    int NumberOfEntries;
} StackGroupPattern;

CallStackPatternMatch WS_CallStack1[] = {{"kernel32!WaitForSingleObjectEx", 0},
                                         {"rpcrt4!UTIL_WaitForSyncIO", 0},
                                         {"rpcrt4!WS_SyncRecv", 0},
                                         {"rpcrt4!WS_SyncRecv", 0},
                                         {"rpcrt4!OSF_CCONNECTION__TransSendReceive", 0},
                                         {"rpcrt4!OSF_CCONNECTION__SendFragment", 0},
                                         {"rpcrt4!OSF_CCALL__SendNextFragment", 0},
                                         {"rpcrt4!OSF_CCALL__FastSendReceive", 0},
                                         {"rpcrt4!OSF_CCALL__SendReceiveHelper", 0},
                                         {"rpcrt4!OSF_CCALL__SendReceive", 0},
                                         {"rpcrt4!I_RpcSendReceive", 0},
                                         {"rpcrt4!NdrSendReceive", sizeof(PVOID)}};

CallStackPatternMatch WS_CallStack2[] = {{"kernel32!WaitForSingleObjectEx", 0},
                                         {"rpcrt4!UTIL_WaitForSyncIO", 0},
                                         {"rpcrt4!UTIL_GetOverlappedResultEx", 0},
                                         {"rpcrt4!WS_SyncRecv", 0},
                                         {"rpcrt4!OSF_CCONNECTION__TransSendReceive", 0},
                                         {"rpcrt4!OSF_CCONNECTION__SendFragment", 0},
                                         {"rpcrt4!OSF_CCALL__SendNextFragment", 0},
                                         {"rpcrt4!OSF_CCALL__FastSendReceive", 0},
                                         {"rpcrt4!OSF_CCALL__SendReceiveHelper", 0},
                                         {"rpcrt4!OSF_CCALL__SendReceive", 0},
                                         {"rpcrt4!I_RpcSendReceive", 0},
                                         {"rpcrt4!NdrSendReceive", sizeof(PVOID)}};

CallStackPatternMatch NMP_CallStack1[] = {{"kernel32!WaitForSingleObjectEx", 0},
                                          {"rpcrt4!UTIL_WaitForSyncIO", 0},
                                          {"rpcrt4!UTIL_GetOverlappedResultEx", 0},
                                          {"rpcrt4!NMP_SyncSendRecv", 0},
                                          {"rpcrt4!OSF_CCONNECTION__TransSendReceive", 0},
                                          {"rpcrt4!OSF_CCONNECTION__SendFragment", 0},
                                          {"rpcrt4!OSF_CCALL__SendNextFragment", 0},
                                          {"rpcrt4!OSF_CCALL__FastSendReceive", 0},
                                          {"rpcrt4!OSF_CCALL__SendReceiveHelper", 0},
                                          {"rpcrt4!OSF_CCALL__SendReceive", 0},
                                          {"rpcrt4!I_RpcSendReceive", 0},
                                          {"rpcrt4!NdrSendReceive", sizeof(PVOID)}};

CallStackPatternMatch LRPC_CallStack1[] = {{"rpcrt4!LRPC_CCALL__SendReceive", 0},
                                           {"rpcrt4!I_RpcSendReceive", 0},
                                           {"rpcrt4!NdrSendReceive", sizeof(PVOID)}};

const int NumberOfWsCallStacks = 2;
StackGroupPattern WS_CallStacks[] = {{WS_CallStack1, 12}, {WS_CallStack2, 12}};

const int NumberOfNmpCallStacks = 1;
StackGroupPattern NMP_CallStacks[] = {{NMP_CallStack1, 12}};

const int NumberOfLrpcCallStacks = 1;
StackGroupPattern LRPC_CallStacks[] = {{LRPC_CallStack1, 3}};

BOOL VerboseStack = FALSE;


BOOL MatchStack(IN PVOID StackStart, IN StackGroupPattern *StackGroup,
                IN int NumberOfElementsInGroup, OUT ULONG_PTR *Value)
{
    int i;
    BOOL Result;
    ULONG_PTR CurrentPos;
    ULONG_PTR CurrentValue;
    ULONG_PTR Displacement;
    int StackPatternPos; // the next stack entry to match
    ULONG_PTR FinalValue = 0;
    int ValueOffset;
    CHAR CurrentName[256];

    for (i = 0; i < NumberOfElementsInGroup; i ++)
        {
        CurrentPos = (ULONG_PTR)StackStart;
        StackPatternPos = 0;
        while (TRUE)
            {
            Result = GetData(CurrentPos, &CurrentValue, sizeof(ULONG_PTR));
            if (Result == FALSE)
                goto NextStack;

            GetSymbol((ULONG64)CurrentValue, CurrentName, (PULONG64)&Displacement);
            if (RpcpStringCompareA((const char *)CurrentName, StackGroup[i].StackPattern[StackPatternPos].FunctionBase) == 0)
                {
                if (VerboseStack)
                    {
                    dprintf("Stack: %d: Match with '%s'\n", i, CurrentName);
                    }
                ValueOffset = StackGroup[i].StackPattern[StackPatternPos].ValueOffset;
                if (ValueOffset != 0)
                    {
                    Result = GetData(CurrentPos + ValueOffset, &FinalValue,
                        sizeof(ULONG_PTR));
                    if (Result == FALSE)
                        goto NextStack;
                    }
                StackPatternPos ++;
                if (StackPatternPos >= StackGroup[i].NumberOfEntries)
                    {
                    // full stack match - return success
                    ASSERT(FinalValue != 0);
                    *Value = FinalValue;
                    return TRUE;
                    }
                }

            CurrentPos += sizeof(ULONG_PTR);
            }
NextStack:
        ;
        }
    return FALSE;
}

BOOL GetDataFromRpcMessage(IN ULONG_PTR RpcMessage, OUT ULONG_PTR *CallObject,
                           OUT DWORD *IfStart, OUT USHORT *ProcNum)
{
    BOOL Result;
    union
        {
        RPC_MESSAGE RpcMessage;
        RPC_CLIENT_INTERFACE Interface;
        } MemLoc;
    ULONG_PTR Interface;

    Result = GetData(RpcMessage, (PVOID) &MemLoc.RpcMessage, sizeof(MemLoc.RpcMessage));
    if (Result == FALSE)
        return FALSE;
    *CallObject = (ULONG_PTR)MemLoc.RpcMessage.Handle;
    *ProcNum = (USHORT)MemLoc.RpcMessage.ProcNum;
    Interface = (ULONG_PTR)MemLoc.RpcMessage.RpcInterfaceInformation;
    Result = GetData(Interface, &MemLoc.Interface, sizeof(MemLoc.Interface));
    if (Result == FALSE)
        return FALSE;
    *IfStart = MemLoc.Interface.InterfaceId.SyntaxGUID.Data1;
    return TRUE;
}

BOOL PrintDceBinding(ULONG_PTR DceBindingPointer)
{
    NO_CONSTRUCTOR_TYPE(DCE_BINDING, DceBinding);
    RPC_CHAR *RpcProtocolSequence;
    RPC_CHAR *NetworkAddress;
    RPC_CHAR *Endpoint;
    BOOL Result;

    Result = GetData(DceBindingPointer, DceBinding, sizeof(DCE_BINDING));
    if (Result == FALSE)
        return FALSE;

    RpcProtocolSequence = ReadProcessRpcChar((ULONG64)DceBinding->RpcProtocolSequence);
    if (RpcProtocolSequence) {
        dprintf("\tProtocol Sequence: \t\"%ws\"\t(Address: %p)\n", RpcProtocolSequence, DceBinding->RpcProtocolSequence);
        delete RpcProtocolSequence;
    }

    NetworkAddress = ReadProcessRpcChar((ULONG64)DceBinding->NetworkAddress);
    if (NetworkAddress) {
        dprintf("\tNetworkAddress:\t\t\"%ws\"\t(Address: %p)\n", NetworkAddress, DceBinding->NetworkAddress);
        delete NetworkAddress;
    }

    Endpoint = ReadProcessRpcChar((ULONG64)DceBinding->Endpoint);
    if (Endpoint) {
        dprintf("\tEndpoint:\t\t\"%ws\" \t(Address: %p)\n", Endpoint, DceBinding->Endpoint);
        delete Endpoint;
    }

    if ((RpcProtocolSequence == NULL) && (NetworkAddress == NULL)
        && (Endpoint == NULL))
        {
        return FALSE;
        }

    return TRUE;
}

BOOL PrintOsfCallInfoFromRpcMessage(ULONG_PTR RpcMessage)
{
    ULONG_PTR CallObject;
    BOOL Result;
    NO_CONSTRUCTOR_TYPE(OSF_CCALL, OsfCCall);
    DWORD CallID;
    DWORD IfStart;
    USHORT ProcNum;
    ULONG_PTR ConnPointer;
    ULONG_PTR AssocPointer;
    ULONG_PTR DceBindingPointer;

    Result = GetDataFromRpcMessage(RpcMessage, &CallObject, &IfStart, &ProcNum);
    if (Result == FALSE)
        return FALSE;

    Result = GetData(CallObject, OsfCCall, sizeof(OSF_CCALL));
    if (Result == FALSE)
        return FALSE;

    CallID = OsfCCall->CallId;
    dprintf("CallID: %d\n", CallID);
    dprintf("IfStart: %x\n", IfStart);
    dprintf("ProcNum: %d\n", (int)ProcNum);

    ConnPointer = (ULONG_PTR)OsfCCall->Connection;
    // get the association pointer
    Result = GetData(ConnPointer + FIELD_OFFSET(OSF_CCONNECTION, Association), &AssocPointer,
        sizeof(ULONG_PTR));
    if (Result == FALSE)
        return FALSE;

    // get the dcebinding pointer
    Result = GetData(AssocPointer + FIELD_OFFSET(OSF_CASSOCIATION, DceBinding), &DceBindingPointer,
        sizeof(ULONG_PTR));
    if (Result == FALSE)
        return FALSE;

    // print the DCE binding info
    PrintDceBinding(DceBindingPointer);

    return TRUE;
}

BOOL PrintLrpcCallInfoFromRpcMessage(ULONG_PTR RpcMessage)
{
    ULONG_PTR CallObject;
    BOOL Result;
    NO_CONSTRUCTOR_TYPE(LRPC_CCALL, LrpcCCall);
    DWORD CallID;
    DWORD IfStart;
    USHORT ProcNum;
    ULONG_PTR AssocPointer;
    ULONG_PTR DceBindingPointer;

    Result = GetDataFromRpcMessage(RpcMessage, &CallObject, &IfStart, &ProcNum);
    if (Result == FALSE)
        return FALSE;

    Result = GetData(CallObject, LrpcCCall, sizeof(LRPC_CCALL));
    if (Result == FALSE)
        return FALSE;

    CallID = LrpcCCall->CallId;
    dprintf("CallID: %d\n", CallID);
    dprintf("IfStart: %x\n", IfStart);
    dprintf("ProcNum: %d\n", (int)ProcNum);

    AssocPointer = (ULONG_PTR)LrpcCCall->Association;

    // get the dcebinding pointer
    Result = GetData(AssocPointer + FIELD_OFFSET(LRPC_CASSOCIATION, DceBinding), &DceBindingPointer,
        sizeof(ULONG_PTR));
    if (Result == FALSE)
        return FALSE;

    // print the DCE binding info
    PrintDceBinding(DceBindingPointer);

    return TRUE;
}

DECLARE_API (rpcreadstack)
{
    PVOID StackStart;
    BOOL Result;
    ULONG_PTR Value;

    LPSTR lpArgumentString = (LPSTR)args;

    StackStart = (PVOID)GetExpression(lpArgumentString);

    // try to match the stack against the different types we support
    // first, try Winsock
    if (VerboseStack)
        {
        dprintf("Matching Winsock stacks\n");
        }
    Result = MatchStack(StackStart, WS_CallStacks, NumberOfWsCallStacks, &Value);
    if (Result == TRUE)
        {
        // call the Winsock stack analysis function
        PrintOsfCallInfoFromRpcMessage(Value);
        return;
        }

    // next, try Named pipes
    if (VerboseStack)
        {
        dprintf("Matching named pipe stacks\n");
        }
    Result = MatchStack(StackStart, NMP_CallStacks, NumberOfNmpCallStacks, &Value);
    if (Result == TRUE)
        {
        // call the named pipe stack analysis function
        PrintOsfCallInfoFromRpcMessage(Value);
        return;
        }

    // next, try LRPC
    if (VerboseStack)
        {
        dprintf("Matching LRPC stacks\n");
        }
    Result = MatchStack(StackStart, LRPC_CallStacks, NumberOfLrpcCallStacks, &Value);
    if (Result == TRUE)
        {
        // call the Lrpc stack analysis function
        PrintLrpcCallInfoFromRpcMessage(Value);
        return;
        }

    dprintf("Not found!\n");
}

DECLARE_API (rpcverbosestack)
{
    VerboseStack = !VerboseStack;
    if (VerboseStack)
        {
        dprintf("Switched to ON\n");
        }
    else
        {
        dprintf("Switched to OFF\n");
        }
}

VOID
do_eerecord(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp0;
    ULONG64 tmp1;
    ULONG tmp2;

    unsigned char Buf[sizeof(ExtendedErrorInfo) + sizeof(ExtendedErrorParam) * (MaxNumberOfEEInfoParams - 1)];
    ULONG64 EEInfoAddr;
    BOOL Result;
    int EEInfoSize;
    RPC_CHAR *ComputerNameStr;
    SYSTEMTIME SystemTime;
    int i;

    ULONG64 nLen;
    ULONG64 TimeStamp;
    ULONG64 ComputerName;
    ULONG64 Params;
    ULONG64 ParamType;
    ULONG64 ParamAddr;

    ULONG64 UnicodeStringAddr;
    ULONG64 AnsiStringAddr;
    ULONG64 BlobAddr;
    ULONG64 nLength;
    ULONG64 pString;
  
    char *AnsiBuf;
    RPC_CHAR *UnicodeBuf;

    dprintf("eerecord at 0x%I64x:\n", qwAddr);

    GET_MEMBER(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, nLen, nLen);
    GET_MEMBER(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, TimeStamp, TimeStamp);
    GET_ADDRESS_OF(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, Params, Params, tmp2);

    GET_ADDRESS_OF(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, ComputerName, ComputerName, tmp2);
    GET_MEMBER(ComputerName, EEComputerName, RPCRT4!EEComputerName, Type, tmp1);
    if ((ULONG)tmp1 == eecnpPresent)
        {
        GET_ADDRESS_OF(ComputerName, EEComputerName, RPCRT4!EEComputerName, Name, tmp1, tmp2);
        GET_MEMBER(tmp1, EEUString, RPCRT4!EEUString, pString, tmp0);

        ComputerNameStr = ReadProcessRpcChar(tmp0);
        if (ComputerNameStr != NULL)
            {
            dprintf("Computer Name: %S\n", ComputerNameStr);
            delete ComputerNameStr;
            }
        }
    else
        {
        dprintf("Computer Name: (null)\n");
        }

    PRINT_MEMBER_DECIMAL_AND_HEX(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, ProcessID, tmp0);
    PRINT_MEMBER_DECIMAL_AND_HEX(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, Status, tmp0);

    // BUG
    dprintf ("TimeStamp=%I64x\n", TimeStamp);
    Result = FileTimeToSystemTime((FILETIME *)&TimeStamp, &SystemTime);

    if (Result)
        {
        dprintf("System Time is: %d/%d/%d %d:%d:%d:%d\n",
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            SystemTime.wMilliseconds);
        }
    else
        {
        dprintf("Couldn't extract system time. Error is %d\n", GetLastError());
        }

    PRINT_MEMBER(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, GeneratingComponent, tmp0);
    PRINT_MEMBER_DECIMAL_AND_HEX(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, Status, tmp0);
    PRINT_MEMBER_DECIMAL_AND_HEX(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, DetectionLocation, tmp0);
    GET_MEMBER(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, Flags, tmp0);
    dprintf("Flags: %S %S\n",
        tmp0 & EEInfoPreviousRecordsMissing ? "Previous Record Missing" : "",
        tmp0 & EEInfoNextRecordsMissing ? "Next Record Missing" : "");

    dprintf("nLen = %d\n", (int)nLen);

    ParamAddr = Params;

    for (i = 0; i < (int)nLen; i++)
        {
        dprintf("Parameter %d:", i);

        GET_MEMBER(ParamAddr, tagParam, RPCRT4!tagParam, Type, ParamType);

        switch((ULONG)ParamType)
            {
            case eeptiAnsiString:

                dprintf("(Ansi string) : ");

                GET_ADDRESS_OF(ParamAddr, tagParam, RPCRT4!tagParam, AnsiString, AnsiStringAddr, tmp2);
                GET_MEMBER(AnsiStringAddr, tagEEAString, RPCRT4!tagEEAString, nLength, nLength);
                GET_MEMBER(AnsiStringAddr, tagEEAString, RPCRT4!tagEEAString, pString, pString);

                // we know the length - use GetData
                AnsiBuf = new char [(unsigned)nLength];
                if (AnsiBuf != NULL)
                    {
                    Result = GetData(pString,
                        AnsiBuf,
                        (ULONG)nLength);
                    if (Result)
                        {
                        dprintf("%s\n", AnsiBuf);
                        }
                    // else
                    // error info has already been printed - nothing to do
                    delete [] AnsiBuf;
                    }
                break;

            case eeptiUnicodeString:
  
                dprintf("(Unicode string) : ");

                GET_ADDRESS_OF(ParamAddr, tagParam, RPCRT4!tagParam, UnicodeString, UnicodeStringAddr, tmp2);
                GET_MEMBER(UnicodeStringAddr, tagEEAString, RPCRT4!tagEEAString, nLength, nLength);
                GET_MEMBER(UnicodeStringAddr, tagEEAString, RPCRT4!tagEEAString, pString, pString);

                // we know the length - use GetData
                UnicodeBuf = new RPC_CHAR [(unsigned)nLength];
                if (UnicodeBuf != NULL)
                    {
                    Result = GetData(pString,
                        UnicodeBuf,
                        (ULONG)(nLength * sizeof(RPC_CHAR)));
                    if (Result)
                        {
                        dprintf("%S\n", UnicodeBuf);
                        }
                    // else
                    // error info has already been printed - nothing to do
                    delete [] UnicodeBuf;
                    }
                break;

            case eeptiLongVal:
                PRINT_MEMBER_DECIMAL_AND_HEX(ParamAddr, tagParam, RPCRT4!tagParam, LVal, tmp0);
                break;

            case eeptiShortVal:
                PRINT_MEMBER_DECIMAL_AND_HEX(ParamAddr, tagParam, RPCRT4!tagParam, IVal, tmp0);
                break;

            case eeptiPointerVal:
                PRINT_MEMBER_DECIMAL_AND_HEX(ParamAddr, tagParam, RPCRT4!tagParam, PVal, tmp0);
                break;

            case eeptiNone:
                dprintf("(Truncated value)\n");
                break;

            case eeptiBinary:
                dprintf("(Binary value:)\n");
                GET_ADDRESS_OF(ParamAddr, tagParam, RPCRT4!tagParam, Blob, BlobAddr, tmp2);
                PRINT_MEMBER_DECIMAL_AND_HEX(BlobAddr, tagBinaryEEInfo, RPCRT4!tagBinaryEEInfo, nSize, tmp0);
                PRINT_MEMBER_DECIMAL_AND_HEX(BlobAddr, tagBinaryEEInfo, RPCRT4!tagBinaryEEInfo, pBlob, tmp0);
                break;

            default:
                dprintf("Invalid type: %d\n", (ULONG)ParamType);
            }

        ParamAddr += GET_TYPE_SIZE(tagParam, RPCRT4!tagParam);
        }
}

VOID
do_eeinfo(
    ULONG64 qwAddr
    )
{
    ULONG64 PrevNextElement = qwAddr;
    ULONG64 NextElement = qwAddr;
    ULONG64 FirstElement = qwAddr;
    BOOL Result;

    do
        {
        do_eerecord(NextElement);

        PrevNextElement = NextElement; 
        GET_MEMBER(NextElement, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, Next, NextElement);
 
        // prevent loops
        if (NextElement == FirstElement)
            {
            dprintf("Loop detected - exitting ...\n");
            return;
            }
        dprintf("------------------------\n");
        }
    while(NextElement != 0 && PrevNextElement != NextElement);
}

VOID PrintTypeinfoUsage(VOID) {
    dprintf("Wrong arguments to !rpcexts.typeinfo\n");
    dprintf("Please use !rpcexts.typeinfo on|off\n");
}

DECLARE_API (typeinfo)
{
    LPSTR lpArgumentString = (LPSTR)args;

    if (strcmp(lpArgumentString, "on") == 0)
        fUseTypeInfo = TRUE;
    else if (strcmp(lpArgumentString, "off") == 0)
        fUseTypeInfo = FALSE;
    else if (strcmp(lpArgumentString, "") == 0)
        {
        if (fUseTypeInfo == TRUE)
            dprintf ("typeinfo use is on\n");
        else
            dprintf ("typeinfo use is off\n");
        }
    else
        PrintTypeinfoUsage();

    return;
}


VOID PrintStackMatchUsage(VOID) {
    dprintf("Wrong arguments to !rpcexts.stackmatch");
    dprintf("Please use !rpcexts.stackmatch start_addr [depth]\n");
}


DECLARE_API( stackmatch )
{
    static ULONG64 Start;
    static ULONG Depth = 0x80;

    CHAR Symbol[128];
    ULONG64 Displacement = 0;
    CHAR ObjSymbol[128];
    ULONG64 ObjDisplacement = 0;

    //
    // Interpret options.
    //
    ULONG ProcessID = 0;
    int ArgumentNo = 0;
    DebugCellID CellID;
    char *DotSeparator;

    //
    // Interpret options.
    //
    char * arg;

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        switch(ArgumentNo)
            {
            case 0:
                Start = GetExpression(arg);
                break;

            case 1:
                Depth = (ULONG) GetExpression(arg);
                break;

            default:
                dprintf("Too many arguments\n");
                PrintStackMatchUsage();

            }
        ArgumentNo ++;
        }

    for (ULONG64 Addr=Start; Addr<=Start+Depth; Addr+=AddressSize) {
        ULONG64 Val;
        ReadPtrUnextend(Addr, &Val);
        dprintf("%I64p  %I64p", Addr, Val);

        GetSymbol(Val, Symbol, &Displacement);
        if (strcmp(Symbol, "") != 0)
            dprintf(" %s+%x", Symbol, Displacement);
        else {
            ULONG64 Obj;
            ReadPtrUnextend(Val, &Obj);

            if (Obj) {
                dprintf(" -> %I64p", Obj);
                GetSymbol(Obj, ObjSymbol, &ObjDisplacement);
                if (strcmp(ObjSymbol, "") != 0)
                    dprintf(" %s+%x", ObjSymbol, ObjDisplacement);
            }
        }

        dprintf("\n");
    }

    Start = Addr;
}

DECLARE_API( listcalls )
{
    ULONG64 qwAddr;
    BOOL fArgSpecified = FALSE;
    ULONG64 ServerAddress;

    LPSTR lpArgumentString = (LPSTR)args;

    if (0 == strtok(lpArgumentString))
        {
        lpArgumentString = "rpcrt4!GlobalRpcServer";
        fArgSpecified = TRUE;
        }

    qwAddr = GetExpression(lpArgumentString);

    if ( !qwAddr )
        {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
        }

    if (fArgSpecified)
        {
        if (ReadPtrUnextend(qwAddr, &ServerAddress))
            {
            dprintf("couldn't read memory at address 0x%I64x\n", qwAddr);
            return;
            }
        }
    else
        ServerAddress = qwAddr;

    do_listcalls(ServerAddress);
}

VOID LoopThroughDict(ULONG64 Dict, PCHAR offset) {
    ULONG64 tmp0;
    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 cDictSize;
    ULONG64 cDictSlots;
    ULONG64 DictSlots;
    int j;
    ULONG64 DictSlot;

    GET_MEMBER(Dict, SIMPLE_DICT, RPCRT4!SIMPLE_DICT, cDictSize, cDictSize);
    GET_MEMBER(Dict, SIMPLE_DICT, RPCRT4!SIMPLE_DICT, cDictSlots, cDictSlots);

    if ((ULONG)cDictSize > (ULONG)cDictSlots)
        {
        dprintf("Bad dictionary\t\t- %I64p\n", Dict);
        return;
        }

    GET_MEMBER(Dict, SIMPLE_DICT, RPCRT4!SIMPLE_DICT, DictSlots, DictSlots);

    dprintf("%sPrinting %d items in dictionary: %I64p with %d slots\n\n", offset, (ULONG)cDictSize, Dict, (ULONG)cDictSlots);

    // Loop throught the associations.
    for (j = 0; j < MIN((int)cDictSize, MAX_ITEMS_IN_DICTIONARY); j++)
        {
        if (!ReadPtrUnextend(DictSlots + j * AddressSize, &DictSlot))
            dprintf ("%s(%d): 0x%I64x - ", offset, j, DictSlot);

        ULONG64 MagicValue;
        ULONG64 ObjectType;
        ULONG64 LocalDict;

        if (ReadPtrUnextend(DictSlot+AddressSize, &MagicValue) ||
            ReadPtrUnextend(DictSlot+AddressSize+4, &ObjectType)) {
            dprintf("Bad or deleted object at %p\n", DictSlot);
            return;
	}

        if ((ULONG)MagicValue != MAGICLONG)
            {
            dprintf("Bad or deleted object at %p\n", DictSlot);
            return;
            }

        switch (((ULONG)ObjectType) & (~OBJECT_DELETED))
            {
            case DG_ADDRESS_TYPE:
                dprintf("DG_ADDRESS\n");
                break;

            case OSF_ADDRESS_TYPE:
                dprintf("OSF_ADDRESS\n");

                GET_ADDRESS_OF(DictSlot, OSF_ADDRESS, RPCRT4!OSF_ADDRESS, Associations, LocalDict, tmp2);

                LoopThroughDict(LocalDict, "\t\t");

                break;

            case LRPC_ADDRESS_TYPE:
                dprintf("LRPC_ADDRESS\n");

                GET_ADDRESS_OF(DictSlot, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, AssociationDictionary, LocalDict, tmp2);

                LoopThroughDict(LocalDict, "\t\t");

                break;

            case OSF_ASSOCIATION_TYPE:
                dprintf("OSF_ASSOCIATION_TYPE\n");

                break;

            case LRPC_SASSOCIATION_TYPE:
                dprintf("LRPC_SASSOCIATION_TYPE\n");

                break;

            default:
                dprintf("The RPC object type is 0x%lx and I don't recognize it.\n", (ObjectType) & ~(OBJECT_DELETED));
            }    
        }
}

VOID
do_listcalls(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp0;
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    dprintf("RPC_SERVER at 0x%I64x\n", qwAddr);

    ULONG64 RpcAddressDictionary;
    GET_ADDRESS_OF(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, RpcAddressDictionary, RpcAddressDictionary, tmp2);
    dprintf("&RpcAddressDictionary(RPC_SIMPLE_DICT) - 0x%I64x\n", RpcAddressDictionary);

    LoopThroughDict(RpcAddressDictionary, "\t");

    dprintf("\n");
}

DECLARE_API( rpcverifier )
{
    ULONG64 qwAddr;
    ULONG64 tmp1;

    dprintf("\n");

    dprintf("gfAppVerifierEnabled = %d\n", GetVar("rpcrt4!gfAppVerifierEnabled"));
    dprintf("gfRPCVerifierEnabled = %d\n\n", GetVar("rpcrt4!gfRPCVerifierEnabled"));

    if (!((BOOL)GetVar("rpcrt4!gfRPCVerifierEnabled")))return;

    qwAddr = GetVar("rpcrt4!pRpcVerifierSettings");

    dprintf("RpcVerifierFlags = 0x%x\n\n", GetVar("rpcrt4!RpcVerifierFlags"));
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, fFaultInjectImpersonateClient, "FaultInjectImpersonateClient", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, ProbFaultInjectImpersonateClient, "ProbFaultInjectImpersonateClient", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, DelayFaultInjectImpersonateClient, "DelayFaultInjectImpersonateClient", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, fCorruptionInjectServerReceives, "CorruptionInjectServerReceives", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, fCorruptionInjectClientReceives, "CorruptionInjectClientReceives", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, ProbRpcHeaderCorruption, "ProbRpcHeaderCorruption", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, ProbDataCorruption, "ProbDataCorruption", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, ProbSecureDataCorruption, "ProbSecureDataCorruption", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, CorruptionPattern, "CorruptionPattern", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, CorruptionSizeType, "CorruptionSizeType", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, CorruptionSize, "CorruptionSize", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, CorruptionDistributionType, "CorruptionDistributionType", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, ProbBufferTruncation, "ProbBufferTruncation", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, tRpcVerifierSettings, RPCRT4!tRpcVerifierSettings, MaxBufferTruncationSize, "MaxBufferTruncationSize", tmp1);
    dprintf("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\epmap\util.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    util.c

Abstract:

    This module provides all the utility functions for the Server side of
    the end-point mapper.

Author:

    Bharat Shah

Revision History:

    06-03-97    gopalp      Added code to cleanup stale EP Mapper entries.

--*/

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <sysinc.h>
#include <rpc.h>
#include <rpcndr.h>
#include "epmp.h"
#include "eptypes.h"
#include "local.h"


//
// Link list manipulation rountines
//

#ifdef DBG
void CountProcessContextList(EP_CLEANUP *pProcessContext, unsigned long nExpectedCount)
{
    unsigned long nActualCount = 0;
    PIFOBJNode pNode = pProcessContext->EntryList;

    while (pNode && (pNode->OwnerOfList == pProcessContext))
        {
        pNode = pNode->Next;
        nActualCount ++;
        }

    if (nActualCount != nExpectedCount)
        {
        DbgPrint("Expected count was %d, while actual count was %d\n", nExpectedCount, 
            nActualCount);
        }
}
#endif

PIENTRY
Link(
    PIENTRY *Head,
    PIENTRY Node
    )
{
    if (Node == NULL)
        return (NULL);

    CheckInSem();

    Node->Next = *Head;

    return(*Head = Node);
}




VOID
LinkAtEnd(
    PIFOBJNode *Head,
    PIFOBJNode Node
    )
{
    register PIFOBJNode *ppNode;

    CheckInSem();

    for ( ppNode = Head; *ppNode; ppNode = &((*ppNode)->Next) );
        {
        ; // Empty body
        }

    *ppNode = Node;
}





PIENTRY
UnLink(
    PIENTRY *Head,
    PIENTRY Node
    )
{
    PIENTRY *ppNode;

    for (ppNode = Head; *ppNode && (*ppNode != Node);
         ppNode = &(*ppNode)->Next)
        {
        ; // Empty body
        }

    if (*ppNode)
        {
        *ppNode = Node->Next;
        return (Node);
        }

    return (0);
}

PIFOBJNode
GetLastIFOBJNode (
    void
    )
/*++

Routine Description:

    Returns the address of the last PIFOBJNode

Arguments:

Return Value:

    See description.

Notes:

    The IFObjList list MUST not be empty when this
    function is called. It will AV if the list is
    empty. Caller must verify that the list is not
    empty before calling this function.

--*/
{
    PIFOBJNode CurrentNode = IFObjList;

    while (CurrentNode->Next != NULL)
        {
        CurrentNode = CurrentNode->Next;
        }

    return CurrentNode;
}


RPC_STATUS
EnLinkOnIFOBJList(
    PEP_CLEANUP ProcessCtxt,
    PIFOBJNode NewNode
    )
/*++

Arguments:

    phContext - The context handle supplied by the process.

    NewNode - The node (EP entry) to be inserted into the EP Mapper database.

Routine Description:

    This routine adds a new entry into the Endpoint Mapper database (which is
    maintained as a linked-list). It also updates the list of entries for the
    process identified by the context handle ProcessCtxt.

Notes:

    a. This routine should always be called by holding a mutex.
    b. NewNode is already allocated by the caller.
    c. IFObjList may be created here.
    d. ProcessCtxt is assumed to be allocated sometime by the caler.

Return Values:

    RPC_S_OK - Always.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    IFOBJNode *LastNode;
#ifdef DBG_DETAIL
    PIFOBJNode pTemp, pLast;
#endif // DBG_DETAIL

    // Parameter validation.
    ASSERT(NewNode);
    ASSERT(ProcessCtxt);
    ASSERT(ProcessCtxt->MagicVal == CLEANUP_MAGIC_VALUE);
    ASSERT_PROCESS_CONTEXT_LIST_COUNT(ProcessCtxt, ProcessCtxt->cEntries);

    CheckInSem();

    //
    // First, insert NewNode into this Process's list of entries.
    //
    NewNode->Next = ProcessCtxt->EntryList;

    if (ProcessCtxt->EntryList != NULL)
        {
        ASSERT(ProcessCtxt->cEntries > 0);
        ASSERT(cTotalEpEntries > 0);
        ASSERT(IFObjList != NULL);

        NewNode->Prev = ProcessCtxt->EntryList->Prev;

        // Next node's Prev pointer
        ProcessCtxt->EntryList->Prev = NewNode;

        if (NewNode->Prev)
            {
            ASSERT(cTotalEpEntries > 1);

            // Previous node's Next pointer
            NewNode->Prev->Next = NewNode;
            }
        }
    else
        {
        ASSERT(ProcessCtxt->cEntries == 0);

        NewNode->Prev = NULL;
        }

    //
    // Now, adjust the Global EP Mapper entries list head, if necessary
    //
    if (ProcessCtxt->EntryList != NULL)
        {
        if (ProcessCtxt->EntryList == IFObjList)
            {
            IFObjList = NewNode;
            }
        }
    else
        {
        // First entry registered by this process
        if (IFObjList != NULL)
            {
            LastNode = GetLastIFOBJNode();
            ASSERT(LastNode != NULL);
            ASSERT(LastNode->Next == NULL);
            // Add the new ProcessCtxt at the tail of IFObjList
            LastNode->Next = NewNode;
            NewNode->Prev = LastNode;
            // should already have been set to NULL
            ASSERT(NewNode->Next == NULL);
            }
        else
            {
            ASSERT(cTotalEpEntries == 0);
            IFObjList = NewNode;
            }        
        }
        
    // Add new node at the head of Process list.
    ProcessCtxt->EntryList = NewNode;
    NewNode->OwnerOfList = ProcessCtxt;

    ProcessCtxt->cEntries++;
    cTotalEpEntries++;
#ifdef DBG_DETAIL
    DbgPrint("RPCSS: cTotalEpEntries++ [%p] (%d)\n", ProcessCtxt, cTotalEpEntries);
    DbgPrint("RPCSS: Dump of IFOBJList\n");
    pTemp = IFObjList;
    pLast = IFObjList;
    while (pTemp)
        {
        DbgPrint("RPCSS: \t\t[%p]\n", pTemp);
        pLast = pTemp;
        pTemp = pTemp->Next;    
        }
    DbgPrint("RPCSS: --------------------\n");
    while (pLast)
        {
        DbgPrint("RPCSS: \t\t\t[%p]\n", pLast);
        pLast = pLast->Prev;            
        }
#endif // DBG_DETAIL

    ASSERT_PROCESS_CONTEXT_LIST_COUNT(ProcessCtxt, ProcessCtxt->cEntries);
    return (Status);
}




RPC_STATUS
UnLinkFromIFOBJList(
    PEP_CLEANUP ProcessCtxt,
    PIFOBJNode DeleteMe
    )
/*++

Arguments:

    phContext - The context handle supplied by the process.

    DeleteMe - The node (EP entry) to be deleted from the EP Mapper database.

Routine Description:

    This routine removes an existing entry from the Endpoint Mapper database
    (which is maintained as a linked-list). It also updates the list of entries
    for the process identified by the context handle ProcessCtxt.

Notes:

    a. This routine should always be called by holding a mutex.
    b. DeleteMe node has to be freed by the caller.
    c. IFOBJlist may become empty (NULLed out) here.
    d. ProcessCtxt may become empty here and if so, it should be freed
       by the caller.

Return Values:

    RPC_S_OK - If everyhing went well.

    RPC_S_ACCESS_DENIED - If something went wrong.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
#ifdef DBG_DETAIL
    PIFOBJNode pTemp, pLast;
#endif // DBG_DETAIL

    // Parameter validation.
    ASSERT(DeleteMe);
    ASSERT(ProcessCtxt);
    ASSERT(ProcessCtxt->MagicVal == CLEANUP_MAGIC_VALUE);


    CheckInSem();

    //
    // The context has been created already for this process. So, there
    // should be one or more entries registered by this process.
    //
    ASSERT(IFObjList);
    ASSERT(cTotalEpEntries > 0);
    ASSERT(ProcessCtxt->EntryList);
    ASSERT(ProcessCtxt->cEntries > 0);
    ASSERT(ProcessCtxt->EntryList->OwnerOfList == ProcessCtxt);
    ASSERT_PROCESS_CONTEXT_LIST_COUNT(ProcessCtxt, ProcessCtxt->cEntries);

    // Trying to unregister someone else's entry?
    if (DeleteMe->OwnerOfList != ProcessCtxt)
        {
        ASSERT("Returning RPC_S_ACCESS_DENIED" &&
               (DeleteMe->OwnerOfList != ProcessCtxt));
        return (RPC_S_ACCESS_DENIED);
        }

    //
    // First, remove DeleteMe from this Process's List.
    //

    // See if it the first element of the process list.
    if (DeleteMe == ProcessCtxt->EntryList)
        {
        if (DeleteMe->Next)
            {
            // if we are nibbling the next segment, zero out the EntryList
            if (DeleteMe->Next->OwnerOfList != ProcessCtxt)
                {
                ProcessCtxt->EntryList = NULL;
                }
            else
                ProcessCtxt->EntryList = DeleteMe->Next;
            }
        else
            {
            ProcessCtxt->EntryList = NULL;
            }
        }

    ASSERT(  ((ProcessCtxt->EntryList != NULL) && (ProcessCtxt->cEntries > 1))
          || (ProcessCtxt->cEntries == 1)  );

    // Remove it.
    if (DeleteMe->Next != NULL)
        {
        // Next node's Prev pointer
        DeleteMe->Next->Prev = DeleteMe->Prev;
        }

    if (DeleteMe->Prev != NULL)
        {
        // Previous node's Next pointer
        DeleteMe->Prev->Next = DeleteMe->Next;
        }
    else
        {
        ASSERT(IFObjList == DeleteMe);
        }


    //
    // Next, adjust the Global EP Mapper entries list head, if necessary
    //
    if (IFObjList == DeleteMe)
        {
        // Can become NULL here.
        IFObjList = DeleteMe->Next;
        }


    // Remove node from all lists.
    DeleteMe->Prev = NULL;
    DeleteMe->Next = NULL;
    DeleteMe->OwnerOfList = NULL;

    ProcessCtxt->cEntries--;
    cTotalEpEntries--;
#ifdef DBG_DETAIL
    DbgPrint("RPCSS: cTotalEpEntries-- [%p] (%d)\n", ProcessCtxt, cTotalEpEntries);
    DbgPrint("RPCSS: Dump of IFOBJList\n");
    pTemp = IFObjList;
    pLast = IFObjList;
    while (pTemp)
        {
        DbgPrint("RPCSS: \t\t[%p]\n", pTemp);
        pLast = pTemp;
        pTemp = pTemp->Next;
        }   
    DbgPrint("RPCSS: --------------------\n");
    while (pLast)
        {
        DbgPrint("RPCSS: \t\t\t[%p]\n", pLast);
        pLast = pLast->Prev;            
        }
#endif // DBG_DETAIL

    ASSERT_PROCESS_CONTEXT_LIST_COUNT(ProcessCtxt, ProcessCtxt->cEntries);
    return (Status);
}




//
// HACK Alert.
//
// Midl 1.00.xx didn't support full pointers.  So, clients from NT 3.1
// machines will use unique pointers.  This function detects and fixes
// the buffer if an older client contacts our new server.

// This HACK can be removed when supporting NT 3.1 era machines is no
// longer required.

void
FixupForUniquePointerClients(
    PRPC_MESSAGE pRpcMessage
    )
{
    unsigned long *pBuffer = (unsigned long *)pRpcMessage->Buffer;

    // Check the obj uuid parameter.

    if (pBuffer[0] != 0)
        {
        // If it is not zero, it should be 1.
        pBuffer[0] = 1;

        // check the map_tower, which moves over 1 + 4 longs for the obj uuid
        if (pBuffer[5] != 0)
            pBuffer[5] = 2;
        }
    else
        {
        // Null obj uuid, check the map_tower.

        if (pBuffer[1] != 0)
            pBuffer[1] = 1;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\astub.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    asyncstub.h

Abstract:

    This is the generated header file

--*/


void
Foo (
    PRPC_ASYNC_STATE pAsync,
    RPC_BINDING_HANDLE hBinding,
    /* [in] */ int sizein,
    /* [in] */ int *bufferin,
    /* [in, out] */ int *sizeout,
    /* [out] */ int **bufferout
    ) ;

//
// Begin, Generated header file
// declare the pipe structure
typedef struct {
    void *state ;
    RPC_STATUS (*PipeReceive) (
                               PRPC_ASYNC_STATE pAsync,
                               int *buffer,
                               int requested_count,
                               int *actual_count) ;
    RPC_STATUS (*PipeSend) (
                            PRPC_ASYNC_STATE pAsync,
                            void *context,
                            int *buffer,
                            int num_elements) ;
    } async_intpipe ;

void
FooPipe (
    PRPC_ASYNC_STATE pAsync,
    RPC_BINDING_HANDLE hBinding,
    /* [in] */ int checksum_in,
    /* [in] */ async_intpipe *inpipe,
    /* [out] */ async_intpipe *outpipe,
    /* [out] */ int *checksum_out) ;


#define APP_ERROR          0xBABE000L
#define SYNC_EXCEPT      APP_ERROR+1
#define ASYNC_EXCEPT    APP_ERROR+2

#define UUID_TEST_CANCEL     10
#define UUID_SLEEP_1000      11
#define UUID_EXTENDED_ERROR  12
#define UUID_ASYNC_EXCEPTION 13
#define UUID_SYNC_EXCEPTION  14
#define UUID_SLEEP_2000      15
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\align.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    Align.h

Abstract:

    Defines a macro for aligning an integer value or pointer
    to 0 mod 2^n for any n.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     12-22-95    Bits 'n pieces
    MarioGo     02-19-96    Made type safe for C++.

--*/

#ifndef _ALIGN_H
#define _ALIGN_H

#ifdef __cplusplus

//
// The C++ interface looks like
//
//  val = Align(val, 8)  // returns val aligned to 0 mod 8
//  val = Align16(val);  // returns val aligned to 0 mod 16
//
//  Boths forms on the interface are equally efficient.
//
//  Returns the argument aligned up to the nearest "0 mod factor" boundary.  Has
//  no affect on values which are already aligned to 0 mod factor.  The argument
//  maybe any integer or void pointer type.
//
//

#define DECL_ALIGN_N(type) inline type Align( type value, int poft)       \
    {                                                                     \
    return (type)( ((unsigned long)(value) + ((poft)-1)) & ~(poft - 1) );     \
    }

#define DECL_ALIGN(poft, type) inline type Align##poft ( type value )     \
    {                                                                     \
    return Align(value, poft);                                            \
    }

#define DECL_PAD_N(type) inline unsigned int Pad( type value, int poft )  \
    {                                                                     \
    return (-(long)value) & (poft - 1);                                   \
    }

#define DECL_PAD(poft, type) inline unsigned int Pad##poft (type value)   \
    {                                                                     \
    return Pad(value, poft);                                              \
    }

// same padding, but on pointer type size of argument
#define DECL_ALIGN_PTR_N(type) inline type AlignPtr( type value, int poft)       \
    {                                                                     \
    return (type)( ((ULONG_PTR)(value) + ((poft)-1)) & ~(poft - 1) );     \
    }

#define DECL_ALIGN_PTR(poft, type) inline type AlignPtr##poft ( type value )     \
    {                                                                     \
    return AlignPtr(value, poft);                                            \
    }

#define DECL_PAD_PTR_N(type) inline unsigned int PadPtr( type value, int poft )  \
    {                                                                     \
    return (unsigned int)((-(LONG_PTR)value) & (poft - 1));                       \
    }

#define DECL_PAD_PTR(poft, type) inline unsigned int PadPtr##poft (type value)   \
    {                                                                     \
    return PadPtr(value, poft);                                              \
    }

#define DECL_ALL_ALIGN(type)     \
    DECL_ALIGN_N(type)           \
    DECL_ALIGN(2, type)          \
    DECL_ALIGN(4, type)          \
    DECL_ALIGN(8, type)          \
    DECL_ALIGN(16, type)         \
    DECL_ALIGN(32, type)

#define DECL_ALL_PAD(type)       \
    DECL_PAD_N(type)             \
    DECL_PAD(2, type)            \
    DECL_PAD(4, type)            \
    DECL_PAD(8, type)            \
    DECL_PAD(16, type)           \
    DECL_PAD(32, type)

#define DECL_ALL_ALIGN_PTR(type)     \
    DECL_ALIGN_PTR_N(type)           \
    DECL_ALIGN_PTR(2, type)          \
    DECL_ALIGN_PTR(4, type)          \
    DECL_ALIGN_PTR(8, type)          \
    DECL_ALIGN_PTR(16, type)         \
    DECL_ALIGN_PTR(32, type)

#define DECL_ALL_PAD_PTR(type)       \
    DECL_PAD_PTR_N(type)             \
    DECL_PAD_PTR(2, type)            \
    DECL_PAD_PTR(4, type)            \
    DECL_PAD_PTR(8, type)            \
    DECL_PAD_PTR(16, type)           \
    DECL_PAD_PTR(32, type)

#define DECL_ALL_ALIGN_AND_PAD(type) \
    DECL_ALL_PAD(type)               \
    DECL_ALL_ALIGN(type)

#define DECL_ALL_ALIGN_AND_PAD_PTR(type) \
    DECL_ALL_PAD_PTR(type)               \
    DECL_ALL_ALIGN_PTR(type)

DECL_ALL_ALIGN_AND_PAD(short)
DECL_ALL_ALIGN_AND_PAD(unsigned short)
DECL_ALL_ALIGN_AND_PAD(long)
DECL_ALL_ALIGN_AND_PAD(unsigned long)
DECL_ALL_ALIGN_AND_PAD(int)
DECL_ALL_ALIGN_AND_PAD(unsigned int)
DECL_ALL_ALIGN_AND_PAD_PTR(void __RPC_FAR *)

#ifdef _WIN64
DECL_ALL_ALIGN_AND_PAD(unsigned __int64)
#endif

#if defined(_WIN64)
#define RPCRT_DEFAULT_STRUCT_ALIGNMENT  8
#define RPCRT_NATURAL_BOUNDARY 16
#else
#define RPCRT_DEFAULT_STRUCT_ALIGNMENT  4
#define RPCRT_NATURAL_BOUNDARY 8
#endif

inline BOOL IsBufferAligned(PVOID p)
{
    return (((ULONG_PTR)p % RPCRT_NATURAL_BOUNDARY) == 0);
}

inline BOOL IsBufferAlignedOnStructBoundary(PVOID p)
{
    return (((ULONG_PTR)p % RPCRT_DEFAULT_STRUCT_ALIGNMENT) == 0);
}

inline BOOL IsBufferSizeAligned(size_t s)
{
    return ((s % RPCRT_NATURAL_BOUNDARY) == 0);
}

inline unsigned int PadToNaturalBoundary (unsigned int Value)
{
#if defined(_WIN64)
    return Pad16(Value);
#else
    return Pad8(Value);
#endif    
}

inline PVOID AlignOnNaturalBoundary (PVOID Value)
{
#if defined(_WIN64)
    return AlignPtr16(Value);
#else
    return AlignPtr8(Value);
#endif    
}

// required for global constant expressions
#define ConstPadN(p, poft) ( (-(long)p) & (poft - 1) )

// The maximum size of the padding when aligning to a natural boundary. 
// It is at most (natural boundary - 1) (or max(x mod natural boundary) for all x).
#define RPCRT_NATURAL_BOUNDARY_ALIGNMENT_MAX_SHIFT (RPCRT_NATURAL_BOUNDARY-1)

#define SIZE_OF_OBJECT_AND_PADDING(ObjectType) \
    (sizeof(ObjectType) + ConstPadN(sizeof(ObjectType), RPCRT_DEFAULT_STRUCT_ALIGNMENT))

#else

// C interface.

#define AlignN(p, poft) ( ((unsigned long)(p) + ((poft)-1)) & ~(poft - 1) )
#define PadN(p, poft) ( (-(long)p) & (poft - 1) )

#ifdef DOS
#define AlignPtrN(value, poft) (void __far *)AlignN(value, poft)
#define AlignNearPtrN(value, poft) (void __near *)AlignN(value, poft)
#else
#define AlignPtrN(value, poft) (void *)AlignN(value, poft)
#define AlignNearPtrN(value, poft) (void *)AlignN(value, poft)
#endif

// For aligning integer values

#define Align2(p) AlignN((p), 2)
#define Align4(p) AlignN((p), 4)
#define Align8(p) AlignN((p), 8)
#define Align16(p) AlignN((p), 16)
#define Align32(p) AlignN((p), 32)

// For aligning pointers

#define AlignPtr2(p) AlignPtrN((p), 2)
#define AlignPtr4(p) AlignPtrN((p), 4)
#define AlignPtr8(p) AlignPtrN((p), 8)
#define AlignPtr16(p) AlignPtrN((p), 16)
#define AlignPtr32(p) AlignPtrN((p), 32)

// For near pointers
#define AlignNearPtr2(p) AlignNearPtrN((p), 2)
#define AlignNearPtr4(p) AlignNearPtrN((p), 4)
#define AlignNearPtr8(p) AlignNearPtrN((p), 8)
#define AlignNearPtr16(p) AlignNearPtrN((p), 16)
#define AlignNearPtr32(p) AlignNearPtrN((p), 32)

// For everything
#define Pad2(p) PadN((p), 2)
#define Pad4(p) PadN((p), 4)
#define Pad8(p) PadN((p), 8)
#define Pad16(p) PadN((p), 16)
#define Pad32(p) PadN((p), 32)

#endif // __cplusplus

#endif // _ALIGN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\bcache.cxx ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

    Module Name:

        bcache.cxx

    Abstract:

        RPC's buffer cache implementation

    Author:

        Mario Goertzel    [MarioGo]

    Revision History:

        MarioGo     9/7/1997    Bits 'n pieces
        KamenM      5/15/2001   Rewrite the paged bcache implementation
        GrigoriK    6/2002      Rewrite bcache to work with read-only page heap
                                eliminating paged bcache infrastructure.

--*/

#include <precomp.hxx>

////////////////////////////////////////////////////////////
// (Internal) Perf counters
//#define BUFFER_CACHE_STATS

#ifdef BUFFER_CACHE_STATS
LONG cAllocs = 0;
LONG cFrees = 0;
LONG cAllocsMissed = 0;
LONG cFreesBack = 0;

#define INC_STAT(x) InterlockedIncrement(&x)

#else
#define INC_STAT(x)
#endif

////////////////////////////////////////////////////////////

typedef BCACHE_STATE *PBCTLS;

////////////////////////////////////////////////////////////
// Default hints

CONST BUFFER_CACHE_HINTS gCacheHints[4] =
{
    // 64 bits and WOW6432 use larger message size
#if defined(_WIN64) || defined(USE_LPC6432)
    {1, 4, 512},      // LRPC message size and small calls
#else
    {1, 4, 256},      // LRPC message size and small calls
#endif
    {1, 3, 1024},     // Default CO receive size
    {1, 3, 4096+44},  // Default UDP receive size
    {1, 3, 5840}      // Maximum CO fragment size
};

BUFFER_CACHE_HINTS *pHints = (BUFFER_CACHE_HINTS *)gCacheHints;
BCacheMode gBCacheMode = BCacheModeCached;
BCACHE *gBufferCache;


BCACHE::BCACHE( OUT RPC_STATUS &status)
    // The default process heap lock spin count. This lock is held only
    // for a very short time while pushing/poping into a singly linked list.

    // PERF: move to a user-mode slist implementation if available.
    : _csBufferCacheLock(&status, TRUE, 4000)
{
    DWORD Type;
    DWORD DataSize;
    DWORD Value;

    if (status != RPC_S_OK)
        return;

    // Compute the per cache size default buffer cache cap.
    // This only matters for the default mode.
    UINT cCapBytes = 20 * 1024;  // Start at 20KB for UP workstations.
                              
    if (gfServerPlatform) cCapBytes *= 2;            // *2 for servers
    if (gNumberOfProcessors > 1) cCapBytes *= 2;    // *2 for MP boxes

    for (int i = 0; i < 4; i++)
        {
        _bcGlobalState[i].cBlocks= 0;
        _bcGlobalState[i].pList = 0;

        if (gBCacheMode == BCacheModeDirect)
            {
            _bcGlobalStats[i].cBufferCacheCap = 0;
            _bcGlobalStats[i].cAllocationHits = 0;
            _bcGlobalStats[i].cAllocationMisses = 0;
            }
        else
            {
            _bcGlobalStats[i].cBufferCacheCap = cCapBytes / pHints[i].cSize;

            // We keeps stats on process wide cache hits and misses from the
            // cache.  We initially give credit for 2x allocations required
            // to load the cache.  Any adjustments to the cap, up only, occur
            // in ::FreeHelper.

            _bcGlobalStats[i].cAllocationHits = _bcGlobalStats[i].cBufferCacheCap * 2*8;
            _bcGlobalStats[i].cAllocationMisses = 0;
            }
        }

    return;
}

BCACHE::~BCACHE()
{
    // There should be only one BCACHE object that lives forever.
    // This destructor will be called iff _csBufferCacheLock could
    // not be initialized in the constructor.  We do not need to do
    // anything since the body of constructor did not execute.
}

PVOID
BCACHE::Allocate(CONST size_t cSize)
{
    PBUFFER pBuffer;
    int index;

    INC_STAT(cAllocs);

    // In direct bcache mode try to allocate from heap. We favor
    // full release over speed in order to catch the offenders
    // who touch memory after releasing it.
    if (gBCacheMode == BCacheModeDirect)
        {
        return(AllocHelper(cSize, 
            -1,     // Index
            0       // per thread cache
            ));
        }

    // Find the right bucket, if any.  Binary search.

    if (cSize <= pHints[1].cSize)
        {
        if (cSize <= pHints[0].cSize)
            {
            index = 0;
            }
        else
            {
            index = 1;
            }
        }
    else
        {
        if (cSize <= pHints[2].cSize)
            {
            index = 2;
            }
        else
            {
            if (cSize <= pHints[3].cSize)
                {
                index = 3;
                }
            else
                {
                return(AllocHelper(cSize, 
                    -1,     // Index
                    0       // per thread cache
                    ));
                }
            }
        }

    // Try the per-thread cache, this is the 90% case
    THREAD *pThread = RpcpGetThreadPointer();
    ASSERT(pThread);
    PBCTLS pbctls = pThread->BufferCache;

    if (pbctls[index].pList)
        {
        // we shouldn't have anything in the thread cache in paged bcache mode
        ASSERT(gBCacheMode == BCacheModeCached);
        ASSERT(pbctls[index].cBlocks);

        pBuffer = pbctls[index].pList;
        pbctls[index].pList = pBuffer->pNext;
        pbctls[index].cBlocks--;

        pBuffer->index = index + 1;

        LogEvent(SU_BCACHE, EV_BUFFER_OUT, pBuffer, 0, index, 1, 2);

        return((PVOID)(pBuffer + 1));
        }

    // This is the 10% case

    INC_STAT(cAllocsMissed);

    return(AllocHelper(cSize, index, pbctls));

}

PVOID
BCACHE::AllocHelper(
    IN size_t cSize,
    IN INT index,
    PBCTLS pbctls
    )
/*++

Routine Description:

    Called by BCACHE::Alloc on either large buffers (index == -1)
    or when the per-thread cache is empty.

Arguments:

    cSize - Size of the block to allocate.
    index - The bucket index for this size of block
    pbctls - The per-thread cache, NULL iff index == -1.

Return Value:

    0 - out of memory
    non-zero - A pointer to a block at least 'cSize' bytes long. The returned
    pointer is to the user portion of the block.

--*/
{
    PBUFFER pBuffer = NULL;
    LIST_ENTRY *CurrentListEntry;
    BOOL fFoundUncommittedSegment;
    ULONG TargetSegmentSize;
    PVOID SegmentStartAddress;
    PVOID pTemp;
    BOOL Result;

    // Large buffers are a special case.  Go dirrectly to the heap.
    if (index == -1)
        {
        pBuffer = AllocBlock(cSize);

        if (pBuffer)
            {
            LogEvent(SU_BCACHE, EV_BUFFER_OUT, pBuffer, 0, index, 1, 2);
            return((PVOID(pBuffer + 1)));
            }

        LogEvent(SU_BCACHE, EV_BUFFER_FAIL, 0, 0, index, 1);
        return(0);
        }

    // Try to allocate a process cached buffer

    // loop to avoid taking the mutex in the empty list case.
    // This allows us to opportunistically take it in the
    // non-empty list case only.
    do
        {
        if (0 == _bcGlobalState[index].pList)
            {
            // Looks like there are no global buffer available, allocate
            // a new buffer.
            ASSERT(IsBufferSizeAligned(sizeof(BUFFER_HEAD)));
            cSize = pHints[index].cSize + sizeof(BUFFER_HEAD);

            pBuffer = (PBUFFER) new BYTE[cSize];

            if (!pBuffer)
                {
                LogEvent(SU_BCACHE, EV_BUFFER_FAIL, 0, 0, index, 1);
                return(0);
                }

            _bcGlobalStats[index].cAllocationMisses++;

            break;
            }

        _csBufferCacheLock.Request();

        if (_bcGlobalState[index].pList)
            {
            ASSERT(_bcGlobalState[index].cBlocks);

            pBuffer = _bcGlobalState[index].pList;
            _bcGlobalState[index].cBlocks--;
            _bcGlobalStats[index].cAllocationHits++;

            ASSERT(pbctls[index].pList == NULL);
            ASSERT(pbctls[index].cBlocks == 0);

            PBUFFER pkeep = pBuffer;
            UINT cBlocksMoved = 0;

            while (pkeep->pNext && cBlocksMoved < pHints[index].cLowWatermark)
                {
                pkeep = pkeep->pNext;
                cBlocksMoved++;
                }

            pbctls[index].cBlocks = cBlocksMoved;
            _bcGlobalState[index].cBlocks -= cBlocksMoved;
            _bcGlobalStats[index].cAllocationHits += cBlocksMoved;

            // Now we have the head of the list to move to this
            // thread (pBuffer->pNext) and the tail (pkeep).

            // Block counts in the global state and thread state have
            // already been updated.

            pbctls[index].pList = pBuffer->pNext;

            ASSERT(pkeep->pNext || _bcGlobalState[index].cBlocks == 0);
            _bcGlobalState[index].pList = pkeep->pNext;

            // Break the link (if any) between the new per thread list
            // and the blocks which will remain in the process list.
            pkeep->pNext = NULL;
            }

        _csBufferCacheLock.Clear();

        }
    while (NULL == pBuffer );

    ASSERT(pBuffer);

    ASSERT(IsBufferAligned(pBuffer));

    pBuffer->index = index + 1;

    LogEvent(SU_BCACHE, EV_BUFFER_OUT, pBuffer, 0, index, 1, 2);
    return((PVOID(pBuffer + 1)));
}

VOID
BCACHE::Free(PVOID p)
/*++

Routine Description:

    The fast (common) free path.  For large blocks it just deletes them.  For
    small blocks that are inserted into the thread cache.  If the thread
    cache is too large it calls FreeHelper().

Arguments:

    p - The pointer to free.

Return Value:

    None

--*/
{
    PBUFFER pBuffer = ((PBUFFER )p - 1);
    INT index;

    ASSERT(((pBuffer->index >= 1) && (pBuffer->index <= 4)) || (pBuffer->index == -1));

    index = pBuffer->index - 1;

    LogEvent(SU_BCACHE, EV_BUFFER_IN, pBuffer, 0, index, 1, 1);

    INC_STAT(cFrees);

    if (index >= 0)
        {
        // Free to thread cache

        THREAD *pThread = RpcpGetThreadPointer();

        if (NULL == pThread)
            {
            // No thread cache available - free to process cache.
            FreeBuffers(pBuffer, index, 1);
            return;
            }

        PBCTLS pbctls = pThread->BufferCache;

        pBuffer->pNext = pbctls[index].pList;
        pbctls[index].pList = pBuffer;
        pbctls[index].cBlocks++;

        if (pbctls[index].cBlocks >= pHints[index].cHighWatermark)
            {
            // 10% case - Too many blocks in the thread cache, free to process cache

            FreeHelper(p, index, pbctls);
            }
        }
    else
        {
        FreeBlock(pBuffer);
        }

    return;
}

VOID
BCACHE::FreeHelper(PVOID p, INT index, PBCTLS pbctls)
/*++

Routine Description:

    Called only by Free().  Separate code to avoid unneeded saves/
    restores in the Free() function.  Called when too many
    blocks are in a thread cache bucket.

Arguments:

    p - The pointer being freed, used if pbctls is NULL
    index - The bucket index of this block
    pbctls - A pointer to the thread cache structure.  If
        NULL the this thread has no cache (yet) p should
        be directly freed.

Return Value:

    None

--*/
{
    ASSERT(pbctls[index].cBlocks == pHints[index].cHighWatermark);

    INC_STAT(cFreesBack);

    // First, build the list to free from the TLS cache

    // Note: We free the buffers at the *end* of the per thread cache.  This helps
    // keep a set of buffers near this thread and (with luck) associated processor.

    PBUFFER ptail = pbctls[index].pList;

    // pbctls[index].pList contains the new keep list. (aka pBuffer)
    // ptail is the pointer to the *end* of the keep list.
    // ptail->pNext will be the head of the list to free.

    // One element already in keep list.
    ASSERT(pHints[index].cLowWatermark >= 1);

    for (unsigned i = 1; i < pHints[index].cLowWatermark; i++)
        {
        ptail = ptail->pNext; // Move up in the free list
        ASSERT(ptail);
        }

    // Save the list to free and break the link between keep list and free list.
    PBUFFER pfree = ptail->pNext;
    ptail->pNext = NULL;

    // Thread cache now contains on low watermark elements.
    pbctls[index].cBlocks = pHints[index].cLowWatermark;

    // Now we need to free the extra buffers to the process cache
    FreeBuffers(pfree, index, pHints[index].cHighWatermark - pHints[index].cLowWatermark);
    
    return;
}

VOID
BCACHE::FreeBuffers(PBUFFER pBuffers, INT index, UINT cBuffers)
/*++

Routine Description:

    Frees a set of buffers to the global (process) cache.  Maybe called when a 
    thread has exceeded the number of buffers is wants to cache or when a 
    thread doesn't have a thread cache but we still need to free a buffer.

Arguments:

    pBuffers - A linked list of buffers which need to be freed.
               
    cBuffers - A count of the buffers to be freed.

Return Value:

    None

--*/
{
    PBUFFER pfree = pBuffers;
    BOOL Result;
    PVOID Allocation;

    // Special case for the freeing without a TLS blob.  We're freeing just
    // one buffer but it's next pointer may not be NULL.  

    if (cBuffers == 1)
        {
        pfree->pNext = 0;
        }
    
    // Find the end of the to free list

    PBUFFER ptail = pfree;
    while(ptail->pNext)
        {
        ptail = ptail->pNext;
        }

    // We have a set of cBuffers buffers starting with pfree and ending with
    // ptail that need to move into the process wide cache now.

    _csBufferCacheLock.Request();

    // If we have too many free buffers or the cache is off we'll throw away these extra buffers.

    if ((_bcGlobalState[index].cBlocks >= _bcGlobalStats[index].cBufferCacheCap)
        || (gBCacheMode == BCacheModeDirect))
        {
        // It looks like we have too many buffers or the cache is off.  We can either increase the buffer
        // cache cap or really free the buffers.

        if ((_bcGlobalStats[index].cAllocationHits > _bcGlobalStats[index].cAllocationMisses * 8)
            || (gBCacheMode == BCacheModeDirect))
            {
            // Cache hit rate looks good or we don't want cache, we're going to really free the buffers.
            // Don't hold the lock while actually freeing to the heap.

            _csBufferCacheLock.Clear();

            PBUFFER psave;

            while(pfree)
                {
                psave = pfree->pNext;
            
                delete pfree;
                pfree = psave;
                }

            return;
            }

        // Hit rate looks BAD.  Time to bump up the buffer cache cap.

        UINT cNewCap = _bcGlobalStats[index].cBufferCacheCap;

        cNewCap = min(cNewCap + 32, cNewCap * 2);
                      
        _bcGlobalStats[index].cBufferCacheCap = cNewCap;

        // Start keeping new stats, start with a balanced ratio of hits to misses.
        // We'll get at least (cBlocks + cfree) more hits before the next new miss.

        _bcGlobalStats[index].cAllocationHits = 8 * cNewCap;
        _bcGlobalStats[index].cAllocationMisses = 0;

        // Drop into regular free path, we're going to keep these buffers.
        }

    _csBufferCacheLock.VerifyOwned();

    ptail->pNext = _bcGlobalState[index].pList;
    _bcGlobalState[index].pList = pfree;
    _bcGlobalState[index].cBlocks += cBuffers;

    _csBufferCacheLock.Clear();
    return;
}

void
BCACHE::ThreadDetach(THREAD *pThread)
/*++

Routine Description:

    Called when a thread dies.  Moves any cached buffes into
    the process wide cache.

Arguments:

    pThread - The thread object of the thread which is dying.

Return Value:

    None

--*/
{
    PBCTLS pbctls = pThread->BufferCache;
    INT index;

    // CacheLevelOff mode has no thread cache.
    if (gBCacheMode == BCacheModeDirect)
        {
        ASSERT(pbctls[0].pList == 0);
        ASSERT(pbctls[1].pList == 0);
        ASSERT(pbctls[2].pList == 0);
        ASSERT(pbctls[3].pList == 0);
        }

    for (index = 0; index < 4; index++)
        {

        if (pbctls[index].pList)
            {
            ASSERT(pbctls[index].cBlocks);            

            FreeBuffers(pbctls[index].pList, index, pbctls[index].cBlocks);

            pbctls[index].pList = 0;
            pbctls[index].cBlocks = 0;
            }

        ASSERT(pbctls[index].pList == 0);
        ASSERT(pbctls[index].cBlocks == 0);
        }
}


PBUFFER
BCACHE::AllocBlock(
    IN size_t cBytes
    )
/*++

Routine Description:

    Allocates a buffer directly from the RPC heap.

    In page heap mode allocates buffers from read-only RPC page heap.

Notes:

    Designed with 4Kb and 8Kb pages in mind.  Assumes address space
    is allocated 64Kb at a time.

Arguments:

    cBytes - The size of allocation needed.

Return Value:

    null - out of Vm
    non-null - a pointer to a buffer of cBytes rounded up to page size.

--*/
{
    PBUFFER p;
    size_t BytesToAllocate;
    PVOID pT;

    ASSERT(IsBufferSizeAligned(sizeof(BUFFER_HEAD)));

    BytesToAllocate = cBytes + sizeof(BUFFER_HEAD);

    p = (PBUFFER) new BYTE[BytesToAllocate];

    if (p)
        {
        p->index = -1;
        p->size = BytesToAllocate;
        }

    return (p);
}

VOID
BCACHE::FreeBlock(
    IN PBUFFER pBuffer
    )
/*++

Routine Description:

    Frees a buffer allocated by AllocBlock

Arguments:

    ptr - The buffer to free

Return Value:

    None

--*/
{
    delete [] pBuffer;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\bitset.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       bitset.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File : bitset.cxx

Title : Bit vector implementation of a set.

History :

mikemon    ??-??-??    Beginning of recorded history.
mikemon    11-13-90    Commented the source.

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <bitset.hxx>

int
BITSET::Insert (
    IN int Key
    )
{
    unsigned int * pNewBits;
    int cCount;

    //
    // Check if the Key will fit into the current bit vector.
    //

    if ((int) ((Key/(sizeof(int)*8))+1) > cBits)
        {
        //
        // We need more space in the bit vector, so allocate enough space 
        // to hold the bit for the specified key, copy the old bit vector into the 
        // new bit vector, and then free the old one.
        //

        pNewBits = new unsigned int [Key/(sizeof(int)*8)+1];
        if (pNewBits == (unsigned int *) 0)
            return(1);

        for (cCount = 0; cCount < cBits; cCount++)
            pNewBits[cCount] = pBits[cCount];

        cBits = Key/(sizeof(int)*8) + 1;

        for ( ; cCount < cBits; cCount++)
            pNewBits[cCount] = 0;

        if (pBits != &InitialStorage)
            delete pBits;
        pBits = pNewBits;
        }

    //
    // Turn on the appropriate bit, by ORing it in.
    //
    pBits[Key/(sizeof(int)*8)] |= (1 << (Key % (sizeof(int)*8)));
    return(0);
}

void
BITSET::Delete (
    IN int Key
    )
{
    if ((int) (Key/(sizeof(int)*8)) > cBits-1)
        return;

    //
    // Turn off the appropriate bit, by ANDing in the complement.
    //
    pBits[Key/(sizeof(int)*8)] &= ~(1 << (Key % (sizeof(int)*8)));
}

int
BITSET::MemberP (
    IN int Key
    )
{
    if ((int) (Key/(sizeof(int)*8)) > cBits-1)
        return(0);

    //
    // Test for the appropriate bit
    //
    return(((pBits[Key/(sizeof(int)*8)]
            & (1 << (Key % (sizeof(int)*8)))) ? 1 : 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\binding.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    binding.cxx

Abstract:

    The implementation of the DCE binding class is contained in this
    file.

Author:

    Michael Montague (mikemon) 04-Nov-1991

Revision History:
    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff

--*/

#include <precomp.hxx>
#include <epmap.h>
#include <hndlsvr.hxx>
#include <sdict2.hxx>
#include <dispatch.h>
#include <osfpcket.hxx>
#include <bitset.hxx>
#include <ProtBind.hxx>
#include <osfclnt.hxx>
#include <osfsvr.hxx>
#include <sidcache.hxx>
#include <rpctrans.hxx>


UUID   MgmtIf = { 0xafa8bd80,0x7d8a,0x11c9,
                    {0xbe,0xf4,0x08,0x00,0x2b,0x10,0x29,0x89} };
UUID   NullUuid = { 0L, 0, 0, {0,0,0,0,0,0,0,0} };


int
IsMgmtIfUuid(
   UUID PAPI * IfId
   )
{

  if (RpcpMemoryCompare(IfId, &MgmtIf, sizeof(UUID)) == 0)
      {
      return 1;
      }

  return 0;
}


RPC_CHAR *
DuplicateString (
    IN const RPC_CHAR PAPI * String
    )
/*++

Routine Description:

    When this routine is called, it will duplicate the string into a fresh
    string and return it.

Arguments, either:

    String - Supplies the string to be duplicated.

Return Value:

    The duplicated string is returned.  If insufficient memory is available
    to allocate a fresh string, zero will be returned.

--*/
{
    RPC_CHAR * FreshString, * FreshStringScan;
    const RPC_CHAR PAPI * StringScan;
    unsigned int Length;

    ASSERT(String);

    Length = 1;
    StringScan = String;
    while (*StringScan++ != 0)
        Length += 1;

    FreshString = new RPC_CHAR[Length];
    if (FreshString == 0)
        return(0);

    for (FreshStringScan = FreshString, StringScan = String;
            *StringScan != 0; FreshStringScan++, StringScan++)
        {
        *FreshStringScan = *StringScan;
        }
    *FreshStringScan = *StringScan;

    return(FreshString);
}

PSID
DuplicateSID (
    IN const PSID Sid
    )
/*++

Routine Description:

    When this routine is called, it will duplicate the sid into a fresh
    sid and return it.

Arguments, either:

    Sid - Supplies the sid to be duplicated.

Return Value:

    The duplicated sid is returned.  If insufficient memory is available
    to allocate a fresh sid, zero will be returned.

--*/
{
    PSID NewSid;
    ULONG SidLength;
    BOOL Result;

    ASSERT(IsValidSid(Sid));

    SidLength = GetLengthSid (Sid);

    NewSid = (PSID) new unsigned char [SidLength];

    if (NewSid == NULL)
        return(NULL);

    Result = CopySid (SidLength, NewSid, Sid);

    // CopySid cannot fail unless we gave it invalid parameters
    ASSERT(Result);

    return NewSid;
}

RPC_STATUS
RpcpLookupAccountNameDirect (
    IN RPC_CHAR *ServerPrincipalName,
    OUT PSID *Sid
    )
/*++

Routine Description:

    Lookups a server principal name and translates it to a SID.
    Basically an RPC wrapper for LookupAccountName (with some
    memory management stuff thrown in).

Arguments, either:

    ServerPrincipalName - the server principal name to be translated to
        a SID

    Sid - On output contains a pointer to the allocated SID. Undefined on
        failure. Pointer must be freed with delete.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    int i;
    DWORD SizeofSID, DomainNameLen;
    SID_NAME_USE eUse;
    RPC_CHAR *pDomainName;
    PSID pSID;
    DWORD LastError;
    RPC_STATUS Status;

    SizeofSID = sizeof(SID)+10*sizeof(ULONG);
    DomainNameLen = 256;

    for (i = 0; i < 2; i++)
        {
        pSID = (PSID) new char[SizeofSID];
        pDomainName = new RPC_CHAR[DomainNameLen];

        if (pSID == 0 || pDomainName == 0)
            {
            delete [] pSID;
            delete [] pDomainName;

            return RPC_S_OUT_OF_MEMORY;
            }

        if (LookupAccountNameW (
                                NULL,
                                ServerPrincipalName,
                                pSID,
                                &SizeofSID,
                                pDomainName,
                                &DomainNameLen,
                                &eUse)) 
            {
            break;
            }

        delete [] pSID;
        delete [] pDomainName;

        LastError = GetLastError();
        if (LastError != ERROR_INSUFFICIENT_BUFFER)
            {
            switch (LastError)
                {
                case ERROR_NONE_MAPPED:
                    Status = RPC_S_UNKNOWN_PRINCIPAL;
                    break;

                case ERROR_OUTOFMEMORY:
                    Status = RPC_S_OUT_OF_MEMORY;
                    break;

                case ERROR_TRUSTED_RELATIONSHIP_FAILURE:
                    Status = ERROR_TRUSTED_RELATIONSHIP_FAILURE;
                    break;

                default:
                    Status = RPC_S_ACCESS_DENIED;
                }

            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status,
                EEInfoDLRpcpLookupAccountName10,
                LastError);

            return Status;
            }
        }
    delete [] pDomainName;

    ASSERT(i < 2);

    *Sid = pSID;

    return RPC_S_OK;
}

RPC_STATUS
RpcpLookupAccountName (
    IN RPC_CHAR *ServerPrincipalName,
    IN OUT BOOL *fCache,
    OUT PSID *Sid
    )
/*++

Routine Description:

    Lookups a server principal name and translates it to a SID.
    For performance reasons, we first look the account name up in our
    per process SIDCache, if its not present there, then we look it up and
    add it.


    Note:  This function maps ERROR_TRUSTED_RELATIONSHIP_FAILURE to 
           RPC_S_ACCESS_DENIED.  If you need to receive 
           ERROR_TRUSTED_RELATIONSHIP_FAILURE, then call
           RpcpLookupAccountNameDirect.

Arguments, either:

    ServerPrincipalName - the server principal name to be translated to
        a SID
    
    fCache - On input: If true, then we will first try the cache, if false then 
             we will look the name up directly and bypass the cache.

             On output: If true, then the SID was retrieved from the cache, if false,
             it was retrieved from a lookup.  Undefined on failure.

    Sid - On output contains a pointer to the allocated SID. Undefined on
        failure. Pointer must be freed with delete.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS Status;


    if (*fCache)
        {
        // Query the cache to see if we have looked up this account name already
        Status = QuerySIDCache(ServerPrincipalName, Sid);

        if (Status != RPC_S_OK)
            {       
            return Status;
            }

        if (*Sid != NULL)
            {
            return RPC_S_OK;
            }
        }

    // The account name is not in our cache, we need to look it up
    Status = RpcpLookupAccountNameDirect(ServerPrincipalName,
                                         Sid);

    if (Status == ERROR_TRUSTED_RELATIONSHIP_FAILURE)
        {
        Status = RPC_S_ACCESS_DENIED;
        }

    if (Status == RPC_S_OK)
        {
        *fCache = FALSE;
        // Add this mapping to our cache
        (void) AddToSIDCache(ServerPrincipalName, *Sid);
        }

    return Status;
}

RPC_STATUS
RpcpLookupAccountSid (
    IN PSID Sid,
    OUT RPC_CHAR **ServerPrincipalName
    )
/*++

Routine Description:

    Lookups a SID and translates it to a server principal name.
    Basically an RPC wrapper for LookupAccountSid (with some
    memory management stuff thrown in).

Arguments, either:

    Sid - the SID to be translated into a server principal name.

    ServerPrincipalName - on output, a pointer to the allocated
        server principal name. Undefined on failure.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    int i;
    DWORD SPNLength, DomainNameLen;
    SID_NAME_USE eUse;
    RPC_CHAR *pDomainName, *pServerPrincipalName;
    DWORD LastError;
    RPC_STATUS Status;

    SPNLength = 256;
    DomainNameLen = 256;

    for (i = 0; i < 2; i++)
        {
        pServerPrincipalName = new RPC_CHAR[SPNLength];
        pDomainName = new RPC_CHAR[DomainNameLen];

        if (pServerPrincipalName == 0 || pDomainName == 0)
            {
            delete [] pServerPrincipalName;
            delete [] pDomainName;

            return RPC_S_OUT_OF_MEMORY;
            }

        if (LookupAccountSidW (
                                NULL,
                                Sid,
                                pServerPrincipalName,
                                &SPNLength,
                                pDomainName,
                                &DomainNameLen,
                                &eUse)) 
            {
            break;
            }

        delete [] pServerPrincipalName;
        delete [] pDomainName;

        LastError = GetLastError();
        if (LastError != ERROR_INSUFFICIENT_BUFFER)
            {
            switch (LastError)
                {
                case ERROR_NONE_MAPPED:
                    Status = RPC_S_UNKNOWN_PRINCIPAL;
                    break;

                case ERROR_OUTOFMEMORY:
                    Status = RPC_S_OUT_OF_MEMORY;
                    break;

                default:
                    Status = RPC_S_ACCESS_DENIED;
                }

            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status,
                EEInfoDLRpcpLookupAccountName10,
                LastError);

            return Status;
            }
        }
    delete [] pDomainName;

    ASSERT(i < 2);

    *ServerPrincipalName = pServerPrincipalName;

    return RPC_S_OK;
}

DCE_BINDING::DCE_BINDING (
    IN RPC_CHAR PAPI * ObjectUuid OPTIONAL,
    IN RPC_CHAR PAPI * RpcProtocolSequence OPTIONAL,
    IN RPC_CHAR PAPI * NetworkAddress OPTIONAL,
    IN RPC_CHAR PAPI * Endpoint OPTIONAL,
    IN RPC_CHAR PAPI * Options OPTIONAL,
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    The constructor creates a DCE_BINDING object based on the pieces of
    the string binding specified.

Arguments:

    ObjectUuid - Optionally supplies the object uuid component of the
        binding.

    RpcProtocolSequence - Optionally supplies the rpc protocol sequence
        component of the binding.

    NetworkAddress - Optionally supplies the network address component
        of the binding.

    Endpoint - Optionally supplies the endpoint component of the binding.

    Options - Optionally supplies the network options component of the
        binding.

    Status - Returns the status of the operation.  This argument will
        be set to one of the following values.

        RPC_S_OK - The operation completed successfully.

        RPC_S_INVALID_STRING_UUID - The specified object uuid does
            not contain the valid string representation of a uuid.

        RPC_S_OUT_OF_MEMORY - Insufficient memory is available to
            complete the operation.

--*/
{
    ALLOCATE_THIS(DCE_BINDING);

    *Status = RPC_S_OK;

    if (   ARGUMENT_PRESENT(ObjectUuid)
        && (ObjectUuid[0] != 0))
        {
        if (this->ObjectUuid.ConvertFromString(ObjectUuid))
            {
            *Status = RPC_S_INVALID_STRING_UUID;
            this->ObjectUuid.SetToNullUuid();
            }
        }
    else
        this->ObjectUuid.SetToNullUuid();

    if (ARGUMENT_PRESENT(RpcProtocolSequence))
        {
        this->RpcProtocolSequence = DuplicateString(RpcProtocolSequence);
        if (this->RpcProtocolSequence == 0)
            *Status = RPC_S_OUT_OF_MEMORY;
        }
    else
        this->RpcProtocolSequence = 0;

    if (ARGUMENT_PRESENT(NetworkAddress))
        {
        this->NetworkAddress = DuplicateString(NetworkAddress);
        if (this->NetworkAddress == 0)
            *Status = RPC_S_OUT_OF_MEMORY;
        }
    else
        this->NetworkAddress = 0;

    if (ARGUMENT_PRESENT(Endpoint))
        {
        this->Endpoint = DuplicateString(Endpoint);
        if (this->Endpoint == 0)
            *Status = RPC_S_OUT_OF_MEMORY;
        }
    else
        this->Endpoint = 0;

    if (ARGUMENT_PRESENT(Options))
        {
        this->Options = DuplicateString(Options);
        if (this->Options == 0)
            *Status = RPC_S_OUT_OF_MEMORY;
        }
    else
        {
        this->Options = 0;
        }
}


/*static*/ RPC_CHAR PAPI *
StringCharSearchWithEscape (
    IN RPC_CHAR PAPI * String,
    IN unsigned int Character
    )
/*++

Routine Description:

    This routine is the same as the library routine, strchr, except that
    the backslash character ('\') is treated as an escape character.

Arguments:

    String - Supplies the string in which to search for the character.

    Character - Supplies the character to search for in the string.

Return Value:

    A pointer to the first occurance of Character in String is returned.
    If Character does not exist in String, then 0 is returned.

--*/
{
#ifdef DBCS_ENABLED
    ASSERT(IsDBCSLeadByte((RPC_CHAR)Character) == FALSE);
    ASSERT(IsDBCSLeadByte(RPC_CONST_CHAR('\\')) == FALSE);

    while(*String != (RPC_CHAR)Character)
        {
        if (*String == 0)
            return(0);

        if (*String == RPC_CONST_CHAR('\\'))
            {
            String = (RPC_CHAR *)CharNext((LPCSTR)String);
            }
        String = (RPC_CHAR *)CharNext((LPCSTR)String);
        }
    return(String);
#else
    while (*String != (RPC_CHAR) Character)
        {
        if (*String == RPC_CONST_CHAR('\\'))
            String++;
        if (*String == 0)
            return(0);
        String++;
        }
    return(String);
#endif
}


/*static*/ void
StringCopyWithEscape (
    OUT RPC_CHAR PAPI * Destination,
    IN RPC_CHAR PAPI * Source
    )
/*++

Routine Description:

    This routine is the same as the library routine, strcpy, except that
    the backslash character ('\') is treated as an escape character.  When
    a character is escaped, the backslash character is not copied to the
    Destination.

Arguments:

    Destination - Returns a duplicate of the string specified in Source,
        but with out escaped characters escaped.

    Source - Specifies the string to be copied.

Return Value:

    None.

--*/
{
    BOOL fLastQuote = FALSE;

#ifdef DBCS_ENABLED
    ASSERT(IsDBCSLeadByte('\\') == FALSE);
#endif


    while ((*Destination = *Source) != 0)
        {
#ifdef DBCS_ENABLED
        if (IsDBCSLeadByte(*Source))
            {
            // Copy the whole DBCS character; don't look for
            // escapes within the character.
            Destination++;
            Source++;
            *Destination = *Source;
            if (*Source == 0)
                {
                ASSERT(0);  // Bad string, NULL following a lead byte.
                return;
                }
            Destination++;
            Source++;
            }
        else
#endif
            {
            if (   *Source != RPC_CONST_CHAR('\\')
                || fLastQuote == TRUE)
                {
                Destination++;
                fLastQuote = FALSE;
                }
            else
                {
                fLastQuote = TRUE;
                }
            Source++;
            }
        }
}


/*static*/ RPC_STATUS
ParseAndCopyEndpointField (
    OUT RPC_CHAR ** Endpoint,
    IN RPC_CHAR PAPI * String
    )
/*++

Routine Description:

    This routine parses and then copies the endpoint field in String.  A
    copy of the field is made into a newly allocated string and returned
    in Endpoint.  String is assumed to contain only the endpoint field;
    the terminating ',' or ']' are not included.

Arguments:

    Endpoint - Returns a copy of the endpoint field in a newly allocated
        string.

    String - Supplies the endpoint field to be parsed and copied.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - There is no memory available to make a copy
        of the string.

    RPC_S_INVALID_ENDPOINT_FORMAT - The endpoint field is syntactically
        incorrect.  This error code will be returned if the endpoint field
        does not match the following pattern.

        [ <Endpoint> | "endpoint=" <Endpoint> ]

--*/
{
    // Search will be used to scan along the string to find the end of
    // the endpoint field and the '='.

    RPC_CHAR PAPI * Search;

    Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR('='));
    if (Search == 0)
        {
        // This means that we have the <Endpoint> pattern, so we just
        // copy the endpoint field.

        Search = StringCharSearchWithEscape(String,0);
        *Endpoint = new RPC_CHAR[size_t(Search - String + 1)];
        if (*Endpoint == 0)
            return(RPC_S_OUT_OF_MEMORY);
        StringCopyWithEscape(*Endpoint,String);
        return(RPC_S_OK);
        }

    // Otherwise, we have the "endpoint=" pattern.  First we need to check
    // that the string before the '=' is in fact "endpoint".

    *Search = 0;
    if ( RpcpStringCompare(String, RPC_CONST_STRING("endpoint")) != 0 )
        {
        *Search = RPC_CONST_CHAR('=');
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }
    *Search = RPC_CONST_CHAR('=');
    String = Search + 1;

    // Now we just need to allocate a new string and copy the endpoint into
    // it.

    Search = StringCharSearchWithEscape(String,0);
    *Endpoint = new RPC_CHAR[size_t(Search - String + 1)];
    if (*Endpoint == 0)
        return(RPC_S_OUT_OF_MEMORY);

    StringCopyWithEscape(*Endpoint,String);
    return(RPC_S_OK);
}


RPC_CHAR *
AllocateEmptyString (
    void
    )
/*++

Routine Description:

    This routine allocates and returns an empty string ("").

Return Value:

    A newly allocated empty string will be returned.

--*/
{
    RPC_CHAR * String;

    String = new RPC_CHAR[1];
    if (String != 0)
        *String = 0;
    return(String);
}


DCE_BINDING::DCE_BINDING (
    IN RPC_CHAR PAPI * StringBinding,
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This constructor creates a DCE_BINDING object from a string binding,
    which requires that the string binding be parsed into seperate
    strings and validated.

Arguments:

    StringBinding - Supplies the string being to be parsed.

    Status - Returns the status of the operation.  This parameter will
        take on the following values:

        RPC_S_OK - The operation completed successfully.

        RPC_S_OUT_OF_MEMORY - Insufficient memory is available to
            allocate space for the fields of the string binding.

        RPC_S_INVALID_STRING_BINDING - The string binding is
            syntactically invalid.

        RPC_S_INVALID_ENDPOINT_FORMAT - The endpoint specified in
            the string binding is syntactically incorrect.

        RPC_S_INVALID_STRING_UUID - The specified object uuid does not
            contain the valid string representation of a uuid.

--*/
{
    // String will point to the beginning of the field we are trying to
    // parse.

    RPC_CHAR PAPI * String;

    // Search will be used to scan along the string to find the end of
    // the field we are trying to parse.

    RPC_CHAR PAPI * Search;

    // This will contain the string representation of the object uuid.

    RPC_CHAR PAPI * ObjectUuidString;

    ALLOCATE_THIS(DCE_BINDING);

    // A string binding consists of an optional object uuid, an RPC protocol
    // sequence, a network address, an optional endpoint, and zero or more
    // option fields.
    //
    // [ <Object UUID> "@" ] <RPC Protocol Sequence> ":" <Network Address>
    // [ "[" ( <Endpoint> | "endpoint=" <Endpoint> | ) [","]
    //     [ "," <Option Name> "=" <Option Value>
    //         ( <Option Name> "=" <Option Value> )* ] "]" ]
    //
    // If an object UUID is specified, then it will be followed by '@'.
    // Likewise, if an endpoint and/or option(s) are specified, they will
    // be in square brackets.  Finally, one or more options are specified,
    // then ',' must seperate the optional endpoint from the options.  The
    // backslash character '\' is treated as an escape character in all
    // string binding fields.

    // To begin with, we need to set all of the string pointers to zero.
    // This is necessary so that when we do memory cleanup for error
    // recovery, we know which pointers we allocated a string for.

    ObjectUuidString = 0;
    RpcProtocolSequence = 0;
    NetworkAddress = 0;
    Endpoint = 0;
    Options = 0;

    String = StringBinding;


    // To begin with, we need to parse off the object UUID from the string
    // if it exists.

    Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR('@'));
    if (Search == 0)
        {
        // The string binding does not contain an object UUID.

        ObjectUuid.SetToNullUuid();
        }
    else
        {
        // There is an object UUID in the string.

        // We need to add one for the terminating zero in the
        // string.

        ObjectUuidString = (RPC_CHAR PAPI *) RpcpFarAllocate(
                sizeof(RPC_CHAR)*size_t(Search - String + 1));

        if (ObjectUuidString == 0)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            goto FreeMemoryAndReturn;
            }

        // Now copy the string.

        *Search = 0;
        StringCopyWithEscape(ObjectUuidString,String);
        *Search = RPC_CONST_CHAR('@');

        // Finally, update String so that we are ready to parse the next
        // field.

        String = Search + 1;

        // Now convert the string representation of the object uuid
        // into an actual uuid.

        if (ObjectUuid.ConvertFromString(ObjectUuidString))
        {
            *Status = RPC_S_INVALID_STRING_UUID;
            goto FreeMemoryAndReturn;
        }

        RpcpFarFree(ObjectUuidString);
        ObjectUuidString = 0;
        }

    // The RPC protocol sequence field comes next; it is terminated by
    // ':'.  Both the RPC protocol sequence field and the ':' are required.

    Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR(':'));
    if (Search == 0)
        {
        // This is an error, because the RPC protocol sequence field is
        // required.  We may need to free the string we allocated for
        // the object UUID field.

        *Status = RPC_S_INVALID_STRING_BINDING;
        goto FreeMemoryAndReturn;
        }
    else
        {
        // The same comments which applied to copying the object UUID
        // apply here as well.

        RpcProtocolSequence = new RPC_CHAR[size_t(Search - String + 1)];
        if (RpcProtocolSequence == 0)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            goto FreeMemoryAndReturn;
            }

        *Search = 0;
        StringCopyWithEscape(RpcProtocolSequence,String);
        *Search = RPC_CONST_CHAR(':');

        // Finally, update String so that we are ready to parse the next
        // field.

        String = Search + 1;
        }

    // Next comes the network address field which is required.  It is
    // terminated by zero or '['.

    Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR('['));
    if (Search == 0)
        {
        // This means that the network address is the last field, so we
        // just copy it, and set the remaining fields to be empty strings.

        Search = StringCharSearchWithEscape(String,0);
        NetworkAddress = new RPC_CHAR[size_t(Search - String + 1)];
        if (NetworkAddress == 0)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            goto FreeMemoryAndReturn;
            }
        StringCopyWithEscape(NetworkAddress,String);

        Endpoint = AllocateEmptyString();
        if (Endpoint == 0)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            goto FreeMemoryAndReturn;
            }

        Options = 0;

        *Status = RPC_S_OK;
        return;
        }

    // Otherwise, if we reach here, there is an endpoint and/or options
    // left to parse.  But before we parse them, lets copy the network
    // address field.

    NetworkAddress = new RPC_CHAR [size_t(Search - String + 1)];
    if (NetworkAddress == 0)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        goto FreeMemoryAndReturn;
        }
    *Search = 0;
    StringCopyWithEscape(NetworkAddress,String);
    *Search = RPC_CONST_CHAR('[');

    String = Search + 1;

    // Now we are ready to parse off the endpoint and/or options.
    // To begin with, we check to see if there is a comma.

    Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR(','));
    if (Search == 0)
        {
        // There is only one token in the string binding.  See
        // if its an endpoint, if not, it must be an option.
        // Before we copy the endpoint field, we need to check
        // for the closing square bracket.

        Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR(']'));
        if (Search == 0)
            {
            // This is an error; the string binding is invalid.  We need to
            // clean everything up, and return an error.

            *Status = RPC_S_INVALID_ENDPOINT_FORMAT;
            goto FreeMemoryAndReturn;
            }

        *Search = 0;
        *Status = ParseAndCopyEndpointField(&Endpoint,String);
        *Search = RPC_CONST_CHAR(']');

        // If the parse succeeded, allocate an empty option.
        if (*Status == RPC_S_OK)
            {
            Options = 0;
            }

        // If the endpoint parse failed with RPC_S_INVALID_ENDPOINT_FORMAT,
        // the token must be an option.
        else if (*Status == RPC_S_INVALID_ENDPOINT_FORMAT)
            {
                Endpoint = AllocateEmptyString();
                if (Endpoint == 0)
                    {
                    *Status = RPC_S_OUT_OF_MEMORY;
                    goto FreeMemoryAndReturn;
                    }

                Options = new RPC_CHAR [size_t(Search - String + 1)];
                if (Options == 0)
                    {
                    *Status = RPC_S_OUT_OF_MEMORY;
                    goto FreeMemoryAndReturn;
                    }

                *Search = 0;
                StringCopyWithEscape(Options,String);
                *Search = RPC_CONST_CHAR(']');

            }

        // Something bad must have happened, clean up.
        else
            goto FreeMemoryAndReturn;

        *Status = RPC_S_OK;
        return;
        }

    // When we reach here, we know that there are options.   We have
    // to see if there is an endpoint.  If there is, copy it and then
    // copy the options.  If there isn't, allocate a null endpoint and
    // copy the options.

    *Search = 0;
    *Status = ParseAndCopyEndpointField(&Endpoint,String);
    *Search = RPC_CONST_CHAR(',');

    // If there was an endpoint, skip that part of the string.
    // Otherwise treat it as an option.
    if (*Status == RPC_S_OK)
        String = Search + 1;
    else if (*Status != RPC_S_INVALID_ENDPOINT_FORMAT)
        goto FreeMemoryAndReturn;

    // There was no endpoint, so allocate an empty string.
    else
        {
        Endpoint = AllocateEmptyString();
        if (Endpoint == 0)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            goto FreeMemoryAndReturn;
            }
        }

    // Even if the caller did not specify the NetworkOptions argument,
    // we still want to validate the rest of the string binding.

    Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR(']'));
    if (Search == 0)
        {
        // This is an error; the string binding is invalid.  We need
        // to clean everything up, and return an error.

        *Status = RPC_S_INVALID_STRING_BINDING;
        goto FreeMemoryAndReturn;
        }

    // Go ahead and copy the network options field if we reach here.

    Options = new RPC_CHAR [size_t(Search - String + 1)];
    if (Options == 0)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        goto FreeMemoryAndReturn;
        }

    *Search = 0;
    StringCopyWithEscape(Options,String);
    *Search = RPC_CONST_CHAR(']');

    // Everything worked out fine; we just fall through the memory
    // cleanup code and return.

    *Status = RPC_S_OK;

    // If an error occured up above, we will have set status to the
    // appropriate error code, and jumped here.  We may also arrive
    // here if an error did not occur, hence the check for an error status
    // before we clean up the memory.

FreeMemoryAndReturn:

    if (*Status != RPC_S_OK)
        {
        if (ObjectUuidString != 0)
            RpcpFarFree(ObjectUuidString);

        delete RpcProtocolSequence;
        delete NetworkAddress;
        delete Endpoint;
        delete Options;

        ObjectUuidString    = 0;
        RpcProtocolSequence = 0;
        NetworkAddress      = 0;
        Endpoint            = 0;
        Options             = 0;
        }
}


DCE_BINDING::~DCE_BINDING (
    )
/*++

Routine Description:

    We cleaning things up here when a DCE_BINDING is getting deleted.
    This consists of freeing the strings pointed to by the fields of
    the class.

--*/
{
    delete RpcProtocolSequence;
    delete NetworkAddress;
    delete Endpoint;
    delete Options;
}


/*static*/ int
StringLengthWithEscape (
    IN RPC_CHAR PAPI * String
    )
/*++

Routine Description:

    This routine is the same as the library routine, strlen, except that
    for that following characters, '@', ':', '\', '[', and ',', are
    counted as two characters (to save space for a \) rather than one.

Arguments:

    String - Supplies a string whose length will be determined.

Return Value:

    The length of the string will be returned including enough space to
    escape certain characters.

--*/
{
    // We use length to keep track of how long the string is so far.

    int Length;

    Length = 0;
    while (*String != 0)
        {
#ifdef DBCS_ENABLED
        if (IsDBCSLeadByte(*String))
            {
            String += 2;
            Length += 2;
            }
        else
#endif
            {
            if (   (*String == RPC_CONST_CHAR('@'))
                || (*String == RPC_CONST_CHAR(':'))
                || (*String == RPC_CONST_CHAR('\\'))
                || (*String == RPC_CONST_CHAR('['))
                || (*String == RPC_CONST_CHAR(']'))
                || (*String == RPC_CONST_CHAR(',')))
                Length += 2;
            else
                Length += 1;
            String += 1;
            }
        }
    return(Length);
}

/*static*/ RPC_CHAR PAPI *
StringCopyEscapeCharacters (
    OUT RPC_CHAR PAPI * Destination,
    IN RPC_CHAR PAPI * Source
    )
/*++

Routine Description:

    Source is copied into destination.  When coping into destination, the
    following characters are escaped by prefixing them with a '\': '@',
    ':', '\', '[', ']', and ','.

Arguments:

    Destination - Returns a copy of Source.

    Source - Supplies a string to be copied into destination.

Return Value:

    A pointer to the terminating zero in Destination is returned.

--*/
{
    while ((*Destination = *Source) != 0)
        {
#ifdef DBCS_ENABLED
        if (IsDBCSLeadByte(*Source))
            {
            Destination++;
            Source++;
            *Destination = *Source;
            }
        else
#endif
            {
            if (   (*Source == RPC_CONST_CHAR('@'))
                || (*Source == RPC_CONST_CHAR(':'))
                || (*Source == RPC_CONST_CHAR('\\'))
                || (*Source == RPC_CONST_CHAR('['))
                || (*Source == RPC_CONST_CHAR(']'))
                || (*Source == RPC_CONST_CHAR(',')))
                {
                *Destination++ = RPC_CONST_CHAR('\\');
                *Destination = *Source;
                }
            }
        Destination++;
        Source++;
        }
    *Destination = 0;
    return(Destination);
}


RPC_CHAR PAPI *
DCE_BINDING::StringBindingCompose (
    IN RPC_UUID PAPI * Uuid OPTIONAL,
    IN BOOL fStatic
    )
/*++

Routine Description:

    This method creates a string binding from a DCE_BINDING by combining
    the components of a string binding.

Arguments:

    Uuid - Optionally supplies a uuid to use in composing the string
        binding rather than the object uuid contained in the DCE_BINDING.

Return Value:

    String Binding - A newly allocated and created (from the components)
        is returned.

    0 - Insufficient memory is available to allocate the string binding.

--*/
{
    // We will use the following automatic variable to calculate the
    // required length of the string.

    int Length;

    // Copy is used to copy the fields of the string binding into the
    // string binding.

    RPC_CHAR PAPI * Copy;

    // StringBinding will contain the string binding we are supposed
    // to be creating here.

    RPC_CHAR PAPI * StringBinding;

    // This routine is written as follows.  First we need to calculate
    // the amount of space required to hold the string binding.  This
    // is not quite straight forward as it seems: we need to escape
    // '@', ':', '\', '[', ']', and ',' characters in the string binding
    // we create.  After allocating the string, we copy each piece in,
    // escaping characters as necessary.

    // Go through and figure out how much space each field of the string
    // binding will take up.

    if (!ARGUMENT_PRESENT(Uuid))
        Uuid = &ObjectUuid;

    if (Uuid->IsNullUuid() == 0)
        {
        // The extra plus one is to save space for the '@' which seperates
        // the object UUID field from the RPC protocol sequence field.  The
        // length of the string representation of a uuid is always 36
        // characters.

        Length = 36 + 1;
        }
    else
        {
        Length = 0;
        }

    if (RpcProtocolSequence != 0)
        {
        Length += StringLengthWithEscape(RpcProtocolSequence);
        }

    // We need to save space for the ':' seperating the RPC protocol
    // sequence field from the network address field.

    Length += 1;

    if (NetworkAddress != 0)
        Length += StringLengthWithEscape(NetworkAddress);

    if (   (Endpoint != 0)
        && (Endpoint[0] != 0))
        {
        // The plus two is to save space for the '[' and ']' surrounding
        // the endpoint and options fields.

        Length += StringLengthWithEscape(Endpoint) + 2;

        if (   (Options != 0)
            && (Options[0] != 0))
            {
            // The extra plus one is for the ',' which goes before the
            // options field.

            Length += StringLengthWithEscape(Options) + 1;
            }
        }
    else
        {
        if (   (Options != 0)
            && (Options[0] != 0))
            {
            // We need to add three to the length to save space for the
            // '[' and ']' which will go around the options, and the ','
            // which goes before the options.

            Length += StringLengthWithEscape(Options) + 3;
            }
        }

    // Finally, include space for the terminating zero in the string.

    Length += 1;

    // Now we allocate space for the string binding and copy all of the
    // pieces into it.

    StringBinding = (RPC_CHAR PAPI *)
            RpcpFarAllocate(Length * sizeof(RPC_CHAR));
    if (StringBinding == 0)
        return(0);

    if (Uuid->IsNullUuid() == 0)
        {
        Copy = Uuid->ConvertToString(StringBinding);
        *Copy++ = RPC_CONST_CHAR('@');
        }
    else
        {
        Copy = StringBinding;
        }

    if (RpcProtocolSequence != 0)
        {
        Copy = StringCopyEscapeCharacters(Copy, RpcProtocolSequence);
        }

    *Copy++ = RPC_CONST_CHAR(':');

    if (NetworkAddress != 0)
        {
        Copy = StringCopyEscapeCharacters(Copy, NetworkAddress);
        }

    if ( (fStatic == 0)
        &&  (Endpoint != 0)
        && (Endpoint[0] != 0))
        {
        *Copy++ = RPC_CONST_CHAR('[');
        Copy = StringCopyEscapeCharacters(Copy, Endpoint);

        if (   (Options != 0)
            && (Options[0] != 0))
            {
            *Copy++ = RPC_CONST_CHAR(',');
            Copy = StringCopyEscapeCharacters(Copy, Options);
            }

        *Copy++ = RPC_CONST_CHAR(']');
        }
    else
        {
        if (   (Options != 0)
            && (Options[0] != 0))
            {
            *Copy++ = RPC_CONST_CHAR('[');
            *Copy++ = RPC_CONST_CHAR(',');
            Copy = StringCopyEscapeCharacters(Copy, Options);
            *Copy++ = RPC_CONST_CHAR(']');
            }
        }

    // And do not forget to terminate the string.

    *Copy = 0;

    return(StringBinding);
}


RPC_CHAR PAPI *
DCE_BINDING::ObjectUuidCompose (
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This method returns a string representation of the object UUID
    component of the DCE_BINDING.  The string representation is
    suitable for using as the object UUID component of a string binding.

Arguments:

    Status - Returns the status of the operation if there is insufficient
        memory to allocate for the string to be returned.

Return Value:

    The string representation of the object UUID is returned in a freshly
    allocated string.

--*/
{
    RPC_CHAR PAPI * String;

    if (ObjectUuid.IsNullUuid() != 0)
        return(AllocateEmptyStringPAPI());

    // The string representation of a uuid is always 36 characters long
    // (and the extra character is for the terminating zero).

    String = (RPC_CHAR PAPI *) RpcpFarAllocate(37 * sizeof(RPC_CHAR));
    if (String == 0)
        *Status = RPC_S_OUT_OF_MEMORY;
    else
        {
        ObjectUuid.ConvertToString(String);
        String[36] = 0;
        }

    return(String);
}


RPC_CHAR PAPI *
DCE_BINDING::RpcProtocolSequenceCompose (
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This method returns a string representation of the RPC protocol sequence
    component of the DCE_BINDING.  The string representation is
    suitable for using as the RPC protocol sequence component of a
    string binding.

Arguments:

    Status - Returns the status of the operation if there is insufficient
        memory to allocate for the string to be returned.

Return Value:

    The string representation of the RPC protocol sequence is returned
    in a freshly allocated string.

--*/
{
    RPC_CHAR PAPI * String;

    if (RpcProtocolSequence == 0)
        return(AllocateEmptyStringPAPI());

    String = DuplicateStringPAPI(RpcProtocolSequence);
    if (String == 0)
        *Status = RPC_S_OUT_OF_MEMORY;
    return(String);
}


RPC_CHAR PAPI *
DCE_BINDING::NetworkAddressCompose (
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This method returns a string representation of the network address
    component of the DCE_BINDING.  The string representation is
    suitable for using as the network address component of a string binding.

Arguments:

    Status - Returns the status of the operation if there is insufficient
        memory to allocate for the string to be returned.

Return Value:

    The string representation of the network address is returned in a freshly
    allocated string.

--*/
{
    RPC_CHAR PAPI * String;

    if (NetworkAddress == 0)
        return(AllocateEmptyStringPAPI());

    String = DuplicateStringPAPI(NetworkAddress);
    if (String == 0)
        *Status = RPC_S_OUT_OF_MEMORY;
    return(String);
}


RPC_CHAR PAPI *
DCE_BINDING::EndpointCompose (
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This method returns a string representation of the endpoint
    component of the DCE_BINDING.  The string representation is
    suitable for using as the endpoint component of a string binding.

Arguments:

    Status - Returns the status of the operation if there is insufficient
        memory to allocate for the string to be returned.

Return Value:

    The string representation of the endpoint is returned in a freshly
    allocated string.

--*/
{
    RPC_CHAR PAPI * String;

    if (Endpoint == 0)
        return(AllocateEmptyStringPAPI());

    String = DuplicateStringPAPI(Endpoint);
    if (String == 0)
        *Status = RPC_S_OUT_OF_MEMORY;
    return(String);
}


RPC_CHAR PAPI *
DCE_BINDING::OptionsCompose (
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This method returns a string representation of the options
    component of the DCE_BINDING.  The string representation is
    suitable for using as the options component of a string binding.

Arguments:

    Status - Returns the status of the operation if there is insufficient
        memory to allocate for the string to be returned.

Return Value:

    The string representation of the options is returned in a freshly
    allocated string.

--*/
{
    RPC_CHAR PAPI * String;

    if (Options == 0)
        return(AllocateEmptyStringPAPI());

    String = DuplicateStringPAPI(Options);
    if (String == 0)
        *Status = RPC_S_OUT_OF_MEMORY;
    return(String);
}


BINDING_HANDLE *
DCE_BINDING::CreateBindingHandle (
    OUT RPC_STATUS *Status
    )
/*++
Routine Description:

    We will create a binding handle specific to the rpc protocol sequence
    specified by the DCE_BINDING object.  The object uuid will be
    passed on to the created binding handle.  Ownership of this
    passes to this routine.  If an error occurs, it will be deleted.

Arguments:
    The created binding handle will be returned, or zero if an error
    occured.

Return Value:
    RPC_S_OK - We had no trouble allocating the binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory was available to
    complete the operation.

    RPC_S_INVALID_RPC_PROTSEQ - The rpc protocol sequence is
    syntactically invalid.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The requested rpc protocol sequence
    is not supported.
--*/
{
    TRANS_INFO *ClientTransInfo ;
    BINDING_HANDLE *BindingHandle ;

    if ( RpcpMemoryCompare(
                        RpcProtocolSequence,
                        RPC_CONST_STRING("ncalrpc"),
                        8 * sizeof(RPC_CHAR)) == 0 )
        {
        BindingHandle = LrpcCreateBindingHandle();

        if (BindingHandle == 0)
            {
            delete this;
            *Status =  RPC_S_OUT_OF_MEMORY;

            return 0;
            }
        }

    else if ( RpcpMemoryCompare(
                        RpcProtocolSequence,
                        RPC_CONST_STRING("ncadg_"),
                        6*sizeof(RPC_CHAR)) == 0)
        {
        BindingHandle = DgCreateBindingHandle();
        if (BindingHandle == 0)
            {
            delete this;
            *Status =  RPC_S_OUT_OF_MEMORY;

            return 0;
            }

        *Status = OsfMapRpcProtocolSequence(0,
                                                 RpcProtocolSequence,
                                                 &ClientTransInfo);

        if (*Status != RPC_S_OK)
            {
            delete BindingHandle;
            delete this;

            return 0;
            }
        }

    else if ( RpcpMemoryCompare(
                    RPC_CONST_STRING("ncacn_"),
                    RpcProtocolSequence,
                    6 * sizeof(RPC_CHAR)) == 0 )
        {
        BindingHandle = OsfCreateBindingHandle();
        if (BindingHandle == 0)
            {
            delete this;
            *Status =  RPC_S_OUT_OF_MEMORY;

            return 0;
            }

        *Status = OsfMapRpcProtocolSequence(0,
                                            RpcProtocolSequence,
                                            &ClientTransInfo) ;
        if (*Status != RPC_S_OK)
            {
            delete BindingHandle;
            delete this;

            return 0;
            }
        }
    else
        {
        delete this;
        *Status =  RPC_S_INVALID_RPC_PROTSEQ;

        return 0;
        }

    BindingHandle->SetObjectUuid(&ObjectUuid);
    *Status = BindingHandle->PrepareBindingHandle(ClientTransInfo, this);
    if (*Status != RPC_S_OK)
        {
        delete BindingHandle;
        delete this;

        return 0;
        }
    *Status = RPC_S_OK;
    return BindingHandle;
}


void
DCE_BINDING::AddEndpoint(
    IN RPC_CHAR *Endpoint
    )
/*++

Routine Description:

    This routine can be used to update the endpoint stored in the DCE_BINDING.
    If the DCE_BINDING already has an endpoint it is deleted.

Arguments:

    Endpoint - The new endpoint to store in this DCE_BINDING.  Ownership
               passes to this DCE_BINDING.

Return Value:

    n/a

--*/
{
    if (this->Endpoint)
        delete this->Endpoint;

    this->Endpoint = Endpoint;
}


RPC_STATUS
DCE_BINDING::ResolveEndpointIfNecessary (
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation,
    IN RPC_UUID * ObjectUuid,
    IN OUT void PAPI * PAPI * EpLookupHandle,
    IN BOOL UseEpMapperEp,
    IN unsigned ConnTimeout,
    IN ULONG CallTimeout,
    IN CLIENT_AUTH_INFO *AuthInfo OPTIONAL
    )
/*++

Routine Description:

    This routine will determine the endpoint if it is not specified.
    The arguments specifies interface information necessary to resolve
    the endpoint, as well as the object uuid.

Arguments:

    RpcInterfaceInformation - Supplies the interface information necessary
        to resolve the endpoint.

    ObjectUuid - Supplies the object uuid in the binding.

    EpLookupHandle - Supplies the current value of the endpoint mapper
        lookup handle for a binding, and returns the new value.

    ConnTimeout - the connection timeout

    CallTimeout - the call timeout

    AuthInfo - optional authentication info to be used when resolving the endpoint

Return Value:

    RPC_S_OK - The endpoint is fully resolved.

    RPC_S_NO_ENDPOINT_FOUND - The endpoint can not be resolved.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to resolve
        the endpoint.

    EPT_S_NOT_REGISTERED  - There are no more endpoints to be found
        for the specified combination of interface, network address,
        and lookup handle.

    EPT_S_CANT_PERFORM_OP - The operation failed due to misc. error e.g.
        unable to bind to the EpMapper.

--*/
{
    unsigned int Index;
    RPC_STATUS RpcStatus;
    UNICODE_STRING UnicodeString;

    if (   (Endpoint == 0)
        || (Endpoint[0] == 0) )
        {

        // This binding does not have an endpoint, so we must perform
        // binding resolution to obtain an endpoint.  First we look
        // in the interface information to see if an endpoint corresponding
        // to the rpc protocol sequence for this binding is there.

        for (Index = 0;
                Index < RpcInterfaceInformation->RpcProtseqEndpointCount;
                Index++)
            {
            RpcStatus = AnsiToUnicodeString(
                    RpcInterfaceInformation->RpcProtseqEndpoint[
                            Index].RpcProtocolSequence, &UnicodeString);

            if (RpcStatus != RPC_S_OK)
                return(RpcStatus);

            if ( RpcpStringCompare(RpcProtocolSequence,
                    UnicodeString.Buffer) == 0 )
                {
                RtlFreeUnicodeString(&UnicodeString);

                if (Endpoint != 0)
                    {
                    delete Endpoint;
                    Endpoint = 0;
                    }

                RpcStatus = AnsiToUnicodeString(
                        RpcInterfaceInformation->RpcProtseqEndpoint[
                                Index].Endpoint, &UnicodeString);

                if (RpcStatus != RPC_S_OK)
                    return(RpcStatus);

                Endpoint = DuplicateString(UnicodeString.Buffer);

                RtlFreeUnicodeString(&UnicodeString);

                if (Endpoint == 0)
                    return(RPC_S_OUT_OF_MEMORY);

                return(RPC_S_OK);
                }
            RtlFreeUnicodeString(&UnicodeString);
            }

        //The endpoint has not been supplied so resolve the endpoint.

        //CLH 2/17/94 If datagram and forward is required (that is
        //RpcEpResolveBinding has not been called), then simply put
        //the endpoint mapper's endpoint into this binding handles endpoint.
        //The endpoint mapper on the destination node will resolve the
        //endpoint and its runtime will forward the pkt.

        if (Endpoint != 0)
            {
            delete Endpoint;
            Endpoint = 0;
            }

        //
        // We cannot allow management interfaces to be resolved if they dont contain
        // an object uuid.
        //
        if (  (IsMgmtIfUuid ((UUID PAPI * )
                  &RpcInterfaceInformation->InterfaceId.SyntaxGUID))
              &&( (ObjectUuid == 0) ||
                  (RpcpMemoryCompare(ObjectUuid, &NullUuid, sizeof(UUID)) == 0) ) )
           {
           return(RPC_S_BINDING_INCOMPLETE);
           }

        if ( (RpcpMemoryCompare(RpcProtocolSequence,
                    RPC_CONST_STRING("ncadg_"), 6*sizeof(RPC_CHAR)) == 0)
              && (UseEpMapperEp != 0) )
          {
          RpcStatus = EpGetEpmapperEndpoint(
                        ((RPC_CHAR * PAPI *) &Endpoint),
                        RpcProtocolSequence);
          return((RpcStatus == RPC_S_OK) ?
                  RPC_P_EPMAPPER_EP : RpcStatus);
          }
        else
          {

          // Otherwise, we need to contact the endpoint mapper to
          // resolve the endpoint.

          return (EpResolveEndpoint((UUID PAPI *) ObjectUuid,
            &RpcInterfaceInformation->InterfaceId,
            &RpcInterfaceInformation->TransferSyntax,
            RpcProtocolSequence, 
            NetworkAddress, 
            Options, 
            EpLookupHandle, 
            ConnTimeout,
            CallTimeout,
            AuthInfo,
            (RPC_CHAR * PAPI *) &Endpoint));
          }
        }
    return(RPC_S_OK);
}


DCE_BINDING::Compare (
    IN DCE_BINDING * DceBinding,
    OUT BOOL *fOnlyEndpointDiffers
    )
/*++

Routine Description:

    This method compares two DCE_BINDING objects for equality.

Arguments:

    DceBinding - Supplies a DCE_BINDING object to compare with this.
    fOnlyEndpointDiffers - this output variable will be set to TRUE
        if the result is non-zero and only the endpoint is different.
        It will be set to FALSE if the result is non-zero, and there
        is more than the endpoint different. If this function returns
        0, the fOnlyEndpointDiffers argument is undefined.

Return Value:

    Zero will be returned if the specified DCE_BINDING object is the
    same as this.  Otherwise, non-zero will be returned.

--*/
{
    int Result;

    Result = CompareWithoutSecurityOptions(DceBinding,
        fOnlyEndpointDiffers);
    if (Result != 0)
        return Result;

    if (Options != 0)
        {
        if (DceBinding->Options != 0)
            {
            Result = RpcpStringCompare(DceBinding->Options, Options);
            }
        else
            Result = 1;
        }
    else
        {
        if (DceBinding->Options != 0)
            Result = 1;
        // else - Result has already been set from above
        //    Result = 0;
        }

    if (Result)
        {
        // if we didn't bail out after CompareWithoutSecurityOptions,
        // everything but the security options must have been the same
        // If Result is non-zero, only the security optinos have been
        // different. This means that it is not only the endpoint that
        // is different.
        *fOnlyEndpointDiffers = FALSE;
        }

    return(Result);
}

DCE_BINDING::CompareWithoutSecurityOptions (
    IN DCE_BINDING * DceBinding,
    OUT BOOL *fOnlyEndpointDiffers
    )
/*++

Routine Description:

    This method compares two DCE_BINDING objects for equality without
    comparing the security options.

Arguments:

    DceBinding - Supplies a DCE_BINDING object to compare with this.
    fOnlyEndpointDiffers - this output variable will be set to TRUE
        if the result is non-zero and only the endpoint is different.
        It will be set to FALSE if the result is non-zero, and there
        is more than the endpoint different. If this function returns
        0, the fOnlyEndpointDiffers argument is undefined.

Return Value:

    Zero will be returned if the specified DCE_BINDING object is the
    same as this.  Otherwise, non-zero will be returned.

--*/
{
    int Result;

    *fOnlyEndpointDiffers = FALSE;

    Result = RpcpMemoryCompare(&(DceBinding->ObjectUuid), &ObjectUuid, sizeof(UUID));
    if (Result != 0)
        return(Result);

    if (RpcProtocolSequence != 0)
        {
        if (DceBinding->RpcProtocolSequence != 0)
            {
            Result = RpcpStringCompare(DceBinding->RpcProtocolSequence,
                    RpcProtocolSequence);
            if (Result != 0)
                return(Result);
            }
        else
            return(1);
        }
    else
        {
        if (DceBinding->RpcProtocolSequence != 0)
            return(1);
        }

    if (NetworkAddress != 0)
        {
        if (DceBinding->NetworkAddress != 0)
            {
            Result = RpcpStringCompare(DceBinding->NetworkAddress,
                    NetworkAddress);
            if (Result != 0)
                return(Result);
            }
        else
            return(1);
        }
    else
        {
        if (DceBinding->NetworkAddress != 0)
            return(1);
        }

    *fOnlyEndpointDiffers = TRUE;

    if (Endpoint != 0)
        {
        if (DceBinding->Endpoint != 0)
            {
            Result = RpcpStringCompare(DceBinding->Endpoint, Endpoint);
            if (Result != 0)
                return(Result);
            }
        else
            return(1);
        }
    else
        {
        if (DceBinding->Endpoint != 0)
            return(1);
        }

    return(0);
}

DCE_BINDING *
DCE_BINDING::DuplicateDceBinding (
    )
/*++

Routine Description:

    We duplicate this DCE binding in this method.

Return Value:

    A duplicate DCE_BINDING to this DCE_BINDING will be returned, if
    everthing works correctly.  Otherwise, zero will be returned
    indicating an out of memory error.

--*/
{
    DCE_BINDING * DceBinding;
    RPC_STATUS Status = RPC_S_OK;
    RPC_CHAR ObjectUuidString[37];

    ObjectUuid.ConvertToString(ObjectUuidString);
    ObjectUuidString[36] = 0;

    DceBinding = new DCE_BINDING(ObjectUuidString,RpcProtocolSequence,
            NetworkAddress,Endpoint,Options,&Status);
    if (Status != RPC_S_OK)
        {
        ASSERT(Status == RPC_S_OUT_OF_MEMORY);
        delete DceBinding;
        return(0);
        }

    return(DceBinding);
}


void
DCE_BINDING::MakePartiallyBound (
    )
/*++

Routine Description:

    We need to make the binding into a partially bound one by setting the
    endpoint to zero.  This is really easy to do.

--*/
{
    if (Endpoint != 0)
        {
        delete Endpoint;
        Endpoint = 0;
        }
}

BOOL
DCE_BINDING::MaybeMakePartiallyBound (
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation,
    IN RPC_UUID * MyObjectUuid
    )
/*++
Function Name:MaybeMakePartiallyBound

Parameters:

Description:
    If the interface can uniquely identify an RPC server on a machine, the
    binding is made partially bound. Otherwise, it is not.

Returns:


--*/
/*++

Routine Description:

--*/
{
    if ((IsMgmtIfUuid ((UUID PAPI * )
        &RpcInterfaceInformation->InterfaceId.SyntaxGUID))
        &&((MyObjectUuid == 0) ||
        (RpcpMemoryCompare(MyObjectUuid, &NullUuid, sizeof(UUID)) == 0)))
        {
        return FALSE;
        }

    MakePartiallyBound();
    return TRUE;
}

RPC_STATUS
IsRpcProtocolSequenceSupported (
    IN RPC_CHAR PAPI * RpcProtocolSequence
    )
/*++

Routine Description:

    This routine determines if the specified rpc protocol sequence is
    supported.  It will optionally return the parts of the rpc protocol
    sequence (rpc protocol specifier, and address + interface specifiers).

Arguments:

    RpcProtocolSequence - Supplies an rpc protocol sequence to check.

    RpcProtocolPart - Optionally returns the rpc protocol part of the
        rpc protocol sequence.

    AddressAndInterfacePart - Optionally returns the address and interface
        parts of the rpc protocol sequence.

Return Value:

    RPC_S_OK - The specified rpc protocol sequence is supported.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to check
        the rpc protocol sequence.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The specified rpc protocol sequence is not
        supported (but it appears to be valid).

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        syntactically invalid.

--*/
{
    RPC_STATUS Status;
    TRANS_INFO *ClientTransInfo ;
    size_t ProtSeqLength;

    ProtSeqLength = RpcpStringLength(RpcProtocolSequence);
    if ( (ProtSeqLength >= 7) 
            && 
         (RpcpMemoryCompare(RpcProtocolSequence, RPC_CONST_STRING("ncalrpc"),
                8 * sizeof(RPC_CHAR)) == 0) )
        {
        return(RPC_S_OK);
        }

    else if ( (ProtSeqLength >= 6) 
                && ((RpcpMemoryCompare(RPC_CONST_STRING("ncacn_"),
                        RpcProtocolSequence, 6 * sizeof(RPC_CHAR)) == 0 )
                    ||  ( RpcpMemoryCompare(RPC_CONST_STRING("ncadg_"), RpcProtocolSequence,
                            6 * sizeof(RPC_CHAR)) == 0 )) )

        {
        RPC_PROTSEQ_VECTOR *ProtseqVector;
        unsigned int i;

        Status = RpcNetworkInqProtseqs(&ProtseqVector);
        if (Status != RPC_S_OK)
            {
            return Status;
            }

        Status = RPC_S_PROTSEQ_NOT_SUPPORTED;

        for (i = 0; i < ProtseqVector->Count; i++)
            {
            if (RpcpStringCompare(RpcProtocolSequence, ProtseqVector->Protseq[i]) == 0)
                {
                Status = RPC_S_OK;
                break;
                }
            }

        RpcProtseqVectorFree(&ProtseqVector);

        return(Status);
        }
    else if ( (ProtSeqLength >= 6) 
                && 
              (RpcpMemoryCompare(RpcProtocolSequence, RPC_CONST_STRING("mswmsg"),
                7 * sizeof(RPC_CHAR)) == 0) )
        {
        return(RPC_S_PROTSEQ_NOT_SUPPORTED);
        }

    return(RPC_S_INVALID_RPC_PROTSEQ);
}


LOADABLE_TRANSPORT::LOADABLE_TRANSPORT (
    IN RPC_TRANSPORT_INTERFACE  pTransportInterface,
    IN RPC_CHAR * DllName,
    IN RPC_CHAR PAPI * ProtocolSequence,
    IN DLL *LoadableTransportDll,
    IN FuncGetHandleForThread GetHandleForThread,
    IN FuncReleaseHandleForThread ReleaseHandleForThread,
    OUT RPC_STATUS *Status,
    OUT TRANS_INFO * PAPI *TransInfo
    ) :  nThreadsAtCompletionPort(0),
         ThreadsDoingLongWait(0)
/*++

Routine Description:

    To construct the object, all we have got to do is to copy the
    arguments into the object.

Arguments:

    DllName - Supplies the name of the dll from which this transport
        interface was loaded.

--*/
{
        
    RpcpStringCopy(this->DllName, DllName) ;
    LoadedDll = LoadableTransportDll;

    *TransInfo = new TRANS_INFO(pTransportInterface,
                                ProtocolSequence,
                                this) ;
    if (*TransInfo == 0)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        return ;
        }

    if (ProtseqDict.Insert(*TransInfo) == -1)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        return ;
        }

    ThreadsStarted = 0;
    nActivityValue = 0;
    nOptimalNumberOfThreads = gNumberOfProcessors + 1;
    ProcessCallsFunc = pTransportInterface->ProcessCalls;

    this->GetHandleForThread = GetHandleForThread;
    this->ReleaseHandleForThread = ReleaseHandleForThread;

#ifndef NO_PLUG_AND_PLAY
    PnpListen = pTransportInterface->PnpListen;
#endif

    *Status = RPC_S_OK;
    NumThreads = 0;
}


TRANS_INFO *
LOADABLE_TRANSPORT::MapProtocol (
    IN RPC_CHAR * DllName,
    IN RPC_CHAR PAPI * ProtocolSequence
    )
/*++

Routine Description:

    This method is used to search the dictionary.  It compares a
    LOADABLE_TRANSPORT with a transport interface to see if
    they match.

Arguments:

    DllName - Supplies the name of the dll from which this loadable
        transport interface was loaded.

Return Value:

--*/
{
    TRANS_INFO *Protseq ;
    TRANSPORT_LOAD TransportLoad;
    RPC_TRANSPORT_INTERFACE  pTransport;
    DictionaryCursor cursor;

    if (RpcpStringCompare(DllName, this->DllName) != 0)
        {
        return 0;
        }

    ProtseqDict.Reset(cursor) ;
    while ((Protseq = ProtseqDict.Next(cursor)) != 0)
        {
        if (Protseq->MatchProtseq(ProtocolSequence))
            {
            return Protseq ;
            }
        }

    if (GetTransportEntryPoints(LoadedDll, &TransportLoad,
            &GetHandleForThread,
            &ReleaseHandleForThread) == 0)
        return 0;

    pTransport = (*TransportLoad) (ProtocolSequence);

    if (pTransport == 0)
        {
        return 0 ;
        }

    Protseq = new TRANS_INFO(
                                pTransport,
                                ProtocolSequence,
                                this) ;
    if (Protseq == 0)
        {
        return 0;
        }

    if (ProtseqDict.Insert(Protseq) == -1)
        {
        delete Protseq ;
        return 0;
        }

    return Protseq ;
}


TRANS_INFO *
LOADABLE_TRANSPORT::MatchId (
    IN unsigned short Id
    )
{
    TRANS_INFO *Protseq ;
    DictionaryCursor cursor;

    ProtseqDict.Reset(cursor) ;
    while ((Protseq = ProtseqDict.Next(cursor)) != 0)
        {
        if (Protseq->MatchId(Id))
            {
            return Protseq ;
            }
        }

    return 0;
}

LOADABLE_TRANSPORT_DICT * LoadedLoadableTransports = NULL;

BOOL GetTransportEntryPoints(IN DLL *LoadableTransportDll, OUT TRANSPORT_LOAD *TransportLoad,
                             OUT FuncGetHandleForThread *GetHandleForThread,
                             OUT FuncReleaseHandleForThread *ReleaseHandleForThread
                             )
/*++
Function Name:GetTransportEntryPoints

Parameters: IN LoadableTransportDll - the DLL on which to obtain the entry points
            OUT TRANSPORT_LOAD *TransportLoad - the TransportLoad function for this DLL. 0 iff the 
                function fails
            OUT FuncGetHandleForThread *GetHandleForThread - the GetHandleForThread function for this DLL
            OUT FuncReleaseHandleForThread *ReleaseHandleForThread - the ReleaseHandleForThread
                function for this DLL

Description: Gets the entry points from this transport DLL

Returns: TRUE if successful, FALSE otherwise

--*/
{
    *TransportLoad = (TRANSPORT_LOAD) LoadableTransportDll->GetEntryPoint("TransportLoad");

    *GetHandleForThread = 
        (FuncGetHandleForThread) LoadableTransportDll->GetEntryPoint("GetCompletionPortHandleForThread");
    *ReleaseHandleForThread = 
        (FuncReleaseHandleForThread) LoadableTransportDll->GetEntryPoint("ReleaseCompletionPortHandleForThread");

    if ((*TransportLoad == 0)
        || (*GetHandleForThread == 0) 
        || (*ReleaseHandleForThread == 0)
        )
        {
        *TransportLoad = 0;
        return FALSE;
        }

    return TRUE;
}

RPC_STATUS
LoadableTransportInfo (
    IN RPC_CHAR * DllName,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    OUT TRANS_INFO * PAPI *pTransInfo
    )
/*++

Routine Description:

    We need to return the client information for the loadable transport
    specified by the argument, DllName.  This may mean that we need
    to load the transport support dll.

Argument:

    DllName - Supplies the name of the dll which we need to try and
        load to get the appropriate loadable transport interface.

    RpcProtocolSequence - Supplies the protocol sequence for which
        we are trying to find the appropriate loadable transport
        interface.

    Status - Returns the specific error code for failure to find/load
        a loadable transport.

Return Value:

    0 - If the specified transport interface can not be loaded for any
        reason: does not exist, out of memory, version mismatch, etc.

    Otherwise, a pointer to the client information for the requested
        transport interface (loadable transport support) will be returned.

--*/
{
    RPC_TRANSPORT_INTERFACE pTransportInterface;
    LOADABLE_TRANSPORT * LoadableTransport;
    TRANSPORT_LOAD TransportLoad;
    FuncGetHandleForThread GetHandleForThread;
    FuncReleaseHandleForThread ReleaseHandleForThread;
    DLL * LoadableTransportDll;
    RPC_STATUS Status = RPC_S_OK;
    DictionaryCursor cursor;

    ASSERT(Status == 0);

    // we can support only up to 4 loadable transports (though today we
    // use only 1 and we don't allow third parties to write their own). 
    // This allows us to avoid taking a mutex when browsing the 
    // LoadedLoadableTransports dictionary, as we never remove
    // transport from it
    ASSERT(LoadedLoadableTransports->Size() <= INITIALDICTSLOTS);

    //
    // To begin with, check to see if the transport is already loaded.
    // If so, all we have got to do is to return a pointer to it.
    //
    RequestGlobalMutex();
    LoadedLoadableTransports->Reset(cursor);
    while ((LoadableTransport
            = LoadedLoadableTransports->Next(cursor)) != 0)
        {
        *pTransInfo = LoadableTransport->MapProtocol (
                                                DllName,
                                                RpcProtocolSequence) ;
        if (*pTransInfo != 0)
            {
            ClearGlobalMutex();

            return RPC_S_OK;
            }
        }

    //
    // If we reach here, that means that we need to try and load the
    // specified loadable transport DLL.
    //
    LoadableTransportDll = new DLL(DllName, &Status);

    if (LoadableTransportDll == 0)
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }

    if (Status != RPC_S_OK)
        {
        ClearGlobalMutex();
        delete LoadableTransportDll;

        VALIDATE(Status)
            {
            RPC_S_OUT_OF_MEMORY,
            RPC_S_INVALID_ARG
            } END_VALIDATE;

         if ( Status != RPC_S_OUT_OF_MEMORY )
            {
            ASSERT( Status == RPC_S_INVALID_ARG );
            Status = RPC_S_PROTSEQ_NOT_SUPPORTED;
            }

        return Status;
        }

    if (GetTransportEntryPoints(LoadableTransportDll, &TransportLoad, &GetHandleForThread, 
        &ReleaseHandleForThread) == 0)
        {
        ClearGlobalMutex();
        delete LoadableTransportDll;

        return RPC_S_PROTSEQ_NOT_SUPPORTED;
        }

    pTransportInterface = (*TransportLoad)(RpcProtocolSequence);

    if ( pTransportInterface == 0 )
        {
        ClearGlobalMutex();
        delete LoadableTransportDll;

        return RPC_S_PROTSEQ_NOT_SUPPORTED;
        }

    if ( pTransportInterface->TransInterfaceVersion
        > RPC_TRANSPORT_INTERFACE_VERSION )
        {
        ClearGlobalMutex();
        delete LoadableTransportDll;

        return RPC_S_PROTSEQ_NOT_SUPPORTED;
        }

    //
    // When we reach here, we have successfully loaded and initialized
    // the loadable transport DLL.  Now we need to create the client
    // loadable transport and stick it in the dictionary.
    //
    LoadableTransport = new LOADABLE_TRANSPORT(
                                                     pTransportInterface,
                                                     DllName,
                                                     RpcProtocolSequence,
                                                     LoadableTransportDll,
                                                     GetHandleForThread,
                                                     ReleaseHandleForThread,
                                                     &Status,
                                                     pTransInfo);

    if ( LoadableTransport == 0 )
        {
        ClearGlobalMutex();
        delete LoadableTransportDll;

        return RPC_S_OUT_OF_MEMORY;
        }

    if ( Status != RPC_S_OK
        || LoadedLoadableTransports->Insert(LoadableTransport) == -1 )
        {
        ClearGlobalMutex();
        delete LoadableTransportDll;
        delete LoadableTransport;

        return RPC_S_OUT_OF_MEMORY;
        }

    ClearGlobalMutex();

    return RPC_S_OK;
}

TRANS_INFO PAPI *
GetLoadedClientTransportInfoFromId(
    IN unsigned short Id
    )
/*++

Routine Description:

    We need to return the client information for the loadable transport
    specified by the argument, TransportId. We look into the DICT and see
    if the transport is loaded- it it isnt, tough- we will return an error.
    -this is because we need Protseq and dllname to load a transport and
    all we have is a transport ID.

Argument:

    Id - Transport Id. This is actually the opcode used to encode endpoint
         in a DCE tower. For a listing see DCE spec Chapter 11&12.

    Status - Returns the error/success code.

Return Value:

    0 - If the specified transport interface can not be loaded for any
        reason: does not exist, out of memory.

    Otherwise, a pointer to the client information for the requested
        transport interface (loadable transport support) will be returned.

--*/
{
    TRANS_INFO PAPI *TransInfo ;
    LOADABLE_TRANSPORT * LoadableTransport;
    DictionaryCursor cursor;

    // To begin with, check to see if the transport is already loaded.
    // If so, all we have got to do is to return a pointer to it.

    RequestGlobalMutex();
    LoadedLoadableTransports->Reset(cursor);
    while ((LoadableTransport
            = LoadedLoadableTransports->Next(cursor)) != 0)
        {
        TransInfo = LoadableTransport->MatchId(Id);
        if (TransInfo != 0)
           {
            ClearGlobalMutex();

            return(TransInfo);
           }
        }

    // If we reached here, that means that we are in trouble
    // We assumed that all relevant loadable transports will be
    // loaded for us.... but we are wrong!

    ClearGlobalMutex();
    return(0);
}



int
InitializeLoadableTransportClient (
    )
/*++

Routine Description:

    This routine will be called at DLL load time.  We do all necessary
    initializations here for this file.

Return Value:

    Zero will be returned if initialization completes successfully;
    otherwise, non-zero will be returned.

--*/
{
    if (LoadedLoadableTransports == 0)
        {
        LoadedLoadableTransports = new LOADABLE_TRANSPORT_DICT;
        if (LoadedLoadableTransports == 0)
            return(1);
        }
    return(0);
}



inline
BOOL
ProcessIOEventsWrapper(
    IN LOADABLE_TRANSPORT PAPI *Transport
    )
/*++
Function Name:ProcessIOEventsWrapper

Parameters:

Description:

Returns:
    TRUE - thread should exit.

--*/
{
    Transport->ProcessIOEvents();
    return(TRUE);
}



RPC_STATUS
LOADABLE_TRANSPORT::StartServerIfNecessary (
    )
/*++
Function Name:StartServerIfNecessary

Parameters:

Description:

Returns:

--*/
{
    int i;
    RPC_STATUS Status ;
    int MinimumThreads = GlobalRpcServer->MinimumCallThreads ;

    if (    ThreadsStarted != 0
        ||  InterlockedIncrement(&ThreadsStarted) != 1)
        {
        return RPC_S_OK ;
        }

    Status = InitializeServerSideCellHeapIfNecessary();
    if (Status != RPC_S_OK)
        {
        ThreadsStarted = 0;
        return Status;
        }

    for (i = 0; i < MinimumThreads; i++)
        {
        InterlockedIncrement(&NumThreads);
        Status = GlobalRpcServer->CreateThread (
                             (THREAD_PROC) &ProcessIOEventsWrapper, this) ;
        if (Status != RPC_S_OK)
            {
            NumThreads = 0;
            ThreadsStarted = 0;
            return Status ;
            }
        }

    return RPC_S_OK;
}


RPC_STATUS
LOADABLE_TRANSPORT::CreateThread (void)
/*++
Function Name:CreateThread

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    if (NumThreads < 1)
        {
        Status = GlobalRpcServer->CreateThread (
                          (THREAD_PROC) &ProcessIOEventsWrapper, this) ;
        if (Status != RPC_S_OK)
            {
            return Status;
            }

        InterlockedIncrement(&NumThreads);
        }

    return RPC_S_OK;
}

inline
RPC_STATUS
LOADABLE_TRANSPORT::ProcessCalls (
    IN  INT Timeout,
    OUT RPC_TRANSPORT_EVENT *pEvent,
    OUT RPC_STATUS *pEventStatus,
    OUT PVOID *ppEventContext,
    OUT UINT *pBufferLength,
    OUT BUFFER *pBuffer,
    OUT PVOID *ppSourceContext)
/*++
Function Name:ProcessCalls

Parameters:

Description:

Returns:

--*/
{
    return (*ProcessCallsFunc) (
                            Timeout,
                            pEvent,
                            pEventStatus,
                            ppEventContext,
                            pBufferLength,
                            pBuffer,
                            ppSourceContext) ;
}

const ULONG MAX_THREAD_TIMEOUT = 660*1000;      // 11 minutes

void ProcessNewAddressEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                            IN RPC_TRANSPORT_EVENT Event,
                            IN RPC_STATUS EventStatus,
                            IN PVOID pEventContext,
                            IN UINT BufferLength,
                            IN BUFFER Buffer,
                            IN PVOID pSourceContext)
{
    LISTEN_FOR_PNP_NOTIFICATIONS PnpFunc;

    RpcpPurgeEEInfo();

    GlobalRpcServer->CreateOrUpdateAddresses();

#ifndef NO_PLUG_AND_PLAY
    PnpFunc = pLoadableTransport->PnpListen;
    (*PnpFunc)();
#endif
}

void ProcessConnectionServerReceivedEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                                          IN RPC_TRANSPORT_EVENT Event,
                                          IN RPC_STATUS EventStatus,    // operation status
                                          IN PVOID pEventContext,   // trans conenction
                                          IN UINT BufferLength,     // buffer length
                                          IN BUFFER Buffer,         // buffer
                                          IN PVOID pSourceContext)
{
    OSF_SCONNECTION *SConnection = InqTransSConnection(pEventContext);

    ASSERT(SConnection->InvalidHandle(OSF_SCONNECTION_TYPE) == 0);

    RpcpPurgeEEInfo();

    SConnection->ProcessReceiveComplete(EventStatus,
                                        Buffer,
                                        BufferLength);
}

void ProcessConnectionServerReceivedEventAvrf(LOADABLE_TRANSPORT *pLoadableTransport, 
                                              IN RPC_TRANSPORT_EVENT Event,
                                              IN RPC_STATUS EventStatus,
                                              IN PVOID pEventContext,
                                              IN UINT BufferLength,
                                              IN BUFFER Buffer,
                                              IN PVOID pSourceContext)
{
    if (EventStatus == RPC_S_OK)
        {
        CorruptionInject(ServerReceive,
                         &BufferLength,
                         &Buffer);
        }

    ProcessConnectionServerReceivedEvent(pLoadableTransport, 
                                         Event,
                                         EventStatus,
                                         pEventContext,
                                         BufferLength,
                                         Buffer,
                                         pSourceContext);
}

void ProcessConnectionServerSendEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                                      IN RPC_TRANSPORT_EVENT Event,
                                      IN RPC_STATUS EventStatus,
                                      IN PVOID pEventContext,
                                      IN UINT BufferLength,
                                      IN BUFFER Buffer,
                                      IN PVOID pSourceContext   // send context
                                      )
{
    OSF_SCALL *SCall = InqTransSCall(pSourceContext);
    
    ASSERT(SCall->InvalidHandle(OSF_SCALL_TYPE) == 0);
    
    ASSERT(EventStatus != RPC_S_OK
           || ((rpcconn_common *) Buffer)->frag_length == BufferLength);

    RpcpPurgeEEInfo();

    SCall->ProcessSendComplete(EventStatus, Buffer);
}

void ProcessConnectionClientSendEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                                      IN RPC_TRANSPORT_EVENT Event,
                                      IN RPC_STATUS EventStatus,    // Operation status
                                      IN PVOID pEventContext,
                                      IN UINT BufferLength,
                                      IN BUFFER Buffer,             // Buffer
                                      IN PVOID pSourceContext       // send context
                                      )
{
    REFERENCED_OBJECT *pObj;

    pObj = (REFERENCED_OBJECT *) *((PVOID *)
                     ((char *) pSourceContext - sizeof(void *)));
    ASSERT(pObj->InvalidHandle(OSF_CCALL_TYPE | OSF_CCONNECTION_TYPE) == 0);
    
    RpcpPurgeEEInfo();

    pObj->ProcessSendComplete(EventStatus, Buffer);
}

void ProcessConnectionClientReceiveEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                                         IN RPC_TRANSPORT_EVENT Event,
                                         IN RPC_STATUS EventStatus, // operation status
                                         IN PVOID pEventContext,    // trans connection
                                         IN UINT BufferLength,      // buffer length
                                         IN BUFFER Buffer,          // buffer
                                         IN PVOID pSourceContext)
{
    OSF_CCONNECTION *CConnection = InqTransCConnection(pEventContext);

    ASSERT(CConnection->InvalidHandle(OSF_CCONNECTION_TYPE) == 0);
    ASSERT(CConnection->IsExclusive() == FALSE);
    // make it hold on free builds as well
    if (CConnection->IsExclusive())
        {
        *((ULONG *)0) = Event;
        }

    RpcpPurgeEEInfo();

    CConnection->ProcessReceiveComplete(
                                EventStatus,
                                Buffer,
                                BufferLength);
    CConnection->RemoveReference();
}


void ProcessConnectionClientReceiveEventAvrf(LOADABLE_TRANSPORT *pLoadableTransport, 
                                             IN RPC_TRANSPORT_EVENT Event,
                                             IN RPC_STATUS EventStatus,
                                             IN PVOID pEventContext,
                                             IN UINT BufferLength,
                                             IN BUFFER Buffer,
                                             IN PVOID pSourceContext)
{
    if (EventStatus == RPC_S_OK)
        {
        CorruptionInject(ClientReceive,
                         &BufferLength,
                         &Buffer);
        }

    ProcessConnectionClientReceiveEvent(pLoadableTransport, 
                                        Event,
                                        EventStatus,
                                        pEventContext,
                                        BufferLength,
                                        Buffer,
                                        pSourceContext);
}

void ProcessDatagramServerReceiveEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                                       IN RPC_TRANSPORT_EVENT Event,
                                       IN RPC_STATUS EventStatus,
                                       IN PVOID pEventContext,
                                       IN UINT BufferLength,
                                       IN BUFFER Buffer,
                                       IN PVOID pSourceContext)
{
    RpcpPurgeEEInfo();
    
    ProcessDgServerPacket( EventStatus, 
                           pEventContext, 
                           Buffer, 
                           BufferLength, 
                           (DatagramTransportPair *)pSourceContext );
}

void ProcessDatagramServerReceiveEventAvrf(LOADABLE_TRANSPORT *pLoadableTransport, 
                                           IN RPC_TRANSPORT_EVENT Event,
                                           IN RPC_STATUS EventStatus,
                                           IN PVOID pEventContext,
                                           IN UINT BufferLength,
                                           IN BUFFER Buffer,
                                           IN PVOID pSourceContext)
{
    if (EventStatus == RPC_S_OK)
        {
        CorruptionInject(ServerReceive,
                         &BufferLength,
                         &Buffer);
        }

    ProcessDatagramServerReceiveEvent(pLoadableTransport, 
                                      Event,
                                      EventStatus,
                                      pEventContext,
                                      BufferLength,
                                      Buffer,
                                      pSourceContext);
}

void ProcessDatagramClientReceiveEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                                       IN RPC_TRANSPORT_EVENT Event,
                                       IN RPC_STATUS EventStatus,
                                       IN PVOID pEventContext,
                                       IN UINT BufferLength,
                                       IN BUFFER Buffer,
                                       IN PVOID pSourceContext)
{
    RpcpPurgeEEInfo();

    ProcessDgClientPacket( EventStatus, 
        pEventContext, 
        Buffer, 
        BufferLength, 
        (DatagramTransportPair *)pSourceContext );
}

void ProcessDatagramClientReceiveEventAvrf(LOADABLE_TRANSPORT *pLoadableTransport, 
                                           IN RPC_TRANSPORT_EVENT Event,
                                           IN RPC_STATUS EventStatus,
                                           IN PVOID pEventContext,
                                           IN UINT BufferLength,
                                           IN BUFFER Buffer,
                                           IN PVOID pSourceContext)
{
    if (EventStatus == RPC_S_OK)
        {
        CorruptionInject(ClientReceive,
                         &BufferLength,
                         &Buffer);
        }

    ProcessDatagramClientReceiveEvent(pLoadableTransport, 
                                      Event,
                                      EventStatus,
                                      pEventContext,
                                      BufferLength,
                                      Buffer,
                                      pSourceContext);
}

void ProcessRuntimePostedEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                               IN RPC_TRANSPORT_EVENT Event,
                               IN RPC_STATUS EventStatus,
                               IN PVOID pEventContext,
                               IN UINT BufferLength,
                               IN BUFFER Buffer,
                               IN PVOID pSourceContext)
{
    BOOL IsServer;
    BOOL SendToRuntime;
    RPC_STATUS RpcStatus;

    RpcpPurgeEEInfo();

    switch (BufferLength)
        {
        case CO_EVENT_BIND_TO_SERVER:

            extern void OsfBindToServer( PVOID Context );

            OsfBindToServer( pEventContext );
            break;

        case DG_EVENT_CALLBACK_COMPLETE:

            class DG_SCONNECTION;
            extern void ConvCallCompletedWrapper( PVOID Connection );

            ConvCallCompletedWrapper(pEventContext);
            break;

        case CO_EVENT_TICKLE_THREAD:
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Tickled\n",
                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
            // no-op
            break;

        case IN_PROXY_IIS_DIRECT_RECV:
            HTTP2IISDirectReceive(pEventContext);
            break;

        case HTTP2_DIRECT_RECEIVE:

            // For now we will not inject corruption prior to HTTP2DirectReceive.
            // We will need to query ((HTTP2EndpointReceiver *)pEventContext)->IsServer
            // to tell which kind of buffer this really is before injecting corruption.

            EventStatus = HTTP2DirectReceive(pEventContext,
                (BYTE **)&Buffer,
                (ULONG *)&BufferLength,
                &pEventContext,
                &IsServer
                );

            if (EventStatus != RPC_P_PACKET_CONSUMED) 
                {
                if (IsServer == FALSE)
                    {
                    if (gfRPCVerifierEnabled && EventStatus == RPC_S_OK)
                        {
                        CorruptionInject(ClientReceive,
                                         &BufferLength,
                                         &Buffer);
                        }
                    ProcessConnectionClientReceiveEvent(pLoadableTransport,
                        Event,
                        EventStatus,
                        pEventContext,
                        BufferLength,
                        Buffer,
                        pSourceContext);
                    }
                else
                    {
                    if (gfRPCVerifierEnabled && EventStatus == RPC_S_OK)
                        {
                        CorruptionInject(ServerReceive,
                                         &BufferLength,
                                         &Buffer);
                        }
                    ProcessConnectionServerReceivedEvent(pLoadableTransport,
                        Event,
                        EventStatus,
                        pEventContext,
                        BufferLength,
                        Buffer,
                        pSourceContext);
                    }
                }
            break;

        case HTTP2_WINHTTP_DIRECT_RECV:

            if (gfRPCVerifierEnabled && EventStatus == RPC_S_OK)
                {
                CorruptionInject(ClientReceive,
                                 &BufferLength,
                                 &Buffer);
                }

            EventStatus = HTTP2WinHttpDirectReceive(pEventContext,
                (BYTE **)&Buffer,
                (ULONG *)&BufferLength,
                &pEventContext
                );

            if (EventStatus != RPC_P_PACKET_CONSUMED) 
                {
                ProcessConnectionClientReceiveEvent(pLoadableTransport,
                    Event,
                    EventStatus,
                    pEventContext,
                    BufferLength,
                    Buffer,
                    pSourceContext);
                }
            break;

        case HTTP2_WINHTTP_DIRECT_SEND:
            EventStatus = HTTP2WinHttpDirectSend(pEventContext,
                (BYTE **)&Buffer,
                &pSourceContext
                );

            if (EventStatus != RPC_P_PACKET_CONSUMED) 
                {
                ProcessConnectionClientSendEvent(pLoadableTransport,
                    Event,
                    EventStatus,
                    pEventContext,
                    BufferLength,
                    Buffer,
                    pSourceContext);
                }
            break;

        case HTTP2_WINHTTP_DELAYED_RECV:
            HTTP2WinHttpDelayedReceive(pEventContext);
            break;

        case PLUG_CHANNEL_DIRECT_SEND:
            RpcStatus = HTTP2PlugChannelDirectSend(pEventContext);
            ASSERT(RpcStatus == RPC_S_OK);
            break;

        case CHANNEL_DATA_ORIGINATOR_DIRECT_SEND:
            EventStatus = HTTP2ChannelDataOriginatorDirectSend(pEventContext,
                &IsServer,
                &pSourceContext,
                &Buffer,
                &BufferLength
                );

            if (EventStatus != RPC_P_PACKET_CONSUMED) 
                {
                if (IsServer == FALSE)
                    {
                    ProcessConnectionClientSendEvent(pLoadableTransport,
                        Event,
                        EventStatus,
                        pEventContext,
                        BufferLength,
                        Buffer,
                        pSourceContext);
                    }
                else
                    {
                    ProcessConnectionServerSendEvent(pLoadableTransport,
                        Event,
                        EventStatus,
                        pEventContext,
                        BufferLength,
                        Buffer,
                        pSourceContext);
                    }
                }
            break;

        case HTTP2_FLOW_CONTROL_DIRECT_SEND:
            EventStatus = HTTP2FlowControlChannelDirectSend(pEventContext,
                &IsServer,
                &SendToRuntime,
                &pSourceContext,
                &Buffer,
                &BufferLength
                );

            if ((EventStatus != RPC_P_PACKET_CONSUMED) && (SendToRuntime != FALSE)) 
                {
                if (IsServer == FALSE)
                    {
                    ProcessConnectionClientSendEvent(pLoadableTransport,
                        Event,
                        EventStatus,
                        pEventContext,
                        BufferLength,
                        Buffer,
                        pSourceContext);
                    }
                else
                    {
                    ProcessConnectionServerSendEvent(pLoadableTransport,
                        Event,
                        EventStatus,
                        pEventContext,
                        BufferLength,
                        Buffer,
                        pSourceContext);
                    }
                }
            break;

        case HTTP2_RESCHEDULE_TIMER:
            HTTP2TimerReschedule(pEventContext);
            break;

        case HTTP2_ABORT_CONNECTION:
            HTTP2AbortConnection(pEventContext);
            break;

        case HTTP2_RECYCLE_CHANNEL:
            HTTP2RecycleChannel(pEventContext);
            break;

        default:
            ASSERT( 0 );
        }
}

void ProcessInvalidIOEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                           IN RPC_TRANSPORT_EVENT Event,
                           IN RPC_STATUS EventStatus,
                           IN PVOID pEventContext,
                           IN UINT BufferLength,
                           IN BUFFER Buffer,
                           IN PVOID pSourceContext)
{
    ASSERT(0);
}

void ProcessComplexTSend(LOADABLE_TRANSPORT *pLoadableTransport, 
                                       IN RPC_TRANSPORT_EVENT Event,
                                       IN RPC_STATUS EventStatus,   // status of the operation
                                       IN PVOID pEventContext,
                                       IN UINT BufferLength,
                                       IN BUFFER Buffer,
                                       IN PVOID pSourceContext      // send context
                                       )
{
    EventStatus = HTTP2ProcessComplexTSend(pSourceContext,
        EventStatus,
        &Buffer
        );

    if (EventStatus != RPC_P_PACKET_CONSUMED)
        {
        if ((Event & TYPE_MASK) == CLIENT)
            {
            ProcessConnectionClientSendEvent(pLoadableTransport,
                Event,
                EventStatus,
                pEventContext,
                BufferLength,
                Buffer,
                pSourceContext
                );
            }
        else
            {
            ProcessConnectionServerSendEvent(pLoadableTransport,
                Event,
                EventStatus,
                pEventContext,
                BufferLength,
                Buffer,
                pSourceContext
                );
            }
        }
}

void ProcessComplexTReceive(LOADABLE_TRANSPORT *pLoadableTransport, 
                            IN RPC_TRANSPORT_EVENT Event,
                            IN RPC_STATUS EventStatus,   // status of the operation
                            IN PVOID pEventContext,      // connection
                            IN UINT BufferLength,
                            IN BUFFER Buffer,
                            IN PVOID pSourceContext     // bytes received
                            )
{
    ULONG Bytes = PtrToUlong(pSourceContext);

    EventStatus = HTTP2ProcessComplexTReceive(&pEventContext,
        EventStatus,
        Bytes,
        &Buffer,
        &BufferLength
        );

    if ((EventStatus != RPC_P_PACKET_CONSUMED) 
        && (EventStatus != RPC_P_PARTIAL_RECEIVE))
        {
        if ((Event & TYPE_MASK) == CLIENT)
            {
            ProcessConnectionClientReceiveEvent(pLoadableTransport,
                Event,
                EventStatus,
                pEventContext,
                BufferLength,
                Buffer,
                pSourceContext);
            }
        else
            {
            ProcessConnectionServerReceivedEvent(pLoadableTransport,
                Event,
                EventStatus,
                pEventContext,
                BufferLength,
                Buffer,
                pSourceContext);
            }
        }
}

void ProcessComplexTReceiveAvrf(LOADABLE_TRANSPORT *pLoadableTransport, 
                                IN RPC_TRANSPORT_EVENT Event,
                                IN RPC_STATUS EventStatus,
                                IN PVOID pEventContext,
                                IN UINT BufferLength,
                                IN BUFFER Buffer,
                                IN PVOID pSourceContext
                                )
{
    if (EventStatus == RPC_S_OK)
        {
        CorruptionInject(ClientReceive,
                         &BufferLength,
                         &Buffer);
        }

    ProcessComplexTReceive(pLoadableTransport, 
                           Event,
                           EventStatus,
                           pEventContext,
                           BufferLength,
                           Buffer,
                           pSourceContext);
}

// note that this array must have correspondence to the constants in rpctrans.hxx
ProcessIOEventFunc *IOEventDispatchTable[LastRuntimeConstant + 1] = 
    {
    // 0 is CONNECTION | CLIENT | SEND
    ProcessConnectionClientSendEvent,
    // 1 is DATAGRAM | CLIENT | SEND
    ProcessInvalidIOEvent,
    // 2 is invalid
    ProcessInvalidIOEvent,
    // 3 is invalid
    ProcessInvalidIOEvent,
    // 4 is CONNECTION | SERVER | SEND
    ProcessConnectionServerSendEvent,
    // 5 is DATAGRAM | SERVER | SEND
    ProcessInvalidIOEvent,
    // 6 is invalid
    ProcessInvalidIOEvent,
    // 7 is invalid
    ProcessInvalidIOEvent,
    // 8 is CONNECTION | CLIENT | RECEIVE
    ProcessConnectionClientReceiveEvent,
    // 9 is DATAGRAM | CLIENT | RECEIVE
    ProcessDatagramClientReceiveEvent,
    // 10 is invalid
    ProcessInvalidIOEvent,
    // 11 is invalid
    ProcessInvalidIOEvent,
    // 12 is CONNECTION | SERVER | RECEIVE
    ProcessConnectionServerReceivedEvent,
    // 13 is DATAGRAM | SERVER | RECEIVE
    ProcessDatagramServerReceiveEvent,
    // 14 is invalid
    ProcessInvalidIOEvent,
    // 15 is invalid
    ProcessInvalidIOEvent,
    // 16 is COMPLEX_T | CONNECTION | SEND | CLIENT
    ProcessComplexTSend,
    // 17 is RuntimePosted
    ProcessRuntimePostedEvent,
    // 18 is NewAddress
    ProcessNewAddressEvent,
    // 19 is invalid
    ProcessInvalidIOEvent,
    // 20 is COMPLEX_T | CONNECTION | SEND | SERVER
    ProcessComplexTSend,
    // 21 is invalid
    ProcessInvalidIOEvent,
    // 22 is invalid
    ProcessInvalidIOEvent,
    // 23 is invalid
    ProcessInvalidIOEvent,
    // 24 is COMPLEX_T | CONNECTION | RECEIVE | CLIENT
    ProcessComplexTReceive,
    // 25 is invalid
    ProcessInvalidIOEvent,
    // 26 is invalid
    ProcessInvalidIOEvent,
    // 27 is invalid
    ProcessInvalidIOEvent,
    // 28 is COMPLEX_T | CONNECTION | RECEIVE | SERVER
    ProcessComplexTReceive
    };

const ULONG UndefinedLocalThreadTimeout = 0;

void LOADABLE_TRANSPORT::ProcessIOEvents (
    )
/*++
Function Name:ProcessIOEvents

Parameters:

Description:

Returns:
    TRUE - the thread should not be cached
    FALSE - the thread should be cached

--*/
{
    RPC_STATUS Status ;
    RPC_TRANSPORT_EVENT Event ;
    RPC_STATUS EventStatus ;
    PVOID EventContext ;
    BUFFER Buffer ;
    UINT BufferLength ;
    PVOID pSourceContext = 0;
    int Timeout = gThreadTimeout;
    unsigned int nLocalActivityValue = 0;
    int nOldActivityValue = nActivityValue;
    HANDLE hCompletionPortHandleForThread = GetHandleForThread();
    THREAD *CurrentThread;
    DebugThreadInfo *ThreadDebugCell;
    BOOL fThreadIsDoingLongWait = FALSE;
    ULONG LocalNumThreads;
    ULONG LocalThreadsDoingLongWait;
    long LocalMaxThreadTimeout;
#if defined (RPC_GC_AUDIT)
    long Temp;
#endif
    long ThreadActivationDelay;

    if (IocThreadStarted == 0)
        {
        IocThreadStarted = 1;
        }

    nThreadsAtCompletionPort.Increment();

    if ((gProrateStart > 0) && ((DWORD)nThreadsAtCompletionPort.GetInteger() > gProrateStart))
        {
        ThreadActivationDelay = nThreadsAtCompletionPort.GetInteger() - gProrateStart;
        if (ThreadActivationDelay > 0)
            {
            ThreadActivationDelay *= gProrateFactor;

            if ((DWORD)ThreadActivationDelay > gProrateMax)
                ThreadActivationDelay = gProrateMax;

            Sleep(ThreadActivationDelay);
            }
        }

    CurrentThread = RpcpGetThreadPointer();
    ASSERT(CurrentThread);
    ThreadDebugCell = CurrentThread->DebugCell;
    if (ThreadDebugCell)
        {
        ThreadDebugCell->Status = dtsIdle;
        ThreadDebugCell->LastUpdateTime = NtGetTickCount();
        ThreadDebugCell->Endpoint.CellID = 0;
        ThreadDebugCell->Endpoint.SectionID = 0;
        }

    while (1)
        {

        EventContext = hCompletionPortHandleForThread;
        Status = ProcessCalls (Timeout, 
                               &Event,
                               &EventStatus,
                               &EventContext,
                               &BufferLength,
                               &Buffer,
                               &pSourceContext);


        if (Status == RPC_S_OK)
            {
            InterlockedDecrement(&NumThreads);

            if (fThreadIsDoingLongWait)
                {
                fThreadIsDoingLongWait = FALSE;
#if defined (RPC_GC_AUDIT)
                Temp = ThreadsDoingLongWait.Decrement();
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: is coming back from long wait %d\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId(), Temp);
#else
                ThreadsDoingLongWait.Decrement();
#endif
                }

            Timeout = gThreadTimeout;

            if (ThreadDebugCell)
                {
                ThreadDebugCell->Status = dtsProcessing;
                ThreadDebugCell->LastUpdateTime = NtGetTickCount();
                }

            // capture the current activity state
            nOldActivityValue = nActivityValue;

            // indicate to the next thread that there's activity
            nLocalActivityValue ++;
            if ((nLocalActivityValue & 0xFF) == 0)
                nActivityValue ++;

            // make sure that the io event is within the bounds of the dispatch table
            ASSERT(Event < sizeof(IOEventDispatchTable) / sizeof(IOEventDispatchTable[0]));

            (*IOEventDispatchTable[Event])(this,
                                           Event,
                                           EventStatus,
                                           EventContext,
                                           BufferLength,
                                           Buffer,
                                           pSourceContext);

            InterlockedIncrement(&NumThreads);

            if (ThreadDebugCell)
                {
                ThreadDebugCell->Status = dtsIdle;
                ThreadDebugCell->LastUpdateTime = NtGetTickCount();
                }

            }
        else
            {
            BOOL fKeepThread = FALSE;

            // N.B. If a thread times out waiting for an Irp, we should
            // let it go, unless any one of the following conditions
            // exist:
            //  - it is the last listening thread on the port
            //  - there is an Irp pending on it
            //  - the port is busy, and we are at or below the optimal
            //    number of threads for this number of processors

            // N.B. The NumThreads and ThreadsDoingLongWait are not
            // changed atomically with respect to each other. This
            // opens a race condition, but the race is benign, if the
            // simple rule below is kept.
            // Whenever we change both NumThreads and 
            // ThreadsDoingLongWait, we must do so in a way that errs
            // to less threads doing short wait, rather than more
            // threads doing short wait. Thus we may scare somebody
            // into not doing a long wait, but that's better rather
            // than letting somebody do a long wait, and toasting the
            // garbage collection. For overview of the garbage
            // collection mechanism, see the header in GC.cxx
            ASSERT(Status == RPC_P_TIMEOUT);
            LocalNumThreads = InterlockedDecrement(&NumThreads);

            PerformGarbageCollection();

            if (!fThreadIsDoingLongWait)
                {
                // we will be conservative, and we will presume we will be
                // doing a long wait. If we're not, we'll decrement it later
                fThreadIsDoingLongWait = TRUE;
                LocalThreadsDoingLongWait = ThreadsDoingLongWait.Increment();
                }
            else
                {
                // we were already doing a long wait - just grab the current
                // value
                LocalThreadsDoingLongWait = ThreadsDoingLongWait.GetInteger();
                }

            // if there are no threads on short wait, and either one-time garbage
            // collection was requested (GarbageCollectionRequested), or items
            // with periodic garbage collection are requested 
            // (PeriodicGarbageCollectItems > 0), we can't go on a long wait
            if ((LocalNumThreads <= LocalThreadsDoingLongWait)
                && (GarbageCollectionRequested || (PeriodicGarbageCollectItems > 0)))
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: garbage collection requested - doing short wait %d, %d, %d, %d\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId(), LocalNumThreads,
                    LocalThreadsDoingLongWait, GarbageCollectionRequested, PeriodicGarbageCollectItems);
#endif
                // if garbage collection was requested, and there are
                // no threads doing a short wait, we can't do a long 
                // wait - indicate to the code below that gThreadTimeout
                // is the maximum allowed thread timeout and decrement
                // the number of threads doing a long wait (we incremented
                // it above - this decrement restores it)
                ASSERT (fThreadIsDoingLongWait);

                ThreadsDoingLongWait.Decrement();
                fThreadIsDoingLongWait = FALSE;

                LocalMaxThreadTimeout = gThreadTimeout;
                }
            else
                {
                // signal the code below that there is no restriction on
                // the timeout applied, and it is free to choose its
                // timeout
                LocalMaxThreadTimeout = UndefinedLocalThreadTimeout;
                }

            if (LocalNumThreads == 0)
                {
                fKeepThread = TRUE;

                if (LocalMaxThreadTimeout == UndefinedLocalThreadTimeout)
                    {
#if defined (RPC_GC_AUDIT)
                    DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Max thread timeout\n",
                        GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                    ASSERT(fThreadIsDoingLongWait);

                    Timeout = INFINITE;
                    }
                else
                    {
                    ASSERT(fThreadIsDoingLongWait == FALSE);
                    Timeout = LocalMaxThreadTimeout;
                    }
                }
#ifdef RPC_OLD_IO_PROTECTION
            else if (ThreadSelf()->InqProtectCount() > 1)
#else
            // the simplest form of timing out threads introduces the following problem
            // On an MP box, if we have N processors executing N threads, we need to keep
            // an extra thread to listen for new requests. However, periodically, it will
            // timeout, die, and then get recreated by one of the executing threads which
            // picks a new call. This wastes cycles. If, on the other hand, on an MP box
            // we keep N+1 threads around, we hurt scalability in the ASP case.
            // We solve this problem by introducing the concept of a busy port. A port is
            // busy if it has served within one timeout period approximately 2048 or more
            // calls. If a port falls into the busy category, we don't let go the N+1th
            // thread on an MP box. If the port has activity, but not enough to get into
            // the busy category, we timeout the extra thread. 2048 is an arbitrary number
            // where we switch trading memory for speed. nOptimalNumberOfThreads is
            // the number of processors + 1 for this implementation.
            // since nLocalActivityValue is updated once per 256 requests (to avoid sloshing)
            // having a difference of 8 is approximately 2048 requests. There is wide
            // margin of error, as it is possible for threads to be anywhere in the 256
            // range and still count as nothing, but that's ok.
            else if ((nThreadsAtCompletionPort.GetInteger() <= nOptimalNumberOfThreads)
                        && ((nOldActivityValue + 8) < nActivityValue))
#endif
                {
                fKeepThread = TRUE;
                Timeout *= 2;

                if (LocalMaxThreadTimeout == UndefinedLocalThreadTimeout)
                    LocalMaxThreadTimeout = MAX_THREAD_TIMEOUT;

                // if by doubling we have exceeded the max timeout,
                // drop back to it
                if (Timeout > LocalMaxThreadTimeout)
                    {
                    Timeout = LocalMaxThreadTimeout;
                    }
                // else
                //    {
                //    We could have checked whether Timeout still falls into
                //    the short wait category after doubling, but we know
                //    that short wait is gThreadTimeout, and after doubling
                //    it will be bigger. Therefore, we don't need to do this
                //    check
                //    }

                if ((ULONG)Timeout > gThreadTimeout)
                    {
                    if (!fThreadIsDoingLongWait)
                        {
#if defined (RPC_GC_AUDIT)
                        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Doing long wait: %d\n",
                            GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId(), Timeout);
#endif
                        fThreadIsDoingLongWait = TRUE;
                        ThreadsDoingLongWait.Increment();
                        }
                    }
                }
            else
                {
                ASSERT(fKeepThread == FALSE);
                }

            nOldActivityValue = nActivityValue;

            if (fKeepThread)
                {
                InterlockedIncrement(&NumThreads);
                if (ThreadDebugCell)
                    {
                    RelocateCellIfPossible((void **) &ThreadDebugCell, &CurrentThread->DebugCellTag);
                    CurrentThread->DebugCell = ThreadDebugCell;
                    }
                }
            else
                {
                if (fThreadIsDoingLongWait)
                    {
                    ThreadsDoingLongWait.Decrement();
                    }
                else
                    {
                    // the only way this thread can be here is if
                    // all other threads are on long wait
                    ASSERT(LocalNumThreads <= LocalThreadsDoingLongWait);

                    // in this case, make a best effort to tickle one
                    // of the threads on a long wait. We ignore the result.
                    // This is ok, because it will only delay the gc until
                    // on of the long wait threads comes back.
                    TickleIocThread();
                    }
                break;
                }
            }
        }

    nThreadsAtCompletionPort.Decrement();

    if (ThreadDebugCell)
        {
        ThreadDebugCell->Status = dtsAllocated;
        ThreadDebugCell->LastUpdateTime = NtGetTickCount();
        }

    ReleaseHandleForThread(hCompletionPortHandleForThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\async.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       async.cxx
//
//--------------------------------------------------------------------------

#include <precomp.hxx>


RPC_STATUS RPC_ENTRY
RpcAsyncRegisterInfo (
    IN PRPC_ASYNC_STATE pAsync
    )
/*++

Routine Description:

 Obsolete function - just an entry point.

Return Value:

--*/

{
#if !defined(_M_IA64)
    return RPC_S_OK ;
#else
    return RPC_S_CANNOT_SUPPORT;
#endif
}


RPC_STATUS RPC_ENTRY
RpcAsyncCancelCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN BOOL fAbort 
    )
/*++
Function Name:RpcAsyncCancelCall

Parameters:

Description:

Returns:

--*/
{
    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) pAsync->RuntimeInfo;

    if (!ThreadSelf())
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    if (MObject)
        {
        if (MObject->InvalidHandle(CALL_TYPE))
            {
            return (RPC_S_INVALID_BINDING);
            }

        return ((CALL *) MObject)->CancelAsyncCall(fAbort);
        }

    return (RPC_S_INVALID_BINDING);
}
    


RPC_STATUS RPC_ENTRY
RpcAsyncGetCallStatus (
    IN PRPC_ASYNC_STATE pAsync
    )
/*++ 

Routine Description:

 description

Arguments:

 pAsync -

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) pAsync->RuntimeInfo;

    if (MObject)
        {
        if (MObject->InvalidHandle(CALL_TYPE))
            {
            return (RPC_S_INVALID_BINDING);
            }

        return ((CALL *) MObject)->GetCallStatus() ;
        }

    return RPC_S_INVALID_BINDING;
}


VOID APIENTRY
I_RpcAPCRoutine (
    IN RPC_APC_INFO *pAPCInfo
    )
{
    PRPC_ASYNC_STATE pAsync = pAPCInfo->pAsync;
    void *Context = pAPCInfo->Context;
    RPC_ASYNC_EVENT Event = pAPCInfo->Event;
    PFN_RPCNOTIFICATION_ROUTINE pRoutine = 
                pAPCInfo->pAsync->u.APC.NotificationRoutine;

    ((CALL *) pAPCInfo->hCall)->FreeAPCInfo(pAPCInfo) ;
    
    (*pRoutine) (pAsync, Context, Event) ;

    //
    // We cannot do anything after the call to the user's API routine. The
    // may be gone 
    //
}


///////////////////////////////////////////////////////
//                    Routines owned by NDR                      //
///////////////////////////////////////////////////////
//
//
//  RpcAsyncAbortCall
//  RpcAsyncCompleteCall
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\bufapi.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    bufapi.cxx

Abstract:

    The two APIs used to allocate and free buffers used to make remote
    procedure calls reside in this file.  These APIs are used by both
    the client and server in caller and callee stubs.

Author:

    Michael Montague (mikemon) 07-Nov-1991

Revision History:

    Connie Hoppe     (connieh) 26-Jul-1993  I_RpcGetBuffer
    Kamen Moutafov   (kamenm)  Jan 2000 - Multiple transfer syntax support

--*/

#include <precomp.hxx>

inline RPC_STATUS CheckHandleValidity (IN OUT RPC_MESSAGE __RPC_FAR * Message)
{
    if (((GENERIC_OBJECT *) (Message->Handle))->InvalidHandle(
                                            CALL_TYPE | BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);
    else
        return RPC_S_OK;
}

RPC_STATUS 
EnterBufApiPartial (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    )
{
    THREAD *Thread;
    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    // for WIN64, these are never set
#if !defined(_WIN64)
    // this is used to workaround a MIDL 1.0 bug
    // which didn't initialize the RpcFlags. MIDL 2.0 initializes the
    // flags correctly, and in addition sets this bit in the ProcNum
    // to indicate the flags are set correctly.
    if (Message->ProcNum & RPC_FLAGS_VALID_BIT)
        {
#endif
        // Flags are valid, clear the bit.
        Message->ProcNum &= ~(RPC_FLAGS_VALID_BIT);
#if !defined(_WIN64)
        }
    else
        {
        // Flags are invalid, set to zero.
        Message->RpcFlags = 0;
        }
#endif

    return RPC_S_OK;
}

RPC_STATUS 
EnterBufApiFull (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    )
{
    RPC_STATUS Status;

    Status = EnterBufApiPartial(Message);
    if (Status == RPC_S_OK)
        Status = CheckHandleValidity (Message);
    return Status;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNegotiateTransferSyntax (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    )
/*++

Routine Description:

    NDR calls this routine to get the transfer syntax to be used in marshalling.
    Stubs that are multiple transfer syntax aware (starting with the 64 bit release
    of Win2000) will set the RPCFLG_HAS_MULTI_SYNTAXES in RPC_CLIENT_INTERFACE
    to indicate they have properly initialized the InterpreterInfo field. Legacy
    stubs will not have this flag initialized, and will call I_RpcGetBuffer[WithObject]
    directly. The runtime has to be prepared to deal with this. Stubs that
    support only NDR2.0 are free to behave as legacy stubs.

Arguments:

    Message - Supplies the information necessary to allocate the buffer,
        and returns the allocated buffer. This function assumes that
        the handle passed in Message->Handle is a binding handle. It also
        assumes Message->TransferSyntax is valid.

Return Value:

    RPC_S_OK - The operation completed successfully.

--*/
{
    RPC_STATUS Status;
    MESSAGE_OBJECT *MessageObject;

    // validate and transorm some input parameters
    Status = EnterBufApiFull(Message);

    MessageObject = (MESSAGE_OBJECT *)Message->Handle;

    if (Status != RPC_S_OK)
        return Status;

    return MessageObject->NegotiateTransferSyntax(Message);
}


RPC_STATUS RPC_ENTRY
I_RpcGetBufferWithObject (
    IN OUT PRPC_MESSAGE Message,
    IN UUID * ObjectUuid
    )
/*++

Routine Description:

    In this API, we do all of the rpc protocol module independent work of
    allocating a buffer to be used in making a remote procedure call.  This
    consists of validating the handle, and then calling the rpc protocol
    module to do the real work.


Arguments:

    Message - Supplies the information necessary to allocate the buffer,
        and returns the allocated buffer.

Return Value:

    RPC_S_OK - The operation completed successfully.

--*/
{
    RPC_STATUS Status;
    RPC_CLIENT_INTERFACE *ClientInterface;
    BOOL fObjectIsSCall;
    MESSAGE_OBJECT *MessageObject;

    Status = CheckHandleValidity (Message);
    if (Status)
        return Status;

    MessageObject = (MESSAGE_OBJECT *)Message->Handle;
    fObjectIsSCall = MessageObject->Type(SCALL_TYPE);

    // in all fairness, this could very well be a server interface, but
    // they have the same layout, and the Flags field is in the same place,
    // so we can test the Flags field as if this is a client interface
    ClientInterface = (RPC_CLIENT_INTERFACE *)Message->RpcInterfaceInformation;

    // check whether this is a client stub that supports multiple transfer 
    // syntaxes if yes, it should have called I_RpcNegotiateTransferSyntax 
    // by now
    if (!fObjectIsSCall && DoesInterfaceSupportMultipleTransferSyntaxes(ClientInterface))
        {
        // if this interface supports multiple transfer syntaxes
        // the stub should have called already I_RpcNegotiateTransferSyntax
        // and this cannot be an OSF_BINDING_HANDLE
        ASSERT(!MessageObject->Type(OSF_BINDING_HANDLE_TYPE));
        ASSERT(!MessageObject->Type(LRPC_BINDING_HANDLE_TYPE));

        if (ObjectUuid && ((RPC_UUID *) ObjectUuid)->IsNullUuid())
            {
            ObjectUuid = 0;
            }

        Status = MessageObject->GetBuffer(Message, ObjectUuid);
        }
    else
        {

        // if not, this is either a legacy stub, a new stub that supports
        // one transfer syntax only, or a server side call

        // validate the input parameters
        Status = EnterBufApiPartial(Message);
        if (Status != RPC_S_OK)
            return Status;

        if (!fObjectIsSCall)
            {
            // this applies only on the client side
            Status = MessageObject->NegotiateTransferSyntax(Message);
            if (Status != RPC_S_OK)
                return Status;
            MessageObject = (MESSAGE_OBJECT *)Message->Handle;

            if (ObjectUuid && ((RPC_UUID *) ObjectUuid)->IsNullUuid())
                {
                ObjectUuid = 0;
                }
            }

        // by now this should not be a binding handle object
        ASSERT(!MessageObject->Type(OSF_BINDING_HANDLE_TYPE));
        ASSERT(!MessageObject->Type(LRPC_BINDING_HANDLE_TYPE));
        Status = MessageObject->GetBuffer(Message, ObjectUuid);
        }

#ifdef DEBUGRPC
    if ( Status == RPC_S_OK )
        {
        // Ensure that the buffer is aligned
        ASSERT( (((ULONG_PTR) Message->Buffer) % 8) == 0);

        // Uncomment this to check for 16 byte alignment on 64 bit
        // ASSERT( IsBufferAligned(Message->Buffer) );
        }
#endif // DEBUGRPC

    return(Status);
}

RPC_STATUS RPC_ENTRY
I_RpcGetBuffer (
    IN OUT PRPC_MESSAGE Message
    )
{
    return I_RpcGetBufferWithObject (Message, 0);
}


RPC_STATUS RPC_ENTRY
I_RpcFreeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

    The stubs free buffers using the API.  The buffer must have been
    obtained from I_RpcGetBuffer or I_RpcSendReceive, or as an argument
    to a callee stub.

Arguments:

    Message - Supplies the buffer to be freed and handle information
        about who owns the buffer.

Return Value:

    RPC_S_OK - The operation completed successfully.

--*/
{
    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    ASSERT( ((GENERIC_OBJECT *) Message->Handle)->InvalidHandle(CALL_TYPE) == 0 );

    ((MESSAGE_OBJECT *) (Message->Handle))->FreeBuffer(Message);

    return(RPC_S_OK);
}



RPC_STATUS RPC_ENTRY
I_RpcFreePipeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

    Free the buffer that was either implicitly or explicitly allocated for use
    in conjunction with pipes

Arguments:

    Message - Supplies the buffer to be freed and handle information
        about who owns the buffer.

Return Value:

    RPC_S_OK - The operation completed successfully.

--*/
{
    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    ASSERT( ((GENERIC_OBJECT *) Message->Handle)->InvalidHandle(CALL_TYPE) == 0 );

    ((MESSAGE_OBJECT *) (Message->Handle))->FreePipeBuffer(Message);

    return(RPC_S_OK);
}



RPC_STATUS RPC_ENTRY
I_RpcReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    )
/*++

Routine Description:

    Realloc a buffer, this is API is used in conjunction with pipes

Arguments:

    Message - Supplies the buffer to be freed and handle information
        about who owns the buffer.

Return Value:

    RPC_S_OK - The operation completed successfully.

--*/

{
    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    ASSERT( ((GENERIC_OBJECT *) Message->Handle)->InvalidHandle(CALL_TYPE) == 0 );

    if (!ThreadSelf())
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcpPurgeEEInfo();

    return ((MESSAGE_OBJECT *) (Message->Handle))->ReallocPipeBuffer(Message, NewSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\cellheap.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CellHeap.cxx

Abstract:

    The functions for the cell heap. Implements a heap
    of cells, each one of equal size with high locality
    of reference.

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>
#include <CellHeap.hxx>
#include <MutexWrp.hxx>

// explicit placement new operator
inline
PVOID __cdecl
operator new(
        size_t size,
        PVOID pPlacement
        )
{
        return pPlacement;
}

const int NumberOfSectionNameRetries = 301;

CellHeap *g_pCellHeap = NULL;
BOOL g_fServerSideCellHeapInitialized = FALSE;
CellSection *pCachedCellSection = NULL;

MUTEX *CellHeap::EffectiveCellHeapMutex = NULL;

#define MAJOR_CELLHEAP_DEBUG

#if DBG
int CellHeap::NumberOfCellsPerFirstPageInSection = 0;
int CellHeap::NumberOfCellsPerPageInSection = 0;
#endif

CellSection *CellSection::AllocateCellSection(OUT RPC_STATUS *Status, 
    IN BOOL fFirstSection, IN SECURITY_DESCRIPTOR *pSecDescriptor, 
    IN CellHeap *pCellHeap)
{
    HANDLE hFileMapping;
    PVOID SectionPointer;
    BOOL bRes;
    int SectionSize = NumberOfPagesPerSection * gPageSize;
    RPC_CHAR SectionName[RpcSectionNameMaxSize];     // 3*8 is the max hex representation
                        // of three DWORDS 
    DWORD RandomNumber[2];
    RPC_CHAR *SectionNamePointer;
    int i;
    CellSection *pCellSection;
    UNICODE_STRING SectionNameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess;
    LARGE_INTEGER SectionSizeParam;
    NTSTATUS NtStatus;
    DWORD ProcessID = GetCurrentProcessId();

    for (i = 0; i < NumberOfSectionNameRetries; i ++)
        {
        // we'll try creating a named object until the last try, when
        // we're content with creating any object
        if (i == (NumberOfSectionNameRetries - 1))
            {
            SectionNamePointer = NULL;
            }
        else
            {
            // the first section is named with the prefix and PID only,
            // which makes the other stuff unnecessary
            if (!fFirstSection)
                {
                // generate the random numbers
                *Status = GenerateRandomNumber((unsigned char *)RandomNumber, 8);
                if (*Status != RPC_S_OK)
                    return NULL;

                GenerateSectionName(SectionName, 
                    sizeof(SectionName) / sizeof(SectionName[0]), 
                    ProcessID, 
                    RandomNumber);
                }
            else
                {
                GenerateSectionName(SectionName, 
                    sizeof(SectionName) / sizeof(SectionName[0]), 
                    ProcessID, 
                    NULL);

                // ensure there are no retries for the first section
                i = NumberOfSectionNameRetries - 2;
                }

            SectionNamePointer = SectionName;
            }

        DesiredAccess = STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE;
        RtlInitUnicodeString(&SectionNameString, SectionNamePointer);
        InitializeObjectAttributes(&ObjectAttributes,
            &SectionNameString,
            OBJ_CASE_INSENSITIVE,
            0,
            pSecDescriptor);
        SectionSizeParam.LowPart = SectionSize;
        SectionSizeParam.HighPart = 0;

        NtStatus = NtCreateSection(&hFileMapping, DesiredAccess, &ObjectAttributes, &SectionSizeParam,
            PAGE_READWRITE, SEC_RESERVE, NULL);
        if (!NT_SUCCESS(NtStatus))
            {
            if (NtStatus == STATUS_NO_MEMORY)
                *Status = RPC_S_OUT_OF_MEMORY;
            else if ((NtStatus == STATUS_INSUFFICIENT_RESOURCES) || (NtStatus == STATUS_QUOTA_EXCEEDED))
                *Status = RPC_S_OUT_OF_RESOURCES;
            else if ((NtStatus == STATUS_OBJECT_PATH_INVALID)
                || (NtStatus == STATUS_OBJECT_PATH_NOT_FOUND)
                || (NtStatus == STATUS_OBJECT_NAME_INVALID)
                || (NtStatus == STATUS_OBJECT_NAME_COLLISION))
                {
                *Status = RPC_S_INTERNAL_ERROR;
                }
            else if (NtStatus == STATUS_OBJECT_TYPE_MISMATCH)
                {
                // somebody is attacking us, or there is a collision - try again
                continue;
                }
            else
                {
                ASSERT(0);
                *Status = RPC_S_OUT_OF_MEMORY;
                }
            return NULL;
            }
        else if (NtStatus == STATUS_OBJECT_NAME_EXISTS)
            {
            CloseHandle(hFileMapping);
            hFileMapping = NULL;
            }
        else
            {
            ASSERT(hFileMapping != NULL);
            break;
            }

        // name conflict - keep trying
        }

    SectionPointer = MapViewOfFileEx(hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, SectionSize, NULL);
    if (SectionPointer == NULL)
        {
        *Status = GetLastError();
        CloseHandle(hFileMapping);
        return NULL;
        }

    if (VirtualAlloc(SectionPointer, 1, MEM_COMMIT, PAGE_READWRITE) == NULL)
        {
        *Status = GetLastError();
        CloseDbgSection(hFileMapping, SectionPointer);
        return NULL;
        }

    *Status = RPC_S_OK;

    // explicit placement - can't fail with NULL return value
    pCellSection = new (SectionPointer) CellSection(Status, hFileMapping, pCellHeap, RandomNumber);
    if (*Status != RPC_S_OK)
        {
        return NULL;
        }

    return pCellSection;
}

#if DBG
void CellSection::AssertValid(CellHeap *pCellHeap)
{
    int i;
    DWORD Ignored;
    BOOL fAccessTestSucceeded;
    int LocalCountOfUsedCells;
    int NumberOfCellsInSection;
    DebugFreeCell *pCurrentCell;

    pCellHeap->CellHeapMutex.VerifyOwned();
    ASSERT(Signature == 0xdada);
    ASSERT(LastCommittedPage >= 1);
    ASSERT(LastCommittedPage <= NumberOfPagesPerSection);

    // check that the pages claimed committed are indeed committed
    for (i = 0; i < LastCommittedPage; i ++)
        {
        fAccessTestSucceeded = TRUE;

        __try
            {
            Ignored = *(DWORD *)(((unsigned char *)this) + gPageSize * i);
            }
        __except (EXCEPTION_EXECUTE_HANDLER)
            {
            fAccessTestSucceeded = FALSE;
            }

        ASSERT(fAccessTestSucceeded == TRUE);
        }

    if (SectionID == -1)
        {
        ASSERT(pCachedCellSection == this);
        }
    else
        {
        ASSERT(pCellHeap->CellHeapSections.Find(SectionID) == this);
        ASSERT(pCachedCellSection != this);
        }

#ifdef MAJOR_CELLHEAP_DEBUG
    NumberOfCellsInSection = pCellHeap->GetSectionCapacity(this);
    pCurrentCell = (DebugFreeCell *)(this + 1);
    LocalCountOfUsedCells = 0;
    // count that the number of used cells is indeed what the header says it is
    for (i = 0; i < NumberOfCellsInSection; i ++)
        {
        if (pCurrentCell->Type != dctFree)
            LocalCountOfUsedCells ++;
        ASSERT(pCurrentCell->Type >= dctFirstEntry);
        ASSERT(pCurrentCell->Type <= dctLastEntry);
        pCurrentCell ++;
        }

    ASSERT(LocalCountOfUsedCells == NumberOfUsedCells);
#endif

    // if this is the cached section, make sure all cells are free
    if (SectionID == -1)
        {
        ASSERT(NumberOfUsedCells == 0);
        }

    // the NextSectionId is checked by the CellHeap validate function
    ASSERT(hFileMapping != NULL);

    // the sections list chain and the free cell chain are 
    // verified by the CellHeap::AssertValid
}
#endif

CellSection::CellSection(IN OUT RPC_STATUS *Status, IN OUT HANDLE hNewFileMapping, 
                         IN CellHeap *pCellHeap, IN DWORD *pRandomNumbers)
{
#if defined(_WIN64)
    ASSERT(sizeof(CellSection) == 64);
#else
    ASSERT(sizeof(CellSection) == 32);
#endif

    // initialize variables to well known values
    Signature = 0xdada;
    LastCommittedPage = 1;
    SectionID = -1;
    NumberOfUsedCells = 0;
    NextSectionId[0] = 0;
    NextSectionId[1] = 0;
    hFileMapping = hNewFileMapping;
    pFirstFreeCell = (DebugFreeCell *)(this + 1);
    InitializeListHead(&SectionListEntry);
#if defined(_WIN64)
    Reserved[0] = 0;
    Reserved[1] = 0;
    Reserved[2] = 0;
    Reserved[3] = 0;
#endif

    if (*Status != RPC_S_OK)
        return;

    InitializeNewPage(this);

    *Status = pCellHeap->SectionCreatedNotify(this, pRandomNumbers, NULL, NULL);

    if (*Status != RPC_S_OK)
        {
        // unmap this - don't touch any data member afterwards!
        CloseDbgSection(hNewFileMapping, this);
        }
    else
        {
#if DBG
        pCellHeap->CellHeapMutex.Request();
        ASSERT_VALID1(this, pCellHeap);
        pCellHeap->CellHeapMutex.Clear();
#endif
        }

}

void CellSection::Free(void)
{
    HANDLE hLocalFileMapping = hFileMapping;

    ASSERT(hLocalFileMapping);

    // unmaps this - don't touch data members after this!
    CloseDbgSection(hLocalFileMapping, this);
}

RPC_STATUS CellSection::ExtendSection(IN CellHeap *pCellHeap)
{
    PVOID NewCommitPointer;

    ASSERT(LastCommittedPage < NumberOfPagesPerSection);
    pCellHeap->CellHeapMutex.VerifyOwned();

    NewCommitPointer = (unsigned char *)this + gPageSize * LastCommittedPage;
    if (VirtualAlloc(NewCommitPointer, 1, MEM_COMMIT, PAGE_READWRITE) == NULL)
        return RPC_S_OUT_OF_MEMORY;

    LastCommittedPage ++;

    InitializeNewPage(NewCommitPointer);

    // the pFirstFreeCell should be NULL - otherwise we shouldn't be
    // extending the section
    ASSERT(pFirstFreeCell == NULL);

    pCellHeap->InsertNewPageSegmentInChain((DebugFreeCell *)NewCommitPointer, 
        (DebugFreeCell *)((unsigned char *)NewCommitPointer + gPageSize - sizeof(DebugFreeCell)));
    pFirstFreeCell = (DebugFreeCell *)NewCommitPointer;

    return RPC_S_OK;
}

void CellSection::InitializeNewPage(PVOID NewPage)
{
    DebugFreeCell *pCurrentFreeCell, *pPrevFreeCell;
    PVOID EndAddress;

    // initialize the cells within the heap and chain them for quick insertion
    // if this is the first page in the section, skip the section header
    if (NewPage == this)
        pCurrentFreeCell = (DebugFreeCell *)(this + 1);
    else
        pCurrentFreeCell = (DebugFreeCell *)NewPage;

    pCurrentFreeCell->FreeCellsChain.Blink = NULL;
    EndAddress = (unsigned char *)NewPage + gPageSize;
    pPrevFreeCell = NULL;
    while (pCurrentFreeCell < (DebugFreeCell *)EndAddress)
        {
        pCurrentFreeCell->TypeHeader = 0;
        pCurrentFreeCell->Type = dctFree;
        pCurrentFreeCell->pOwnerSection = this;
        if (pPrevFreeCell)
            {
            pCurrentFreeCell->FreeCellsChain.Blink = &(pPrevFreeCell->FreeCellsChain);
            pPrevFreeCell->FreeCellsChain.Flink = &(pCurrentFreeCell->FreeCellsChain);
            }
        pPrevFreeCell = pCurrentFreeCell;
        pCurrentFreeCell ++;
        }
    pPrevFreeCell->FreeCellsChain.Flink = NULL;
}

CellHeap::CellHeap(IN OUT RPC_STATUS *Status)
{
    // initialize data members to well known values
    InitializeListHead(&FreeCellsList);
    InitializeListHead(&SectionsList);
    SecurityDescriptor = NULL;
#if DBG
    NumberOfCellsPerFirstPageInSection = (gPageSize - sizeof(CellSection)) / sizeof(DebugFreeCell);
    NumberOfCellsPerPageInSection = (gPageSize / sizeof(DebugFreeCell));
#endif

    if (*Status != RPC_S_OK)
        return;

    EffectiveCellHeapMutex = new MUTEX(Status, TRUE, 8000);
    if (EffectiveCellHeapMutex == NULL)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        return;
        }

    if (*Status != RPC_S_OK)
        {
        delete EffectiveCellHeapMutex;
        return;
        }

    *Status = CreateSecurityDescriptor();
    if (*Status != RPC_S_OK)
        return;
}

CellHeap::~CellHeap(void)
{
    PACL pdacl;
    BOOL DaclPresent;
    BOOL DaclDefaulted;
    BOOL bRes;
    CellSection *pCurrentSection, *pNextSection;

    if (SecurityDescriptor != NULL)
        {
        bRes = GetSecurityDescriptorDacl(SecurityDescriptor, &DaclPresent, 
            &pdacl, &DaclDefaulted);
        ASSERT(bRes);
        ASSERT(DaclPresent);
        ASSERT(DaclDefaulted == FALSE);
        ASSERT(pdacl);
        delete pdacl;
        delete SecurityDescriptor;
        }

    // nuke all sections in the list
    pCurrentSection = (CellSection *) SectionsList.Flink;
    while (pCurrentSection != (CellSection *)&SectionsList)
        {
        CellHeapSections.Delete(pCurrentSection->SectionID);
        pNextSection = (CellSection *) pCurrentSection->SectionListEntry.Flink;
        pCurrentSection->Free();
        pCurrentSection = pNextSection;
        }
}

DebugFreeCell *CellHeap::AllocateCell(OUT CellTag *pCellTag)
{
    DebugFreeCell *pCurrentCell, *pNextCell, *pLastCell;
    LIST_ENTRY *pCurrentEntry;
    CellSection *pCurrentSection;
    RPC_STATUS Status;
    int RetryCount;

    // get the mutex
    CellHeapMutex.Request();

    ASSERT_VALID(this);

    // is there something on the list?
    if (IsListEmpty(&FreeCellsList))
        {
        // no, need to extend the cell heap

        // first, try to extend some section, if there is space for it
        // the list must not be empty
        ASSERT(!IsListEmpty(&SectionsList));

        // this operation is fast, so we can do it inside the mutex and
        // gain simpler code
        pCurrentEntry = SectionsList.Flink;
        while (pCurrentEntry != &SectionsList)
            {
            pCurrentSection = CONTAINING_RECORD(pCurrentEntry, CellSection, SectionListEntry);
            if (pCurrentSection->LastCommittedPage < NumberOfPagesPerSection)
                {
                // try to extend the section
                Status = pCurrentSection->ExtendSection(this);
                if (Status == RPC_S_OK)
                    goto PopFreeDebugCell;

                ASSERT_VALID(this);
                // we're truly out of memory
                CellHeapMutex.Clear();
                return NULL;
                }
            pCurrentEntry = pCurrentEntry->Flink;
            }

        // if we are here, all sections are full - try the cached section
        if (pCachedCellSection)
            {
            pLastCell = CONTAINING_RECORD(pCachedCellSection->pFirstFreeCell->FreeCellsChain.Blink,
                DebugFreeCell, FreeCellsChain);
            pCachedCellSection->pFirstFreeCell->FreeCellsChain.Blink = NULL;
            Status = SectionCreatedNotify(pCachedCellSection, pCachedCellSection->NextSectionId,
                pCachedCellSection->pFirstFreeCell, pLastCell);
            if (Status != RPC_S_OK)
                {
                ASSERT_VALID(this);
                CellHeapMutex.Clear();
                return NULL;
                }

            // terminate the name chain for the just inserted cached section
            pCachedCellSection->NextSectionId[0] = 0;
            pCachedCellSection->NextSectionId[1] = 0;
            pCachedCellSection = NULL;
            goto PopFreeDebugCell;
            }

        ASSERT_VALID(this);
        // This is going to be slow -
        // release the mutex and we will claim it later, when we're done
        CellHeapMutex.Clear();

        RetryCount = 0;
        while (TRUE)
            {
            // try to allocate a new section
            Status = AllocateCellSection(FALSE);
            if (Status == RPC_S_OK)
                {
                CellHeapMutex.Request();
                ASSERT_VALID(this);
                if (!IsListEmpty(&FreeCellsList))
                    goto PopFreeDebugCell;
                // it is possible, though very unlikely that all allocated
                // cells have been used by the other threads. Retry a limited
                // number of times
                CellHeapMutex.Clear();
                RetryCount ++;
                ASSERT(RetryCount < 3);
                }
            else
                return NULL;
            }
        }
    else
        {
PopFreeDebugCell:
        CellHeapMutex.VerifyOwned();
        // pop off the list
        pCurrentEntry = RemoveHeadList(&FreeCellsList);
        pCurrentCell = (DebugFreeCell *) CONTAINING_RECORD(pCurrentEntry, DebugFreeCell, FreeCellsChain);
        // if there are more entries in the list ...
        if (!IsListEmpty(&FreeCellsList))
            {
            pNextCell = (DebugFreeCell *) CONTAINING_RECORD(FreeCellsList.Flink, DebugFreeCell, FreeCellsChain);
            // ... and the next cell is from this section ...
            if (pCurrentCell->pOwnerSection == pNextCell->pOwnerSection)
                {
                // ... mark the next free cell as the first free cell for that section
                pCurrentCell->pOwnerSection->pFirstFreeCell = pNextCell;
                }
            else
                {
                // ... the current section has no more free cells
                pCurrentCell->pOwnerSection->pFirstFreeCell = NULL;
                ASSERT(pCurrentCell->pOwnerSection->NumberOfUsedCells + 1
                    == GetSectionCapacity(pCurrentCell->pOwnerSection));
                }
            }
        else
            {
            // ... the current section has no more free cells
            pCurrentCell->pOwnerSection->pFirstFreeCell = NULL;
            ASSERT(pCurrentCell->pOwnerSection->NumberOfUsedCells + 1 
                == GetSectionCapacity(pCurrentCell->pOwnerSection));
            }
        pCurrentCell->pOwnerSection->NumberOfUsedCells ++;
        }

    pCurrentCell->Type = dctUsedGeneric;

    ASSERT_VALID(this);

    CellHeapMutex.Clear();

    *pCellTag = pCurrentCell->pOwnerSection->SectionID;
    return pCurrentCell;
}

void CellHeap::FreeCell(IN void *cell, IN OUT CellTag *pCellTag)
{
    CellSection *pSection;
    DebugFreeCell *pFreeCell;
    LIST_ENTRY *pCurrentEntry;
    CellSection *pCurrentSection;
    CellSection *pCachedSection;
    CellSection *pPrevSection, *pNextSection;
    BOOL fFreeCurrentSection;
    DebugFreeCell *pFirstCell, *pLastCell;
    DWORD SectionNumbers[2];

    // guard against double frees
    ASSERT(*pCellTag != -1);

    CellHeapMutex.Request();

    ASSERT_VALID(this);

    pSection = CellHeapSections.Find(*pCellTag);
    // make sure the cell is indeed from that section
    ASSERT((unsigned char *)cell >= (unsigned char *)pSection);
    ASSERT((unsigned char *)cell < ((unsigned char *)pSection) + gPageSize * pSection->LastCommittedPage);
    ASSERT(pSection->NumberOfUsedCells > 0);
    pFreeCell = (DebugFreeCell *) cell;

    // push on the list for the section the cell is from
    if (pSection->pFirstFreeCell)
        {
        InsertHeadList(pSection->pFirstFreeCell->FreeCellsChain.Blink, &pFreeCell->FreeCellsChain);
        // the pSection->pFirstFreeCell will be updated below
        }
    else
        {
        // find the place in the free list this goes to
        // the way we do this is walk the rest of the sections list 
        // and try to insert it before the first section we find
        // if we don't find anything, we insert it in the list tail
        pCurrentEntry = pSection->SectionListEntry.Flink;
        while (pCurrentEntry != &SectionsList)
            {
            pCurrentSection = CONTAINING_RECORD(pCurrentEntry, CellSection, SectionListEntry);
            if (pCurrentSection->pFirstFreeCell)
                {
                // we have found our place - use it
                InsertHeadList(pCurrentSection->pFirstFreeCell->FreeCellsChain.Blink, &pFreeCell->FreeCellsChain);
                // the pSection->pFirstFreeCell will be updated below
                break;
                }
            pCurrentEntry = pCurrentEntry->Flink;
            }

        // did we pass through everything?
        if (pCurrentEntry == &SectionsList)
            {
            // if yes, just insert in the tail
            InsertTailList(&FreeCellsList, &pFreeCell->FreeCellsChain);
            // the pSection->pFirstFreeCell will be updated below
            }
        }
    pSection->pFirstFreeCell = pFreeCell;
    pSection->NumberOfUsedCells --;
    pFreeCell->Type = dctFree;
    pFreeCell->pOwnerSection = pSection;

    if ((pSection->NumberOfUsedCells == 0) && (pSection != pFirstSection))
        {
        // unlink this section's segment from the cell free list
        pFirstCell = pFreeCell;

        // find the next section that has something on
        // the free list
        pCurrentEntry = pSection->SectionListEntry.Flink;
        while (pCurrentEntry != &SectionsList)
            {
            pCurrentSection = CONTAINING_RECORD(pCurrentEntry, CellSection, SectionListEntry);
            if (pCurrentSection->pFirstFreeCell)
                {
                pLastCell = CONTAINING_RECORD(pCurrentSection->pFirstFreeCell->FreeCellsChain.Blink, DebugFreeCell, FreeCellsChain);
                ASSERT(pLastCell->pOwnerSection == pSection);
                break;
                }
            pCurrentEntry = pCurrentEntry->Flink;
            }

        // if we didn't find anything, we're the last segment on the free list
        if (pCurrentEntry == &SectionsList)
            {
            pLastCell = CONTAINING_RECORD(FreeCellsList.Blink, DebugFreeCell, FreeCellsChain);
            pFirstCell->FreeCellsChain.Blink->Flink = &FreeCellsList;
            FreeCellsList.Blink = pFirstCell->FreeCellsChain.Blink;
            }
        else
            {
            pFirstCell->FreeCellsChain.Blink->Flink = pLastCell->FreeCellsChain.Flink;
            pLastCell->FreeCellsChain.Flink->Blink = pFirstCell->FreeCellsChain.Blink;
            }

        // chain the cells within the segment
        pFirstCell->FreeCellsChain.Blink = &pLastCell->FreeCellsChain;
        pLastCell->FreeCellsChain.Flink = NULL;

        // remove the section from the dictionary
        CellHeapSections.Delete(pSection->SectionID);
        pSection->SectionID = -1;

        // restore the name chain
        ASSERT(pSection->SectionListEntry.Blink != &SectionsList);
        pPrevSection 
            = CONTAINING_RECORD(pSection->SectionListEntry.Blink, CellSection, SectionListEntry);
        SectionNumbers[0] = pPrevSection->NextSectionId[0];
        SectionNumbers[1] = pPrevSection->NextSectionId[1];
        pPrevSection->NextSectionId[0] = pSection->NextSectionId[0];
        pPrevSection->NextSectionId[1] = pSection->NextSectionId[1];
        pSection->NextSectionId[0] = SectionNumbers[0];
        pSection->NextSectionId[1] = SectionNumbers[1];

        // unlink the chain from the sections list
        RemoveEntryList(&pSection->SectionListEntry);

        fFreeCurrentSection = TRUE;
        }
    else
        {
        fFreeCurrentSection = FALSE;
        }

    if (pSection->NumberOfUsedCells <= 100)
        {
        // the low water mark has been reached - dispose of the cached section
        pCachedSection = pCachedCellSection;

        // if we are freeing the current section, put it as the cached section
        // instead
        if (fFreeCurrentSection)
            {
            pCachedCellSection = pSection;
            }

        if (pCachedSection != NULL)
            {
            if (!fFreeCurrentSection)
                {
                pCachedCellSection = NULL;
                }

            // the first section should not go away
            ASSERT(pCachedSection != pFirstSection);

            ASSERT_VALID(this);
            // do the unmapping outside the mutex since it's slow
            CellHeapMutex.Clear();
            pCachedSection->Free();
            goto FreeCellCleanup;
            }
        }

    ASSERT_VALID(this);

    CellHeapMutex.Clear();

FreeCellCleanup:
    *pCellTag = -1;
}

void CellHeap::RelocateCellIfPossible(IN OUT void **ppCell, IN OUT CellTag *pCellTag)
{
    DebugFreeCell *pNewCell;
    CellTag NewCellTag;

    // if we are not on the first section and there are free cells
    // on the first section ...
    if ((*pCellTag != 0) && pFirstSection->pFirstFreeCell)
        {
        CellHeapMutex.Request();
        if (pFirstSection->pFirstFreeCell == NULL)
            {
            // somebody beat us to it
            CellHeapMutex.Clear();
            return;
            }

        pNewCell = AllocateCell(&NewCellTag);
        // this should succeed - we are doing it in a mutex, and we checked
        // that there are free elements
        ASSERT(pNewCell);
        // we can release the mutex now
        CellHeapMutex.Clear();

        memcpy(pNewCell, *ppCell, sizeof(DebugFreeCell));
        FreeCell(*ppCell, pCellTag);
        *pCellTag = NewCellTag;
        *ppCell = pNewCell;
        }
}

RPC_STATUS CellHeap::SectionCreatedNotify(IN CellSection *pCellSection, IN DWORD *pRandomNumbers,
    IN DebugFreeCell *pFirstCell OPTIONAL, IN DebugFreeCell *pLastCell OPTIONAL)
{
    int Key;
    CellSection *pLastSection;
    PVOID pLastSectionListEntry;
    LIST_ENTRY *EX_Blink;

    CellHeapMutex.Request();
    Key = CellHeapSections.Insert(pCellSection);
    if (Key == -1)
        {
        CellHeapMutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }

    pCellSection->SectionID = (short) Key;
    pLastSectionListEntry = SectionsList.Blink;
    // if there is last section, chain the names
    if (pLastSectionListEntry != &SectionsList)
        {
        pLastSection = (CellSection *)(CONTAINING_RECORD(pLastSectionListEntry, CellSection, SectionListEntry));
        ASSERT(pLastSection->NextSectionId[0] == 0);
        ASSERT(pLastSection->NextSectionId[1] == 0);
        pLastSection->NextSectionId[0] = pRandomNumbers[0];
        pLastSection->NextSectionId[1] = pRandomNumbers[1];
        }
    InsertTailList(&SectionsList, &(pCellSection->SectionListEntry));

    if (pFirstCell == NULL)
        {
        ASSERT(pLastCell == NULL);
        pFirstCell = (DebugFreeCell *)(pCellSection + 1);
        pLastCell = (DebugFreeCell *)((unsigned char *)pCellSection + gPageSize - sizeof(DebugFreeCell));
        }

    // chain the cells in the section to the free list
    InsertNewPageSegmentInChain(pFirstCell, pLastCell);

    CellHeapMutex.Clear();
    return RPC_S_OK;
}

RPC_STATUS CellHeap::InitializeServerSideCellHeap(void)
{
    RPC_STATUS Status = RPC_S_OK;

    CellHeapMutex.Request();
    if (g_fServerSideCellHeapInitialized)
        {
        CellHeapMutex.Clear();
        return RPC_S_OK;
        }
    // there is no race free way to create a first section - do
    // it in the mutex
    Status = AllocateCellSection(
        TRUE    // First Section
        );

    if (Status == RPC_S_OK)
        {
        g_fServerSideCellHeapInitialized = TRUE;
        }
    CellHeapMutex.Clear();
    return Status;
}

#if DBG
void CellHeap::AssertValid(void)
{
    CellSection *pSection, *pPrevSection, *pNextSection;
    CellSection *pPrevSection2;
    DebugFreeCell *pCurrentCell = NULL;
    LIST_ENTRY *pCurrentEntry, *pPrevEntry;
    LIST_ENTRY *pPrevFreeEntry;
    RPC_STATUS Status;
    HANDLE hSection;
    PVOID pMappedSection;
    int SectionsInDictionary;
    int LocalSectionFreeCellsCount;

    CellHeapMutex.VerifyOwned();

    ASSERT(IsValidSecurityDescriptor(SecurityDescriptor));

    // there must be at least one section
    ASSERT(!IsListEmpty(&SectionsList));

    pCurrentEntry = SectionsList.Flink;
    pSection = CONTAINING_RECORD(pCurrentEntry, CellSection, SectionListEntry);
    ASSERT(pSection == pFirstSection);

    SectionsInDictionary = CellHeapSections.Size();

    pPrevSection = NULL;
    pPrevEntry = &SectionsList;
    pPrevFreeEntry = &FreeCellsList;
    while (pCurrentEntry != &SectionsList)
        {
        pSection = CONTAINING_RECORD(pCurrentEntry, CellSection, SectionListEntry);

        ASSERT(pCurrentEntry->Blink == pPrevEntry);
        if (pPrevSection)
            {
            // make sure opening the next section from the previous section
            // yields this section
            Status = OpenSection(&hSection, &pMappedSection, pPrevSection->NextSectionId);
            // it is possible for this operation to fail
            // handle just the success case
            if (Status == RPC_S_OK)
                {
                pNextSection = (CellSection *)pMappedSection;
                ASSERT(pNextSection->SectionID == pSection->SectionID);
                CloseDbgSection(hSection, pNextSection);
                }
            }
        pSection->AssertValid(this);

        SectionsInDictionary --;

        // walk the free list pointers and make sure the free list is correct
        // we do this only if this section has something in the list
        if (pSection->pFirstFreeCell)
            {
            // there is previous section to verify only if we're not at the beginning
            if (pPrevFreeEntry != &FreeCellsList)
                {
                pCurrentCell = CONTAINING_RECORD(pPrevFreeEntry, DebugFreeCell, FreeCellsChain);
                pPrevSection2 = pCurrentCell->pOwnerSection;

                LocalSectionFreeCellsCount = 1;
                }
            else
                {
                pPrevSection2 = NULL;
                }

            // there must be at least one element difference
            // between the previous and this - that is, two
            // sections cannot point to the same cell as their 
            // first free cell
            pPrevFreeEntry = pPrevFreeEntry->Flink;
            while (pPrevFreeEntry != &pSection->pFirstFreeCell->FreeCellsChain)
                {
                // make sure we don't wrap around
                ASSERT (pPrevFreeEntry != &FreeCellsList);
                pCurrentCell = CONTAINING_RECORD(pPrevFreeEntry, DebugFreeCell, FreeCellsChain);
                if (pPrevSection2)
                    {
                    // make sure all cells from the segment belong to the same section
                    ASSERT(pCurrentCell->pOwnerSection == pPrevSection2);
                    LocalSectionFreeCellsCount ++;
                    }
                ASSERT(pPrevFreeEntry->Flink->Blink == pPrevFreeEntry);
                pPrevFreeEntry = pPrevFreeEntry->Flink;
                }
            if (pPrevSection2)
                {
                ASSERT(LocalSectionFreeCellsCount 
                    == GetSectionCapacity(pPrevSection2) - pPrevSection2->NumberOfUsedCells)
                }
            }

        pPrevSection = pSection;
        pPrevEntry = pCurrentEntry;
        pCurrentEntry = pCurrentEntry->Flink;
        }

    // we have iterated through all the sections
    // check the free list for the last section
    // but don't do it if none of the sections had free cells
    if (pPrevFreeEntry != &FreeCellsList)
        {
        pCurrentCell = CONTAINING_RECORD(pPrevFreeEntry, DebugFreeCell, FreeCellsChain);
        pPrevSection2 = pCurrentCell->pOwnerSection;

        LocalSectionFreeCellsCount = 1;

        // there must be at least one element difference
        // between the previous and this - that is, two
        // sections cannot point to the same cell as their 
        // first free cell
        pPrevFreeEntry = pPrevFreeEntry->Flink;
        while (pPrevFreeEntry != &FreeCellsList)
            {
            pCurrentCell = CONTAINING_RECORD(pPrevFreeEntry, DebugFreeCell, FreeCellsChain);
            // make sure all cells from the segment belong to the same section
            ASSERT(pCurrentCell->pOwnerSection == pPrevSection2);
            LocalSectionFreeCellsCount ++;
            ASSERT(pPrevFreeEntry->Flink->Blink == pPrevFreeEntry);
            pPrevFreeEntry = pPrevFreeEntry->Flink;
            }
        ASSERT(LocalSectionFreeCellsCount 
            == GetSectionCapacity(pPrevSection2) - pPrevSection2->NumberOfUsedCells)
        }

    // do some final checks
    // we have wrapped around to the beginning of the list
    ASSERT(pPrevFreeEntry == &FreeCellsList);

    // all of the sections in the list must have been in the dictionary also
    ASSERT(SectionsInDictionary == 0);

    // the names list must be properly terminated
    ASSERT(pSection->NextSectionId[0] == 0);
    ASSERT(pSection->NextSectionId[1] == 0);

    // verify the cached section (if any)
    if (pCachedCellSection)
        {
        pCachedCellSection->AssertValid(this);
        Status = OpenSection(&hSection, &pMappedSection, pCachedCellSection->NextSectionId);
        if (Status == RPC_S_OK)
            {
            pNextSection = (CellSection *)pMappedSection;
            ASSERT(pCachedCellSection->NextSectionId[0] == pNextSection->NextSectionId[0]);
            ASSERT(pCachedCellSection->NextSectionId[1] == pNextSection->NextSectionId[1]);
            CloseDbgSection(hSection, pMappedSection);
            }
        // walk the free list for the cached section and make sure
        // it is linked properly
        ASSERT(pCachedCellSection->pFirstFreeCell);
        pCurrentEntry = &pCachedCellSection->pFirstFreeCell->FreeCellsChain;
        while(pCurrentEntry->Flink != NULL)
            {
            pCurrentEntry = pCurrentEntry->Flink;
            }
        // pCurrentEntry should be the last cell here
        ASSERT(pCachedCellSection->pFirstFreeCell->FreeCellsChain.Blink == pCurrentEntry);
        }
}
#endif

RPC_STATUS CellHeap::CreateSecurityDescriptor(void)
{
    DWORD size = 4 * sizeof(ACCESS_ALLOWED_ACE) + sizeof(LocalSystem) + sizeof(Admin1) ;
    BOOL bRes;
    
    SecurityDescriptor = new SECURITY_DESCRIPTOR;
    if (SecurityDescriptor == NULL)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    PACL pdacl = (PACL) new unsigned char[size + sizeof(ACL)];
    ULONG ldacl = size + sizeof(ACL);

    if (pdacl == NULL)
        {
        delete SecurityDescriptor;
        SecurityDescriptor = NULL;
        return RPC_S_OUT_OF_MEMORY;
        }

    ASSERT(RtlValidSid((PSID)&LocalSystem));
    ASSERT(RtlValidSid((PSID)&Admin1));
//    ASSERT(RtlValidSid((PSID)&Admin2));
//    ASSERT(RtlValidSid((PSID)&Admin3));

    InitializeSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);

    InitializeAcl(pdacl, ldacl, ACL_REVISION);

    // this should not fail unless we messed up with the parameters
    // somewhere
    bRes = AddAccessAllowedAce(pdacl, ACL_REVISION,
                             FILE_MAP_READ,
                             (PVOID)&LocalSystem);
    ASSERT(bRes);

    bRes = AddAccessAllowedAce(pdacl, ACL_REVISION,
                             FILE_MAP_READ,
                             (PVOID)&Admin1);
    ASSERT(bRes);

    /*
    bRes = AddAccessAllowedAce(pdacl, ACL_REVISION,
                             FILE_MAP_READ,
                             (PVOID)&Admin2);
    ASSERT(bRes);

    bRes = AddAccessAllowedAce(pdacl, ACL_REVISION,
                             FILE_MAP_READ,
                             (PVOID)&Admin3);
    ASSERT(bRes);
    */

    bRes = SetSecurityDescriptorDacl(SecurityDescriptor, TRUE, pdacl, FALSE);
    ASSERT(bRes);

    ASSERT(IsValidSecurityDescriptor(SecurityDescriptor));

    return RPC_S_OK;
}

void CellHeap::InsertNewPageSegmentInChain(DebugFreeCell *pFirstCell, DebugFreeCell *pLastCell)
{
    LIST_ENTRY *EX_Blink;

    CellHeapMutex.VerifyOwned();

    // chain the cells in the section to the free list
    ASSERT(pFirstCell->FreeCellsChain.Blink == NULL);
    ASSERT(pLastCell->FreeCellsChain.Flink == NULL);

    // create the links from the list to the new segment
    EX_Blink = FreeCellsList.Blink;
    FreeCellsList.Blink = &(pLastCell->FreeCellsChain);
    EX_Blink->Flink = &(pFirstCell->FreeCellsChain);

    // create the links from the new segment to the list
    pFirstCell->FreeCellsChain.Blink = EX_Blink;
    pLastCell->FreeCellsChain.Flink = &FreeCellsList;
}

RPC_STATUS CellHeap::AllocateCellSection(BOOL fFirstSection)
{
    RPC_STATUS Status;

    CellSection::AllocateCellSection(&Status, fFirstSection, SecurityDescriptor, this);

    if (fFirstSection && (Status == RPC_S_OK))
        {
        pFirstSection = CONTAINING_RECORD(SectionsList.Flink, CellSection, SectionListEntry);
        }

    return Status;
}

#if DBG
RPC_STATUS CellHeap::OpenSection(OUT HANDLE *pHandle, OUT PVOID *pSection, IN DWORD *pSectionNumbers)
{
    return OpenDbgSection(pHandle, pSection, GetCurrentProcessId(), pSectionNumbers);
}
#endif

RPC_STATUS InitializeCellHeap(void)
{
    RPC_STATUS Status = RPC_S_OK;

    if (g_pCellHeap == NULL)
        {
        g_pCellHeap = new CellHeap(&Status);
        if (g_pCellHeap == NULL)
            Status = RPC_S_OUT_OF_MEMORY;
        else if (Status != RPC_S_OK)
            {
            delete g_pCellHeap;
            g_pCellHeap = NULL;
            }
        }

    return Status;
}

C_ASSERT(sizeof(DebugCallInfo) <= 32);
C_ASSERT(sizeof(DebugConnectionInfo) <= 32);
C_ASSERT(sizeof(DebugThreadInfo) <= 32);
C_ASSERT(sizeof(DebugEndpointInfo) <= 32);
C_ASSERT(sizeof(DebugClientCallInfo) <= 32);
C_ASSERT(sizeof(DebugCallTargetInfo) <= 32);
C_ASSERT(sizeof(DebugFreeCell) <= 32);
C_ASSERT(sizeof(DebugCellUnion) <= 32);

// uncomment this for cell heap unit tests
// #define CELL_HEAP_UNIT_TESTS

// cell heap unit tests
#ifdef CELL_HEAP_UNIT_TESTS
typedef struct tagCellTestSectionState
{
    int CommitedPages;
    int UsedCellsInSection;
} CellTestSectionState;

typedef struct tagCellTestBase
{
    int NumberOfSections;
    BOOL fCachedSectionPresent;
    int LastCommand;
    DWORD LastCommandParams[2];
    CellTestSectionState sectionsState[1];
} CellTestBase;

class TestCellAllocation
{
public:
    int NumberOfCells;
    DebugFreeCell **ppCellArray;
    CellTag *pTagsArray;
    void Free(void);
};

void TestCellAllocation::Free(void)
{
    int i;
    for (i = 0; i < NumberOfCells; i ++)
        {
        FreeCell(&(*ppCellArray[i]), &(pTagsArray[i]));
        }

    delete ppCellArray;
    delete pTagsArray;
}

typedef DebugFreeCell *DebugFreeCellPtr;

NEW_SDICT(TestCellAllocation);

class TestState
{
public:
    TestCellAllocation_DICT Allocations;
    void Free(int Allocation)
    {
        TestCellAllocation *pAllocation;

        pAllocation = Allocations.Find(Allocation);
        ASSERT(pAllocation != NULL);

        pAllocation->Free();
        Allocations.Delete(Allocation);
        delete pAllocation;
    }

    void Allocate(int NumberOfCells)
    {
        int i;
        TestCellAllocation *pTestAllocation;

        pTestAllocation = new TestCellAllocation;
        ASSERT(pTestAllocation);

        pTestAllocation->NumberOfCells = NumberOfCells;
        pTestAllocation->ppCellArray = new DebugFreeCellPtr[NumberOfCells];
        ASSERT(pTestAllocation->ppCellArray);
        pTestAllocation->pTagsArray = new CellTag[NumberOfCells];
        ASSERT(pTestAllocation->pTagsArray);

        for (i = 0; i < NumberOfCells; i ++)
            {
            pTestAllocation->ppCellArray[i] = AllocateCell(&pTestAllocation->pTagsArray[i]);
            ASSERT(pTestAllocation->ppCellArray[i] != NULL);
            }
        i = Allocations.Insert(pTestAllocation);
        ASSERT(i != -1);
    }
};

typedef enum tagCellHeapTestActions
{
    chtaFree,
    chtaAllocate,
    chtaFreeAll
} CellHeapTestActions;
#endif

void RPC_ENTRY I_RpcDoCellUnitTest(IN OUT void *p)
{
#ifdef CELL_HEAP_UNIT_TESTS
    const int NumberOfIterations = 383 * 3;
    const int NumberOfCellsPerSection = 383;
    DebugFreeCell *Cells[NumberOfIterations];
    CellTag Tags[NumberOfIterations];
    int i, j;
    CellTestBase *pTestBase = *(CellTestBase **)p;
    static TestState *pTestState = NULL;
    DWORD RandomNumbers[2];
    int NumberOfItemsToAllocate;
    int ItemToFree;
    RPC_STATUS RpcStatus;
    CellHeapTestActions ActionChosen;
    TestCellAllocation *pCurrentAllocation;
    int DictCursor;
    BOOL fFound;
    CellSection *pCellSection;
    DWORD LastCommandParams[2];
    ULONG Command;
//    ServerEnumerationHandle *hServers = (HANDLE *)p;

//    StartServerEnumeration(hServers);
    CellEnumerationHandle h;


    Command = (ULONG)pTestBase;
    if ((Command < 0xFFFF) && (Command != 0))
        {
        RpcStatus = OpenRPCServerDebugInfo(Command, &h);
        if (RpcStatus == RPC_S_OK)
            {
            CloseRPCServerDebugInfo(&h);
            }
        else
            {
            ASSERT(0);
            }
        return;
        }

    // Cell heap unit tests
    // if there are old test results, delete them
    if (pTestBase)
        delete pTestBase;

    if (pTestState == NULL)
        {
        pTestState = new TestState;
        }

    RpcStatus = GenerateRandomNumber((unsigned char *)RandomNumbers, 8);
    ASSERT(RpcStatus == RPC_S_OK);

    // is there something to free?
    if (pTestState->Allocations.Size() == 0)
        {
        ActionChosen = chtaAllocate;
        NumberOfItemsToAllocate = RandomNumbers[1] % 5 + 1;
        }
    else
        {
        // we can do it both ways - check the random number to figure out which
        if ((RandomNumbers[0] % 2777) == 0)
            {
            // once in a great while, free everything
            ActionChosen = chtaFreeAll;
            }
        else if ((RandomNumbers[0] % 100) > 48)
            {
            // allocations have a slight edge
            ActionChosen = chtaAllocate;
            NumberOfItemsToAllocate = RandomNumbers[1] % 5 + 1;
            }
        else
            {
            ActionChosen = chtaFree;
            ItemToFree = RandomNumbers[1] % pTestState->Allocations.Size();
            }
        }

    switch (ActionChosen)
        {
        case chtaFreeAll:
            pTestState->Allocations.Reset(DictCursor);
            while ((pCurrentAllocation = pTestState->Allocations.Next(DictCursor)) != NULL)
                {
                pTestState->Free(DictCursor - 1);
                }
            break;

        case chtaAllocate:
            pTestState->Allocate(NumberOfItemsToAllocate);
            LastCommandParams[0] = NumberOfItemsToAllocate;
            break;

        case chtaFree:
            i = 0;
            fFound = FALSE;
            pTestState->Allocations.Reset(DictCursor);
            while ((pCurrentAllocation = pTestState->Allocations.Next(DictCursor)) != NULL)
                {
                if (ItemToFree == i)
                    {
                    LastCommandParams[0] = pCurrentAllocation->NumberOfCells;
                    LastCommandParams[1] = DictCursor - 1;
                    pTestState->Free(DictCursor - 1);
                    fFound = TRUE;
                    break;
                    }
                i ++;
                }
            ASSERT(fFound == TRUE);
            break;
        }

    // build the state
    pTestBase = (CellTestBase *) new unsigned char [sizeof(CellTestBase) 
        + sizeof(CellTestSectionState) * (g_pCellHeap->CellHeapSections.Size() - 1)];
    ASSERT(pTestBase);
    pTestBase->LastCommand = ActionChosen;
    pTestBase->LastCommandParams[0] = LastCommandParams[0];
    pTestBase->LastCommandParams[1] = LastCommandParams[1];

    pTestBase->NumberOfSections = g_pCellHeap->CellHeapSections.Size();
    pTestBase->fCachedSectionPresent = (pCachedCellSection != NULL);
    i = 0;
    g_pCellHeap->CellHeapSections.Reset(DictCursor);
    while ((pCellSection = g_pCellHeap->CellHeapSections.Next(DictCursor)) != NULL)
        {
        pTestBase->sectionsState[i].CommitedPages = pCellSection->LastCommittedPage;
        pTestBase->sectionsState[i].UsedCellsInSection = pCellSection->NumberOfUsedCells;
        i ++;
        }
    *(CellTestBase **)p = pTestBase;

    /*
    for (j = 0; j < 2; j ++)
        {
        // do the allocations
        for (i = 0; i < NumberOfCellsPerSection; i ++)
            {
            Cells[i] = AllocateCell(&Tags[i]);
            }
        for (i = NumberOfCellsPerSection; i < NumberOfCellsPerSection * 2; i ++)
            {
            Cells[i] = AllocateCell(&Tags[i]);
            }
        for (i = NumberOfCellsPerSection * 2; i < NumberOfCellsPerSection * 3; i ++)
            {
            Cells[i] = AllocateCell(&Tags[i]);
            }

        // do the freeing
        for (i = NumberOfCellsPerSection; i < NumberOfCellsPerSection * 2; i ++)
            {
            FreeCell(Cells[i], &Tags[i]);
            }
        for (i = 0; i < NumberOfCellsPerSection; i ++)
            {
            FreeCell(Cells[i], &Tags[i]);
            }
        for (i = NumberOfCellsPerSection * 2; i < NumberOfCellsPerSection * 3; i ++)
            {
            FreeCell(Cells[i], &Tags[i]);
            }
        }
        */
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dbgcomn.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    DbgComn.h

Abstract:

    Some definitions included from too many places,
    including some pure C files.

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#ifndef __DBGCOMN_HXX__
#define __DBGCOMN_HXX__

#define RpcSectionPrefix  (L"\\RPC Control\\DSEC")
#define RpcSectionPrefixSize 17
// 3*8 is the max hex representation of three DWORDS. The constant
// below is in characters including the terminating NULL.
#define RpcSectionNameMaxSize   (RpcSectionPrefixSize + 3*8 + 1)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\clntapip.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       clntapip.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File : clntapip.cxx

Description :

This file contains the private entry points into the client (and
server) runtime.

History :

mikemon    02-02-91    Created.

-------------------------------------------------------------------- */

#include <precomp.hxx>

#ifdef DOS
THREAD ThreadStatic;
#endif

void PAPI * RPC_ENTRY
I_RpcAllocate (
    IN unsigned int size
    )
{
#ifdef RPC_DELAYED_INITIALIZATION

    if ( RpcHasBeenInitialized == 0 )
        {
        if ( PerformRpcInitialization() != RPC_S_OK )
            {
            return(0);
            }
        }

#endif // RPC_DELAYED_INITIALIZATION

    return(RpcpFarAllocate(size));
}

void RPC_ENTRY
I_RpcFree (
    IN void PAPI * obj
    )
{
    RpcpFarFree(obj);
}

void PAPI * RPC_ENTRY
I_RpcBCacheAllocate (
    IN unsigned int size
    )
{
    if (!ThreadSelf())
        return NULL;
    return(RpcAllocateBuffer(size));
}

void RPC_ENTRY
I_RpcBCacheFree (
    IN void PAPI * obj
    )
{
    RpcFreeBuffer(obj);
}

RPC_STATUS 
I_RpcSetNDRSlot(
    IN void *NewSlot
    )
{
    return RpcpSetNDRSlot(NewSlot);
}

void *
I_RpcGetNDRSlot(
    void
    )
{
    return RpcpGetNDRSlot();
}

void RPC_ENTRY
I_RpcPauseExecution (
    IN unsigned long milliseconds
    )
{
    PauseExecution(milliseconds);
}

const ULONG FatalExceptions[] = 
    {
    STATUS_ACCESS_VIOLATION,
    STATUS_POSSIBLE_DEADLOCK,
    STATUS_INSTRUCTION_MISALIGNMENT,
    STATUS_DATATYPE_MISALIGNMENT,
    STATUS_PRIVILEGED_INSTRUCTION,
    STATUS_ILLEGAL_INSTRUCTION,
    STATUS_BREAKPOINT,
    STATUS_STACK_OVERFLOW,
    STATUS_HANDLE_NOT_CLOSABLE,
    STATUS_IN_PAGE_ERROR
    };

const int FATAL_EXCEPTIONS_ARRAY_SIZE = sizeof(FatalExceptions) / sizeof(FatalExceptions[0]);

int 
RPC_ENTRY
I_RpcExceptionFilter (
    unsigned long ExceptionCode
    )
{
    int i;

    for (i = 0; i < FATAL_EXCEPTIONS_ARRAY_SIZE; i ++)
        {
        if (ExceptionCode == FatalExceptions[i])
            return EXCEPTION_CONTINUE_SEARCH;
        }

    return EXCEPTION_EXECUTE_HANDLER;
}

#ifdef STATS
DWORD g_dwStat1 = 0;
DWORD g_dwStat2 = 0;
DWORD g_dwStat3 = 0;
DWORD g_dwStat4 = 0;

void RPC_ENTRY I_RpcGetStats(DWORD *pdwStat1, DWORD *pdwStat2, DWORD *pdwStat3, DWORD *pdwStat4)
{
    GetStats(pdwStat1, pdwStat2, pdwStat3, pdwStat4);
}
#endif

extern "C"
{
void RPC_ENTRY
I_RpcTimeReset(
    void
    )
/*++

Routine Description:

    This routine is no longer used, however, because it is exported by the
    dll, we need to leave the entry point.

--*/
{

}

void RPC_ENTRY
I_RpcTimeCharge(
    unsigned int Ignore
    )
/*++

Routine Description:

    This routine is no longer used, however, because it is exported by the
    dll, we need to leave the entry point.

--*/
{
    UNUSED(Ignore);
}

unsigned long * RPC_ENTRY
I_RpcTimeGet(
    char __RPC_FAR * Ignore
    )
/*++

Routine Description:

    This routine is no longer used, however, because it is exported by the
    dll, we need to leave the entry point.

--*/
{
    UNUSED(Ignore);

    return(0);
}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dcebind.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    dcebind.cxx

Abstract:

    This module contains the code implementing the Binding Object DCE RPC
    runtime APIs.  APIs which are used only by server applications do not
    live here.

Author:

    Michael Montague (mikemon) 25-Sep-1991

Revision History:

--*/

#include <precomp.hxx>
#include <rpccfg.h>
#include <CharConv.hxx>


RPC_STATUS RPC_ENTRY
RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE PAPI * DestinationBinding
    )
/*++

Routine Description:

    This routine copies binding information and creates a new binding
    handle.

Arguments:

    SourceBinding - Supplies the binding to be duplicated.

    DestinationBinding - Returns a new binding which is a duplicate of
        SourceBinding.

Return Value:

    The status for the operation is returned.

--*/
{
    MESSAGE_OBJECT * Binding;
    THREAD *Thread;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (Thread == NULL)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    Binding = (MESSAGE_OBJECT *) SourceBinding;
    if (Binding->InvalidHandle(BINDING_HANDLE_TYPE))
        {
        return NDRCCopyContextHandle(SourceBinding, DestinationBinding);
        }

    return(Binding->BindingCopy((BINDING_HANDLE *PAPI *) DestinationBinding, 0));
}


RPC_STATUS RPC_ENTRY
I_RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE PAPI * DestinationBinding
    )
/*++

Routine Description:

    This routine copies binding information and creates a new binding
    handle.  In addition, context is being maintained by the server over
    this binding handle.

Arguments:

    SourceBinding - Supplies the binding to be duplicated.

    DestinationBinding - Returns a new binding which is a duplicate of
        SourceBinding.

Return Value:

    The status for the operation is returned.

--*/
{
    MESSAGE_OBJECT * Binding;

    InitializeIfNecessary();

    Binding = (MESSAGE_OBJECT *) SourceBinding;
    if (Binding->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(Binding->BindingCopy((BINDING_HANDLE * PAPI *) DestinationBinding, 1));
}


RPC_STATUS RPC_ENTRY
RpcBindingFree (
    IN OUT RPC_BINDING_HANDLE PAPI * Binding
    )
/*++

Routine Description :

    RpcBindingFree releases binding handle resources.

Arguments:

    Binding - Supplies the binding handle to be freed, and returns zero.

Return Value:

    The status of the operation is returned.

--*/
{
    BINDING_HANDLE * BindingHandle;
    RPC_STATUS Status;

    // if we're shutting down, don't bother
    // Since our other threads have been nuked, data structures may
    // be in half modified state. Therefore it is unsafe to proceed
    // with freeing the binding handle during shutdown
    if (RtlDllShutdownInProgress())
        {
        *Binding = 0;
        return RPC_S_OK;
        }

    InitializeIfNecessary();

    // here it will be more efficient if we succeed, but other code will manage fine
    // even if we don't, so we don't really care about return value
    ThreadSelf();

    ASSERT(!RpcpCheckHeap());

    BindingHandle = (BINDING_HANDLE *) *Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    Status = BindingHandle->BindingFree();
    *Binding = 0;

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcBindingReset (
    IN RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This routine sets the endpoint in the supplied binding handle to
    zero.  This makes the binding handle a partiallly bound binding
    handle.  NOTE: this routine will fail if the binding handle has
    already been used to make remote procedure calls.  Based on how
    this routine will be used (to iterate through the entries in the
    endpoint mapper database), this should not be a problem.

Arguments:

    Binding - Supplies the binding handle for which the endpoint will
        be set to zero, hence making it a partially bound binding handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - The supplied argument is not a valid binding.

    RPC_S_WRONG_KIND_OF_BINDING - Either the supplied binding is not a
        client binding handle or it is a client binding handle which has
        already been used to make remote procedure calls.

--*/
{
    BINDING_HANDLE * BindingHandle;
    THREAD *Thread;

    Thread = ThreadSelf();
    if (Thread == NULL)
        return RPC_S_OUT_OF_MEMORY;

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(BindingHandle->BindingReset());
}


RPC_STATUS RPC_ENTRY
RpcBindingFromStringBinding (
    IN unsigned short PAPI * StringBinding,
    OUT RPC_BINDING_HANDLE PAPI * Binding
    )
/*++

Routine Description:

    This routine returns a binding handle from a string representation
    of a binding handle.

Arguments:

    StringBinding - Supplies the string representation of a binding handle.

    Binding - Returns a binding handle constructed from the string
        representation.

Return Value:

    The status of the operation is returned.

--*/
{
    DCE_BINDING * DceBinding;
    RPC_STATUS Status;
    BINDING_HANDLE * BindingHandle;
    RPC_CHAR __RPC_FAR * CopiedStringBinding;
    THREAD *Thread;

    InitializeIfNecessary();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    *Binding = 0;

    CopiedStringBinding = (RPC_CHAR *)
              _alloca( (RpcpStringLength(StringBinding)+1)*(sizeof(RPC_CHAR)) );
    if (CopiedStringBinding == 0)
        {
        return (RPC_S_OUT_OF_MEMORY);
        }
    RpcpStringCopy(CopiedStringBinding, StringBinding);

    DceBinding = new DCE_BINDING(CopiedStringBinding, &Status);
    if (DceBinding == 0)
        Status = RPC_S_OUT_OF_MEMORY;

    if (Status == RPC_S_OK)
        {
        BindingHandle = DceBinding->CreateBindingHandle(&Status);
        if (Status == RPC_S_OK)
            *Binding = BindingHandle;
        //
        // DceBinding gets deleted by the callee, if the above call fails
        //
        }
    else
        {
        delete DceBinding;
        }

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcBindingSetObject (
    IN RPC_BINDING_HANDLE Binding,
    IN UUID PAPI * ObjectUuid
    )
/*++

Routine Description:

    This routine sets the object UUID value in a binding handle.

Arguments:

    Binding - Supplies the binding handle for which the object UUID is
        to be set.

    ObjectUuid - Supplies the UUID value to put into the binding handle.

Return Values:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - The binding argument does not specify a binding
        handle.

    RPC_S_WRONG_KIND_OF_BINDING - The binding argument does specify a
        binding handle, but it is not a client binding handle (ie. one
        owned by the client side rpc runtime).

--*/
{
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    BindingHandle->SetObjectUuid((RPC_UUID PAPI *) ObjectUuid);

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcBindingVectorFree (
    IN OUT RPC_BINDING_VECTOR PAPI * PAPI * BindingVector
    )
/*++

Routine Description:

    This routine frees the binding handles contained in the vector, and
    the vector itself.

Arguments:

    BindingVector - Supplies a vector of binding handles which will be
        freed.  On return, the pointer to the binding vector will be
        set to zero.

Return Value:

    The status of the operation will be returned.

--*/
{
    unsigned int Index, Count;
    RPC_BINDING_VECTOR PAPI * Vector;
    RPC_STATUS Status;

    InitializeIfNecessary();

    for (Index = 0, Vector = *BindingVector,
            Count = (unsigned int) Vector->Count;
            Index < Count; Index++)
        if (Vector->BindingH[Index] != 0)
            {
            Status = RpcBindingFree(&(Vector->BindingH[Index]));
            if (Status != RPC_S_OK)
                return(Status);
            }
    RpcpFarFree(*BindingVector);
    *BindingVector = 0;

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcEpResolveBinding (
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_IF_HANDLE IfSpec
    )
/*++

Routine Description:

    This routine is used to resolve a partially-bound binding handle
    into a fully-bound binding handle.  A partially-bound binding
    handle is one in which the endpoint is not specified.  To make
    the binding handle fully-bound, we need to determine the endpoint.

Arguments:

    Binding - Supplies a partially-bound binding handle to resolve into
        a fully bound one.  Specifying a fully-bound binding handle to
        this routine is not an error; it has no effect on the binding
        handle.

    IfSpec - Supplies a handle to the description of the interface for
        which we wish to resolve the endpoint.  This information will
        be used to find the correct server on the machine specified by
        the network address in the binding handle.

Return Value:

    RPC_S_OK - The binding handle is now fully-bound.

    RPC_S_NO_ENDPOINT_FOUND - We were unable to resolve the endpoint
        for this particular combination of binding handle (network address)
        and interface.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to resolve
        the endpoint.

    RPC_S_INVALID_BINDING - The binding argument does not specify a binding
        handle.

    RPC_S_WRONG_KIND_OF_BINDING - The binding argument does specify a
        binding handle, but it is not a client binding handle (ie. one
        owned by the client side rpc runtime).

--*/
{
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(BindingHandle->ResolveBinding((PRPC_CLIENT_INTERFACE) IfSpec));
}

RPC_STATUS RPC_ENTRY
RpcNsBindingInqEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned short PAPI * PAPI * EntryName
    )
/*++

Routine Description:

Arguments:

Return Value:

    RPC_S_OK - The entry name for the binding handle has been successfully
        inquired and returned.

    RPC_S_INVALID_BINDING - The binding argument does not specify a binding
        handle.

    RPC_S_WRONG_KIND_OF_BINDING - The binding argument does specify a
        binding handle, but it is not a client binding handle (ie. one
        owned by the client side rpc runtime).

--*/
{
#if !defined(NO_LOCATOR_CODE)
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    if (gfRPCVerifierEnabledWithBreaks)
        {
        // Locator is an unsafe feature to use.  We should flag it in the verifier.
        RPC_VERIFIER_WARNING_MSG("Possible security threat: Client is using the locator name service",
                                 RPC_VERIFIER_UNSAFE_FEATURE);
        RPC_VERIFIER_PRINT_OFFENDING_STACK(1, 4);
        }

    return(BindingHandle->InquireEntryName(EntryNameSyntax, EntryName));
#else
    return RPC_S_CANNOT_SUPPORT;
#endif
}

RPC_STATUS RPC_ENTRY
THUNK_FN(I_RpcNsBindingSetEntryName) (
    IN RPC_BINDING_HANDLE,
    IN unsigned long,
    IN unsigned char *
    )
{
    return RPC_S_CANNOT_SUPPORT;
}


RPC_STATUS RPC_ENTRY
I_RpcNsBindingSetEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned short PAPI * EntryName
    )
/*++

Routine Description:

    This routine is a private entry point for use by name service support
    dlls; it allows them to set the entry name in a binding handle
    before returning it from import or lookup.  If an entry name already
    exists in the binding handle, we just go ahead and overwrite the
    old one with new one.

Arguments:

    Binding - Supplies the binding handle for which we want to set the
        entry name.

    EntryNameSyntax - Supplies the syntax used by the entry name.  We need
        to save this information for when the entry name is inquired.

    EntryName - Supplies the entry name for this binding handle.

Return Value:

    RPC_S_OK - The entry name has been successfully set for the binding
        handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_INVALID_BINDING - The binding argument does not specify a binding
        handle.

    RPC_S_WRONG_KIND_OF_BINDING - The binding argument does specify a
        binding handle, but it is not a client binding handle (ie. one
        owned by the client side rpc runtime).

--*/
{
#if !defined(NO_LOCATOR_CODE)
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    if (gfRPCVerifierEnabledWithBreaks)
        {
        // Locator is an unsafe feature to use.  We should flag it in the verifier.
        RPC_VERIFIER_WARNING_MSG("Possible security threat: Client is using the locator name service",
                                 RPC_VERIFIER_UNSAFE_FEATURE);
        RPC_VERIFIER_PRINT_OFFENDING_STACK(1, 4);
        }

    return(BindingHandle->SetEntryName(EntryNameSyntax, EntryName));
#else
    return RPC_S_CANNOT_SUPPORT;
#endif
}

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short PAPI * PAPI * ServerPrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE PAPI * AuthIdentity, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc OPTIONAL
    )
/*++

Routine Description:

    This routine is used to return the authentication and authorization for
    a binding handle.  You should also see RpcBindingSetAuthInfoW.

Arguments:

    Binding - Supplies the binding handle for which we wish to query the
        authentication and authorization information.

    ServerPrincName - Optionally returns the server principal name set for
        the binding handle.

    AuthnLevel - Optionally returns the authentication level set for the
        binding handle.

    AuthnSvc - Optionally returns the authentication service set for the
        binding handle.

    AuthIdentity - Optionally returns a handle to the security context
        being used for authentication and authorization.

    AuthzSvc -  Optionally returns the authorization service set for the
        binding handle.

Return Value:

    RPC_S_OK - We successfully returned the information requested.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_INVALID_BINDING - The value supplied as the binding argument is
        not a valid binding handle.

    RPC_S_WRONG_KIND_OF_BINDING - A binding handle on the client side must
        be specified as the binding argument.

    RPC_S_BINDING_HAS_NO_AUTH - RpcBindingInqAuthInfo has not yet been
        called on the binding handle, so there is not authentication or
        authorization to be returned.

--*/
{
    BINDING_HANDLE * BindingObject;
    CLIENT_AUTH_INFO * ClientAuthInfo;

    InitializeIfNecessary();

    return( RpcBindingInqAuthInfoEx(
                  Binding,
                  ServerPrincName,
                  AuthnLevel,
                  AuthnSvc,
                  AuthIdentity,
                  AuthzSvc,
                  0,
                  0
                  ) );

}


RPC_STATUS RPC_ENTRY
RpcBindingInqAuthInfoEx (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short PAPI * PAPI * ServerPrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE PAPI * AuthIdentity, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc, OPTIONAL
    IN  unsigned long RpcSecurityQosVersion,
    OUT RPC_SECURITY_QOS * SecurityQos
    )
/*++

Routine Description:

    This routine is used to return the authentication and authorization for
    a binding handle.  You should also see RpcBindingSetAuthInfoW.

Arguments:

    Binding - Supplies the binding handle for which we wish to query the
        authentication and authorization information.

    ServerPrincName - Optionally returns the server principal name set for
        the binding handle.

    AuthnLevel - Optionally returns the authentication level set for the
        binding handle.

    AuthnSvc - Optionally returns the authentication service set for the
        binding handle.

    AuthIdentity - Optionally returns a handle to the security context
        being used for authentication and authorization.

    AuthzSvc -  Optionally returns the authorization service set for the
        binding handle.

    RpcSecurityQosVersion - Indicates a version for RPC_SECURITY_QOS structure,
        that optionally can be inquired. If SecurityQOS passes in is 0, this
        is ignored.

    SecurityQOS - is the version of the Security Quality Of Service


Return Value:

    RPC_S_OK - We successfully returned the information requested.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_INVALID_BINDING - The value supplied as the binding argument is
        not a valid binding handle.

    RPC_S_WRONG_KIND_OF_BINDING - A binding handle on the client side must
        be specified as the binding argument.

    RPC_S_BINDING_HAS_NO_AUTH - RpcBindingInqAuthInfo has not yet been
        called on the binding handle, so there is not authentication or
        authorization to be returned.

--*/
{
    BINDING_HANDLE * BindingObject;
    CLIENT_AUTH_INFO * ClientAuthInfo;

    InitializeIfNecessary();

    BindingObject = (BINDING_HANDLE *) Binding;
    if ( BindingObject->InvalidHandle(BINDING_HANDLE_TYPE) )
        {
        return(RPC_S_INVALID_BINDING);
        }

    ClientAuthInfo = BindingObject->InquireAuthInformation();
    if ( ClientAuthInfo == 0
         || ClientAuthInfo->AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE)
        {
        return(RPC_S_BINDING_HAS_NO_AUTH);
        }

    if (ARGUMENT_PRESENT(AuthnLevel))
        {
        *AuthnLevel = ClientAuthInfo->AuthenticationLevel;
        }
    if (ARGUMENT_PRESENT(AuthnSvc))
        {
        *AuthnSvc = ClientAuthInfo->AuthenticationService;
        }
    if (ARGUMENT_PRESENT(AuthIdentity))
        {
        *AuthIdentity = ClientAuthInfo->AuthIdentity;
        }
    if (ARGUMENT_PRESENT(AuthzSvc))
        {
        *AuthzSvc = ClientAuthInfo->AuthorizationService;
        }
    if (ARGUMENT_PRESENT(ServerPrincName))
        {
        if ( ClientAuthInfo->ServerPrincipalName == 0 )
            {
            *ServerPrincName = 0;
            }
        else
            {
            *ServerPrincName = DuplicateStringPAPI(
                    ClientAuthInfo->ServerPrincipalName);
            if ( *ServerPrincName == 0 )
                {
                return(RPC_S_OUT_OF_MEMORY);
                }
            }
        }
    if (ARGUMENT_PRESENT(SecurityQos))
        {
        if (RpcSecurityQosVersion != RPC_C_SECURITY_QOS_VERSION)
            {
            if (ARGUMENT_PRESENT(ServerPrincName))
                delete *ServerPrincName;
            return (RPC_S_INVALID_ARG);
            }
        SecurityQos->Version = RPC_C_SECURITY_QOS_VERSION;
        SecurityQos->Capabilities = ClientAuthInfo->Capabilities;
        SecurityQos->ImpersonationType = ClientAuthInfo->ImpersonationType;
        SecurityQos->IdentityTracking  = ClientAuthInfo->IdentityTracking;
        }
    return(RPC_S_OK);
}



RPC_STATUS RPC_ENTRY
RpcBindingSetAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned short PAPI * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    )
/*++

Routine Description:

    A client application will use this routine to specify the authentication
    and authorization information in a binding handle, so that the binding
    handle can be used to make authenticated remote procedure calls.  If
    the this routine is not used, then all remote procedure calls on the
    binding handle will be unauthenticated.

Arguments:

    Binding - Supplies binding handle for which we want to set authentication
        and authorization information.

    ServerPrincName - Supplies the expected principal name of the server
        referenced by the binding handle (that is supplied as the binding
        argument).  This information is necessary for some security services
        to be able to authenticate with the server.

    AuthnLevel - Supplies a value indicating the amount (or level) of
        authentication to be performed on remote procedure calls using
        the binding handle.  If we do not support the requested level,
        we will upgrade to the next highest supported level.

        RPC_C_AUTHN_LEVEL_DEFAULT - Indicates that the default level for
            authentication service being used should be used.

        RPC_C_AUTHN_LEVEL_NONE - Do not perform any authentication.

        RPC_C_AUTHN_LEVEL_CONNECT - Authentication will be performed only
            when the client first talks to the server.

        RPC_C_AUTHN_LEVEL_CALL - For connection based protocols, we will
            use RPC_C_AUTHN_LEVEL_PKT instead; for datagram based protocols,
            authentication will be performed at the beginning of each
            remote procedure call.

        RPC_C_AUTHN_LEVEL_PKT - All data will be authenticated to insure that
            the data it is received from the expected client.

        RPC_C_AUTHN_LEVEL_PKT_INTEGRITY - In addition, to authenticating that
            the data is from the expected client, we will verify that none
            of it has been modified.

        RPC_C_AUTHN_LEVEL_PKT_PRIVACY - Finally, this includes all of the
            support in packet integrity, as well as encrypting all remote
            procedure call data.

    AuthnSvc - Supplies the authentication service to use.

    AuthIdentify - Optionally supplies authentication and authorization
        credentials to use; if this argument is not specified, the security
        context for the current address space will be used.

    AuthzSvc - Supplies the authorization service being used by the
        server.  The client must know this so that the correct authorization
        information can be sent to the server.

Return Value:

    RPC_S_OK - The supplied authentication and authorization information has
        been set in the binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_INVALID_BINDING - The value supplied as the binding argument is
        not a valid binding handle.

    RPC_S_WRONG_KIND_OF_BINDING - A binding handle on the client side must
        be specified as the binding argument.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported.

    RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is
        not supported.

    RPC_S_INVALID_AUTH_IDENTITY - The specified security context (supplied
        by the auth identity argument) is invalid.

    RPC_S_UNKNOWN_AUTHZ_SERVICE - The specified authorization service is
        not supported.

--*/

{
   return (  RpcBindingSetAuthInfoEx(
                Binding,
                ServerPrincName,
                AuthnLevel,
                AuthnSvc,
                AuthIdentity,
                AuthzSvc,
                0 ) );
}


RPC_STATUS RPC_ENTRY
RpcBindingSetAuthInfoEx (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned short PAPI * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc,
    IN RPC_SECURITY_QOS *SecurityQOS
    )
/*++

Routine Description:

    A client application will use this routine to specify the authentication
    and authorization information in a binding handle, so that the binding
    handle can be used to make authenticated remote procedure calls.  If
    the this routine is not used, then all remote procedure calls on the
    binding handle will be unauthenticated.

Arguments:

    Binding - Supplies binding handle for which we want to set authentication
        and authorization information.

    ServerPrincName - Supplies the expected principal name of the server
        referenced by the binding handle (that is supplied as the binding
        argument).  This information is necessary for some security services
        to be able to authenticate with the server.

    AuthnLevel - Supplies a value indicating the amount (or level) of
        authentication to be performed on remote procedure calls using
        the binding handle.  If we do not support the requested level,
        we will upgrade to the next highest supported level.

        RPC_C_AUTHN_LEVEL_DEFAULT - Indicates that the default level for
            authentication service being used should be used.

        RPC_C_AUTHN_LEVEL_NONE - Do not perform any authentication.

        RPC_C_AUTHN_LEVEL_CONNECT - Authentication will be performed only
            when the client first talks to the server.

        RPC_C_AUTHN_LEVEL_CALL - For connection based protocols, we will
            use RPC_C_AUTHN_LEVEL_PKT instead; for datagram based protocols,
            authentication will be performed at the beginning of each
            remote procedure call.

        RPC_C_AUTHN_LEVEL_PKT - All data will be authenticated to insure that
            the data it is received from the expected client.

        RPC_C_AUTHN_LEVEL_PKT_INTEGRITY - In addition, to authenticating that
            the data is from the expected client, we will verify that none
            of it has been modified.

        RPC_C_AUTHN_LEVEL_PKT_PRIVACY - Finally, this includes all of the
            support in packet integrity, as well as encrypting all remote
            procedure call data.

    AuthnSvc - Supplies the authentication service to use.

    AuthIdentify - Optionally supplies authentication and authorization
        credentials to use; if this argument is not specified, the security
        context for the current address space will be used.

    AuthzSvc - Supplies the authorization service being used by the
        server.  The client must know this so that the correct authorization
        information can be sent to the server.

    SecurityQOS - a security QOS stucture. Currently accepting RPC_C_SECURITY_QOS_VERSION_2
        and RPC_C_SECURITY_QOS_VERSION_1

Return Value:

    RPC_S_OK - The supplied authentication and authorization information has
        been set in the binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_INVALID_BINDING - The value supplied as the binding argument is
        not a valid binding handle.

    RPC_S_WRONG_KIND_OF_BINDING - A binding handle on the client side must
        be specified as the binding argument.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported.

    RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is
        not supported.

    RPC_S_INVALID_AUTH_IDENTITY - The specified security context (supplied
        by the auth identity argument) is invalid.

    RPC_S_UNKNOWN_AUTHZ_SERVICE - The specified authorization service is
        not supported.

--*/
{
    BINDING_HANDLE * BindingObject;
    RPC_STATUS Status;
    RPC_CHAR __RPC_FAR * ServerName;
    unsigned long ImpersonationType;
    unsigned long IdentityTracking;
    unsigned long Capabilities;
    void *AdditionalCredentials;
    ULONG AdditionalTransportCredentialsType;
    THREAD *Thread;
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
    unsigned int i;
    PSID Sid;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    BindingObject = (BINDING_HANDLE *) Binding;

    if ((SecurityQOS != 0) &&
        ( (SecurityQOS->Version < RPC_C_SECURITY_QOS_VERSION_1) ||
          (SecurityQOS->Version > RPC_C_SECURITY_QOS_VERSION_3) ) )
        {
        return(RPC_S_INVALID_ARG);
        }

    if ( BindingObject->InvalidHandle(BINDING_HANDLE_TYPE) )
        {
        return(RPC_S_INVALID_BINDING);
        }

    //
    // For no authentication, bail out now.
    //

    if (AuthnSvc == RPC_C_AUTHN_NONE)
        {
        if ((AuthnLevel != RPC_C_AUTHN_LEVEL_NONE) &&
            (AuthnLevel != RPC_C_AUTHN_LEVEL_DEFAULT))
            {
            return(RPC_S_UNKNOWN_AUTHN_LEVEL);
            }

        // fall through - we will set all defaults
        }

    if (AuthnSvc == RPC_C_AUTHN_DEFAULT)
        {
        RpcpGetDefaultSecurityProviderInfo();
        AuthnSvc = DefaultProviderId;
        }

    if (AuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        {
        if (AuthnLevel < RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
            {
            AuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
            }
        }

    Sid = NULL;

    if (SecurityQOS != 0)
        {
        IdentityTracking = SecurityQOS->IdentityTracking;
        ImpersonationType= SecurityQOS->ImpersonationType;
        Capabilities     = SecurityQOS->Capabilities;

        // if we were given the hint for lightweight local MA,
        // we must have been told to use MA in the first place
        if (Capabilities & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT)
            {
            if ((Capabilities & RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH) == 0)
                return RPC_S_INVALID_ARG;

            // doesn't work for datagrams
            if (((BINDING_HANDLE *)Binding)->InvalidHandle(DG_BINDING_HANDLE_TYPE) == FALSE)
                return RPC_S_INVALID_ARG;
            }

        // by the condition above, we know we can't have the local MA hint only -
        // if we have local MA hint, we must have full MA also. Thus we can check
        // for full MA only and effectively address both
        if (Capabilities & RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH)
            {
            // if we were asked for full MA, either SID of SPN must be supplied
            if (((ServerPrincName == NULL)
                 ||
                 (ServerPrincName[0] == '\0') )
                && 
                (
                 (SecurityQOS->Version < RPC_C_SECURITY_QOS_VERSION_3)
                 ||
                 (((RPC_SECURITY_QOS_V3 *)SecurityQOS)->Sid == NULL)
                )
               )
                {
#if DBG
                DbgPrint("RPCRT4: %X: Rejecting invalid arguments to RpcBindingSetAuthInfoEx\n",
                    GetCurrentProcessId());
#endif
                return RPC_S_INVALID_ARG;
                }
            }


        if (SecurityQOS->Version == RPC_C_SECURITY_QOS_VERSION_1)
            {
            AdditionalTransportCredentialsType = 0;
            AdditionalCredentials = NULL;
            }
        else
            {
            AdditionalTransportCredentialsType = ((RPC_SECURITY_QOS_V2 *)SecurityQOS)->AdditionalSecurityInfoType;
            AdditionalCredentials = ((RPC_SECURITY_QOS_V2 *)SecurityQOS)->u.HttpCredentials;

            if (AdditionalTransportCredentialsType != RPC_C_AUTHN_INFO_TYPE_HTTP)
                {
                if (AdditionalTransportCredentialsType != 0)
                    return(RPC_S_INVALID_ARG);

                if (AdditionalCredentials != NULL)
                    return(RPC_S_INVALID_ARG);
                }
            else if (AdditionalCredentials == NULL)
                return(RPC_S_INVALID_ARG);
            else
                {
                HttpCredentials = (RPC_HTTP_TRANSPORT_CREDENTIALS_W *)AdditionalCredentials;

                if (HttpCredentials->TransportCredentials)
                    {
                    if (HttpCredentials->TransportCredentials->User)
                        {
                        if (RpcpStringLength(HttpCredentials->TransportCredentials->User) 
                            != HttpCredentials->TransportCredentials->UserLength)
                            {
                            return(RPC_S_INVALID_ARG);
                            }
                        }
                    else if (HttpCredentials->TransportCredentials->UserLength)
                        return(RPC_S_INVALID_ARG);

                    if (HttpCredentials->TransportCredentials->Domain)
                        {
                        if (RpcpStringLength(HttpCredentials->TransportCredentials->Domain) 
                            != HttpCredentials->TransportCredentials->DomainLength)
                            {
                            return(RPC_S_INVALID_ARG);
                            }
                        }
                    else if (HttpCredentials->TransportCredentials->DomainLength)
                        return(RPC_S_INVALID_ARG);

                    if (HttpCredentials->TransportCredentials->Password)
                        {
                        if (RpcpStringLength(HttpCredentials->TransportCredentials->Password) 
                            != HttpCredentials->TransportCredentials->PasswordLength)
                            {
                            return(RPC_S_INVALID_ARG);
                            }
                        }
                    else if (HttpCredentials->TransportCredentials->PasswordLength)
                        return(RPC_S_INVALID_ARG);

                    if (HttpCredentials->TransportCredentials->Flags != SEC_WINNT_AUTH_IDENTITY_UNICODE)
                        return(RPC_S_INVALID_ARG);
                    }

                // if you don't want to authenticate against anyone, you can't authenticate
                if (HttpCredentials->AuthenticationTarget == 0)
                    return(RPC_S_INVALID_ARG);

                // if you don't support any method of authentication, you can't authenticate
                if (HttpCredentials->NumberOfAuthnSchemes == 0)
                    return(RPC_S_INVALID_ARG);

                // if you don't support any method of authentication, you can't authenticate
                if (HttpCredentials->AuthnSchemes == NULL)
                    return(RPC_S_INVALID_ARG);

                // check whether Negotiate, Passport or Digest are in the list of auth scehemes. If yes,
                // reject the call since we don't support them yet.
                for (i = 0; i < HttpCredentials->NumberOfAuthnSchemes; i ++)
                    {
                    if (HttpCredentials->AuthnSchemes[i] == RPC_C_HTTP_AUTHN_SCHEME_PASSPORT)
                        return RPC_S_CANNOT_SUPPORT;
                    if (HttpCredentials->AuthnSchemes[i] == RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE)
                        return RPC_S_CANNOT_SUPPORT;
                    if (HttpCredentials->AuthnSchemes[i] == RPC_C_HTTP_AUTHN_SCHEME_DIGEST)
                        return RPC_S_CANNOT_SUPPORT;
                    }
                }

            if (SecurityQOS->Version == RPC_C_SECURITY_QOS_VERSION_3)
                {
                // doesn't work for datagrams
                if ((((BINDING_HANDLE *)Binding)->InvalidHandle(DG_BINDING_HANDLE_TYPE) == FALSE)
                    && ((RPC_SECURITY_QOS_V3 *)SecurityQOS)->Sid)
                    return RPC_S_INVALID_ARG;

                Sid = ((RPC_SECURITY_QOS_V3 *)SecurityQOS)->Sid;
                }
            }
        }
    else
        {
        IdentityTracking   = RPC_C_QOS_IDENTITY_STATIC;
        ImpersonationType  = RPC_C_IMP_LEVEL_IMPERSONATE;
        Capabilities       = RPC_C_QOS_CAPABILITIES_DEFAULT;
        AdditionalTransportCredentialsType = 0;
        AdditionalCredentials = NULL;
        }

    if (AuthnSvc == RPC_C_AUTHN_NONE)
        {
        Status = BindingObject->SetAuthInformation(
                                          ServerPrincName,
                                          AuthnLevel,
                                          AuthnSvc,
                                          AuthIdentity,
                                          AuthzSvc,
                                          0,
                                          ImpersonationType,
                                          IdentityTracking,
                                          Capabilities,
                                          FALSE,  // Acquire new credentials
                                          AdditionalTransportCredentialsType,
                                          AdditionalCredentials,
                                          Sid
                                          );
        }
    else
        {
        Status = BindingObject->SetAuthInformation(
                                          ServerPrincName,
                                          AuthnLevel,
                                          AuthnSvc,
                                          AuthIdentity,
                                          AuthzSvc,
                                          0,
                                          ImpersonationType,
                                          IdentityTracking,
                                          Capabilities,
                                          TRUE,  // Acquire new credentials
                                          AdditionalTransportCredentialsType,
                                          AdditionalCredentials,
                                          Sid
                                          );
        }

   return (Status);
}


RPC_STATUS RPC_ENTRY
I_RpcBindingInqSecurityContext (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **SecurityContextHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

    The status for the operation is returned.

--*/
{
    CALL * Call;

    InitializeIfNecessary();

    Call = (CALL *) Binding;

    if (Call->InvalidHandle(CALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(Call->InqSecurityContext(SecurityContextHandle));
}

RPC_STATUS RPC_ENTRY
I_RpcTurnOnEEInfoPropagation (
    void
    )
/*++

Routine Description:
    Turns on extended error info propagation for this process.

Arguments:


Return Value:

    RPC_S_OK.

--*/
{
    g_fSendEEInfo = TRUE;

    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dcecmisc.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    dcecmisc.cxx


Abstract:

    This module contains the code implementing miscellaneous DCE RPC
    runtime APIs.  In particular, this includes the following APIs:
    RpcIfInqId, RpcNetworkIsProtseqValid, RpcMgmtInqComTimeout,
    RpcMgmtSetComTimeout, RpcMgmtSetCancelTimeout, and DceErrorInqText.

Author:

    Michael Montague (mikemon) 11-Nov-1991

Revision History:

--*/

#include <precomp.hxx>

#if !defined(_M_IA64)
unsigned long RecvWindow = 0;
unsigned long SendWindow = 0;
#endif

RPC_STATUS RPC_ENTRY
RpcIfInqId (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_IF_ID PAPI * RpcIfId
    )
/*++

Routine Description:

    The routine is used by an application to obtain the interface
    identification part of an interface specification.  This is a really
    simple API since the RpcIfHandle points to the interface information,
    so all we have got to do is cast RpcIfHandle and copy some stuff.

Arguments:

    RpcIfHandle - Supplies a handle to the interface specification.

    RpcIfId - Returns the interface identification part of the interface
        specification.

Return Value:

    RPC_S_OK - The operation completed successfully.

--*/
{
    RPC_CLIENT_INTERFACE PAPI * RpcInterfaceInformation;

    InitializeIfNecessary();

    RpcInterfaceInformation = (RPC_CLIENT_INTERFACE PAPI *) RpcIfHandle;
    RpcpMemoryCopy(&(RpcIfId->Uuid),
            &(RpcInterfaceInformation->InterfaceId.SyntaxGUID),sizeof(UUID));
    RpcIfId->VersMajor =
            RpcInterfaceInformation->InterfaceId.SyntaxVersion.MajorVersion;
    RpcIfId->VersMinor =
            RpcInterfaceInformation->InterfaceId.SyntaxVersion.MinorVersion;
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcNetworkIsProtseqValid (
    IN unsigned short PAPI * Protseq
    )
/*++

Routine Description:

    An application program will use this API to determine if an rpc
    protocol sequence is supported by the current system.

Arguments:

    Protseq - Supplies an rpc protocol sequence to be check to see if
        it is supported.

Return Value:

    RPC_S_OK - The specified rpc protocol sequence is support.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The specified rpc protocol sequence
        is not supported (but it appears to be valid).

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        invalid.

--*/
{
    InitializeIfNecessary();

    return(IsRpcProtocolSequenceSupported(Protseq));
}


RPC_STATUS RPC_ENTRY
RpcMgmtInqComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int PAPI * Timeout
    )
/*++

Routine Description:

    This routine is used to obtain the communications timeout from a
    binding handle.

Arguments:

    Binding - Supplies a binding handle from which to inquire the
        communication timeout.

    Timeout - Returns the communications timeout in the binding handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - The specified binding is not a client side
        binding handle.
--*/
{
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    *Timeout = BindingHandle->InqComTimeout();
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcMgmtSetComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned int Timeout
    )
/*++

Routine Description:

    An application will use this routine to set the communications
    timeout for a binding handle.  The timeout value specifies the
    relative amount of time that should be spent to establish a binding
    to the server before giving up.

Arguments:

    Binding - Supplies the binding handle for which the communications
        timeout value will be set.

    Timeout - Supplies the communications timeout value to set in the
        binding handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - The specified binding is not a client side
        binding handle.

    RPC_S_INVALID_TIMEOUT - The specified timeout value is invalid.

--*/
{
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(BindingHandle->SetComTimeout(Timeout));
}


RPC_STATUS RPC_ENTRY
I_RpcIfInqTransferSyntaxes (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_TRANSFER_SYNTAX PAPI * TransferSyntaxes,
    IN unsigned int TransferSyntaxSize,
    OUT unsigned int PAPI * TransferSyntaxCount
    )
/*++

Routine Description:

    This routine will be used to obtain the transfer syntaxes support
    by an interface.  A description of the interface is supplied via
    the interface handle.

Arguments:

    RpcIfHandle - Supplies a reference to the interface from which we
        want to inquire the transfer syntaxes.

    TransferSyntaxes - Returns a copy of the transfer syntaxes support
        by the interface.

    TransferSyntaxSize - Supplies the number of RPC_TRANSFER_SYNTAX records
        which can fit in the transfer syntaxes buffer.

    TransferSyntaxCount - Returns the number of transfer syntaxes supported
        by the interface.  This value will always be returned, whether or
        not an error occurs.

Return Value:

    RPC_S_OK - We copied the transfer syntaxes into the buffer successfully.

    RPC_S_BUFFER_TOO_SMALL - The supplies transfer syntaxes buffer is too
        small; the transfer syntax count parameter will return the minimum
        size required.

--*/
{
    RPC_CLIENT_INTERFACE PAPI * RpcInterfaceInformation;

    *TransferSyntaxCount = 1;
    if (TransferSyntaxSize < 1)
        return(RPC_S_BUFFER_TOO_SMALL);

    RpcInterfaceInformation = (RPC_CLIENT_INTERFACE PAPI *) RpcIfHandle;
    RpcpMemoryCopy(&(TransferSyntaxes->Uuid),
            &(RpcInterfaceInformation->TransferSyntax.SyntaxGUID),
            sizeof(UUID));
    TransferSyntaxes->VersMajor =
        RpcInterfaceInformation->TransferSyntax.SyntaxVersion.MajorVersion;
    TransferSyntaxes->VersMinor =
        RpcInterfaceInformation->TransferSyntax.SyntaxVersion.MinorVersion;

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcMgmtEnableIdleCleanup (
    void
    )
/*++

Routine Description:

    An application will use this routine to enable cleanup of idle resources.
    For the connection oriented protocol module, a connection must be idle
    for five minutes before it is cleaned up.

Return Value:

    RPC_S_OK - Cleanup of idle resources has been enabled.

    RPC_S_OUT_OF_THREADS - Insufficient threads are available to be able
        to perform this operation.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to be
        able to perform this operation.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to be able to
        perform this operation.

--*/
{
    InitializeIfNecessary();

    return(EnableIdleConnectionCleanup());
}


RPC_STATUS RPC_ENTRY
DceErrorInqTextA (
    IN RPC_STATUS RpcStatus,
    OUT unsigned char __RPC_FAR * ErrorText
    )
/*++

Routine Description:

    The supplied status code is converted into a text message if possible.

Arguments:

    RpcStatus - Supplies the status code to convert.

    ErrorText - Returns a character string containing the text message
        for the status code.

Return Value:

    RPC_S_OK - The supplied status codes has successfully been converted
        into a text message.

    RPC_S_INVALID_ARG - The supplied value is not a valid status code.

--*/
{
    if ( FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS
            | FORMAT_MESSAGE_FROM_SYSTEM, 0, RpcStatus, 0, (char *)ErrorText,
            DCE_C_ERROR_STRING_LEN, 0) == 0 )
        {
          if ( FormatMessageA( FORMAT_MESSAGE_IGNORE_INSERTS |
                   FORMAT_MESSAGE_FROM_SYSTEM, 0, RPC_S_NOT_RPC_ERROR,
                   0, (char *)ErrorText, DCE_C_ERROR_STRING_LEN,  0 ) == 0 )
              {
              *ErrorText = '\0';
              return(RPC_S_INVALID_ARG);
              }
        }

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
DceErrorInqTextW (
    IN RPC_STATUS RpcStatus,
    OUT unsigned short __RPC_FAR * ErrorText
    )
/*++

Routine Description:

    The supplied status code is converted into a text message if possible.

Arguments:

    RpcStatus - Supplies the status code to convert.

    ErrorText - Returns a character string containing the text message
        for the status code.

Return Value:

    RPC_S_OK - The supplied status codes has successfully been converted
        into a text message.

    RPC_S_INVALID_ARG - The supplied value is not a valid status code.

--*/
{
    if ( FormatMessageW(FORMAT_MESSAGE_IGNORE_INSERTS
            | FORMAT_MESSAGE_FROM_SYSTEM, 0, RpcStatus, 0, ErrorText,
            DCE_C_ERROR_STRING_LEN * sizeof(RPC_CHAR), 0) == 0 )
        {
          if ( FormatMessageW( FORMAT_MESSAGE_IGNORE_INSERTS |
                FORMAT_MESSAGE_FROM_SYSTEM, 0, RPC_S_NOT_RPC_ERROR, 0,
                ErrorText, DCE_C_ERROR_STRING_LEN * sizeof(RPC_CHAR),0 ) == 0 )
              {
              *ErrorText = 0;
              return(RPC_S_INVALID_ARG);
              }
        }

    return(RPC_S_OK);
}


#if !defined(_M_IA64)
RPC_STATUS RPC_ENTRY
I_RpcConnectionInqSockBuffSize(
  OUT unsigned long __RPC_FAR * RecvBuffSize,
  OUT unsigned long __RPC_FAR * SendBuffSize
  )
{
    RequestGlobalMutex();

    *RecvBuffSize = RecvWindow;
    *SendBuffSize = SendWindow;

    ClearGlobalMutex();
    return (RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
I_RpcConnectionSetSockBuffSize(
   IN unsigned long RecvBuffSize,
   IN unsigned long SendBuffSize
   )
{
    if (RecvBuffSize > 0xFFFF)
        {
        RecvBuffSize = 0xFFFF;
        }
    if (SendBuffSize > 0xFFFF)
        {
        SendBuffSize = 0xFFFF;
        }
    RequestGlobalMutex();
    RecvWindow =  RecvBuffSize;
    SendWindow = SendBuffSize;
    ClearGlobalMutex();

    return (RPC_S_OK);
}


void RPC_ENTRY
I_RpcConnectionInqSockBuffSize2(
    OUT unsigned long __RPC_FAR * RecvWindowSize
    )
{
    *RecvWindowSize = RecvWindow;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dcecmmn.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    dcecmmn.cxx

Abstract:

    This module contains the code implementing the Binding Object DCE RPC
    runtime APIs which are common to both the client and server runtimes.
    Two different versions of each of the common APIs live in this file;
    one contains the code for both the client and server runtimes, the
    other contains the code for just the client runtime.  The files
    dcecsvr.cxx (client and server) and dcecclnt.cxx (client) include
    this file.  The client side only, dcecclnt.cxx, will define
    RPC_CLIENT_SIDE_ONLY.

Author:

    Michael Montague (mikemon) 04-Nov-1991

Revision History:

--*/

// This file is always included into file which include precomp.hxx

#include <precomp.hxx>
#include <rpcdce.h>
#ifndef RPC_CLIENT_SIDE_ONLY
#include <rpccfg.h>
#endif
#ifndef RPC_CLIENT_SIDE_ONLY
#include <hndlsvr.hxx>
#endif // RPC_CLIENT_SIDE_ONLY


RPC_STATUS RPC_ENTRY
RpcBindingInqObject (
    IN RPC_BINDING_HANDLE Binding,
    OUT UUID PAPI * ObjectUuid
    )
/*++

Routine Description:

    RpcBindingInqObject returns the object UUID from the binding handle.

Arguments:

    Binding - Supplies a binding handle from which the object UUID will
        be returned.

    ObjectUuid - Returns the object UUID contained in the binding handle.

Return Value:

    The status of the operation is returned.

--*/
{
    BINDING_HANDLE *BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;

#ifdef RPC_CLIENT_SIDE_ONLY

    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    BindingHandle->InquireObjectUuid((RPC_UUID PAPI *) ObjectUuid);

#else // ! RPC_CLIENT_SIDE_ONLY

    if ( BindingHandle == 0 )
        {
        BindingHandle = (BINDING_HANDLE *) RpcpGetThreadContext();
        if ( BindingHandle == 0 )
            {
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }

    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE | SCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    if (BindingHandle->Type(BINDING_HANDLE_TYPE))
        BindingHandle->InquireObjectUuid((RPC_UUID PAPI *) ObjectUuid);
    else
        ((SCALL *) BindingHandle)->InquireObjectUuid(
                (RPC_UUID PAPI *) ObjectUuid);

#endif // RPC_CLIENT_SIDE_ONLY

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcBindingToStringBinding (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short PAPI * PAPI * StringBinding
    )
/*++

Routine Description:

    RpcBindingToStringBinding returns a string representation of a binding
    handle.

Arguments:

    Binding - Supplies a binding handle for which the string representation
        will be returned.

    StringBinding - Returns the string representation of the binding handle.

Return Value:

    The status of the operation will be returned.
--*/
{
#ifdef RPC_CLIENT_SIDE_ONLY

    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(BindingHandle->ToStringBinding(StringBinding));

#else // RPC_CLIENT_SIDE_ONLY

    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (((GENERIC_OBJECT *) Binding)->InvalidHandle(BINDING_HANDLE_TYPE
            | SCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    if (((GENERIC_OBJECT *) Binding)->Type(BINDING_HANDLE_TYPE))
        return(((BINDING_HANDLE *) Binding)->ToStringBinding(
                        StringBinding));
    else
        return(((SCALL *) Binding)->ToStringBinding(StringBinding));

#endif // RPC_CLIENT_SIDE_ONLY
}


RPC_STATUS RPC_ENTRY
I_RpcBindingToStaticStringBindingW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short PAPI * PAPI * StringBinding
    )
/*++

Routine Description:

    RpcBindingToStringBinding returns a string representation of a binding
    handle.

Arguments:

    Binding - Supplies a binding handle for which the string representation
        will be returned.

    StringBinding - Returns the string representation of the binding handle.

Return Value:

    The status of the operation will be returned.
--*/
{
    RPC_STATUS Status;

    InitializeIfNecessary();

    if (((GENERIC_OBJECT *) Binding)->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    if (((GENERIC_OBJECT *) Binding)->InvalidHandle(SVR_BINDING_HANDLE_TYPE))
        {
        return (((BINDING_HANDLE *) Binding)->ToStringBinding(StringBinding));
        }

    return (((SVR_BINDING_HANDLE *) Binding)->ToStaticStringBinding(StringBinding));
}


RPC_STATUS RPC_ENTRY
RpcMgmtInqDefaultProtectLevel(
    IN  unsigned long AuthnSvc,
    OUT unsigned long PAPI *AuthnLevel
    )
/*++

Routine Description:

    Returns the default protect level for the specified authentication service.
    For Nt 3.5, all packaged except the DECs krb package must support
    connect level as their default.

Arguments:

   AuthnSvc - Specified Authentication Service

   AuthnLevel - Default protection level supported.


Return Value:

    RPC_S_OK - We successfully determined whether or not the client is
        local.

--*/

{

   RPC_CHAR DllName[255+1];
#ifndef RPC_CLIENT_SIDE_ONLY
   RPC_CHAR *Dll = &DllName[0];
#endif
   unsigned long Count;
   RPC_STATUS Status;

   InitializeIfNecessary();

#ifndef RPC_CLIENT_SIDE_ONLY
   Status = RpcGetSecurityProviderInfo(
                     AuthnSvc,
                     &Dll,
                     &Count);

   if (Status != RPC_S_OK)
      {

      ASSERT(Status == RPC_S_UNKNOWN_AUTHN_SERVICE);
      return (Status);

      }
#endif

   //Authn Service is installed

   if (AuthnSvc == RPC_C_AUTHN_DCE_PRIVATE)
      {
      *AuthnLevel = RPC_C_PROTECT_LEVEL_PKT_INTEGRITY;
      }
   else
      {
      *AuthnLevel = RPC_C_PROTECT_LEVEL_CONNECT;
      }

   return (RPC_S_OK);

}



RPC_STATUS RPC_ENTRY
RpcBindingSetOption( IN RPC_BINDING_HANDLE hBinding,
                     IN unsigned long      option,
                     IN ULONG_PTR          optionValue )
/*++

Routine Description:

  An RPC client calls this routine to set transport specific
  options for a binding handle.

Arguments:

  hBinding    - The binding handle in question. This must be of
                type BINDING_HANDLE_TYPE.
  option      - Which transport specific option to set.
  optionValue - The new value for the transport option.

Return Value: RPC_S_OK
              RPC_S_INVALID_BINDING
              RPC_S_CANNOT_SUPPORT
--*/
{
    RPC_STATUS Status;

    InitializeIfNecessary();

    if ((option == RPC_C_OPT_DONT_LINGER) && (optionValue == FALSE))
        return RPC_S_INVALID_ARG;

    if ( ((GENERIC_OBJECT*)hBinding)->InvalidHandle(BINDING_HANDLE_TYPE) )
        {
        Status = RpcSsGetContextBinding(hBinding, &hBinding);
        if (Status != RPC_S_OK)
            return RPC_S_INVALID_BINDING;

        return RpcBindingSetOption(hBinding, option, optionValue);
        }
    else
        return ((BINDING_HANDLE*)hBinding)->SetTransportOption(
                                           option,
                                           optionValue );
}



RPC_STATUS RPC_ENTRY
RpcBindingInqOption( IN  RPC_BINDING_HANDLE hBinding,
                     IN  unsigned long      option,
                     OUT ULONG_PTR         *pOptionValue )
/*++

Routine Description:

  An RPC client calls this routine to get the value of a
  transport specific option for a binding handle.

Arguments:

  hBinding    - The binding handle in question. This must be of
                type BINDING_HANDLE_TYPE.
  option      - Which transport specific option to set.
  pOptionValue- The current value for the transport option is
                returned here.

Return Value: RPC_S_OK
              RPC_S_INVALID_BINDING
              RPC_S_CANNOT_SUPPORT
--*/
{
    InitializeIfNecessary();

    if ( ((GENERIC_OBJECT*)hBinding)->InvalidHandle(BINDING_HANDLE_TYPE) )
        return RPC_S_INVALID_BINDING;
    else
        {
        if (option > RPC_C_OPT_MAX_OPTIONS)
            {
            return RPC_S_INVALID_ARG;
            }

        return ((BINDING_HANDLE*)hBinding)->InqTransportOption(
                                           option,
                                           pOptionValue );
        }
}



RPC_STATUS RPC_ENTRY
I_RpcBindingInqConnId (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **ConnId,
    OUT BOOL *pfFirstCall
    )
/*++

Routine Description:

    Used to get the connection id corresponding to the binding handle.

Arguments:

    Binding - Supplies the binding handle from which we wish to obtain
        the connection id.

    ConnId - If the call suceeds, *ConnId will contain the connection Id
    pfFirstCall - If the call succeeds,
                    *pfFirstCall - 1 - This is the first time
                                    - 0 - This is not the first time

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - When the argument is not a binding handle.

--*/

{
    BINDING_HANDLE * BindingHandle;

    BindingHandle = (BINDING_HANDLE *) Binding;

    if (BindingHandle->InvalidHandle(SCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    return ((SCALL *) Binding)->InqConnection(ConnId, pfFirstCall);
}


RPC_STATUS RPC_ENTRY
I_RpcBindingInqTransportType(
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Type
    )
/*++

Routine Description:

    Determines what kind of transport this binding handle uses.

Arguments:

    Binding - Supplies the binding handle from which we wish to obtain
        the information.


    Type - Points to the type of binding if the functions succeeds.
           One of:
           TRANSPORT_TYPE_CN
           TRANSPORT_TYPE_DG
           TRANSPORT_TYPE_LPC

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - When the argument is not a binding handle.

--*/
{
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;

#ifndef RPC_CLIENT_SIDE_ONLY
    if ( BindingHandle == 0 )
        {
        BindingHandle = (BINDING_HANDLE *) RpcpGetThreadContext();
        if ( BindingHandle == 0 )
            {
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }
#endif

    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE|SCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

#ifndef RPC_CLIENT_SIDE_ONLY
    if (BindingHandle->Type(SCALL_TYPE))
        {
        return(((SCALL *)BindingHandle)->InqTransportType(Type));
        }
    else
#endif
    return(BindingHandle->InquireTransportType(Type));
}


//
// Map of RPC (local system) error codes to well known NCA error codes
// so that the receiver can correctly convert these well known errors
// into system specific errors.
//
const long RpcToNcaMap[] =
    {
    RPC_S_UNKNOWN_IF,           NCA_STATUS_UNK_IF,
    RPC_S_NOT_LISTENING,        NCA_STATUS_SERVER_TOO_BUSY,
    RPC_S_SERVER_TOO_BUSY,      NCA_STATUS_SERVER_TOO_BUSY,
    RPC_S_PROTOCOL_ERROR,       NCA_STATUS_PROTO_ERROR,
    RPC_S_PROCNUM_OUT_OF_RANGE, NCA_STATUS_OP_RNG_ERROR,
    RPC_S_UNSUPPORTED_TYPE,     NCA_STATUS_UNSUPPORTED_TYPE,
    RPC_X_SS_CONTEXT_MISMATCH,  NCA_STATUS_CONTEXT_MISMATCH,
    RPC_X_INVALID_BOUND,        NCA_STATUS_INVALID_BOUND,
    RPC_X_SS_HANDLES_MISMATCH,  NCA_STATUS_CONTEXT_MISMATCH,
    RPC_S_INVALID_TAG,          NCA_STATUS_INVALID_TAG,
    RPC_S_OUT_OF_MEMORY,        NCA_STATUS_REMOTE_OUT_OF_MEMORY,
    RPC_S_CALL_FAILED_DNE,      NCA_STATUS_CALL_DNE,
    RPC_S_CALL_FAILED,          NCA_STATUS_FAULT_UNSPEC,
    RPC_S_CALL_CANCELLED,       NCA_STATUS_FAULT_CANCEL,
    RPC_S_COMM_FAILURE,         NCA_STATUS_COMM_FAILURE,
    RPC_X_PIPE_EMPTY,           NCA_STATUS_FAULT_PIPE_EMPTY,
    RPC_X_PIPE_CLOSED,          NCA_STATUS_FAULT_PIPE_CLOSED,
    RPC_X_WRONG_PIPE_ORDER,     NCA_STATUS_FAULT_PIPE_ORDER,
    RPC_X_PIPE_DISCIPLINE_ERROR,NCA_STATUS_FAULT_PIPE_DISCIPLINE,

    // Currently not used
    // NCA_STATUS_BAD_ACTID
    // NCA_STATUS_WHO_ARE_YOU_FAILED
    // NCA_STATUS_WRONG_BOOT_TIME
    // NCA_STATUS_YOU_CRASHED

    STATUS_INTEGER_DIVIDE_BY_ZERO,  NCA_STATUS_ZERO_DIVIDE,
    STATUS_FLOAT_DIVIDE_BY_ZERO,    NCA_STATUS_FP_DIV_ZERO,
    STATUS_FLOAT_UNDERFLOW,         NCA_STATUS_FP_UNDERFLOW,
    STATUS_FLOAT_OVERFLOW,          NCA_STATUS_FP_OVERFLOW,
    STATUS_FLOAT_INVALID_OPERATION, NCA_STATUS_FP_ERROR,
    STATUS_INTEGER_OVERFLOW,        NCA_STATUS_OVERFLOW,
        // Note: these exceptions are not caught by our code.
        // STATUS_ACCESS_VIOLATION,        NCA_STATUS_ADDRESS_ERROR,
        // STATUS_PRIVILEGED_INSTRUCTION,  NCA_STATUS_ILLEGAL_INSTRUCTION,
        // STATUS_ILLEGAL_INSTRUCTION,     NCA_STATUS_ILLEGAL_INSTRUCTION,

    };


//
// Map of NCA error codes to RPC (local system) error codes.  These
// errors usually arrive in fault packets and may have come from an
// NT, Mac or OSF machine.
//
const long NcaToRpcMap[] =
    {
    NCA_STATUS_COMM_FAILURE,            RPC_S_COMM_FAILURE,
    NCA_STATUS_OP_RNG_ERROR,            RPC_S_PROCNUM_OUT_OF_RANGE,
    NCA_STATUS_UNK_IF,                  RPC_S_UNKNOWN_IF,
    NCA_STATUS_PROTO_ERROR,             RPC_S_PROTOCOL_ERROR,
    NCA_STATUS_OUT_ARGS_TOO_BIG,        RPC_S_SERVER_OUT_OF_MEMORY,
    NCA_STATUS_REMOTE_OUT_OF_MEMORY,    RPC_S_SERVER_OUT_OF_MEMORY,
    NCA_STATUS_SERVER_TOO_BUSY,         RPC_S_SERVER_TOO_BUSY,
    NCA_STATUS_UNSUPPORTED_TYPE,        RPC_S_UNSUPPORTED_TYPE,
    NCA_STATUS_ILLEGAL_INSTRUCTION,     RPC_S_ADDRESS_ERROR,
    NCA_STATUS_ADDRESS_ERROR,           RPC_S_ADDRESS_ERROR,
    NCA_STATUS_OVERFLOW,                RPC_S_ADDRESS_ERROR,
    NCA_STATUS_ZERO_DIVIDE,             RPC_S_ZERO_DIVIDE,
    NCA_STATUS_FP_DIV_ZERO,             RPC_S_FP_DIV_ZERO,
    NCA_STATUS_FP_UNDERFLOW,            RPC_S_FP_UNDERFLOW,
    NCA_STATUS_FP_OVERFLOW,             RPC_S_FP_OVERFLOW,
    NCA_STATUS_FP_ERROR,                RPC_S_FP_OVERFLOW,
    NCA_STATUS_INVALID_TAG,             RPC_S_INVALID_TAG,
    NCA_STATUS_INVALID_BOUND,           RPC_S_INVALID_BOUND,
    NCA_STATUS_CONTEXT_MISMATCH,        RPC_X_SS_CONTEXT_MISMATCH,
    NCA_STATUS_FAULT_CANCEL,            RPC_S_CALL_CANCELLED,
    NCA_STATUS_WHO_ARE_YOU_FAILED,      RPC_S_CALL_FAILED,
    NCA_STATUS_YOU_CRASHED,             RPC_S_CALL_FAILED,
    NCA_STATUS_FAULT_UNSPEC,            RPC_S_CALL_FAILED,
    NCA_STATUS_VERSION_MISMATCH,        RPC_S_PROTOCOL_ERROR,
    NCA_STATUS_INVALID_PRES_CXT_ID,     RPC_S_PROTOCOL_ERROR,
    NCA_STATUS_FAULT_PIPE_EMPTY,        RPC_X_PIPE_EMPTY,
    NCA_STATUS_FAULT_PIPE_CLOSED,       RPC_X_PIPE_CLOSED,
    NCA_STATUS_FAULT_PIPE_ORDER,        RPC_X_WRONG_PIPE_ORDER,
    NCA_STATUS_FAULT_PIPE_MEMORY,       RPC_S_OUT_OF_MEMORY,
    NCA_STATUS_FAULT_PIPE_DISCIPLINE,   RPC_X_PIPE_DISCIPLINE_ERROR,
    NCA_STATUS_FAULT_PIPE_COMM_ERROR,   RPC_S_COMM_FAILURE,
    NCA_STATUS_INVALID_CHECKSUM,        RPC_S_CALL_FAILED_DNE,
    NCA_STATUS_INVALID_CRC,             RPC_S_CALL_FAILED_DNE,
    NCA_STATUS_UNSPEC_REJECT,           RPC_S_CALL_FAILED_DNE,
    NCA_STATUS_BAD_ACTID,               RPC_S_CALL_FAILED_DNE,
    NCA_STATUS_CALL_DNE,                RPC_S_CALL_FAILED_DNE,
    NCA_STATUS_UNSUPPORTED_AUTHN_LEVEL, RPC_S_UNSUPPORTED_AUTHN_LEVEL,

    // Catch all for OSF interop
    0, RPC_S_CALL_FAILED
    };

long
MapStatusCode(
    IN long StatusToMap,
    IN const long aErrorMap[],
    IN unsigned MapSize
    )
/*++

Routine Description:

    Maps a status value from one type of error to another.

Arguments:

    StatusToMap - The status code to map
    aErrorMap - An array of status codes of the format <original error><mapped error>
    MapSize - The number of <original error>'s in the array.

Return Value:

    If a mapping is found it will be returned, otherwise the original error is returned.

--*/
{
    for (unsigned i = 0; i < MapSize; i++)
        {
        if (aErrorMap[i * 2] == StatusToMap)
            return(aErrorMap[i * 2 + 1]);
        }
    return(StatusToMap);
}

unsigned long
MapToNcaStatusCode (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    This routine maps a local RPC status code to an NCA status code to
    be sent across the wire.

Arguments:

    RpcStatus - Supplies the RPC status code to be mapped into an NCA
        status code.

Return Value:

    The NCA status code will be returned.  If the RPC status code could
    not be mapped, it will be returned unchanged.

--*/
{
    return((unsigned long) MapStatusCode(
                                         RpcStatus,
                                         RpcToNcaMap,
                                         sizeof(RpcToNcaMap)/(2*sizeof(long))
                                        )
           );
}

RPC_STATUS
MapFromNcaStatusCode (
    IN unsigned long NcaStatus
    )
/*++

Routine Description:

    This routine is used to map an NCA status code (typically one received
    off of the wire) into a local RPC status code.  If the NCA status code
    can not be mapped, it will be returned unchanged.

Arguments:

    NcaStatus - Supplies the NCA status code to be mapped into an RPC status
        code.

Return Value:

    An RPC status code will be returned.

--*/
{
    return((RPC_STATUS) MapStatusCode(NcaStatus,
                                      NcaToRpcMap,
                                      sizeof(NcaToRpcMap)/(2*sizeof(long))
                                     )
           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dcestrng.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    dcestrng.cxx

Abstract:

    This module contains the code for the String Object DCE RPC runtime
    APIs, as well as the APIs which compose and parse string bindings.

Author:

    Michael Montague (mikemon) 25-Sep-1991

Revision History:

--*/

#include <precomp.hxx>


RPC_STATUS RPC_ENTRY
RpcStringBindingCompose (
    IN unsigned short PAPI * ObjUuid OPTIONAL,
    IN unsigned short PAPI * Protseq OPTIONAL,
    IN unsigned short PAPI * NetworkAddr OPTIONAL,
    IN unsigned short PAPI * Endpoint OPTIONAL,
    IN unsigned short PAPI * Options OPTIONAL,
    OUT unsigned short PAPI * PAPI * StringBinding OPTIONAL
    )
/*++

Routine Description:

    This routine combines the components of a string binding into a
    string binding.  Empty fields in the string binding can be specified
    by passing a NULL argument value or by providing an empty string ("").

Arguments:

    ObjUuid - Optionally supplies a string representation of an object UUID.

    Protseq - Optionally supplies a string representation of a protocol
        sequence.

    NetworkAddr - Optionally supplies a string representation of a
        network address.

    Endpoint - Optionally supplies a string representation of an endpoint.

    Options - Optionally supplies a string representation of network options.

    StringBinding - Optionally returns the string binding composed from the
        pieces specified by the other parameters.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insuffient memory is available to allocate space
        for the string binding.

--*/
{
    DCE_BINDING * DceBinding;
    RPC_STATUS Status;

    InitializeIfNecessary();

    // If the caller did not want us to return the string binding, then
    // do not even bother to compose one.
    if (!ARGUMENT_PRESENT(StringBinding))
        {
        return (RPC_S_OK);
        }

    DceBinding = new DCE_BINDING(ObjUuid, Protseq, NetworkAddr, Endpoint,
            Options, &Status);

    if (DceBinding == 0)
        return(RPC_S_OUT_OF_MEMORY);


    if (Status != RPC_S_OK)
        {
        delete DceBinding;
        return(Status);
        }

    *StringBinding = DceBinding->StringBindingCompose(0);

    delete DceBinding;

    if (*StringBinding == 0)
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcStringBindingParse (
    IN unsigned short PAPI * StringBinding,
    OUT unsigned short PAPI * PAPI * ObjUuid OPTIONAL,
    OUT unsigned short PAPI * PAPI * Protseq OPTIONAL,
    OUT unsigned short PAPI * PAPI * NetworkAddr OPTIONAL,
    OUT unsigned short PAPI * PAPI * Endpoint OPTIONAL,
    OUT unsigned short PAPI * PAPI * NetworkOptions OPTIONAL
    )
/*++

Routine Description:

    RpcStringBindingParse returns as seperate strings the object UUID
    part and address parts of a string binding.

Arguments:

    StringBinding - Supplies a string binding to parsed into its component
        parts.

    ObjUuid - Optionally returns the object UUID part of the string binding.

    Protseq - Optionally returns the protocol sequence part of the string
        binding.

    NetworkAddr - Optionally returns the network address part of the string
        binding.

    Endpoint - Optionally returns the endpoint part of the string binding.

    NetworkOptions - Optionally returns the network options part of the
        string binding.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficent memory is available to allocate
        space for the fields of the string binding.

    RPC_S_INVALID_STRING_BINDING - The string binding is syntactically
        invalid.

    RPC_S_INVALID_ARG - The string binding is not specified
        (ie. ARGUMENT_PRESENT(StringBinding) is false).

--*/
{
    RPC_STATUS Status;
    DCE_BINDING * DceBinding;
    RPC_CHAR __RPC_FAR * CopiedStringBinding;

    InitializeIfNecessary();

    if (!ARGUMENT_PRESENT(StringBinding))
        return(RPC_S_INVALID_ARG);

    CopiedStringBinding = (RPC_CHAR *)
              _alloca( (RpcpStringLength(StringBinding)+1)*(sizeof(RPC_CHAR)) );
    if (CopiedStringBinding == 0)
        {
        return (RPC_S_OUT_OF_MEMORY);
        }
    RpcpStringCopy(CopiedStringBinding, StringBinding);

    DceBinding = new DCE_BINDING(CopiedStringBinding,&Status);

    if ( DceBinding == 0 )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    if ( Status != RPC_S_OK )
        {
        delete DceBinding;
        return(Status);
        }

    if ( ARGUMENT_PRESENT(ObjUuid) )
        {
        *ObjUuid = DceBinding->ObjectUuidCompose(&Status);
        }

    if ( ARGUMENT_PRESENT(Protseq) && (Status == RPC_S_OK))
        {
        *Protseq = DceBinding->RpcProtocolSequenceCompose(&Status);
        }

    if ( ARGUMENT_PRESENT(NetworkAddr) && (Status == RPC_S_OK))
        {
        *NetworkAddr = DceBinding->NetworkAddressCompose(&Status);
        }

    if ( ARGUMENT_PRESENT(Endpoint) && (Status == RPC_S_OK))
        {
        *Endpoint = DceBinding->EndpointCompose(&Status);
        }

    if ( ARGUMENT_PRESENT(NetworkOptions) && (Status == RPC_S_OK))
        {
        *NetworkOptions = DceBinding->OptionsCompose(&Status);
        }

    delete DceBinding;

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcStringFreeW (
    IN OUT unsigned short PAPI * PAPI * String
    )
/*++

Routine Description:

    This routine frees a character string allocated by the runtime.

Arguments:

    String - Supplies the address of the pointer to the character string
        to free, and returns zero.

Return Values:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_ARG - The String argument does not contain the address
        of a pointer to a character string.

--*/
{
    InitializeIfNecessary();

    if (String == 0)
        return(RPC_S_INVALID_ARG);

    RpcpFarFree(*String);
    *String = 0;
    return(RPC_S_OK);
}

RPC_STATUS RPC_ENTRY
RpcStringFreeA (
    IN OUT unsigned char PAPI * PAPI * String
    )
/*++

Routine Description:

    This routine frees a character string allocated by the runtime.

Arguments:

    String - Supplies the address of the pointer to the character string
        to free, and returns zero.

Return Values:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_ARG - The String argument does not contain the address
        of a pointer to a character string.

--*/
{
	return RpcStringFreeW((WCHAR **)String);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dgclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    dgclnt.cxx

Abstract:

    This is the client side of datagram rpc.

Author:

    Jeff Roberts

Revisions:

    Jeff Roberts  (jroberts)  9-30-1996

        Began asynchronous call support.
        Began to remove DOS and Win16 support.

--*/

#include <precomp.hxx>
#include <conv.h>
#include <convc.h>
#include <epmap.h>
#include <dgpkt.hxx>
#include <spseal.h>
#include <locks.hxx>
#include <dgclnt.hxx>
#include <hndlsvr.hxx>
#include <dgsvr.hxx>

/*

There are a lot of mutexes in this architecture.  All these objects are
protected by mutexes:

  DG_BINDING_HANDLE
  DG_CASSOCIATION
  DG_CLIENT_ADDRESS_TABLE
  DG_CCONNECTION
  DG_ASSOCIATION_TABLE (exclusive access)

In many cases it is necessary to acquire multiple mutexes at a time.  To avoid
deadlock, multiple mutexes must be taken in the order they are listed above.
For most of the code's history this ordering was not articulated, so there is
no macro to help enforce it.  It's just a good idea.

*/

//
// If you #define INTRODUCE_ERRORS then you can get the client and server
// to drop or delay some packets.  Here are the environment variables that
// control this behavior:
//
// set ServerDelayRate=xxx    where xxx is a percentage 0..100
// set ServerDelayTime=xxx    where xxx is the number of msec to delay
// set ServerDropRate=xxx     where xxx is a percentage 0..100
//
// set ClientDelayRate=xxx    where xxx is a percentage 0..100
// set ClientDelayTime=xxx    where xxx is the number of msec to delay
// set ClientDropRate=xxx     where xxx is a percentage 0..100
//

#define IDLE_CCALL_LIFETIME          (30 * 1000)
#define IDLE_CCALL_SWEEP_INTERVAL    (30 * 1000)

//#define IDLE_CCONNECTION_LIFETIME       (5 * 60 * 1000)
//#define IDLE_CCONNECTION_SWEEP_INTERVAL (1 * 60 * 1000)
//#define IDLE_CASSOCIATION_LIFETIME   (10 * 60 * 1000)

#define IDLE_CCONNECTION_LIFETIME       (2 * 60 * 1000)
#define IDLE_CCONNECTION_SWEEP_INTERVAL (    30 * 1000)
#define IDLE_CASSOCIATION_LIFETIME      (    30 * 1000)

#define GLOBAL_SCAVENGER_INTERVAL    (30 * 1000)
#define IDLE_ENDPOINT_LIFETIME       (30 * 1000)
#define PENALTY_BOX_DURATION         (10 * 1000)

#define CXT_HANDLE_KEEPALIVE_INTERVAL (20 * 1000)
#define CXT_HANDLE_SWEEP_INTERVAL     (10 * 1000)

//
// endpoint flags
//

// in rpcdce.h:
// #define RPC_C_USE_INTERNET_PORT         0x1
// #define RPC_C_USE_INTRANET_PORT         0x2

// calls with the maybe attribute are banished to a separate endpoint
//
#define PORT_FOR_MAYBE_CALLS   (0x1000)

// if a call fails or sends an ACK, there is a chance that an ICMP will be sent
// and we don't want it sitting in the port buffer when the next call uses the endpoint.
//
#define PENALTY_BOX            (0x0800)

//-------------------------------------------------------------------

DG_ASSOCIATION_TABLE * ActiveAssociations;

CLIENT_ACTIVITY_TABLE * ClientConnections;
ENDPOINT_MANAGER *      EndpointManager;

DELAYED_ACTION_TABLE *  DelayedProcedures;

long                    GlobalScavengerTimeStamp;
DELAYED_ACTION_NODE *   GlobalScavengerTimer;
DELAYED_ACTION_NODE *   ContextHandleTimer;

LONG ClientConnectionCount = 0;
LONG ClientCallCount = 0;

//-------------------------------------------------------------------

void
ContextHandleProc(
                  void * arg
                  );

void
DelayedAckFn(
    void * parm
    );

void
DelayedSendProc(
    void * parm
    );

RPC_STATUS
DispatchCallbackRequest(
    DG_CLIENT_CALLBACK *    CallbackObject
    );

int
InitializeRpcProtocolDgClient();

//--------------------------------------------------------------------


void
EnableGlobalScavenger()
{
    DelayedProcedures->Add(GlobalScavengerTimer, GLOBAL_SCAVENGER_INTERVAL + (5 * 1000), FALSE);
}

void
GlobalScavengerProc(
    void * Arg
    )
{
    long CurrentTime = PtrToLong( Arg );

    if (!CurrentTime)
        {
        CurrentTime = GetTickCount();
        }

    if (CurrentTime - GlobalScavengerTimeStamp <= 0)
        {
        return;
        }

    GlobalScavengerTimeStamp = CurrentTime;

    boolean Continue = FALSE;

    Continue |= DG_PACKET::DeleteIdlePackets(CurrentTime);

    Continue |= ActiveAssociations->DeleteIdleEntries(CurrentTime);

    Continue |= EndpointManager->DeleteIdleEndpoints(CurrentTime);

    if (Continue)
        {
        EnableGlobalScavenger();
        }
}

#ifdef INTRODUCE_ERRORS

long ServerDelayTime;
long ServerDelayRate;
long ServerDropRate;

long ClientDelayTime;
long ClientDelayRate;
long ClientDropRate;

#endif


int
InitializeRpcProtocolDgClient ()
/*++

Routine Description:

    This routine initializes the datagram protocol.

Arguments:

    <none>

Return Value:

    0 if successfull, 1 if not.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    //
    // Don't take the global mutex if we can help it.
    //
    if (ProcessStartTime)
        {
        return 0;
        }

    RequestGlobalMutex();

    if (!ProcessStartTime)
        {
        Status = DG_PACKET::Initialize();
        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        DelayedProcedures = new DELAYED_ACTION_TABLE(&Status);
        if (!DelayedProcedures)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        GlobalScavengerTimer = new DELAYED_ACTION_NODE(GlobalScavengerProc, 0);
        if (!GlobalScavengerTimer)
            {
            goto abend;
            }

        GlobalScavengerTimeStamp = GetTickCount();

        ContextHandleTimer = new DELAYED_ACTION_NODE(ContextHandleProc, 0);
        if (!ContextHandleTimer)
            {
            goto abend;
            }

        ClientConnections = new CLIENT_ACTIVITY_TABLE(&Status);
        if (!ClientConnections)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        ActiveAssociations = new DG_ASSOCIATION_TABLE(&Status);
        if (!ActiveAssociations)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        EndpointManager = new ENDPOINT_MANAGER(&Status);
        if (!EndpointManager)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        //
        // Server boot time is represented as the number of seconds
        // since 1/1/1970.  It must increase with each boot of the server.
        //

        LARGE_INTEGER CurrentTime;
        NTSTATUS Nt_Status;

        Nt_Status = NtQuerySystemTime(&CurrentTime);

        ASSERT( NT_SUCCESS(Nt_Status) );

        RtlTimeToSecondsSince1980(&CurrentTime, &ProcessStartTime);

        ProcessStartTime += (60 * 60 * 24 * 365 * 10);


#ifdef INTRODUCE_ERRORS

        char EnvBuffer[64];

        if (GetEnvironmentVariableA("ServerDelayTime", EnvBuffer, 64))
            {
            ::ServerDelayTime = atol(EnvBuffer);
            }
        if (GetEnvironmentVariableA("ServerDelayRate", EnvBuffer, 64))
            {
            ::ServerDelayRate = atol(EnvBuffer);
            }
        if (GetEnvironmentVariableA("ServerDropRate", EnvBuffer, 64))
            {
            ::ServerDropRate = atol(EnvBuffer);
            }
        if (GetEnvironmentVariableA("ClientDelayTime", EnvBuffer, 64))
            {
            ::ClientDelayTime = atol(EnvBuffer);
            }
        if (GetEnvironmentVariableA("ClientDelayRate", EnvBuffer, 64))
            {
            ::ClientDelayRate = atol(EnvBuffer);
            }
        if (GetEnvironmentVariableA("ClientDropRate", EnvBuffer, 64))
            {
            ::ClientDropRate = atol(EnvBuffer);
            }
#endif
        }

    ClearGlobalMutex();

    return 0;

    //--------------------------------------------------------------------

abend:

    delete EndpointManager;
    EndpointManager = 0;

    delete ActiveAssociations;
    ActiveAssociations = 0;

    delete ClientConnections;
    ClientConnections = 0;

    delete GlobalScavengerTimer;
    GlobalScavengerTimer = 0;

    delete DelayedProcedures;
    DelayedProcedures = 0;

    ClearGlobalMutex();

    return 1;
}


BINDING_HANDLE  *
DgCreateBindingHandle ()
/*++

Routine Description:

    Pseudo-constructor for creating a dg binding handle. It is done in a
    separate function so that the calling routine doesn't have to know
    any protocol-specific information.

Arguments:

    <none>

Return Value:

    A DG_BINDING_HANDLE, if successful, otherwise 0 (indicating out of mem)

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    BINDING_HANDLE * Binding;

    Binding = new DG_BINDING_HANDLE(&Status);
    if (Status != RPC_S_OK)
        {
        delete Binding;
        return 0;
        }

    return Binding;
}


void
DG_CASSOCIATION::FlushAcks(
                           )
{
    PDG_CCONNECTION Connection;
    DictionaryCursor cursor;


    MutexRequest();

    ActiveConnections.Reset(cursor);

    while (Connection = ActiveConnections.Next(cursor))
        {
        // If an ACK is pending, send it.
        //
        Connection->CancelDelayedAck( TRUE );
        }

    ASSERT( ReferenceCount.GetInteger() > 0 );

    MutexClear();
}


void
DG_CASSOCIATION::DecrementRefCount()
/*++

Routine Description:

    Decrements the ref count to an association. If the ref count hits zero,
    the association is marked for deletion.

    It is possible for the count to go to zero just as another thread is
    scavenging the association table.  This would be a rare occurence, and
    should cause no ill effect.

--*/
{
    ASSERT( !InvalidHandle(DG_CASSOCIATION_TYPE) );

    ActiveAssociations->UpdateTimeStamp( this );

    long Count = ReferenceCount.Decrement();

    LogEvent(SU_CASSOC, EV_DEC, this, 0, Count);

    if (0 == Count)
        {
        LogEvent(SU_CASSOC, EV_STOP, this);
        EnableGlobalScavenger();
        }
}


RPC_STATUS
DG_CASSOCIATION::UpdateAssociationWithAddress(
    PDG_PACKET           Packet,
    DG_TRANSPORT_ADDRESS NewAddress
    )
{
    ASSERT( !InvalidHandle(DG_CASSOCIATION_TYPE) );

    long OldAssociationFlags;

    if (!AssociationFlag)
        {
        return RPC_S_OK;
        }

    if (Packet->Header.PacketType != DG_FACK     &&
        Packet->Header.PacketType != DG_WORKING  &&
        Packet->Header.PacketType != DG_RESPONSE &&
        Packet->Header.PacketType != DG_FAULT    )
        {
        return RPC_S_OK;
        }

    OldAssociationFlags = InterlockedExchange(&AssociationFlag, 0);

    if (0 == OldAssociationFlags)
        {
        return RPC_S_OK;
        }

    LogEvent(SU_CASSOC, EV_RESOLVED, this, 0, OldAssociationFlags);

    CLAIM_MUTEX Lock( Mutex );

    //
    // Save the updated network address + endpoint.
    //
    RPC_STATUS Status;
    char * SecondAddress;

    SecondAddress =  (char *) (this + 1);
    SecondAddress += TransportInterface->AddressSize;

    //
    // The only flags we handle here are UNRESOLVEDEP and BROADCAST.
    //
    ASSERT( 0 == (OldAssociationFlags & ~(UNRESOLVEDEP | BROADCAST)) );

    if (OldAssociationFlags & BROADCAST)
        {
        RPC_STATUS Status = RPC_S_OK;
        DCE_BINDING * OldDceBinding = 0;
        DCE_BINDING * NewDceBinding = 0;
        RPC_CHAR * ObjectUuid = 0;
        RPC_CHAR * AddressString = (RPC_CHAR *) _alloca(TransportInterface->AddressStringSize * sizeof(RPC_CHAR));
        RPC_CHAR * EndpointString = pDceBinding->InqEndpoint();

        Status = TransportInterface->QueryAddress(NewAddress, AddressString);
        if ( Status != RPC_S_OK )
            {
            LogError(SU_CASSOC, EV_STATUS, this, 0, Status);
            SetErrorFlag();
            return Status;
            }

        if (OldAssociationFlags & UNRESOLVEDEP)
            {
            Status = TransportInterface->QueryEndpoint(NewAddress, ResolvedEndpoint);
            if ( Status != RPC_S_OK )
                {
                LogError(SU_CASSOC, EV_STATUS, this, 0, Status);
                SetErrorFlag();
                return Status;
                }

            EndpointString = ResolvedEndpoint;
            }

        ObjectUuid = pDceBinding->ObjectUuidCompose( &Status );
        if ( Status != RPC_S_OK )
            {
            LogError(SU_CASSOC, EV_STATUS, this, 0, Status);
            SetErrorFlag();
            return Status;
            }

        NewDceBinding = new DCE_BINDING( ObjectUuid,
                                         pDceBinding->InqRpcProtocolSequence(),
                                         AddressString,
                                         EndpointString,
                                         pDceBinding->InqNetworkOptions(),
                                         &Status
                                         );
        RpcpFarFree( ObjectUuid );

        if (Status || !NewDceBinding)
            {
            delete NewDceBinding;

            LogError(SU_CASSOC, EV_STATUS, this, 0, Status);
            SetErrorFlag();
            return Status;
            }

        OldDceBinding = pDceBinding;
        pDceBinding = NewDceBinding;

        delete OldDceBinding;
        }
    else if (OldAssociationFlags & UNRESOLVEDEP)
        {
        //
        // We have resolved a dynamic endpoint; update the endpoint in the DCE_BINDING.
        //
        Status = TransportInterface->QueryEndpoint(NewAddress, ResolvedEndpoint);
        if ( Status != RPC_S_OK )
            {
            LogError(SU_CASSOC, EV_STATUS, this, 0, Status);
            SetErrorFlag();
            return Status;
            }

        pDceBinding->AddEndpoint(ResolvedEndpoint);

        ResolvedEndpoint = 0;
        }
    else
        {
        ASSERT( 0 );
        }

    RpcpMemoryCopy( SecondAddress, NewAddress, TransportInterface->AddressSize );
    ServerAddress = SecondAddress;

    return RPC_S_OK;
}


RPC_STATUS
DG_BINDING_HANDLE::FindOrCreateAssociation(
    IN const PRPC_CLIENT_INTERFACE Interface,
    IN BOOL                        fReconnect,
    IN BOOL                        fBroadcast
    )
{
    RPC_STATUS Status;
    BOOL fPartial = FALSE;
    LONG AssociationFlag = 0;

    if (fBroadcast)
        {
        AssociationFlag = DG_CASSOCIATION::BROADCAST;
        }

    //
    // Check to see if we need to resolve this endpoint.
    //
    Status = pDceBinding->ResolveEndpointIfNecessary(
        Interface,
        InqPointerAtObjectUuid(),
        InquireEpLookupHandle(),
        TRUE,                         // UseEpMapper Ep If Necessary
        InqComTimeout(),
        DEFAULT_EPMAP_CALL_TIMEOUT,   // CallTimeout
        NULL                          // AuthInfo
        );

    if (Status == RPC_P_EPMAPPER_EP)
        {
        AssociationFlag |= DG_CASSOCIATION::UNRESOLVEDEP;
        fPartial = TRUE;
        Status = 0;
        }

    if (Status)
        {
        return Status;
        }

    //
    // A binding with the UNIQUE option set should maintain its own association,
    // never sharing with other binding handles.  This is used by the Wolfpack
    // cluster software to manage connections themselves.
    //
    ULONG_PTR fUnique;

    Status = InqTransportOption(RPC_C_OPT_UNIQUE_BINDING, &fUnique);
    ASSERT(Status == RPC_S_OK);

    if (fUnique == 0 && fBroadcast == FALSE)
        {
        //
        // Look for a matching association.
        //
        ASSERT( Association == 0 );

        Association = ActiveAssociations->Find( this, Interface, fContextHandle, fPartial, fReconnect );
        if (Association)
            {
            return 0;
            }
        }

    //
    // Create a matching association.
    //
    ASSERT(pDceBinding);

    DCE_BINDING * NewDceBinding = pDceBinding->DuplicateDceBinding();

    if (!NewDceBinding)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    Association = new (TransportInterface) DG_CASSOCIATION( TransportInterface,
                                                            AssociationFlag,
                                                            NewDceBinding,
                                                            (BOOL) fUnique,
                                                            &Status
                                                            );

    if (Association == 0)
        {
        // DceBinding is freed in the distructor of DG_CASSOCIATION.
        // Since Association could not be allocated we need to free the
        // DCE binding here.
        delete NewDceBinding;
        Status = RPC_S_OUT_OF_MEMORY;
        }

    if (Status)
        {
        delete Association;
        Association = 0;

        return Status;
        }

    //
    // Other threads using this binding handle for the same interface
    // will reuse this association instead of creating a new one.
    //
    Association->AddInterface(Interface, InqPointerAtObjectUuid());

    return 0;
}



RPC_STATUS
DG_BINDING_HANDLE::SetTransportOption( IN unsigned long option,
                                       IN ULONG_PTR     optionValue )
/*++

Routine Description:

  Set the binding specific transport option to the optionValue.

Arguments:

  option      -- Option to set (transport specific).
  optionValue -- New value for option.

Return Value: RPC_S_OK
              RPC_S_CANNOT_SUPPORT
              RPC_S_ARG_INVALID
              RPC_S_OUT_OF_MEMORY

--*/
{
  RPC_STATUS  Status = RPC_S_OK;

  if (option >= RPC_C_OPT_BINDING_NONCAUSAL)
      {
      //
      // This option can be changed only before a call is made.
      //
      if (option == RPC_C_OPT_UNIQUE_BINDING && Association != NULL)
      {
          return RPC_S_WRONG_KIND_OF_BINDING;
          }

      return BINDING_HANDLE::SetTransportOption(option, optionValue);
      }

  if ( (TransportInterface) && (TransportInterface->OptionsSize > 0) )
     {
     if (pvTransportOptions == NULL)
        {
        pvTransportOptions = (void*)I_RpcAllocate(TransportInterface->OptionsSize);
        if (pvTransportOptions == NULL)
           {
           return RPC_S_OUT_OF_MEMORY;
           }

        Status = TransportInterface->InitOptions(pvTransportOptions);
        }

     if (Status == RPC_S_OK)
        {
        Status = TransportInterface->SetOption(pvTransportOptions,option,optionValue);
        }
     }
  else
     {
     Status = RPC_S_CANNOT_SUPPORT;
     }

  return Status;
}



RPC_STATUS
DG_BINDING_HANDLE::InqTransportOption( IN  unsigned long  option,
                                       OUT ULONG_PTR     *pOptionValue )
/*++

Routine Description:

  Get the value of a transport specific binding option.

Arguments:

  option      -- Option to inquire.
  pOptionValue - Place to return the current value.

Return Value: RPC_S_OK
              RPC_S_CANNOT_SUPPORT
              RPC_S_ARG_INVALID
              RPC_S_OUT_OF_MEMORY

--*/
{
  RPC_STATUS    Status = RPC_S_OK;

  if (option >= RPC_C_OPT_BINDING_NONCAUSAL)
      {
      return BINDING_HANDLE::InqTransportOption(option, pOptionValue);
      }

  if ( (TransportInterface) && (TransportInterface->OptionsSize > 0) )
  {
    if (pvTransportOptions == NULL)
    {
      pvTransportOptions = (void*)I_RpcAllocate(TransportInterface->OptionsSize);
      if (pvTransportOptions == NULL)
        return RPC_S_OUT_OF_MEMORY;

      Status = TransportInterface->InitOptions(pvTransportOptions);
    }

    if (Status == RPC_S_OK)
      Status = TransportInterface->InqOption(pvTransportOptions,option,pOptionValue);
  }
  else
    Status = RPC_S_CANNOT_SUPPORT;

  return Status;
}



RPC_STATUS
DG_BINDING_HANDLE::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

    This is the routine that is called to initiate an rpc. At this point,
    the client stub is allocating memory to place the parameters into. Ask our
    association for a DG_CCALL object to transact this call on then send
    the buffer request off to that DG_CCALL.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call.

Return Value:

    RPC_S_OUT_OF_MEMORY

    RPC_S_OK

Revision History:

--*/
{
    BOOL fBroadcast = FALSE;
    RPC_STATUS  Status;

    LogEvent(  SU_HANDLE, EV_PROC, this, 0, 'G' + (('e' + (('t' + ('B' << 8)) << 8)) << 8));

    if (Message->RpcFlags & (RPC_NCA_FLAGS_MAYBE | RPC_NCA_FLAGS_BROADCAST))
        {
        Message->RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }

    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
        {
        Status = TransportObject->CreateThread();
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    if (Message->RpcFlags & RPC_NCA_FLAGS_BROADCAST)
        {
        fBroadcast = TRUE;
        }

    MutexRequest();

    ASSERT(pDceBinding != 0);

    //
    // Have we already determined the association for this binding handle?
    //
    if (Association == 0)
        {
        Status = FindOrCreateAssociation( (PRPC_CLIENT_INTERFACE) Message->RpcInterfaceInformation, FALSE, fBroadcast );
        if (Status)
            {
            MutexClear();
            LogError(SU_HANDLE, EV_STATUS, this, 0, Status);
            return (Status);
            }
        }


    {
    const CLIENT_AUTH_INFO * AuthInfo = InquireAuthInformation();

    if ( AuthInfo &&
         AuthInfo->AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE  &&
         AuthInfo->IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC )
        {
        Status = ReAcquireCredentialsIfNecessary();
        if (Status != RPC_S_OK)
            {
            MutexClear();
            LogError(SU_HANDLE, EV_STATUS, this, 0, Status);
            return (Status);
            }
        }
    }

    // Here's the deal, Sparky:
    //      association refcount = (# of binding handles with a pointer to it)
    //                           + (# of the association's connections in use)
    //      connection refcount  = (# of the connection's CCALLs in use)
    //      binding refcount     = (# of connections with a pointer to it)

    PDG_CCALL Call = 0;
    const CLIENT_AUTH_INFO * AuthInfo;

    if (Message->RpcFlags & RPC_NCA_FLAGS_MAYBE)
        {
        AuthInfo = 0;
        }
    else
        {
        AuthInfo = InquireAuthInformation();
        }

    Status = Association->AllocateCall( this, AuthInfo, &Call, (Message->RpcFlags & RPC_BUFFER_ASYNC) ? TRUE : FALSE );

    MutexClear();

    if (Status != RPC_S_OK)
        {
        LogError(SU_HANDLE, EV_STATUS, this, 0, Status);
        return Status;
        }

    return Call->GetInitialBuffer(Message, ObjectUuid);
}


BOOL
DG_CASSOCIATION::SendKeepAlive()
/*++

Routine Description:

    This calls convc_indy() to tell the server to keep the association's
    context handles alive.  The NT server code does not register the convc interface,
    since the mere fact of activity on a connection keeps the connection, and therefore
    the association group, alive.

Return Value:

    TRUE  if successful
    FALSE if not

--*/
{
    RPC_STATUS status = 0;

    LogEvent(SU_CASSOC, EV_ACK, this);

    if (!KeepAliveHandle)
        {
        MutexRequest();

        if (!KeepAliveHandle)
            {
            DCE_BINDING * NewDceBinding;

            NewDceBinding = pDceBinding->DuplicateDceBinding();
            if (!NewDceBinding)
                {
                MutexClear();
                return FALSE;
                }

            KeepAliveHandle = new DG_BINDING_HANDLE(this, NewDceBinding, &status);

            if (status)
                {
                delete KeepAliveHandle;
                delete NewDceBinding;
                MutexClear();
                return FALSE;
                }

            if (!KeepAliveHandle)
                {
                delete NewDceBinding;
                MutexClear();
                return FALSE;
                }

            IncrementBindingRefCount( FALSE );
            }

        MutexClear();
        }

    RpcTryExcept
        {
        _convc_indy( KeepAliveHandle, &ActiveAssociations->CasUuid );
        }
    RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) )
        {
        // don't care
#ifdef DBG
        DbgPrint("RPC: exception 0x%x in context-handle keep-alive\n", RpcExceptionCode());
#endif
        }
    RpcEndExcept;

    return TRUE;
}


PDG_CCONNECTION
DG_CASSOCIATION::AllocateConnection(
    IN  PDG_BINDING_HANDLE BindingHandle,
    IN  const CLIENT_AUTH_INFO * AuthInfo,
    IN  DWORD ThreadId,
    IN  BOOL  fAsync,
    OUT RPC_STATUS * pStatus
    )
{
    if (!ThreadId)
        {
        ThreadId = GetCurrentThreadId();
        }

    boolean fStacking = FALSE;
    RPC_STATUS Status = RPC_S_OK;
    PDG_CCONNECTION Connection = 0;
    PDG_CCONNECTION BusyConnection;
    DictionaryCursor cursor;

                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 0 ), this, Connection );

    long StartTime = GetTickCount();

retry:

    BusyConnection = 0;

    MutexRequest();

    //
    // Multiple async calls from the same thread should all use a single
    // connection unless the binding handle is marked "non-causal".
    // A synchronous call from the same thread should use a different
    // connection.
    //
    // A connection waiting to send a delayed ACK is still marked active,
    // but we want to reuse it anyway.
    //
    // The plan, therefore, is to search first for an active connection if
    // the call is async and causal, then search for a connection that is
    // inactive except for a delayed ack, then search for an idle connection.
    //

    if (fAsync)
        {
        ULONG_PTR fNonCausal;

        Status = BindingHandle->InqTransportOption(
                                                   RPC_C_OPT_BINDING_NONCAUSAL,
                                                   &fNonCausal);
        ASSERT(Status == RPC_S_OK);

        if (fNonCausal == 0)
            {
            fStacking = TRUE;
            }
        }

    //
    // Search for a connection handling this thread's async calls.
    //
    if (fStacking)
        {
        ActiveConnections.Reset(cursor);

        while (Connection = ActiveConnections.Next(cursor))
            {
            BusyConnection = Connection;

            if ( Connection->BindingHandle != BindingHandle ||
                 Connection->ThreadId      != ThreadId )
                 {
                 continue;
                 }

            //
            // The app may have changed the security info since the other
            // calls were submitted.
            //
            if (FALSE == fLoneBindingHandle &&
                FALSE == Connection->IsSupportedAuthInfo(AuthInfo))
                {
                continue;
                }

            Connection->MutexRequest();
            if (Connection->fBusy)
                {
                // The connection is in a transitional state and is unavailable right now.
                // If this is a Unique binding handle, retry.  Otherwise keep looking.
                //
                Connection->MutexClear();

                if (fLoneBindingHandle)
                    {
                    LogError(SU_CASSOC, EV_PROC, this, (void *) 4, 'R' + (('e' + (('t' + ('r' << 8)) << 8)) << 8));
                    MutexClear();
                    Sleep(1);
                    goto retry;
                    }
                continue;
                }

            if ( Connection->BindingHandle != BindingHandle ||
                 Connection->ThreadId      != ThreadId )
                {
                Connection->MutexClear();
                continue;
                }

            MutexClear();

            //
            // Add a reference for the new call to come.
            //
            Connection->IncrementRefCount();

            Connection->CancelDelayedAck();

            return Connection;
            }
        }

    //
    // Search for a connection that is waiting on a delayed ack.
    //
    ActiveConnections.Reset(cursor);

    while (Connection = ActiveConnections.Next(cursor))
        {
        BusyConnection = Connection;
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 1 ), this, Connection );
        if (!Connection->AckPending)
            {
            continue;
            }

        if (FALSE == fLoneBindingHandle &&
            FALSE == Connection->IsSupportedAuthInfo(AuthInfo))
            {
            continue;
            }
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 2 ), this, Connection );
        Connection->MutexRequest();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 3 ), this, Connection );
        if (Connection->fBusy)
            {
            // The connection is in a transitional state and is unavailable right now.
            // If this is a Unique binding handle, retry.  Otherwise keep looking.
            //
            Connection->MutexClear();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 4 ), this, Connection );
            if (fLoneBindingHandle)
                {
                LogError(SU_CASSOC, EV_PROC, this, (void *) 5, 'R' + (('e' + (('t' + ('r' << 8)) << 8)) << 8));
                MutexClear();
                Sleep(1);
                goto retry;
            }

            continue;
            }
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 5 ), this, Connection );
        if (!Connection->AckPending)
            {
            Connection->MutexClear();
            continue;
        }

        DG_BINDING_HANDLE * OldHandle = Connection->BindingHandle;

        Connection->BindingHandle = BindingHandle;
        Connection->ThreadId      = ThreadId;
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 6 ), this, Connection );
#ifdef DBG
        //
        // debugging code for clustering
        //
        if (fLoneBindingHandle)
            {
            DG_CCONNECTION * SecondConnection = 0;

            //
            // See if a valid inactive connection exists,  This could cause trouble, too.
            //
            InactiveConnections.Reset(cursor);

            SecondConnection = InactiveConnections.Next(cursor);
            if (SecondConnection &&
                SecondConnection->fError == FALSE)
                {
                DbgPrint("RPC: failure of unique-handle semantics (2)\n");
                DbgBreakPoint();
                }
            }
#endif

        MutexClear();

        //
        // Add a reference for the call to come.  This prevents the conn from
        // accidentally being moved to the inactive list.
        //
        Connection->IncrementRefCount();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 7 ), this, Connection );
        //
        // Must cancel the delayed ACK before releasing the mutex, so other threads
        // can't pick it up like this thread did.
        //
        Connection->CancelDelayedAck();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 8 ), this, Connection );
        if (OldHandle != Connection->BindingHandle)
            {
            Connection->MutexClear();

            BindingHandle->IncrementRefCount();
            OldHandle->DecrementRefCount();

            Connection->MutexRequest();
            }

        return Connection;
        }

    //
    // Search for an idle connection with matching security info.
    //
    InactiveConnections.Reset(cursor);

    while (0 != (Connection = InactiveConnections.Next(cursor)))
        {
        BusyConnection = Connection;

        if (Connection->fError)
            {
            continue;
            }

        if (fLoneBindingHandle ||
            Connection->IsSupportedAuthInfo(AuthInfo))
            {
            LogEvent(SU_CCONN, EV_START, Connection, this);

            ASSERT( FALSE == Connection->fAutoReconnect );
            ASSERT( FALSE == Connection->fError );

            InactiveConnections.Delete(Connection->AssociationKey);
            Connection->AssociationKey = ActiveConnections.Insert(Connection);
            if (-1 == Connection->AssociationKey)
                {
                MutexClear();
                *pStatus = RPC_S_OUT_OF_MEMORY;
                delete Connection;
                return 0;
                }

            IncrementRefCount();

            ASSERT( FALSE == Connection->fBusy );

            Connection->MutexRequest();

            Connection->BindingHandle = BindingHandle;
            Connection->ThreadId      = ThreadId;

            ClientConnections->Add(Connection);

            MutexClear();

            BindingHandle->IncrementRefCount();

            //
            // Add a reference for the call to come.
            //
            Connection->IncrementRefCount();

            return Connection;
            }
        }

    //
    // Unique handles have special semantics.
    //
    if (fLoneBindingHandle && BusyConnection)
        {
        if (BindingHandle == KeepAliveHandle)
            {
            LogEvent(SU_CASSOC, EV_PROC, this, (void *) 1, 'R' + (('e' + (('t' + ('r' << 8)) << 8)) << 8));
            //
            // Keep-alive was begun just as the app thread began using the handle.
            // Don't bother executing the keep-alive.
            //
            MutexClear();
            *pStatus = RPC_S_CALL_IN_PROGRESS;
            return 0;
            }

        ASSERT( BusyConnection->BindingHandle );

        if (BusyConnection->BindingHandle == KeepAliveHandle)
            {
            LogEvent(SU_CASSOC, EV_PROC, this, (void *) 2, 'R' + (('e' + (('t' + ('r' << 8)) << 8)) << 8));
#if 0
            if (GetTickCount() - StartTime > 10*1000)
                {
                DbgPrint("RPC: keep-alive tied up a connection for > 10 seconds\n");
                DbgBreakPoint();
                }
#endif
            //
            // App thread began a call just as the keep-alive thread was finishing one.
            // Wait for the keep-alive to finish.
            //
            MutexClear();

            Sleep(1);

            goto retry;
            }

        //
        // Two app threads contending, or the current connection is closing.
        //
        if (BusyConnection->fBusy)
            {
            LogError(SU_CASSOC, EV_PROC, this, (void *) 6, 'R' + (('e' + (('t' + ('r' << 8)) << 8)) << 8));
            MutexClear();
            Sleep(1);
            goto retry;
            }

        //
        // Create a new connection.
        //
        LogEvent(SU_CASSOC, EV_PROC, this, (void *) 3, 'R' + (('e' + (('t' + ('r' << 8)) << 8)) << 8));

#ifdef DBG
        //
        // If it's in use, it should be doing something.
        //
        if ( FALSE == BusyConnection->fError &&
             BusyConnection->TimeStamp != 0  &&
             (GetTickCount() - BusyConnection->TimeStamp) > 60000)
            {
            DbgPrint("RPC: failure of unique-handle semantics (3)\n");
            DbgBreakPoint();
            }
#endif
        }

    //
    // Create a new connection and add it to the active conn list.
    // Increment the refcount here to avoid having the assoc deleted
    // while we are tied up.
    //
    IncrementRefCount();

    MutexClear();

    Connection = new (TransportInterface) DG_CCONNECTION(this, AuthInfo, &Status);
    if (!Connection)
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }
    if (Status != RPC_S_OK)
        {
        DecrementRefCount();
        delete Connection;
        *pStatus = Status;
        return 0;
        }

    Connection->BindingHandle = BindingHandle;
    Connection->ThreadId      = ThreadId;

    MutexRequest();

    Connection->MutexRequest();

    LogEvent(SU_CCONN, EV_START, Connection, this);
    Connection->AssociationKey = ActiveConnections.Insert(Connection);

    MutexClear();

    if (-1 == Connection->AssociationKey)
        {
        DecrementRefCount();

        // don't have to release the connection mutex because we are deleting it
        delete Connection;
        *pStatus = RPC_S_OUT_OF_MEMORY;
        return 0;
        }

    BindingHandle->IncrementRefCount();

    ClientConnections->Add(Connection);

    //
    // Add a reference for the call in progress.
    //
    Connection->IncrementRefCount();

    return Connection;
}


RPC_STATUS
DG_CASSOCIATION::AllocateCall(
    IN  PDG_BINDING_HANDLE BindingHandle,
    IN  const CLIENT_AUTH_INFO * AuthInfo,
    OUT PDG_CCALL * ppCall,
    IN  BOOL  fAsync
    )
{
    RPC_STATUS Status = 0;
    PDG_CCONNECTION Connection;

    Connection = AllocateConnection(BindingHandle, AuthInfo, 0, fAsync, &Status);

    if (!Connection)
        {
        return Status;
        }

    *ppCall = Connection->AllocateCall();

    if (!*ppCall)
        {
        // Even though allocating the call has failed, connection has been
        // created and placed into dictionaries, so we should not delete it.
        return RPC_S_OUT_OF_MEMORY;
        }

    return RPC_S_OK;
}


void
DG_CASSOCIATION::ReleaseConnection(
    IN PDG_CCONNECTION Connection
    )
{
    DG_BINDING_HANDLE * MyHandle;

    LogEvent(SU_CCONN, EV_STOP, Connection, this);

    ClientConnections->Remove(Connection);

    int Key;

    MutexRequest();

    ActiveConnections.Delete(Connection->AssociationKey);
    Connection->AssociationKey = InactiveConnections.Insert(Connection);
    Key = Connection->AssociationKey;

    Connection->WaitForNoReferences();

    MyHandle = Connection->BindingHandle;
    Connection->BindingHandle = 0;

    MutexClear();

    if (MyHandle)
        {
        MyHandle->DecrementRefCount();
        }

    if (-1 == Key)
        {
        Connection->CancelDelayedAck();
        delete Connection;
        }

    DecrementRefCount();
}


DG_CCALL *
DG_CCONNECTION::AllocateCall()

/*++

Description:

    Provides a DG_CCALL to use.  The connection mutex is cleared on exit.

--*/
{
    DG_CCALL * Call = 0;
    RPC_STATUS Status = RPC_S_OK;

    Mutex.VerifyOwned();

    ASSERT( !AckPending );
    ASSERT( ReferenceCount );

    if (CachedCalls)
        {
        Call = CachedCalls;
        CachedCalls = CachedCalls->Next;

        MutexClear();
        }
    else
        {
        MutexClear();

        Call = new DG_CCALL(this, &Status);
        if (!Call)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            delete Call;

            MutexRequest();

            DecrementRefCount();
            return 0;
            }
        }

    Call->IncrementRefCount();

    Call->Cancelled = FALSE;
    Call->CancelPending = FALSE;

    LogEvent(SU_CCALL, EV_START, Call, this);

    return Call;
}


RPC_STATUS
DG_BINDING_HANDLE::BindingFree (
    )
/*++

Routine Description:

    Implements RpcBindingFree for dg binding handles.

Arguments:

    <none>

Return Value:

    RPC_S_OK

--*/
{
    LogEvent( SU_HANDLE, EV_PROC, this, 0, 'F' + (('r' + (('e' + ('e' << 8)) << 8)) << 8), TRUE);

    if (!ThreadSelf())
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    // Flush the delayed ack on any connection using this handle.
    //
    if (Association)
        {
        PDG_CASSOCIATION TempAssociation;

        MutexRequest();

        TempAssociation = Association;
        Association = 0;

        MutexClear();

        if (TempAssociation != 0)
            {
            TempAssociation->DecrementBindingRefCount(fContextHandle);
            }
        }

    //
    // Decrement the ref count. If the count has hit zero, this call will
    // delete this.
    //
    DecrementRefCount();

    return RPC_S_OK;
}


RPC_STATUS
DG_BINDING_HANDLE::PrepareBindingHandle (
    IN TRANS_INFO *     a_TransportInterface,
    IN DCE_BINDING *    DceBinding
    )
/*++

Routine Description:

    Serves as an auxiliary constructor for DG_BINDING_HANDLE. This is called
    to initialize stuff after the DG_BINDING_HANDLE has been constructed.

Arguments:

    TransportInterface - pointer to the DG_CLIENT_TRANSPORT object that this
        DG_BINDING_HANDLE is active on.

    DceBinding - Pointer to the DCE_BINDING that we are associated with.

Return Value:

    none

--*/
{
    ASSERT(pDceBinding == 0);

    Association        = 0;
    pDceBinding        = DceBinding;
    TransportObject    = a_TransportInterface;
    TransportInterface = (RPC_DATAGRAM_TRANSPORT *) a_TransportInterface->InqTransInfo();

    RPC_CHAR * Endpoint = pDceBinding->InqEndpoint();
    if (!Endpoint || Endpoint[0] == 0)
        {
        fDynamicEndpoint = TRUE;
        }
    else
        {
        fDynamicEndpoint = FALSE;
        }
    return RPC_S_OK;
}


RPC_STATUS
DG_BINDING_HANDLE::ToStringBinding (
    OUT RPC_CHAR __RPC_FAR * __RPC_FAR * StringBinding
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    <return from DG_CASSOCIATION::ToStringBinding>


--*/
{
    CLAIM_MUTEX Lock( BindingMutex );

    if (Association == 0)
        {
        *StringBinding = pDceBinding->StringBindingCompose(
            InqPointerAtObjectUuid()
            );
        if (*StringBinding == 0)
            {
            return RPC_S_OUT_OF_MEMORY;
            }
        return RPC_S_OK;
        }
    else
        {
        return Association->ToStringBinding(
            StringBinding,
            InqPointerAtObjectUuid()
            );
        }
}


RPC_STATUS
DG_BINDING_HANDLE::ResolveBinding (
    IN RPC_CLIENT_INTERFACE __RPC_FAR * RpcClientInterface
    )
/*++

Routine Description:

    Resolve this binding.

Arguments:

    RpcClientInterface - Interface info used to resolve the endpoint.

Return Value:

    RPC_S_OK
    <return from DCE_BINDING::ResolveEndpointIfNecessary>

--*/
{
    CLAIM_MUTEX Lock( BindingMutex );

    LogEvent( SU_HANDLE, EV_RESOLVED, this, Association );

    if ( Association == 0 )
        {
        RPC_STATUS Status;
        Status = pDceBinding->ResolveEndpointIfNecessary(
            RpcClientInterface,
            InqPointerAtObjectUuid(),
            InquireEpLookupHandle(),
            FALSE,
            InqComTimeout(),
            DEFAULT_EPMAP_CALL_TIMEOUT, // CallTimeout
            NULL                        // AuthInfo
            );

        if (Status)
            {
            LogError( SU_HANDLE, EV_STATUS, this, 0, Status );
            }

        return Status;
        }
    return RPC_S_OK;
}


RPC_STATUS
DG_BINDING_HANDLE::BindingReset (
    )
/*++

Routine Description:

    Reset this binding to a 'zero' value.

Arguments:

    <none>

Return Value:

    RPC_S_OK;

--*/
{
    LogEvent( SU_HANDLE, EV_PROC, this, 0, 'R' + (('e' + (('s' + ('e' << 8)) << 8)) << 8), TRUE);

    MutexRequest();

    DisassociateFromServer();

    pDceBinding->MakePartiallyBound();

    if (0 != *InquireEpLookupHandle())
        {
        EpFreeLookupHandle(*InquireEpLookupHandle());
        *InquireEpLookupHandle() = 0;
        }

    MutexClear();
    return RPC_S_OK;
}


RPC_STATUS
DG_BINDING_HANDLE::BindingCopy (
    OUT BINDING_HANDLE  * __RPC_FAR * DestinationBinding,
    IN unsigned int MaintainContext
    )
/*++

Routine Description:

    Creates a copy of this binding handle.

Arguments:

    DestinationBinding - Where to place a pointer to the new binding.

Return Value:

    RPC_S_OK

--*/
{
    RPC_STATUS          Status = RPC_S_OK;
    PDG_BINDING_HANDLE  Binding;
    DCE_BINDING *       NewDceBinding = 0;

    *DestinationBinding = 0;

    Binding = new DG_BINDING_HANDLE(&Status);
    if ( Binding == 0 || Status != RPC_S_OK)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    MutexRequest();

    //
    // If the binding refers to a dynamic endpoint or is used for broadcast calls,
    // then the association may have a more up-to-date DCE_BINDING.
    //
    if (Association)
        {
        NewDceBinding = Association->DuplicateDceBinding();
        }
    else
        {
        NewDceBinding = pDceBinding->DuplicateDceBinding();
        }

    if (!NewDceBinding)
        {
        MutexClear();
        delete Binding;
        return RPC_S_OUT_OF_MEMORY;
        }

    //
    // Clone calls MapAuthLevel which depends on these items, so copy them first.
    //
    Binding->TransportObject    = TransportObject;
    Binding->TransportInterface = TransportInterface;
    Binding->pDceBinding        = NewDceBinding;
    Binding->fDynamicEndpoint   = fDynamicEndpoint;
    Binding->fContextHandle     = MaintainContext;

    Status = Binding->BINDING_HANDLE::Clone( this );
    if (Status != RPC_S_OK)
        {
        MutexClear();
        delete Binding;
        Binding = 0;
        return Status;
        }

    //
    //  If we clone a binding handle with the UNIQUE option set, we want
    // to use a separate association.
    //
    if (Association && !Association->fLoneBindingHandle)
        {
        Binding->Association = Association;
        Binding->Association->IncrementBindingRefCount( MaintainContext );
        }
    else
        {
        Binding->Association = 0;
        }

    MutexClear();

    *DestinationBinding = (BINDING_HANDLE  *) Binding;

    if (MaintainContext)
        {
        //
        // We've created a context handle; ensure the keep-alive proc is active.
        //
        DelayedProcedures->Add(ContextHandleTimer, CXT_HANDLE_SWEEP_INTERVAL, FALSE);
        }
    return RPC_S_OK;
}


PDG_CCONNECTION
DG_BINDING_HANDLE::GetReplacementConnection(
    PDG_CCONNECTION OldConnection,
    PRPC_CLIENT_INTERFACE Interface
    )
{
    BOOL fBroadcast = FALSE;

    CLAIM_MUTEX Lock( BindingMutex );

    if (OldConnection->CurrentCall->IsBroadcast())
        {
        fBroadcast = TRUE;
        }

    if (OldConnection->Association == Association)
        {
        BOOL Dynamic = fDynamicEndpoint;

        Association->SetErrorFlag();

        //
        // If the binding handle has no object ID, releasing the current
        // endpoint would mean all mgmt calls on the new connection would fail.
        //
        if (IsMgmtIfUuid(&Interface->InterfaceId.SyntaxGUID))
            {
            fDynamicEndpoint = FALSE;
            }

        DisassociateFromServer();

        fDynamicEndpoint = (boolean) Dynamic;
        }

    if (!Association && RPC_S_OK != FindOrCreateAssociation(Interface, TRUE, fBroadcast))
        {
        return 0;
        }

    RPC_STATUS Status;
    return Association->AllocateConnection(this,
                                           OldConnection->InqAuthInfo(),
                                           OldConnection->ThreadId,
                                           OldConnection->CurrentCall->pAsync ? TRUE : FALSE,
                                           &Status
                                           );
}


void
DG_BINDING_HANDLE::DisassociateFromServer()
{
    PDG_CASSOCIATION TempAssociation;

    LogEvent(SU_HANDLE, EV_DISASSOC, this, Association, 0, TRUE);

    MutexRequest();

    TempAssociation = Association;
    Association = 0;

    //
    // This frees memory while holding the mutex - not ideal..
    // One could modify DCE_BINDING::MakePartiallyBound to return the old
    // endpoint so we can delete it outside the mutex.
    //
    if (fDynamicEndpoint)
        {
        pDceBinding->MakePartiallyBound();
        }

    MutexClear();

    if (TempAssociation != 0)
        {
        TempAssociation->DecrementBindingRefCount(fContextHandle);
        }
}


unsigned long
DG_BINDING_HANDLE::MapAuthenticationLevel (
    IN unsigned long AuthenticationLevel
    )
{
    if (AuthenticationLevel == RPC_C_AUTHN_LEVEL_CONNECT ||
        AuthenticationLevel == RPC_C_AUTHN_LEVEL_CALL )
        {
        return(RPC_C_AUTHN_LEVEL_PKT);
        }

    // This is an additional mapping for the reliable DG protocols
    // (i.e. Falcon/RPC). This protocols only use the following
    // three levels: RPC_C_AUTHN_LEVEL_NONE           1
    //               RPC_C_AUTHN_LEVEL_PKT_INTEGRITY  5
    //               RPC_C_AUTHN_LEVEL_PKT_PRIVACY    6
    if (TransportInterface->IsMessageTransport)
       {
       if (AuthenticationLevel == RPC_C_AUTHN_LEVEL_DEFAULT)
          {
          return RPC_C_AUTHN_LEVEL_NONE;
          }

       if (  (AuthenticationLevel > RPC_C_AUTHN_LEVEL_NONE)
          && (AuthenticationLevel < RPC_C_AUTHN_LEVEL_PKT_PRIVACY) )
          {
          return RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
          }
       }

    return(AuthenticationLevel);
}


BOOL
DG_BINDING_HANDLE::SetTransportAuthentication(
                      IN  unsigned long  ulAuthenticationLevel,
                      IN  unsigned long  ulAuthenticationService,
                      OUT RPC_STATUS    *pStatus )
//  Routine Description:
//
//    Do transport specific security for one of the datagram transports.
//    This is currently only for the Falcon transport.
//
//  Return Values:
//
//    TRUE   -- Continue with the RPC level authenticaion.
//
//    FALSE  -- This setting is just for the transport, so don't continue
//              setting RPC level authenticaion.
//
{
   BOOL  fContinue;


   if (RPC_C_AUTHN_NONE == ulAuthenticationService)
      {
      // RPC_C_AUTHN_NONE is a special case that is applied to both RPC and transport
      // authentication.
      *pStatus = SetTransportOption(RPC_C_OPT_MQ_AUTHN_SERVICE,ulAuthenticationService);
      fContinue = TRUE;
      }
   else
      {
      *pStatus = SetTransportOption(RPC_C_OPT_MQ_AUTHN_SERVICE,ulAuthenticationService);

      if (RPC_S_OK == *pStatus)
         {
         *pStatus = SetTransportOption(RPC_C_OPT_MQ_AUTHN_LEVEL,ulAuthenticationLevel);
         fContinue = FALSE;
         }
      else
         {
         *pStatus = RPC_S_CANNOT_SUPPORT;
         fContinue = TRUE;
         }
      }

   return fContinue;
}



DG_CASSOCIATION::DG_CASSOCIATION(
    IN     RPC_DATAGRAM_TRANSPORT * a_Transport,
    IN     LONG                     a_AssociationFlag,
    IN     DCE_BINDING *            a_DceBinding,
    IN     BOOL                     a_Unique,
    IN OUT RPC_STATUS *             pStatus
    ) :
    Mutex               ( pStatus ),
    TransportInterface  ( a_Transport ),
    AssociationFlag     ( a_AssociationFlag ),
    pDceBinding         ( a_DceBinding ),
    CurrentPduSize      ( a_Transport->BasePduSize ),
    fLoneBindingHandle  ( (boolean) a_Unique ),
    RemoteWindowSize    ( 1 ),
    ServerAddress       ( 0 ),
    ServerBootTime      ( 0 ),
    ReferenceCount      ( 0 ),
    BindingHandleReferences( 0 ),
    InternalTableIndex  ( -1 ),
    KeepAliveHandle     ( 0 ),
    fServerSupportsAsync(FALSE),
    fErrorFlag          (FALSE)
/*++

Remarks:

    Notice that the object is initialized so that the destructor can be called
    even if the constructor bails out early.

Arguments:

    pDceBinding - DCE_BINDING that we are associated with
    pStatus     - where failure codes go; should be RPC_S_OK on entry

--*/
{
    ObjectType = DG_CASSOCIATION_TYPE;

    LogEvent(SU_CASSOC, EV_CREATE, this, 0, *pStatus);

    ResolvedEndpoint = NULL;

    if (*pStatus != RPC_S_OK)
        {
        LogError(SU_CASSOC, EV_CREATE, this, 0, *pStatus);
        return;
        }

    ServerAddress = this + 1;

    ResolvedEndpoint = new RPC_CHAR[1+TransportInterface->EndpointStringSize];
    if (!ResolvedEndpoint)
        {
        *pStatus = RPC_S_OUT_OF_MEMORY;
        return;
        }

    *pStatus = TransportInterface->InitializeAddress(ServerAddress,
                                                     pDceBinding->InqNetworkAddress(),
                                                     pDceBinding->InqEndpoint(),
                                                     TRUE, // use cache
                                                     ( a_AssociationFlag & BROADCAST) ? TRUE : FALSE
                                                     );
    if (*pStatus == RPC_P_FOUND_IN_CACHE)
        {
        *pStatus = RPC_S_OK;
        }

    if (*pStatus)
        {
        return;
        }

    LogEvent(SU_CASSOC, EV_START, this);

    *pStatus = ActiveAssociations->Add( this );
    if (*pStatus)
        {
        LogError(SU_CASSOC, EV_START, this, 0, *pStatus);
        return;
        }

    //
    // If this was created by a UNIQUE binding handle, we want connection keep-alives
    // even though no context handles point to it.  This will keep our connection
    // alive on the server.
    //
    IncrementBindingRefCount( fLoneBindingHandle );
    if (fLoneBindingHandle)
        {
        DelayedProcedures->Add(ContextHandleTimer, CXT_HANDLE_SWEEP_INTERVAL, FALSE);
        }

    LastReceiveTime = GetTickCount();
}


DG_CASSOCIATION::~DG_CASSOCIATION()
/*++

Routine Description:

    Destructor for a DG_CASSOCIATION. This will free up the cached DG_CCALL
    and deregister us from the transport.

Arguments:

    <none>

Return Value:

    <none>

--*/
{
    LogEvent(SU_CASSOC, EV_DELETE, this);

    ASSERT( !InvalidHandle(DG_CASSOCIATION_TYPE) );

    PDG_CCONNECTION Connection;
    DictionaryCursor cursor;

    //
    // Delete all calls for this association..
    //
    InactiveConnections.Reset(cursor);
    while ( (Connection = InactiveConnections.Next(cursor)) != 0 )
        {
        InactiveConnections.Delete(Connection->AssociationKey);
        Connection->CancelDelayedAck();
        delete Connection;
        }

   delete pDceBinding;
   delete ResolvedEndpoint;
   delete KeepAliveHandle;

#if 0
   char * FirstAddress;
   char * SecondAddress;

   FirstAddress =  (char *) (this + 1);
   SecondAddress = FirstAddress + TransportInterface->AddressSize;

   ASSERT( ServerAddress == FirstAddress || ServerAddress == SecondAddress );

   TransportInterface->CloseAddress( FirstAddress );

   if (ServerAddress == SecondAddress)
       {
       TransportInterface->CloseAddress( SecondAddress );
       }
#endif
}


RPC_STATUS
DG_CASSOCIATION::ToStringBinding (
    OUT RPC_CHAR * * StringBinding,
    IN RPC_UUID *    ObjectUuid
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

    ObjectUuid - Supplies the object uuid of the binding handle which
        is requesting that we create a string binding.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY

--*/
{
    CLAIM_MUTEX Lock(Mutex);

    *StringBinding = pDceBinding->StringBindingCompose(ObjectUuid);
    if (*StringBinding == 0)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    return RPC_S_OK;
}


BOOL
OptionalStringsEqual(
    RPC_CHAR * String1,
    RPC_CHAR * String2
    )
/*++

Routine Description:

    Compares two strings, checking for NULL pointers.

Arguments:

    the strings

Return Value:

    TRUE if they are equal
    FALSE if they differ

--*/

{
    if (String1 == String2)
        {
        return TRUE;
        }

    if (!String1 || !String2)
        {
        return FALSE;
        }

    if (0 == RpcpStringCompare(String1, String2))
        {
        return TRUE;
        }

    return FALSE;
}


BOOL
DG_CASSOCIATION::ComparePartialBinding(
    PDG_BINDING_HANDLE Binding,
    void * InterfaceInformation
    )
/*++

Routine Description:

    Checks compatibility between the association and a partially-bound handle.

Arguments:

    Binding - the binding handle

    InterfaceInformation - a pointer to the RPC_INTERFACE to be used

Return Value:

    TRUE if the association is compatible
    FALSE if not

--*/

{
    RPC_CHAR * String1;
    RPC_CHAR * String2;

    // We do not need to take a mutex since this funcitons is called from
    // DG_ASSOCIATION_TABLE::Find only, where an exclusive mutex is taken.
    // CLAIM_MUTEX lock( Mutex );

    if (FALSE == OptionalStringsEqual(
                     pDceBinding->InqRpcProtocolSequence(),
                     Binding->pDceBinding->InqRpcProtocolSequence()
                     ))
        {
        return FALSE;
        }

    if (FALSE == OptionalStringsEqual(
                     pDceBinding->InqNetworkAddress(),
                     Binding->pDceBinding->InqNetworkAddress()
                     ))
        {
        return FALSE;
        }

    if (FALSE == OptionalStringsEqual(
                     pDceBinding->InqNetworkOptions(),
                     Binding->pDceBinding->InqNetworkOptions()
                     ))
        {
        return FALSE;
        }

    RPC_UUID Object;
    Binding->InquireObjectUuid(&Object);

    return InterfaceAndObjectDict.Find(InterfaceInformation, &Object);
}


BOOL
DG_CASSOCIATION::AddInterface(
    void *     InterfaceInformation,
    RPC_UUID * ObjectUuid
    )
/*++

Routine Description:

    Declares that this association supports the given <interface, object uuid>
    pair.

Arguments:

    InterfaceInformation - a pointer to the RPC_INTERFACE

    ObjectUuid - the object UUID

Return Value:

    TRUE if the pair was added to the dictionary
    FALSE if an error occurred

--*/

{
    CLAIM_MUTEX Lock(Mutex);

    return InterfaceAndObjectDict.Insert(InterfaceInformation, ObjectUuid);
}


BOOL
DG_CASSOCIATION::RemoveInterface(
    void *     InterfaceInformation,
    RPC_UUID * ObjectUuid
    )
/*++

Routine Description:

    Declares that this association no longer supports the given
    <interface, object uuid> pair.

Arguments:

    InterfaceInformation - a pointer to the RPC_INTERFACE

    ObjectUuid - the object UUID


Return Value:

    TRUE if the pair was in the dictionary
    FALSE if not

--*/

{
    CLAIM_MUTEX Lock(Mutex);

    return InterfaceAndObjectDict.Delete(InterfaceInformation, ObjectUuid);
}


DG_CCONNECTION::DG_CCONNECTION(
    IN     PDG_CASSOCIATION    a_Association,
    IN     const CLIENT_AUTH_INFO *  a_AuthInfo,
    IN OUT RPC_STATUS *        pStatus
    ) :
    DG_COMMON_CONNECTION    (a_Association->TransportInterface, pStatus),
    Association             (a_Association),
    AuthInfo                (a_AuthInfo, pStatus),
    AssociationKey          (-1),
    TimeStamp               (0),
    SecurityContextId       (0),
    BindingHandle           (0),
    ThreadId                (0),
    CachedCalls             (0),
    ActiveCallHead          (0),
    ActiveCallTail          (0),
    CurrentCall             (0),
    AckPending              (0),
    AckOrphaned             (FALSE),
    SecurityBuffer          (0),
    SecurityBufferLength    (0),
    ServerResponded         (FALSE),
    CallbackCompleted       (FALSE),
    fServerSupportsAsync    (a_Association->fServerSupportsAsync),
    fSecurePacketReceived   (FALSE),
    InConnectionTable       (FALSE),
    fBusy                 (FALSE),
    PossiblyRunDown         (FALSE),
    fAutoReconnect          (FALSE),
    fError                  (FALSE),
    DelayedAckTimer         (DelayedAckFn, 0)
{
    ObjectType = DG_CCONNECTION_TYPE;
    LogEvent(SU_CCONN, EV_CREATE, this, a_Association, *pStatus);

    InterlockedIncrement(&ClientConnectionCount);

    if (RPC_S_OK != *pStatus)
        {
        return;
        }

    CurrentPduSize   = Association->CurrentPduSize;
    RemoteWindowSize = Association->RemoteWindowSize;

    *pStatus = UuidCreate((UUID *) &ActivityNode.Uuid);
    if (*pStatus == RPC_S_UUID_LOCAL_ONLY)
        {
        *pStatus = RPC_S_OK;
        }

    if (*pStatus)
        {
        return;
        }

    if (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        *pStatus = InitializeSecurityContext();

        if (*pStatus == RPC_P_CONTINUE_NEEDED ||
            *pStatus == RPC_P_COMPLETE_NEEDED ||
            *pStatus == RPC_P_COMPLETE_AND_CONTINUE)
            {
            *pStatus = RPC_S_OK;
            }
        }

    if (*pStatus)
        {
        LogError(SU_CCONN, EV_SEC_INIT1, this, IntToPtr(*pStatus), I_RpcGetExtendedError());
        return;
        }
}

DG_CCONNECTION::~DG_CCONNECTION()
{
    InterlockedDecrement(&ClientConnectionCount);
    LogEvent(SU_CCONN, EV_DELETE, this, Association);

#ifdef DEBUGRPC
    BOOL Cancelled = DelayedProcedures->Cancel(&DelayedAckTimer);

    ASSERT( !Cancelled );
#endif

    while ( AckPending )
        {
        Sleep(10);
        }

    while (CachedCalls)
        {
        DG_CCALL * Call = CachedCalls;

        CachedCalls = CachedCalls->Next;

        delete Call;
        }

    if (SecurityBuffer)
        {
        delete SecurityBuffer;
}
}


long
DG_CCONNECTION::DecrementRefCountAndKeepMutex()
{
    Mutex.VerifyOwned();

    long Count = --ReferenceCount;

    LogEvent(SU_CCONN, EV_DEC, this, 0, Count, TRUE);

    // Since this->ThreadId is still nonzero, no other thread will increment
    // the refcount behind our back.

    if (0 == Count)
        {
        TimeStamp = GetTickCount();

        fBusy = TRUE;
        MutexClear();

        fAutoReconnect = FALSE;
        fError         = FALSE;

        Association->ReleaseConnection(this);

        // the association may have been deleted
        }

    return Count;
}

long
DG_CCONNECTION::DecrementRefCount()
{
    long Count = DecrementRefCountAndKeepMutex();

    if (Count > 0)
        {
        MutexClear();
        }

    return Count;
}


void
DG_CCONNECTION::PostDelayedAck(
    )
{
    Mutex.VerifyOwned();

    LogEvent(SU_CCONN, EV_PROC, this, IntToPtr((AckOrphaned << 16) | AckPending), 0x41736f50);

    if (!AckPending)
        {
        IncrementRefCount();

        ++AckPending;
        DelayedAckTimer.Initialize(DelayedAckFn, this);
        DelayedProcedures->Add(&DelayedAckTimer, TWO_SECS_IN_MSEC, TRUE);
        }
}

void
DelayedAckFn(
    void * parm
    )
{
    PDG_CCONNECTION(parm)->SendDelayedAck();
}

void
DG_CCONNECTION::SendDelayedAck()
{
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 1 ), this );
    MutexRequest();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 2 ), this );

    LogEvent(SU_CCONN, EV_PROC, this, IntToPtr((AckOrphaned << 16) | AckPending), 0x41646e53);

    if (AckOrphaned)
        {
        AckOrphaned = FALSE;
        DecrementRefCount();
        return;
        }

    ASSERT( AckPending == 1 );

    //
    // Keep DG_CASSOCIATION::AllocateConnection() from taking the connection
    // once AckPending drops to zero.
    //
    fBusy = TRUE;
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 3 ), this );
    --AckPending;
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 4 ), this );
    DecrementRefCountAndKeepMutex();
    CurrentCall->SendAck();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 5 ), this );
    CurrentCall->DecrementRefCount();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 6 ), this );
}

void
DG_CCONNECTION::CancelDelayedAck(
                                 BOOL Flush
                                 )
{
    boolean Cancelled;

    if (Flush)
        {
        if (!MutexTryRequest())
            {
            return;
            }
        }
    else
        {
        MutexRequest();
        }

    ASSERT( AckPending == 0 || AckPending == 1 );

    Cancelled = (boolean) DelayedProcedures->Cancel(&DelayedAckTimer);

    LogEvent(SU_CCONN, EV_PROC, this, IntToPtr((Cancelled << 16) | AckPending), 0x416e6143);

                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 7 ), this, (PVOID) Cancelled );

    if (AckPending)
        {
        if (Flush)
            {
            CurrentCall->SendAck();
            }

        if (Cancelled)
            {
            // the proc was queued and had not yet fired
            //
            DecrementRefCountAndKeepMutex();
            }
        else
            {
            // the proc was called but had not yet taken the connection mutex.
            // some callers of this procedure already hold the mutex, so we can't release it
            // and let the othre thread run.  So we set this flag to let it know not to send
            // the ack.  There is no need to keep a count: there is only one delayed-procedure
            // thread, so only one such proc can be outstanding at a time.

            // This assert doesn't work: if a proc is orphaned, then AckPending is TRUE.
            // Until that thread finishes, every time another thread calls CancelDelayedAck
            // it will come here.
            //
            // ASSERT( AckOrphaned == FALSE );

            AckOrphaned = TRUE;
            }

        --AckPending;
        CurrentCall->DecrementRefCount();
        }
    else
        {
        if (Cancelled)
            {
            ASSERT( 0 && "delayed ack queued but AckPending == 0" );
            }
        else
            {
            // The proc was not queued, or already ran to completion
            //
            }
        MutexClear();
        }
}


DG_CCALL::DG_CCALL(
    IN  PDG_CCONNECTION    a_Connection,
    OUT RPC_STATUS *       pStatus
    ) : State                   (CallInit),
    Connection              (a_Connection),
    InterfacePointer        (0),
    DelayedSendPending      (0),
    CancelPending           (FALSE),

#pragma warning(disable:4355)
    TransmitTimer           (DelayedSendProc, this),
#pragma warning(default:4355)

    DG_PACKET_ENGINE( DG_REQUEST,
                      DG_PACKET::AllocatePacket(a_Connection->TransportInterface->ExpectedPduSize),
                      pStatus )
{

    Previous = Next = 0;

    ObjectType = DG_CCALL_TYPE;
    pAsync = 0;

    InterlockedIncrement(&ClientCallCount);

    if (*pStatus != RPC_S_OK)
        {
        return;
        }

    CancelEventId = 1;

    ReadConnectionInfo(a_Connection, 0);

    pSavedPacket->Header.ActivityHint  = 0xffff;

    LogEvent(SU_CCALL, EV_CREATE, this, a_Connection);
}

DG_CCALL::~DG_CCALL()
{
    LogEvent(SU_CCALL, EV_DELETE, this, Connection);
    InterlockedDecrement(&ClientCallCount);
}

inline RPC_STATUS
DG_CCALL::GetInitialBuffer(
    IN OUT RPC_MESSAGE * Message,
    IN UUID *MyObjectUuid
    )
{
    AsyncStatus = RPC_S_ASYNC_CALL_PENDING;

    Message->Handle = (RPC_BINDING_HANDLE) this;

    Next = DG_CCALL_NOT_ACTIVE;

    if (MyObjectUuid)
        {
        UuidSpecified = 1;
        RpcpMemoryCopy(&ObjectUuid, MyObjectUuid, sizeof(UUID));
        }
    else if (Connection->BindingHandle->InqIfNullObjectUuid() == 0)
        {
        UuidSpecified = 1;
        RpcpMemoryCopy(&ObjectUuid,
                       Connection->BindingHandle->InqPointerAtObjectUuid(),
                       sizeof(UUID));
        }
    else
        {
        UuidSpecified = 0;
        }

    if (GetTickCount() - Connection->TimeStamp > (3 * 60 * 1000))
        {
        Connection->PossiblyRunDown = TRUE;
        }

    RPC_STATUS Status = GetBuffer(Message);

    if (Status)
        {
        Connection->MutexRequest();
        DecrementRefCount();
        }

    return Status;
}

long
DG_CCALL::DecrementRefCount()
{
    long Count = DecrementRefCountAndKeepMutex();

    if (Count > 0)
        {
        Connection->MutexClear();
        }

    return Count;
}

long
DG_CCALL::DecrementRefCountAndKeepMutex()
{
    Connection->Mutex.VerifyOwned();

    --ReferenceCount;

    LogEvent(SU_CCALL, EV_DEC, this, 0, ReferenceCount);

    if (ReferenceCount == 0)
        {
        ASSERT( !DelayedSendPending );

        if (SourceEndpoint)
            {
            EndpointManager->ReleaseEndpoint(SourceEndpoint);
            SourceEndpoint = 0;
            }

        TimeStamp = GetTickCount();

//        ASSERT( !LastReceiveBuffer );

//        CheckForLeakedPackets();

        SetState(CallInit);

        Connection->EndCall(this);
        Connection->AddCallToCache(this);

        return Connection->DecrementRefCountAndKeepMutex();
        }
    else
        {
        return 1;
        }
}


RPC_STATUS
DG_CCONNECTION::TransferCallsToNewConnection(
    PDG_CCALL FirstCall,
    PDG_CCONNECTION NewConnection
    )
{
    PDG_CCALL Call;
    PDG_CCALL NextCall;

    int Count = 0;

    for (Call = FirstCall; Call; Call = NextCall)
        {
        LogError(SU_CCONN, EV_TRANSFER, this, Call);

        NextCall = Call->Next;

        EndCall(Call);
        Count = DecrementRefCountAndKeepMutex();

        NewConnection->BeginCall(Call);
        NewConnection->IncrementRefCount();

        Call->SwitchConnection(NewConnection);
        }

    //
    // AllocateConnection() incremented the refcount so now we have one ref too many.
    //
    NewConnection->DecrementRefCountAndKeepMutex();

    // <this> may have been deleted, I'm not sure.

    if (Count)
        {
        MutexClear();
        }

    NewConnection->fAutoReconnect = TRUE;

    return RPC_S_OK;
}


void
DG_CASSOCIATION::DeleteIdleConnections(
    long CurrentTime
    )
{
    DictionaryCursor cursor;

    if (CurrentTime - LastScavengeTime < IDLE_CCONNECTION_SWEEP_INTERVAL )
        {
        return;
        }

    if (fLoneBindingHandle)
        {
        //
        // This was created by a binding that wanted exclusive use of the association.
        // The way the cluster guys are using it, retiring connections  would only be
        // an intrusion.
        //
        return;
        }

    long ContextHandles = ActiveAssociations->GetContextHandleCount(this);

    MutexRequest();

    if (CurrentTime - LastScavengeTime < IDLE_CCONNECTION_SWEEP_INTERVAL )
        {
        MutexClear();
        return;
        }

    InactiveConnections.Reset(cursor);

    DG_CCONNECTION * Head = 0;
    DG_CCONNECTION * Node = InactiveConnections.Next(cursor);

    //
    // We should never see a context handle on an association with no connections.
    // We preserve one connection on the association so that we can send keep-alives.
    //
    if (ContextHandles > 0 && ActiveConnections.Size() == 0)
        {
        ASSERT( Node );

        Node = InactiveConnections.Next(cursor);
        }

    while (Node)
        {
        if (CurrentTime - Node->TimeStamp > IDLE_CCONNECTION_LIFETIME)
            {
            InactiveConnections.Delete(Node->AssociationKey);

            Node->Next = Head;
            Head = Node;
            }

        Node = InactiveConnections.Next(cursor);
        }

    LastScavengeTime = CurrentTime;

    MutexClear();

    while (Head)
        {
        Node = Head->Next;

        Head->CancelDelayedAck();
        delete Head;

        Head = Node;
        }
}


DG_CCALL *
DG_CCONNECTION::FindIdleCalls(
    long CurrentTime
    )
{
    Mutex.VerifyOwned();

    if (CurrentTime - LastScavengeTime < IDLE_CCALL_SWEEP_INTERVAL )
        {
        return 0;
        }

    LastScavengeTime = CurrentTime;


    DG_CCALL * Node;

    for (Node = CachedCalls; Node; Node = Node->Next)
        {
        if (CurrentTime - Node->TimeStamp > IDLE_CCALL_LIFETIME )
            {
            break;
            }
        }

    if (Node)
        {
        DG_CCALL * Next = Node->Next;
        Node->Next = 0;
        Node = Next;
        }

    return Node;
}


RPC_STATUS
DG_CCALL::GetBuffer(
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

    This method is called to actually allocate memory for an rpc call.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call.
    ObjectUuid - Ignored

Return Value:

    RPC_S_OUT_OF_MEMORY
    RPC_S_OK

--*/
{
    LogEvent(SU_CCALL, EV_PROC, this, IntToPtr(Message->BufferLength), 'G' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));

    RPC_STATUS Status = CommonGetBuffer(Message);

    LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);
    if (Status)
        {
        LogError(SU_CCALL, EV_STATUS, this, 0, Status);
        }

    return Status;
}


void
DG_CCALL::FreeBuffer(
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    This is called by stubs in order to free a marshalling buffer.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call.

Return Value:

    <none>

--*/
{
    FreePipeBuffer(Message);

    Connection->MutexRequest();
    DecrementRefCount();
}

void
DG_CCALL::FreePipeBuffer (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    Called by stubs to free a buffer used for marshalling pipe data.

Arguments:

    Message - description of the buffer

Return Value:

z    none

--*/

{
    LogEvent(SU_CCALL, EV_PROC, this, Message->Buffer, 'F' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));

    CommonFreeBuffer(Message);
}


RPC_STATUS
DG_CCALL::ReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    )
/*++

Routine Description:

    Called by stubs to change the size of a pipe buffer.  If possible, the
    buffer will be reallocated in place; otherwise, we will allocate a new
    buffer and duplicate the existing data.

Arguments:

    Message - (on entry) describes the existing  buffer
              (on exit)  describes the new buffer

    NewSize - new requested buffer size

Return Value:

    mainly RPC_S_OK for success or RPC_S_OUT_OF_MEMORY for failure

--*/

{
    LogEvent(SU_CCALL, EV_PROC, this, Message->Buffer, 'R' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));

    RPC_STATUS Status = CommonReallocBuffer(Message, NewSize);

    LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);
    if (Status)
        {
        LogError(SU_CCALL, EV_STATUS, this, 0, Status);
        }

    return Status;
}


void
DG_CCALL::BuildNcaPacketHeader(
    PNCA_PACKET_HEADER Header,
    PRPC_MESSAGE       Message
    )
/*++

Routine Description:

    Given an input RPC_MESSAGE, builds a nca packet header.

Arguments:

    pNcaPacketHeader - Where to build the new packet header.

    Message - The original RPC_MESSAGE.

Return Value:

    <none>

--*/
{
    PRPC_CLIENT_INTERFACE pCli = (PRPC_CLIENT_INTERFACE) (Message->RpcInterfaceInformation);
    RPC_UUID * pUuid = (RPC_UUID *) (&(pCli->InterfaceId.SyntaxGUID));

    Header->InterfaceId = *pUuid;

    if (UuidSpecified)
        {
        RpcpMemoryCopy(&(Header->ObjectId), &ObjectUuid, sizeof(UUID));
        }
    else
        {
        RpcpMemorySet(&Header->ObjectId, 0, sizeof(UUID));
        }

    Header->InterfaceVersion.MajorVersion = pCli->InterfaceId.SyntaxVersion.MajorVersion;
    Header->InterfaceVersion.MinorVersion = pCli->InterfaceId.SyntaxVersion.MinorVersion;

    Header->SequenceNumber  = SequenceNumber;
    Header->OperationNumber = (unsigned short) Message->ProcNum;
    Header->ServerBootTime  = Connection->Association->ServerBootTime;

    Header->InterfaceHint  = 0xffff;
    Header->PacketType     = DG_REQUEST;
    Header->PacketFlags    = (unsigned char) RpcToPacketFlagsArray[Message->RpcFlags & RPC_NCA_PACKET_FLAGS];
    Header->PacketFlags2   = 0;
}


inline RPC_STATUS
DG_CCONNECTION::UpdateServerAddress(
    IN DG_PACKET *          Packet,
    IN DG_TRANSPORT_ADDRESS Address
    )
{
    ServerResponded = TRUE;

    Association->CurrentPduSize   = CurrentPduSize;
    Association->RemoteWindowSize = RemoteWindowSize;

    return Association->UpdateAssociationWithAddress( Packet, Address );
}


void
DG_CCALL::SendAck(
    )
{
    LogEvent(SU_CCALL, EV_ACK, this);

    pSavedPacket->Header.PacketType    = DG_ACK;
    pSavedPacket->SetPacketBodyLen(0);
    pSavedPacket->SetFragmentNumber(ReceiveFragmentBase);

    SetSerialNumber(&pSavedPacket->Header, SendSerialNumber);

    Connection->SealAndSendPacket(SourceEndpoint, 0, &pSavedPacket->Header, 0);

    if (FALSE == SourceEndpoint->Async)
        {
        SourceEndpoint->Flags |= PENALTY_BOX;
        }
}

inline RPC_STATUS
DG_CCALL::SendPing(
    )
{
    pSavedPacket->Header.PacketType = DG_PING;
    pSavedPacket->Header.PacketFlags &= DG_PF_IDEMPOTENT;
    pSavedPacket->SetPacketBodyLen(0);

    AddSerialNumber(&pSavedPacket->Header);

    unsigned Frag = (pSavedPacket->Header.PacketType << 16) | pSavedPacket->GetFragmentNumber();
    LogEvent(SU_CCALL, EV_PKT_OUT, this, 0, Frag);

    RPC_STATUS Status = Connection->SealAndSendPacket(SourceEndpoint, 0, &pSavedPacket->Header, 0);

    ++SendSerialNumber;

    return Status;
}


PDG_CCONNECTION
MapGenericHandleToConnection(
    handle_t Handle,
    UUID * Uuid
    )
{
    PDG_CCONNECTION Connection;

    ASSERT( Handle );

    if (PMESSAGE_OBJECT(Handle)->Type(DG_CCONNECTION_TYPE))
        {
        Connection = PDG_CCONNECTION(Handle);

        Connection->MutexRequest();
        }
    else
        {
        ASSERT( PMESSAGE_OBJECT(Handle)->Type(DG_CALLBACK_TYPE) );

        Connection = PDG_CLIENT_CALLBACK(Handle)->Connection;
        if (Connection)
            {
            Connection->MutexRequest();
            }
        else
            {
            Connection = ClientConnections->Lookup( (RPC_UUID *) Uuid );
            PDG_CLIENT_CALLBACK(Handle)->Connection = Connection;
            }
        }

    return Connection;
}

#define CCC_SEQUENCE    0x0001
#define CCC_CAS         0x0002
#define CCC_AUTH        0x0004
#define CCC_ASYNC_OK    0x0008
#define CCC_AUTH_MORE   0x0010

void
ConvCore(
    DWORD           Bits,
    PRPC_ASYNC_STATE AsyncHandle,
    handle_t        Handle,
    UUID *          Uuid,
    unsigned long   ServerBootTime,
    byte *          InData,
    long            InLength,
    long            OutMaxLength,
    unsigned long * SequenceNumber,
    UUID *          pCASUuid,
    byte *          OutData,
    long *          pOutLength,
    error_status_t *Status
    )
{
    if (pOutLength)
        {
        *pOutLength = 0;
        }

    PDG_CCONNECTION Connection = MapGenericHandleToConnection(Handle, Uuid);

    LogEvent(SU_CCONN, EV_CALLBACK, Connection, 0, Bits);

    if (!Connection)
        {
        *Status = NCA_STATUS_BAD_ACTID;

        RpcAsyncCompleteCall(AsyncHandle, 0);
        return;
        }

    //
    // See if this activity id has a call in progress.
    //
    if (Connection->ActivityNode.CompareUuid(Uuid) != 0)
        {
        Connection->MutexClear();
        *Status = NCA_STATUS_BAD_ACTID;
        RpcAsyncCompleteCall(AsyncHandle, 0);
        return;
        }

    *Status = RPC_S_OK;

    if (Connection->Association->ServerBootTime == 0)
        {
        //
        // the server is responding to our first call.
        //
        Connection->Association->ServerBootTime       = ServerBootTime;
        }
    else if (Connection->Association->ServerBootTime != ServerBootTime)
        {
        //
        // The server crashed.
        //
        Connection->MutexClear();
        *Status = NCA_STATUS_YOU_CRASHED;
        RpcAsyncCompleteCall(AsyncHandle, 0);
        return;
        }

    if (Bits & CCC_ASYNC_OK)
        {
        Connection->EnableOverlappedCalls();
        }

    if (Bits & CCC_SEQUENCE)
        {
        *SequenceNumber = Connection->GetSequenceNumber();
        }

    if (Bits & CCC_CAS)
        {
        ASSERT( ActiveAssociations->fCasUuidReady );

        *pCASUuid = ActiveAssociations->CasUuid;
        }

    if (Bits & CCC_AUTH)
        {
        if (Connection->PossiblyRunDown)
            {
            Connection->PossiblyRunDown = FALSE;
            Connection->fSecurePacketReceived = FALSE;
            }

        *Status = MapToNcaStatusCode(
                        Connection->DealWithAuthCallback(
                                    InData,
                                    InLength,
                                    OutData,
                                    OutMaxLength,
                                    pOutLength
                                    )
                        );
        }

    if (Bits & CCC_AUTH_MORE)
        {
        *Status = MapToNcaStatusCode(
                        Connection->DealWithAuthMore(
                                    InLength,
                                    OutData,
                                    OutMaxLength,
                                    pOutLength
                                    )
                        );
        }

    if (RPC_S_OK == *Status)
        {
        Connection->CallbackCompleted = TRUE;
        }

    Connection->MutexClear();
    RpcAsyncCompleteCall(AsyncHandle, 0);
}

void
conv_are_you_there(
    PRPC_ASYNC_STATE AsyncHandle,
    handle_t Handle,
    UUID * Uuid,
    unsigned long ServerBootTime,
    error_status_t *Status
    )
{
    ConvCore(0,                 // bits
             AsyncHandle,
             Handle,
             Uuid,
             ServerBootTime,
             0,                 // in  auth data
             0,                 // in  auth data length
             0,                 // out auth data max length
             0,                 // sequence number
             0,                 // CAS UUID
             0,                 // out auth data
             0,                 // out auth data length
             Status
             );
}


void
conv_who_are_you(
    PRPC_ASYNC_STATE AsyncHandle,
    IN handle_t           Handle,
    IN UUID          *    Uuid,
    IN unsigned long      ServerBootTime,
    OUT unsigned long *   SequenceNumber,
    OUT error_status_t *  Status
    )

/*++

Routine Description:

    This is the conv_who_are_you callback routine that the server will
    call to check if it crashed.

Arguments:

    pUuid - Activity Uuid.

    ServerBootTime - The server's record of its boot time.

    SequenceNumber - We return our record of our sequence number.

    Status - 0 if we think things are ok, else an NCA error code

Return Value:

    <none>
--*/

{
    ConvCore(CCC_SEQUENCE,
             AsyncHandle,
             Handle,
             Uuid,
             ServerBootTime,
             0,                 // in  auth data
             0,                 // in  auth data length
             0,                 // out auth data max length
             SequenceNumber,
             0,                 // CAS UUID
             0,                 // out auth data
             0,                 // out auth data length
             Status
             );
}


void
conv_who_are_you2(
    PRPC_ASYNC_STATE AsyncHandle,
    IN  handle_t            Handle,
    IN  UUID          *     Uuid,
    IN  unsigned long       ServerBootTime,
    OUT unsigned long *     SequenceNumber,
    OUT UUID          *     pCASUuid,
    OUT error_status_t *    Status
    )

/*++

Routine Description:

    This is the conv_who_are_you callback routine that the server will
    call to check if it crashed.

Arguments:


Return Value:

    <none>
--*/

{
    ConvCore(CCC_SEQUENCE | CCC_CAS,
             AsyncHandle,
             Handle,
             Uuid,
             ServerBootTime,
             0,                 // in  auth data
             0,                 // in  auth data length
             0,                 // out auth data max length
             SequenceNumber,
             pCASUuid,
             0,                 // out auth data
             0,                 // out auth data length
             Status
             );
}


void
conv_who_are_you_auth(
    PRPC_ASYNC_STATE AsyncHandle,
    handle_t        Handle,
    UUID *          Uuid,
    unsigned long   ServerBootTime,
    byte *          InData,
    long            InLength,
    long            OutMaxLength,
    unsigned long * SequenceNumber,
    UUID *          pCASUuid,
    byte *          OutData,
    long *          pOutLength,
    error_status_t *Status
    )
{
    ConvCore(CCC_SEQUENCE | CCC_CAS | CCC_AUTH,
             AsyncHandle,
             Handle,
             Uuid,
             ServerBootTime,
             InData,
             InLength,
             OutMaxLength,
             SequenceNumber,
             pCASUuid,
             OutData,
             pOutLength,
             Status
             );
}



void
conv_who_are_you_auth_more(
    PRPC_ASYNC_STATE AsyncHandle,
    handle_t        Handle,
    UUID *          Uuid,
    unsigned long   ServerBootTime,
    long            Index,
    long            OutMaxLength,
    byte *          OutData,
    long *          pOutLength,
    error_status_t *Status
    )
{
    ConvCore(CCC_AUTH_MORE,
             AsyncHandle,
             Handle,
             Uuid,
             ServerBootTime,
             0,
             Index,
             OutMaxLength,
             0,
             0,
             OutData,
             pOutLength,
             Status
             );
}


void
DG_CCONNECTION::EnableOverlappedCalls()
{
    Association->fServerSupportsAsync = TRUE;

    if (FALSE == fServerSupportsAsync)
        {
        fServerSupportsAsync = TRUE;

        MutexRequest();
        MaybeTransmitNextCall();
        MutexClear();
        }
}


RPC_STATUS
DG_CCALL::GetEndpoint(
    DWORD EndpointFlags
    )
{
    SourceEndpoint = EndpointManager->RequestEndpoint(
                   Connection->TransportInterface,
                   (pAsync) ? TRUE : FALSE,
                   EndpointFlags,
                   this
                   );

    if (!SourceEndpoint)
        {
        return RPC_S_OUT_OF_RESOURCES;
        }

    if (pSavedPacket->MaxDataLength < SourceEndpoint->Stats.PreferredPduSize)
        {
        PDG_PACKET NewPacket = DG_PACKET::AllocatePacket(SourceEndpoint->Stats.PreferredPduSize);
        if (!NewPacket)
            {
            EndpointManager->ReleaseEndpoint(SourceEndpoint);
            SourceEndpoint = 0;
            return RPC_S_OUT_OF_MEMORY;
            }

        NewPacket->Header = pSavedPacket->Header;

        FreePacket(pSavedPacket);
        pSavedPacket = NewPacket;
        }

    //
    // If there is a chance that the endpoint has queued ICMP rejects, drain them.
    //
    if (FALSE == SourceEndpoint->Async &&
        (SourceEndpoint->Flags & PENALTY_BOX))
        {
        RPC_STATUS Status;

        do
            {
            PDG_PACKET Packet = 0;
            DG_TRANSPORT_ADDRESS ReceiveAddress = 0;
            unsigned Length = 0;
            void * Buffer = 0;

            Status = Connection->TransportInterface->SyncReceive(
                                    &SourceEndpoint->TransportEndpoint,
                                    &ReceiveAddress,
                                    &Length,
                                    &Buffer,
                                    0
                                    );

            LogEvent( SU_CCALL, EV_PKT_IN, Connection, Buffer, Status);

            if (Buffer)
                {
                Packet = DG_PACKET::FromPacketHeader(Buffer);
                Packet->DataLength = Length;

                FreePacket(Packet);
                }

            if (Status == RPC_P_PORT_DOWN)
                {
                Status = 0;
                }

            }
        while ( !Status );
        }

    SourceEndpoint->Flags &= ~(PENALTY_BOX);

    return 0;
}


RPC_STATUS
DG_CCALL::BeforeSendReceive(
    PRPC_MESSAGE Message
    )
{
    DWORD         EndpointFlags;
    RPC_STATUS    Status;

    NotificationIssued = -1;

    ASSERT( 0 == (Connection->BindingHandle->EndpointFlags & PORT_FOR_MAYBE_CALLS));

    EndpointFlags = Connection->BindingHandle->EndpointFlags;

    if (Message->RpcFlags & RPC_NCA_FLAGS_MAYBE)
        {
        if (FALSE == Connection->Association->TransportInterface->IsMessageTransport)
            {
            EndpointFlags |= PORT_FOR_MAYBE_CALLS;
            }
        }

    Status = GetEndpoint(EndpointFlags);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    Status = Connection->BeginCall(this);
    if (Status != RPC_S_OK)
        {
        EndpointManager->ReleaseEndpoint(SourceEndpoint);
        SourceEndpoint = 0;
        return Status;
        }

    InterfacePointer = (PRPC_CLIENT_INTERFACE) Message->RpcInterfaceInformation;

    UnansweredRequestCount  = 0;

    NewCall();

    //
    // Set transport specific options for this binding handle (if any).
    // NOTE: These options are from RpcBindingSetOption().
    //
    if ( (Connection->BindingHandle->pvTransportOptions)
         && (Connection->Association->TransportInterface->ImplementOptions) )
       {
       Status = Connection->Association->TransportInterface->ImplementOptions(
                                                                SourceEndpoint->TransportEndpoint,
                                                                Connection->BindingHandle->pvTransportOptions);
       }

    //
    // Fill in common fields of the send packet.
    //
    BuildNcaPacketHeader(&pSavedPacket->Header, Message);

    BasePacketFlags = pSavedPacket->Header.PacketFlags;

    SetState(CallQuiescent);

    ForceAck        = FALSE;
    AllArgsSent     = FALSE;
    StaticArgsSent  = FALSE;

    ASSERT( !DelayedSendPending );

//#ifdef NTENV

    if (!pAsync)
        {
        Status = RegisterForCancels(this);
        if (Status != RPC_S_OK)
            {
            Connection->EndCall(this);

            EndpointManager->ReleaseEndpoint(SourceEndpoint);
            SourceEndpoint = 0;

            return Status;
            }
        }
//#endif

    //
    // If this is a call on the "conv" interface, we should set it also.
    //
    PRPC_CLIENT_INTERFACE pCli = (PRPC_CLIENT_INTERFACE) (Message->RpcInterfaceInformation);
    RPC_UUID * pUuid = (RPC_UUID *) (&(pCli->InterfaceId.SyntaxGUID));

    if (0 == pUuid->MatchUuid((RPC_UUID *) &((PRPC_SERVER_INTERFACE) conv_ServerIfHandle)->InterfaceId.SyntaxGUID ))
        {
        BasePacketFlags2 = DG_PF2_UNRELATED;
        if (Previous)
            {
            Previous->ForceAck = TRUE;
            }
        }

    unsigned TimeoutLevel = Connection->BindingHandle->InqComTimeout();

    if (Message->RpcFlags & RPC_NCA_FLAGS_BROADCAST)
        {
        ReceiveTimeout = 3000;
        TimeoutLimit = 1000 * (TimeoutLevel+1)/2;
        }
    else if (TimeoutLevel == RPC_C_BINDING_INFINITE_TIMEOUT)
        {
        ReceiveTimeout = 5000;
        TimeoutLimit = 0x7fffffff;
        }
    else if (Connection->TransportInterface->IsMessageTransport)
        {
        ReceiveTimeout = 5000;
        TimeoutLimit = 300000 + 10000 * ( 1 << TimeoutLevel );
        }
    else
        {
        ReceiveTimeout = 250 + 250 * (TimeoutLevel+1)/2;
        TimeoutLimit = 1000 * ( 1 << TimeoutLevel );
        }

    LastReceiveTime = GetTickCount();

    return Status;
}


RPC_STATUS
DG_CCALL::AfterSendReceive(
    PRPC_MESSAGE Message,
    RPC_STATUS Status
    )
{
    DG_BINDING_HANDLE * OldBinding = 0;

    Connection->Mutex.VerifyOwned();

    PDG_CASSOCIATION Association = Connection->Association;

    CancelDelayedSend();

//#ifdef NTENV

    if (!pAsync)
        {
        EVAL_AND_ASSERT(RPC_S_OK == UnregisterForCancels());
        }

//#endif

    if (RPC_S_OK == Status)
        {
        ASSERT( !Buffer );

        Connection->PossiblyRunDown = FALSE;

        if (0 == (Message->RpcFlags & RPC_NCA_FLAGS_MAYBE))
            {
            Association->ClearErrorFlag();
            }

        // NOTE: No ACK for [message] calls.
        if ( (ForceAck) && !(Message->RpcFlags & RPCFLG_MESSAGE) )
            {
            SendAck();
            }
        else if (Next)
            {
            //
            // Don't ACK because we will transmit the next queued call momentarily.
            //
            }
        else if (0 == (BufferFlags & RPC_NCA_FLAGS_IDEMPOTENT) ||
                 Message->BufferLength > MaxFragmentSize)
            {
            //
            // NOTE: We don't need an ACK for [message] calls...
            //
            if ( !(Message->RpcFlags & RPCFLG_MESSAGE) &&
                 !(Message->RpcFlags & RPC_NCA_FLAGS_MAYBE) )
                {
                ++ReferenceCount;
                LogEvent(SU_CCALL, EV_INC, this, 0, ReferenceCount);
                Connection->PostDelayedAck();
                }
            }
        }
    else
        {
        if (FALSE == SourceEndpoint->Async)
            {
            SourceEndpoint->Flags |= PENALTY_BOX;
            }

        Status = MapErrorCode(Status);

        CleanupSendWindow();
        CleanupReceiveWindow();

        if (RPC_S_SERVER_UNAVAILABLE == Status ||
            RPC_S_UNKNOWN_IF         == Status ||
            RPC_S_CALL_FAILED        == Status ||
            RPC_S_CALL_FAILED_DNE    == Status ||
            RPC_S_COMM_FAILURE       == Status ||
            RPC_S_CALL_CANCELLED     == Status ||
            RPC_S_PROTOCOL_ERROR     == Status
            )
            {
            Connection->fError = TRUE;
            Association->SetErrorFlag();
            OldBinding = Connection->BindingHandle;
            OldBinding->IncrementRefCount();
            }
        }

    SetState(CallComplete);

    pAsync = 0;

    long CurrentTime = GetTickCount();
    DG_CCALL * IdleCalls = Connection->FindIdleCalls(CurrentTime);

    if (Status == RPC_S_OK)
        {
        Connection->MutexClear();

        //
        // Record that this interface is valid for this association.
        //
        Association->AddInterface(Message->RpcInterfaceInformation, &pSavedPacket->Header.ObjectId);
        }
    else
        {
        RPC_UUID Object;

        Object.CopyUuid(&pSavedPacket->Header.ObjectId);
        Association->IncrementRefCount();

        //
        // If the call is dying, we need to free the current buffer here
        // instead of letting NDR do it on the usual schedule.
        // The freeing needs to happen before the counter decrement while
        // this pointer is still valid.
        if (1 == ReferenceCount)
            {
            FreePipeBuffer(Message);
            Message->Handle = 0;
            }
        // Decrementing the reference count may cause the call
        // to be deleted.  Do not touch any of its fields or methods
        // after this.  We are holding connection mutex so the path should
        // be syncronized.
        DecrementRefCount();

        Association->RemoveInterface(Message->RpcInterfaceInformation, &Object);
        Association->DecrementRefCount();
        }

    if (OldBinding)
        {
        OldBinding->DisassociateFromServer();
        OldBinding->DecrementRefCount();
        }

    while (IdleCalls)
        {
        DG_CCALL * Next = IdleCalls->Next;

        delete IdleCalls;

        IdleCalls = Next;
        }

    return Status;
}


RPC_STATUS
DG_CCALL::MapErrorCode(
    RPC_STATUS Status
    )
{
    LogError(SU_CCALL, EV_STATUS, this, 0, Status);

    //
    // Map security errors to access-denied.
    //
    if (0x80090000UL == (Status & 0xffff0000UL))
        {
#ifdef DEBUGRPC
        if (Status != SEC_E_NO_IMPERSONATION     &&
            Status != SEC_E_UNSUPPORTED_FUNCTION )
            {
            PrintToDebugger("RPC DG: mapping security error %lx to access-denied\n", Status);
            }
#endif
        Status = RPC_S_SEC_PKG_ERROR;
        }

    //
    // We have to return CALL_FAILED if all the [in] static parms have
    // been sent, even if they weren't acknowledged.
    //
    if (RPC_P_HOST_DOWN      == Status ||
        RPC_P_PORT_DOWN      == Status ||
        RPC_P_SEND_FAILED    == Status ||
        RPC_P_RECEIVE_FAILED == Status ||
        RPC_P_TIMEOUT        == Status )
        {
        if (Connection->CallbackCompleted &&
            !(BufferFlags & RPC_NCA_FLAGS_IDEMPOTENT) &&
            StaticArgsSent)
            {
            Status = RPC_S_CALL_FAILED;
            }
        else if (Connection->ServerResponded)
            {
            Status = RPC_S_CALL_FAILED_DNE;
            }
        else
            {
            Status = RPC_S_SERVER_UNAVAILABLE;
            }
        }

    return Status;
}


RPC_STATUS
DG_CCALL::SendReceive(
    IN OUT PRPC_MESSAGE Message
    )
{
    LogEvent(SU_CCALL, EV_PROC, this, Message->Buffer, 0x52646e53);

    RPC_STATUS Status;

    ASSERT(  !(Message->RpcFlags & RPC_BUFFER_ASYNC) && !pAsync);

    Connection->MutexRequest();

    Status = BeforeSendReceive(Message);
    if (Status)
        {
        FreeBuffer(Message);

        Connection->MutexClear();

        return Status;
        }

    //
    // [maybe], [maybe, broadcast] and [message] calls.
    //
    if (  (Message->RpcFlags & RPC_NCA_FLAGS_MAYBE)
          || (Message->RpcFlags & RPCFLG_MESSAGE) )
        {
        Message->RpcFlags |= RPC_NCA_FLAGS_MAYBE;

        Status = MaybeSendReceive(Message);

        return AfterSendReceive(Message, Status);
        }

    if (Message->RpcFlags & RPC_NCA_FLAGS_BROADCAST)
        {
        if (Message->BufferLength > SourceEndpoint->Stats.PreferredPduSize)
            {
            FreeBuffer(Message);
            Connection->MutexClear();

            return RPC_S_SERVER_UNAVAILABLE;
            }
        }

    //
    // Send a single burst of packets.
    // An asynchronous call will return to the caller; an ordinary call
    // will loop until the call is complete.
    //
    SetFragmentLengths();

    SetState(CallSendReceive);

    Status = PushBuffer(Message);
    if (Status)
        {
        LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);
        LogError(SU_CCALL, EV_STATUS, this, 0, Status);

        FreePipeBuffer(Message);

        return AfterSendReceive(Message, Status);
        }

    ASSERT( !Message->Buffer );
    ASSERT( !Message->BufferLength );

    while (RPC_S_OK == Status && FALSE == fReceivedAllFragments)
        {
        Status = ReceiveSinglePacket();
        }

    if (Status)
        {
        LogError(SU_CCALL, EV_STATUS, this, 0, Status);
        }

    if (RPC_S_OK == Status)
        {
        Status = AssembleBufferFromPackets(Message, this);
        }

    //
    // Depending upon circumstances, AfterSendReceive() may cause the ccall,
    // the association, and/or the binding handle to be freed.
    //

    SetState(CallQuiescent);

    return AfterSendReceive(Message, Status);
}


RPC_STATUS
DG_CCALL::AttemptAutoReconnect()
{
    RPC_STATUS Status;

    ASSERT( State == CallSend || State == CallSendReceive ||
            (State == CallReceive && !fRetransmitted && SendWindowBase == 0
             ) );

/*

If the call's association has the error flag set, look for a follow-up
association, otherwise create a follow-up association.

link the binding handle to the new association, and ask it for a connection
to be associated with the existing connection's thread ID.  Move this call
and successors to the new connection, send some packets, and return
to the packet loop.

*/
    PDG_CCONNECTION OldConnection = Connection;
    PDG_CCONNECTION NewConnection;

    //
    // To avoid a deadlock, we must release the connection mutex before
    // taking the binding mutex.  The fBusy flag prevents another thread
    // from using it.
    //
    OldConnection->fError  = TRUE;
    OldConnection->fBusy = TRUE;
    OldConnection->MutexClear();

    NewConnection = OldConnection->BindingHandle->GetReplacementConnection(OldConnection, InterfacePointer);
    if (!NewConnection)
        {
        OldConnection->MutexRequest();
        return RPC_S_CALL_FAILED_DNE;
        }

    //
    // We now own NewConnection's mutex.  Transfer calls to be retried.
    //
    OldConnection->MutexRequest();
    Status = OldConnection->TransferCallsToNewConnection(this, NewConnection);

    ASSERT( !Status );

    if (FALSE == SourceEndpoint->Async)
        {
        //
        // Get a fresh endpoint to avoid a race with any ICMP rejects.
        // If that fails, leave the old endpoint in place and bail out of the call.
        //
        DG_ENDPOINT * OldEndpoint = SourceEndpoint;

        SourceEndpoint = 0;

        Status = GetEndpoint(OldEndpoint->Flags);

        OldEndpoint->Flags |= PENALTY_BOX;

        if (Status)
                {
            SourceEndpoint = OldEndpoint;
            return Status;
                }

        EndpointManager->ReleaseEndpoint(OldEndpoint);
            }

    //
    // Attempt the call again.
    //
    LastReceiveTime = GetTickCount();

    Status = SendSomeFragments();

    return Status;
}


RPC_STATUS
DG_CCALL::ReceiveSinglePacket()
{
    RPC_STATUS Status;
    PDG_PACKET Packet = 0;
    DG_TRANSPORT_ADDRESS ReceiveAddress = 0;

    Connection->MutexClear();

    unsigned Length = 0;
    void * Buffer = 0;

    Status = Connection->TransportInterface->SyncReceive(
                            &SourceEndpoint->TransportEndpoint,
                            &ReceiveAddress,
                            &Length,
                            &Buffer,
                            ReceiveTimeout
                            );

    if (Buffer)
        {
        Packet = DG_PACKET::FromPacketHeader(Buffer);
        Packet->DataLength = Length;
        }

    Connection->MutexRequest();

    if (Status == RPC_P_HOST_DOWN)
        {
        RpcpErrorAddRecord( EEInfoGCRuntime,
                            Status,
                            EEInfoDLDG_CCALL__ReceiveSinglePacket10
                            );

        return Status;
        }

    //
    // If the transport tells us the server is not present (ICMP reject)
    // then we can try auto-reconnect - as long as there is no possibility
    // that the server crashed while executing our stub.
    //
    if (Status == RPC_P_PORT_DOWN)
        {
        RpcpErrorAddRecord( EEInfoGCRuntime,
                            Status,
                            EEInfoDLDG_CCALL__ReceiveSinglePacket20,
                            (ULONG) Connection->fAutoReconnect,
                            (ULONG) BufferFlags
                            );

        if (!Connection->fAutoReconnect &&
            (!fRetransmitted || (BufferFlags & RPC_NCA_FLAGS_IDEMPOTENT)))
            {
            Status = AttemptAutoReconnect();
            return Status;
            }

        ASSERT( !Packet && !ReceiveAddress );
        return Status;
        }

    if (Status == RPC_P_OVERSIZE_PACKET)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: packet is too large\n");
#endif
        Packet->Flags |= DG_PF_PARTIAL;
        Status = RPC_S_OK;
        }
    else
        {
        ASSERT( !Packet || Packet->DataLength <= Packet->MaxDataLength );
        }

    if (Status == RPC_S_OK)
        {
        LogEvent(SU_CCALL, EV_PKT_IN, this, (void *) 0, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());

        do
            {
            //
            // Request packets are special.
            //
            if (Packet->Header.PacketType == DG_REQUEST)
                {
                Status = StandardPacketChecks(Packet);
                if (Status)
                    {
                    LogError(SU_CCALL, EV_PKT_IN, this, (void *) 1, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                    FreePacket(Packet);
                    break;
                    }

                if (Packet->Header.AuthProto != 0)
                    {
                    LogError(SU_CCALL, EV_PKT_IN, this, (void *) 2, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                    FreePacket(Packet);
                    break;
                    }

                if (Packet->Flags & DG_PF_PARTIAL)
                    {
                    LogError(SU_CCALL, EV_PKT_IN, this, (void *) 3, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                    FreePacket(Packet);
                    break;
                    }

                LogEvent(SU_CCALL, EV_PKT_IN, this, (void *) 4, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());

                Connection->ServerResponded = TRUE;
                Status = DealWithRequest(Packet, ReceiveAddress);
                if (Status)
                    {
                    //
                    // Make sure that the call times out in a reasonable time period.
                    //
                    if (long(GetTickCount()) - LastReceiveTime > TimeoutLimit)
                        {
                        LogError(SU_CCALL, EV_STATUS, this, (void *) 7, RPC_P_TIMEOUT);

                        SendQuit();
                        return RPC_P_TIMEOUT;
                        }

                    }

                return RPC_S_OK;
                }

            Status = StandardPacketChecks(Packet);
            if (Status)
                {
                LogError(SU_CCALL, EV_PKT_IN, this, (void *) 5, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                FreePacket(Packet);

                if (Status == NCA_STATUS_VERSION_MISMATCH)
                    {
                    Status = 0;
                    }

                break;
                }

            if (Packet->Header.SequenceNumber != SequenceNumber ||
                Connection->ActivityNode.Uuid.MatchUuid(&Packet->Header.ActivityId))
                {
                LogEvent(SU_CCALL, EV_PKT_IN, this, (void *) 6, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                FreePacket(Packet);
                break;
                }

            Status = Connection->UpdateServerAddress(Packet, ReceiveAddress);
            if (Status)
                {
                FreePacket(Packet);
                break;
                }

            // We need to purge stale EEInfo that may be left over from a send.
            RpcpPurgeEEInfo();

            Status = DispatchPacket(Packet);
            }
        while ( 0 );
        }
    else
        {
        ASSERT( !Packet && !ReceiveAddress );

        if (SequenceNumber <= Connection->CurrentSequenceNumber())
            {
            if (!TimeoutCount)
                {
                ReceiveTimeout = 500;
                }

            ++TimeoutCount;

            //
            // Shorten the burst length.
            //
            SendBurstLength = (1+SendBurstLength)/2;

            if (Status == RPC_P_TIMEOUT)
                {
                LogEvent(SU_CCALL, EV_STATUS, this, 0, Status);

                IncreaseReceiveTimeout();
                }
            else
                {
                RpcpErrorAddRecord( EEInfoGCRuntime,
                                    Status,
                                    EEInfoDLDG_CCALL__ReceiveSinglePacket30
                                    );

                LogError(SU_CCALL, EV_STATUS, this, 0, Status);

                //
                // Perhaps it's a transient error.  Wait a moment and try again.
                //
#ifdef DEBUGRPC
                if (Status != RPC_S_OUT_OF_RESOURCES &&
                    Status != RPC_S_OUT_OF_MEMORY    &&
                    Status != RPC_P_RECEIVE_FAILED   )
                    {
                    DbgPrint("RPC: d/g receive status %x\n"
                             "Please send the error code to jroberts, and hit 'g'",
                             Status
                             );

                    RpcpBreakPoint();
                    }
#endif

                Sleep(500);
                }
            }

        Status = DealWithTimeout();
        }

    return Status;
}


RPC_STATUS
DG_CCALL::AsyncSend(
    PRPC_MESSAGE Message
    )
{
    if (AsyncStatus != RPC_S_OK &&
        AsyncStatus != RPC_S_ASYNC_CALL_PENDING )
        {
        Connection->MutexRequest();

        return AfterSendReceive(Message, AsyncStatus);
        }

    return Send(Message);
}


RPC_STATUS
DG_CCALL::Send(
    PRPC_MESSAGE Message
    )
{
    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
        {
        LogEvent(SU_CCALL, EV_PROC, this, Message->Buffer, 'A' + (('S' + (('n' + ('d' << 8)) << 8)) << 8));
        }
    else
        {
        LogEvent(SU_CCALL, EV_PROC, this, Message->Buffer, 'S' + (('e' + (('n' + ('d' << 8)) << 8)) << 8));
        }

    LogEvent(SU_CCALL, EV_BUFFER_IN, this, Message->Buffer, Message->BufferLength);

    RPC_STATUS Status = RPC_S_OK;

    Connection->MutexRequest();

    //
    // See DG_CCALL::CancelDelayedSend for details.
    //
    while (State == CallCancellingSend)
        {
        Connection->MutexClear();
        Sleep(1);
        Connection->MutexRequest();
        }

    if (State == CallInit)
        {
        Status = BeforeSendReceive(Message);
        if (RPC_S_OK != Status)
            {
            Connection->MutexClear();
            FreeBuffer(Message);
            return Status;
            }
        }

    SetFragmentLengths();

    if ((Message->RpcFlags & RPC_BUFFER_PARTIAL) &&
        Message->BufferLength < (ULONG) MaxFragmentSize * SendWindowSize )
        {
        Status = RPC_S_SEND_INCOMPLETE;

        Connection->IncrementRefCount();
        if (pAsync)
            {
            IssueNotification( RpcSendComplete );
            }

        Connection->DecrementRefCount();

        LogEvent(SU_CCALL, EV_STATUS, this, 0, Status);
        return Status;
        }

    SetState(CallSend);

    Status = PushBuffer(Message);
    if (Status)
        {
        FreePipeBuffer(Message);
        Status = AfterSendReceive(Message, Status);

        LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);
        LogError(SU_CCALL, EV_STATUS, this, 0, Status);

        return Status;
        }

    if (pAsync)
        {
        Connection->MutexClear();
        }
    else
        {
        while (RPC_S_OK == Status && !IsBufferAcknowledged())
            {
            Status = ReceiveSinglePacket();
            }

        SetState(CallQuiescent);

        if (Status == RPC_S_OK)
            {
            Connection->MutexClear();
            }
        else
            {
            Status = AfterSendReceive(Message, Status);
            }
        }

    if (!Status && Message->BufferLength)
        {
        Status = RPC_S_SEND_INCOMPLETE;
        }

    LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);
    LogEvent(SU_CCALL, EV_STATUS, this, 0, Status);

    return Status;
}


RPC_STATUS
DG_CCALL::MaybeSendReceive(
    IN OUT PRPC_MESSAGE Message
    )

/*++

Routine Description:

    Sends a [maybe], [broadcast, maybe] or [message] call.

Arguments:

    Message - Message to be sent.

Return Value:

    RPC_S_OK
    <error from Transport>

--*/

{
    RPC_STATUS  Status = RPC_S_OK;

    //
    // Make sure this fits into a single packet.
    //
    if ( !(Message->RpcFlags & RPCFLG_MESSAGE)
         && (Message->BufferLength > MaxFragmentSize) )
        {
        FreePipeBuffer(Message);
        return RPC_S_OK;
        }

    //
    // [maybe] calls are implicitly idempotent.
    //
    Message->RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;

    //
    // Build the request packet.
    //
    PDG_PACKET         Packet = DG_PACKET::FromStubData(Message->Buffer);
    PNCA_PACKET_HEADER Header = &Packet->Header;

    *Header = pSavedPacket->Header;

    BuildNcaPacketHeader(Header, Message);

    Header->SetPacketBodyLen (Message->BufferLength);
    Header->SetFragmentNumber(0);
    Header->AuthProto      = 0;
    Header->ServerBootTime = 0;

    AddSerialNumber(Header);

    //
    // Send the packet.
    //
    LogEvent(SU_CCALL, EV_PKT_OUT, this, 0, 0);

    Status = SendSecurePacket(SourceEndpoint,
                              Connection->Association->InqServerAddress(),
                              Header,
                              0,
                              0
                              );

    FreePipeBuffer(Message);
    Message->BufferLength = 0;

    if (Message->RpcFlags & RPCFLG_MESSAGE)
        {
        return Status;
        }
    else
        {
        return RPC_S_OK;
        }
}


RPC_STATUS
DG_CCALL::AsyncReceive(
    PRPC_MESSAGE Message,
    unsigned MinimumSize
    )
{
    LogEvent(SU_CCALL, EV_PROC, this, IntToPtr(MinimumSize), 0x76635241);
    LogEvent(SU_CCALL, EV_BUFFER_IN, this, Message->Buffer, Message->BufferLength);

    ASSERT( pAsync && (Message->RpcFlags & RPC_BUFFER_ASYNC) );

    Connection->MutexRequest();

    if (State == CallSend)
        {
        Connection->MutexClear();
        return RPC_S_ASYNC_CALL_PENDING;
        }

    //
    // See DG_CCALL::CancelDelayedSend for details.
    //
    while (State == CallCancellingSend)
        {
        Connection->MutexClear();
        Sleep(1);
        Connection->MutexRequest();
        }

    if (AsyncStatus != RPC_S_OK &&
        AsyncStatus != RPC_S_ASYNC_CALL_PENDING )
        {
        return AfterSendReceive(Message, AsyncStatus);
        }

    if (!fReceivedAllFragments &&
        !(ConsecutiveDataBytes >= MinimumSize && (Message->RpcFlags & RPC_BUFFER_PARTIAL)))
        {
        if (Message->RpcFlags & RPC_BUFFER_NONOTIFY)
            {
            // just checking
            }
        else
            {
            SetState(CallReceive);

            PipeReceiveSize = MinimumSize;
            }

        Connection->MutexClear();

        LogEvent(SU_CCALL, EV_STATUS, this, 0, RPC_S_ASYNC_CALL_PENDING);

        return RPC_S_ASYNC_CALL_PENDING;
        }

    RPC_STATUS Status = RPC_S_OK;

    Status = AssembleBufferFromPackets(Message, this);

    LogEvent(SU_CCALL, EV_STATUS, this, 0, Status);
    LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);

    if (0 == (Message->RpcFlags & RPC_BUFFER_PARTIAL) ||
        (Message->RpcFlags & RPC_BUFFER_COMPLETE)     ||
        RPC_S_OK != Status                            )
        {
        Status = AfterSendReceive(Message, Status);
        }
    else
        {
        Connection->MutexClear();
        }

    return Status;
}


RPC_STATUS
DG_CCALL::Receive(
    PRPC_MESSAGE Message,
    unsigned MinimumSize
    )
{
    LogEvent(SU_CCALL, EV_PROC, this, IntToPtr(MinimumSize), 0x76636552);
    LogEvent(SU_CCALL, EV_BUFFER_IN, this, Message->Buffer, Message->BufferLength);

    RPC_STATUS Status = RPC_S_OK;

    Connection->MutexRequest();

    SetState(CallReceive);

    while (RPC_S_OK == Status &&
           !fReceivedAllFragments &&
           !(ConsecutiveDataBytes >= MinimumSize && (Message->RpcFlags & RPC_BUFFER_PARTIAL)))
        {
        Status = ReceiveSinglePacket();
        }

    if (RPC_S_OK == Status)
        {
        Status = AssembleBufferFromPackets(Message, this);
        }

    LogEvent(SU_CCALL, EV_STATUS, this, 0, RPC_S_OK);
    LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);

    if (0 == (Message->RpcFlags & RPC_BUFFER_PARTIAL) ||
        (Message->RpcFlags & RPC_BUFFER_COMPLETE)     ||
        RPC_S_OK != Status                            )
        {
        Status = AfterSendReceive(Message, Status);
        }
    else
        {
        Connection->MutexClear();
        }

    return Status;
}


BOOL
DG_CCALL::IssueNotification (
    IN RPC_ASYNC_EVENT Event
    )
{
    Connection->Mutex.VerifyOwned();

    LogEvent(SU_CCALL, EV_NOTIFY, this, (void *) Event, AsyncStatus);

    if (State == CallInit     ||
        State == CallComplete ||
        State == CallCancellingSend )
        {
#ifdef DEBUGRPC
        DbgPrint("RPC: redundant notification on ccall %lx\n", this);
#endif
        return TRUE;
        }

    if (Event == RpcCallComplete)
        {
        SetState(CallComplete);
        }
    else
        {
        SetState(CallQuiescent);
        }

    if (pAsync->NotificationType == RpcNotificationTypeApc)
        {
        IncrementRefCount();
        }

    int i;
    for (i=1; i < 3; ++i)
        {
        if (CALL::IssueNotification(Event))
            {
            return TRUE;
            }

        Sleep(200);
        }

    DecrementRefCountAndKeepMutex();

    return FALSE;
}

void
DG_CCALL::FreeAPCInfo (
    IN RPC_APC_INFO *pAPCInfo
    )
{
    LogEvent(SU_CCALL, EV_APC, this);

    Connection->MutexRequest();

    CALL::FreeAPCInfo(pAPCInfo);

    DecrementRefCount();
}


RPC_STATUS
DG_CCALL::CancelAsyncCall (
    IN BOOL fAbort
    )
{
    Connection->MutexRequest();

    if (State == CallInit     ||
        State == CallComplete ||
        State == CallCancellingSend )
        {
        Connection->MutexClear();
        return RPC_S_OK;
        }

    RpcpErrorAddRecord( EEInfoGCRuntime,
                        RPC_S_CALL_CANCELLED,
                        EEInfoDLDG_CCALL__CancelAsyncCall10,
                        (ULONG) fAbort
                        );

    SendQuit();

    Connection->IncrementRefCount();

    if (fAbort)
        {
        CancelDelayedSend();
        CleanupReceiveWindow();

        AsyncStatus = RPC_S_CALL_CANCELLED;
        IssueNotification( RpcCallComplete );
        }
    else
        {
        CancelPending = TRUE;
        }

    Connection->DecrementRefCount();

    return RPC_S_OK;
}


RPC_STATUS
DG_CCALL::DealWithRequest(
    IN PDG_PACKET           Packet,
    IN DG_TRANSPORT_ADDRESS ReceiveAddress
    )
{
    RPC_STATUS Status = RPC_S_OK;
    RPC_MESSAGE CallbackMessage;
    PNCA_PACKET_HEADER OriginalHeader;
    DG_CLIENT_CALLBACK Callback;

    //
    // Save the server data rep for challenge response processing.
    //
    Connection->Association->ServerDataRep = 0x00ffffff & (*(unsigned long *) (Packet->Header.DataRep));

    Callback.LocalEndpoint = SourceEndpoint;
    Callback.Connection    = Connection;
    Callback.RemoteAddress = ReceiveAddress;
    Callback.Request       = Packet;

    return DispatchCallbackRequest(&Callback);
}



RPC_STATUS
DG_CCALL::DealWithFack(
    PDG_PACKET pPacket
    )
{
    BOOL Updated;
    RPC_STATUS Status;

    SendBurstLength += 1;

    Status = UpdateSendWindow(pPacket, &Updated);

    if (Updated)
        {
        Connection->UpdateAssociation();
        }

    FreePacket(pPacket);

    if (Status != RPC_P_HOST_DOWN)
        {
        Status = 0;
        }

    return Status;
}


RPC_STATUS
DG_CCALL::DealWithResponse(
    PDG_PACKET pPacket
    )
{
    #ifdef DBG
    if (!Connection->TransportInterface->IsMessageTransport)
       {
       CORRUPTION_ASSERT( !(pPacket->GetPacketBodyLen() % 8)               ||
                          !(pPacket->Header.PacketFlags & DG_PF_FRAG)      ||
                           (pPacket->Header.PacketFlags & DG_PF_LAST_FRAG) );
       }
    #endif

    Connection->Association->LastReceiveTime = LastReceiveTime;

    //
    // The first response is implicitly a FACK for the final request packet.
    //
    MarkAllPacketsReceived();

    //
    // Add packet to received list, and send a fack if necessary.
    //
    if (FALSE == UpdateReceiveWindow(pPacket))
        {
        FreePacket(pPacket);
        }

    Connection->MaybeTransmitNextCall();

    return RPC_S_OK;
}


RPC_STATUS
DG_CCALL::DealWithWorking(
    PDG_PACKET pPacket
    )
{
    Connection->Association->LastReceiveTime = LastReceiveTime;

    //
    // WORKING is implicitly a FACK for the final request packet.
    //
    MarkAllPacketsReceived();

    Connection->MaybeTransmitNextCall();

    //
    // Reduce server load by increasing the timeout during long calls.
    //
    IncreaseReceiveTimeout();

    FreePacket(pPacket);

    return RPC_S_OK;
}


void
DG_CCALL::IncreaseReceiveTimeout()
{
    if (Connection->TransportInterface->IsMessageTransport)
        {
        return;
        }

    ReceiveTimeout *= 2;
    if (ReceiveTimeout > 16000)
        {
        ReceiveTimeout = 16000;
        }

    if (long(GetTickCount()) - LastReceiveTime + ReceiveTimeout > TimeoutLimit)
        {
        ReceiveTimeout = 1 + TimeoutLimit - (GetTickCount() - LastReceiveTime);
        if (ReceiveTimeout < 0)
            {
            ReceiveTimeout = 0;
            }
        }

    long CancelTimeout = ThreadGetRpcCancelTimeout();
    if (CancelTimeout != RPC_C_CANCEL_INFINITE_TIMEOUT)
        {
        CancelTimeout *= 1000;

        if (CancelTimeout < 2000)
            {
            CancelTimeout = 2000;
            }

        if (ReceiveTimeout > CancelTimeout)
            {
            ReceiveTimeout = CancelTimeout;
            }
        }
}


RPC_STATUS
DG_CCALL::DealWithNocall(
    PDG_PACKET pPacket
    )
{
    BOOL Used;
    BOOL Updated;
    RPC_STATUS Status;

    if (pPacket->GetPacketBodyLen() == 0)
        {
        //
        // Don't trust the FragmentNumber field.
        //
        pPacket->SetFragmentNumber(0xffff);
        }

    Status = UpdateSendWindow(pPacket, &Updated);

    if (Updated)
        {
        Connection->UpdateAssociation();
        }

    FreePacket(pPacket);

    //
    // Ordinarily a NOCALL means the request wasn't received, and we should
    // fail the call after several in a row.  But a NOCALL with window size 0
    // means the request was received and queued, and we want to back off as
    // for a WORKING packet.
    //
    if (SendWindowSize != 0)
        {
        ++UnansweredRequestCount;
        }

//    IncreaseReceiveTimeout();

    if (UnansweredRequestCount > 4)
        {
        SendQuit();
        return RPC_P_PORT_DOWN;
        }

    if (Status != RPC_P_HOST_DOWN)
        {
        Status = 0;
        }

    return Status;
}

RPC_STATUS
DG_CCALL::ProcessFaultOrRejectData(
    PDG_PACKET Packet
    )
{
    RPC_STATUS Status = RPC_S_CALL_FAILED;

    //
    // Read the standard OSF error code.
    //
    if (Packet->GetPacketBodyLen() >= sizeof(unsigned long))
        {
        unsigned long Error = * (unsigned long *) Packet->Header.Data;

        if (NeedsByteSwap(&Packet->Header))
            {
            Error = RpcpByteSwapLong(Error);
            }
        Status = MapFromNcaStatusCode(Error);

        LogEvent( SU_CCALL, EV_STATUS, this, 0, Error);
        }

    //
    // Read the extended error info, if present.
    //
    if (Packet->GetPacketBodyLen() > sizeof(EXTENDED_FAULT_BODY))
        {
        EXTENDED_FAULT_BODY * body = (EXTENDED_FAULT_BODY *) Packet->Header.Data;

        if (body->Magic == DG_EE_MAGIC_VALUE)
            {
            ExtendedErrorInfo *EEInfo;

            UnpickleEEInfoFromBuffer( body->EeInfo,
                                      Packet->GetPacketBodyLen() - sizeof(EXTENDED_FAULT_BODY)
                                      );

            EEInfo = RpcpGetEEInfo();
            if (EEInfo && pAsync)
                {
                ASSERT(this->EEInfo == NULL);

                // move the eeinfo to the call. Even though it is possible
                // that the call will be completed on this thread, it is
                // still ok, as we will move it back during completion
                this->EEInfo = EEInfo;
                RpcpClearEEInfo();
                }
            }
        }

    return Status;
}


RPC_STATUS
DG_CCALL::DealWithFault(
    PDG_PACKET pPacket
    )
{
    RPC_STATUS Status = ProcessFaultOrRejectData(pPacket);

    FreePacket(pPacket);

    SendAck();

    return Status;
}


RPC_STATUS
DG_CCALL::DealWithReject(
    PDG_PACKET pPacket
    )
{
    RPC_STATUS Status = ProcessFaultOrRejectData(pPacket);

    FreePacket(pPacket);

    if (!fRetransmitted || (BufferFlags & RPC_NCA_FLAGS_IDEMPOTENT))
        {
        if (Status == NCA_STATUS_WRONG_BOOT_TIME ||
            (!Connection->fAutoReconnect && Status == RPC_S_CALL_FAILED_DNE))
            {
            Status = AttemptAutoReconnect();
            }
        }

    return Status;
}


RPC_STATUS
DG_CCALL::SendQuit(
    )
{
    QUIT_BODY_0 * pBody = (QUIT_BODY_0 *) pSavedPacket->Header.Data;

    pSavedPacket->Header.PacketType    = DG_QUIT;
    pSavedPacket->Header.PacketFlags   &= DG_PF_IDEMPOTENT;
    pSavedPacket->SetPacketBodyLen(sizeof(QUIT_BODY_0));

    AddSerialNumber(&pSavedPacket->Header);

    pBody->Version = 0;
    pBody->EventId = CancelEventId;

    unsigned Frag = (pSavedPacket->Header.PacketType << 16) | pSavedPacket->GetFragmentNumber();
    LogEvent(SU_CCALL, EV_PKT_OUT, this, 0, Frag);

    return Connection->SealAndSendPacket(SourceEndpoint, 0, &pSavedPacket->Header, 0);
}


RPC_STATUS
DG_CCALL::DealWithQuack(
    PDG_PACKET pPacket
    )
{
    if (FALSE == CancelPending)
        {
        FreePacket(pPacket);
        return RPC_S_OK;
        }

    QUACK_BODY_0 * pBody = (QUACK_BODY_0 *) pPacket->Header.Data;

    if (0 == pPacket->GetPacketBodyLen())
        {
        //
        // The server orphaned a call.  I hope it is the current one.
        //
        goto ok;
        }

    //
    // The ver 0 quack packet contains two ulongs and a uchar; I'd like to
    // test for sizeof(quack body) but C++ likes to pad structure sizes
    // to 0 mod 4.  Hence the explicit test for length < 9.
    //
    if (pPacket->GetPacketBodyLen() < 9 ||
        pBody->Version != 0)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: unknown QUACK format: version 0x%lx, length 0x%hx\n",
                 pBody->Version, pPacket->GetPacketBodyLen()
                 );
#endif
        FreePacket(pPacket);
        return RPC_S_OK;
        }

    if (pBody->EventId != CancelEventId)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: ignoring unknown QUACK event id 0x%lx\n",
                 pBody->EventId
                 );
#endif
        FreePacket(pPacket);
        return RPC_S_OK;
        }

ok:

    CancelPending = FALSE;
    FreePacket(pPacket);

    return RPC_S_OK;
}


RPC_STATUS
DG_CCONNECTION::SealAndSendPacket(
    IN DG_ENDPOINT *                 SourceEndpoint,
    IN DG_TRANSPORT_ADDRESS          UnusedRemoteAddress,
    IN UNALIGNED NCA_PACKET_HEADER * Header,
    IN unsigned long                 DataOffset
    )
/*

- NT 3.5 did not support secure datagram RPC.

- NT 3.51 and NT 4.0 servers will probably fail to decrypt a multifragment
request if some fragments are encrypted with one context and others use a
different context, since they decrypt all the packets using the last active
context instead of looking at each packet's 'ksno' field.

- NT 3.51 and NT 4.0 servers dispose of stale contexts only when the activity
is deleted.

- NT 3.51 and NT 4.0 clients use only one set of security parameters
(provider, level, principal name) per connection.  The only time the ksno
changes is on NT 4.0 when a Kerberos context expires and must be renewed.

- NT 3.51 and NT 4.0 clients do not notice if ksno rises above 0xff.  If it
does, the next call will fail because the server sees only the lowest 8 bits
and mistakenly reuses another context.

- NT 3.51 clients do not notice whether the thread is impersonating, so they
can mistakenly reuse a connection if all info except the username is identical.

- NT 3.51 clients mistakenly send [maybe] calls with an auth trailer, if the
underlying connection is secure.  OSF and NT 4.0 force [maybe] calls insecure.

*/

{
    ASSERT( 0 == ActivityNode.CompareUuid(&Header->ActivityId) );

retry_packet:

    RPC_STATUS Status;
    Status = SendSecurePacket(SourceEndpoint,
                              Association->InqServerAddress(),
                              Header,
                              DataOffset,
                              ActiveSecurityContext
                              );

    if (Status == SEC_E_CONTEXT_EXPIRED)
        {
        Status = InitializeSecurityContext();
        if (RPC_S_OK == Status)
            {
            goto retry_packet;
            }
        }

    return Status;
}


RPC_STATUS
DG_CCONNECTION::InitializeSecurityContext(
    )
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    delete ActiveSecurityContext;

    if (SecurityContextId > 0xff)
        {
        ActiveSecurityContext = 0;
        return RPC_S_OUT_OF_RESOURCES;
        }

    ActiveSecurityContext = new SECURITY_CONTEXT(&AuthInfo, SecurityContextId, TRUE, &RpcStatus);
    if (0 == ActiveSecurityContext)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    if (RpcStatus)
        {
        delete ActiveSecurityContext;
        ActiveSecurityContext = 0;
        return RPC_S_OUT_OF_MEMORY;
        }

    ++SecurityContextId;

    SECURITY_BUFFER_DESCRIPTOR BufferDescriptorIn;
    DCE_INIT_SECURITY_INFO InitSecurityInfo;
    SECURITY_BUFFER SecurityBuffersIn[1];

    BufferDescriptorIn.ulVersion = 0;
    BufferDescriptorIn.cBuffers  = 1;
    BufferDescriptorIn.pBuffers  = SecurityBuffersIn;

    SecurityBuffersIn[0].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
    SecurityBuffersIn[0].pvBuffer   = &InitSecurityInfo;
    SecurityBuffersIn[0].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);

    InitSecurityInfo.DceSecurityInfo.SendSequenceNumber    = 0;
    InitSecurityInfo.DceSecurityInfo.ReceiveSequenceNumber = ActiveSecurityContext->AuthContextId;
    RpcpMemoryCopy(&InitSecurityInfo.DceSecurityInfo.AssociationUuid, &ActivityNode.Uuid, sizeof(UUID));

    InitSecurityInfo.AuthorizationService = AuthInfo.AuthorizationService;
    InitSecurityInfo.PacketType           = ~0;

    RpcStatus = ActiveSecurityContext->InitializeFirstTime(
                    AuthInfo.Credentials,
                    AuthInfo.ServerPrincipalName,
                    AuthInfo.AuthenticationLevel,
                    &BufferDescriptorIn
                    );

    LogEvent(SU_CCONN, EV_SEC_INIT1, this, IntToPtr(RpcStatus), I_RpcGetExtendedError());

    return RpcStatus;
}


RPC_STATUS
DG_CCONNECTION::DealWithAuthCallback(
    IN void  * InToken,
    IN long  InTokenLength,
    OUT void * OutToken,
    OUT long MaxOutTokenLength,
    OUT long * OutTokenLength
    )
{
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptorIn;
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptorOut;
    DCE_INIT_SECURITY_INFO InitSecurityInfo;
    SECURITY_BUFFER SecurityBuffersIn [2];
    SECURITY_BUFFER SecurityBuffersOut[2];
    RPC_STATUS Status;

    InitSecurityInfo.DceSecurityInfo.SendSequenceNumber    = 0;
    InitSecurityInfo.DceSecurityInfo.ReceiveSequenceNumber = ActiveSecurityContext->AuthContextId;
    ActivityNode.QueryUuid( &InitSecurityInfo.DceSecurityInfo.AssociationUuid );

    InitSecurityInfo.AuthorizationService = AuthInfo.AuthorizationService;
    InitSecurityInfo.PacketType           = ~0;

    BufferDescriptorIn.ulVersion = 0;
    BufferDescriptorIn.cBuffers  = 2;
    BufferDescriptorIn.pBuffers  = SecurityBuffersIn;

    SecurityBuffersIn[0].BufferType = SECBUFFER_TOKEN;
    SecurityBuffersIn[0].pvBuffer   = InToken;
    SecurityBuffersIn[0].cbBuffer   = InTokenLength;

    SecurityBuffersIn[1].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
    SecurityBuffersIn[1].pvBuffer   = &InitSecurityInfo;
    SecurityBuffersIn[1].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);

    BufferDescriptorOut.ulVersion = 0;
    BufferDescriptorOut.cBuffers  = 1;
    BufferDescriptorOut.pBuffers  = SecurityBuffersOut;

    SecurityBuffersOut[0].BufferType = SECBUFFER_TOKEN;
    SecurityBuffersOut[0].pvBuffer   = OutToken;
    SecurityBuffersOut[0].cbBuffer   = MaxOutTokenLength;

    Status = ActiveSecurityContext->InitializeThirdLeg(
                                                  AuthInfo.Credentials,
                                                  Association->ServerDataRep,
                                                  &BufferDescriptorIn,
                                                  &BufferDescriptorOut
                                                  );


    if (Status != RPC_S_OK)
        {
        LogError(SU_CCONN, EV_SEC_INIT3, this, IntToPtr(Status), I_RpcGetExtendedError());

        *OutTokenLength = 0;
        return (Status);
        }
    else
        {
        LogEvent(SU_CCONN, EV_SEC_INIT3, this, IntToPtr(Status), I_RpcGetExtendedError());

        *OutTokenLength = SecurityBuffersOut[0].cbBuffer;
        }

    //
    // If the result buffer spans multiple packets, return the first and store
    // the complete buffer in the connection for conv_who_are_you_auth_more().
    //
    if (!CurrentCall)
        {
        return 0;
        }

    long MaxData = CurrentCall->SourceEndpoint->Stats.MaxPduSize - sizeof(NCA_PACKET_HEADER) - 0x28;

    if (*OutTokenLength > MaxData)
        {
        if (SecurityBuffer)
            {
            delete SecurityBuffer;
            }

        SecurityBuffer = new unsigned char[ *OutTokenLength ];
        if (!SecurityBuffer)
            {
            *OutTokenLength = 0;
            return NCA_STATUS_REMOTE_OUT_OF_MEMORY;
            }

        memcpy( SecurityBuffer, SecurityBuffersOut[0].pvBuffer, *OutTokenLength );

        SecurityBufferLength = *OutTokenLength;

        *OutTokenLength = MaxData;
        return NCA_STATUS_PARTIAL_CREDENTIALS;
        }

    return (Status);
}


RPC_STATUS
DG_CCONNECTION::DealWithAuthMore(
    IN  long Index,
    OUT void * OutToken,
    OUT long MaxOutTokenLength,
    OUT long * OutTokenLength
    )
{
    if (0 == SecurityBuffer)
        {
        *OutTokenLength = 0;
        return 0;
        }

    if (SecurityBufferLength <= Index)
        {
        *OutTokenLength = 0;
        return 0;
        }

    if (!CurrentCall)
        {
        return 0;
        }

    long MaxData = CurrentCall->SourceEndpoint->Stats.MaxPduSize - sizeof(NCA_PACKET_HEADER) - 0x28;

    *OutTokenLength = SecurityBufferLength - Index;
    if (*OutTokenLength > MaxData)
        {
        *OutTokenLength = MaxData;
        memcpy(OutToken, SecurityBuffer + Index, *OutTokenLength);
        return NCA_STATUS_PARTIAL_CREDENTIALS;
        }

    memcpy(OutToken, SecurityBuffer + Index, *OutTokenLength);
    return 0;
}


RPC_STATUS
DG_CCONNECTION::VerifyPacket(
    DG_PACKET * Packet
    )
{
    if (AuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE ||
        (Packet->Flags & DG_PF_PARTIAL))
        {
        return RPC_S_OK;
        }

    if (!Packet->Header.AuthProto)
        {
        if (!fSecurePacketReceived && Packet->Header.PacketType != DG_RESPONSE)
            {
            return RPC_S_OK;
            }

        if (Packet->Header.PacketType == DG_REJECT ||
            Packet->Header.PacketType == DG_NOCALL)
            {
            return RPC_S_OK;
            }

        return RPC_S_ACCESS_DENIED;
        }

    RPC_STATUS Status;
    PDG_SECURITY_TRAILER Verifier = (PDG_SECURITY_TRAILER) (Packet->Header.Data + Packet->GetPacketBodyLen());

    if (Verifier->key_vers_num == ActiveSecurityContext->AuthContextId)
        {
        Status = VerifySecurePacket(Packet, ActiveSecurityContext);
        }
//    else if (Verifier->key_vers_num == ActiveSecurityContext->AuthContextId - 1)
//        {
//        Status = VerifySecurePacket(Packet, PreviousSecurityContext);
//        }
    else
        {
        Status = RPC_P_CONTEXT_EXPIRED;
        }

    if (RPC_S_OK == Status)
        {
        fSecurePacketReceived = TRUE;
        }

    return Status;
}


inline
int
DG_CCONNECTION::IsSupportedAuthInfo(
    IN const CLIENT_AUTH_INFO * ClientAuthInfo
    )
{
    BOOL Supported;
    RPC_STATUS RpcStatus;

    // datagrams don't support any of that
    ASSERT(AuthInfo.ServerSid == NULL);
    ASSERT((AuthInfo.Capabilities & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT) == 0);
    if (ClientAuthInfo)
        {
        ASSERT(ClientAuthInfo->ServerSid == NULL);
        ASSERT((ClientAuthInfo->Capabilities & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT) == 0);
        }

    RpcStatus = AuthInfo.IsSupportedAuthInfo (ClientAuthInfo, 
        nptNotNamedPipe,      // npType
        FALSE,                // IsExlusiveConnection - ignored for non named pipes
        &Supported
        );

    // since datagram doesn't support any of the SID stuff, it cannot hit a failure path
    // in supportedAuthInfo
    ASSERT(RpcStatus == RPC_S_OK);

    return Supported;
}


int
DG_CASSOCIATION::CompareWithBinding(
    IN PDG_BINDING_HANDLE Binding
    )
{
    BOOL Ignored;

    ASSERT( !InvalidHandle(DG_CASSOCIATION_TYPE) );

    // We do not need to take a mutex since this funcitons is called from
    // DG_ASSOCIATION_TABLE::Find only, where an exclusive mutex is taken.
    // CLAIM_MUTEX lock( Mutex );

    if (0 != pDceBinding->Compare(Binding->pDceBinding,
                                    &Ignored    // fOnlyEndpointDifferent
                                    )
       )
        {
        return 1;
        }

    return 0;
}

RPC_STATUS
DG_CCALL::Cancel(
    void * ThreadHandle
    )
{
    LogError( SU_CCALL, EV_PROC, this, 0, 'C' + (('a' + (('n' + (' ' << 8) )<< 8) )<< 8));
    InterlockedIncrement(&Cancelled);

    return RPC_S_OK;
}

unsigned
DG_CCALL::TestCancel()
{
    LogEvent( SU_CCALL, EV_PROC, this, IntToPtr(Cancelled), 'T' + (('s' + (('t' + ('C' << 8)) << 8)) << 8));

    if (!Cancelled)
        {
        return 0;
        }

    return InterlockedExchange(&Cancelled, 0);
}


RPC_STATUS
DG_CCALL::SendSomeFragments(
    )
{
    RPC_STATUS Status;

    if (0 == FirstUnsentFragment)
        {
        if (SequenceNumber > Connection->CurrentSequenceNumber())
            {
            return RPC_S_OK;
            }

        //
        // If we begin sending this call's request before a previous call
        // is complete, then we should add the DG_PF2_UNRELATED bit to this call.
        //
        if (Connection->Association->fServerSupportsAsync)
            {
            ASSERT( Connection->Association->fServerSupportsAsync );

            PDG_CCALL node = Previous;

            while (node && node->fReceivedAllFragments)
                {
                node = node->Previous;
                }

            if (node)
                {
                BasePacketFlags2 = DG_PF2_UNRELATED;
                Previous->ForceAck = TRUE;
                }
            }

        // Note that Previous may not be the call immediately prior to this one,
        // since the prior call may have completed already and been removed
        // from the list.
        }

    LogEvent(SU_CCALL, EV_PROC, this, (void *) 1, 0x656d6f53);

    Status = DG_PACKET_ENGINE::SendSomeFragments();

    if (IsBufferSent())
        {
        //
        // The first buffer contains all the static args; it's simpler
        // to set the flags multiple times than to set it only for the
        // first buffer.
        //
        StaticArgsSent = TRUE;

        if (0 == (BufferFlags & RPC_BUFFER_PARTIAL))
            {
            AllArgsSent = TRUE;
            }
        }

    if (pAsync && AsyncStatus == RPC_S_ASYNC_CALL_PENDING)
        {
        PostDelayedSend();
        }

    return Status;
}


RPC_STATUS
DG_CCALL::DealWithTimeout()
{
    RPC_STATUS Status;

#ifdef DEBUGRPC
    Status = 0xbaadcccc;
#endif

    LogEvent(SU_CCALL, EV_PROC, this, 0, 0x656d6f53);

    ASSERT (State != CallComplete);

    if (!CancelPending && TestCancel() > 0)
        {
        ++CancelEventId;
        CancelPending = TRUE;
        CancelTime = GetTickCount();
        }

    if (CancelPending)
        {
        SendQuit();

        if ((long(GetTickCount()) - CancelTime) / 1000 >= ThreadGetRpcCancelTimeout() )
            {
            RpcpErrorAddRecord( EEInfoGCRuntime,
                                RPC_S_CALL_CANCELLED,
                                EEInfoDLDG_CCALL__DealWithTimeout10,
                                (ULONG) ThreadGetRpcCancelTimeout(),
                                (ULONG) (long(GetTickCount()) - CancelTime)
                                );

            CancelPending = FALSE;
            return RPC_S_CALL_CANCELLED;
            }

        return RPC_S_OK;
        }

    if (long(GetTickCount()) - LastReceiveTime >= TimeoutLimit)
        {
        LogError(SU_CCALL, EV_PROC, this, (void *) 2, 0x656d6f53);

        RpcpErrorAddRecord( EEInfoGCRuntime,
                            RPC_P_TIMEOUT,
                            EEInfoDLDG_CCALL__DealWithTimeout20,
                            (ULONG) TimeoutLimit,
                            (ULONG) (long(GetTickCount()) - LastReceiveTime)
                            );
 
        SendQuit();
        return RPC_P_TIMEOUT;
        }

    LogEvent(SU_CCALL, EV_PROC, this, (void *) 4, 0x656d6f53);

    int ConvComparisonResult = 1;

    //
    // The client for NT 3.5 (build 807) swallows requests for conv_who_are_you2.
    // If the server pings the callback instead of retransmitting the request,
    // the 807 client will give up before we ever try conv_who_are_you.  Instead,
    // retransmit the request packet for calls over the conv interface.
    //
    PRPC_SERVER_INTERFACE Conv = (PRPC_SERVER_INTERFACE) conv_ServerIfHandle;
    if (FALSE == AllArgsSent ||
        (BufferFlags & RPC_NCA_FLAGS_BROADCAST) ||
        (0 == (ConvComparisonResult = RpcpMemoryCompare(&pSavedPacket->Header.InterfaceId,
                                                        &Conv->InterfaceId.SyntaxGUID,
                                                        sizeof(UUID)
                                                        ))))
        {
        //
        // Not all request packets have been transferred.
        //
        Status = SendSomeFragments();
        }
    else
        {
        //
        // Send a FACK if we have seen at least one response packet.
        //
        if (pReceivedPackets || ReceiveFragmentBase > 0)
            {
            Status = SendFackOrNocall(pReceivedPackets, DG_FACK);
            }
        else
            {
            Status = SendPing();
            }
        }

    if (pAsync && AsyncStatus == RPC_S_ASYNC_CALL_PENDING)
        {
        PostDelayedSend();
        }

    if (Status != RPC_P_HOST_DOWN)
        {
        Status = 0;
        }
    else
        {
        RpcpErrorAddRecord( EEInfoGCRuntime,
                            Status,
                            EEInfoDLDG_CCALL__DealWithTimeout30
                            );
        }

    return Status;
}


BOOL
INTERFACE_AND_OBJECT_LIST::Insert(
    void     __RPC_FAR * Interface,
    RPC_UUID __RPC_FAR * Object
    )
{
    INTERFACE_AND_OBJECT * Current;
    INTERFACE_AND_OBJECT * Prev;
    unsigned Count;

    for (Count = 0, Prev = 0, Current = Head;
         Count < MAX_ELEMENTS && Current != NULL;
         Count++, Prev = Current, Current = Current->Next)
        {
        if (Interface == Current->Interface &&
            0 == Current->Object.MatchUuid(Object))
            {
            return TRUE;
            }
        }

    if (Current)
        {
        //
        // We have too many elements in the list. Reuse this one, the oldest.
        //
        if (Current == Head)
            {
            Head = Current->Next;
            }
        else
            {
            Prev->Next = Current->Next;
            }
        }
    else
        {
        if (Cache1Available)
            {
            Cache1Available = FALSE;
            Current = &Cache1;
            }
        else if (Cache2Available)
            {
            Cache2Available = FALSE;
            Current = &Cache2;
            }
        else
            {
            Current = new INTERFACE_AND_OBJECT;
            if (!Current)
                {
                return FALSE;
                }
            }
        }

    Current->Update(Interface, Object);
    Current->Next = Head;
    Head = Current;

    return TRUE;
}


BOOL
INTERFACE_AND_OBJECT_LIST::Find(
    void     __RPC_FAR * Interface,
    RPC_UUID __RPC_FAR * Object
    )
{
    INTERFACE_AND_OBJECT * Current;
    INTERFACE_AND_OBJECT * Prev;

    for (Current = Head; Current; Prev = Current, Current = Current->Next)
        {
        if (Interface == Current->Interface &&
            0 == Current->Object.MatchUuid(Object))
            {
            break;
            }
        }

    if (!Current)
        {
        return FALSE;
        }

    if (Current != Head)
        {
        Prev->Next = Current->Next;
        Current->Next = Head;
        Head = Current;
        }

    return TRUE;
}


BOOL
INTERFACE_AND_OBJECT_LIST::Delete(
    void     __RPC_FAR * Interface,
    RPC_UUID __RPC_FAR * Object
    )
{
    INTERFACE_AND_OBJECT * Current;
    INTERFACE_AND_OBJECT * Prev;

    for (Current = Head; Current; Prev = Current, Current = Current->Next)
        {
        if (Interface == Current->Interface &&
            0 == Current->Object.MatchUuid(Object))
            {
            break;
            }
        }

    if (!Current)
        {
        return FALSE;
        }

    if (Current == Head)
        {
        Head = Current->Next;
        }
    else
        {
        Prev->Next = Current->Next;
        }

    if (Current == &Cache1)
        {
        Cache1Available = TRUE;
        }
    else if (Current == &Cache2)
        {
        Cache2Available = TRUE;
        }
    else
        {
        delete Current;
        }

    return TRUE;
}


INTERFACE_AND_OBJECT_LIST::~INTERFACE_AND_OBJECT_LIST(
    )
{
    INTERFACE_AND_OBJECT * Next;

    while (Head)
        {
        Next = Head->Next;

        if (Head != &Cache1 && Head != &Cache2)
            {
            delete Head;
            }

        Head = Next;
        }
}


#ifdef DEBUGRPC

void
DumpBuffer(
    void FAR * Buffer,
    unsigned Length
    )
{
    const BYTES_PER_LINE = 16;

    unsigned char FAR *p = (unsigned char FAR *) Buffer;

    //
    // 3 chars per byte for hex display, plus an extra space every 4 bytes,
    // plus a byte for the printable representation, plus the \0.
    //
    char Outbuf[BYTES_PER_LINE*3+BYTES_PER_LINE/4+BYTES_PER_LINE+1];
    Outbuf[0] = 0;
    Outbuf[sizeof(Outbuf)-1] = 0;
    char * HexDigits = "0123456789abcdef";

    unsigned Index;
    for (unsigned Offset=0; Offset < Length; Offset++)
        {
        Index = Offset % BYTES_PER_LINE;

        if (Index == 0)
            {
            DbgPrint("   %s\n", Outbuf);
            memset(Outbuf, ' ', sizeof(Outbuf)-1);
            }

        Outbuf[Index*3+Index/4  ] = HexDigits[p[Offset] / 16];
        Outbuf[Index*3+Index/4+1] = HexDigits[p[Offset] % 16];
        Outbuf[BYTES_PER_LINE*3+BYTES_PER_LINE/4+Index] = iscntrl(p[Offset]) ? '.' : p[Offset];
        }

    DbgPrint("   %s\n", Outbuf);
}
#endif

//------------------------------------------------------------------------


RPC_STATUS
DispatchCallbackRequest(
    DG_CLIENT_CALLBACK *    CallbackObject
    )
{
    BOOL                fAsyncCapable = FALSE;
    RPC_STATUS          Status = RPC_S_OK;
    RPC_MESSAGE         CallbackMessage;
    PNCA_PACKET_HEADER  pHeader = &CallbackObject->Request->Header;

    CallbackMessage.Buffer = 0;

    if (pHeader->PacketFlags2 & DG_PF2_UNRELATED)
        {
        fAsyncCapable = TRUE;
        }

    //
    // Allow only the internal "conv" interface as a callback.
    //
    if (0 != pHeader->InterfaceId.MatchUuid((RPC_UUID *) &((PRPC_SERVER_INTERFACE) conv_ServerIfHandle)->InterfaceId.SyntaxGUID ))
        {
        Status = RPC_S_UNKNOWN_IF;
        }
    else if (0 != (CallbackObject->Request->Header.PacketFlags & DG_PF_FRAG))
        {
        Status = RPC_S_CALL_FAILED_DNE;
        }
    else
        {
        //
        // Dispatch to the callback stub.
        // The client doesn't support Manager EPVs or nonidempotent callbacks.
        //
        RPC_STATUS ExceptionCode;

        CallbackMessage.Handle = CallbackObject;
        CallbackMessage.DataRepresentation = 0x00ffffff & (*(unsigned long *) &pHeader->DataRep);
        CallbackMessage.Buffer = pHeader->Data;
        CallbackMessage.BufferLength = pHeader->GetPacketBodyLen();
        CallbackMessage.ProcNum = pHeader->OperationNumber;

        CallbackMessage.ManagerEpv = 0;
        CallbackMessage.ImportContext = 0;
        CallbackMessage.TransferSyntax = 0;
        CallbackMessage.RpcFlags = RPC_NCA_FLAGS_IDEMPOTENT;

        CallbackMessage.RpcInterfaceInformation = conv_ServerIfHandle;

        Status = DispatchCallback(((PRPC_SERVER_INTERFACE) CallbackMessage.RpcInterfaceInformation)->DispatchTable,
                                  &CallbackMessage,
                                  &ExceptionCode
                                  );
        if (Status)
            {
            if (Status == RPC_P_EXCEPTION_OCCURED)
                {
                Status = ExceptionCode;
                }
            }
        else if (fAsyncCapable && CallbackObject->Connection)
            {
            CallbackObject->Connection->EnableOverlappedCalls();
            }

        LogEvent(SU_CCONN, EV_STATUS, CallbackObject->Connection, 0, Status);
        }

    if (Status != RPC_S_OK)
        {
        LogError(SU_CCONN, EV_STATUS, CallbackObject->Connection, 0, Status);

        InitErrorPacket(CallbackObject->Request, DG_REJECT, Status);
        CallbackObject->SendPacket( pHeader );
        }

    return Status;
}

//------------------------------------------------------------------------


PDG_CCONNECTION
CLIENT_ACTIVITY_TABLE::Lookup(
    RPC_UUID * Uuid
    )
/*++

Routine Description:


Arguments:

    Packet

Return Value:


--*/
{
    unsigned Hash = MakeHash(Uuid);

    RequestHashMutex(Hash);

    UUID_HASH_TABLE_NODE * Node = UUID_HASH_TABLE::Lookup(Uuid, Hash);

    PDG_CCONNECTION Connection = 0;

    if (Node)
        {
        Connection = DG_CCONNECTION::FromHashNode(Node);

        Connection->MutexRequest();
        ReleaseHashMutex(Hash);
        }
    else
        {
        ReleaseHashMutex(Hash);
        }

    return Connection;
}


RPC_STATUS
StandardPacketChecks(
    DG_PACKET * pPacket
    )
{
    if (pPacket->Header.RpcVersion != DG_RPC_PROTOCOL_VERSION)
        {
        return NCA_STATUS_VERSION_MISMATCH;
        }

    ByteSwapPacketHeaderIfNecessary(pPacket);

    if (0 == (pPacket->Flags & DG_PF_PARTIAL))
        {
        //
        // Check for inconsistent packet length fields.
        //
        if (pPacket->DataLength < sizeof(NCA_PACKET_HEADER) ||
            pPacket->DataLength - sizeof(NCA_PACKET_HEADER) < pPacket->GetPacketBodyLen())
            {
            return RPC_S_PROTOCOL_ERROR;
            }
        }

    pPacket->DataLength -= sizeof(NCA_PACKET_HEADER);

    //
    // The X/Open standard does not give these fields a full byte.
    //
    pPacket->Header.RpcVersion &= 0x0F;
    pPacket->Header.PacketType &= 0x1F;

    //
    // Fix up bogus OSF packets.
    //
    DeleteSpuriousAuthProto(pPacket);

    return RPC_S_OK;
}

//------------------------------------------------------------------------


void
ProcessDgClientPacket(
    IN DWORD                 Status,
    IN DG_TRANSPORT_ENDPOINT LocalEndpoint,
    IN void *                PacketHeader,
    IN unsigned long         PacketLength,
    IN DatagramTransportPair *AddressPair
    )
{
    PDG_PACKET Packet = DG_PACKET::FromPacketHeader(PacketHeader);

    Packet->DataLength = PacketLength;

#ifdef INTRODUCE_ERRORS

    if (::ClientDropRate)
        {
        if ((GetRandomCounter() % 100) < ::ClientDropRate)
            {
            unsigned Frag = (Packet->Header.PacketType << 16) | Packet->Header.GetFragmentNumber();
            unsigned Uuid = *(unsigned *) &Packet->Header.ActivityId;
            unsigned Type = Packet->Header.PacketType;

            LogError(SU_PACKET, EV_DROP, (void *) Uuid, (void *) Type, Frag);

            Packet->Free();
            return;
            }
        }

    if (::ClientDelayRate)
        {
        if ((GetRandomCounter() % 100) < ::ClientDelayRate)
            {
            unsigned Frag = (Packet->Header.PacketType << 16) | Packet->Header.GetFragmentNumber();
            unsigned Uuid = *(unsigned *) &Packet->Header.ActivityId;
            unsigned Type = Packet->Header.PacketType;

            LogError(SU_PACKET, EV_DELAY, (void *) Uuid, (void *) Type, Frag);

            Sleep(::ClientDelayTime);
            }
        }

#endif


    if (Status == RPC_P_OVERSIZE_PACKET)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: async packet is too large\n");
#endif
        Packet->Flags |= DG_PF_PARTIAL;
        Status = RPC_S_OK;
        }

    if (Status != RPC_S_OK)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: async receive completed with status 0x%lx\n", Status);
        RpcpBreakPoint();
#endif
        Packet->Free(FALSE);
        }

    if (Packet->Header.PacketType == DG_REQUEST)
        {
        DG_CLIENT_CALLBACK CallbackObject;

        CallbackObject.LocalEndpoint = DG_ENDPOINT::FromEndpoint( LocalEndpoint );
        CallbackObject.Connection    = 0;
        CallbackObject.Request       = Packet;
        CallbackObject.RemoteAddress = AddressPair->RemoteAddress;

        DispatchCallbackRequest(&CallbackObject);
        return;
        }

    RPC_UUID ActivityId = Packet->Header.ActivityId;

    if (NeedsByteSwap(&Packet->Header))
        {
        ByteSwapUuid(&ActivityId);
        }

    PDG_CCONNECTION Connection = ClientConnections->Lookup( &ActivityId );

    if (Connection)
        {
        Connection->DispatchPacket(Packet, AddressPair->RemoteAddress);
        }
    else
        {
#ifdef DEBUGRPC
        if (Packet->Header.PacketType != DG_QUACK)
            {
            PrintToDebugger("RPC DG: no connection found for async packet of type 0x%hx\n",
                            Packet->Header.PacketType);
            }
#endif
        Packet->Free(FALSE);
        }
}


void
DG_CCONNECTION::DispatchPacket(
    PDG_PACKET Packet,
    DG_TRANSPORT_ADDRESS Address
    )
{
    Mutex.VerifyOwned();

    PDG_CCALL Call;

    if (RPC_S_OK != StandardPacketChecks(Packet))
        {
        Packet->Free();
        MutexClear();
        return;
        }

    RPC_STATUS Status = UpdateServerAddress(Packet, Address);
    if (Status)
        {
        LogEvent(SU_CCONN, EV_PKT_IN, this, IntToPtr(Packet->Header.SequenceNumber), (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        Packet->Free();
        MutexClear();
        return;
        }

    Call = ActiveCallHead;
    while (Call && Call->GetSequenceNumber() < Packet->Header.SequenceNumber)
        {
        Call = Call->Next;
        }

    if (Call && Call->GetSequenceNumber() == Packet->Header.SequenceNumber)
        {
        Call->IncrementRefCount();
        Call->DispatchPacket(Packet);
        Call->DecrementRefCount();
        }
    else
        {
        MutexClear();
        LogEvent(SU_CCONN, EV_PKT_IN, this, IntToPtr(Packet->Header.SequenceNumber), (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        Packet->Free();
        }
}

//------------------------------------------------------------------------


RPC_STATUS
DG_CCALL::DispatchPacket(
    IN DG_PACKET * Packet
    )
{
    BOOL ExtrasReference = FALSE;
    RPC_STATUS Status;
    PNCA_PACKET_HEADER pHeader = &Packet->Header;

    LogEvent(SU_CCALL, EV_PKT_IN, this, (void *) 0, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());

    if (State == CallCancellingSend ||
        State == CallComplete )
        {
        FreePacket(Packet);
        return RPC_S_OK;
        }

    CancelDelayedSend();

    if (!CancelPending && TestCancel() > 0)
        {
        ++CancelEventId;
        CancelPending = TRUE;
        CancelTime = GetTickCount();
        }

    if (CancelPending)
        {
        if ((long(GetTickCount()) - CancelTime) / 1000 > ThreadGetRpcCancelTimeout() )
            {
            RpcpErrorAddRecord( EEInfoGCRuntime,
                                RPC_S_CALL_CANCELLED,
                                EEInfoDLDG_CCALL__DispatchPacket10,
                                (ULONG) ThreadGetRpcCancelTimeout(),
                                (ULONG) (long(GetTickCount()) - CancelTime)
                                );

            SendQuit();
            CancelPending = FALSE;
            FreePacket(Packet);
            return RPC_S_CALL_CANCELLED;
            }
        }

    if (Packet->Flags & DG_PF_PARTIAL)
        {
        SendFackOrNocall(Packet, DG_FACK);

        FreePacket(Packet);
        return RPC_S_OK;
        }

    // If the security context has expired, loop again - we will send
    // a packet using the current security context, and the server
    // will begin using that context to respond.
    //
    Status = Connection->VerifyPacket(Packet);
    if (Status)
        {
        FreePacket(Packet);

        if (Status == ERROR_SHUTDOWN_IN_PROGRESS)
            {
            return ERROR_SHUTDOWN_IN_PROGRESS;
            }

        if (pAsync && AsyncStatus == RPC_S_ASYNC_CALL_PENDING)
            {
            PostDelayedSend();
            }

        return RPC_S_OK;
        }

    if (DG_NOCALL != pHeader->PacketType)
        {
        UnansweredRequestCount = 0;
        TimeoutCount = 0;
        Connection->fAutoReconnect = FALSE;
        }

    LastReceiveTime = GetTickCount();

    //
    // It's not clear when the hint is allowed to change, so let's
    // always save it.
    //
    InterfaceHint                       = pHeader->InterfaceHint;
    ActivityHint                        = pHeader->ActivityHint;

    pSavedPacket->Header.InterfaceHint  = pHeader->InterfaceHint;
    pSavedPacket->Header.ActivityHint   = pHeader->ActivityHint;

    //
    // Handle the packet.
    //
    switch (pHeader->PacketType)
        {
        case DG_RESPONSE: Status = DealWithResponse(Packet); break;
        case DG_FACK:     Status = DealWithFack    (Packet); break;
        case DG_WORKING:  Status = DealWithWorking (Packet); break;
        case DG_NOCALL:   Status = DealWithNocall  (Packet); break;
        case DG_QUACK:    Status = DealWithQuack   (Packet); break;
        case DG_FAULT:    Status = DealWithFault   (Packet); break;
        case DG_REJECT:   Status = DealWithReject  (Packet); break;
        case DG_PING:              FreePacket      (Packet); break;
        default:          Status = RPC_S_PROTOCOL_ERROR; FreePacket(Packet); break;
        }

    if (pAsync)
        {
        if (RPC_S_OK == Status)
            {
            if (State == CallSend )
                {
                if (IsBufferAcknowledged())
                    {
                    SetState(CallQuiescent);

                    if (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE)
                        {
                        IssueNotification( RpcSendComplete );
                        }
                    }
                }

            if (fReceivedAllFragments)
                {
                AsyncStatus = RPC_S_OK;
                IssueNotification(RpcCallComplete);
                }
            else
                {
                if (State == CallReceive )
                    {
                    if (PipeReceiveSize && ConsecutiveDataBytes >= PipeReceiveSize)
                        {
                        IssueNotification( RpcReceiveComplete );
                        }
                    }

                PostDelayedSend();
                }
            }
        else
            {
            CancelDelayedSend();

            AsyncStatus = MapErrorCode(Status);
            IssueNotification(RpcCallComplete);
            }
        }

    if (CancelPending)
        {
        SendQuit();
        }

    return Status;
}


RPC_STATUS
DG_CCONNECTION::BeginCall(
    PDG_CCALL Call
    )
{
    //
    // Add the call to the end of the active call list.
    //
    Call->SetSequenceNumber(LowestUnusedSequence++);
    Call->Next = 0;
    Call->Previous = ActiveCallTail;

    if (ActiveCallHead)
        {
        ASSERT( Call->GetSequenceNumber() > ActiveCallTail->GetSequenceNumber() );

        ActiveCallTail->Next = Call;
        }
    else
        {
        ActiveCallHead = Call;
        }

    ActiveCallTail = Call;

    //
    // Update CurrentCall if appropriate.
    //
    if (WillNextCallBeQueued() == RPC_S_ASYNC_CALL_PENDING)
        {
        LogEvent(SU_CCONN, EV_PUSH, this, Call, (ULONG_PTR) CurrentCall);
        }
    else
        {
        LogEvent(SU_CCONN, EV_PUSH, this, Call, 0);
        if (CurrentCall)
            {
            CancelDelayedAck();
            }
        CurrentCall = Call;
        }

    return RPC_S_OK;
}


void
DG_CCONNECTION::EndCall(
    PDG_CCALL Call
    )
/*++

Routine Description:

    This fn removes a call from the active call list.
    If the call posts a delayed ACK, this fn should not be called
    until the delayed procedure runs or is cancelled.

Arguments:

    Call - the call to remove

--*/
{
    if (Call->Next == DG_CCALL_NOT_ACTIVE)
        {
        return;
        }

    if (Call->GetSequenceNumber() == LowestActiveSequence)
        {
        if (Call->Next)
            {
            LowestActiveSequence = Call->Next->GetSequenceNumber();
            }
        else
            {
            LowestActiveSequence = LowestUnusedSequence;
            }
        }

    if (CurrentCall == Call)
        {
        CurrentCall = Call->Next;

        //
        // Queued async calls on a dead connection are cancelled, one at a time.
        // As one is cleaned up, it will cancel the next, by induction.
        //
        if (this->fError)
            {
            if (CurrentCall && CurrentCall->InProgress())
                {
                CurrentCall->CancelAsyncCall( TRUE );
                }
            }

        if (!CurrentCall)
            {
            CurrentCall = Call->Previous;
            }
        }

    //
    // Now remove the call from the active list.
    //
    if (Call->Previous)
        {
        Call->Previous->Next = Call->Next;
        }
    else
        {
        ActiveCallHead = Call->Next;
        }

    if (Call->Next)
        {
        Call->Next->Previous = Call->Previous;
        }
    else
        {
        ActiveCallTail = Call->Previous;
        }

    Call->Next = DG_CCALL_NOT_ACTIVE;
}


RPC_STATUS
DG_CCONNECTION::MaybeTransmitNextCall()
{
    RPC_STATUS Status = 0;

    Mutex.VerifyOwned();

    if (WillNextCallBeQueued() == RPC_S_ASYNC_CALL_PENDING)
        {
        return RPC_S_OK;
        }

    if (!CurrentCall || !CurrentCall->Next)
        {
        LogEvent(SU_CCONN, EV_POP, this, 0);
        return RPC_S_OK;
        }

    PDG_CCALL Call = CurrentCall->Next;

    LogEvent(SU_CCONN, EV_POP, this, Call);

    ASSERT( Call->GetSequenceNumber() > CurrentCall->GetSequenceNumber() );

    CancelDelayedAck();

    CurrentCall = Call;

    Status = Call->SendSomeFragments();
    if (Status == RPC_P_HOST_DOWN)
        {
        return Status;
        }

    return 0;
}


RPC_STATUS
DG_CCONNECTION::WillNextCallBeQueued()
{
    if (!CurrentCall)
        {
        return RPC_S_OK;
        }

    if (fServerSupportsAsync)
        {
        if (CurrentCall->AllArgsSent &&
            CurrentCall->IsBufferAcknowledged())
            {
            return RPC_S_OK;
            }
        }
    else
        {
        if (CurrentCall->fReceivedAllFragments)
            {
            return RPC_S_OK;
            }
        }

    return RPC_S_ASYNC_CALL_PENDING;
}


RPC_STATUS
DG_CLIENT_CALLBACK::GetBuffer(
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

    This method is called to actually allocate memory for an rpc call.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call.
    ObjectUuid - Ignored

Return Value:

    RPC_S_OUT_OF_MEMORY
    RPC_S_OK

--*/
{
    PDG_PACKET  pPacket;

    //
    // Set up the message structure to point at this DG_CCALL.
    //
    Message->Handle = (RPC_BINDING_HANDLE)this;

    if (Message->BufferLength < LocalEndpoint->Stats.PreferredPduSize)
        {
        Message->BufferLength = LocalEndpoint->Stats.PreferredPduSize;
        }

    pPacket = DG_PACKET::AllocatePacket(Message->BufferLength);

    if (0 == pPacket)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    //
    // Point the buffer at the appropriate place in the packet.
    //
    Message->Buffer = pPacket->Header.Data;

    return RPC_S_OK;
}


void
DG_CLIENT_CALLBACK::FreeBuffer(
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    This is called by stubs in order to free a marshalling buffer.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call.

Return Value:

    <none>

--*/
{
    if (Message->Buffer)
        {
        PDG_PACKET Packet = DG_PACKET::FromStubData(Message->Buffer);

        Packet->Free(FALSE);
        if (Packet == Request)
            {
            Request = 0;
            }

        Message->Buffer = 0;
        }
}


RPC_STATUS
DG_CLIENT_CALLBACK::SetAsyncHandle (
    IN RPC_ASYNC_STATE * hAsync
    )
{
    return RPC_S_OK;
}

RPC_STATUS
DG_CLIENT_CALLBACK::AsyncSend(
    IN OUT PRPC_MESSAGE Message
    )
{
    return Send(Message);
}

RPC_STATUS
DG_CLIENT_CALLBACK::Send(
    IN OUT PRPC_MESSAGE Message
    )
{
    PNCA_PACKET_HEADER pHeader = CONTAINING_RECORD( Message->Buffer, NCA_PACKET_HEADER, Data );
    DG_PACKET * Packet         = CONTAINING_RECORD( Message->Buffer, DG_PACKET, Header.Data );

    //
    // The callback was successful, so the buffer has changed.
    // Create the packet header, send the response, and free the
    // request and response buffers.
    //

    *pHeader = Request->Header;

    SetMyDataRep(pHeader);

    pHeader->PacketType   = DG_RESPONSE;
    pHeader->PacketFlags  = DG_PF_NO_FACK;
    pHeader->AuthProto    = 0;
    pHeader->SetPacketBodyLen (Message->BufferLength);
    pHeader->SetFragmentNumber(0);

    if (Message->BufferLength + sizeof(NCA_PACKET_HEADER) > LocalEndpoint->Stats.MaxPduSize)
        {
        InitErrorPacket( Packet, DG_FAULT, NCA_STATUS_OUT_ARGS_TOO_BIG );
        }

    SendPacket( pHeader );

    FreeBuffer(Message);

    return RPC_S_OK;
}

RPC_STATUS
DG_CLIENT_CALLBACK::SendReceive(
    IN OUT PRPC_MESSAGE Message
    )
{
    return RPC_S_CANNOT_SUPPORT;
}

RPC_STATUS
DG_CLIENT_CALLBACK::Receive(
    IN OUT PRPC_MESSAGE Message,
    IN unsigned MinimumSize
    )
{
    return RPC_S_CANNOT_SUPPORT;
}


ENDPOINT_MANAGER::ENDPOINT_MANAGER(
    IN OUT RPC_STATUS * pStatus
    ) :
    Mutex(pStatus)
{
    unsigned u;

    for (u=0; u < DG_TRANSPORT_COUNT; ++u)
        {
        AsyncEndpoints[u] = 0;
        }

    Endpoints = 0;

    LastScavengeTime = GetTickCount();
}


DG_ENDPOINT *
ENDPOINT_MANAGER::RequestEndpoint(
    IN RPC_DATAGRAM_TRANSPORT * TransportInterface,
    IN BOOL Async,
    IN DWORD Flags,
    IN DG_CCALL *Call
    )
{
    ASSERT(0 == (Flags & PENALTY_BOX) );

    if (Async)
        {
        unsigned u;
        for (u=0; u < DG_TRANSPORT_COUNT && AsyncEndpoints[u]; ++u)
            {
            if (AsyncEndpoints[u]->TransportInterface == TransportInterface &&
                AsyncEndpoints[u]->Flags == Flags)
                {
                LogEvent(SU_CENDPOINT, EV_START, AsyncEndpoints[u], 0, Async);

                InterlockedIncrement(&AsyncEndpoints[u]->NumberOfCalls);

                return AsyncEndpoints[u];
                }
            }

        Mutex.Request();

        for (; u < DG_TRANSPORT_COUNT && AsyncEndpoints[u]; ++u)
            {
            if (AsyncEndpoints[u]->TransportInterface == TransportInterface &&
                AsyncEndpoints[u]->Flags == Flags)
                {
                Mutex.Clear();
                LogEvent(SU_CENDPOINT, EV_START, AsyncEndpoints[u], 0, Async);

                InterlockedIncrement(&AsyncEndpoints[u]->NumberOfCalls);

                return AsyncEndpoints[u];
                }
            }

        DG_ENDPOINT * Node;

        Node = (DG_ENDPOINT *) new char[sizeof(DG_ENDPOINT) + TransportInterface->ClientEndpointSize];

        LogEvent(SU_CENDPOINT, EV_CREATE, Node, TransportInterface, Async);

        if (Node)
            {
            Node->TransportInterface = TransportInterface;
            Node->Async = TRUE;
            Node->Flags = Flags;

            RPC_STATUS Status;

            //
            // If the call is a conv_callback and we are using selective bindings,
            // then we need to make sure that the endpoint created will listen only
            // on the interface that received the original DG_SCALL.  To do this we need
            // to check that this is in fact a callback and that selective bindings
            // are being used.
            //

            if (// Check that this is a callback.
                Call->pAsync->NotificationType == RpcNotificationTypeCallback &&
                // Check that this is a conv callback.
                Call->pAsync->u.APC.NotificationRoutine == &(DG_SCONNECTION::ConvNotificationRoutine) &&
                // Check that selective bindings are being used.
                pFirewallTable != NULL)
                {
                // We need to make sure that the address for the endpoint that will be created is
                // the same as that of the address on which the orignal DG_SCALL has been received.
                DG_SCONNECTION *SConnection = CONTAINING_RECORD(Call->pAsync,
                                                                DG_SCONNECTION,
                                                                Callback.AsyncState);

                PVOID ServerTransEndpoint = &(SConnection->pAddress->Endpoint.TransportEndpoint);

                Status = TransportInterface->OpenEndpoint(&Node->TransportEndpoint,
                                                          TRUE,
                                                          Flags,
                                                          ServerTransEndpoint);
                }
            else
                {
                Status = TransportInterface->OpenEndpoint(&Node->TransportEndpoint, TRUE, Flags, NULL);
                }

            if (Status)
                {
                LogError(SU_CENDPOINT, EV_STATUS, Node, 0, Status);

                Mutex.Clear();
                delete Node;
                return 0;
                }

            Status = TransportInterface->QueryEndpointStats(&Node->TransportEndpoint, &Node->Stats);
            if (Status)
                {
                LogError(SU_CENDPOINT, EV_STATUS, Node, 0, Status);
                Mutex.Clear();

                Node->TransportInterface->Close(Node->TransportEndpoint);
                delete Node;
                return 0;
                }

            Node->NumberOfCalls = 1;

            AsyncEndpoints[u] = Node;

            Mutex.Clear();

            return AsyncEndpoints[u];
            }

        LogEvent(SU_CENDPOINT, EV_STATUS, Node, 0, 0);
        return 0;
        }
    else
        {
        Mutex.Request();

        DG_ENDPOINT * Previous = 0;
        DG_ENDPOINT * Node = Endpoints;

        //
        // Look for a node on the right transport and with the same flags.
        // If the flags match except for the penalty box, use it only if
        // the endpoint has been idle for the right length of time.
        // The caller must drain any buffered packets on a penalty-box endpoint.
        //
        for ( ; Node; Previous=Node, Node=Node->Next )
            {
            if (Node->TransportInterface != TransportInterface)
                {
                continue;
                }

            if (Node->Flags == Flags)
                {
                break;
                }

            if (Node->Flags == (Flags | PENALTY_BOX) &&
                GetTickCount() - Node->TimeStamp >= PENALTY_BOX_DURATION)
            {
                break;
                }
            }

        if (Node)
            {
            if (Previous)
                {
                Previous->Next = Node->Next;
                }
            else
                {
                Endpoints = Node->Next;
                }

            Node->NumberOfCalls = 1;

            Mutex.Clear();

            LogEvent(SU_CENDPOINT, EV_START, Node, 0, Async);

            return Node;
            }
        else
            {
            Mutex.Clear();

            Node = (DG_ENDPOINT *) new char[sizeof(DG_ENDPOINT) + TransportInterface->ClientEndpointSize];

            LogEvent(SU_CENDPOINT, EV_CREATE, Node, TransportInterface, Async);

            if (Node)
                {
                Node->TransportInterface = TransportInterface;
                Node->Async = FALSE;
                Node->Flags = Flags;

                RPC_STATUS Status = TransportInterface->OpenEndpoint(&Node->TransportEndpoint, FALSE, Flags, NULL);
                if (Status)
                    {
                    LogEvent(SU_CENDPOINT, EV_STATUS, Node, 0, Status);

                    delete Node;
                    return 0;
                    }

                Status = TransportInterface->QueryEndpointStats(&Node->TransportEndpoint, &Node->Stats);
                if (Status)
                    {
                    LogEvent(SU_CENDPOINT, EV_STATUS, Node, 0, Status);

                    Mutex.Clear();

                    Node->TransportInterface->Close(Node->TransportEndpoint);
                    delete Node;
                    return 0;
                    }

                Node->NumberOfCalls = 1;
                return Node;
                }

            LogEvent(SU_CENDPOINT, EV_STATUS, Node, 0, 0);
            return 0;
            }
        }
}


void
ENDPOINT_MANAGER::ReleaseEndpoint(
    IN DG_ENDPOINT * Node
    )
{
    LogEvent(SU_CENDPOINT, EV_STOP, Node, 0, Node->Async);

    if (Node->Async)
        {
        InterlockedDecrement(&Node->NumberOfCalls);
        }
    else
        {
        Node->TimeStamp = GetTickCount();

        Mutex.Request();

        Node->Next = Endpoints;
        Endpoints = Node;

        Mutex.Clear();

        EnableGlobalScavenger();
        }
}


BOOL
ENDPOINT_MANAGER::DeleteIdleEndpoints(
    long CurrentTime
    )
{
    boolean More = FALSE;

    Mutex.Request();

    DG_ENDPOINT * Node;
    DG_ENDPOINT * Prev = 0;

    for (Node = Endpoints; Node; Node = Node->Next)
        {
        ASSERT( Node->Async == FALSE );

        if (CurrentTime - Node->TimeStamp > IDLE_ENDPOINT_LIFETIME )
            {
            break;
            }

        Prev = Node;
        More = TRUE;
        }

    if (Prev)
        {
        Prev->Next = 0;
        }
    else
        {
        Endpoints = 0;
        }

    LastScavengeTime = CurrentTime;

    Mutex.Clear();

    while (Node)
        {
        DG_ENDPOINT * Next = Node->Next;

        LogEvent(SU_CENDPOINT, EV_DELETE, Node, Node->TransportInterface, Node->Async);

        Node->TransportInterface->Close(Node->TransportEndpoint);
        delete Node;

        Node = Next;
        }

    return More;
}

void
DG_CCALL::PostDelayedSend()
{
    Connection->Mutex.VerifyOwned();

    //
    // Cancel the rpevious send, to make sure the pending-send count is accurate.
    // Then post the new request.
    //
    CancelDelayedSend();

    DelayedSendPending++;
    DelayedProcedures->Add(&TransmitTimer, (GetTickCount() - LastReceiveTime) + ReceiveTimeout, TRUE);

    LogEvent(SU_CCALL, EV_PROC, this, 0, 0x6e534450);
}

void
DG_CCALL::CancelDelayedSend()
{
    Connection->Mutex.VerifyOwned();

    LogEvent(SU_CCALL, EV_PROC, this, 0, 0x6e534443);
    if (!DelayedSendPending)
        {
        return;
        }

    if (TRUE == DelayedProcedures->Cancel(&TransmitTimer))
        {
        DelayedSendPending--;
        return;
        }

    //
    // We just missed the activation of the delayed procedure.
    // This thread must let go of the mutex in order for ExecuteDelayedSend
    // to continue.  It's important that no other thread change the call state
    // during this process, since ExecuteDelayedSend checks for that state.
    //
    DG_CLIENT_STATE OldState = State;

    SetState(CallCancellingSend);

    Connection->MutexClear();

    while (DelayedSendPending)
        {
        Sleep(1);
        }

    Connection->MutexRequest();

    SetState(OldState);
}

void
DG_CCALL::ExecuteDelayedSend()
{
    LogEvent(SU_CCALL, EV_PROC, this, 0, 0x6e534445);

    Connection->MutexRequest();

    DelayedSendPending--;

    if (DelayedSendPending)
        {
        //
        // Multiple sends are pending.  Only one is helpful.
        //
        Connection->MutexClear();
        return;
        }

    if (State == CallCancellingSend)
        {
        Connection->MutexClear();
        return;
        }

    if (!TimeoutCount)
        {
        ReceiveTimeout = 500;
        }

    IncreaseReceiveTimeout();

    RPC_STATUS Status = DealWithTimeout();

    if (Status != RPC_S_OK)
        {
        AsyncStatus = MapErrorCode(Status);
        IssueNotification( RpcCallComplete );
        }

    Connection->MutexClear();
}


void
DelayedSendProc(
    void * parm
    )
{
    PDG_CCALL(parm)->ExecuteDelayedSend();
}


DG_ASSOCIATION_TABLE::DG_ASSOCIATION_TABLE(
                                           RPC_STATUS * pStatus
                                           )
                                           : Mutex( *pStatus )
{
    Associations       = InitialAssociations;
    AssociationsLength = INITIAL_ARRAY_LENGTH;

    long i;
    for (i=0; i < AssociationsLength; ++i)
        {
        Associations[i].fBusy = FALSE;
        Associations[i].Hint  = ~0;
        }

    fCasUuidReady      = FALSE;

    PreviousFreedCount = MINIMUM_IDLE_ENTRIES;
}




RPC_STATUS
DG_ASSOCIATION_TABLE::Add(
    DG_CASSOCIATION * Association
    )
/*++

Routine Description:

    Adds <Association> to the table.

Return Value:

    zero if success
    a Win32 error if failure

--*/
{
    LONG i;
    LONG OldAssociationsLength;

    //
    // Make a hint for the association.
    //
    HINT Hint = MakeHint( Association->pDceBinding );

    //
    // Look for an open space in the current block.
    //
    Mutex.LockExclusive();

    //
    // Make sure this process has a "client address space UUID".  The callback
    // for each connection will ask for it.
    // We do this here because we are not supposed to do it in InitializeRpcProtocolDgClient.
    // It would cause a perf hit even in code that uses only LRPCbindings.
    //
    if (!fCasUuidReady)
        {
        RPC_STATUS Status;

        Status = UuidCreate(&CasUuid);
        if (Status == RPC_S_UUID_LOCAL_ONLY)
            {
            Status = 0;
            }

        if (Status)
            {
            Mutex.UnlockExclusive();

            LogEvent( SU_CASSOC, EV_STATUS, 0, 0, Status );
            return Status;
            }

        fCasUuidReady = TRUE;
        }

    for (i = 0; i < AssociationsLength; ++i)
        {
        if (!Associations[i].fBusy)
            {
            break;
            }
        }

    if (i == AssociationsLength)
        {
        //
        // The current block is full; allocate an expanded block.
        //
        LONG NewAssociationsLength = 2*AssociationsLength;
        NODE * NewAssociations = new NODE[ NewAssociationsLength ];
        if (!NewAssociations)
            {
            Mutex.UnlockExclusive();

            LogEvent( SU_CASSOC, EV_STATUS, 0, 0, RPC_S_OUT_OF_MEMORY );
            return RPC_S_OUT_OF_MEMORY;
            }

        //
        // Initialize the used and unused sections of the new block.
        //
        RpcpMemoryCopy( NewAssociations, Associations, sizeof(NODE) * AssociationsLength );

        RpcpMemorySet( &NewAssociations[ AssociationsLength ], 0, sizeof(NODE) * (NewAssociationsLength-AssociationsLength) );

        //
        // Replace the block.
        //
        if (Associations != InitialAssociations)
            {
            delete Associations;
            }

        i = AssociationsLength;

        Associations = NewAssociations;
        AssociationsLength = NewAssociationsLength;
        }

    Associations[i].fBusy       = TRUE;
    Associations[i].Hint        = Hint;
    Associations[i].Association = Association;
    Associations[i].TimeStamp   = GetTickCount();
    Associations[i].ContextHandleCount = 0;

    Association->InternalTableIndex = i;

    Mutex.UnlockExclusive();

    return 0;
}


DG_CASSOCIATION *
DG_ASSOCIATION_TABLE::Find(
     DG_BINDING_HANDLE    * Binding,
     RPC_CLIENT_INTERFACE * Interface,
     BOOL                   fContextHandle,
     BOOL                   fPartial,
     BOOL                   fAutoReconnect
     )
/*++

Routine Description:

    Locate an association that matches <Binding>'s DCE_BINDING.
    If <fPartial> is true, the endpoint will not be compared, but the
    association must have <Interface> in its list of successful interfaces
    in order to match. <fContextHandle> is true if the binding handle is
    embedded in a context handle.

Return Value:

    the association, if an matching one was found
    NULL otherwise

--*/
{
    //
    // Calculate the hint for a matching association.
    //
    HINT Hint = MakeHint( Binding->pDceBinding );

    //
    // For auto-reconnect, only recently-successful associations qualify.
    // MinimumTime is after the failed call began, at least for most com-timeout
    // settings.
    //
    long MinimumTime = GetTickCount() - (15 * 1000);

    // DG_CASSOCIATION::ComparePartialBinding and DG_CASSOCIATION::CompareWithBinding
    // both take DG_CASSOCIATION::Mutex.  This can lead to mutex inversion with an
    // exclusive lock to DG_ASSOCIATION_TABLE, since in th eother parts of the code
    // DG_ASSOCIATION_TABLE shared and exclusive locks are taken after DG_CASSOCIATION::Mutex
    // is taken.
    //
    // Since this is th eonly path on which CompareWithBinding and ComparePartialBinding are called,
    // we can just take an exclusive  Mutex instead of a shared one and not take the
    // DG_CASSOCIATION::Mutex during the binding comparison.
    Mutex.LockExclusive();

    long i;
    for (i = 0; i < AssociationsLength; ++i)
        {
        if (Associations[i].Hint == Hint &&
            Associations[i].fBusy)
            {
            DG_CASSOCIATION * Association = Associations[i].Association;

            if (Association->ErrorFlag())
                {
                continue;
                }

            if (Association->fLoneBindingHandle)
                {
                continue;
                }

            if (fAutoReconnect &&
                MinimumTime - Association->LastReceiveTime > 0)
                {
                continue;
                }

            if (fPartial)
                {
                if (Association->ComparePartialBinding(Binding, Interface) == TRUE)
                   {
                   Association->IncrementBindingRefCount(fContextHandle);
                   Associations[i].TimeStamp   = GetTickCount();

                   Mutex.UnlockExclusive();
                   return Association;
                   }
                }
            else
                {
                if (Association->CompareWithBinding(Binding) == 0)
                   {
                   Association->IncrementBindingRefCount(fContextHandle);
                   Associations[i].TimeStamp   = GetTickCount();

                   Mutex.UnlockExclusive();
                   return Association;
                   }
                }
            }
        }

    Mutex.UnlockExclusive();
    return 0;
}


void
ContextHandleProc(
                  void * arg
                  )
{
    ActiveAssociations->SendContextHandleKeepalives();
}

BOOL
DG_ASSOCIATION_TABLE::SendContextHandleKeepalives()
{
    BOOL fContextHandles = FALSE;
    long StartTime = GetTickCount();

    Mutex.LockShared();

    long i;
    for (i=0; i < AssociationsLength; ++i)
        {
        if (!Associations[i].fBusy)
            {
            continue;
            }

        if (Associations[i].ContextHandleCount > 0)
            {
            fContextHandles = TRUE;

            if (StartTime - Associations[i].TimeStamp >= CXT_HANDLE_KEEPALIVE_INTERVAL)
                {
                //
                // We have to avoid holding the shared lock when calling a procedure
                // that may take the exclusive lock.
                // DG_CASSOCIATION::DecrementRefCount may delete the association,
                // and that would want the exclusive table lock.
                //
                Associations[i].Association->IncrementRefCount();
                Mutex.UnlockShared();

                if (Associations[i].Association->SendKeepAlive())
                    {
                    Associations[i].TimeStamp = GetTickCount();
                    }

                Associations[i].Association->DecrementRefCount();
                Mutex.LockShared();
                }
            }
        }

    Mutex.UnlockShared();

    if (fContextHandles)
        {
        long FinishTime = GetTickCount();

        if (FinishTime-StartTime >= CXT_HANDLE_SWEEP_INTERVAL)
            {
            //
            // We are behind. Recursion or "goto start" would be cheaper,
            // but would block other delayed procs that are ready to fire.
            //
            DelayedProcedures->Add(ContextHandleTimer, 0, TRUE);
            }
        else
            {
            DelayedProcedures->Add(ContextHandleTimer, CXT_HANDLE_SWEEP_INTERVAL-(FinishTime-StartTime), TRUE);
            }
        }
    return fContextHandles;
}


void
DG_ASSOCIATION_TABLE::Delete(
    DG_CASSOCIATION * Association
    )
{
    long Index = Association->InternalTableIndex;

    if (Index == -1)
        {
        return;
        }

    ASSERT( Index >= 0 && Index < AssociationsLength );
    ASSERT( Associations[Index].Association == Association );

    Mutex.LockExclusive();

    ASSERT( Associations[Index].fBusy );

    Associations[Index].fBusy = FALSE;
    Associations[Index].Hint  = ~0;

    Mutex.UnlockExclusive();

    delete Association;
}


BOOL
DG_ASSOCIATION_TABLE::DeleteIdleEntries(
                                        long CurrentTime
                                        )
/*++

Routine Description:

    This deletes entries idle more than IDLE_CASSOCIATION_LIFETIME milliseconds.

    The fn takes only the read lock until it finds an entry that needs deletion.
    Then it takes the write lock, and keeps it until the table is scoured.

Return Value:

    TRUE if items are left in the table at the end
    FALSE if the table is empty at the end

--*/
{
    BOOL fExclusive = FALSE;
    BOOL fLeftovers = FALSE;
    long i = 0;
    DG_CASSOCIATION * Association;

    //
    // Initialize an array to hold removed associations.
    //
    long NextFreedEntry = 0;
    long MaximumFreedEntries = PreviousFreedCount;

    DG_CASSOCIATION ** FreedEntries = (DG_CASSOCIATION **) _alloca( sizeof(DG_CASSOCIATION *) * MaximumFreedEntries );

    memset( FreedEntries, 0, sizeof(DG_CASSOCIATION *) * MaximumFreedEntries );

    //
    //
    //
    Mutex.LockShared();

    for (i=0; i < AssociationsLength; ++i)
        {
        if (Associations[i].fBusy)
            {
            if (CurrentTime - Associations[i].TimeStamp > IDLE_CASSOCIATION_LIFETIME)
                {
                //
                // We must claim the exclusive lock now to get an accurate answer.
                //
                if (!fExclusive)
                    {
                    fExclusive = TRUE;
                    Mutex.ConvertToExclusive();
                    }

                if (Associations[i].fBusy &&
                    CurrentTime - Associations[i].TimeStamp > IDLE_CASSOCIATION_LIFETIME &&
                    Associations[i].Association->ReferenceCount.GetInteger() == 0)
                    {
                    //
                    // It's official; the association will be deleted.
                    // Add it to the deletion array and release its slot in Associations[]..
                    //
                    Associations[i].Association->InternalTableIndex = -1;
                    FreedEntries[ NextFreedEntry ] = Associations[i].Association;

                    Associations[i].fBusy = FALSE;
                    Associations[i].Hint  = ~0;

                    ++NextFreedEntry;
                    if (NextFreedEntry == MaximumFreedEntries)
                        {
                        break;
                        }
                    }
                else
                    {
                    fLeftovers = TRUE;
                    }
                }
            else
                {
                fLeftovers = TRUE;
                }
            }
        }

    if (fExclusive)
        {
        Mutex.UnlockExclusive();
        }
    else
        {
        Mutex.UnlockShared();
        }

    //
    // Calculate the length of the array for the next pass.
    //
    if (NextFreedEntry == MaximumFreedEntries)
        {
        fLeftovers = TRUE;
        PreviousFreedCount = MaximumFreedEntries * 2;
        }
    else if (NextFreedEntry < MINIMUM_IDLE_ENTRIES)
        {
        PreviousFreedCount = MINIMUM_IDLE_ENTRIES;
        }
    else
        {
        PreviousFreedCount = NextFreedEntry;
        }

    //
    // Delete the removed associations.
    //
    --NextFreedEntry;
    while (NextFreedEntry >= 0)
        {
        delete FreedEntries[ NextFreedEntry ];
        --NextFreedEntry;
        }

    return fLeftovers;
}


DG_ASSOCIATION_TABLE::HINT
DG_ASSOCIATION_TABLE::MakeHint(
                               DCE_BINDING * pDceBinding
                               )
/*++

Routine Description:

    Construct a cheap hint to scan the association table.
    The hint should not depend on the endpoint, since we want
    a partial binding's pDceBinding to match an association
    that has a resolved endpoint.

Return Value:

    The hint.

--*/
{
    HINT Hint = 0;
    RPC_CHAR * String;

    String = pDceBinding->InqNetworkAddress();

    while (*String)
        {
        Hint *= 37;
        Hint += *String;
        ++String;
        }

    return Hint;
}


void
DG_ASSOCIATION_TABLE::IncrementContextHandleCount(
    DG_CASSOCIATION * Association
    )
/*++

Routine Description:

    Increment the count of context handles associated with this index.
    This is stired in the table rather than in the association
    so that the count can be accessed even if the association is swapped out.

--*/
{
    Mutex.LockShared();

    long Index = Association->InternalTableIndex;

    if (Index == -1)
        {
        Mutex.UnlockShared();
        return;
        }

    ASSERT( Index >= 0 && Index < AssociationsLength );
    ASSERT( Associations[Index].Association == Association );

    ++Associations[Index].ContextHandleCount;

    Mutex.UnlockShared();
}


void
DG_ASSOCIATION_TABLE::DecrementContextHandleCount(
    DG_CASSOCIATION * Association
    )
/*++

Routine Description:

    Decrement the count of context handles associated with this index.
    This is stired in the table rather than in the association
    so that the count can be accessed even if the association is swapped out.

--*/
{
    Mutex.LockShared();

    long Index = Association->InternalTableIndex;

    if (Index == -1)
        {
        Mutex.UnlockShared();
        return;
        }

    ASSERT( Index >= 0 && Index < AssociationsLength );
    ASSERT( Associations[Index].Association == Association );

    --Associations[Index].ContextHandleCount;

    Mutex.UnlockShared();
}


long
DG_ASSOCIATION_TABLE::GetContextHandleCount(
    DG_CASSOCIATION * Association
    )
/*++

Routine Description:

    Decrement the count of context handles associated with this index.
    This is stired in the table rather than in the association
    so that the count can be accessed even if the association is swapped out.

--*/
{
    long Count;
    Mutex.LockShared();
    long Index = Association->InternalTableIndex;

    if (Index == -1)
        {
        Mutex.UnlockShared();
        return 0;
        }

    ASSERT( Index >= 0 && Index < AssociationsLength );
    ASSERT( Associations[Index].Association == Association );

    Count = Associations[Index].ContextHandleCount;

    Mutex.UnlockShared();

    return Count;
}


void
DG_ASSOCIATION_TABLE::UpdateTimeStamp(
    DG_CASSOCIATION * Association
    )
/*++

Routine Description:

    Decrement the count of context handles associated with this index.
    This is stired in the table rather than in the association
    so that the count can be accessed even if the association is swapped out.

--*/
{
    Mutex.LockShared();
    long Index = Association->InternalTableIndex;

    if (Index == -1)
        {
        Mutex.UnlockShared();
        return;
        }

    ASSERT( Index >= 0 && Index < AssociationsLength );
    ASSERT( Associations[Index].Association == Association );

    Associations[Index].TimeStamp = GetTickCount();
    Mutex.UnlockShared();
}


//
// test hook data.
//
//
// casting unsigned to/from void * is OK in this case.
//
#pragma warning(push)
#pragma warning(disable:4312)
NEW_NAMED_SDICT2( TEST_HOOK, RPC_TEST_HOOK_FN_RAW, RPC_TEST_HOOK_ID );
#pragma warning(pop)

TEST_HOOK_DICT2 * pTestHookDict;

RPCRTAPI
DWORD
RPC_ENTRY
I_RpcSetTestHook(
    RPC_TEST_HOOK_ID id,
    RPC_TEST_HOOK_FN fn
    )
{
    InitializeIfNecessary();

    GlobalMutexRequest();

    if (0 == pTestHookDict)
        {
        pTestHookDict = new TEST_HOOK_DICT2;
        if (!pTestHookDict)
            {
            GlobalMutexClear();
            return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

    pTestHookDict->Delete( id );
    pTestHookDict->Insert( id, fn );

    GlobalMutexClear();
    return 0;
}

void
ForceCallTestHook(
    RPC_TEST_HOOK_ID id,
    PVOID            subject,
    PVOID            object
    )
{
    if (pTestHookDict)
        {
        RPC_TEST_HOOK_FN fn = pTestHookDict->Find( id );

        if (fn)
            {
            (*fn)(id, subject, object);
            }
        }
}


RPC_TEST_HOOK_FN
GetTestHook(
    RPC_TEST_HOOK_ID id
    )
{
    return pTestHookDict->Find( id );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dgpkt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       dgpkt.cxx
//
//--------------------------------------------------------------------------

/*++

Module Name:

    dgpkt.cxx

Abstract:



Author:

    Jeff Roberts (jroberts)  22-May-1995

Revision History:

     22-May-1995     jroberts

        Created this module.

     09-Jul-1997     edwardr

        Added support for large packets (>65535) for Falcon/RPC.

--*/

#include <precomp.hxx>
#include <dgpkt.hxx>

unsigned long   ProcessStartTime;
unsigned        RandomCounter = 0x6789abce;


const unsigned
RpcToPacketFlagsArray[8] =
{
    0,
    DG_PF_IDEMPOTENT,
                       DG_PF_BROADCAST,
    DG_PF_IDEMPOTENT | DG_PF_BROADCAST,
                                         DG_PF_MAYBE,
    DG_PF_IDEMPOTENT |                   DG_PF_MAYBE,
                       DG_PF_BROADCAST | DG_PF_MAYBE,
    DG_PF_IDEMPOTENT | DG_PF_BROADCAST | DG_PF_MAYBE,
};

const unsigned
PacketToRpcFlagsArray[8] =
{
            0           |            0             |           0            ,
    RPC_NCA_FLAGS_MAYBE |            0             |           0            ,
            0           | RPC_NCA_FLAGS_IDEMPOTENT |           0            ,
    RPC_NCA_FLAGS_MAYBE | RPC_NCA_FLAGS_IDEMPOTENT |           0            ,
            0           |            0             | RPC_NCA_FLAGS_BROADCAST,
    RPC_NCA_FLAGS_MAYBE |            0             | RPC_NCA_FLAGS_BROADCAST,
            0           | RPC_NCA_FLAGS_IDEMPOTENT | RPC_NCA_FLAGS_BROADCAST,
    RPC_NCA_FLAGS_MAYBE | RPC_NCA_FLAGS_IDEMPOTENT | RPC_NCA_FLAGS_BROADCAST,
};


DG_PACKET_ENGINE::DG_PACKET_ENGINE(
    unsigned char           a_PacketType,
    DG_PACKET *             a_Packet,
    RPC_STATUS *            pStatus
    ) :
    pSavedPacket          (a_Packet),
    PacketType            (a_PacketType),
    ReferenceCount        (0),
    BaseConnection        (0),
    SourceEndpoint        (0),
    RemoteAddress         (0),
    Buffer                (0),
    BufferLength          (0),
    QueuedBufferHead      (0),
    QueuedBufferTail      (0),
    pReceivedPackets      (0),
    pLastConsecutivePacket(0),
    ConsecutiveDataBytes  (0),
    ReceiveFragmentBase   (0),
    CachedPacket          (0),
    LastReceiveBuffer     (0),
    LastReceiveBufferLength(0),

    Cancelled             (FALSE)

{
    if (!a_Packet)
        {
        *pStatus = RPC_S_OUT_OF_MEMORY;
        }

    if (*pStatus)
        {
        return;
        }

    pSavedPacket->Header.RpcVersion    = DG_RPC_PROTOCOL_VERSION;
    pSavedPacket->Header.PacketFlags   = 0;

    SetMyDataRep(&pSavedPacket->Header);

#ifdef DEBUGRPC
    BasePacketFlags = ~0;
#endif
}

void
DG_PACKET_ENGINE::ReadConnectionInfo(
    DG_COMMON_CONNECTION * a_Connection,
    DG_TRANSPORT_ADDRESS   a_RemoteAddress
    )
{
    BaseConnection        = a_Connection;
    RemoteAddress         = a_RemoteAddress;

    CurrentPduSize        = 0;
    SetFragmentLengths();

    pSavedPacket->Header.InterfaceHint = 0xffff;
    RpcpMemoryCopy( &pSavedPacket->Header.ActivityId,
                    &a_Connection->ActivityNode.Uuid,
                    sizeof(UUID)
                    );
}

DG_PACKET_ENGINE::~DG_PACKET_ENGINE(
    )
{
    ASSERT( !LastReceiveBuffer );
    ASSERT( !pReceivedPackets  );
    ASSERT( !QueuedBufferHead  );
    ASSERT( !Buffer            );

    if (pSavedPacket)
        {
        FreePacket(pSavedPacket);
        }

    if (CachedPacket)
        {
        FreePacket(CachedPacket);
        }

    CleanupReceiveWindow();
}


void
DG_PACKET_ENGINE::NewCall()
/*++

Routine Description:

    A new call dawns.

Arguments:



Return Value:

    none

--*/

{
    ASSERT( !pLastConsecutivePacket );
    ASSERT( !ConsecutiveDataBytes );

    ASSERT( !LastReceiveBuffer );

    SetFragmentLengths();

    Buffer = 0;

    fReceivedAllFragments = FALSE;
    fRetransmitted        = FALSE;

    TimeoutCount        = 0;

    RepeatedFack        = 0;
    FackSerialNumber    = 0;
    SendSerialNumber    = 0;
    ReceiveSerialNumber = 0;

    SendWindowBase      = 0;
    FirstUnsentFragment = 0;
    SendBurstLength     = SendWindowSize;

    ReceiveFragmentBase = 0;

    RingBufferBase = 0;

#ifdef DEBUGRPC

    for (unsigned i=0; i < MAX_WINDOW_SIZE; i++)
        {
        FragmentRingBuffer[i].SerialNumber = 0xeeee0000;
        FragmentRingBuffer[i].Length       = 0xdd000000;
        FragmentRingBuffer[i].Offset       = 0xb000b000;
        }

#endif

    BasePacketFlags2 = 0;
}


RPC_STATUS
DG_PACKET_ENGINE::PushBuffer(
    PRPC_MESSAGE Message
    )
/*++

Function Description:

    Submits a buffer to be sent over the network.
    If a buffer is in progress, the new buffer is added to the
    "pending" list.  IF not, the buffer is placed in the "active" slot.

    The only time a buffer will not go in the active slot is during an
    async pipe call when the app is not waiting for send-complete
    notifications before submitting new buffers.

Notes:

    The buffer sent will be truncated to the nearest packet if
    RPC_BUFFER_PARTIAL is set, and Message.BufferLength is set to
    the amount actually sent.

--*/
{
//    ASSERT( Buffer == 0 || IsBufferAcknowledged() );

    RPC_STATUS Status = 0;
    RPC_STATUS FixupStatus = 0;
    unsigned FractionalPart = Message->BufferLength % MaxFragmentSize;
    unsigned SendLength     = Message->BufferLength;

    if (Message->RpcFlags & RPC_BUFFER_PARTIAL)
        {
        SendLength -= FractionalPart;
        }

    if (!Buffer || IsBufferAcknowledged())
        {
        SetCurrentBuffer(Message->Buffer,
                         SendLength,
                         Message->RpcFlags
                         );

        Status = SendSomeFragments();
        }
    else
        {
        QUEUED_BUFFER * Node = new QUEUED_BUFFER;
        if (!Node)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        Node->Buffer       = Message->Buffer;
        Node->BufferLength = SendLength;
        Node->BufferFlags  = Message->RpcFlags;
        Node->Next = 0;

        if (QueuedBufferTail)
            {
            QueuedBufferTail->Next = Node;
            }
        else
            {
            ASSERT( !QueuedBufferHead );

            QueuedBufferHead = Node;
            }

        QueuedBufferTail = Node;

        Status = 0;
        }

    FixupStatus = FixupPartialSend(Message);

    if (!Status)
        {
        Status = FixupStatus;
        }

    return Status;
}


RPC_STATUS
DG_PACKET_ENGINE::PopBuffer(
                            BOOL fSend
                            )
/*++

Function Description:

    Move the next pending send buffer into the active send buffer slot.
    This is a no-op except unless this is an async pipe call and the app
    is not waiting for send-complete notifications.

Notes:

    The buffer sent will be truncated to the nearest packet if
    RPC_BUFFER_PARTIAL is set, and Message.BufferLength is set to
    the amount actually sent.

--*/
{
    RPC_STATUS Status = 0;
    RPC_MESSAGE Message;

    Message.Buffer       = Buffer;
    Message.BufferLength = BufferLength;

    QUEUED_BUFFER * Node = QueuedBufferHead;

    if (Node)
        {
        QueuedBufferHead = Node->Next;
        if (!QueuedBufferHead)
            {
            QueuedBufferTail = 0;
            }

        SetCurrentBuffer(Node->Buffer, Node->BufferLength, Node->BufferFlags);
        if (fSend)
            {
            Status = SendSomeFragments();
            }
        delete Node;
        }
    else
        {
        Buffer       = 0;
        BufferLength = 0;
        BufferFlags  = 0;
        }

    if (Message.Buffer)
        {
        CommonFreeBuffer(&Message);
        }

    return Status;
}


RPC_STATUS
DG_PACKET_ENGINE::FixupPartialSend(
    RPC_MESSAGE * Message
    )
/*++

Function Description:

    This fn "does the right thing" with the unsent bit at the end of
    a pipe send.  For sync sends, this means moving the unsent bit
    to the front of the existing buffer.  For async sends, this means
    allocating a new buffer and copying the unsent bit into it.

--*/
{
    if (!(Message->RpcFlags & RPC_BUFFER_PARTIAL))
        {
        // We need this so Receive will be passed a null buffer
        // unless the stub sticks one in the message.

        Message->Buffer = 0;
        Message->BufferLength = 0;
        return RPC_S_OK;
        }

    unsigned FractionalPart;

//    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
//        {
        RPC_MESSAGE NewMessage;

        FractionalPart = Message->BufferLength % MaxFragmentSize;
        if (!FractionalPart)
            {
            Message->Buffer = 0;
            Message->BufferLength = 0;
            return RPC_S_OK;
            }

        DG_PACKET * Packet = DG_PACKET::AllocatePacket(CurrentPduSize);
        if (!Packet)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        RpcpMemoryCopy(Packet->Header.Data,
                       ((char *) Message->Buffer) + (Message->BufferLength - FractionalPart),
                       FractionalPart
                       );

        Message->Buffer       = Packet->Header.Data;
        Message->BufferLength = FractionalPart;
//        }
//    else
//        {
//        char * Temp = (char *) Message->Buffer;
//
//        FractionalPart = Message->BufferLength - FirstUnsentOffset;
//        if (!FractionalPart)
//            {
//            return RPC_S_OK;
//            }
//
//        RpcpMemoryMove(Message->Buffer, Temp + FirstUnsentOffset, FractionalPart);
//        Message->BufferLength = FractionalPart;
//        }

    return RPC_S_OK;
}


void
DG_PACKET_ENGINE::SetCurrentBuffer(
     void *        a_Buffer,
     unsigned      a_BufferLength,
     unsigned long a_BufferFlags
     )
{
    Buffer       = a_Buffer;
    BufferLength = a_BufferLength;
    BufferFlags  = a_BufferFlags;

    TimeoutCount = 0;
    SendWindowBits = 0;
    FirstUnsentOffset = 0;

    if (BufferLength == 0)
        {
        FinalSendFrag = SendWindowBase;
        }
    else
        {
        FinalSendFrag = SendWindowBase + (BufferLength-1) / MaxFragmentSize;
        }
}


RPC_STATUS
DG_PACKET_ENGINE::CommonGetBuffer(
    RPC_MESSAGE * Message
    )
{
    unsigned char SubjectType;
    void * Subject;

    unsigned    Length;
    PDG_PACKET  pPacket;

    Length = sizeof(NCA_PACKET_HEADER)
             + Align8(Message->BufferLength)
             + SecurityTrailerSize;

    unsigned BaseLength = BaseConnection->TransportInterface->BasePduSize;

//    if (Length <= BaseLength)
//        {
//        pPacket = DG_PACKET::AllocatePacket(BaseLength);
//        }
//    else if (Length <= CurrentPduSize)
//        {
//        pPacket = AllocatePacket();
//        }
//    else
        {
        pPacket = DG_PACKET::AllocatePacket(Length);
        }

    if (0 == pPacket)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    //
    // Point the buffer at the appropriate place in the packet.
    //
    Message->Buffer = pPacket->Header.Data;

//    if (pPacket->MaxDataLength < 256)
//        {
//        AddActivePacket(pPacket);
//        }

    return RPC_S_OK;
}


void
DG_PACKET_ENGINE::CommonFreeBuffer(
    RPC_MESSAGE * Message
    )
{
    if (!Message->Buffer)
        {
        return;
        }

    PDG_PACKET Packet = DG_PACKET::FromStubData(Message->Buffer);

    LogEvent(SU_ENGINE, EV_PROC, this, Message->Buffer, 'F' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));

    ASSERT( Packet->MaxDataLength < 0x7fffffffUL );

//    if (Packet && Packet->MaxDataLength < 256)
//        {
//        RemoveActivePacket(Packet);
//        }

    FreePacket(Packet);

    if (Message->Buffer == LastReceiveBuffer)
        {
        LastReceiveBuffer = 0;
        LastReceiveBufferLength = 0;
        }

    Message->Buffer = 0;
}


RPC_STATUS
DG_PACKET_ENGINE::CommonReallocBuffer(
    IN RPC_MESSAGE * Message,
    IN unsigned int NewSize
    )
{
    if (Message->Buffer == LastReceiveBuffer &&
        NewSize <= LastReceiveBufferLength)
        {
        Message->BufferLength = NewSize;

        return RPC_S_OK;
        }

    RPC_STATUS Status;
    RPC_MESSAGE NewMessage;

    NewMessage.BufferLength = NewSize;

    Status = CommonGetBuffer(&NewMessage);
    if (RPC_S_OK != Status)
        {
        return Status;
        }

    LastReceiveBuffer       = NewMessage.Buffer;
    LastReceiveBufferLength = NewMessage.BufferLength;

    if (NewSize >= Message->BufferLength)
        {
        RpcpMemoryCopy(NewMessage.Buffer,
                       Message->Buffer,
                       Message->BufferLength
                       );
        }

    CommonFreeBuffer(Message);

    Message->Buffer             = NewMessage.Buffer;
    Message->BufferLength       = NewMessage.BufferLength;

    return RPC_S_OK;
}

void
DG_PACKET_ENGINE::CleanupSendWindow()
{
    while (Buffer)
        {
        PopBuffer(FALSE);
        }
}

void
DG_PACKET_ENGINE::CleanupReceiveWindow()
{
    //
    // Free any response packets.
    //
    while (pReceivedPackets)
        {
        PDG_PACKET Next = pReceivedPackets->pNext;
        FreePacket(pReceivedPackets);
        pReceivedPackets = Next;
        }

    pLastConsecutivePacket = 0;
    ConsecutiveDataBytes = 0;
}


RPC_STATUS
DG_PACKET_ENGINE::SendSomeFragments()
/*++

Routine Description:

    Sends some fragments of the user buffer.

Arguments:



Return Value:

    result of the send operation

--*/

{
    RPC_STATUS Status = RPC_S_OK;
    unsigned short i = 0;
    unsigned short AckFragment;
    unsigned short Frag;
    unsigned short Remainder;
    unsigned Offset;
    unsigned FragmentsSent = 0;

#ifdef DEBUGRPC
    if (!Buffer &&
        (BufferFlags & RPC_BUFFER_PARTIAL))
        {
//        return RPC_S_SEND_INCOMPLETE;
        RpcpBreakPoint();
        }
#endif

    if (SendBurstLength > SendWindowSize)
        {
        SendBurstLength = SendWindowSize;
        }

    //
    // If we can extend the window, do so; otherwise, resend old packets.
    //
    if (FirstUnsentFragment <= FinalSendFrag &&
        FirstUnsentFragment < SendWindowBase + SendWindowSize)
        {
        unsigned short ThisBurstLength;

        Frag = FirstUnsentFragment;

        ThisBurstLength = SendBurstLength;

        if (ThisBurstLength > FinalSendFrag + 1 - Frag)
            {
            ThisBurstLength = FinalSendFrag + 1 - Frag;
            }

        if (Frag + ThisBurstLength > SendWindowBase + SendWindowSize)
            {
            ThisBurstLength = (SendWindowBase + SendWindowSize) - Frag;
            }

        while (++FragmentsSent <= ThisBurstLength && Status == RPC_S_OK)
            {
            if (FragmentsSent == ThisBurstLength &&
                (Frag != FinalSendFrag || (BufferFlags & RPC_BUFFER_PARTIAL) || (BasePacketFlags2 & DG_PF2_UNRELATED)))
                {
                Status = SendFragment(Frag, PacketType, TRUE);
                }
            else
                {
                Status = SendFragment(Frag, PacketType, FALSE);
                }

            ++Frag;
            }

        //
        // Cut down the burst length if our window is maxed out.
        //
        if (Frag - SendWindowBase >= SendWindowSize)
            {
            SendBurstLength = (1+SendBurstLength)/2;
            }
        }

    if (0 == FragmentsSent && !IsBufferAcknowledged())
        {
        // We can get here if all the unacknowledged fragments have serial
        // numbers greater than the one the client last acknowledged, and
        // the window is also maxed out.
        //
        // This could mean the network is very slow, or the unack'ed packets
        // have been lost.
        //
        Status = SendFragment(SendWindowBase, PacketType, TRUE);
        }

    return Status;
}


RPC_STATUS
DG_PACKET_ENGINE::SendFragment(
    unsigned FragNum,
    unsigned char PacketType,
    BOOL fFack
    )
{
    NCA_PACKET_HEADER PriorData;
    UNALIGNED NCA_PACKET_HEADER __RPC_FAR * pHeader;

    //
    // Figure out where the packet starts and how long it is.
    //
    unsigned Offset;
    unsigned Length;
    unsigned Index = (FragNum - SendWindowBase + RingBufferBase) % MAX_WINDOW_SIZE;
    unsigned DistanceToEnd;

    if (FragNum < FirstUnsentFragment)
        {
        Offset = FragmentRingBuffer[Index].Offset;
        Length = FragmentRingBuffer[Index].Length;
        DistanceToEnd = BufferLength - Offset;

#ifdef DEBUGRPC
        if (Offset >= 0xb000b000 || Length >= 0xdd000000)
            {
            RpcpBreakPoint();
            }
#endif
        fRetransmitted = TRUE;
        }
    else
        {
        ASSERT(FragNum == FirstUnsentFragment);

        Offset = FirstUnsentOffset;
        Length = MaxFragmentSize;
        DistanceToEnd = BufferLength - Offset;

        if (DistanceToEnd < Length)
            {
            Length = DistanceToEnd;
            }

        FirstUnsentOffset += Length;
        FirstUnsentFragment = 1 + FragNum;
        }

    if (BufferLength)
        {
// this is harmless and can sometimes be triggered on the first call of an activity
//        ASSERT(Length);
//        ASSERT(Offset < BufferLength);
        }
    else
        {
        ASSERT(!Length);
        ASSERT(!Offset);
        }

    //
    // Time to start assembling the buffer.
    //
    pHeader = (PNCA_PACKET_HEADER) (PCHAR(Buffer) - sizeof(NCA_PACKET_HEADER));

    *pHeader = pSavedPacket->Header;

    pHeader->PacketType      = PacketType;
    pHeader->PacketFlags     = BasePacketFlags;
    pHeader->PacketFlags2    = BasePacketFlags2;

    if (FinalSendFrag != 0 ||
        (BufferFlags & RPC_BUFFER_PARTIAL))
        {
        pHeader->PacketFlags |= DG_PF_FRAG;

        if (FragNum == FinalSendFrag &&
            0 == (BufferFlags & RPC_BUFFER_PARTIAL))
            {
            pHeader->PacketFlags |= DG_PF_LAST_FRAG;
            }
        }

    pHeader->SetPacketBodyLen (Length);
    pHeader->SetFragmentNumber((unsigned short) FragNum);

    if (FALSE == fFack)
        {
        pHeader->PacketFlags |= DG_PF_NO_FACK;
        }

    AddSerialNumber(pHeader);

    RPC_STATUS Status;

    //
    // Stub data is encrypted in-place; we need not to encrypt the original data
    // so we can retransmit it if necessary.
    //
    unsigned Frag = (pHeader->PacketType << 16) | pHeader->GetFragmentNumber();
    LogEvent(SU_ENGINE, EV_PKT_OUT, this, 0, Frag);

    if (BaseConnection->ActiveSecurityContext  &&
        BaseConnection->ActiveSecurityContext->AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
        {
        RpcpMemoryCopy(&pSavedPacket->Header,     pHeader,                sizeof(NCA_PACKET_HEADER));
        RpcpMemoryCopy(pSavedPacket->Header.Data, pHeader->Data + Offset, pHeader->GetPacketBodyLen());

        Status = BaseConnection->SealAndSendPacket(SourceEndpoint, RemoteAddress, &pSavedPacket->Header, 0);
        }
    else
        {
        Status = BaseConnection->SealAndSendPacket(SourceEndpoint, RemoteAddress, pHeader, Offset);
        }

    FragmentRingBuffer[Index].SerialNumber = SendSerialNumber;
    FragmentRingBuffer[Index].Length       = Length;
    FragmentRingBuffer[Index].Offset       = Offset;

    ++SendSerialNumber;

    if (Status)
        {
        LogError(SU_ENGINE, EV_STATUS, this, 0, Status);
        }

    return Status;
}


RPC_STATUS
DG_PACKET_ENGINE::UpdateSendWindow(
    PDG_PACKET pPacket,
    BOOL * pfUpdated
    )
/*++

Routine Description:

    Update the send window based upon a received FACK or NOCALL.
    The caller should filter out other packet types.

Arguments:

    pPacket - the packet received

Return Value:

    return code:

        TRUE if PDU size or window size changed
        FALSE if not
--*/
{
    RPC_STATUS Status = 0;

    FACK_BODY_VER_0 PAPI * pBody = (FACK_BODY_VER_0 PAPI *) pPacket->Header.Data;

    *pfUpdated = FALSE;

    unsigned short Diff;
    unsigned short RemoteBase = 1+pPacket->GetFragmentNumber();


    ASSERT(pPacket->TimeReceived == 0x31415926);

    //
    // Check that we can understand this packet.
    //
    if (0 != pPacket->GetPacketBodyLen())
        {
        //
        // Version 0 and version 1 are identical.
        //
        if (0 != pBody->Version &&
            1 != pBody->Version)
            {
#ifdef DEBUGRPC
            PrintToDebugger("RPC DG: warning - FACK body version %u\n", pBody->Version);
#endif
            pPacket->SetPacketBodyLen(0);
            }
        else if (pPacket->GetPacketBodyLen() < sizeof(FACK_BODY_VER_0))
            {
#ifdef DEBUGRPC
            PrintToDebugger("RPC DG: warning - FACK body truncated\n");
#endif
            pPacket->SetPacketBodyLen(0);
            }
        else if (pPacket->GetPacketBodyLen() < sizeof(FACK_BODY_VER_0) + pBody->AckWordCount * sizeof(unsigned long))
            {
#ifdef DEBUGRPC
            PrintToDebugger("RPC DG: warning - FACK body length inconsistent\n");
#endif
            pPacket->SetPacketBodyLen(0);
            }
        else
            {
            if (NeedsByteSwap(&pPacket->Header))
                {
                ByteSwapFackBody0(pBody);
                }

            //
            // NT 1057 used 0xffff to signal no packets have been received.
            // This doesn't match OSF.
            //
            if (0xffff == pBody->SerialNumber)
                {
                pBody->SerialNumber = 0;
                }

            //
            // If the other guy is resending the same FACK, we should resend.
            // If it's different, then we are likely OK.
            //
            if (pBody->SerialNumber == FackSerialNumber)
                {
                goto send;
                }

            if (pBody->SerialNumber < FackSerialNumber)
                {
                FackSerialNumber = pBody->SerialNumber;
                goto dont_send;
                }

            FackSerialNumber = pBody->SerialNumber;
            }
        }

    //
    // Update send window.
    //
    if (RemoteBase < SendWindowBase)
        {
        //
        // Fragments previously acknowledged are now missing.  Either this
        // packet was delivered out of order, or the server crashed and
        // restarted.  Ignore the packet.
        //
        goto dont_send;
        }

    if (RemoteBase > FirstUnsentFragment)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: bogus FACK packet received\n");
#endif
        goto dont_send;
        }

    //
    // We are moving the window base forward.  We need to advance the
    // ring buffer base by the same amount, and clear the entries
    // corresponding to unsent packets.
    //
    Diff = RemoteBase - SendWindowBase;

    ASSERT(Diff <= MAX_WINDOW_SIZE);

#ifdef DEBUGRPC
    while (Diff)
        {
        FragmentRingBuffer[RingBufferBase].SerialNumber |= 0xeeee0000;
        FragmentRingBuffer[RingBufferBase].Length       |= 0xdd000000;
        FragmentRingBuffer[RingBufferBase].Offset       |= 0xb0000000;

        ++RingBufferBase;
        RingBufferBase %= MAX_WINDOW_SIZE;
        --Diff;
        }
#else
    RingBufferBase += Diff;
    RingBufferBase %= MAX_WINDOW_SIZE;
#endif

    SendWindowBase = RemoteBase;
    SendWindowBits = 0;

    ASSERT( SendWindowBase <= FirstUnsentFragment );

    if (IsBufferAcknowledged())
        {
        PopBuffer(FALSE);
        }

    if (0 != pPacket->GetPacketBodyLen())
        {
        LogEvent(SU_ENGINE, EV_WINDOW, this, (void *) pBody->WindowSize, pBody->Acks[0]);

        if (pBody->AckWordCount)
            {
            //
            // Save missing-packet bitmask.
            //
            SendWindowBits = pBody->Acks[0];
            }

        //
        // Adjust window size.
        //
        if (pBody->WindowSize > MAX_WINDOW_SIZE)
            {
            pBody->WindowSize = MAX_WINDOW_SIZE;
            }

        SendWindowSize = pBody->WindowSize;

        if (SendBurstLength > SendWindowSize)
            {
            SendBurstLength = SendWindowSize;
            }

        //
        // Adjust maximum PDU length.
        //
        unsigned NewPduSize;
        NewPduSize = pBody->MaxDatagramSize;
        if (NewPduSize > SourceEndpoint->Stats.PreferredPduSize)
            {
            NewPduSize = SourceEndpoint->Stats.PreferredPduSize;
            }

        BaseConnection->CurrentPduSize    = (unsigned short) NewPduSize;
        BaseConnection->RemoteWindowSize  = pBody->WindowSize;

        //
        // If no packets are getting through, we probably are sending
        // packets that are too large.
        //
        if (0 == RemoteBase     &&
            0 == SendWindowBits &&
            NewPduSize < CurrentPduSize)
            {
            CurrentPduSize = (unsigned short) NewPduSize;
            SetFragmentLengths();

            FirstUnsentFragment = 0;
            FirstUnsentOffset   = 0;
            FinalSendFrag = SendWindowBase + (BufferLength-1) / MaxFragmentSize;
            }

        *pfUpdated = TRUE;
        }

send:

    Status = SendSomeFragments();

dont_send:

    return Status;
}


BOOL
DG_PACKET_ENGINE::UpdateReceiveWindow(
    PDG_PACKET pPacket
    )
/*++

Routine Description:

    Adds a fragment to the receive list, and sends a FACK.

Arguments:



Return Value:



--*/
{
    ASSERT(pPacket->TimeReceived == 0x31415926);

    //
    // Don't retain data from previous pipe buffers.
    //
    if (pPacket->GetFragmentNumber() < ReceiveFragmentBase)
        {
        if (0 == (pPacket->Header.PacketFlags & DG_PF_NO_FACK))
            {
            SendFackOrNocall(pPacket, DG_FACK);
            }

        return FALSE;
        }

    //
    // Attempt to guess the client's max PDU size.  Round down to a multiple
    // of eight, for NDR.
    //
    if (pPacket->DataLength + sizeof(NCA_PACKET_HEADER) > BaseConnection->CurrentPduSize)
        {
        unsigned RemoteTransportBuffer = BaseConnection->CurrentPduSize * BaseConnection->RemoteWindowSize;

        BaseConnection->CurrentPduSize   = ((pPacket->DataLength + sizeof(NCA_PACKET_HEADER)) & ~7);
        BaseConnection->RemoteWindowSize = RemoteTransportBuffer / BaseConnection->CurrentPduSize;
        if (0 == BaseConnection->RemoteWindowSize)
            {
            BaseConnection->RemoteWindowSize = 1;
            }
        }

    PNCA_PACKET_HEADER pHeader = &pPacket->Header;

    unsigned short Serial = ReadSerialNumber(pHeader);

    if (Serial > ReceiveSerialNumber)
        {
        ReceiveSerialNumber = Serial;
        }

    //
    // Authentication levels above AUTHN_LEVEL_PKT will checksum the packet,
    // so we must remove these bits from the header.
    //
    pPacket->Header.PacketFlags  &= ~(DG_PF_FORWARDED);
    pPacket->Header.PacketFlags2 &= ~(DG_PF2_FORWARDED_2);

    //
    // Check the easy case: is this a single packet call?
    //
    if ((pHeader->PacketFlags & DG_PF_FRAG) == 0  &&
        (pHeader->PacketFlags & DG_PF_LAST_FRAG) == 0)
        {
        if (pReceivedPackets)
            {
            CORRUPTION_ASSERT( pReceivedPackets->Header.SequenceNumber == pPacket->Header.SequenceNumber );
            return FALSE;
            }

        pReceivedPackets = pPacket;
        pLastConsecutivePacket = pPacket;

        pPacket->pNext = pPacket->pPrevious = 0;

        ConsecutiveDataBytes += pHeader->GetPacketBodyLen();

        fReceivedAllFragments = TRUE;

        return TRUE;
        }

    //
    // This is a multi-packet call.  Insert the packet in pReceivedPackets
    // and send a FACK.
    //
    PDG_PACKET      pScan;
    PDG_PACKET      pTrail;
    BOOL            PacketAddedToList = TRUE;

    if (pReceivedPackets == 0)
        {
        pReceivedPackets = pPacket;

        if (ReceiveFragmentBase == pHeader->GetFragmentNumber())
            {
            pLastConsecutivePacket = pPacket;
            ConsecutiveDataBytes += pHeader->GetPacketBodyLen();
            }

        pPacket->pNext = pPacket->pPrevious = 0;
        }
    else
        {
        //
        // Not the first packet to be received. So scan for its place in the
        // list.
        //
        unsigned short FragNum = pHeader->GetFragmentNumber();

        if (pLastConsecutivePacket)
            {
            pScan = pLastConsecutivePacket;
            }
        else
            {
            pScan = pReceivedPackets;
            }

        pTrail = 0;
        while (pScan && pScan->GetFragmentNumber() < FragNum)
            {
            ASSERT(pScan->TimeReceived == 0x31415926);
            ASSERT(pScan->Header.SequenceNumber == SequenceNumber);

            pTrail = pScan;
            pScan = pScan->pNext;
            }

        if (pScan != 0)
            {
            if (pScan->GetFragmentNumber() > FragNum)
                {
                if (pScan->pPrevious &&
                    pScan->pPrevious->GetFragmentNumber() >= FragNum)
                    {
                    //
                    // The new packet is a duplicate of a preexisting one
                    // upstream from pLastConsecutivePacket.
                    //
                    PacketAddedToList = FALSE;
                    }
                else
                    {
                    //
                    // Our fragment fills a gap in the series.
                    //
                    pPacket->pPrevious = pScan->pPrevious;
                    pPacket->pNext     = pScan;

                    if (pScan->pPrevious == 0)
                        {
                        pReceivedPackets = pPacket;
                        }
                    else
                        {
                        pScan->pPrevious->pNext = pPacket;
                        }
                    pScan->pPrevious = pPacket;
                    }
                }
            else
                {
                //
                // The new packet is a duplicate of a preexisting one
                // downstream from pLastConsecutivePacket.
                //
                PacketAddedToList = FALSE;
                }
            }
        else
            {
            //
            // The fragnum is larger than everything seen so far.
            //
            pTrail->pNext = pPacket;
            pPacket->pPrevious = pTrail;
            pPacket->pNext = 0;
            }
        }

    if (TRUE == PacketAddedToList)
        {
        //
        // Scan the list for the first missing fragment.
        //
        unsigned short ScanNum;
        if (pLastConsecutivePacket)
            {
            pScan = pLastConsecutivePacket->pNext;
            ScanNum = pLastConsecutivePacket->GetFragmentNumber() + 1;
            }
        else
            {
            pScan = pReceivedPackets;
            ScanNum = ReceiveFragmentBase;
            }

        while (pScan)
            {
            if (ScanNum == pScan->GetFragmentNumber())
                {
                ConsecutiveDataBytes += pScan->GetPacketBodyLen();
                pLastConsecutivePacket = pScan;
                }

            pScan = pScan->pNext;
            ++ScanNum;
            }

        //
        // We have updated pLastConsecutivePacket; is the whole buffer here?
        //
        if (pLastConsecutivePacket &&
            pLastConsecutivePacket->Header.PacketFlags & DG_PF_LAST_FRAG)
            {
            fReceivedAllFragments = TRUE;
            }
        }

    ASSERT(pReceivedPackets);

    //
    // Fack the fragment if necessary.
    //
    if (0 == (pHeader->PacketFlags & DG_PF_NO_FACK))
        {
        SendFackOrNocall(pPacket, DG_FACK);
        }

    return PacketAddedToList;
}


RPC_STATUS
DG_PACKET_ENGINE::SendFackOrNocall(
    PDG_PACKET pPacket,
    unsigned char PacketType
    )
{
    unsigned ReceiveWindowSize;

    ReceiveWindowSize = SourceEndpoint->Stats.ReceiveBufferSize
                      / ((1+SourceEndpoint->NumberOfCalls) * CurrentPduSize);

    if (0 == ReceiveWindowSize)
        {
        ReceiveWindowSize = 1;
        }
    else if (ReceiveWindowSize > MAX_WINDOW_SIZE)
        {
        ReceiveWindowSize = MAX_WINDOW_SIZE;
        }

    pSavedPacket->Header.PacketType     = PacketType;
    pSavedPacket->Header.SequenceNumber = SequenceNumber;
    pSavedPacket->Header.PacketFlags2   = 0;

    FACK_BODY_VER_0 PAPI * pBody = (FACK_BODY_VER_0 PAPI *) pSavedPacket->Header.Data;

    pBody->Version         = 1;
    pBody->Pad1            = 0;
    pBody->MaxDatagramSize = SourceEndpoint->Stats.PreferredPduSize;
    pBody->MaxPacketSize   = SourceEndpoint->Stats.MaxPacketSize;
    pBody->AckWordCount    = 1;
    pBody->WindowSize      = (unsigned short) ReceiveWindowSize;

    if (pPacket)
        {
        pBody->SerialNumber = ReadSerialNumber(&pPacket->Header);
        }
    else
        {
        pBody->SerialNumber = ReceiveSerialNumber;
        }

    unsigned short FragNum = ReceiveFragmentBase-1;
    PDG_PACKET     pScan   = 0;

    if (pLastConsecutivePacket)
        {
        FragNum = pLastConsecutivePacket->GetFragmentNumber();
        pScan   = pLastConsecutivePacket->pNext;
        }
    else if (pReceivedPackets)
        {
        pScan   = pReceivedPackets->pNext;
        }

    unsigned Bit;
    pBody->Acks[0] = 0;

    while ( pScan )
        {
        Bit = pScan->GetFragmentNumber() - FragNum - 1;

        pBody->Acks[0] |= (1 << Bit);

        pScan = pScan->pNext;
        }

    if (pBody->Acks[0] == 0)
        {
        pBody->AckWordCount = 0;
        }

    pSavedPacket->SetPacketBodyLen( sizeof(FACK_BODY_VER_0) + sizeof(unsigned long) );
    pSavedPacket->SetFragmentNumber(FragNum);

    AddSerialNumber(&pSavedPacket->Header);

    unsigned Frag = (pSavedPacket->Header.PacketType << 16) | pSavedPacket->GetFragmentNumber();
    LogEvent(SU_ENGINE, EV_PKT_OUT, this, 0, Frag);

    RPC_STATUS Status;

    Status = BaseConnection->SealAndSendPacket(SourceEndpoint, RemoteAddress, &pSavedPacket->Header, 0);

    if (Status)
        {
        LogError(SU_ENGINE, EV_STATUS, this, 0, Status);
        }

    return Status;
}


RPC_STATUS
DG_PACKET_ENGINE::AssembleBufferFromPackets(
    RPC_MESSAGE *   Message,
    CALL *          Call
    )
/*++

Routine Description:

    This function coalesces the list of consecutive packets into a monolithic
    buffer.

Arguments:

    Message - if .Buffer != 0 , use it.  Otherwise allocate one.

    Call    - in case we need to call GetBuffer

Return Value:

    RPC_S_OK - success

    RPC_S_OUT_OF_MEMORY - we couldn't allocate or reallocate Message.Buffer

--*/

{
    ASSERT( pLastConsecutivePacket );
    //
    // If only one packet is available, use the packet buffer itself.
    //
    if (0 == Message->Buffer && 0 == pReceivedPackets->pNext)
        {
        ASSERT(ConsecutiveDataBytes == pReceivedPackets->GetPacketBodyLen());

        Message->Buffer = pReceivedPackets->Header.Data;
        Message->BufferLength = ConsecutiveDataBytes;
        Message->DataRepresentation = 0x00ffffff & (*(unsigned long PAPI *) &pReceivedPackets->Header.DataRep);

        if (0 == (pReceivedPackets->Header.PacketFlags & DG_PF_FRAG))
            {
            Message->RpcFlags |= RPC_BUFFER_COMPLETE;
            }

        if (pReceivedPackets->Header.PacketFlags & DG_PF_LAST_FRAG)
            {
            Message->RpcFlags |= RPC_BUFFER_COMPLETE;
            }

        pReceivedPackets = 0;
        pLastConsecutivePacket = 0;

        ConsecutiveDataBytes = 0;

        ++ReceiveFragmentBase;

        LastReceiveBuffer       = Message->Buffer;
        LastReceiveBufferLength = Message->BufferLength;

        return RPC_S_OK;
        }

    //
    // Get a buffer if we need it.
    //
    RPC_STATUS Status;

    if (0 == Message->Buffer)
        {
        ASSERT(0 == (Message->RpcFlags & RPC_BUFFER_EXTRA));

        Message->BufferLength = ConsecutiveDataBytes;

        Status = Call->GetBuffer(Message, 0);
        if (RPC_S_OK != Status)
            {
            return Status;
            }

        LastReceiveBuffer       = Message->Buffer;
        LastReceiveBufferLength = Message->BufferLength;
        }

    //
    // Reallocate the buffer if it is too small.
    //
    char __RPC_FAR * CopyBuffer = (char __RPC_FAR *) Message->Buffer;

    if (Message->RpcFlags & (RPC_BUFFER_EXTRA | RPC_BUFFER_PARTIAL))
        {
        ASSERT( !LastReceiveBufferLength         ||
                (CopyBuffer >= LastReceiveBuffer &&
                 CopyBuffer <= ((char __RPC_FAR *) LastReceiveBuffer) + LastReceiveBufferLength) );

        if (0 == (Message->RpcFlags & RPC_BUFFER_EXTRA))
            {
            Message->BufferLength = 0;
            }

        unsigned Offset = Message->BufferLength;
        CopyBuffer += Offset;
        if (CopyBuffer + ConsecutiveDataBytes > ((char __RPC_FAR *) LastReceiveBuffer) + LastReceiveBufferLength)
            {
            Status = I_RpcReallocPipeBuffer(Message, Offset + ConsecutiveDataBytes);
            if (RPC_S_OK != Status)
                {
                return Status;
                }

            CopyBuffer = (char __RPC_FAR *) Message->Buffer + Offset;
            }
        else
            {
            Message->BufferLength += ConsecutiveDataBytes;
            }
        }
    else
        {
        Message->BufferLength = ConsecutiveDataBytes;
        }

    Message->DataRepresentation = 0x00ffffff & (*(unsigned long PAPI *) &pReceivedPackets->Header.DataRep);

    {
    PDG_PACKET pkt = DG_PACKET::FromStubData(Message->Buffer);

    ASSERT( pkt->MaxDataLength >= Message->BufferLength );
    }

    //
    // Copy the stub data into the buffer.
    //
#ifdef DEBUGRPC
    unsigned long Count = 0;
#endif

    PDG_PACKET Packet;
    BOOL fLastPacket = FALSE;
    do
        {
        ASSERT(pReceivedPackets->TimeReceived == 0x31415926);
        if (ReceiveFragmentBase != pReceivedPackets->GetFragmentNumber())
            {
            CORRUPTION_ASSERT(ReceiveFragmentBase == pReceivedPackets->GetFragmentNumber());
            return RPC_S_PROTOCOL_ERROR;
            }

        if (pReceivedPackets == pLastConsecutivePacket)
            {
            fLastPacket = TRUE;

            if (0 == (pReceivedPackets->Header.PacketFlags & DG_PF_FRAG))
                {
                Message->RpcFlags |= RPC_BUFFER_COMPLETE;
                }

            if (pReceivedPackets->Header.PacketFlags & DG_PF_LAST_FRAG)
                {
                Message->RpcFlags |= RPC_BUFFER_COMPLETE;
                }
            }

        unsigned Length = pReceivedPackets->GetPacketBodyLen();
        RpcpMemoryCopy(CopyBuffer, pReceivedPackets->Header.Data, Length);

#ifdef DEBUGRPC
        Count += Length;
#endif

        CopyBuffer += Length;
        Packet = pReceivedPackets;

        pReceivedPackets = pReceivedPackets->pNext;
        ASSERT(!pReceivedPackets || pReceivedPackets->pPrevious == Packet);
        FreePacket(Packet);

        ++ReceiveFragmentBase;
        }
    while (!fLastPacket);

    ASSERT(Count == ConsecutiveDataBytes);

    ASSERT(fLastPacket || 0 == Count % 8);

    pLastConsecutivePacket = 0;
    ConsecutiveDataBytes = 0;

    if (pReceivedPackets)
        {
        pReceivedPackets->pPrevious = 0;
        }

    return RPC_S_OK;
}


void
DG_PACKET_ENGINE::SetFragmentLengths()
{
    PSECURITY_CONTEXT pSecurityContext = BaseConnection->ActiveSecurityContext;

    if (0 == pSecurityContext)
        {
        SecurityTrailerSize = 0;
        }
    else switch (pSecurityContext->AuthenticationLevel)
        {
        case RPC_C_AUTHN_LEVEL_NONE:
            {
            SecurityTrailerSize = 0;
            break;
            }

        case RPC_C_AUTHN_LEVEL_PKT:
        case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:
            {
            SecurityTrailerSize  = (unsigned short) pSecurityContext->MaximumSignatureLength();
            SecurityTrailerSize += (unsigned short) Align4(sizeof(DG_SECURITY_TRAILER));
            break;
            }

        case RPC_C_AUTHN_LEVEL_PKT_PRIVACY:
            {
            SecurityTrailerSize  = (unsigned short) pSecurityContext->MaximumHeaderLength();
            SecurityTrailerSize += (unsigned short) Align(sizeof(DG_SECURITY_TRAILER), Align4(pSecurityContext->BlockSize()));
            break;
            }

        default:
            {
            ASSERT(0 && "RPC: unknown protect level");
            break;
            }
        }

    if (CurrentPduSize != BaseConnection->CurrentPduSize)
        {
        CurrentPduSize = (unsigned short) BaseConnection->CurrentPduSize;
        SendWindowSize = (unsigned short) BaseConnection->RemoteWindowSize;
        }

    MaxFragmentSize = CurrentPduSize - sizeof(NCA_PACKET_HEADER);

    if (SecurityTrailerSize)
        {
        MaxFragmentSize -= SecurityTrailerSize;
        MaxFragmentSize -= MaxFragmentSize % SECURITY_HEADER_ALIGNMENT;
        }
}


void
ByteSwapPacketHeader(
    PDG_PACKET  pPacket
    )
/*++

Routine Description:

    Byte swaps the packet header of the specified packet.

Arguments:

    pPacket - Pointer to the packet whose header needs byte swapping.

Return Value:

    <none>

--*/
{
    unsigned long __RPC_FAR * VerNum = (unsigned long __RPC_FAR *) &(pPacket->Header.InterfaceVersion);

    ByteSwapUuid(&(pPacket->Header.ObjectId));
    ByteSwapUuid(&(pPacket->Header.InterfaceId));
    ByteSwapUuid(&(pPacket->Header.ActivityId));
    pPacket->Header.ServerBootTime = RpcpByteSwapLong(pPacket->Header.ServerBootTime);
    *VerNum = RpcpByteSwapLong(*VerNum);
    pPacket->Header.SequenceNumber = RpcpByteSwapLong(pPacket->Header.SequenceNumber);
    pPacket->Header.OperationNumber = RpcpByteSwapShort(pPacket->Header.OperationNumber);
    pPacket->Header.InterfaceHint = RpcpByteSwapShort(pPacket->Header.InterfaceHint);
    pPacket->Header.ActivityHint = RpcpByteSwapShort(pPacket->Header.ActivityHint);
    pPacket->Header.PacketBodyLen = RpcpByteSwapShort(pPacket->Header.PacketBodyLen);
    pPacket->Header.FragmentNumber = RpcpByteSwapShort(pPacket->Header.FragmentNumber);
}


void
ByteSwapFackBody0(
    FACK_BODY_VER_0 __RPC_FAR * pBody
    )
{
    pBody->WindowSize = RpcpByteSwapShort(pBody->WindowSize);
    pBody->MaxDatagramSize = RpcpByteSwapLong (pBody->MaxDatagramSize);
    pBody->MaxPacketSize = RpcpByteSwapLong (pBody->MaxPacketSize);
    pBody->SerialNumber = RpcpByteSwapShort(pBody->SerialNumber);
    pBody->AckWordCount = RpcpByteSwapShort(pBody->AckWordCount);

    unsigned u;
    for (u=0; u < pBody->AckWordCount; ++u)
        {
        pBody->Acks[u] = RpcpByteSwapLong (pBody->Acks[u]);
        }
}



RPCRTAPI RPC_STATUS RPC_ENTRY
I_RpcTransDatagramAllocate(
    IN  DG_TRANSPORT_ENDPOINT TransportEndpoint,
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength,
    OUT DatagramTransportPair **pAddressPair
    )
{
    DG_ENDPOINT * Endpoint = DG_ENDPOINT::FromEndpoint(TransportEndpoint);
    RPC_DATAGRAM_TRANSPORT * Transport = Endpoint->TransportInterface;

    if ( !Endpoint->Stats.PreferredPduSize )
        {
        RpcpBreakPoint();
        }

    DG_PACKET * Packet = DG_PACKET::AllocatePacket(Endpoint->Stats.PreferredPduSize 
        + Transport->AddressSize 
        + sizeof(DatagramTransportPair));
    if (!Packet)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DG_TRANSPORT_ADDRESS Address = DG_TRANSPORT_ADDRESS(Packet->Header.Data - sizeof(NCA_PACKET_HEADER) + Endpoint->Stats.PreferredPduSize);

    *pBuffer        = &Packet->Header;
    *pBufferLength  = Endpoint->Stats.PreferredPduSize;
    *pAddressPair = (DatagramTransportPair *)((char *)Address + Transport->AddressSize);
    (*pAddressPair)->RemoteAddress = Address;

    return RPC_S_OK;
}

RPCRTAPI RPC_STATUS RPC_ENTRY
I_RpcTransDatagramAllocate2(
    IN     DG_TRANSPORT_ENDPOINT TransportEndpoint,
    OUT    BUFFER               *pBuffer,
    IN OUT PUINT                 pBufferLength,
    OUT    DG_TRANSPORT_ADDRESS *pAddress
    )
{
    DG_ENDPOINT             *pEndpoint = DG_ENDPOINT::FromEndpoint(TransportEndpoint);
    RPC_DATAGRAM_TRANSPORT *pTransport = pEndpoint->TransportInterface;
    DWORD        dwSize = *pBufferLength;

    if (dwSize < pEndpoint->Stats.PreferredPduSize)
        {
        dwSize = pEndpoint->Stats.PreferredPduSize;
        }

    DG_PACKET * Packet = DG_PACKET::AllocatePacket( dwSize + pTransport->AddressSize);

    if (!Packet)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DG_TRANSPORT_ADDRESS Address = DG_TRANSPORT_ADDRESS(Packet->Header.Data - sizeof(NCA_PACKET_HEADER) + dwSize);

    *pBuffer        = &Packet->Header;
    *pBufferLength  = dwSize;
    *pAddress       = Address;

    return RPC_S_OK;
}


RPCRTAPI RPC_STATUS RPC_ENTRY
I_RpcTransDatagramFree(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN BUFFER Buffer
    )
{
    DG_PACKET * Packet = DG_PACKET::FromPacketHeader( Buffer );

    Packet->Free();

    return RPC_S_OK;
}

RPC_STATUS
DG_PACKET::Initialize(
    )
{
    return RPC_S_OK;
}


BOOL
DG_PACKET::DeleteIdlePackets(
    long CurrentTime
    )
/*++

Routine Description:

    This fn scans the free packet list for very old packets and deletes them.

Arguments:

    none

Return Value:

    none

--*/
{
    return FALSE;
}


DG_COMMON_CONNECTION::DG_COMMON_CONNECTION(
    RPC_DATAGRAM_TRANSPORT *a_TransportInterface,
    RPC_STATUS *            pStatus
    ) :
    Mutex               (pStatus),
    TimeStamp           (0),
    TransportInterface  (a_TransportInterface),
    ReferenceCount      (0),
    CurrentPduSize      (a_TransportInterface->BasePduSize),
    RemoteWindowSize    (1),
    RemoteDataUpdated   (FALSE),
    LowestActiveSequence(0),
    LowestUnusedSequence(0),
    ActiveSecurityContext(0)
{
}

DG_COMMON_CONNECTION::~DG_COMMON_CONNECTION()
{
    delete ActiveSecurityContext;
}


RPC_STATUS
SendSecurePacket(
    IN DG_ENDPOINT *                SourceEndpoint,
    IN DG_TRANSPORT_ADDRESS         RemoteAddress,
    IN UNALIGNED NCA_PACKET_HEADER *pHeader,
    IN unsigned long                DataOffset,
    IN SECURITY_CONTEXT *           SecurityContext
    )
{
    RPC_STATUS Status = RPC_S_OK;
    unsigned TrailerLength   = 0;
    unsigned MaxTrailerSize  = 0;

    PDG_SECURITY_TRAILER pTrailer = 0;

    if (SecurityContext && SecurityContext->AuthenticationLevel > RPC_C_AUTHN_LEVEL_NONE)
        {
        // Pad the stub data length to a multiple of 8, so the security
        // trailer is properly aligned.  OSF requires that the pad bytes
        // be included in PacketBodyLen.
        //
        pHeader->SetPacketBodyLen(Align8(pHeader->GetPacketBodyLen()));

        pHeader->AuthProto = (unsigned char) SecurityContext->AuthenticationService;

        SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;
        SECURITY_BUFFER SecurityBuffers[5];
        DCE_MSG_SECURITY_INFO MsgSecurityInfo;

        BufferDescriptor.ulVersion = 0;
        BufferDescriptor.cBuffers = 5;
        BufferDescriptor.pBuffers = SecurityBuffers;

        SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        SecurityBuffers[0].pvBuffer   = pHeader;
        SecurityBuffers[0].cbBuffer   = sizeof(NCA_PACKET_HEADER);

        SecurityBuffers[1].BufferType = SECBUFFER_DATA;
        SecurityBuffers[1].pvBuffer   = pHeader->Data + DataOffset;
        SecurityBuffers[1].cbBuffer   = pHeader->GetPacketBodyLen();

        if (SecurityContext->AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
            {
            SecurityBuffers[2].cbBuffer = (ULONG) Align(sizeof(DG_SECURITY_TRAILER), Align4(SecurityContext->BlockSize()));
            SecurityBuffers[3].cbBuffer = SecurityContext->MaximumHeaderLength();
            }
        else
            {
            SecurityBuffers[2].cbBuffer = (ULONG) Align4(sizeof(DG_SECURITY_TRAILER));
            SecurityBuffers[3].cbBuffer = SecurityContext->MaximumSignatureLength();
            }

        pTrailer = (PDG_SECURITY_TRAILER) _alloca(SecurityBuffers[2].cbBuffer + SecurityBuffers[3].cbBuffer);

        SecurityBuffers[2].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        SecurityBuffers[2].pvBuffer   = pTrailer;

        SecurityBuffers[3].BufferType = SECBUFFER_TOKEN;
        SecurityBuffers[3].pvBuffer   = (unsigned char *) pTrailer
                                      + SecurityBuffers[2].cbBuffer;

        SecurityBuffers[4].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        SecurityBuffers[4].pvBuffer   = &MsgSecurityInfo;
        SecurityBuffers[4].cbBuffer   = sizeof(DCE_MSG_SECURITY_INFO);

        MsgSecurityInfo.SendSequenceNumber    = pHeader->GetFragmentNumber();
        MsgSecurityInfo.ReceiveSequenceNumber = SecurityContext->AuthContextId;
        MsgSecurityInfo.PacketType            = ~0;

        TrailerLength = SecurityBuffers[2].cbBuffer;

        pTrailer->protection_level = (unsigned char) SecurityContext->AuthenticationLevel;
        pTrailer->key_vers_num     = (unsigned char) SecurityContext->AuthContextId;

        Status = SecurityContext->SignOrSeal (
                pHeader->SequenceNumber,
                SecurityContext->AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                &BufferDescriptor );

        ASSERT( SecurityBuffers[3].cbBuffer > 0 );

        TrailerLength += SecurityBuffers[3].cbBuffer;
        }
    else
        {
        //
        // Unsecure packet.
        //
        pHeader->AuthProto = 0;
        }

    if (RPC_S_OK == Status)
        {
        Status = SourceEndpoint->TransportInterface->Send(
                                          &SourceEndpoint->TransportEndpoint,
                                          RemoteAddress,
                                          pHeader,
                                          sizeof(NCA_PACKET_HEADER),
                                          pHeader->Data + DataOffset,
                                          pHeader->GetPacketBodyLen(),
                                          pTrailer,
                                          TrailerLength
                                          );
        }

    return Status;
}


RPC_STATUS
VerifySecurePacket(
    PDG_PACKET pPacket,
    SECURITY_CONTEXT * pSecurityContext
    )
{
    RPC_STATUS Status = RPC_S_OK;
    PDG_SECURITY_TRAILER pVerifier = (PDG_SECURITY_TRAILER)
                      (pPacket->Header.Data + pPacket->GetPacketBodyLen());

    if (pSecurityContext->AuthenticationLevel < RPC_C_AUTHN_LEVEL_PKT)
        {
        return RPC_S_OK;
        }

    ASSERT(pVerifier->protection_level >= RPC_C_AUTHN_LEVEL_PKT);
    ASSERT(pVerifier->protection_level <= RPC_C_AUTHN_LEVEL_PKT_PRIVACY);

    SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;
    SECURITY_BUFFER            SecurityBuffers[5];
    DCE_MSG_SECURITY_INFO      MsgSecurityInfo;

    BufferDescriptor.ulVersion = 0;
    BufferDescriptor.cBuffers = 5;
    BufferDescriptor.pBuffers = SecurityBuffers;

    SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
    SecurityBuffers[0].pvBuffer   = &pPacket->Header;
    SecurityBuffers[0].cbBuffer   = sizeof(NCA_PACKET_HEADER);

    SecurityBuffers[1].BufferType = SECBUFFER_DATA;
    SecurityBuffers[1].pvBuffer   = pPacket->Header.Data;
    SecurityBuffers[1].cbBuffer   = pPacket->GetPacketBodyLen();

    SecurityBuffers[2].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
    SecurityBuffers[2].pvBuffer   = pVerifier;

    if (pVerifier->protection_level == RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
        {
        unsigned Alignment = Align4(pSecurityContext->BlockSize());

        SecurityBuffers[2].cbBuffer = (ULONG) Align(sizeof(DG_SECURITY_TRAILER), Alignment);
        SecurityBuffers[3].pvBuffer = AlignPtr(pVerifier + 1,               Alignment);
        }
    else
        {
        SecurityBuffers[2].cbBuffer = (ULONG) Align4(sizeof(DG_SECURITY_TRAILER));
        SecurityBuffers[3].pvBuffer = AlignPtr4(pVerifier + 1);
        }

    SecurityBuffers[3].BufferType = SECBUFFER_TOKEN;
    SecurityBuffers[3].cbBuffer   = pPacket->DataLength
                                  - SecurityBuffers[1].cbBuffer
                                  - SecurityBuffers[2].cbBuffer;

    SecurityBuffers[4].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
    SecurityBuffers[4].pvBuffer   = &MsgSecurityInfo;
    SecurityBuffers[4].cbBuffer   = sizeof(DCE_MSG_SECURITY_INFO);

    MsgSecurityInfo.SendSequenceNumber    = pPacket->GetFragmentNumber();
    MsgSecurityInfo.ReceiveSequenceNumber = pSecurityContext->AuthContextId;
    MsgSecurityInfo.PacketType            = ~0;

    //
    // If the packet came from a big-endian machine, we must restore
    // the header to its original condition or the checksum will fail.
    //
    ByteSwapPacketHeaderIfNecessary(pPacket);

    Status = pSecurityContext->VerifyOrUnseal(
                pPacket->Header.SequenceNumber,
                pVerifier->protection_level != RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                &BufferDescriptor
                );

    //
    // Gotta re-swap the header so we can still look at its fields.
    //
    ByteSwapPacketHeaderIfNecessary(pPacket);

    if (RPC_S_OK != Status)
        {
#ifdef DEBUGRPC
            DbgPrint("dg rpc: %lx: pkt %lx type %lx has bad security info (error 0x%lx)\n",
                     GetCurrentProcessId(), pPacket, pPacket->Header.PacketType, Status);
#endif

        ASSERT(Status == RPC_S_ACCESS_DENIED ||
               Status == ERROR_PASSWORD_MUST_CHANGE ||
               Status == ERROR_PASSWORD_EXPIRED ||
               Status == ERROR_ACCOUNT_DISABLED ||
               Status == ERROR_INVALID_LOGON_HOURS ||
               Status == RPC_S_OUT_OF_MEMORY);
        }

    return(Status);
}

BOOL
DG_PickleEEInfoIntoPacket (
    IN DG_PACKET * Packet,
    IN size_t PickleStartOffset
    )
/*++
Function Name: PickeEEInfoIntoPacket

Parameters:
    PickleStartOffset - the offset in bytes where the pickling starts
    pHeader - pointer to the packet to fill

Description:
    Checks for EEInfo on the thread, trims the EEInfo to Packet->MaxDataLength,
        and pickles the EEInfo starting from PickleStartOffset.

Returns:
    TRUE if EEInfo was pickled. FALSE if not.

--*/
{
    BOOL fEEInfoPresent = FALSE;
    ExtendedErrorInfo *EEInfo;
    RPC_STATUS RpcStatus;
    size_t CurrentPacketSize;

    EEInfo = RpcpGetEEInfo();
    if (EEInfo)
        {
        AddComputerNameToChain(EEInfo);
        TrimEEInfoToLength (Packet->MaxDataLength-PickleStartOffset, &CurrentPacketSize);
        if (CurrentPacketSize != 0)
            {
            CurrentPacketSize += PickleStartOffset;

            ASSERT(IsBufferAligned(Packet->Header.Data + PickleStartOffset));

            RpcpMemorySet(Packet->Header.Data, 0, CurrentPacketSize);

            RpcStatus = PickleEEInfo( EEInfo,
                                      Packet->Header.Data + PickleStartOffset,
                                      CurrentPacketSize   - PickleStartOffset
                                      );

            if (RpcStatus == RPC_S_OK)
                {
                fEEInfoPresent = TRUE;
                Packet->SetPacketBodyLen( CurrentPacketSize );
                }
            }
        }

    return fEEInfoPresent;
}


void
InitErrorPacket(
    DG_PACKET *     pPacket,
    unsigned char   PacketType,
    RPC_STATUS      RpcStatus
    )
/*++

Routine Description:

    Maps <ProcessStatus> to an NCA error code and sends
    a FAULT or REJECT packet to the client, as appropriate.

Arguments:

    pSendPacket - a packet to use, or zero if this fn should allocate one

    ProcessStatus - NT RPC error code

Return Value:

    none

--*/
{
    NCA_PACKET_HEADER * pHeader = &pPacket->Header;

    CleanupPacket(pHeader);

    pHeader->PacketType = PacketType;

    size_t FaultSize;
    BOOL fEEInfoPresent = FALSE;

    //
    // This mapping distinguishes client-side shutdown from server-side shutdown.
    //
    if (RpcStatus == ERROR_SHUTDOWN_IN_PROGRESS)
        {
        if (PacketType == DG_REJECT)
            {
            RpcStatus = RPC_S_SERVER_UNAVAILABLE;
            }
        else
            {
            RpcStatus = ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
            }
        }
    else if (RpcStatus == RPC_P_CLIENT_SHUTDOWN_IN_PROGRESS)
        {
        RpcStatus = ERROR_SHUTDOWN_IN_PROGRESS;
        }

    if (g_fSendEEInfo)
        {
        fEEInfoPresent = DG_PickleEEInfoIntoPacket( pPacket, FIELD_OFFSET( EXTENDED_FAULT_BODY, EeInfo) );
        }

    if (fEEInfoPresent)
        {
        //
        // Packet body length already set.
        //
        EXTENDED_FAULT_BODY * body = (EXTENDED_FAULT_BODY *) pHeader->Data;

        body->NcaStatus = MapToNcaStatusCode(RpcStatus);
        body->Magic     = DG_EE_MAGIC_VALUE;
        body->reserved1 = 0;
        body->reserved2 = 0;
        }
    else
        {
        size_t XopenFaultSize = sizeof(unsigned long);

        *(unsigned long *)(pHeader->Data) = MapToNcaStatusCode(RpcStatus);

        pHeader->SetPacketBodyLen(XopenFaultSize);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dcesvr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    dcesvr.cxx

Abstract:

    This routine implements the server side DCE runtime APIs.  The
    routines in this file are used by server applications only.

Author:

    Michael Montague (mikemon) 13-Nov-1991

Revision History:

--*/

#include <precomp.hxx>
#include <wincrypt.h>
#include <rpcssl.h>
#include <rpcobj.hxx>
#include <rpcasync.h>
#include <hndlsvr.hxx>
#include <mgmt.h>
#include <rpccfg.h>
#include <sidcache.hxx>
#include <CharConv.hxx>

long GroupIdCounter;

RPC_INTERFACE * GlobalManagementInterface = NULL;


RPC_STATUS RPC_ENTRY
RpcNetworkInqProtseqs (
    OUT RPC_PROTSEQ_VECTOR PAPI * PAPI * ProtseqVector
    )
/*++

Routine Description:

    A server application will call this routine to obtain a list of the
    rpc protocol sequences supported by this system configuration.

Arguments:

    ProtseqVector - Returns a vector of the rpc protocol sequences
        supported by this system configuration.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_NO_PROTSEQS - The current system configuration does not
        support any rpc protocol sequences.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to inquire
        the rpc protocol sequences supported by this system configuration.

--*/
{
    InitializeIfNecessary();

    return(RpcConfigInquireProtocolSequences(FALSE, ProtseqVector));
}


RPC_STATUS RPC_ENTRY
RpcObjectInqType (
    IN UUID PAPI * ObjUuid,
    OUT UUID PAPI * TypeUuid OPTIONAL
    )
/*++

Routine Description:

    A server application will use this routine to obtain the type uuid
    for an object.  This routine can also be used to determine whether
    a given object is register with the runtime or not.  This is done
    by not specifying the optional type uuid argument.

Arguments:

    ObjUuid - Supplies the object uuid for which we want look up the
        type uuid.

    TypeUuid - Optionally returns the type uuid of the specified object
        uuid.

Return Value:

    RPC_S_OK - The operation completed successfully; the object uuid
        is registered with the runtime or the object inquiry function
        knows the object uuid.

    RPC_S_OBJECT_NOT_FOUND - The specified object uuid has not been
        registered with the runtime and the object inquiry function
        does not know about the object uuid.

--*/
{
    RPC_UUID OptionalTypeUuid;

    InitializeIfNecessary();

    if (ARGUMENT_PRESENT(TypeUuid))
        {
        return(ObjectInqType(
                (RPC_UUID PAPI *) ObjUuid, (RPC_UUID PAPI *) TypeUuid));
        }

    return(ObjectInqType(
            (RPC_UUID PAPI *) ObjUuid, &OptionalTypeUuid));
}


RPC_STATUS RPC_ENTRY
RpcObjectSetInqFn (
    IN RPC_OBJECT_INQ_FN PAPI * InquiryFn
    )
/*++

Routine Description:

    A function to be used to determine an object's type is specified
    using this routine.

Arguments:

    InquiryFn - Supplies a pointer to a function which will automatically
        be called when an inquiry is made for the type of object which
        has not yet been registered with the runtime.

Return Value:

    RPC_S_OK - This value will always be returned.

--*/
{
    InitializeIfNecessary();

    return(ObjectSetInqFn(InquiryFn));
}


RPC_STATUS RPC_ENTRY
RpcObjectSetType (
    IN UUID PAPI * ObjUuid,
    IN UUID PAPI * TypeUuid OPTIONAL
    )
/*++

Routine Description:

    An application will call this routine to register an object and its
    type with the runtime.

Arguments:

    ObjUuid - Supplies the object uuid to be registered with the runtime.

    TypeUuid - Supplies the type of the object being registered.  The type
        is registered with the object.

Return Value:

    RPC_S_OK - The object uuid (and type uuid with it) were successfully
        registered with the runtime.

    RPC_S_ALREADY_REGISTERED - The object uuid specified has already
        been registered with the runtime.

    RPC_S_OUT_OF_MEMORY - There is insufficient memory available to
        register the object with the runtime.

    RPC_S_INVALID_OBJECT - The object uuid specified is the nil uuid.

--*/
{
    InitializeIfNecessary();

    return(ObjectSetType(
            (RPC_UUID PAPI *) ObjUuid, (RPC_UUID PAPI *) TypeUuid));
}


RPC_STATUS RPC_ENTRY
RpcProtseqVectorFree (
    IN OUT RPC_PROTSEQ_VECTOR PAPI * PAPI * ProtseqVector
    )
/*++

Routine Description:

    The protocol sequence vector obtained by calling RpcNetworkInqProtseqs
    is freed using this routine.  Each of the protocol sequences (they
    are represented as strings) and the vector itself are all freed.

Arguments:

    ProtseqVector - Supplies the rpc protocol sequence vector to be freed,
        and returns zero in place of the pointer to the vector.

Return Value:

    RPC_S_OK - This routine always completes successfully.

--*/
{
    unsigned int Index, Count;

    InitializeIfNecessary();

    if ( *ProtseqVector == 0 )
        {
        return(RPC_S_OK);
        }

    for (Index = 0, Count = (*ProtseqVector)->Count; Index < Count; Index++)
        {
        delete((*ProtseqVector)->Protseq[Index]);
        }

    delete(*ProtseqVector);
    *ProtseqVector = 0;

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcServerInqBindings (
    OUT RPC_BINDING_VECTOR PAPI * PAPI * BindingVector
    )
/*++

Routine Description:

    A server application will call this routine to obtain a vector of
    binding handles.  Each protocol sequence registered with the rpc
    server will be used to create one binding handle.

Arguments:

    BindingVector - Returns the vector of binding handles.

Return Value:

    RPC_S_OK - At least one rpc protocol sequence has been registered
        with the rpc server, and the operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_NO_BINDINGS - No rpc protocol sequences have been successfully
        registered with the rpc server.

--*/
{
    InitializeIfNecessary();
    *BindingVector = 0L;

    return(GlobalRpcServer->InquireBindings(BindingVector));
}


RPC_STATUS RPC_ENTRY
RpcServerInqIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid, OPTIONAL
    OUT RPC_MGR_EPV PAPI * PAPI * MgrEpv
    )
/*++

Routine Description:

    A server application will call this routine to obtain the manager
    entry point vector for a given interface and a given type uuid.

Arguments:

    IfSpec - Supplies a description of the interface.

    MgrTypeUuid - Optionally supplies the type uuid of the manager
        entry point vector we want returned.  If no manager type uuid
        is specified, then the null uuid is assumed.

    MgrEpv - Returns the manager entry point vector.

Return Value:

    RPC_S_OK - The manager entry point vector has successfully been
        returned.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with the interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    InitializeIfNecessary();

    return(GlobalRpcServer->InquireManagerEpv(
                    (RPC_SERVER_INTERFACE PAPI *) IfSpec,
                    (RPC_UUID PAPI *) MgrTypeUuid, MgrEpv));
}


RPC_STATUS RPC_ENTRY
RpcServerListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaxCalls,
    IN unsigned int DontWait
    )
/*++

Routine Description:

    This routine gets called to start the rpc server listening for remote
    procedure calls.  We do not return until RpcMgmtStopServerListening
    is called and all active remote procedure calls complete, or a fatal
    error occurs in the runtime.

Arguments:

    MinimumCallThreads - Supplies the minimum number of threads which
        should be around to service remote procedure calls.  A higher
        value for this number will give more responsive service at the
        cost of more threads.

    MaxCalls - Supplies the maximum number of concurrent calls the rpc
        server is willing to accept.  This number must be greater than
        or equal to the largest MaxCalls value specified to the
        RpcServerUse* routines.

    DontWait - Supplies a flag indicating whether or not to wait until
        RpcMgmtStopServerListening has been called and all calls have
        completed.  A non-zero value indicates not to wait.

Return Value:

    RPC_S_OK - Everything worked as expected.  All active remote procedure
        calls have completed.  It is now safe to exit this process.

    RPC_S_ALREADY_LISTENING - Another thread has already called
        RpcServerListen and has not yet returned.

    RPC_S_NO_PROTSEQS_REGISTERED - No protocol sequences have been
        registered with the rpc server.  As a consequence it is
        impossible for the rpc server to receive any remote procedure
        calls, hence, the error code.

    RPC_S_MAX_CALLS_TOO_SMALL - The supplied value for MaxCalls is smaller
        than the the supplied value for MinimumCallThreads, or the zero
        was supplied for MaxCalls.

--*/
{
    THREAD *Thread;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    return(GlobalRpcServer->ServerListen(MinimumCallThreads, MaxCalls,
                    DontWait));
}


RPC_STATUS RPC_ENTRY
RpcServerRegisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid OPTIONAL,
    IN RPC_MGR_EPV PAPI * MgrEpv OPTIONAL
    )
/*++

Routine Description:

    This routine is used by server application to register a manager
    entry point vector and optionally an interface.  If the interface
    has not been registered, then it will be registered.  If it has
    already been registered, the manager entry point vector will be
    added to it under the specified type uuid.

Arguments:

    IfSpec - Supplies a description of the interface.  This is actually
        a pointer to an opaque data structure which the runtime knows
        how to interpret.

    MgrTypeUuid - Optionally supplies the type uuid for the specified
        manager entry point vector.  If no type uuid is supplied, then
        the null uuid will be used as the type uuid.

    MgrEpv - Optionally supplies a manager entry point vector corresponding
        to the type uuid.  If a manager entry point vector is not supplied,
        then the manager entry point vector in the interface will be
        used.

Return Value:

    RPC_S_OK - The specified rpc interface has been successfully
        registered with the rpc server.  It is now ready to accept
        remote procedure calls.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to register
        the rpc interface with the rpc server.

    RPC_S_TYPE_ALREADY_REGISTERED - A manager entry point vector has
        already been registered for the supplied rpc interface and
        manager type UUID.

--*/
{
    InitializeIfNecessary();

    return(GlobalRpcServer->RegisterInterface(
                    (RPC_SERVER_INTERFACE PAPI *) IfSpec,
                    (RPC_UUID PAPI *) MgrTypeUuid, MgrEpv, 0,
                    MAX_IF_CALLS, gMaxRpcSize, 0));
}


RPC_STATUS RPC_ENTRY
RpcServerRegisterIfEx (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid,
    IN RPC_MGR_EPV PAPI * MgrEpv,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN RPC_IF_CALLBACK_FN PAPI *IfCallbackFn
    )
/*++

Routine Description:

    This routine is used by server application to register a manager
    entry point vector and  an interface.  If the interface
    has not been registered, then it will be registered.  If it has
    already been registered, the manager entry point vector will be
    added to it under the specified type uuid. If the IF_AUTOLISTEN flag
    has been specified, then the registered interface will be treated as an
    auto-listen interface.

Arguments:

    IfSpec - Supplies a description of the interface.  This is actually
        a pointer to an opaque data structure which the runtime knows
        how to interpret.

    MgrTypeUuid - Optionally supplies the type uuid for the specified
        manager entry point vector.  If no type uuid is supplied, then
        the null uuid will be used as the type uuid.

    MgrEpv - Optionally supplies a manager entry point vector corresponding
        to the type uuid.  If a manager entry point vector is not supplied,
        then the manager entry point vector in the interface will be
        used.

    Flags -
        RPC_IF_OLE - the interface is an OLE interface. Calls need to be dispatched
                      to procnum 0
        RPC_IF_AUTOLISTEN - the interface is an auto-listen inteface, calls may be
                      dispatched on this inteface as soon as it is registered.

    MaxCalls -
        Maximum number of calls that can be simulaneously dispatched on this interface

Return Value:

    RPC_S_OK - The specified rpc interface has been successfully
        registered with the rpc server.  It is now ready to accept
        remote procedure calls.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to register
        the rpc interface with the rpc server.

    RPC_S_TYPE_ALREADY_REGISTERED - A manager entry point vector has
        already been registered for the supplied rpc interface and
        manager type UUID.

--*/
{
    InitializeIfNecessary();

    if (Flags & RPC_IF_OLE)
        {
        Flags |= RPC_IF_AUTOLISTEN ;
        }

    return(GlobalRpcServer->RegisterInterface(
                    (RPC_SERVER_INTERFACE PAPI *) IfSpec,
                    (RPC_UUID PAPI *) MgrTypeUuid, MgrEpv, Flags,
                    MaxCalls, gMaxRpcSize, IfCallbackFn));
}


RPC_STATUS RPC_ENTRY
RpcServerRegisterIf2 (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid,
    IN RPC_MGR_EPV PAPI * MgrEpv,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN unsigned int MaxRpcSize,
    IN RPC_IF_CALLBACK_FN PAPI *IfCallbackFn
    )
{
    InitializeIfNecessary();

    if (Flags & RPC_IF_OLE)
        {
        Flags |= RPC_IF_AUTOLISTEN ;
        }

    return(GlobalRpcServer->RegisterInterface(
                    (RPC_SERVER_INTERFACE PAPI *) IfSpec,
                    (RPC_UUID PAPI *) MgrTypeUuid, MgrEpv, Flags,
                    MaxCalls, MaxRpcSize, IfCallbackFn));
}


RPC_STATUS RPC_ENTRY
RpcServerUnregisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid, OPTIONAL
    IN unsigned int WaitForCallsToComplete
    )
/*++

Routine Description:

    A server application will use this routine to unregister an interface
    with the rpc server.  Depending on what is specified for the manager
    type uuid one or all of the manager entry point vectors will be removed
    from the interface.

Arguments:

    IfSpec - Supplies a description of the interface.  This is actually
        a pointer to an opaque data structure which the runtime knows
        how to interpret.

    MgrTypeUuid - Optionally supplies the type uuid of the manager entry
        point vector to be removed.  If this argument is not supplied,
        then all manager entry point vectors for this interface will
        be removed.

    WaitForCallsToComplete - Supplies a flag indicating whether or not
        this routine should wait for all calls to complete using the
        interface and manager being unregistered.  A non-zero value
        indicates to wait.

Return Value:

    RPC_S_OK - The manager entry point vector(s) are(were) successfully
        removed from the specified interface.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with the interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    InitializeIfNecessary();

    return(GlobalRpcServer->UnregisterIf(
                    (RPC_SERVER_INTERFACE PAPI *) IfSpec,
                    (RPC_UUID PAPI *) MgrTypeUuid, WaitForCallsToComplete));
}

RPC_STATUS RPC_ENTRY
RpcServerUnregisterIfEx (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid, OPTIONAL
    IN int RundownContextHandles
    )
/*++

Routine Description:

    Does the same as RpcServerUnregisterIf and in addition to that
    will cleanup all context handles registered by this interface
    provided that the interface is using strict_context_handles. If
    the interface does not use strict context handles, this API will
    return ERROR_INVALID_HANDLE, but the interface will be
    unregistered. Unlike RpcServerUnregisterIf, this API requires the
    IfSpec argument.

Arguments:

    IfSpec - Supplies a description of the interface.  This is actually
        a pointer to an opaque data structure which the runtime knows
        how to interpret.

    MgrTypeUuid - Optionally supplies the type uuid of the manager entry
        point vector to be removed.  If this argument is not supplied,
        then all manager entry point vectors for this interface will
        be removed.

    RundownContextHandles - if TRUE, the context handles belonging to
        this interface will be rundown. If FALSE, only the runtime
        portion of the context handle will be cleaned up, and the
        server portion of the context handle will be left alone.

Return Value:

    RPC_S_OK - The manager entry point vector(s) are(were) successfully
        removed from the specified interface.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with the interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    RPC_STATUS RpcStatus;
    DestroyContextHandleCallbackContext CallbackContext;

    InitializeIfNecessary();

    if (!ARGUMENT_PRESENT(IfSpec))
        return ERROR_INVALID_PARAMETER;

    RpcStatus = RpcServerUnregisterIf(IfSpec,
        MgrTypeUuid,
        TRUE    // WaitForCallsToComplete
        );

    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    CallbackContext.RpcInterfaceInformation = (RPC_SERVER_INTERFACE *) IfSpec;
    CallbackContext.RundownContextHandles = RundownContextHandles;
    RpcStatus = GlobalRpcServer->EnumerateAndCallEachAddress(
        RPC_SERVER::actDestroyContextHandle,
        &CallbackContext);

    return RpcStatus;
}


RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqsEx (
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    A server application will use this routine to add all rpc protocol
    sequences supported by the current operating environment to the
    rpc server.  An endpoint will be dynamically selected for each rpc
    protocol sequence.  We will inquire the supported rpc protocol
    sequences, and then let the RPC_SERVER class take care of adding
    each one for us.

Arguments:

    MaxCalls - Supplies a lower bound for the number of concurrent
        remote procedure calls the server must be able to handle.

    SecurityDescriptor - Optionally supplies a security descriptor to
        place on the rpc protocol sequence (address) we are adding to
        the rpc server.

Return Value:

    RPC_S_OK - All supported rpc protocol sequences have been added to
        the rpc server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to add all of
        the supported rpc protocol sequences to the rpc server.

    RPC_S_NO_PROTSEQS - The current system configuration does not
        support any rpc protocol sequences.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

--*/
{
    RPC_PROTSEQ_VECTOR * RpcProtseqVector;
    RPC_STATUS Status;
    unsigned int Index, ValidProtocolSequences = 0;
    THREAD *Thread;
    ULONG OriginalEndpointFlags;

    InitializeIfNecessary();

    if (Policy->Length < sizeof(RPC_POLICY))
        {
        return RPC_S_INVALID_BOUND ;
        }

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    Status = RpcConfigInquireProtocolSequences(TRUE, &RpcProtseqVector);
    if (Status != RPC_S_OK)
        {
        return(Status);
        }

    // save away the original value
    OriginalEndpointFlags = Policy->EndpointFlags;

    Policy->EndpointFlags |= RPC_C_DONT_FAIL;

    for (Index = 0; Index < RpcProtseqVector->Count; Index++)
        {
        //
        // Don't include nb protocols, ncadg_mq and ncacn_http
        // in RpcServerUseAllProtseqs().
        //
        if ( (RpcpStringNCompare(RPC_CONST_STRING("ncacn_nb_"),
                                 RpcProtseqVector->Protseq[Index],
                                 9) == 0)
           ||(RpcpStringNCompare(RPC_CONST_STRING("ncadg_mq"),
                                 RpcProtseqVector->Protseq[Index],
                                 8) == 0)
#if !defined(APPLETALK_ON)
           ||(RpcpStringNCompare(RPC_CONST_STRING("ncacn_at_dsp"),
                                 RpcProtseqVector->Protseq[Index],
                                 12) == 0)
#endif
           ||(RpcpStringNCompare(RPC_CONST_STRING("ncacn_http"),
                                 RpcProtseqVector->Protseq[Index],
                                 10) == 0) )
            {
            continue;
            }

        Status = GlobalRpcServer->UseRpcProtocolSequence(NULL,
                RpcProtseqVector->Protseq[Index], MaxCalls, 0,
                SecurityDescriptor, Policy->EndpointFlags, Policy->NICFlags);
        if ( Status == RPC_S_OK )
            {
            ValidProtocolSequences += 1;
            }
        else if (   ( Status == RPC_S_OUT_OF_MEMORY )
                 || ( Status == RPC_S_INVALID_SECURITY_DESC )
                 || ( Status == RPC_S_OUT_OF_RESOURCES ) )
            {
            RpcProtseqVectorFree(&RpcProtseqVector);
            Policy->EndpointFlags = OriginalEndpointFlags;
            return(Status);
            }
        }

    Policy->EndpointFlags = OriginalEndpointFlags;
    RpcProtseqVectorFree(&RpcProtseqVector);

    if ( ValidProtocolSequences == 0 )
        {
        return(Status);
        }

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqs (
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return RpcServerUseAllProtseqsEx (MaxCalls, SecurityDescriptor, &Policy) ;
}


RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqsIfEx (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    A server application will use this routine to add all protocol
    sequences and endpoints specified in the header of an IDL file.
    This information (from the IDL file) is specified by the interface
    specification argument.

Arguments:

    MaxCalls - Supplies a lower bound for the number of concurrent
        remote procedure calls the server must be able to handle.

    IfSpec - Supplies the interface specification from which we
        should extract the rpc protocol sequence and end point
        information to be used.

    SecurityDescriptor - Optionally supplies a security descriptor to
        place on the rpc protocol sequence (address) we are adding to
        the rpc server.

Return Value:

    RPC_S_OK - All of the support rpc protocol sequences (and their
        associated endpoints) have been added to the rpc server.

    RPC_S_NO_PROTSEQS - None of the specified rpc protocol sequences
        are supported by the rpc server, or no rpc protocol sequences
        were specified.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to add the
        requested rpc protocol sequence to the rpc server.

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        syntactically invalid.

    RPC_S_DUPLICATE_ENDPOINT - One of the supplied endpoints has already
        been added to this rpc server.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

--*/
{
    RPC_SERVER_INTERFACE PAPI * RpcServerInfo;
    unsigned int SupportedProtseqCount = 0;
    unsigned int Index;
    RPC_STATUS Status;

    InitializeIfNecessary();

    if (Policy->Length < sizeof(RPC_POLICY))
        {
        return RPC_S_INVALID_BOUND ;
        }

    RpcServerInfo = (RPC_SERVER_INTERFACE PAPI *) IfSpec;

    if (RpcServerInfo->RpcProtseqEndpointCount == 0)
        {
        return(RPC_S_NO_PROTSEQS);
        }

    Policy->EndpointFlags |= RPC_C_DONT_FAIL;

    for (Index = 0; Index < RpcServerInfo->RpcProtseqEndpointCount;
            Index++)
        {
        Status = RpcServerUseProtseqEpExA(
                RpcServerInfo->RpcProtseqEndpoint[Index].RpcProtocolSequence,
                MaxCalls, RpcServerInfo->RpcProtseqEndpoint[Index].Endpoint,
                SecurityDescriptor, Policy);
        if ( Status == RPC_S_OK )
            {
            SupportedProtseqCount += 1;
            }
        else if (   ( Status == RPC_S_OUT_OF_MEMORY )
                 || ( Status == RPC_S_INVALID_SECURITY_DESC )
                 || ( Status == RPC_S_OUT_OF_RESOURCES ) )
            {
            return(Status);
            }
        }

    if ( SupportedProtseqCount == 0 )
        {
        return(RPC_S_NO_PROTSEQS);
        }

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqsIf (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return RpcServerUseAllProtseqsIfEx ( MaxCalls, IfSpec, SecurityDescriptor, &Policy) ;
}


RPC_STATUS RPC_ENTRY
I_RpcServerUseProtseq2 (
    IN unsigned short PAPI *NetworkAddress,
    IN unsigned short PAPI *Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI *SecurityDescriptor,
    IN void *pPolicy
    )
{
    PRPC_POLICY Policy = (PRPC_POLICY) pPolicy;
    THREAD *Thread;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    if (Policy->Length < sizeof(RPC_POLICY))
        {
        return RPC_S_INVALID_BOUND ;
        }

    return(GlobalRpcServer->UseRpcProtocolSequence(NetworkAddress, Protseq, MaxCalls, 0,
                    SecurityDescriptor, Policy->EndpointFlags, Policy->NICFlags));
}


RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEx (
    IN unsigned short PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    This routine is used by a server application to add an rpc protocol
    sequence to the rpc server.  An endpoint will be dynamically selected
    for this rpc protocol sequence.  What we do is to let the RPC_SERVER
    class take care of most of the work.

Arguments:

    Protseq - Supplies the rpc protocol sequence we wish to add.  An
        rpc protocol sequence contains two pieces of information we
        are interested in: the rpc protocol (connection, datagram, or
        shared memory) and the transport interface requested.

    MaxCalls - Supplies a lower bound for the number of concurrent
        remote procedure calls the server must be able to handle.

    SecurityDescriptor - Optionally supplies a security descriptor to
        place on the rpc protocol sequence (address) we are adding to
        the rpc server.

Return Value:

    RPC_S_OK - The requested rpc protocol sequence has been added to
        the rpc server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to add the
        requested rpc protocol sequence to the rpc server.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The specified rpc protocol sequence
        is not supported (but it appears to be valid).

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        syntactically invalid.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

--*/
{
    return I_RpcServerUseProtseq2(NULL, Protseq, MaxCalls, SecurityDescriptor, Policy);
}


RPC_STATUS RPC_ENTRY
RpcServerUseProtseq (
    IN unsigned short PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;
    THREAD *Thread;

    InitializeIfNecessary();

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    return RpcServerUseProtseqEx(Protseq, MaxCalls, SecurityDescriptor, &Policy) ;
}


RPC_STATUS RPC_ENTRY
I_RpcServerUseProtseqEp2 (
    IN unsigned short PAPI * NetworkAddress,
    IN unsigned short PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_CHAR PAPI * Endpoint,
    IN void PAPI * SecurityDescriptor,
    IN void *pPolicy
    )
{
    PRPC_POLICY Policy = (PRPC_POLICY) pPolicy;

    InitializeIfNecessary();

    if (Policy->Length < sizeof(RPC_POLICY))
        {
        return RPC_S_INVALID_BOUND ;
        }

    return(GlobalRpcServer->UseRpcProtocolSequence(NetworkAddress, Protseq, MaxCalls,
                    Endpoint, SecurityDescriptor,
                    Policy->EndpointFlags, Policy->NICFlags));
}


RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEpEx (
    IN unsigned short PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned short PAPI * Endpoint,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    This routine is used by a server application to add an rpc protocol
    sequence and an endpoint to the rpc server.  What we do is to let
    the RPC_SERVER class take care of most of the work.

Arguments:

    Protseq - Supplies the rpc protocol sequence we wish to add.  An
        rpc protocol sequence contains two pieces of information we
        are interested in: the rpc protocol (connection, datagram, or
        shared memory) and the transport interface requested.

    MaxCalls - Supplies a lower bound for the number of concurrent
        remote procedure calls the server must be able to handle.

    Endpoint - Supplies the endpoint to use for this rpc protocol
        sequence.

    SecurityDescriptor - Optionally supplies a security descriptor to
        place on the rpc protocol sequence (address) we are adding to
        the rpc server.

Return Value:

    RPC_S_OK - The requested rpc protocol sequence has been added to
        the rpc server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to add the
        requested rpc protocol sequence to the rpc server.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The specified rpc protocol sequence
        is not supported (but it appears to be valid).

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        syntactically invalid.

    RPC_S_INVALID_ENDPOINT_FORMAT -

    RPC_S_DUPLICATE_ENDPOINT - The supplied endpoint has already been
        added to this rpc server.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

--*/
{
    return I_RpcServerUseProtseqEp2 (NULL, Protseq, MaxCalls, Endpoint,
                                     SecurityDescriptor, (void *) Policy);
}


RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEp (
    IN RPC_CHAR PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_CHAR PAPI * Endpoint,
    IN void PAPI * SecurityDescriptor
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return RpcServerUseProtseqEpEx(Protseq, MaxCalls, Endpoint,
                SecurityDescriptor, &Policy) ;
}


RPC_STATUS RPC_ENTRY
RpcServerUseProtseqIfEx (
    IN unsigned short PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    A server application will use this routine to one of the protocol
    sequences (and its associated endpoint) specified in the header of
    an IDL file.  This information (from the IDL file) is specified by
    the interface specification argument.

Arguments:

    Protseq - Supplies the rpc protocol sequence to be added to
        the rpc server.  The list of rpc protocol sequence -- endpoint
        pairs in the interface specification will be searched to find
        the corresponding endpoint.

    MaxCalls - Supplies a lower bound for the number of concurrent
        remote procedure calls the server must be able to handle.

    IfSpec - Supplies the interface specification from which we
        should extract the rpc protocol sequence and end point
        information to be used.

    SecurityDescriptor - Optionally supplies a security descriptor to
        place on the rpc protocol sequence (address) we are adding to
        the rpc server.

Return Value:

    RPC_S_OK - The requested rpc protocol sequence (and its associated
        endpoint) has been added to the rpc server.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The supplied rpc protocol sequence
        is not supported by the rpc server.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The supplied rpc protocol sequence is not
        in the list of rpc protocol sequences in the interface specification.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to add the
        requested rpc protocol sequence to the rpc server.

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        syntactically invalid.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

--*/
{
    RPC_SERVER_INTERFACE PAPI * RpcServerInfo;
    unsigned int Index, EndpointsRegistered = 0;
    RPC_STATUS RpcStatus;
#ifdef UNICODE
    UNICODE_STRING UnicodeString;
#endif // UNICODE

    InitializeIfNecessary();

    if (Policy->Length < sizeof(RPC_POLICY))
        {
        return RPC_S_INVALID_BOUND ;
        }


    RpcServerInfo = (RPC_SERVER_INTERFACE PAPI *) IfSpec;

    for (Index = 0; Index < RpcServerInfo->RpcProtseqEndpointCount;
            Index++)
        {
#ifdef UNICODE
        RpcStatus = AnsiToUnicodeString(
                RpcServerInfo->RpcProtseqEndpoint[Index].RpcProtocolSequence,
                &UnicodeString);
        if (RpcStatus != RPC_S_OK)
            return(RpcStatus);
        if ( RpcpStringCompare(Protseq, UnicodeString.Buffer) == 0 )
#else // UNICODE
        if ( RpcpStringCompare(Protseq,
                RpcServerInfo->RpcProtseqEndpoint[Index].RpcProtocolSequence)
                == 0 )
#endif // UNICODE
            {
#ifdef UNICODE
            RtlFreeUnicodeString(&UnicodeString);
#endif
            RpcStatus = RpcServerUseProtseqEpExA(
                    RpcServerInfo->RpcProtseqEndpoint[ Index].RpcProtocolSequence,
                    MaxCalls, RpcServerInfo->RpcProtseqEndpoint[Index].Endpoint,
                    SecurityDescriptor, Policy);
            if ( RpcStatus != RPC_S_OK )
                {
                return(RpcStatus);
                }
            EndpointsRegistered += 1;
            }
#ifdef UNICODE
        else
            {
            RtlFreeUnicodeString(&UnicodeString);
            }
#endif // UNICODE
        }

    if ( EndpointsRegistered == 0 )
        {
        return(RPC_S_PROTSEQ_NOT_SUPPORTED);
        }
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcServerUseProtseqIf (
    IN unsigned short PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return RpcServerUseProtseqIfEx (Protseq, MaxCalls, IfSpec,
                SecurityDescriptor, &Policy) ;
}


RPC_STATUS RPC_ENTRY
RpcMgmtStatsVectorFree (
    IN OUT RPC_STATS_VECTOR ** StatsVector
    )
/*++

Routine Description:

    This routine is used to free the statistics vector obtained from
    RpcMgmtInqStats.

Arguments:

    StatsVector - Supplies the statistics vector to be freed; on return,
        the pointer this pointer points to will be set to zero.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_ARG - The specified statistics vectors does not contain
        the address of a statistics vector.

--*/
{
    InitializeIfNecessary();

    if (StatsVector == 0)
        return(RPC_S_INVALID_ARG);

    RpcpFarFree(*StatsVector);
    *StatsVector = 0;
    return(RPC_S_OK);
}



// N.B. This must be the same as the range declared in the IDL file.
#define MAX_STATISTICS 50

RPC_STATUS RPC_ENTRY
RpcMgmtInqStats (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_STATS_VECTOR ** Statistics
    )
/*++

Routine Description:

    This routine is used to inquire statistics about the server.  In
    particular, the statistics consist of the number of remote procedure
    calls received by this server, the number of remote procedure calls
    initiated by this server (callbacks), the number of network packets
    received, and the number of network packets sent.

Arguments:

    Binding -  Optionally supplies a binding handle to the server.  If this
        argument is not supplied, the local application is queried.

    Statistics - Returns the statistics vector for this server.

Return Value:

    RPC_S_OK - Everything worked just fine, and you now know the
        statistics for this server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_INVALID_BINDING - The supplied binding is not zero.

--*/
{
    unsigned long Status = 0;
    unsigned long Count = MAX_STATISTICS;
    unsigned long StatsVector[MAX_STATISTICS];

    InitializeIfNecessary();

    if (Binding == 0)
        {
        *Statistics = (RPC_STATS_VECTOR *) RpcpFarAllocate(sizeof(RPC_STATS_VECTOR)
                      + 3 * sizeof(unsigned long));
        if (*Statistics == 0)
            return(RPC_S_OUT_OF_MEMORY);

        (*Statistics)->Count = 4;
        GlobalRpcServer->InquireStatistics(*Statistics);

        return(RPC_S_OK);
        }

    _rpc_mgmt_inq_stats(Binding, &Count, StatsVector, &Status);

    if ( Status == RPC_S_OK )
        {
        *Statistics = (RPC_STATS_VECTOR __RPC_FAR *) RpcpFarAllocate(
                sizeof(RPC_STATS_VECTOR) + sizeof(unsigned long)
                * (MAX_STATISTICS - 1));
        if ( *Statistics == 0 )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        for ((*Statistics)->Count = 0; (*Statistics)->Count < Count
                    && (*Statistics)->Count < MAX_STATISTICS;
                    (*Statistics)->Count++)
            {
            (*Statistics)->Stats[(*Statistics)->Count] =
                    StatsVector[(*Statistics)->Count];
            }
        }

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcMgmtIsServerListening (
    IN RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    An application will use this routine to determine whether or not
    the server is listening.

Arguments:

    Binding - Optionally supplies a binding handle to the server.  If this
        argument is not supplied, the local application is queried.

Return Value:

    RPC_S_OK - The server is listening.

    RPC_S_INVALID_BINDING - The supplied binding is not zero.

    RPC_S_NOT_LISTENING - The server is not listening.

--*/
{
    unsigned long Result;
    unsigned long Status = 0;

    InitializeIfNecessary();

    if (Binding == 0)
        {
        if (GlobalRpcServer->IsServerListening() == 0)
            return(RPC_S_NOT_LISTENING);
        return(RPC_S_OK);
        }

    Result = _rpc_mgmt_is_server_listening(Binding, &Status);

    if (Status == RPC_S_OK)
        {
        return((Result == 1) ? RPC_S_OK : RPC_S_NOT_LISTENING);
        }
     if ( (Status == RPC_S_SERVER_UNAVAILABLE)
        || (Status == RPC_S_SERVER_TOO_BUSY) )
        {
        return (RPC_S_NOT_LISTENING);
        }

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcMgmtStopServerListening (
    IN RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This routine is used by an application to stop the rpc server from
    accepting any more remote procedure calls.  Currently active remote
    procedure calls are allowed to complete.

Arguments:

    Binding - Optionally supplies a binding handle to the server.  If this
        argument is not supplied, the local server is stopped.

Return Value:

    RPC_S_OK - The server has been successfully notified that it should
        stop listening for remote procedure calls.  No new remote procedure
        calls will be accepted after this routine returns.  RpcServerListen
        will return after all active calls have completed.

    RPC_S_NOT_LISTENING - A thread has not called RpcServerListen (and
        not returned) yet.

--*/
{
    RPC_STATUS Status;

    InitializeIfNecessary();

    if (Binding == 0)
        {
        return(GlobalRpcServer->StopServerListening());
        }

    _rpc_mgmt_stop_server_listening(Binding, (unsigned long *)&Status);

    return(Status);

}


RPC_STATUS RPC_ENTRY
RpcMgmtWaitServerListen (
    void
    )
/*++

Routine Description:

    This routine performs the wait that RpcServerListen normally performs
    when the DontWait flag is not set.  An application must call this
    routine only after RpcServerListen has been called with the DontWait
    flag set.  We do not return until RpcMgmtStopServerListening is called
    and all active remote procedure calls complete, or a fatal error occurs
    in the runtime.

Return Value:

    RPC_S_OK - Everything worked as expected.  All active remote procedure
        calls have completed.  It is now safe to exit this process.

    RPC_S_ALREADY_LISTENING - Another thread has already called
        RpcMgmtWaitServerListen and has not yet returned.

    RPC_S_NOT_LISTENING - RpcServerListen has not yet been called.

--*/
{
    InitializeIfNecessary();

    return(GlobalRpcServer->WaitServerListen());
}

RPC_STATUS RPC_ENTRY
I_RpcBindingInqDynamicEndpointA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char PAPI * PAPI * DynamicEndpoint
    )
{
#ifdef UNICODE
    return (RPC_S_CANNOT_SUPPORT);
#else
    USES_CONVERSION;
    CNlDelUnicodeAnsi thunkedDynamicEndpoint;
    RPC_STATUS RpcStatus;

    RpcStatus = I_RpcBindingInqDynamicEndpointW(Binding, thunkedDynamicEndpoint);
    if (RpcStatus == RPC_S_OK)
        {
        ATTEMPT_CONVERT_W2A_OPTIONAL(thunkedDynamicEndpoint, DynamicEndpoint);
        }
    return RpcStatus;
#endif
}


RPC_STATUS RPC_ENTRY
I_RpcBindingInqDynamicEndpointW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short PAPI * PAPI * DynamicEndpoint
    )
/*++

Routine Description:

    This routine is used to inquire the dynamic endpoint from a binding
    handle.  The only binding handles which will have dynamic endpoints
    are those which are create from rpc addresses which have dynamic
    endpoints.  This routine will be used for one purpose and one purpose
    only: RpcEpRegister and RpcEpRegisterNoReplace need to know which
    binding handles have dynamic endpoints; only binding handles with
    dynamic endpoints get placed into the endpoint mapper database.

Arguments:

    Binding - Supplies the binding handle from which we wish to obtain
        the dynamic endpoint.

    DynamicEndpoint - Returns a pointer to a string containing the dynamic
        endpoint for this binding handle if it has one; otherwise, it
        will be zero.  If a string is return, it must be freed using
        RpcStringFree.

Return Value:

    RPC_S_OK - The operation completed successfully.  This does not
        indicate whether or not the binding handle has a dynamic endpoint.
        To determine that, you must check whether *DynamicEndpoint is
        equal to zero.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to duplicate
        the dynamic endpoint.

    RPC_S_INVALID_BINDING - The binding argument does not specify a binding
        handle.

--*/
{
    BINDING_HANDLE * BindingHandle;
#ifndef UNICODE
    USES_CONVERSION;
    COutDelThunk thunkedDynamicEndpoint;
    RPC_STATUS RpcStatus;
#endif

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

#ifdef UNICODE
    return (BindingHandle->InquireDynamicEndpoint(DynamicEndpoint));
#else
    RpcStatus = BindingHandle->InquireDynamicEndpoint(thunkedDynamicEndpoint);
    if (RpcStatus == RPC_S_OK)
        {
        ATTEMPT_OUT_THUNK_OPTIONAL(thunkedDynamicEndpoint, DynamicEndpoint);
        }
    return RpcStatus;
#endif

}


RPC_STATUS RPC_ENTRY
RpcServerRegisterAuthInfo (
    IN unsigned short PAPI * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn, OPTIONAL
    IN void PAPI * Arg OPTIONAL
    )
/*++

Routine Description:

    A server application will use this routine to indicate to the runtime
    what authentication service to use for authenticating remote procedure
    calls.  This routine should be called once for each pair of authentication
    service and principal name which the server wishes to use for
    authentication.  In order for an client to be able to talk with an
    authenticated server, the authentication service specified by the client
    must be one of the ones registered by the server.  Attempting to
    register the same authentication service and principal name will not
    result in an error.

Arguments:

    ServerPrincName - Supplies the principal name for the server.

    AuthnSvc - Supplies an authentication service to use when the server
        receives a remote procedure call.

    GetKeyFn - Optionally supplies a routine to be used when the runtime
        needs an encryption key.

    Arg - Optionally supplies an argument to be passed to the routine used
        to get keys each time it is called.

Return Value:

    RPC_S_OK - The authentication service and server principal name have
        been registered with the runtime.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported.

--*/
{
    THREAD *Thread;
    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    return(GlobalRpcServer->RegisterAuthInformation(ServerPrincName,
                    AuthnSvc, GetKeyFn, Arg));
}


RPC_STATUS RPC_ENTRY
RpcBindingInqAuthClient (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE PAPI * Privs,
    OUT unsigned short PAPI * PAPI * PrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc OPTIONAL
    )
{
    return RpcBindingInqAuthClientEx( ClientBinding,
                                       Privs,
                                       PrincName,
                                       AuthnLevel,
                                       AuthnSvc,
                                       AuthzSvc,
                                       0
                                       );
}


RPC_STATUS RPC_ENTRY
RpcBindingInqAuthClientEx (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE PAPI * Privs,
    OUT unsigned short PAPI * PAPI * ServerPrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc, OPTIONAL
    IN  unsigned long        Flags
    )
/*++

Routine Description:

    A server application will use this routine to obtain the authorization
    information about a client making an authenticated remote procedure
    call.

Arguments:

    ClientBinding - Optionally supplies a binding handle on the server
        side which indicates for which remote procedure call we wish to
        obtain authorization information.  If no binding handle is supplied,
        then it is taken to be the remote procedure call currently being
        handled by this server thread.

    Privs - Returns a handle to the privileges information for the client
        thread which made the remote procedure call.

    ServerPrincName - Optionally returns the server principal name specified
        by the client application.

    AuthnLevel - Optionally returns the authentication level requested
        by the client application.

    AuthnSvc - Optionally returns the authentication service requested by
        the client application.

    AuthzSvc - Optionally returns the authorization service requested by
        the client application.

Return Value:

    RPC_S_OK - We successfully obtained the requested authentication and
        authorization information.

    RPC_S_INVALID_BINDING - The supplied binding handle (as the binding
        argument) is not a valid binding handle.

    RPC_S_WRONG_KIND_OF_BINDING - The binding handle is not a binding handle
        on the server side.

    RPC_S_BINDING_HAS_NO_AUTH - The remote procedure call is not
        authenticated.

    RPC_S_NO_CALL_ACTIVE - No binding handle was supplied and there is no
        call active for this server thread.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

--*/
{
    SCALL * SCall;

    InitializeIfNecessary();

    if (ARGUMENT_PRESENT(ClientBinding))
        {
        SCall = (SCALL *) ClientBinding;
        if (SCall->InvalidHandle(SCALL_TYPE))
            {
            return(RPC_S_INVALID_BINDING);
            }
        }
    else
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if ( SCall == 0 )
            {
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }

    return SCall->InquireAuthClient(Privs,
                    ServerPrincName,
                    AuthnLevel,
                    AuthnSvc,
                    AuthzSvc,
                    Flags
                    );
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqCallAttributesW (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    IN OUT void *RpcCallAttributes
    )
/*++

Routine Description:

    A server application will use this routine to obtain the security context
    attributes for the calling client.

Arguments:

    ClientBinding - Optionally supplies a binding handle on the server
        side which indicates for which remote procedure call we wish to
        obtain authorization information.  If no binding handle is supplied,
        then it is taken to be the remote procedure call currently being
        handled by this server thread.

    RpcCallAttributes - a pointer to 
        RPC_CALL_ATTRIBUTES_V1_W structure. The Version
        member must be initialized.

Return Value:

    RPC_S_OK for success of RPC_S_* /Win32 error code for error. EEInfo is
        supplied. If the function fails, the contents of 
        RpcCallAttributes is undefined.
--*/
{
    SCALL * SCall;
    RPC_CALL_ATTRIBUTES_V1 *CallAttributes;

    CallAttributes = 
        (RPC_CALL_ATTRIBUTES_V1 *)RpcCallAttributes;

    if (CallAttributes->Version != 1)
        return ERROR_INVALID_PARAMETER;

    if (CallAttributes->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        if ((CallAttributes->ServerPrincipalName == NULL) &&
            (CallAttributes->ServerPrincipalNameBufferLength != 0))
            {
            return ERROR_INVALID_PARAMETER;
            }
        }

    if (CallAttributes->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        if ((CallAttributes->ClientPrincipalName == NULL) &&
            (CallAttributes->ClientPrincipalNameBufferLength != 0))
            {
            return ERROR_INVALID_PARAMETER;
            }
        }

    InitializeIfNecessary();

    if (ARGUMENT_PRESENT(ClientBinding))
        {
        SCall = (SCALL *) ClientBinding;
        if (SCall->InvalidHandle(SCALL_TYPE))
            {
            return(RPC_S_INVALID_BINDING);
            }
        }
    else
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if ( SCall == 0 )
            {
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }

    return SCall->InquireCallAttributes(CallAttributes);
}

RPC_STATUS RPC_ENTRY
RpcImpersonateClient (
    IN RPC_BINDING_HANDLE ClientBinding OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Values:

--*/
{
    SCALL * SCall;
    THREAD *Thread;

    InitializeIfNecessary();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    if ( ClientBinding == 0 )
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if (SCall == 0)
            return(RPC_S_NO_CALL_ACTIVE);
        }
    else
        {
        SCall = (SCALL *) ClientBinding;
        if (SCall->InvalidHandle(SCALL_TYPE))
            return(RPC_S_INVALID_BINDING);
        }

    return(SCall->ImpersonateClient());
}

// the handle to the authz.dll. Protected by the global mutex. Once initialized,
// never uninitialized
HMODULE AuthzDllHandle = NULL;

// pointer to the AuthzInitializeContextFromToken function from authz.dll. Once
// initialized, never uninitialized
AuthzInitializeContextFromTokenFnType AuthzInitializeContextFromTokenFn = NULL;

// pointer to the AuthzInitializeContextFromSid function from authz.dll. Once 
// initialized, never uninitialized
AuthzInitializeContextFromSidFnType AuthzInitializeContextFromSidFn = NULL;

// pointer to the AuthzInitializeContextFromContext function from authz.dll. Once 
// initialized, never uninitialized
AuthzInitializeContextFromAuthzContextFnType AuthzInitializeContextFromAuthzContextFn = NULL;

// pointer to the AuthzInitializeContextFromToken function from authz.dll. Once
// initialized, never uninitialized
AuthzFreeContextFnType AuthzFreeContextFn = NULL;

// the dummy resource manager with NULL callbacks for everything. Protected
// by the global mutex. Once initialized, never uninitialized
AUTHZ_RESOURCE_MANAGER_HANDLE DummyResourceManager = NULL;

typedef struct tagProcLoadArgs
{
    char *ProcName;
    PVOID *ProcRoutine;
} ProcLoadArgs;

const ProcLoadArgs AuthzProcs[4] = {
    {"AuthzInitializeContextFromToken", (PVOID *)&AuthzInitializeContextFromTokenFn},
    {"AuthzInitializeContextFromAuthzContext", (PVOID *)&AuthzInitializeContextFromAuthzContextFn},
    {"AuthzInitializeContextFromSid", (PVOID *)&AuthzInitializeContextFromSidFn},
    {"AuthzFreeContext", (PVOID *) &AuthzFreeContextFn}
    };

RPC_STATUS
InitializeAuthzSupportIfNecessary (
    void
    )
/*++

Routine Description:
    Perform initialization required for Authz functions to work. Everybody
    should call that before they use any Authz functionality.

Arguments:

Return Values:
    RPC_S_OK for success and RPC_S_* for the rest

--*/
{
    RPC_STATUS Status;
    int i;

    if (AuthzDllHandle)
        return RPC_S_OK;

    GlobalMutexRequest();

    if (AuthzDllHandle)
        {
        GlobalMutexClear();
        return RPC_S_OK;
        }

    AuthzDllHandle = LoadLibrary(L"Authz.dll");
    if (AuthzDllHandle)
        {
        Status = RPC_S_OK;
        for (i = 0; i < (sizeof(AuthzProcs) / sizeof(AuthzProcs[0])); i ++)
            {
            *(AuthzProcs[i].ProcRoutine) = GetProcAddress(AuthzDllHandle,
                AuthzProcs[i].ProcName);

            if (*(AuthzProcs[i].ProcRoutine) == NULL)
                {
                Status = GetLastError();
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    Status,
                    EEInfoDLInitializeAuthzSupportIfNecessary20,
                    AuthzProcs[i].ProcName);
                FreeLibrary(AuthzDllHandle);
                AuthzDllHandle = NULL;
                break;
                }
            }
        }
    else
        {
        Status = GetLastError();
        RpcpErrorAddRecord(EEInfoGCRuntime,
            Status,
            EEInfoDLInitializeAuthzSupportIfNecessary10,
            L"Authz.dll");
        }

    GlobalMutexClear();

    return Status;
}

typedef AUTHZAPI
BOOL
(WINAPI *AuthzInitializeResourceManagerFnType) (
    IN DWORD AuthzFlags,
    IN PFN_AUTHZ_DYNAMIC_ACCESS_CHECK pfnAccessCheck OPTIONAL,
    IN PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS pfnComputeDynamicGroups OPTIONAL,
    IN PFN_AUTHZ_FREE_DYNAMIC_GROUPS pfnFreeDynamicGroups OPTIONAL,
    IN PCWSTR szResourceManagerName,
    OUT PAUTHZ_RESOURCE_MANAGER_HANDLE pAuthzResourceManager
    );

RPC_STATUS
CreateDummyResourceManagerIfNecessary (
    void
    )
/*++

Routine Description:
    Perform initialization of the dummy resource manager. Any function that
    uses the dummy resource manager must call this function beforehand.
    This function must be called after InitializeAuthzSupportIfNecessary

Arguments:

Return Values:
    RPC_S_OK for success and RPC_S_* for the rest

--*/
{
    AuthzInitializeResourceManagerFnType AuthzInitializeResourceManagerFn;
    RPC_STATUS Status;
    BOOL Result;
    ULONG Flags;
    HANDLE EffectiveToken;
    HANDLE SavedToken;
    char Buffer[40];
    ULONG ReturnLength;
    ULONG LastError;
    TOKEN_PRIVILEGES *ActualTokenPrivileges;
    ULONG i;

    // this function must be called after InitializeAuthzSupportIfNecessary
    ASSERT(AuthzDllHandle);

    if (DummyResourceManager)
        return RPC_S_OK;

    SavedToken = NULL;
    Flags = AUTHZ_RM_FLAG_NO_AUDIT;

    // check whether we have audit privilege. If we do, we won't specify
    // AUTHZ_RM_FLAG_NO_AUDIT
    Result = OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_IMPERSONATE | TOKEN_QUERY,
                 TRUE,
                 &EffectiveToken
                 );

    if (Result)
        {
        SavedToken = EffectiveToken;
        Result = RevertToSelf();
        // we must always be able to revert to self unless the
        // thread was created impersonating, in which case we
        // already have a bug
        ASSERT(Result);
        }
    else
        {
        LastError = GetLastError();
        if ((LastError != ERROR_NO_TOKEN)
            && (LastError != ERROR_ACCESS_DENIED))
            {
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    // if either OpenThreadToken/Revert succeeded or we didn't fail with
    // access denied, check the process token
    if (Result || (LastError != ERROR_ACCESS_DENIED))
        {
        Result = OpenProcessToken (GetCurrentProcess(),
            TOKEN_QUERY,
            &EffectiveToken
            );

        if (Result == FALSE)
            {
            LastError = GetLastError();

            if (LastError != ERROR_ACCESS_DENIED)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                goto CleanupAndExit;
                }

            ASSERT(Flags == AUTHZ_RM_FLAG_NO_AUDIT);
            }
        else
            {
            Result = GetTokenInformation (EffectiveToken,
                TokenPrivileges,
                Buffer,
                sizeof(Buffer),
                &ReturnLength
                );

            if (Result == FALSE)
                {
                if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                    {
                    ActualTokenPrivileges = (TOKEN_PRIVILEGES *) new char [ReturnLength];
                    if (ActualTokenPrivileges == NULL)
                        {
                        CloseHandle(EffectiveToken);
                        Status = RPC_S_OUT_OF_MEMORY;
                        goto CleanupAndExit;
                        }

                    Result = GetTokenInformation (EffectiveToken,
                        TokenPrivileges,
                        ActualTokenPrivileges,
                        ReturnLength,
                        &ReturnLength
                        );

                    if (Result == FALSE)
                        {
                        ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
                        delete [] ActualTokenPrivileges;
                        CloseHandle(EffectiveToken);
                        Status = RPC_S_OUT_OF_MEMORY;
                        goto CleanupAndExit;
                        }
                    }
                else
                    {
                    CloseHandle(EffectiveToken);
                    Status = RPC_S_OUT_OF_MEMORY;
                    goto CleanupAndExit;
                    }
                }
            else
                {
                ActualTokenPrivileges = (TOKEN_PRIVILEGES *)Buffer;
                }

            // we no longer need the token - close it
            CloseHandle(EffectiveToken);

            // zoom through the list of privileges and look for the audit privilege
            for (i = 0; i < ActualTokenPrivileges->PrivilegeCount; i ++)
                {
                if ((ActualTokenPrivileges->Privileges[i].Luid.LowPart == SE_AUDIT_PRIVILEGE)
                    && (ActualTokenPrivileges->Privileges[i].Attributes & SE_PRIVILEGE_ENABLED))
                    {
                    // we found the audit privilege enabled. Ask for auditing.
                    // (or rather don't ask for no auditing)
                    Flags = 0;
                    break;
                    }
                }

            // cleanup the allocation we made
            if (ActualTokenPrivileges != (TOKEN_PRIVILEGES *)Buffer)
                delete [] ActualTokenPrivileges;
            }
        }
    else
        {
        // OpenThreadToken failed, and it failed with access denied.
        // Make sure auditing is off, and make a best effort to
        // initialize Authz.
        ASSERT(Flags == AUTHZ_RM_FLAG_NO_AUDIT);
        }

    GlobalMutexRequest();

    if (DummyResourceManager)
        {
        GlobalMutexClear();
        Status = RPC_S_OK;
        goto CleanupAndExit;
        }

    AuthzInitializeResourceManagerFn
        = (AuthzInitializeResourceManagerFnType) GetProcAddress(AuthzDllHandle,
        "AuthzInitializeResourceManager");

    if (AuthzInitializeResourceManagerFn == NULL)
        {
        Status = GetLastError();
        RpcpErrorAddRecord(EEInfoGCRuntime,
            Status,
            EEInfoDLCreateDummyResourceManagerIfNecessary10,
            "AuthzInitializeResourceManager");
        }
    else
        {
        Result = AuthzInitializeResourceManagerFn(
            Flags,      // Flags
            NULL,   // pfnAccessCheck
            NULL,   // pfnComputeDynamicGroups
            NULL,   // pfnFreeDynamicGroups
            L"",    // Name
            &DummyResourceManager);

        if (Result == FALSE)
            {
            Status = GetLastError();
            RpcpErrorAddRecord(EEInfoGCAuthz,
                Status,
                EEInfoDLCreateDummyResourceManagerIfNecessary20);
            }
        else
            Status = RPC_S_OK;
        }

    GlobalMutexClear();

CleanupAndExit:
    if (SavedToken)
        {
        Result = SetThreadToken (NULL,  // NULL means current thread
            SavedToken
            );

        // after the security folks reviewed some code, this should
        // never fail unless there is a bug in the code above.
        ASSERT(Result);

        CloseHandle(SavedToken);
        }

    return Status;
}

RPC_STATUS RPC_ENTRY
RpcGetAuthorizationContextForClient (
    IN RPC_BINDING_HANDLE ClientBinding OPTIONAL,
    IN BOOL ImpersonateOnReturn,
    IN PVOID Reserved1,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Reserved2,
    IN DWORD Reserved3,
    IN PVOID Reserved4,
    OUT PVOID *pAuthzClientContext
    )
/*++

Routine Description:
    Gets an authorization context for the client that can be used
    with Authz functions. The resulting context is owned by the caller
    and must be freed by it.

Arguments:
    ImpersonateOnReturn - if TRUE, when we return, we should be impersonating.
    If the function fails, we're not impersonating
    Reserved1 - the resource manager to use (passed to Authz). Must be
    NULL for now
    pExpirationTime - the expiration time to use (passed to Authz)
    Reserved2 - the LUID (passed to Authz). Must be 0 for now.
    Resevred3 - Flags (passed to Authz). Must be 0 for now.
    Reserved4 - DynamicGroupArgs parameter required by Authz (passed to Authz)
    pAuthzClientContext - the authorization context, returned on success.
    Undefined on failure.

Return Values:
    RPC_S_OK for success, ERROR_INVALID_PARAMETER for non-null values for
    the Reserved parameters and RPC_S_* / Win32 errors for the rest

--*/
{
    SCALL * SCall;
    THREAD *Thread;
    RPC_STATUS Status;

    InitializeIfNecessary();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    if ((Reserved1 != NULL)
        || (Reserved2.HighPart != 0)
        || (Reserved2.LowPart != 0)
        || (Reserved3 != 0)
        || (Reserved4 != NULL))
        {
        return ERROR_INVALID_PARAMETER;
        }

    Status = InitializeAuthzSupportIfNecessary();
    if (Status != RPC_S_OK)
        return Status;

    Status = CreateDummyResourceManagerIfNecessary();
    if (Status != RPC_S_OK)
        return Status;

    if ( ClientBinding == 0 )
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if (SCall == 0)
            return(RPC_S_NO_CALL_ACTIVE);
        }
    else
        {
        SCall = (SCALL *) ClientBinding;
        if (SCall->InvalidHandle(SCALL_TYPE))
            return(RPC_S_INVALID_BINDING);
        }

    return(SCall->GetAuthorizationContext(ImpersonateOnReturn,
        DummyResourceManager,
        pExpirationTime,
        Reserved2,
        Reserved3,
        Reserved4,
        (PAUTHZ_CLIENT_CONTEXT_HANDLE)pAuthzClientContext));
}

RPC_STATUS RPC_ENTRY
RpcFreeAuthorizationContext (
    IN OUT PVOID *pAuthzClientContext
    )
/*++

Routine Description:
    Frees an authorization context obtained through
    RpcGetAuthorizationContextForClient

Arguments:
    pAuthzClientContext - a pointer to the authorization context to
    be freed. The function will zero-out the freed authorization context
    to prevent accidental re-use in the success case. The authorization
    context won't be touched in case of failure.

Return Values:
    RPC_S_OK for success, Win32 errors for the rest

--*/
{
    BOOL Result;

    Result = AuthzFreeContextFn((AUTHZ_CLIENT_CONTEXT_HANDLE)(*pAuthzClientContext));
    if (Result == FALSE)
        {
        return GetLastError();
        }
    else
        {
        *pAuthzClientContext = NULL;
        return RPC_S_OK;
        }
}


RPC_STATUS RPC_ENTRY
RpcRevertToSelfEx (
    IN RPC_BINDING_HANDLE ClientBinding OPTIONAL
    )
/*++

Routine Description:

Return Value:

--*/
{
    SCALL * SCall ;

    InitializeIfNecessary();

    ASSERT(!RpcpCheckHeap());

    if ( ClientBinding == 0 )
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if ( SCall == 0 )
            return(RPC_S_NO_CALL_ACTIVE);
        }
    else
        {
        SCall = (SCALL *) ClientBinding;
        if (SCall->InvalidHandle(SCALL_TYPE))
            return(RPC_S_INVALID_BINDING);

        }

    return(SCall->RevertToSelf());
}


RPC_STATUS RPC_ENTRY
RpcRevertToSelf (
    )
/*++

Routine Description:

Return Value:

--*/
{

    return(RpcRevertToSelfEx((RPC_BINDING_HANDLE) 0));

}


RPC_STATUS RPC_ENTRY
RpcMgmtSetServerStackSize (
    IN unsigned long ThreadStackSize
    )
/*++

Routine Description:

    An application will use this routine to specify the stack size for
    each of the threads created by the server to handle remote procedure
    calls.

Arguments:

    ThreadStackSize - Supplies the thread stack size in bytes.

Return Value:

    RPC_S_OK - Everybody is happy with the stack size.

    RPC_S_INVALID_ARG - The stack size is either too small, or too large.

--*/
{
    InitializeIfNecessary();

    return(SetThreadStackSize(ThreadStackSize));
}


RPC_STATUS RPC_ENTRY
I_RpcBindingIsClientLocal (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL,
    OUT unsigned int PAPI * ClientLocalFlag
    )
/*++

Routine Description:

    This routine exists for one reason: so that the security system can
    tell if a client is local or remote.  The client must be using named
    pipes to talk to the server.

Arguments:

    BindingHandle - Optionally supplies a client binding handle specifing
        which client we want to know if it is local or remote.  If this
        parameter is not supplied, then we will determine local/remote for
        the client which made call currently being handled by this server
        thread.

    ClientLocalFlag - Returns an indication of whether or not the client is
        local (ie. on the same machine as the server).  This field will be
        set to a non-zero value to indicate that the client is local;
        otherwise, the client is remote.

Return Value:

    RPC_S_OK - We successfully determined whether or not the client is
        local.

    RPC_S_NO_CALL_ACTIVE - There is no call active for this server thread.

    RPC_S_CANNOT_SUPPORT - Only the connection oriented protocol over named
        pipes can support this operation.  If the client is using something
        else, other than the connection oriented protocol, this will be
        returned.

    RPC_S_INVALID_BINDING - The binding argument does not supply a client
        binding handle.

--*/
{
    SCALL *SCall;

    InitializeIfNecessary();

    if ( BindingHandle == 0 )
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if ( SCall == 0 )
            {
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }
    else
        {
        SCall = (SCALL *) BindingHandle;
        if ( SCall->InvalidHandle(SCALL_TYPE) )
            {
            return(RPC_S_INVALID_BINDING);
            }
        }

    return(SCall->IsClientLocal(ClientLocalFlag));
}


RPC_STATUS RPC_ENTRY
RpcMgmtInqIfIds (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    )
/*++

Routine Description:

    This routine is used to obtain a vector of the interface identifiers of
    the interfaces supported by a server.

Arguments:

    Binding - Optionally supplies a binding handle to the server.  If this
        argument is not supplied, the local application is queried.

    IfIdVector - Returns a vector of the interfaces supported by the server.

Return Value:

    RPC_S_OK - Everything worked just fine, and you now know the interfaces
        supported by this server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_INVALID_BINDING - The supplied binding is not zero.

--*/
{
    RPC_STATUS Status;
    unsigned int Count;

    InitializeIfNecessary();

    if ( Binding == 0 )
        {
        return(GlobalRpcServer->InquireInterfaceIds(IfIdVector));
        }

    // if callers pass in memory, they open the possibility for buffer
    // overrun since this is out conformant structure. Prevent apps
    // from shooting themselves in the foot.
    *IfIdVector = NULL;

    _rpc_mgmt_inq_if_ids(Binding, (rpc_if_id_vector_p_t *) IfIdVector,
                        (unsigned long *) &Status);

    // do some basic consistency checks on the return vector.
    if (Status == RPC_S_OK)
        {
        if (*IfIdVector == NULL)
            {
            return RPC_S_PROTOCOL_ERROR;
            }

        // check that we weren't supplied non-zero count, but 0 pointer.
        if (((*IfIdVector)->Count > 0) && ((*IfIdVector)->IfId == NULL))
            {
            // RpcIfIdVectorFree is prepared to deal with this
            RpcIfIdVectorFree(IfIdVector);
            return RPC_S_PROTOCOL_ERROR;
            }

        // check that we are not returned sparse array. Technically this is valid
        // but chances are callers won't handle it.
        for (Count = 0; Count < (*IfIdVector)->Count; Count++)
            {
            if ( (*IfIdVector)->IfId[Count] == 0 )
                {
                // RpcIfIdVectorFree is prepared to deal with this
                RpcIfIdVectorFree(IfIdVector);
                return RPC_S_PROTOCOL_ERROR;                
                }
            }
        }

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcIfIdVectorFree (
    IN OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    )
/*++

Routine Description:

    This routine is used to free an interface id vector.

Arguments:

    IfIdVector - Supplies the interface id vector to be freed; on return
        this will be set to zero.

Return Value:

    RPC_S_OK - This will always be returned.

--*/
{
    unsigned int Count;

    InitializeIfNecessary();

    if (!*IfIdVector)
        {
        return(RPC_S_OK);
        }

    for (Count = 0; Count < (*IfIdVector)->Count; Count++)
        {
        if ( (*IfIdVector)->IfId[Count] != 0 )
            {
            RpcpFarFree((*IfIdVector)->IfId[Count]);
            }
        }
    RpcpFarFree(*IfIdVector);
    *IfIdVector = 0;
    return(RPC_S_OK);
}



// StringToUnicodeString lives in epmgmt.c
//
extern "C" RPC_CHAR *StringToWideCharString(unsigned char *, RPC_STATUS *);

#define SERVER_PRINC_NAME_SIZE 256

RPC_STATUS RPC_ENTRY
RpcMgmtInqServerPrincName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName
    )
/*++

Routine Description:


Arguments:

    Binding - Supplies

    AuthnSvc - Supplies

    ServerPrincName - Returns


Return Value:

    RPC_S_OK - Everything worked just fine, and you now know the interfaces
        supported by this server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_INVALID_BINDING - The supplied binding is not zero.

--*/
{
    RPC_STATUS Status;
    unsigned char *AnsiPrincName;
    THREAD *Thread;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    if ( Binding == 0 )
        {
        return(GlobalRpcServer->InquirePrincipalName(AuthnSvc, ServerPrincName));
        }

    AnsiPrincName = new unsigned char[SERVER_PRINC_NAME_SIZE + 1];
    if (AnsiPrincName == 0)
        return(RPC_S_OUT_OF_MEMORY);

    _rpc_mgmt_inq_princ_name(Binding, AuthnSvc, SERVER_PRINC_NAME_SIZE,
                AnsiPrincName, (unsigned long *)&Status);

    *ServerPrincName = 0;

    if ( Status == RPC_S_OK )
        {

        Status = A2WAttachHelper((char *)AnsiPrincName, ServerPrincName);

        if (Status != RPC_S_OK)
            {
            delete AnsiPrincName;
            ASSERT(Status == RPC_S_OUT_OF_MEMORY);
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    delete AnsiPrincName;

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcServerInqDefaultPrincName (
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * PrincName
    )
/*++

Routine Description:


Arguments:

    PrincName - Returns


Return Value:

    RPC_S_OK - Everything worked just fine, and you now know the interfaces
        supported by this server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    SECURITY_CREDENTIALS *pCredentials;
    SEC_CHAR * DefaultPrincName = NULL;
    RPC_CHAR *CopyPrincName;

    InitializeIfNecessary();

    Status = FindServerCredentials(
                NULL,
                NULL,
                AuthnSvc,
                0,
                NULL,
                &pCredentials
                );

    if (Status != RPC_S_OK) {
        return (Status);
    }

    Status = pCredentials->InquireDefaultPrincName(&DefaultPrincName);

    if (Status != RPC_S_OK) {

        pCredentials->DereferenceCredentials();
        return (Status);
    }

    ASSERT(DefaultPrincName);

    CopyPrincName = DuplicateString((RPC_CHAR *)DefaultPrincName);

    pCredentials->DereferenceCredentials();

    if (CopyPrincName == 0)
        return(RPC_S_OUT_OF_MEMORY);

    *PrincName = CopyPrincName;

    return (RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerInqDefaultPrincName) (
    IN unsigned long AuthnSvc,
    OUT THUNK_CHAR **PrincName
    )
{
    RPC_STATUS  RpcStatus;
        USES_CONVERSION;
        COutDelThunk thunkedPrincName;

    RpcStatus = RpcServerInqDefaultPrincName(AuthnSvc,
                                              thunkedPrincName);

    if (RpcStatus != RPC_S_OK)
                {
        return(RpcStatus);
                }

        ATTEMPT_OUT_THUNK(thunkedPrincName, PrincName);

    return (RpcStatus);
}


RPC_STATUS RPC_ENTRY
RpcBindingServerFromClient (
    IN RPC_BINDING_HANDLE ClientBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    )
/*++

Routine Description:

    This routine is used by a server application to convert a client binding
    handle (server side binding handle) into a partially bound server binding
    handle (client side binding handle).

Arguments:

    ClientBinding - Supplies a client binding.

    ServerBinding - Returns a partially bound server binding handle which
        can be used to get back to the client.

Return Values:

    RPC_S_OK - The client binding handle has been successfully converted into
        a server binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete this
        operation.

    RPC_S_CANNOT_SUPPORT - The requested operation can not be supported.

    RPC_S_INVALID_BINDING - The supplied client binding is invalid.

    RPC_S_WRONG_KIND_OF_BINDING - The supplied client binding is not a
        client binding.

--*/
{
    GENERIC_OBJECT * SCall;
    THREAD *Thread;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    if (ARGUMENT_PRESENT(ClientBinding))
        {
        SCall = (GENERIC_OBJECT *) ClientBinding;
        if (SCall->InvalidHandle(CALL_TYPE | BINDING_HANDLE_TYPE))
            {
            *ServerBinding = 0;
            return(RPC_S_INVALID_BINDING);
            }

        if (SCall->InvalidHandle(SCALL_TYPE))
            {
            *ServerBinding = 0;
            return(RPC_S_WRONG_KIND_OF_BINDING);
            }
        }
    else
        {
        SCall = (GENERIC_OBJECT *) RpcpGetThreadContext();
        if ( SCall == 0 )
            {
            *ServerBinding = 0;
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }

    return(((SCALL *) SCall)->ConvertToServerBinding(ServerBinding));
}


RPC_STATUS RPC_ENTRY
I_RpcServerRegisterForwardFunction(
    IN RPC_FORWARD_FUNCTION __RPC_FAR * pForwardFunction
    )

/*++

Routine Description:
    Allows Epmapper to register a function with the runtime
    to allow the runtime to determine the 'forwarding' endpoint
    (that is the local endpoint the server must forward the
    currently received packet to).

Return Value:

--*/
{

    InitializeIfNecessary();

    GlobalRpcServer->RegisterRpcForwardFunction(pForwardFunction);

    return RPC_S_OK;
}

RPC_ADDRESS_CHANGE_FN * gAddressChangeFn = 0;

RPC_ADDRESS_CHANGE_FN * RPC_ENTRY
I_RpcServerInqAddressChangeFn()
{
    return gAddressChangeFn;
}

RPC_STATUS RPC_ENTRY
I_RpcServerSetAddressChangeFn(
    IN RPC_ADDRESS_CHANGE_FN * pAddressChangeFn
    )
{
    gAddressChangeFn = pAddressChangeFn;
    return RPC_S_OK;
}

RPC_STATUS
RPC_ENTRY
I_RpcServerInqLocalConnAddress (
    IN RPC_BINDING_HANDLE Binding,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    This routine is used by a server application to inquire about the local
    address on which a call is made.

Arguments:

    Binding - Supplies a valid server binding (SCALL).

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6. Undefined on failure.

Return Values:

    RPC_S_OK - success.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete this
        operation.

    RPC_S_INVALID_BINDING - The supplied client binding is invalid.

    RPC_S_CANNOT_SUPPORT - The local address was inquired for a protocol
        sequence that doesn't support this type of functionality. Currently
        only ncacn_ip_tcp supports it.

    RPC_S_* or Win32 error for other errors
--*/
{
    SCALL *SCall;
    THREAD *Thread;
    RPC_STATUS Status;

    InitializeIfNecessary();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    if ( Binding == 0 )
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if (SCall == 0)
            return(RPC_S_NO_CALL_ACTIVE);
        }
    else
        {
        SCall = (SCALL *) Binding;
        if (SCall->InvalidHandle(SCALL_TYPE))
            return(RPC_S_INVALID_BINDING);
        }

    return InqLocalConnAddress(
        SCall,
        Buffer,
        BufferSize,
        AddressFormat);
}

RPC_STATUS RPC_ENTRY
I_RpcServerUnregisterEndpoint (
    IN RPC_CHAR * Protseq,
    IN RPC_CHAR * Endpoint
    )
{
    InitializeIfNecessary();

    return GlobalRpcServer->UnregisterEndpoint(Protseq, Endpoint);
}

RPC_STATUS
RPC_ENTRY
I_RpcServerTurnOnOffKeepalives (
    IN RPC_BINDING_HANDLE Binding OPTIONAL,
    IN BOOL TurnOn,
    IN ULONG Time,
    IN ULONG Interval
    )
/*++

Routine Description:

    A server application will use this routine to set the comminucation timeout
    for the connection for the current call.  This works for ncacn_ip_tcp only.
    The transport layer will issue keepalive packets to monitor the connection,
    so care must be taken when setting this.

Arguments:

    Binding - Optionally supplies a binding handle on the server
        side which indicates for which remote procedure call we wish to
        set the timeout.  If no binding handle is supplied, then the
        remote procedure call currently being handled by this server thread is used.
    TurnOn - If non-zero the keepalives will be turned on.  Must be non-zero.
    Time - The length in milliseconds between the last keep alive
        response and the next probe.
    Interval - The keepalive interval in milliseconds between
        two consequitive keep alive probes if the first one
        did not receive a response.

Return Value:

    RPC_S_OK for success of RPC_S_* /Win32 error code for error.

--*/
{
    SCALL * SCall;

    InitializeIfNecessary();

    if (!TurnOn)
        {
        return(RPC_S_CANNOT_SUPPORT);
        }

    if (ARGUMENT_PRESENT(Binding))
        {
        SCall = (SCALL *) Binding;
        if (SCall->InvalidHandle(SCALL_TYPE))
            {
            return(RPC_S_INVALID_BINDING);
            }
        }
    else
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if ( SCall == 0 )
            {
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }
    return SCall->TurnOnOffKeepAlives (TurnOn, Time, Interval);
}

// declare it as pure C so that it gets exported properly
extern "C"
{

RPC_STATUS
RPC_ENTRY
I_RpcServerIsClientDisconnected (
    IN RPC_BINDING_HANDLE Binding OPTIONAL,
    OUT BOOL *ClientIsDisconnected
    );

};

RPC_STATUS
RPC_ENTRY
I_RpcServerIsClientDisconnected (
    IN RPC_BINDING_HANDLE Binding OPTIONAL,
    OUT BOOL *ClientIsDisconnected
    )
/*++

Routine Description:

    Checks whether the client for the given call has disconnected. This is
        supported only for ncalrpc and ncacn* protocol sequences. It is not
        supported for ncadg* protocol sequences.

Arguments:

    Binding - Optionally supplies a binding handle on the server
        side which indicates for which remote procedure call we wish to
        set the timeout.  If no binding handle is supplied, then the
        remote procedure call currently being handled by this server thread is used.
    ClientIsDisconnected - on output it will contain non-zero if the client is
        disconnected. If the client is still connected, it will contain 0.
        Undefined on failure.

Return Value:

    RPC_S_OK for success of RPC_S_CANNOT_SUPPORT. This API cannot fail if called
        with valid arguments and within the context of an RPC call.

Note:

    If called on async RPC calls, it is the obligation of the caller to make sure that
        the call is not completed while this API is in progress.

--*/
{
    SCALL * SCall;

    InitializeIfNecessary();

    if (ARGUMENT_PRESENT(Binding))
        {
        SCall = (SCALL *) Binding;
        }
    else
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if ( SCall == 0 )
            {
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }

    if (SCall->InvalidHandle(OSF_SCALL_TYPE | LRPC_SCALL_TYPE))
        {
        return(RPC_S_INVALID_BINDING);
        }

    SCall->IsClientDisconnected (ClientIsDisconnected);

    return RPC_S_OK;
}

int
InitializeRpcServer (
    )
/*++

Routine Description:

    This routine will be called once at DLL initialization time.  We
    have got to create and initialize the server.  This will get it
    all ready to hang protocol sequences (addresses) and interfaces
    from.

Return Value:

    Zero will be returned if everything is initialized correctly;
    otherwise, non-zero will be returned.

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    if (GlobalRpcServer == NULL)
        {
        GlobalRpcServer = new RPC_SERVER(&RpcStatus);
        if ( GlobalRpcServer == NULL )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        else if (RpcStatus != RPC_S_OK)
            {
            delete GlobalRpcServer;
            GlobalRpcServer = NULL;
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    if (SIDCache == NULL)
        {
        SIDCache = new SID_CACHE(&RpcStatus);
        if (SIDCache == NULL)
            {
            return RPC_S_OUT_OF_MEMORY;
            delete GlobalRpcServer;
            GlobalRpcServer = NULL;
            }
        else if (RpcStatus != RPC_S_OK)
            {
            delete GlobalRpcServer;
            GlobalRpcServer = NULL;
            delete SIDCache;
            SIDCache = NULL;
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    GroupIdCounter = GetTickCount();

    // If we can't create the global management interface
    // don't worry about it; it probably won't be used anyway.
    // When it is used, it should be checked for NULL.

    if (GlobalManagementInterface == NULL)
        {
        // We should not expect to have more then RPC_C_PROTSEQ_MAX_REQS_DEFAULT
        // simultaneous calls on this interface.  The calls do not receive more then 10K.
        GlobalManagementInterface = new RPC_INTERFACE(
            (RPC_SERVER_INTERFACE *)mgmt_ServerIfHandle,
            GlobalRpcServer, 0, MAX_IF_CALLS, mgmt_MaxRpcSize, 0, &RpcStatus);

        if ( GlobalManagementInterface == NULL )
            {
            return(RPC_S_OUT_OF_MEMORY);
	    }
        else if (RpcStatus != RPC_S_OK)
            {
            delete GlobalManagementInterface;
            GlobalManagementInterface = NULL;
            return(RPC_S_OUT_OF_MEMORY);
            }

        GlobalManagementInterface->RegisterTypeManager(0,
            ((RPC_SERVER_INTERFACE *)mgmt_ServerIfHandle)->DefaultManagerEpv);
        }

    return(RpcStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dceuuid.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    dceuuid.cxx

Abstract:

    This module contains the entry points for routines dealing with
    UUIDs.  In particular, UuidCreate lives here.

Author:

    Michael Montague (mikemon) 16-Jan-1992

Revision History:

    Dave Steckler (davidst) 31-Mar-1992
        If NT, remote call to UuidGetValues.

    Mario Goertzel (mariogo) 1-May-1994
        Added the rest of the DCE UUID APIs

    Mario Goertzel (mariogo) 18-May-1994
        Changed algorithm and implementation.  No longer based on RPC.
        Platform specific functions in uuidsup.cxx (win32) and
        dos\uuid16 (dos/win16).

--*/


#include <precomp.hxx>
#include <uuidsup.hxx>
#include <rc4.h>
#include <randlib.h>
#include <crypt.h>

// Contain a cached block of uuids to reduce the
// average cost of creating a uuid.

UUID_CACHED_VALUES_STRUCT  UuidCachedValues;

#define CACHE_VALID      1
#define CACHE_LOCAL_ONLY 2  // -> CACHE_VALID
static unsigned char UuidCacheValid = CACHE_LOCAL_ONLY;


RPC_STATUS RPC_ENTRY
I_UuidCreate(
    OUT UUID PAPI * Uuid
    )
/*++
    Historically this function was used for cheap sometimes unique
    uuid's for context handles and such.  Now it's just a wrapper
    for UuidCreate.
--*/
{
    RPC_STATUS Status = UuidCreateSequential (Uuid);
    if (Status == RPC_S_UUID_LOCAL_ONLY)
        return(RPC_S_OK);

    return(Status);
}


#define RC4_REKEY_PARAM (500000)
extern void *g_rc4SafeCtx;

RPC_STATUS GenerateRandomNumber(unsigned char *Buffer, int BufferSize)
{
    unsigned int KeyEntry;
    unsigned int KeyBytesUsed = 0;

    rc4_safe_select(g_rc4SafeCtx, &KeyEntry, &KeyBytesUsed);

    if (KeyBytesUsed >= RC4_REKEY_PARAM)
        {
        BYTE newSeed[256];

        if (!RtlGenRandom (newSeed, sizeof(newSeed)))
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        rc4_safe_key(g_rc4SafeCtx, KeyEntry, sizeof(newSeed), newSeed);
        }

    // the rc4_safe fucntion is thread safe
    rc4_safe(g_rc4SafeCtx, KeyEntry, BufferSize, Buffer);

    return RPC_S_OK;
}


RPC_STATUS RPC_ENTRY
UuidCreate (
    OUT UUID PAPI * Uuid
    )
{
    RPC_STATUS RpcStatus;
    RPC_UUID_GENERATE PAPI * RpcUuid = (RPC_UUID_GENERATE PAPI *) Uuid;

    RpcStatus = GenerateRandomNumber((unsigned char *)Uuid, 16);
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    // Overwriting some bits of the uuid
    RpcUuid->TimeHiAndVersion =
        (RpcUuid->TimeHiAndVersion & RPC_UUID_TIME_HIGH_MASK) | RPC_RAND_UUID_VERSION;
    RpcUuid->ClockSeqHiAndReserved =
        (RpcUuid->ClockSeqHiAndReserved & RPC_UUID_CLOCK_SEQ_HI_MASK) | RPC_UUID_RESERVED;

    return RPC_S_OK;
}

#define MAX_CACHED_UUID_TIME 10000  // 10 seconds


RPC_STATUS RPC_ENTRY
UuidCreateSequential (
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    This routine will create a new UUID (or GUID) which is unique in
    time and space.  We will try to guarantee that the UUID (or GUID)
    we generate is unique in time and space.  This means that this
    routine may fail if we can not generate one which we can guarantee
    is unique in time and space.

Arguments:

    Uuid - Returns the generated UUID (or GUID).

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_UUID_NO_ADDRESS - We were unable to obtain the ethernet or
        token ring address for this machine.

    RPC_S_UUID_LOCAL_ONLY - On NT & Chicago if we can't get a
        network address.  This is a warning to the user, the
        UUID is still valid, it just may not be unique on other machines.

    RPC_S_OUT_OF_MEMORY - Returned as needed.
--*/
{
    RPC_UUID_GENERATE PAPI * RpcUuid = (RPC_UUID_GENERATE PAPI *) Uuid;
    RPC_STATUS Status = RPC_S_OK;
    static DWORD LastTickCount = 0;

    InitializeIfNecessary();

    if (GetTickCount()-LastTickCount > MAX_CACHED_UUID_TIME)
        {
        UuidCachedValues.AllocatedCount = 0;
        LastTickCount = GetTickCount();
        }

    ULARGE_INTEGER Time;
    long Delta;

    for(;;)
        {
        Time.QuadPart = UuidCachedValues.Time.QuadPart;

        // Copy the static info into the UUID.  We can't do this later
        // because the clock sequence could be updated by another thread.

        *(unsigned long *)&RpcUuid->ClockSeqHiAndReserved =
            *(unsigned long *)&UuidCachedValues.ClockSeqHiAndReserved;
        *(unsigned long *)&RpcUuid->NodeId[2] =
            *(unsigned long *)&UuidCachedValues.NodeId[2];

        Delta = InterlockedDecrement(&UuidCachedValues.AllocatedCount);

        if (Time.QuadPart != UuidCachedValues.Time.QuadPart)
            {
            // If our captured time doesn't match the cache then another
            // thread already took the lock and updated the cache. We'll
            // just loop and try again.
            continue;
            }

        if (Delta >= 0)
            {
            break;
            }

        //
        // Allocate block of Uuids.
        //

        Status = UuidGetValues( &UuidCachedValues );
        if (Status == RPC_S_OK)
            {
            UuidCacheValid = CACHE_VALID;
            }
        else
            {
            UuidCacheValid = CACHE_LOCAL_ONLY;
            }

        if (Status != RPC_S_OK
            && Status != RPC_S_UUID_LOCAL_ONLY)
            {
#ifdef DEBUGRPC
            if (Status != RPC_S_OUT_OF_MEMORY)
                PrintToDebugger("RPC: UuidGetValues returned or raised: %x\n", Status);
#endif
            ASSERT( (Status == RPC_S_OUT_OF_MEMORY) );


            return Status;
            }

        // Loop
        }


    Time.QuadPart -= Delta;

    RpcUuid->TimeLow = (unsigned long) Time.LowPart;
    RpcUuid->TimeMid = (unsigned short) (Time.HighPart & 0x0000FFFF);
    RpcUuid->TimeHiAndVersion = (unsigned short)
        (( (unsigned short)(Time.HighPart >> 16)
        & RPC_UUID_TIME_HIGH_MASK) | RPC_UUID_VERSION);

    ASSERT(   Status == RPC_S_OK
           || Status == RPC_S_UUID_LOCAL_ONLY);

    if (UuidCacheValid == CACHE_LOCAL_ONLY)
        {
        return RPC_S_UUID_LOCAL_ONLY;
        }

    return(Status);
}

RPC_STATUS RPC_ENTRY
UuidToString (
    IN UUID PAPI * Uuid,
    OUT unsigned short PAPI * PAPI * StringUuid
    )
/*++

Routine Description:

    This routine converts a UUID into its string representation.

Arguments:

    Uuid - Supplies the UUID to be converted into string representation.

    StringUuid - Returns the string representation of the UUID.  The
        runtime will allocate the string.  The caller is responsible for
        freeing the string using RpcStringFree.

Return Value:

    RPC_S_OK - We successfully converted the UUID into its string
        representation.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        a string.

--*/
{
    RPC_CHAR PAPI * String;

    InitializeIfNecessary();

    // The string representation of a UUID is always 36 character long,
    // and we need one more for the terminating zero.

    *StringUuid = (RPC_CHAR PAPI *) RpcpFarAllocate(sizeof(RPC_CHAR) * 37);
    if ( *StringUuid == 0 )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }
    String = ((RPC_UUID PAPI *) Uuid)->ConvertToString(*StringUuid);
    *String = 0;

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
UuidFromString (
    IN unsigned short PAPI * StringUuid OPTIONAL,
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    We convert a UUID from its string representation into the binary
    representation.

Arguments:

    StringUuid - Optionally supplies the string representation of the UUID;
        if the string is not supplied, then the Uuid is set to the NIL UUID.

    Uuid - Returns the binary representation of the UUID.

Return Value:

    RPC_S_OK - The string representation was successfully converted into
        the binary representation.

    RPC_S_INVALID_STRING_UUID - The supplied string UUID is not correct.

--*/
{
    RPC_UUID RpcUuid;

    if ( StringUuid == 0 )
        {
        ((RPC_UUID PAPI *) Uuid)->SetToNullUuid();
        return(RPC_S_OK);
        }

    if ( RpcUuid.ConvertFromString(StringUuid) != 0)
        {
        return(RPC_S_INVALID_STRING_UUID);
        }
    ((RPC_UUID PAPI *) Uuid)->CopyUuid(&RpcUuid);
    return(RPC_S_OK);
}


signed int RPC_ENTRY
UuidCompare (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    )
/*++

Routine Description:

    The supplied uuids are compared and their order is determined.

Arguments:

    Uuid1, Uuid2 - Supplies the uuids to be compared.  A value of NULL can
        be supplied to indicate the nil uuid.

    Status - The status of the function.  Currently always RPC_S_OK.

Return Value:

    Returns the result of the comparison.  Negative one (-1) will be returned
    if Uuid1 precedes Uuid2 in order, zero will be returned if Uuid1 is equal
    to Uuid2, and positive one (1) will be returned if Uuid1 follows Uuid2 in
    order.  A nil uuid is the first uuid in order.

Note:

    The algorithm for comparing uuids is specified by the DCE RPC Architecture.

--*/
{
    int Uuid1Nil, Uuid2Nil;
    RPC_STATUS RpcStatus;

    Uuid1Nil = UuidIsNil(Uuid1, &RpcStatus);
    ASSERT(RpcStatus == RPC_S_OK);

    Uuid2Nil = UuidIsNil(Uuid2, &RpcStatus);
    ASSERT(RpcStatus == RPC_S_OK);

    *Status = RPC_S_OK;

    if ( Uuid1Nil != 0 )
        {
        // Uuid1 is the nil uuid.

        if ( Uuid2Nil != 0 )
            {
            // Uuid2 is the nil uuid.

            return(0);
            }
        else
            {
            return(-1);
            }
        }
    else if ( Uuid2Nil != 0 )
        {
        // Uuid2 is the nil uuid.

        return(1);
        }
    else
        {
        if ( Uuid1->Data1 == Uuid2->Data1 )
            {
            if ( Uuid1->Data2 == Uuid2->Data2 )
                {
                if ( Uuid1->Data3 == Uuid2->Data3 )
                    {
                    int compare = RpcpMemoryCompare(&Uuid1->Data4[0],
                                                    &Uuid2->Data4[0],
                                                    8);
                    if (compare > 0)
                        {
                        return(1);
                        }
                    else if (compare < 0 )
                        {
                        return(-1);
                        }
                    return(0);
                    }
                else if ( Uuid1->Data3 > Uuid2->Data3 )
                    {
                    return(1);
                    }
                else
                    {
                    return(-1);
                    }
                }
            else if ( Uuid1->Data2 > Uuid2->Data2 )
                {
                return(1);
                }
            else
                {
                return(-1);
                }
            }
        else if ( Uuid1->Data1 > Uuid2->Data1 )
            {
            return(1);
            }
        else
            {
            return(-1);
            }
        }

    ASSERT(!"This is not reached");
    return(1);
}


RPC_STATUS RPC_ENTRY
UuidCreateNil (
    OUT UUID __RPC_FAR * NilUuid
    )
/*++

Arguments:

    NilUuid - Returns a nil uuid.

--*/
{
    ((RPC_UUID __RPC_FAR *)NilUuid)->SetToNullUuid();

    return(RPC_S_OK);
}


int RPC_ENTRY
UuidEqual (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    )
/*++

Routine Description:

    This routine is used to determine if two uuids are equal.

Arguments:

    Uuid1, Uuid2 - Supplies the uuids to compared for equality.  A value of
        NULL can be supplied to indicate the nil uuid.

    Status - Will always be set to RPC_S_OK.

Return Value:

    Returns non-zero if Uuid1 equals Uuid2; otherwise, zero will be
        returned.

--*/
{
    *Status = RPC_S_OK;

    if (Uuid1 == 0)
        {
        if (    (Uuid2 == 0)
            ||  ((RPC_UUID __RPC_FAR *)Uuid2)->IsNullUuid())
            {
            return 1;
            }
        return 0;
        }

    if (Uuid2 == 0)
        {
        if (((RPC_UUID __RPC_FAR *)Uuid1)->IsNullUuid())
            {
            return 1;
            }
        return 0;
        }

    return( ((RPC_UUID __RPC_FAR *)Uuid1)->MatchUuid(
                 (RPC_UUID __RPC_FAR *)Uuid2)
             == 0 );
}


unsigned short RPC_ENTRY
UuidHash (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    )
/*++

Routine Description:

    An application will use this routine to create a hash value for a uuid.

Arguments:

    Uuid - Supplies the uuid for which we want to create a hash value.  A
        value of NULL can be supplied to indicate the nil uuid.

    Status - Will always be set to RPC_S_OK.

Return Value:

    Returns the hash value.

--*/
{
    *Status = RPC_S_OK;

    if ( Uuid == 0 )
        {
        return(0);
        }

    return( ((RPC_UUID __RPC_FAR *)Uuid)->HashUuid() );
}


int RPC_ENTRY
UuidIsNil (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    )
/*++

Routine Description:

    We will determine if the supplied uuid is the nil uuid or not.

Arguments:

    Uuid - Supplies the uuid to check.  A value of NULL indicates the nil
        uuid.

    Status - This will always be RPC_S_OK.

Return Value:

    Returns non-zero if the supplied uuid is the nil uuid; otherwise, zero
    will be returned.

--*/
{
    *Status = RPC_S_OK;

    if ( Uuid == 0 )
        {
        return(1);
        }

    return ( ((RPC_UUID __RPC_FAR *) Uuid)->IsNullUuid() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\delaytab.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       delaytab.cxx
//
//--------------------------------------------------------------------------

/*++

Module Name:

    delaytab.cxx

Abstract:

    interface for DELAYED_ACTION_TABLE, which asynchronously calls
    functions after a specified delay.

Author:

    Jeff Roberts (jroberts)  2-Nov-1994

Revision History:

     2-Nov-1994     jroberts

        Created this module.

--*/

#include <precomp.hxx>
#include "delaytab.hxx"

#include "rpcuuid.hxx"
#include "sdict.hxx"
#include "binding.hxx"
#include "handle.hxx"
#include "rpcssp.h"
#include "secclnt.hxx"
#include "hndlsvr.hxx"



inline unsigned long
CurrentTimeInMsec(
     void
     )
{
    return GetTickCount();
}


BOOL
DelayedActionThread(
    LPVOID  Parms
    )

/*++

Routine Description:

    This is a thread proc for the delayed call table.

Arguments:

    Parms - address of table

Return Value:

    FALSE - thread should be returned to the the cache.

--*/
{
    DELAYED_ACTION_TABLE * pTable = (DELAYED_ACTION_TABLE *) Parms;

    pTable->ThreadProc();

    return FALSE;
}


void
DELAYED_ACTION_TABLE::ThreadProc()
{
/*++

Routine Description:

    This thread takes requests off the delayed-action list and processes them.
    After 15 seconds of inactivity, this thread terminates.

Arguments:

    none

Return Value:

    none

--*/

    BOOL     EmptyList = FALSE;
    long     CurrentTime;
    long     WaitTime;

    DELAYED_ACTION_NODE Copy;
    DELAYED_ACTION_NODE * pNode;

    //
    // Disabling the event priority boost has the benefit of allowing a thread
    // who posts a request to continue processing afterwards.  This should
    // improve locality of reference, since this thread will not preempt
    // the poster.
    //
    if (FALSE == SetThreadPriorityBoost(GetCurrentThread(), TRUE))
        {
#ifdef DEBUGRPC
        DbgPrint("RPC DG: SetThreadPriorityBoost failed with %lu\n", GetLastError());
#endif
        }

    do
        {
        DELAYED_ACTION_FN pFn;
        void * pData;

        Mutex.Request();

#ifdef DEBUGRPC
        {
        unsigned ObservedCount = 0;
        DELAYED_ACTION_NODE * Scan = ActiveList.Next;
        while (Scan != &ActiveList)
            {
            ++ObservedCount;
            Scan = Scan->Next;
            }

        if (ObservedCount != NodeCount)
            {
            PrintToDebugger("RPC DG: delay thread sees %lu nodes but there should be %lu\n", ObservedCount, NodeCount);
            RpcpBreakPoint();
            }
        }
#endif

        pNode = ActiveList.Next;
        if (pNode != &ActiveList)
            {
            ASSERT(pNode->TriggerTime != DELAYED_ACTION_NODE::DA_NodeFree);

            EmptyList = FALSE;

            CurrentTime = CurrentTimeInMsec();
            if (pNode->TriggerTime - CurrentTime > 0)
                {
                WaitTime = pNode->TriggerTime - CurrentTime;
                }
            else
                {
                WaitTime = 0;

                pFn   = pNode->Fn;
                pData = pNode->Data;

                Cancel(pNode);
                }
            }
        else
            {
            CurrentTime = CurrentTimeInMsec();

            if (!EmptyList)
                {
                WaitTime = 15000UL;
                EmptyList = TRUE;
                }
            else
                {
                ThreadActive = FALSE;
                Mutex.Clear();
                break;
                }
            }

        ThreadWakeupTime = CurrentTime + WaitTime;

        Mutex.Clear();

        if (WaitTime)
            {
            ThreadEvent.Wait(WaitTime);
            }
        else
            {
            (*pFn)(pData);
            }
        }
    while ( !fExitThread );
}


DELAYED_ACTION_TABLE::DELAYED_ACTION_TABLE(
    RPC_STATUS * pStatus
    )
/*++

Routine Description:

    constructor for the delayed-action table.  Initially no thread is created.

Arguments:

    pStatus - if an error occurs, this will be filled in

Return Value:

    none

--*/

    : Mutex(pStatus),
      ThreadEvent(pStatus, 0),
      ActiveList(0, 0),
      fExitThread(0),
      ThreadActive(FALSE)
{
    fConstructorFinished = FALSE;

    if (*pStatus != RPC_S_OK)
        {
        return;
        }

    ActiveList.Next = &ActiveList;
    ActiveList.Prev = &ActiveList;

#ifdef DEBUGRPC

    LastAdded = 0;
    LastRemoved = 0;
    NodeCount = 0;

#endif

    fConstructorFinished = TRUE;
}


DELAYED_ACTION_TABLE::~DELAYED_ACTION_TABLE(
    )
/*++

Routine Description:

    Dsestructor for the delayed-action table.  It tells the associated thread
    to terminate, and waits until that happens.

Arguments:

    none

Return Value:

    none

--*/

{
    if (FALSE == fConstructorFinished)
        {
        return;
        }

    DELAYED_ACTION_NODE * pNode;

    fExitThread = 1;
    ThreadEvent.Raise();

    while (ActiveList.Next != &ActiveList)
        {
        Sleep(500);
        }
}


RPC_STATUS
DELAYED_ACTION_TABLE::Add(
    DELAYED_ACTION_NODE * pNode,
    unsigned Delay,
    BOOL ForceUpdate
    )
/*++

Routine Description:

    Adds a node to the table with the specified delay.  The action taken if
    the node is already in the list depends upon <ForceUpdate>: if FALSE,
    the old trigger time is kept; if TRUE, the new time is used and the node
    is moved in the list appropriately.

Arguments:

    pNode - the node

    Delay - delay time in milliseconds

    ForceUpdate - only used when pNode is already in the list (see text above)

Return Value:

    RPC_S_OK, or an error

--*/

{
    if (!ForceUpdate && pNode->IsActive())
        {
        return RPC_S_OK;
        }

    CLAIM_MUTEX Lock(Mutex);

    if (pNode->IsActive())
        {
        Cancel(pNode);
        }

    //
    // Add the node to the active list.
    //
    DELAYED_ACTION_NODE * pScan;

    pScan = ActiveList.Next;
    pNode->TriggerTime = Delay + CurrentTimeInMsec();

    long TriggerTime = pNode->TriggerTime;

    while (pScan != &ActiveList && pScan->TriggerTime - TriggerTime < 0)
        {
        ASSERT(pScan->IsActive());
        ASSERT(pScan != pNode);

        pScan = pScan->Next;
        }

    pNode->Next = pScan;
    pNode->Prev = pScan->Prev;

    pNode->Next->Prev = pNode;
    pNode->Prev->Next = pNode;

#ifdef DEBUGRPC
    ++NodeCount;
    LastAdded = pNode;
#endif

    if (!ThreadActive)
        {
        fExitThread = FALSE;

        RPC_STATUS Status = GlobalRpcServer->CreateThread(DelayedActionThread, this);
        if (Status)
            {
            return Status;
            }

        ThreadActive = TRUE;
        }
    else if (ActiveList.Next == pNode && TriggerTime - ThreadWakeupTime < 0)
        {
        ThreadEvent.Raise();
        }

    return RPC_S_OK;
}


BOOL
DELAYED_ACTION_TABLE::SearchForNode(
    DELAYED_ACTION_NODE * pNode
    )
/*++

Routine Description:

    Finds the node in the table.

Arguments:



Return Value:

    TRUE if pNode is in the table
    FALSE if not

--*/

{
    CLAIM_MUTEX Lock(Mutex);

    //
    // Search for node in active list.
    //
    DELAYED_ACTION_NODE * pScan;

    pScan = ActiveList.Next;
    while (pScan != &ActiveList && pScan != pNode)
        {
        pScan = pScan->Next;
        }

    if (pScan)
        {
        return TRUE;
        }
    else
        {
        return FALSE;
        }
}


void
DELAYED_ACTION_TABLE::QueueLength(
    unsigned * pTotalCount,
    unsigned * pOverdueCount
    )
/*++

Routine Description:

    Determines the number of active entries and the number of entries
    that are late.

Arguments:



Return Value:

    none

--*/

{
    CLAIM_MUTEX Lock(Mutex);

    DELAYED_ACTION_NODE * pScan = ActiveList.Next;
    unsigned Count = 0;
    long CurrentTime = GetTickCount();

    while (pScan != &ActiveList && CurrentTime - pScan->TriggerTime > 0)
        {
        ++Count;
        pScan = pScan->Next;
        }

    *pOverdueCount = Count;

    while (pScan != &ActiveList)
        {
        ++Count;
        pScan = pScan->Next;
        }

    *pTotalCount = Count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dcethunk.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    dceansi.cxx


Abstract:

    This file contains the ansi (as opposed to unicode) versions of the
    runtime APIs.  All of these APIs simply do conversions between ansi
    and unicode, and then call a unicode version of the API to do the
    work.

Author:

    Michael Montague (mikemon) 18-Dec-1991

Revision History:

--*/

#include <precomp.hxx>
#include <wincrypt.h>
#include <rpcssl.h>
#include <CharConv.hxx>


RPC_STATUS
AnsiToUnicodeString (
    IN unsigned char * String,
    OUT UNICODE_STRING * UnicodeString
    )
/*++

Routine Description:

    This helper routine is used to convert an ansi string into a unicode
    string.

Arguments:

    String - Supplies the ansi string (actually a zero terminated string)
        to convert into a unicode string.

    UnicodeString - Returns the unicode string.  This string will have
        to be freed using RtlFreeUnicodeString by the caller.

Return Value:

    RPC_S_OK - The ansi string was successfully converted into a unicode
        string.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available for the unicode
        string.

--*/
{
    NTSTATUS NtStatus;
    ANSI_STRING AnsiString;

    RtlInitAnsiString(&AnsiString,(PSZ) String);
    NtStatus = RtlAnsiStringToUnicodeString(UnicodeString,&AnsiString,TRUE);
    if (!NT_SUCCESS(NtStatus))
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}

unsigned char *
UnicodeToAnsiString (
    IN RPC_CHAR * WideCharString,
    OUT RPC_STATUS * RpcStatus
    )
/*++

Routine Description:

    This routine will convert a unicode string into an ansi string,
    including allocating memory for the ansi string.

Arguments:

    WideCharString - Supplies the unicode string to be converted into
        an ansi string.

    RpcStatus - Returns the status of the operation; this will be one
        of the following values.

        RPC_S_OK - The unicode string has successfully been converted
            into an ansi string.

        RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
            the ansi string.

Return Value:

    A pointer to the ansi string will be returned.

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    unsigned char * NewString;

    RtlInitUnicodeString(&UnicodeString,WideCharString);
    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,TRUE);
    if (!NT_SUCCESS(NtStatus))
        {
        *RpcStatus = RPC_S_OUT_OF_MEMORY;
        return(0);
        }

    NewString = new unsigned char[AnsiString.Length + 1];
    if (NewString == 0)
        {
        RtlFreeAnsiString(&AnsiString);
        *RpcStatus = RPC_S_OUT_OF_MEMORY;
        return(0);
        }

    memcpy(NewString,AnsiString.Buffer,AnsiString.Length + 1);
    RtlFreeAnsiString(&AnsiString);
    *RpcStatus = RPC_S_OK;
    return(NewString);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingFromStringBinding) (
    IN THUNK_CHAR *StringBinding,
    OUT RPC_BINDING_HANDLE PAPI * Binding
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcBindingFromStringBindingW.

Return Value:

    RPC_S_OUT_OF_MEMORY - This value will be returned if there is
        insufficient memory available to allocate the unicode string.

--*/
{
        USES_CONVERSION;
        RPC_STATUS RpcStatus;
        CHeapInThunk thunkStringBinding;

        ATTEMPT_HEAP_IN_THUNK(thunkStringBinding, StringBinding);

    RpcStatus = RpcBindingFromStringBinding(thunkStringBinding, Binding);

    return(RpcStatus);
}



RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingToStringBinding) (
    IN RPC_BINDING_HANDLE Binding,
    OUT THUNK_CHAR **StringBinding
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcBindingToStringBindingW.

Return Value:

    RPC_S_OUT_OF_MEMORY - We will return this value if we do not
        have enough memory to convert the unicode string binding
        into an ansi string binding.

--*/
{
    RPC_STATUS RpcStatus;
    COutDelThunk thunkStringBinding;
    USES_CONVERSION;

    RpcStatus = RpcBindingToStringBinding(Binding, thunkStringBinding);
    if (RpcStatus != RPC_S_OK)
        return(RpcStatus);

    ATTEMPT_OUT_THUNK(thunkStringBinding, StringBinding);

    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcStringBindingCompose) (
    IN THUNK_CHAR *ObjUuid OPTIONAL,
    IN THUNK_CHAR *Protseq OPTIONAL,
    IN THUNK_CHAR *NetworkAddr OPTIONAL,
    IN THUNK_CHAR *Endpoint OPTIONAL,
    IN THUNK_CHAR *Options OPTIONAL,
    OUT THUNK_CHAR **StringBinding OPTIONAL
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcStringBindingComposeW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available to
        convert unicode string into ansi strings (and back again),
        we will return this value.

--*/
{
    USES_CONVERSION;
    CHeapInThunk thunkedObjUuid;
    CStackInThunk thunkedProtseq;
    CHeapInThunk thunkedNetworkAddr;
    CHeapInThunk thunkedEndpoint;
    CHeapInThunk thunkedOptions;
    COutDelThunk thunkedStringBinding;
    RPC_STATUS RpcStatus;

    ATTEMPT_HEAP_IN_THUNK_OPTIONAL(thunkedObjUuid, ObjUuid);
    ATTEMPT_STACK_IN_THUNK_OPTIONAL(thunkedProtseq, Protseq);
    ATTEMPT_HEAP_IN_THUNK_OPTIONAL(thunkedNetworkAddr, NetworkAddr);
    ATTEMPT_HEAP_IN_THUNK_OPTIONAL(thunkedEndpoint, Endpoint);
    ATTEMPT_HEAP_IN_THUNK_OPTIONAL(thunkedOptions, Options);

    RpcStatus = RpcStringBindingCompose(thunkedObjUuid, thunkedProtseq,
            thunkedNetworkAddr, thunkedEndpoint, thunkedOptions,
            thunkedStringBinding);

    if (RpcStatus != RPC_S_OK)
        return(RpcStatus);

    if (ARGUMENT_PRESENT(StringBinding))
        {
        ATTEMPT_OUT_THUNK(thunkedStringBinding, StringBinding);
        }
    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcStringBindingParse) (
    IN THUNK_CHAR * StringBinding,
    OUT THUNK_CHAR **ObjUuid OPTIONAL,
    OUT THUNK_CHAR **Protseq OPTIONAL,
    OUT THUNK_CHAR **NetworkAddr OPTIONAL,
    OUT THUNK_CHAR **Endpoint OPTIONAL,
    OUT THUNK_CHAR **NetworkOptions OPTIONAL
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcStringBindingParseW.

Return Value:

    RPC_S_OUT_OF_MEMORY - This will be returned if insufficient memory
        is available to convert the strings to and from unicode.

--*/
{
    USES_CONVERSION;
    CHeapInThunk thunkedStringBinding;
    COutDelThunk thunkedObjUuid;
    COutDelThunk thunkedProtseq;
    COutDelThunk thunkedNetworkAddr;
    COutDelThunk thunkedEndpoint;
    COutDelThunk thunkedNetworkOptions;
    RPC_STATUS RpcStatus;

    ATTEMPT_HEAP_IN_THUNK(thunkedStringBinding, StringBinding);

    RpcStatus = RpcStringBindingParse(thunkedStringBinding,
            thunkedObjUuid, thunkedProtseq, thunkedNetworkAddr,
            thunkedEndpoint, thunkedNetworkOptions);

    if (RpcStatus != RPC_S_OK)
        return(RpcStatus);

    if (ARGUMENT_PRESENT(Protseq))
        *Protseq = 0;

    if (ARGUMENT_PRESENT(NetworkAddr))
        *NetworkAddr = 0;

    if (ARGUMENT_PRESENT(Endpoint))
        *Endpoint = 0;

    if (ARGUMENT_PRESENT(NetworkOptions))
        *NetworkOptions = 0;

    if (ARGUMENT_PRESENT(ObjUuid))
        {
        RpcStatus = thunkedObjUuid.Convert();
        if (RpcStatus != RPC_S_OK)
            goto DeleteStringsAndReturn;
        *ObjUuid = thunkedObjUuid;
        }

    if (ARGUMENT_PRESENT(Protseq))
        {
        RpcStatus = thunkedProtseq.Convert();
        if (RpcStatus != RPC_S_OK)
            goto DeleteStringsAndReturn;
        *Protseq = thunkedProtseq;
        }

    if (ARGUMENT_PRESENT(NetworkAddr))
        {
        RpcStatus = thunkedNetworkAddr.Convert();
        if (RpcStatus != RPC_S_OK)
            goto DeleteStringsAndReturn;
        *NetworkAddr = thunkedNetworkAddr;
        }

    if (ARGUMENT_PRESENT(Endpoint))
        {
        RpcStatus = thunkedEndpoint.Convert();
        if (RpcStatus != RPC_S_OK)
            goto DeleteStringsAndReturn;
        *Endpoint = thunkedEndpoint;
        }

    if (ARGUMENT_PRESENT(NetworkOptions))
        {
        RpcStatus = thunkedNetworkOptions.Convert();
        if (RpcStatus != RPC_S_OK)
            goto DeleteStringsAndReturn;
        *NetworkOptions = thunkedNetworkOptions;
        }


DeleteStringsAndReturn:

    if (RpcStatus != RPC_S_OK)
        {
        if (ARGUMENT_PRESENT(Protseq))
            {
            delete *Protseq;
            *Protseq = 0;
            }

        if (ARGUMENT_PRESENT(NetworkAddr))
            {
            delete *NetworkAddr;
            *NetworkAddr = 0;
            }

        if (ARGUMENT_PRESENT(Endpoint))
            {
            delete *Endpoint;
            *Endpoint = 0;
            }

        if (ARGUMENT_PRESENT(NetworkOptions))
            {
            delete *NetworkOptions;
            *NetworkOptions = 0;
            }
        }

    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcNetworkIsProtseqValid) (
    IN THUNK_CHAR *Protseq
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcNetworkIsProtseqValidW.

Return Value:

    RPC_S_OUT_OF_MEMORY - We will return this value if we run out of
        memory trying to allocate space for the string.

--*/
{
    USES_CONVERSION;
    CStackInThunk thunkedProtseq;
    RPC_STATUS RpcStatus;

    ATTEMPT_STACK_IN_THUNK(thunkedProtseq, Protseq);

    RpcStatus = RpcNetworkIsProtseqValid(thunkedProtseq);

    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcNetworkInqProtseqs) (
#ifdef UNICODE
    OUT RPC_PROTSEQ_VECTORA PAPI * PAPI * ProtseqVector
#else
    OUT RPC_PROTSEQ_VECTORW PAPI * PAPI * ProtseqVector
#endif
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcNetworkInqProtseqsW.

Return Value:

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to convert
        the rpc protocol sequences from unicode into ansi.

--*/
{
    RPC_STATUS RpcStatus;
    RPC_CHAR *pString;
    unsigned int Index, Count;

    RpcStatus = RpcNetworkInqProtseqs(
        (RPC_PROTSEQ_VECTOR **) ProtseqVector);
    if (RpcStatus != RPC_S_OK)
        return(RpcStatus);

    for (Index = 0, Count = (*ProtseqVector)->Count; Index < Count; Index++)
        {
        pString = (RPC_CHAR *) (*ProtseqVector)->Protseq[Index];
#ifdef UNICODE
        RpcStatus = W2AAttachHelper(pString, (char **) &((*ProtseqVector)->Protseq[Index]));
#else
        RpcStatus = A2WAttachHelper((char *) pString, &((*ProtseqVector)->Protseq[Index]));
#endif
        delete pString;
        if (RpcStatus != RPC_S_OK)
            {
#ifdef UNICODE
            RpcProtseqVectorFreeA(ProtseqVector);
#else
            RpcProtseqVectorFreeW(ProtseqVector);
#endif
            return(RpcStatus);
            }
        }

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcProtseqVectorFree) (
#ifdef UNICODE
    IN OUT RPC_PROTSEQ_VECTORA PAPI * PAPI * ProtseqVector
#else
    IN OUT RPC_PROTSEQ_VECTORW PAPI * PAPI * ProtseqVector
#endif
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcProtseqVectorFreeW.

--*/
{
    return(RpcProtseqVectorFree((RPC_PROTSEQ_VECTOR **) ProtseqVector));
}


RPC_STATUS RPC_ENTRY
THUNK_FN(I_RpcServerUseProtseq2) (
    IN THUNK_CHAR * NetworkAddress,
    IN THUNK_CHAR * Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor,
    IN void * pPolicy
    )
{
    USES_CONVERSION;
    CStackInThunk thunkProtseq;
    CHeapInThunk thunkNetworkAddress;
    RPC_STATUS RpcStatus;
    PRPC_POLICY Policy = (PRPC_POLICY) pPolicy;

    ATTEMPT_STACK_IN_THUNK(thunkProtseq, Protseq);
    ATTEMPT_HEAP_IN_THUNK_OPTIONAL(thunkNetworkAddress, NetworkAddress);

    RpcStatus = I_RpcServerUseProtseq2(thunkNetworkAddress, thunkProtseq, MaxCalls,
        SecurityDescriptor, (void *) Policy);

    return(RpcStatus);
}



RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerUseProtseqEx) (
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    This is the ansi thunk to RpcServerUseProtseqW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we do not have enough memory to convert
        the ansi strings into unicode strings, this value will be returned.

--*/
{
    return THUNK_FN(I_RpcServerUseProtseq2) (NULL, Protseq, MaxCalls, SecurityDescriptor, (void *) Policy) ;
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerUseProtseq) (
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return THUNK_FN(I_RpcServerUseProtseq2) (NULL, Protseq, MaxCalls, SecurityDescriptor, (void *) &Policy) ;
}


RPC_STATUS RPC_ENTRY
THUNK_FN(I_RpcServerUseProtseqEp2) (
    IN THUNK_CHAR * NetworkAddress,
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN THUNK_CHAR *Endpoint,
    IN void PAPI * SecurityDescriptor,
    IN void * pPolicy
    )
/*++

Routine Description:

    This is the ansi thunk to RpcServerUseProtseqEpW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we do not have enough memory to convert
        the ansi strings into unicode strings, this value will be returned.

--*/
{
    USES_CONVERSION;
    CStackInThunk thunkedProtseq;
    CHeapInThunk thunkedEndpoint;
    CHeapInThunk thunkedNetworkAddress;
    PRPC_POLICY Policy = (PRPC_POLICY) pPolicy;

    ATTEMPT_STACK_IN_THUNK(thunkedProtseq, Protseq);
    ATTEMPT_HEAP_IN_THUNK_OPTIONAL(thunkedEndpoint, Endpoint);
    ATTEMPT_HEAP_IN_THUNK_OPTIONAL(thunkedNetworkAddress, NetworkAddress);

    return (I_RpcServerUseProtseqEp2(thunkedNetworkAddress, thunkedProtseq, MaxCalls,
        thunkedEndpoint, SecurityDescriptor,
        (void *) Policy));
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerUseProtseqEpEx) (
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN THUNK_CHAR *Endpoint,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    This is the ansi thunk to RpcServerUseProtseqEpW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we do not have enough memory to convert
        the ansi strings into unicode strings, this value will be returned.

--*/
{
    return THUNK_FN(I_RpcServerUseProtseqEp2) (NULL, Protseq, MaxCalls, Endpoint,
                    SecurityDescriptor, (void *) Policy) ;
}




RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerUseProtseqEp) (
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN THUNK_CHAR *Endpoint,
    IN void PAPI * SecurityDescriptor
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return THUNK_FN(I_RpcServerUseProtseqEp2) (NULL, Protseq, MaxCalls, Endpoint,
                    SecurityDescriptor, (void *) &Policy) ;
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerUseProtseqIfEx) (
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    This is the ansi thunk to RpcServerUseProtseqIfW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we do not have enough memory to convert
        the ansi strings into unicode strings, this value will be returned.

--*/
{
    USES_CONVERSION;
    CStackInThunk thunkedProtseq;

    ATTEMPT_STACK_IN_THUNK(thunkedProtseq, Protseq);

    return (RpcServerUseProtseqIfEx(thunkedProtseq, MaxCalls,
                        IfSpec, SecurityDescriptor, Policy));
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerUseProtseqIf) (
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return THUNK_FN(RpcServerUseProtseqIfEx) ( Protseq, MaxCalls, IfSpec,
                SecurityDescriptor, &Policy) ;
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcNsBindingInqEntryName) (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT THUNK_CHAR **EntryName
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcNsBindingInqEntryNameW.

Return Value:

    RPC_S_OUT_OF_MEMORY - We will return this value if we do not
        have enough memory to convert the unicode entry name into
        an ansi entry name.

--*/
{
    RPC_STATUS RpcStatus;
    USES_CONVERSION;
    COutDelThunk thunkedEntryName;

    RpcStatus = RpcNsBindingInqEntryName(Binding, EntryNameSyntax,
            thunkedEntryName);

    if ( RpcStatus == RPC_S_NO_ENTRY_NAME )
        {
        ATTEMPT_OUT_THUNK(thunkedEntryName, EntryName);
        return(RPC_S_NO_ENTRY_NAME);
        }

    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    ATTEMPT_OUT_THUNK(thunkedEntryName, EntryName);
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(UuidToString) (
    IN UUID PAPI * Uuid,
    OUT THUNK_CHAR **StringUuid
    )
/*++

Routine Description:

    This routine converts a UUID into its string representation.

Arguments:

    Uuid - Supplies the UUID to be converted into string representation.

    StringUuid - Returns the string representation of the UUID.  The
        runtime will allocate the string.  The caller is responsible for
        freeing the string using RpcStringFree.

Return Value:

    RPC_S_OK - We successfully converted the UUID into its string
        representation.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        a string.

--*/
{
    // The string representation of a UUID is always 36 character long,
    // and we need one more for the terminating zero.

    RPC_CHAR String[37];
    RPC_STATUS RpcStatus;

    InitializeIfNecessary();

    ((RPC_UUID PAPI *) Uuid)->ConvertToString(String);
    String[36] = 0;
#ifdef UNICODE
    return W2AAttachHelper(String, (char **)StringUuid);
#else
    return A2WAttachHelper((char *)String, StringUuid);
#endif
}


RPC_STATUS RPC_ENTRY
THUNK_FN(UuidFromString) (
    IN THUNK_CHAR *StringUuid OPTIONAL,
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    We convert a UUID from its string representation into the binary
    representation.

Arguments:

    StringUuid - Optionally supplies the string representation of the UUID;
        if this argument is not supplied, then the NIL UUID is returned.

    Uuid - Returns the binary representation of the UUID.

Return Value:

    RPC_S_OK - The string representation was successfully converted into
        the binary representation.

    RPC_S_INVALID_STRING_UUID - The supplied string UUID is not correct.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to convert the
        ansi string into a unicode string.

--*/
{
    RPC_UUID RpcUuid;
    RPC_STATUS RpcStatus;
    USES_CONVERSION;
    CHeapInThunk thunkedStringUuid;

    if ( StringUuid == 0 )
        {
        ((RPC_UUID PAPI *) Uuid)->SetToNullUuid();
        return(RPC_S_OK);
        }

    ATTEMPT_HEAP_IN_THUNK(thunkedStringUuid, StringUuid);

    if (RpcUuid.ConvertFromString(thunkedStringUuid) != 0)
        {
        return(RPC_S_INVALID_STRING_UUID);
        }
    ((RPC_UUID PAPI *) Uuid)->CopyUuid(&RpcUuid);
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerRegisterAuthInfo) (
    IN THUNK_CHAR *ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void PAPI * Arg OPTIONAL
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcServerRegisterAuthInfoW.

Return Value:

    RPC_S_OUT_OF_MEMORY - We will return this value if we do not have
        enough memory to convert the ansi server principal name into
        a unicode string.

--*/
{
    USES_CONVERSION;
    CHeapInThunk thunkedServerPrincName;
    RPC_STATUS RpcStatus;

    ATTEMPT_HEAP_IN_THUNK(thunkedServerPrincName, ServerPrincName);

    RpcStatus = RpcServerRegisterAuthInfo(thunkedServerPrincName, AuthnSvc,
            GetKeyFn, Arg);

    return(RpcStatus);
}

RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingInqAuthClient) (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE PAPI * Privs,
    OUT THUNK_CHAR **PrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc OPTIONAL
    )
{
    return THUNK_FN(RpcBindingInqAuthClientEx)( ClientBinding,
                                       Privs,
                                       PrincName,
                                       AuthnLevel,
                                       AuthnSvc,
                                       AuthzSvc,
                                       0
                                       );
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingInqAuthClientEx) (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE PAPI * Privs,
    OUT THUNK_CHAR **ServerPrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc, OPTIONAL
    IN  unsigned long        Flags
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcBindingInqAuthClientW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we can not allocate space to convert the
        unicode server principal name into unicode, we will return this
        value.

--*/
{
    RPC_STATUS RpcStatus;
    USES_CONVERSION;
    COutDelThunk thunkedServerPrincName;

    RpcStatus = RpcBindingInqAuthClientEx(ClientBinding,
                                          Privs,
                                          (ARGUMENT_PRESENT(ServerPrincName) ? (RPC_CHAR **)thunkedServerPrincName : 0),
                                          AuthnLevel,
                                          AuthnSvc,
                                          AuthzSvc,
                                          Flags);

    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    if (ARGUMENT_PRESENT(ServerPrincName))
        {
        ATTEMPT_OUT_THUNK_OPTIONAL(thunkedServerPrincName, ServerPrincName);
        }
    return(RpcStatus);
}

RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerInqCallAttributes) (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    IN OUT void *RpcCallAttributes
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcServerInqCallAttributes.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we can not allocate space to convert the
        unicode server principal name into unicode, we will return this
        value.
    The API can in addition return all errors returned by the Unicode
        version.

--*/
{
    RPC_STATUS RpcStatus;
    USES_CONVERSION;
    COutDelThunk thunkedServerPrincName;
    RPC_CALL_ATTRIBUTES_V1_W *CallAttributesW;
    RPC_CALL_ATTRIBUTES_V1_A *CallAttributesA;
    unsigned char *OldClientPrincipalNameBuffer;
    RPC_CHAR *NewClientPrincipalNameBuffer = NULL;
    ULONG OldClientPrincipalNameBufferLength;
    ULONG NewClientPrincipalNameBufferLength;
    unsigned char *OldServerPrincipalNameBuffer;
    RPC_CHAR *NewServerPrincipalNameBuffer = NULL;
    ULONG OldServerPrincipalNameBufferLength;
    ULONG NewServerPrincipalNameBufferLength;

    // we use the same structure to pass to the unicode API, but
    // we save some data members
    CallAttributesW = 
        (RPC_CALL_ATTRIBUTES_V1_W *)RpcCallAttributes;
    CallAttributesA = 
        (RPC_CALL_ATTRIBUTES_V1_A *)RpcCallAttributes;

    if (CallAttributesW->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        OldClientPrincipalNameBuffer = CallAttributesA->ClientPrincipalName;
        OldClientPrincipalNameBufferLength = CallAttributesA->ClientPrincipalNameBufferLength;
        if (OldClientPrincipalNameBufferLength != 0)
            {
            NewClientPrincipalNameBuffer = new RPC_CHAR[OldClientPrincipalNameBufferLength];
            if (NewClientPrincipalNameBuffer == NULL)
                {
                return RPC_S_OUT_OF_MEMORY;
                }
            }
        else
            {
            // here CallAttributesW->ClientPrincipalName must be NULL. If it's
            // not, the unicode function will return error. Delegate the check to it
            NewClientPrincipalNameBuffer = CallAttributesW->ClientPrincipalName;
            }
        }

    if (CallAttributesW->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        OldServerPrincipalNameBuffer = CallAttributesA->ServerPrincipalName;
        OldServerPrincipalNameBufferLength = CallAttributesA->ServerPrincipalNameBufferLength;
        if (OldServerPrincipalNameBufferLength != 0)
            {
            NewServerPrincipalNameBuffer = new RPC_CHAR[OldServerPrincipalNameBufferLength];
            if (NewServerPrincipalNameBuffer == NULL)
                {
                if ((CallAttributesW->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME) 
                    && (OldClientPrincipalNameBufferLength != 0))
                    {
                    ASSERT(NewClientPrincipalNameBuffer != NULL);
                    delete [] NewClientPrincipalNameBuffer;
                    }
                return RPC_S_OUT_OF_MEMORY;
                }
            }
        else
            {
            // here CallAttributesW->ServerPrincipalName must be NULL. If it's
            // not, the unicode function will return error. Delegate the check to it
            NewServerPrincipalNameBuffer = CallAttributesW->ServerPrincipalName;
            }
        }

    // by now all buffers are allocated, so we don't have failure paths b/n
    // here and the API call
    if (CallAttributesW->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        CallAttributesW->ServerPrincipalName = NewServerPrincipalNameBuffer;
        CallAttributesW->ServerPrincipalNameBufferLength *= 2;
        }

    if (CallAttributesW->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        CallAttributesW->ClientPrincipalName = NewClientPrincipalNameBuffer;
        CallAttributesW->ClientPrincipalNameBufferLength *= 2;
        }

    RpcStatus = RpcServerInqCallAttributes(ClientBinding,
                                          RpcCallAttributes
                                          );

    // restore user's values to the structure regardless of failure
    if (CallAttributesW->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        NewClientPrincipalNameBufferLength = CallAttributesA->ClientPrincipalNameBufferLength;
        CallAttributesA->ClientPrincipalNameBufferLength = OldClientPrincipalNameBufferLength;
        CallAttributesA->ClientPrincipalName = OldClientPrincipalNameBuffer;
        };

    if (CallAttributesW->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        NewServerPrincipalNameBufferLength = CallAttributesA->ServerPrincipalNameBufferLength;
        CallAttributesA->ServerPrincipalNameBufferLength = OldServerPrincipalNameBufferLength;
        CallAttributesA->ServerPrincipalName = OldServerPrincipalNameBuffer;
        };

    if ((RpcStatus != RPC_S_OK)
        && (RpcStatus != ERROR_MORE_DATA))
        {
        if ((CallAttributesW->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME) 
            && (OldClientPrincipalNameBufferLength != 0))
            {
            ASSERT(NewClientPrincipalNameBuffer != NULL);
            delete [] NewClientPrincipalNameBuffer;
            }

        if ((CallAttributesW->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME) 
            && (OldServerPrincipalNameBufferLength != 0))
            {
            ASSERT(NewServerPrincipalNameBuffer != NULL);
            delete [] NewServerPrincipalNameBuffer;
            }

        return(RpcStatus);
        }

    ASSERT((RpcStatus == RPC_S_OK)
        || (RpcStatus == ERROR_MORE_DATA));

    if (CallAttributesW->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        CallAttributesW->ServerPrincipalNameBufferLength = NewServerPrincipalNameBufferLength >> 1;
        // if we returned non-zero, and there was enough space in the string to start with, we must
        // have returned a string as well
        if ((CallAttributesW->ServerPrincipalNameBufferLength > 0)
            && (CallAttributesW->ServerPrincipalNameBufferLength <= OldServerPrincipalNameBufferLength))
            {
            RtlUnicodeToMultiByteN((char *)CallAttributesA->ServerPrincipalName, 
                CallAttributesA->ServerPrincipalNameBufferLength, 
                NULL, 
                NewServerPrincipalNameBuffer, 
                NewServerPrincipalNameBufferLength);
            }
        }

    if (CallAttributesW->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        CallAttributesW->ClientPrincipalNameBufferLength = NewClientPrincipalNameBufferLength >> 1;
        // if we returned non-zero, and there was enough space in the string to start with, we must
        // have returned a string as well
        if ((CallAttributesW->ClientPrincipalNameBufferLength > 0)
            && (CallAttributesW->ClientPrincipalNameBufferLength <= OldClientPrincipalNameBufferLength))
            {
            RtlUnicodeToMultiByteN((char *)CallAttributesA->ClientPrincipalName, 
                CallAttributesA->ClientPrincipalNameBufferLength, 
                NULL, 
                NewClientPrincipalNameBuffer, 
                NewClientPrincipalNameBufferLength);
            }
        }

    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingInqAuthInfo) (
    IN RPC_BINDING_HANDLE Binding,
    OUT THUNK_CHAR **ServerPrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE PAPI * AuthIdentity, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc OPTIONAL
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcBindingInqAuthInfoW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we can not allocate space to convert the
        unicode server principal name into unicode, we will return this
        value.

--*/
{
    RPC_STATUS RpcStatus;

    return( THUNK_FN(RpcBindingInqAuthInfoEx) (
                     Binding,
                     ServerPrincName,
                     AuthnLevel,
                     AuthnSvc,
                     AuthIdentity,
                     AuthzSvc,
                     0,
                     0
                     ) );

}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingInqAuthInfoEx) (
    IN RPC_BINDING_HANDLE Binding,
    OUT THUNK_CHAR **ServerPrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE PAPI * AuthIdentity, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc, OPTIONAL
    IN  unsigned long RpcSecurityQosVersion,
    OUT RPC_SECURITY_QOS * SecurityQOS
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcBindingInqAuthInfoW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we can not allocate space to convert the
        unicode server principal name into unicode, we will return this
        value.

--*/
{
    RPC_STATUS RpcStatus;
    USES_CONVERSION;
    COutDelThunk thunkedServerPrincName;

    RpcStatus = RpcBindingInqAuthInfoEx(
            Binding,
            (ARGUMENT_PRESENT(ServerPrincName) ? (RPC_CHAR **)thunkedServerPrincName : 0),
            AuthnLevel,
            AuthnSvc,
            AuthIdentity,
            AuthzSvc,
            RpcSecurityQosVersion,
            SecurityQOS
            );

    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    if (ARGUMENT_PRESENT(ServerPrincName))
        {
        ATTEMPT_OUT_THUNK_OPTIONAL(thunkedServerPrincName, ServerPrincName);
        }

    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingSetAuthInfo)(
    IN RPC_BINDING_HANDLE Binding,
    IN THUNK_CHAR *ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    )
{


    return ( THUNK_FN(RpcBindingSetAuthInfoEx)(
                          Binding,
                          ServerPrincName,
                          AuthnLevel,
                          AuthnSvc,
                          AuthIdentity,
                          AuthzSvc,
                          0
                          ) );

}



RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingSetAuthInfoEx) (
    IN RPC_BINDING_HANDLE Binding,
    IN THUNK_CHAR *ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc,
    IN RPC_SECURITY_QOS * SecurityQOS
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcBindingSetAuthInfoW.

Return Value:

    RPC_S_OUT_OF_MEMORY - We will return this value if we do not have
        enough memory to convert the ansi server principal name into
        a unicode string.

--*/
{
    USES_CONVERSION;
    CHeapInThunk thunkedServerPrincName;
    RPC_STATUS RpcStatus;
    RPC_HTTP_TRANSPORT_CREDENTIALS_A *HttpCredentials;
    ULONG AdditionalTransportCredentialsType;
    RPC_SECURITY_QOS_V3_W SecurityQOS3;
    RPC_SECURITY_QOS_V3_W *SecurityQOSToUse;

    ATTEMPT_HEAP_IN_THUNK(thunkedServerPrincName, ServerPrincName);

    if (SecurityQOS)
        {
        if (SecurityQOS->Version == RPC_C_SECURITY_QOS_VERSION_1)
            {
            RpcpMemoryCopy(&SecurityQOS3, SecurityQOS, sizeof(RPC_SECURITY_QOS));
            SecurityQOS3.AdditionalSecurityInfoType = 0;
            SecurityQOS3.u.HttpCredentials = NULL;
            SecurityQOS3.Sid = NULL;
            }
        else
            {
            RpcpMemoryCopy(&SecurityQOS3, SecurityQOS, sizeof(RPC_SECURITY_QOS_V3_A));
            AdditionalTransportCredentialsType = ((RPC_SECURITY_QOS_V3 *)SecurityQOS)->AdditionalSecurityInfoType;
            HttpCredentials = ((RPC_SECURITY_QOS_V3_A *)SecurityQOS)->u.HttpCredentials;

            if (AdditionalTransportCredentialsType != RPC_C_AUTHN_INFO_TYPE_HTTP)
                {
                if (AdditionalTransportCredentialsType != 0)
                    return(RPC_S_INVALID_ARG);

                if (HttpCredentials != NULL)
                    return(RPC_S_INVALID_ARG);
                }
            else if (HttpCredentials == NULL)
                return(RPC_S_INVALID_ARG);
            else
                {
                if (HttpCredentials->TransportCredentials)
                    {
                    if (HttpCredentials->TransportCredentials->User)
                        {
                        if (RpcpStringLengthA((const char *)HttpCredentials->TransportCredentials->User) 
                            != HttpCredentials->TransportCredentials->UserLength)
                            {
                            return(RPC_S_INVALID_ARG);
                            }
                        }
                    else if (HttpCredentials->TransportCredentials->UserLength)
                        return(RPC_S_INVALID_ARG);

                    if (HttpCredentials->TransportCredentials->Domain)
                        {
                        if (RpcpStringLengthA((const char *)HttpCredentials->TransportCredentials->Domain) 
                            != HttpCredentials->TransportCredentials->DomainLength)
                            {
                            return(RPC_S_INVALID_ARG);
                            }
                        }
                    else if (HttpCredentials->TransportCredentials->DomainLength)
                        return(RPC_S_INVALID_ARG);

                    if (HttpCredentials->TransportCredentials->Password)
                        {
                        if (RpcpStringLengthA((const char *)HttpCredentials->TransportCredentials->Password) 
                            != HttpCredentials->TransportCredentials->PasswordLength)
                            {
                            return(RPC_S_INVALID_ARG);
                            }
                        }
                    else if (HttpCredentials->TransportCredentials->PasswordLength)
                        return(RPC_S_INVALID_ARG);

                    if (HttpCredentials->TransportCredentials->Flags != SEC_WINNT_AUTH_IDENTITY_ANSI)
                        return(RPC_S_INVALID_ARG);
                    }

                // if you don't want to authenticate against anyone, you can't authenticate
                if (HttpCredentials->AuthenticationTarget == 0)
                    return(RPC_S_INVALID_ARG);

                // if you don't support any method of authentication, you can't authenticate
                if (HttpCredentials->NumberOfAuthnSchemes == 0)
                    return(RPC_S_INVALID_ARG);

                // if you don't support any method of authentication, you can't authenticate
                if (HttpCredentials->AuthnSchemes == NULL)
                    return(RPC_S_INVALID_ARG);

                SecurityQOS3.u.HttpCredentials = ConvertToUnicodeHttpTransportCredentials (
                    HttpCredentials);

                if (SecurityQOS3.u.HttpCredentials == NULL)
                    return RPC_S_OUT_OF_MEMORY;
                }

            if (SecurityQOS->Version == RPC_C_SECURITY_QOS_VERSION_3)
                {
                SecurityQOS3.Sid = ((RPC_SECURITY_QOS_V3 *)SecurityQOS)->Sid;
                }
            else
                {
                SecurityQOS3.Version = RPC_C_SECURITY_QOS_VERSION_3;
                SecurityQOS3.Sid = NULL;
                }
            }
        SecurityQOSToUse = &SecurityQOS3;
        }
    else
        {
        SecurityQOSToUse = NULL;
        }

    RpcStatus = RpcBindingSetAuthInfoEx(Binding, thunkedServerPrincName,
            AuthnLevel, AuthnSvc, AuthIdentity, AuthzSvc, (RPC_SECURITY_QOS *)SecurityQOSToUse);

    if (SecurityQOSToUse && (SecurityQOS3.AdditionalSecurityInfoType == RPC_C_AUTHN_INFO_TYPE_HTTP))
        {
        // free the converted credentials
        WipeOutAuthIdentity(SecurityQOS3.u.HttpCredentials->TransportCredentials);
        FreeHttpTransportCredentials(SecurityQOS3.u.HttpCredentials);
        }

    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcMgmtInqServerPrincName) (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT THUNK_CHAR **ServerPrincName
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcMgmtInqServerPrincNameW.

Return Value:

    RPC_S_OUT_OF_MEMORY - We will return this value if we do not have
        enough memory to convert the unicode server principal name into
        an ansi string.

--*/
{
    RPC_STATUS RpcStatus;
    USES_CONVERSION;
    COutDelThunk thunkedServerPrincName;

    RpcStatus = RpcMgmtInqServerPrincName(Binding, AuthnSvc, thunkedServerPrincName);
    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    ATTEMPT_OUT_THUNK(thunkedServerPrincName, ServerPrincName);
    return(RPC_S_OK);
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
THUNK_FN(RpcCertGeneratePrincipalName)(
                      PCCERT_CONTEXT Context,
                      DWORD         Flags,
                      OUT THUNK_CHAR  **pBuffer
                      )
{
    USES_CONVERSION;
    COutDelThunk thunkedServerPrincName;

    RPC_STATUS Status = RpcCertGeneratePrincipalName( Context,
                                                    Flags,
                                                    thunkedServerPrincName
                                                    );
    if (Status != RPC_S_OK)
        {
        return Status;
        }


    ATTEMPT_OUT_THUNK(thunkedServerPrincName, pBuffer);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dgsvr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    dgsvr.cxx

Abstract:

    This is the server protocol code for datagram rpc.

Author:

    Dave Steckler (davidst) 15-Dec-1992

Revision History:

    Jeff Roberts  (jroberts) 11-22-1994

        Rewrote it.

    Jeff Roberts  (jroberts)  9-30-1996

        Began asynchronous call support.

    Edward Reus   (edwardr)   7-09-1997

        Support for large packets (Falcon).

--*/
#include <precomp.hxx>

//
// Remember that any #defines must go AFTER the precompiled header in order
// to be noticed by the compiler.
//

// uncomment this to have the server try the msconv interface, used by NT5 beta 1.
//
// #define TRY_MSCONV_INTERFACE


#include "sdict2.hxx"
#include "hndlsvr.hxx"
#include "dgpkt.hxx"
#include "delaytab.hxx"
#include "hashtabl.hxx"
#include "locks.hxx"
#include "dgclnt.hxx"
#include "dgsvr.hxx"
#include <conv.h>
#include <convc.h>

#ifdef TRY_MSCONV_INTERFACE
#include <msconv.h>
#endif

#define IDLE_SCONNECTION_LIFETIME       (3 * 60 * 1000)
#define IDLE_SCONNECTION_SWEEP_INTERVAL (30 * 1000)
#define IDLE_SCALL_LIFETIME             (15 * 1000)

// Used to test races between conv callback sync and async completion paths.
//#define INDUCE_CONV_CALLBACK_RACES

struct REMOTE_ADDRESS_INFO
{
#pragma warning(disable:4200)

    unsigned RemoteInfoLength;
    unsigned SecurityInfoPadLength;
    byte     Address[];

#pragma warning(default:4200)
};

//------------------------------------------------------------------------

LONG fPruning = FALSE;

SERVER_ACTIVITY_TABLE *  ServerConnections;
ASSOC_GROUP_TABLE *      AssociationGroups;

LONG ServerConnectionCount = 0;
LONG ServerCallCount = 0;

#ifdef INTRODUCE_ERRORS

extern long ServerDelayTime;
extern long ServerDelayRate;
extern long ServerDropRate;

#endif
//--------------------------------------------------------------------

extern int
StringLengthWithEscape (
    IN RPC_CHAR * String
    );

extern RPC_CHAR *
StringCopyEscapeCharacters (
    OUT RPC_CHAR * Destination,
    IN RPC_CHAR * Source
    );

void
ServerCallScavengerProc(
    void *  Parms
    );

RPC_STATUS
InitializeServerGlobals(
    );

void
InterpretFailureOptions(
    );

//--------------------------------------------------------------------

#if !defined(WIN96)
char __pure_virtual_called()
{
    ASSERT(0 && "rpc: pure virtual fn called in dg");
    return 0;
}
#endif


boolean ServerGlobalsInitialized = FALSE;

RPC_STATUS
InitializeServerGlobals(
    )
/*++

Routine Description:

    This fn initializes all the global variables used by the datagram
    server.  If anything fails, all the objects are destroyed.

Arguments:

    none

Return Value:

    RPC_S_OK if ok
    RPC_S_OUT_OF_MEMORY if an object could not be created

--*/

{
    RPC_STATUS Status = RPC_S_OK;

    //
    // Don't take the global mutex if we can help it.
    //
    if (ServerGlobalsInitialized)
        {
        return 0;
        }

    RequestGlobalMutex();

    if (0 != InitializeRpcProtocolDgClient())
        {
        ClearGlobalMutex();
        return RPC_S_OUT_OF_MEMORY;
        }

    if (!ServerGlobalsInitialized)
        {
        ServerConnections = new SERVER_ACTIVITY_TABLE(&Status);
        if (!ServerConnections)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        AssociationGroups = new ASSOC_GROUP_TABLE(&Status);
        if (!AssociationGroups)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        ServerGlobalsInitialized = TRUE;
        }

    ClearGlobalMutex();

    return Status;

    //--------------------------------------------------------------------

abend:

    delete AssociationGroups;
    AssociationGroups = 0;

    delete ServerConnections;
    ServerConnections = 0;

    ClearGlobalMutex();

    return Status;
}


RPC_ADDRESS *
DgCreateRpcAddress (
    IN TRANS_INFO * TransportInfo
    )
/*++

Routine Description:

    This is a psuedo-constructor for the DG_ADDRESS class. This is done this
    way so that the calling routine doesn't have to have any protocol-specific
    knowledge.

Arguments:

    TransportInterface - Pointer to a PDG_RPC_SERVER_TRANSPORT_INFO.
    pStatus - Pointer to where to put the return value

Return Value:

    pointer to new DG_ADDRESS.

--*/
{
    //
    // If the global active call table hasn't been initialized, then do
    // so now.
    //
    if (0 != InitializeServerGlobals())
        {
        return 0;
        }

    RPC_STATUS  Status = RPC_S_OK;

    PDG_ADDRESS Address;


    Address = new (TransportInfo) DG_ADDRESS(
                           TransportInfo,
                           &Status
                           );
    if (!Address)
        {
        return 0;
        }

    if (Status != RPC_S_OK)
        {
        delete Address;
        return 0;
        }

    return Address;
}


DG_ADDRESS::DG_ADDRESS(
    TRANS_INFO * a_LoadableTransport,
    RPC_STATUS * pStatus
    )
    : RPC_ADDRESS(pStatus),

    TotalThreadsThisEndpoint    (0),
    ThreadsReceivingThisEndpoint(0),
    MinimumCallThreads          (0),
    MaximumConcurrentCalls      (0),
    CachedConnections           (0),
    ActiveCallCount             (0),
    AutoListenCallCount         (0)

/*++

Routine Description:

    This is the constructor for a DG_ADDRESS.

Arguments:

    TransportInterface - Pointer to a PDG_RPC_SERVER_TRANSPORT_INFO

    pStatus - Pointer to where to put the return value

Return Value:

    None (this is a constructor)

Revision History:

--*/

{
    TransInfo = a_LoadableTransport;
    ObjectType = DG_ADDRESS_TYPE;

    //
    // Make sure the RPC_ADDRESS (et. al.) initialized correctly.
    //
    if (*pStatus != RPC_S_OK)
        {
        return;
        }

    Endpoint.TransportInterface = (RPC_DATAGRAM_TRANSPORT *)
                                        TransInfo->InqTransInfo();
}


DG_ADDRESS::~DG_ADDRESS()

/*++

Routine Description:

    This is the destructor for a DG_ADDRESS.
    It is called only if the endpoint failed!

Arguments:

    <None>

Return Value:

    <None>

--*/

{
}

inline void
DG_ADDRESS::BeginAutoListenCall (
    )
{
    AutoListenCallCount.Increment() ;
}

inline void
DG_ADDRESS::EndAutoListenCall (
    )
{
    ASSERT(AutoListenCallCount.GetInteger() >= 1);
    AutoListenCallCount.Decrement() ;
}


void
DG_ADDRESS::WaitForCalls(
    )
{
    while (InqNumberOfActiveCalls() > AutoListenCallCount.GetInteger())
        {
        ServerConnections->PruneEntireTable(0);
        PauseExecution(500);
        }
}

void
DG_ADDRESS::EncourageCallCleanup(
    RPC_INTERFACE * Interface
    )
{
    if (ServerGlobalsInitialized && AutoListenCallCount.GetInteger() > 0)
        {
        ServerConnections->PruneEntireTable(Interface);
        }
}

RPC_STATUS
DG_ADDRESS::ServerSetupAddress (
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * *  pEndpointString,
    IN unsigned int  PendingQueueSize,
    IN void *        SecurityDescriptor,
    IN unsigned long EndpointFlags,
    IN unsigned long NICFlags
    )
{
    RPC_STATUS  Status;

    Status = Endpoint.TransportInterface->Listen(
                                        Endpoint.TransportEndpoint,
                                        NetworkAddress,
                                        pEndpointString,
                                        SecurityDescriptor,
                                        EndpointFlags,
                                        NICFlags
                                        );
    if (!Status)
        {
        Status = Endpoint.TransportInterface->QueryEndpointStats(
                                        &Endpoint.TransportEndpoint,
                                        &Endpoint.Stats
                                        );
        }

    Endpoint.Flags = EndpointFlags;

    return Status;
}

#ifndef NO_PLUG_AND_PLAY

void
DG_ADDRESS::PnpNotify (
    )
{
    Endpoint.TransportInterface->PnpNotify();
}
#endif


RPC_STATUS
DG_ADDRESS::ServerStartingToListen (
    IN unsigned int MinThreads,
    IN unsigned int MaxCalls
    )
/*++

Routine Description:

    The runtime calls this fn to ensure a thread is listening on the address's
    endpoint.  Currently, it may be called from RpcServerUse*Protseq*() or
    from RpcServerRegisterIfEx().

Arguments:

    MinimumCallThreads - Supplies a number indicating the minimum number
        of call threads that should be created for this address. This is
        a hint, and datagram ignores it.

    MaximumConcurrentCalls - Supplies the maximum number of concurrent
        calls that this server will support.  RPC_INTERFACE::DispatchToStub
        limits the number of threads dispatched to a stub; the argument
        here is just a hint for the transport.

Return Value:

    RPC_S_OK             if everything went ok.
    RPC_S_OUT_OF_THREADS if we needed another thread and couldn't create one

--*/
{
    MaximumConcurrentCalls = MaxCalls;

    return CheckThreadPool();
}

RPC_STATUS
DG_ADDRESS::CompleteListen(
    )
{
    Endpoint.TransportInterface->CompleteListen(Endpoint.TransportEndpoint);

    return 0;
}

RPC_STATUS
DG_ADDRESS::CheckThreadPool(
    )
{
    return TransInfo->CreateThread();
}


RPC_STATUS RPC_ENTRY
I_RpcLaunchDatagramReceiveThread(
    void * pVoid
    )
{
/*++

Routine Description:

    If all of the following are true:

        - the transport is part of our thread-sharing scheme
        - this address's endpoint is being monitored by the shared thread
          (hence no RPC thread is receiving on the endpoint)
        - the shared thread detects data on this address's endpoint

    then the shared thread will call this (exported) function to create
    a thread to handle the incoming packet.

Arguments:

    pVoid - the DG_ADDRESS of the endpoint with data

Return Value:

    result from CreateThread()

--*/

    PDG_ADDRESS pAddress = (PDG_ADDRESS) pVoid;

    return pAddress->CheckThreadPool();
}


void
DG_ADDRESS::ServerStoppedListening (
    )

/*++

Routine Description:

    The runtime calls this fn to inform the address that the server is not
    listening any more.  Since auto-listen interfaces may still be present,
    this doesn't mean much anymore.

Arguments:

    <None>

Return Value:

    <None>

--*/
{
}


long
DG_ADDRESS::InqNumberOfActiveCalls (
    )
{
    return ActiveCallCount;
}


BOOL
DG_ADDRESS::ForwardPacketIfNecessary(
    IN PDG_PACKET           Packet,
    IN DG_TRANSPORT_ADDRESS RemoteAddress
    )
/*++

Routine Description:

       (courtesy of Connie)

       The runtime has determined that it is dedicated to the
       Epmapper and that pkts may arrive that are really
       destined for an endpoint other than that of the epmapper
       (ie: this is the beginning of dynamic endpoint resolution
       by the forwarding mechanism).

       The runtime has just received a packet and has called
       this routine to determine if (a) the packet is destined
       for the epmapper (in which case it returns indicating that
       the packet should be processed as is)  OR
       (b) the packet is destined for another local server (in
       which case it forwarded to its intented destination) OR
       (c) is in error (in which case returns indicating an error).

       It searches for the i/f.  If not found it calls the
       epmapper get forward function to determine the real destination
       endpoint for this i/f. If the epmapper recognizes the i/f,
       it calls ForwardPacket to forward the packet.

Return Value:

    TRUE  if the packet needed to be forwarded
    FALSE if it should be handled locally

--*/
{
    RPC_STATUS            Status;
    PNCA_PACKET_HEADER    pHeader = &Packet->Header;

    RPC_INTERFACE *       pRpcInterface;
    RPC_SYNTAX_IDENTIFIER RpcIfSyntaxIdentifier;
    char *                EndpointString = 0;

    //
    // Build an interface syntax identifier from the packet.
    //
    RpcpMemoryCopy(
        &RpcIfSyntaxIdentifier.SyntaxGUID,
        &pHeader->InterfaceId,
        sizeof(RPC_UUID)
        );

    RpcIfSyntaxIdentifier.SyntaxVersion.MajorVersion =
                              pHeader->InterfaceVersion.MajorVersion;
    RpcIfSyntaxIdentifier.SyntaxVersion.MinorVersion =
                              pHeader->InterfaceVersion.MinorVersion;
    //
    // Try to find the appropriate interface to dispatch to.
    //
    pRpcInterface = Server->FindInterface(&RpcIfSyntaxIdentifier);

    //
    //  If the Interface is Mgmt If .. EpMapper has registered it  and will be found
    //  The criteria then is .. If Packet has a Non NULL Obj Id forward .. else process
    //
    if (pRpcInterface &&
        0 == RpcpMemoryCompare(&pHeader->ObjectId, &NullUuid, sizeof(UUID)) )
        {
        //Interface found, just process as normal
        return FALSE;
        }
    else
        {
        //Interface wasn't found. Let's ask endpoint mapper to resolve it
        //for us.

        unsigned char * AnsiProtseq;

        // Must convert the protocol sequence into an ansi string.

        unsigned Length = 1 + RpcpStringLength(InqRpcProtocolSequence());
        AnsiProtseq = (unsigned char *) _alloca(Length);
        if (!AnsiProtseq)
            {
            return TRUE;
            }

        NTSTATUS NtStatus;
        NtStatus = RtlUnicodeToMultiByteN((char *) AnsiProtseq,
                                          Length,
                                          NULL,
                                          InqRpcProtocolSequence(),
                                          Length * sizeof(RPC_CHAR)
                                          );
        ASSERT(NT_SUCCESS(NtStatus));

        RpcTryExcept
            {
            // Call the epmapper get forward function. It returns the
            // endpoint of the server this packet is really destined for.

            Status =  (*Server->pRpcForwardFunction)(
                         (UUID *) &pHeader->InterfaceId,
                         (RPC_VERSION *) &pHeader->InterfaceVersion,
                         (UUID *) &pHeader->ObjectId,
                         AnsiProtseq,
                         (void * *) &EndpointString
                         );
            }
        RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) )
            {
            Status = RpcExceptionCode();
            }
        RpcEndExcept

        if (Status != RPC_S_OK)
            {
            if (!(pHeader->PacketFlags & DG_PF_BROADCAST) &&
                !(pHeader->PacketFlags & DG_PF_MAYBE))
                {
                // couldn't find the interface, or some other error occurred.
                // The X/Open version of the AES, available in 1997, says we should
                // set the boot time to zero in this situation.
                //
                InitErrorPacket(Packet, DG_REJECT, RPC_S_UNKNOWN_IF );
                Packet->Header.ServerBootTime = 0;
                SendPacketBack (&Packet->Header, Packet->GetPacketBodyLen(), RemoteAddress);
                }
            return TRUE;
            }

        if (EndpointString)
            {
            ForwardPacket(Packet, RemoteAddress, EndpointString);
            I_RpcFree(EndpointString);
            }
        }

    return TRUE;
}


RPC_STATUS
DG_ADDRESS::ForwardPacket(
    IN PDG_PACKET               Packet,
    IN DG_TRANSPORT_ADDRESS     RemoteAddress,
    IN char *                   ServerEndpointString
    )
/*++

Routine Description:

    This method will be called to forward a packet that was just
    received to the intended destination endpoint.

    The runtime has received a packet for an unknkown i/f.
    It has passed this packet to the epmapper who has found the
    correct destination enpoint in its table and has instructed the
    runtime to forward the packet to this Endpoint. This procedure
    will do just that.

--*/
{
    //
    // Avoid a loop if the server gets confused.
    //
    if (Packet->Header.PacketType != DG_REQUEST &&
        Packet->Header.PacketType != DG_PING    &&
        Packet->Header.PacketType != DG_QUIT)
        {
#ifdef DEBUGRPC
        DbgPrint("DG RPC: not forwarding packet of type %u\n", Packet->Header.PacketType);
#endif
        return RPC_S_OK;
        }

    //
    // Use the same value for 32 and 64 bit.
    //
    #define REMOTE_ADDRESS_PAD 8

    unsigned             Length;
    REMOTE_ADDRESS_INFO *pRemoteAddressInfo;
    unsigned             EndpointInfoStart  = Align( Packet->DataLength, REMOTE_ADDRESS_PAD );
    unsigned             EndpointInfoLength = sizeof(REMOTE_ADDRESS_INFO)
                                            + Endpoint.TransportInterface->AddressSize;
    //
    // We have not yet subtracted the header from the packet's DataLength.
    //
    Length = EndpointInfoStart + EndpointInfoLength;

    //
    // If the packet header was byte-swapped, restore it to its original format.
    //
    ByteSwapPacketHeaderIfNecessary(Packet);


    // BE CAREFUL READING OR WRITING THE PACKET HEADER AFTER IT IS BYTE-SWAPPED.


    //
    // If the original packet is short enough, we can append out data
    // to the end; otherwise, we need to send one packet with the original
    // data and another with the client address info.
    //
    if (Length <= Endpoint.Stats.PreferredPduSize)
        {
        //
        // Mark it "forwarded with appended endpoint info"
        //
        Packet->Header.PacketFlags  |=  DG_PF_FORWARDED;
        Packet->Header.PacketFlags2 &= ~DG_PF2_FORWARDED_2;

        pRemoteAddressInfo = (REMOTE_ADDRESS_INFO *) ( Packet->Header.Data
                                                     + EndpointInfoStart
                                                     - sizeof(NCA_PACKET_HEADER) );

        pRemoteAddressInfo->SecurityInfoPadLength = EndpointInfoStart - Packet->DataLength;
        }
    else
        {
        Length = EndpointInfoLength + sizeof(NCA_PACKET_HEADER);

        //
        // Mark it "forwarded without appended endpoint info"
        //
        Packet->Header.PacketFlags  &= ~DG_PF_FORWARDED;
        Packet->Header.PacketFlags2 |=  DG_PF2_FORWARDED_2;

        Endpoint.TransportInterface->ForwardPacket( Endpoint.TransportEndpoint,
                                                    0,
                                                    0,
                                                    &Packet->Header,
                                                    Packet->DataLength,
                                                    0,
                                                    0,
                                                    ServerEndpointString
                                                    );

        //
        // Mark it "endpoint info only".
        //
        Packet->Header.PacketFlags  |= DG_PF_FORWARDED;
        Packet->Header.PacketFlags2 |= DG_PF2_FORWARDED_2;

        Packet->SetPacketBodyLen(EndpointInfoLength);
        Packet->Header.AuthProto     = 0;

        pRemoteAddressInfo           = (REMOTE_ADDRESS_INFO *) Packet->Header.Data;

        pRemoteAddressInfo->SecurityInfoPadLength = 0;
        }

    //
    // Add endpoint info and send it.
    //
    pRemoteAddressInfo->RemoteInfoLength = sizeof(REMOTE_ADDRESS_INFO)
                                         + Endpoint.TransportInterface->AddressSize;
    RpcpMemoryCopy(
        pRemoteAddressInfo->Address,
        RemoteAddress,
        Endpoint.TransportInterface->AddressSize
        );

    Endpoint.TransportInterface->ForwardPacket( Endpoint.TransportEndpoint,
                                                0,
                                                0,
                                                &Packet->Header,
                                                Length,
                                                0,
                                                0,
                                                ServerEndpointString
                                                );
    return RPC_S_OK;
}


BOOL
DG_ADDRESS::CaptureClientAddress(
    IN  PDG_PACKET           Packet,
    OUT DG_TRANSPORT_ADDRESS RemoteAddress
    )
/*++

Routine Description:

        This method is called when a packet with DG_PF_FORWARDED arrives.
        This means the endpoint mapper sent it and it includes a
        REMOTE_ADDRESS_INFO structure.  The fn will remove it and store the
        client's remote address in RemoteAddress.

        If the packet was forwarded and not fragmented, we restore it to its
        original state and zap the DG_PF_FORWARDED bit.

Return Value:

    TRUE  if the packet was valid
    FALSE if it appeared malformed

--*/
{
    CORRUPTION_ASSERT( Packet->DataLength >= Packet->GetPacketBodyLen() );

    //
    // Watch for packets that might crash us.
    //
    unsigned AddressInfoLength = sizeof(REMOTE_ADDRESS_INFO)
                                + Endpoint.TransportInterface->AddressSize;

    if (Packet->DataLength < Packet->GetPacketBodyLen() ||
        Packet->DataLength - Packet->GetPacketBodyLen() < AddressInfoLength)
        {
        #ifdef DEBUGRPC
        DbgPrint("RPC DG: forwarded packet data is impossibly short\n");
        #endif
        return FALSE;
        }

    Packet->DataLength -= AddressInfoLength;

    //
    // If this is a nonfragmented packet, the endpoint info is beyond
    // the stub data and security trailer.
    //
    REMOTE_ADDRESS_INFO * pAddressInfo;

    if (Packet->Header.PacketFlags2 & DG_PF2_FORWARDED_2)
        {
        pAddressInfo = (REMOTE_ADDRESS_INFO *) Packet->Header.Data;
        }
    else
        {
        // After fixing up the length, we can treat this like a packet
        // sent directly from the client.
        //
        Packet->Header.PacketFlags &= ~DG_PF_FORWARDED;

        pAddressInfo = (REMOTE_ADDRESS_INFO *) ( Packet->Header.Data
                                               + Packet->DataLength );

        if (pAddressInfo->RemoteInfoLength != AddressInfoLength)
            {
            #ifdef DEBUGRPC
            DbgPrint("RPC DG: forwarded packet contains wrong address structure length\n");
            #endif
            return FALSE;
            }

        if (pAddressInfo != AlignPtr( pAddressInfo, REMOTE_ADDRESS_PAD ))
            {
            #ifdef DEBUGRPC
            DbgPrint("RPC DG: forwarded packet contains a misaligned address structure\n");
            #endif
            return FALSE;
            }
        }

    if (pAddressInfo->SecurityInfoPadLength > REMOTE_ADDRESS_PAD ||
        Packet->DataLength < pAddressInfo->SecurityInfoPadLength)
        {
        #ifdef DEBUGRPC
        DbgPrint("RPC DG: forwarded packet's address struct has invalid pad length\n");
        #endif
        return FALSE;
        }

    Packet->DataLength -= pAddressInfo->SecurityInfoPadLength;

    //
    // Record the client's true endpoint.
    //
    RpcpMemoryCopy(
                RemoteAddress,
                pAddressInfo->Address,
                Endpoint.TransportInterface->AddressSize
                );

    return TRUE;
}

#pragma optimize("t", on)


void
ProcessDgServerPacket(
    IN DWORD                 Status,
    IN DG_TRANSPORT_ENDPOINT LocalEndpoint,
    IN void *                PacketHeader,
    IN unsigned long         PacketLength,
    IN DatagramTransportPair *AddressPair
    )
{
    PDG_PACKET Packet = DG_PACKET::FromPacketHeader(PacketHeader);

    Packet->DataLength = PacketLength;

#ifdef INTRODUCE_ERRORS

    if (::ServerDropRate)
        {
        if ((GetRandomCounter() % 100) < ::ServerDropRate)
            {
            unsigned Frag = (Packet->Header.PacketType << 16) | Packet->Header.GetFragmentNumber();
            unsigned Uuid = *(unsigned *) &Packet->Header.ActivityId;
            unsigned Type = Packet->Header.PacketType;

            LogError(SU_PACKET, EV_DROP, (void *) Uuid, (void *) Type, Frag);

            Packet->Free();
            return;
            }
        }

    if (::ServerDelayRate)
        {
        if ((GetRandomCounter() % 100) < ::ServerDelayRate)
            {
            unsigned Frag = (Packet->Header.PacketType << 16) | Packet->Header.GetFragmentNumber();
            unsigned Uuid = *(unsigned *) &Packet->Header.ActivityId;
            unsigned Type = Packet->Header.PacketType;

            LogError(SU_PACKET, EV_DELAY, (void *) Uuid, (void *) Type, Frag);

            Sleep(::ServerDelayTime);
            }
        }

#endif

    if (Status == RPC_P_OVERSIZE_PACKET)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: async packet is too large\n");
#endif
        Packet->Flags |= DG_PF_PARTIAL;
        Status = RPC_S_OK;
        }

    if (Status != RPC_S_OK)
        {
        LogError(SU_PACKET, EV_STATUS, Packet, 0, Status);
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: async receive completed with status 0x%lx\n", Status);
#endif
        Packet->Free();
        return;
        }

    DG_ADDRESS * Address = DG_ADDRESS::FromEndpoint(LocalEndpoint);

    Address->DispatchPacket(Packet, AddressPair);
}


void
DG_ADDRESS::DispatchPacket(
    DG_PACKET * Packet,
    IN DatagramTransportPair *AddressPair
    )
{
    RPC_INTERFACE *    pRpcInterface;
    RPC_SYNTAX_IDENTIFIER   RpcIfSyntaxIdentifier;

    //
    // Mask off bits not used by X/Open or by us.
    // Notice that the current arrangement strips the extra bits before
    // forwarding, so if these bits become important the code will have to
    // be rearranged.
    //
    Packet->Header.RpcVersion   &= 0x0F;
    Packet->Header.PacketType   &= 0x1F;

    Packet->Header.PacketFlags  &= 0x7f;
    Packet->Header.PacketFlags2 &= 0x87;

    //
    // Filter out packets that clients shouldn't send.
    //
    switch (Packet->Header.PacketType)
        {
        case DG_REQUEST:
        case DG_PING:
        case DG_FACK:
        case DG_QUIT:
        case DG_ACK:
            {
            break;
            }

        default:
            {
            LogError(SU_ADDRESS, EV_PKT_IN, this, (void *) 1, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
            FreePacket(Packet);
            return;
            }
        } // switch (PacketType)

    if (Packet->Header.RpcVersion != DG_RPC_PROTOCOL_VERSION)
        {
#ifdef DEBUGRPC
        DbgPrint("dg rpc: packet %x has version %u\n", Packet, Packet->Header.RpcVersion);
        DbgPrint("  length %u\n", Packet->DataLength);

        if (Packet->DataLength > 80)
            {
            Packet->DataLength = 80;
            }

        DumpBuffer(&Packet->Header, Packet->DataLength);
#endif
        SendRejectPacket(Packet, NCA_STATUS_VERSION_MISMATCH, AddressPair->RemoteAddress);
        FreePacket(Packet);
        return;
        }

    ByteSwapPacketHeaderIfNecessary(Packet);

    //
    // Make sure the header is intact.
    // Allow a packet with truncated stub data to pass; the SCALL
    // will send a FACK-with-body to tell the client our max packet size.
    //
    if (Packet->DataLength < sizeof(NCA_PACKET_HEADER))
        {
#ifdef DEBUGRPC
        DbgPrint("dg rpc: packet %x has invalid length\n", Packet);
        DbgPrint("  length %u\n", Packet->DataLength);

        if (Packet->DataLength > 80)
            {
            Packet->DataLength = 80;
            }

        DumpBuffer(&Packet->Header, Packet->DataLength);
        RpcpBreakPoint();
#endif
        LogError(SU_ADDRESS, EV_PKT_IN, this, (void *) 2, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        FreePacket(Packet);
        return;
        }

    //
    // If we are the endpoint mapper, forward packet if necessary.
    //
    if (GlobalRpcServer->pRpcForwardFunction)
        {
        if (TRUE == ForwardPacketIfNecessary(Packet, AddressPair->RemoteAddress))
            {
            LogEvent(SU_ADDRESS, EV_PKT_IN, this, (void *) 3, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
            FreePacket(Packet);
            return;
            }
        }

    //
    // Exclude RPC header from DataLength.
    //
    Packet->DataLength -= sizeof(NCA_PACKET_HEADER);

    //
    // If the packet includes a client address trailer from the endpoint mapper,
    // remove it and stick the client address in <RemoteAddres>.
    //
    if (Packet->Header.PacketFlags & DG_PF_FORWARDED)
        {
        if (FALSE == CaptureClientAddress(Packet, AddressPair->RemoteAddress))
            {
            LogEvent(SU_ADDRESS, EV_PKT_IN, this, (void *) 4, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
            FreePacket(Packet);
            return;
            }
        }

    // Reject pkt if boot time in pkt does not match
    // the server's boot time.
    //
    if (Packet->Header.ServerBootTime != ProcessStartTime &&
        Packet->Header.ServerBootTime != 0)
        {
        if (!(Packet->Header.PacketFlags & DG_PF_MAYBE))
            {
            SendRejectPacket(Packet, NCA_STATUS_WRONG_BOOT_TIME, AddressPair->RemoteAddress);
            }

        LogError(SU_ADDRESS, EV_PKT_IN, this, (void *) 5, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        FreePacket(Packet);
        return;
        }

    //
    // sometimes OSF packets say they include security info
    // when they don't.
    //
    DeleteSpuriousAuthProto(Packet);

    //
    // Find or create a connection and then give it the packet.
    //
    DG_SCONNECTION * Connection = ServerConnections->FindOrCreate(this, Packet);

    if (!Connection)
        {
        if (Packet->Header.PacketFlags & (DG_PF_BROADCAST | DG_PF_MAYBE))
            {
            //
            // not much point sending an error packet in this case
            //
            }
        else
            {
            if (Packet->Header.PacketType == DG_REQUEST)
                {
                SendRejectPacket(Packet, RPC_S_OUT_OF_MEMORY, AddressPair->RemoteAddress);
                }
            else
                {
                CleanupPacket(&Packet->Header);
                Packet->Header.PacketType    = DG_NOCALL;
                Packet->SetPacketBodyLen(0);
                Packet->SetFragmentNumber(0xffff);
                SetSerialNumber( &Packet->Header, 0);
                SendPacketBack( &Packet->Header, 0, AddressPair->RemoteAddress);
                }
            }

        LogError(SU_ADDRESS, EV_PKT_IN, this, (void *) 6, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        FreePacket(Packet);
        return;
        }

    Connection->DispatchPacket(Packet, AddressPair);

    ServerConnections->Prune();
}

#pragma optimize("", on)


PDG_SCONNECTION
DG_ADDRESS::AllocateConnection(
    )
/*++

Routine Description:

    Allocates a new DG_SCONNECTION from the cache or from the heap.

Arguments:

    none

Return Value:

    the call

--*/

{
    PDG_SCONNECTION Connection;

    AddressMutex.Request();

    UUID_HASH_TABLE_NODE * Node = CachedConnections;

    if (Node)
        {
        CachedConnections = Node->pNext;

        AddressMutex.Clear();

        Connection = DG_SCONNECTION::FromHashNode(Node);
        }
    else
        {
        AddressMutex.Clear();

        RPC_STATUS Status = RPC_S_OK;

        Connection = new DG_SCONNECTION(this, &Status);

        if (!Connection)
            {
            return 0;
            }

        if (Status != RPC_S_OK)
            {
            delete Connection;
            return 0;
            }
        }

    LogEvent(SU_SCONN, EV_START, Connection, this);

    return Connection;
}


void
DG_ADDRESS::FreeConnection(
    PDG_SCONNECTION Connection
    )
/*++

Routine Description:

    Returns an unused DG_SCONNECTION to the cache or the heap.

Arguments:

    the connection

Return Value:

    none

--*/

{
    AddressMutex.Request();

    if (CachedConnections)
        {
        AddressMutex.Clear();
        delete Connection;
        return;
        }
    else
        {
        CachedConnections = &Connection->ActivityNode;
        Connection->ActivityNode.pNext = 0;
        AddressMutex.Clear();
        return;
        }

    AddressMutex.Request();

    Connection->ActivityNode.pNext = CachedConnections;

    CachedConnections = &Connection->ActivityNode;

    AddressMutex.Clear();
}


DG_SCALL::DG_SCALL(
    DG_ADDRESS * Address,
    RPC_STATUS * pStatus
    ) :
    DG_PACKET_ENGINE(DG_RESPONSE, Address->AllocatePacket(), pStatus),
    Connection      (0),
    PipeWaitEvent   (0),
    PipeWaitType    (PWT_NONE),
    PipeThreadId    (0),
    State           (CallInit),
    pCachedSid      (0),
    pwsCachedUserName(0),
    dwCachedUserNameSize(0)

/*++

Routine Description:

    This is the constructor for the DG_SCALL class. This class represents a
    call in progress on a server.

Arguments:

    pAddress - The address this call is taking place on.
    pStatus - Where to put a construction error code.

--*/
{
#ifdef MONITOR_SERVER_PACKET_COUNT
    OutstandingPacketCount = 0;
#endif

    DispatchBuffer = 0;

    LogEvent(SU_SCALL, EV_CREATE, this, Address);
    ObjectType = DG_SCALL_TYPE;

    InterlockedIncrement(&ServerCallCount);

    if (*pStatus)
        {
        return;
        }

    SourceEndpoint = &Address->Endpoint;
}


BOOL
DG_SCALL::Cleanup()
{
    if (ReferenceCount)
        {
        LogEvent(SU_SCALL, EV_CLEANUP, this, 0, ReferenceCount);

        ASSERT( State != CallComplete && State != CallInit );
        return FALSE;
        }

    if (pAsync)
        {
        DoPostDispatchProcessing();
        }

    switch (State)
        {
        case CallBeforeDispatch:
        case CallDispatched:

            CleanupReceiveWindow();

        case CallSendingResponse:

            RPC_MESSAGE Message;

            CleanupSendWindow();

            Message.Buffer = DispatchBuffer;
            Message.ReservedForRuntime = 0;
            FreeBuffer(&Message);

            ASSERT( !DispatchBuffer );

            if (Privileges)
                {
                ASSERT( Connection->ActiveSecurityContext );

                Connection->ActiveSecurityContext->DeletePac( Privileges );
                Privileges = 0;
                }

            if (Interface->IsAutoListenInterface())
                {
                Connection->pAddress->EndAutoListenCall();
                }

            Connection->pAddress->DecrementActiveCallCount();

            if (pAsync)
                {
                Interface->EndCall(0, 1);
                if (Interface->IsAutoListenInterface())
                    {
                    // This is the path where async calls complete.
                    // We need to decrement CallNumber.
                    Interface->EndAutoListenCall(TRUE);
                    }
                }

            Cancelled = FALSE;

            ASSERT( PipeWaitType == PWT_NONE );

            PipeThreadId = 0;

        case CallInit:

            if ( LastReceiveBuffer )
                {
                RPC_MESSAGE Message;

                Message.Buffer = LastReceiveBuffer;
                Message.ReservedForRuntime = 0;
                FreeBuffer(&Message);
                }

#ifdef MONITOR_SERVER_PACKET_COUNT
            ASSERT( OutstandingPacketCount == 0 );
#endif
            Connection->FreeCall(this);
            SetState(CallComplete);
            break;

        case CallComplete:
            {
            LogEvent(SU_SCALL, EV_CLEANUP, this, 0, CallComplete);
            break;
            }

        default:
            {
            LogEvent(SU_SCALL, EV_CLEANUP, this, 0, State);
#ifdef DEBUGRPC
            DbgPrint("RPC: process %x bad call state %x in DG_SCALL::Cleanup\n",
                     GetCurrentProcessId(), State);
#endif
            }
        }

    return TRUE;
}


inline BOOL
DG_SCALL_TABLE::Add(
    PDG_SCALL     Call,
    unsigned long Sequence
    )
{
    //
    // Add the call to the end of the active call list.
    //
    Call->Next = 0;
    Call->Previous = ActiveCallTail;

    if (ActiveCallHead)
        {
        ASSERT( Call->GetSequenceNumber() > ActiveCallTail->GetSequenceNumber() );

        ActiveCallTail->Next = Call;
        }
    else
        {
        ActiveCallHead = Call;
        }

    ActiveCallTail = Call;

    return TRUE;
}

inline void
DG_SCALL_TABLE::Remove(
    PDG_SCALL Call
    )
{
    LogEvent(SU_SCALL, EV_REMOVED, Call, this);

    if (Call->Previous)
        {
        ASSERT( ActiveCallHead != Call );
        Call->Previous->Next = Call->Next;
        }
    else
        {
        ASSERT( ActiveCallHead == Call );
        ActiveCallHead = Call->Next;
        }

    if (Call->Next)
        {
        ASSERT( ActiveCallTail != Call );
        Call->Next->Previous = Call->Previous;
        }
    else
        {
        ASSERT( ActiveCallTail == Call );
        ActiveCallTail = Call->Previous;
        }

    Call->Next = 0;
    Call->Previous = 0;
}


inline PDG_SCALL
DG_SCALL_TABLE::Successor(
    PDG_SCALL Call
    )
{
//    ASSERT( Call == Find(Call->SequenceNumber) );

    return Call->Next;
}


inline PDG_SCALL
DG_SCALL_TABLE::Find(
    unsigned long Sequence
    )
{
    PDG_SCALL Call;

    for (Call = ActiveCallHead; Call; Call = Call->Next)
        {
        if (Call->GetSequenceNumber() == Sequence)
            {
            return Call;
            }

        if (Call->GetSequenceNumber() > Sequence)
            {
            return NULL;
            }
        }

    return NULL;
}


inline PDG_SCALL
DG_SCALL_TABLE::Predecessor(
    unsigned long Sequence
    )
{
    PDG_SCALL Call, Previous = 0;

    for (Call = ActiveCallHead; Call; Call = Call->Next)
        {
        if (Call->GetSequenceNumber() >= Sequence)
            {
            break;
            }

        Previous = Call;
        }

    return Previous;
}


inline void
DG_SCALL_TABLE::RemoveIdleCalls(
    BOOL            Aggressive,
    RPC_INTERFACE * Interface
    )
{
    PDG_SCALL Call;

    for (Call = ActiveCallHead; Call; )
        {
        ASSERT( !Call->InvalidHandle(DG_SCALL_TYPE) );

        PDG_SCALL Next = Call->Next;

        // If the call has in fact expired, it will be removed from this list
        // and added to the connection's cached call list.
        //
        Call->HasExpired( Aggressive, Interface );

        Call = Next;
        }
}


DG_SCONNECTION::DG_SCONNECTION(
    DG_ADDRESS * a_Address,
    RPC_STATUS * pStatus
    ) :
    DG_COMMON_CONNECTION(a_Address->Endpoint.TransportInterface, pStatus),
    pAddress            (a_Address),
    pAssocGroup         (0),
    CachedCalls         (0),
    LastInterface       (0),
    CurrentCall         (0),
    MaxKeySeq           (0),
    fFirstCall          (0),
    BlockIdleCallRemoval(0),
    pMessageMutex       (0)
{
    LogEvent(SU_SCONN, EV_CREATE, this, a_Address);
    ObjectType = DG_SCONNECTION_TYPE;
    fFirstCall = 0;
    InterlockedIncrement(&ServerConnectionCount);
}


DG_SCONNECTION::~DG_SCONNECTION()
{
    InterlockedDecrement(&ServerConnectionCount);
    delete CachedCalls;

    if (pMessageMutex)
        {
        delete pMessageMutex;
        }
}


void
DG_SCONNECTION::Activate(
    PNCA_PACKET_HEADER pHeader,
    unsigned short NewHash
    )
{
    AuthInfo.AuthenticationService = pHeader->AuthProto;
    if (AuthInfo.AuthenticationService)
        {
        DG_SECURITY_TRAILER * pVerifier = (DG_SECURITY_TRAILER *)
                     (pHeader->Data + pHeader->GetPacketBodyLen());

        AuthInfo.AuthenticationLevel   = pVerifier->protection_level;
        AuthInfo.AuthorizationService  = 0;
        AuthInfo.ServerPrincipalName   = 0;
        AuthInfo.PacHandle             = 0;
        }
    else
        {
        AuthInfo.AuthenticationLevel   = RPC_C_AUTHN_LEVEL_NONE;
        AuthInfo.AuthorizationService  = RPC_C_AUTHZ_NONE;
        AuthInfo.ServerPrincipalName   = 0;
        AuthInfo.PacHandle             = 0;
        }

    ActivityNode.Initialize(&pHeader->ActivityId);
    ActivityHint = NewHash;

    LogEvent( SU_SCONN, EV_START, this, IntToPtr(pHeader->ActivityId.Data1), ActivityHint );

    PDG_SCALL Call;

    for (Call = CachedCalls; Call; Call = Call->Next)
        {
        Call->BindToConnection(this);
        }

    Callback.State       = NoCallbackAttempted;
    MaxKeySeq            = 0;
    LowestActiveSequence = 0;
    LowestUnusedSequence = 0;

    TimeStamp = GetTickCount();
}


void
DG_SCONNECTION::Deactivate(
    )
{
    LogEvent(SU_SCONN, EV_STOP, this, pAddress);

    ASSERT( !CurrentCall );

    while (CachedCalls && CachedCalls->Next)
        {
        PDG_SCALL Call = CachedCalls;
        CachedCalls = Call->Next;
        delete Call;
        }

    for (unsigned u = 0; u <= MaxKeySeq; ++u)
        {
        delete SecurityContextDict.Delete(u);
        }

    //
    // Delete all previous interface callback results.
    //
    DictionaryCursor cursor;
    InterfaceCallbackResults.Reset(cursor);
    while (InterfaceCallbackResults.Next(cursor, TRUE))
        ;

    ActiveSecurityContext = 0;

    if (pAssocGroup)
        {
        AssociationGroups->DecrementRefCount(pAssocGroup);
        pAssocGroup = 0;
        }

    pAddress->FreeConnection(this);
}


PDG_SCALL
DG_SCONNECTION::AllocateCall()
{
    PDG_SCALL Call = 0;

    if (CachedCalls)
        {
        Call = CachedCalls;
        CachedCalls = CachedCalls->Next;

        ASSERT( !Call->InvalidHandle(DG_SCALL_TYPE) );
        ASSERT( !CachedCalls || !CachedCalls->InvalidHandle(DG_SCALL_TYPE) );
        }
    else
        {
        RPC_STATUS Status = RPC_S_OK;

        Call = new (pAddress->Endpoint.TransportInterface) DG_SCALL(pAddress, &Status);
        if (!Call)
            {
            return 0;
            }

        if (Status)
            {
            delete Call;
            return 0;
            }

        Call->BindToConnection(this);
        }

    //
    // Allow ACTIVE_CALL_TABLE::Remove to succeed even if the call is not in the table.
    //
    Call->Next = Call;
    Call->Previous = Call;

    IncrementRefCount();

    return Call;
}


void
DG_SCONNECTION::FreeCall(
    PDG_SCALL Call
    )
{
    DecrementRefCount();

    if (CurrentCall == Call)
        {
        CurrentCall = ActiveCalls.Successor(Call);
        }

    if (Call->GetSequenceNumber() == LowestActiveSequence)
        {
        PDG_SCALL Successor = ActiveCalls.Successor(Call);

        if (Successor)
            {
            LowestActiveSequence = Successor->GetSequenceNumber();
            }
        else
            {
            LowestActiveSequence = LowestUnusedSequence;
            }
        }

    ActiveCalls.Remove(Call);
    AddCallToCache(Call);
}

void
DG_SCALL::NewCall(
    PDG_PACKET            a_Packet,
    DatagramTransportPair *AddressPair
    )
{
    ASSERT( State == CallInit || State == CallComplete );
    ASSERT( DispatchBuffer == 0 );

    SetState(CallInit);

    SequenceNumber = a_Packet->Header.SequenceNumber;

    pSavedPacket->Header.ObjectId       = a_Packet->Header.ObjectId;
    pSavedPacket->Header.SequenceNumber = SequenceNumber;
    pSavedPacket->Header.PacketFlags    = 0;

    // Initialize the fields that may remain unused so that we do not send
    // back stale data.  Even though these values will be ignored, revealing
    // the contents of server's memory present a security threat.
    RpcpMemorySet(&pSavedPacket->Header.InterfaceId, 0, sizeof(RPC_UUID));
    RpcpMemorySet(&pSavedPacket->Header.InterfaceVersion, 0, sizeof(RPC_VERSION));
    pSavedPacket->Header.OperationNumber = 0;

    BasePacketFlags = 0;

    DG_PACKET_ENGINE::NewCall();

    RpcpMemoryCopy(RemoteAddress, AddressPair->RemoteAddress, Connection->TransportInterface->AddressSize);
    LocalAddress = *(DWORD *)AddressPair->LocalAddress;

    if ((a_Packet->Header.PacketFlags2 & DG_PF2_FORWARDED_2)  &&
        (a_Packet->Header.PacketFlags  & DG_PF_FORWARDED) == 0)
        {
        KnowClientAddress = FALSE;
        }
    else
        {
        KnowClientAddress = TRUE;
        }

    CallWasForwarded  = FALSE;
    CallInProgress    = FALSE;
    Privileges        = 0;
    CancelEventId     = 0;
    pAsync            = 0;

    FinalSendBufferPresent = FALSE;
}


DG_SCALL::~DG_SCALL()
/*++

Routine Description:

    Destructor for the DG_SCALL object.

Arguments:

    <None>

Return Value:

    <None>

--*/
{
#ifdef MONITOR_SERVER_PACKET_COUNT
    ASSERT( OutstandingPacketCount == 0 );
#endif

    InterlockedDecrement(&ServerCallCount);

    delete PipeWaitEvent;
    PipeWaitEvent = 0;

    if (pCachedSid)
       {
       I_RpcFree(pCachedSid);
       }

    if (pwsCachedUserName)
       {
       I_RpcFree(pwsCachedUserName);
       }
}

RPC_STATUS
DG_SCALL::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
{
    // this can happen in the callback case only.
    // Datagrams don't really support multiple transfer
    // syntaxes. Return whatever the stub wants, which is
    // already recorded in the transfer syntax field

    return RPC_S_OK;
}


RPC_STATUS
DG_SCALL::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )

/*++

Routine Description:

    This routine is called by the stub to allocate space. This space is to
    be used for output arguments.
    If these args fit into a single packet, then use the first packet
    on the to-be-deleted list.


Arguments:

    Message - The RPC_MESSAGE structure associated with this call.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY

--*/
{
    LogEvent(SU_SCALL, EV_PROC, this, IntToPtr(Message->BufferLength), 'G' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));

    RPC_STATUS Status = CommonGetBuffer(Message);

    LogEvent(SU_SCALL, EV_BUFFER_OUT, this, Message->Buffer, (Message->RpcFlags << 4) | Message->BufferLength);
    if (Status)
        {
        LogError(SU_SCALL, EV_STATUS, this, 0, Status);
        }

#ifdef MONITOR_SERVER_PACKET_COUNT
    DG_PACKET::FromStubData(Message->Buffer)->pCount = &OutstandingPacketCount;
    InterlockedIncrement( &OutstandingPacketCount );
    LogEvent( SU_SCALL, '(', this, DG_PACKET::FromStubData(Message->Buffer), OutstandingPacketCount );
#endif

    return Status;
}


void
DG_SCALL::FreeBuffer (
    IN PRPC_MESSAGE Message
    )

/*++

Routine Description:

    This routine is called to free up the marshalled data after the stub
    is through with it.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call

Return Value:

    <none>
--*/

{
    LogEvent(SU_SCALL, EV_PROC,      this, Message, 'F' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));
    LogEvent(SU_SCALL, EV_BUFFER_IN, this, Message->Buffer, Message->BufferLength);

    if (Message->Buffer)
        {
        if (Message->Buffer == DispatchBuffer)
            {
            DispatchBuffer = 0;
            }

        // The ReservedForRuntime field is a local variable of ProcessRpcCall,
        // so it is valid only during dispatch.
        //
        if (State == CallDispatched && Message->ReservedForRuntime)
            {
            PRPC_RUNTIME_INFO Info = (PRPC_RUNTIME_INFO) Message->ReservedForRuntime;
            if (Message->Buffer == Info->OldBuffer)
                {
                Info->OldBuffer = 0;
                }
            }
        CommonFreeBuffer(Message);
        }
}


RPC_STATUS
DG_SCALL::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    This routine is called for a user-level callback.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY

Revision History:

--*/

{
    Message->ReservedForRuntime = 0;
    FreeBuffer(Message);

    return RPC_S_CALL_FAILED;
}

#pragma optimize("t", on)


void
DG_SCONNECTION::DispatchPacket(
    IN DG_PACKET *           Packet,
    IN DatagramTransportPair *AddressPair
    )
/*++

Routine Description:

    Once a packet's activity UUID is known, this fn dispatches the packet
    to the appropriate DG_SCALL, creating one if necessary.

Arguments:

    Packet        - the packet to dispatch
    AddressPair   - the remote/local address that sent/received the packet

--*/
{
    PNCA_PACKET_HEADER pHeader = &Packet->Header;

#ifdef DEBUGRPC

    RPC_UUID * pInActivityUuid = &pHeader->ActivityId;

    ASSERT(0 == ActivityNode.CompareUuid(pInActivityUuid));

#endif

    TimeStamp = GetTickCount();

    //
    // Make sure the security info is consistent.
    //
    if (AuthInfo.AuthenticationService != pHeader->AuthProto)
        {
        if (pHeader->PacketType != DG_PING &&
            (0 == (pHeader->PacketFlags & DG_PF_MAYBE) || pHeader->AuthProto))
            {
            LogError(SU_SCONN, EV_PKT_IN, this, (void *) 10, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
#ifdef DEBUGRPC
            DbgPrint("dg rpc: %lx dropping %u whose auth service %u is inconsistent w/the activity %u\n",
                      GetCurrentProcessId(), pHeader->PacketType, pHeader->AuthProto, AuthInfo.AuthenticationService);
#endif
            Mutex.Clear();
            Packet->Free();
            return;
            }
        }
    else if (pHeader->AuthProto)
        {
        DG_SECURITY_TRAILER * Verifier = (DG_SECURITY_TRAILER *)
                     (Packet->Header.Data + Packet->GetPacketBodyLen());

        if (Verifier->protection_level != AuthInfo.AuthenticationLevel)
            {
            LogError(SU_SCONN, EV_PKT_IN, this, (void *) 11, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
#ifdef DEBUGRPC
            DbgPrint("dg rpc: %lx dropping pkt whose auth level is inconsistent with the activity\n", GetCurrentProcessId());
#endif
            Mutex.Clear();
            Packet->Free();
            return;
            }
        }

    //
    // Sanity-check the packet length.
    //
    if (0 == (Packet->Flags & DG_PF_PARTIAL))
        {
        if (pHeader->AuthProto)
            {
            if (Packet->DataLength < Packet->GetPacketBodyLen() + sizeof(DG_SECURITY_TRAILER))
                {
                #ifdef DEBUGRPC
                DbgPrint("dg rpc: secure packet truncated from at least %lu to %lu\n",
                         Packet->GetPacketBodyLen() + sizeof(DG_SECURITY_TRAILER), Packet->DataLength);
                #endif

                Mutex.Clear();

                LogError(SU_SCONN, EV_PKT_IN, this, (void *) 8, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                Packet->Free();
                return;
                }
            }
        else
            {
            if (Packet->DataLength < Packet->GetPacketBodyLen())
                {
#ifdef DEBUGRPC
                DbgPrint("dg rpc: packet truncated from %lu to %lu\n", Packet->GetPacketBodyLen(), Packet->DataLength);
#endif
                Mutex.Clear();
                LogError(SU_SCONN, EV_PKT_IN, this, (void *) 9, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                Packet->Free();
                return;
                }
            }
        }

    //
    // [maybe] and [broadcast] calls should be [idempotent].
    //
    if (((pHeader->PacketFlags & DG_PF_MAYBE) || (pHeader->PacketFlags & DG_PF_BROADCAST)) &&
        !(pHeader->PacketFlags & DG_PF_IDEMPOTENT))
        {
        Mutex.Clear();
        LogEvent(SU_SCONN, EV_PKT_IN, this, (void *) 0, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        Packet->Free();
        return;
        }

    //
    // [maybe] calls require little of our advanced technology.
    //
    if (pHeader->PacketFlags & DG_PF_MAYBE)
        {
        if (HandleMaybeCall(Packet, AddressPair))
            {
            // mutex released in HandleMaybeCall.
            return;
            }
        }

    //
    // Calls below LowestActiveSequence are dead.
    //
    if (pHeader->SequenceNumber < LowestActiveSequence)
        {
        Mutex.Clear();
        LogEvent(SU_SCONN, EV_PKT_IN, this, (void *) 0, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        Packet->Free();
        return;
        }

    //
    // Find or allocate the DG_SCALL for this packet.
    //
    PDG_SCALL Call = 0;

    if (pHeader->SequenceNumber < LowestUnusedSequence)
        {
        Call = ActiveCalls.Find(pHeader->SequenceNumber);
        if (!Call)
            {
            Mutex.Clear();
            LogError(SU_SCONN, EV_PKT_IN, this, (void *) 1, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
            Packet->Free();
            return;
            }
        }
    else
        {
        Call = HandleNewCall(Packet, AddressPair);
        if (!Call)
            {
            Mutex.Clear();
            Packet->Free();
            return;
            }
        }

    Mutex.VerifyOwned();

    Call->DispatchPacket(Packet, AddressPair->RemoteAddress);

    CallDispatchLoop();

    Mutex.Clear();

    Mutex.VerifyNotOwned();
}


void
DG_SCONNECTION::CallDispatchLoop()
{
    Mutex.VerifyOwned();

    //
    // The loop below is to handle the case where a bunch of async calls arrive
    // more or less simultaneously.  When stub #1 has finished, we should
    // dispatch stub #2 immediately instead of waiting for the client to ping.
    //
    while (CurrentCall && CurrentCall->ReadyToDispatch() &&
           (Callback.State == CallbackSucceeded  ||
            Callback.State == NoCallbackAttempted ))
        {
        PDG_SCALL Call = CurrentCall;

        Call->ProcessRpcCall();

        // After we are done processing the call we should
        // clear EEInfo record before moving on to the next one.
        // This prevent eeinfo from building up.
        RpcpPurgeEEInfo();

        if (CurrentCall == Call)
            {
            CurrentCall = ActiveCalls.Successor(Call);
            }
        }

    Mutex.VerifyOwned();
}


PDG_SCALL
DG_SCONNECTION::HandleNewCall(
    IN DG_PACKET *           Packet,
    IN DatagramTransportPair *AddressPair
    )
{
    PDG_SCALL Call = 0;

    PNCA_PACKET_HEADER pHeader = &Packet->Header;

    //
    // Only a REQUEST can instantiate a new call.
    //
    if (pHeader->PacketType != DG_REQUEST)
        {
        LogError(SU_SCONN, EV_PKT_IN, this, (void *) 2, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());

        CleanupPacket(&Packet->Header);

        Packet->Header.PacketType = DG_NOCALL;

        Packet->SetPacketBodyLen(0);
        Packet->SetFragmentNumber(0xffff);

        SealAndSendPacket( &pAddress->Endpoint,
                           AddressPair->RemoteAddress,
                           &Packet->Header,
                           0
                           );
        return 0;
        }

    if ((Packet->Header.PacketFlags  & DG_PF_FORWARDED) &&
        (Packet->Header.PacketFlags2 & DG_PF2_FORWARDED_2) == 0)
        {
        //
        // This packet is not a true request.
        //
        LogError(SU_SCONN, EV_PKT_IN, this, (void *) 3, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        return 0;
        }

    //
    // See if the call closes a previous call.
    //
    if (0 == (pHeader->PacketFlags2 & DG_PF2_UNRELATED))
        {
        PDG_SCALL PreviousCall = ActiveCalls.Predecessor(pHeader->SequenceNumber);

        if (PreviousCall)
            {
            PreviousCall->FinishSendOrReceive(TRUE);
            PreviousCall->Cleanup();
            }
        }

    LowestUnusedSequence = pHeader->SequenceNumber + 1;

    //
    // Prepare a DG_SCALL to handle the packet.
    //
    Call = AllocateCall();
    LogEvent(SU_SCALL, EV_START, Call, this, pHeader->SequenceNumber);

    if (!Call)
        {
        LogError(SU_SCONN, EV_PKT_IN, this, (void *) 4, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        pAddress->SendRejectPacket(Packet, RPC_S_OUT_OF_MEMORY, AddressPair->RemoteAddress);
        return 0;
        }

    Call->NewCall(Packet, AddressPair);

    if (FALSE == ActiveCalls.Add(Call, pHeader->SequenceNumber))
        {
        AddCallToCache(Call);
        LogError(SU_SCONN, EV_PKT_IN, this, (void *) 5, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        pAddress->SendRejectPacket(Packet, RPC_S_OUT_OF_MEMORY, AddressPair->RemoteAddress);
        return 0;
        }

    if (!CurrentCall)
        {
        CurrentCall = Call;
        }

    return Call;
}

#pragma optimize("", on)


BOOL
DG_SCONNECTION::HandleMaybeCall(
    IN DG_PACKET *           Packet,
    IN DatagramTransportPair *AddressPair
    )
{
    PNCA_PACKET_HEADER pHeader = &Packet->Header;

    if (pHeader->PacketType != DG_REQUEST)
        {
        Mutex.Clear();
        Packet->Free();
        return TRUE;
        }

    if (!(pHeader->PacketFlags  & DG_PF_FORWARDED) &&
        !(pHeader->PacketFlags2 & DG_PF2_FORWARDED_2) )
        {
        DG_SCALL * Call = AllocateCall();

        LogEvent(SU_SCALL, EV_START, Call, this, pHeader->SequenceNumber);

        if (!Call)
            {
            Mutex.Clear();
            Packet->Free();
            return TRUE;
            }

        Call->NewCall(Packet, AddressPair);


        Call->DealWithRequest( Packet );

        if (Call->ReadyToDispatch())
            {
            Call->ProcessRpcCall();
            }

        BOOL Result = Call->Cleanup();
        ASSERT( Result );

        Mutex.Clear();
        return TRUE;
        }

    //
    // [maybe] calls fragmented by the ep mapper go through the normal route
    //
    return FALSE;
}


BOOL
DG_SCALL::ReadyToDispatch(
    )
{
    BOOL fReadyToDispatch = FALSE;

    //
    // Before we can execute the call, we need the client's true endpoint,
    // for a forwarded call.  For a non-idempotent call we also need a
    // successful callback.
    //
    // For a stub in a pipes interface, we need only fragment zero;
    // for ordinary interfaces we need all the fragments.
    //
    if (KnowClientAddress && State == CallBeforeDispatch)
        {
        //
        // See if we are ready to dispatch to the stub.
        //
        if (Interface->IsPipeInterface())
            {
            if (pReceivedPackets && 0 == pReceivedPackets->GetFragmentNumber())
                {
                fReadyToDispatch = TRUE;
                }
            }
        else
            {
            if (fReceivedAllFragments)
                {
                fReadyToDispatch = TRUE;
                }
            }
        }

    //
    // Make sure the callback succeeded.
    //
    if (fReadyToDispatch)
        {
        if (0 == (pReceivedPackets->Header.PacketFlags & DG_PF_IDEMPOTENT) &&
            !Connection->pAssocGroup)
            {
            fReadyToDispatch = FALSE;
            }
        }

    return fReadyToDispatch;
}

#pragma optimize("t", on)


void
DG_SCALL::DispatchPacket(
    IN PDG_PACKET Packet,
    IN DG_TRANSPORT_ADDRESS a_RemoteAddress
    )
{
#ifdef MONITOR_SERVER_PACKET_COUNT
    if (Packet->Header.PacketType == DG_REQUEST)
        {
        InterlockedIncrement( &OutstandingPacketCount );
        Packet->pCount = &OutstandingPacketCount;
        LogEvent( SU_SCALL, '(', this, Packet, OutstandingPacketCount );
        }
#endif

    TimeStamp = GetTickCount();

    if (State == CallInit &&
        Packet->Header.PacketType != DG_REQUEST)
        {
        LogError(SU_SCALL, EV_PKT_IN, this, (void *) 1, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        if (KnowClientAddress)
            {
            SendFackOrNocall(Packet, DG_NOCALL);
            }

        FreePacket(Packet);
        return;
        }

    if (State == CallComplete)
        {
        LogEvent(SU_SCALL, EV_PKT_IN, this, (void *) 2, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        FreePacket(Packet);
        return;
        }

    //
    // FORWARDED    FORWARDED_2     Meaning
    // ---------    -----------     -------
    //    no            no          packet sent directly from client
    //    yes           no          packet forwarded by ep mapper (with DREP/ep trailer)
    //    no            yes         packet data forwarded by ep mapper (no trailer)
    //    yes           yes         sent from ep mapper; contains only the DREP/ep trailer
    //
    if (Packet->Header.PacketFlags2 & DG_PF2_FORWARDED_2)
        {
        CallWasForwarded = TRUE;

        if (Packet->Header.PacketFlags & DG_PF_FORWARDED)
            {
            if (!KnowClientAddress)
                {
                //
                // Record the client's true endpoint.
                //
                RpcpMemoryCopy(
                            RemoteAddress,
                            a_RemoteAddress,
                            Connection->pAddress->Endpoint.TransportInterface->AddressSize
                            );

                KnowClientAddress = TRUE;
                }

            LogEvent(SU_SCALL, EV_PKT_IN, this, (void *) 3, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());

            FreePacket(Packet);
            return;
            }
        }
    else
        {
        ASSERT( (Packet->Header.PacketFlags & DG_PF_FORWARDED) == 0 );
        }

    LogEvent(SU_SCALL, EV_PKT_IN, this, 0, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());

    switch (Packet->Header.PacketType)
        {
        case DG_REQUEST:    DealWithRequest (Packet);  break;
        case DG_PING:       DealWithPing    (Packet);  break;
        case DG_FACK:       DealWithFack    (Packet);  break;
        case DG_QUIT:       DealWithQuit    (Packet);  break;
        case DG_ACK:        DealWithAck     (Packet);  break;
        default:
            {
            FreePacket(Packet);
            FinishSendOrReceive(TRUE);
            Cleanup();
            }
        }
}

#pragma optimize("", on)


void
DG_SCALL::DealWithPing(
    PDG_PACKET pPacket
    )
/*++

Routine Description:

    Figures out what to do with a PING packet.  It may send a WORKING
    or NOCALL packet, or retransmit response fragments.

Arguments:

    pPacket - the PING packet

Return Value:

    none

--*/
{
    //
    // Ignore security trailer.  The only way extra PINGs can hose me is by
    // chewing up CPU, and authenticating would only make it worse.
    //

    NCA_PACKET_HEADER * pHeader = &pPacket->Header;

    unsigned PacketSeq = pHeader->SequenceNumber;

    unsigned short Serial = ReadSerialNumber(&pPacket->Header);
    if (Serial < ReceiveSerialNumber)
        {
        FreePacket(pPacket);
        return;
        }

    ReceiveSerialNumber = Serial;

    switch (State)
        {
        case CallInit:
            {
            SendFackOrNocall(pPacket, DG_NOCALL);
            break;
            }

        case CallBeforeDispatch:
        case CallDispatched:
        case CallAfterDispatch:
            {
            if (fReceivedAllFragments)
                {
                pHeader->PacketType = DG_WORKING;
                pHeader->SetPacketBodyLen(0);

                SealAndSendPacket(pHeader);
                }
            else
                {
                SendFackOrNocall(pPacket, DG_FACK);
                }
            break;
            }

        case CallSendingResponse:
            {
            SendSomeFragments();
            break;
            }

        case CallComplete:
            {
            break;
            }

        default:
            {
            ASSERT(0 && "invalid call state");
            }
        }

    FreePacket(pPacket);
}


RPC_STATUS
DG_SCONNECTION::VerifyNonRequestPacket(
    DG_PACKET * Packet
    )
{
    if (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        if (AuthInfo.AuthenticationService != RPC_C_AUTHN_DCE_PRIVATE )
            {
            SECURITY_CONTEXT * Context = FindMatchingSecurityContext(Packet);

            if (!Context)
                {
                LogError(SU_SCONN, EV_STATUS, this, (void *) 110, RPC_S_ACCESS_DENIED );
                return RPC_S_ACCESS_DENIED;
                }

            return VerifySecurePacket(Packet, Context);
            }
        }

    return RPC_S_OK;
}


RPC_STATUS
DG_SCONNECTION::VerifyRequestPacket(
    DG_PACKET * Packet
    )
{
    if (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        SECURITY_CONTEXT * Context = FindMatchingSecurityContext(Packet);

        if (!Context)
            {
            LogError(SU_SCONN, EV_STATUS, this, (void *) 111, RPC_S_ACCESS_DENIED );
            return RPC_S_ACCESS_DENIED;
            }

        return VerifySecurePacket(Packet, Context);
        }

    return RPC_S_OK;
}


void
DG_SCALL::DealWithQuit(
    PDG_PACKET pPacket
    )
/*++

Routine Description:

    Handles a QUIT packet:

    - If the cancel event ID is new, we cancel the current call and send a QUACK.
    - If the event ID is the current one, we retransmit the QUACK.
    - If the event ID is older than the current one, we ignore the packet.

Arguments:

    the packet

Return Value:

    none

--*/
{
    if (RPC_S_OK != Connection->VerifyNonRequestPacket(pPacket))
        {
        FreePacket(pPacket);
        return;
        }

    QUIT_BODY_0 * pBody = (QUIT_BODY_0 *) pPacket->Header.Data;

    if (pPacket->GetPacketBodyLen() < sizeof(QUIT_BODY_0) ||
        pBody->Version != 0)
        {
#ifdef DEBUGRPC
        DbgPrint("RPC DG: unknown quit format: version 0x%lx, length 0x%hx\n",
                 pBody->Version, pPacket->GetPacketBodyLen()
                 );
#endif

        FreePacket(pPacket);
        return;
        }

    if (pBody->EventId > CancelEventId)
        {
        CancelEventId = pBody->EventId;
        Cancel(0);
        }

    if (pBody->EventId == CancelEventId)
        {
        pSavedPacket->Header.PacketType     = DG_QUACK;
        pSavedPacket->Header.SequenceNumber = SequenceNumber;
        pSavedPacket->SetPacketBodyLen(sizeof(QUACK_BODY_0));

        QUACK_BODY_0 * pAckBody = (QUACK_BODY_0 *) pSavedPacket->Header.Data;

        pAckBody->Version  = 0;
        pAckBody->EventId = CancelEventId;

        //
        // If the app has picked up the cancel notification, set Accepted == TRUE.
        // This is likely only if the QUIT was  retransmitted.
        //
        if (Cancelled)
            {
            pAckBody->Accepted = FALSE;
            }
        else
            {
            pAckBody->Accepted = TRUE;
            }

        SealAndSendPacket(&pSavedPacket->Header);
        }
    else
        {
#ifdef DEBUGRPC
        DbgPrint("RPC DG: stale cancel event id %lu\n", pBody->EventId);
#endif
        }

    FreePacket(pPacket);
}


void
DG_SCALL::DealWithAck(
    PDG_PACKET pPacket
    )
/*++

Routine Description:

    Figures out what to do with an ACK packet.
    It turns off the fragment-retransmission timer.

Arguments:

    pPacket - the ACK packet

Return Value:

    none

--*/

{
    if (State == CallSendingResponse)
        {
        //
        // Accept only an authenticated ACK if the call is secure.
        //
        // Sometimes OSF clients will omit the sec trailer from the ACK.
        //
        if (RPC_S_OK != Connection->VerifyNonRequestPacket(pPacket))
            {
            FreePacket(pPacket);
            return;
            }

        FinishSendOrReceive(FALSE);
        Cleanup();
        }

    FreePacket(pPacket);
}


void
DG_SCALL::DealWithFack(
    PDG_PACKET pPacket
    )
/*++

Routine Description:

    Figures out what to do with a FACK packet.
    If there is more data to send, it sends the next fragment
    and restarts the fragment-retransmission timer.

Arguments:

    pPacket - the packet

Return Value:

    none

--*/
{
    BOOL Ignore;

    // is call finished?
    if (State != CallSendingResponse)
        {
        FreePacket(pPacket);
        return;
        }

    if (RPC_S_OK != Connection->VerifyNonRequestPacket(pPacket))
        {
        FreePacket(pPacket);
        return;
        }

    //
    // Note fack arrival, and send more packets if necessary.
    //
    TimeoutCount = 0;

    SendBurstLength += 1;

    UpdateSendWindow(pPacket, &Ignore);

    //
    // See whether we need to wake up a call to I_RpcSend, or generate an APC.
    //
    if (IsBufferAcknowledged())
        {
        FinishSendOrReceive(FALSE);
        }

    FreePacket(pPacket);
}

#pragma optimize("t", on)


void
DG_SCALL::DealWithRequest(
    PDG_PACKET      pPacket
    )
{
    RPC_STATUS         Status  = RPC_S_OK;
    PNCA_PACKET_HEADER pHeader = &pPacket->Header;

    ASSERT(pHeader->SequenceNumber == SequenceNumber);

    switch (State)
        {
        case CallInit:
            {
            //
            // Be sure the server is listening and the interface is supported.
            //
            RPC_SYNTAX_IDENTIFIER InterfaceInfo;

            InterfaceInfo.SyntaxVersion = pHeader->InterfaceVersion;
            RpcpMemoryCopy(
                &(InterfaceInfo.SyntaxGUID),
                &(pHeader->InterfaceId),
                sizeof(RPC_UUID)
                );

            if (Connection->LastInterface &&
                0 == Connection->LastInterface->MatchInterfaceIdentifier(&InterfaceInfo))
                {
                Interface = Connection->LastInterface;
                }
            else
                {
                Interface = GlobalRpcServer->FindInterface(&InterfaceInfo);
                Connection->LastInterface = Interface;
                }

            if (!Interface)
                {
                Status = RPC_S_UNKNOWN_IF;
                }
            else if (!GlobalRpcServer->IsServerListening() &&
                     !Interface->IsAutoListenInterface())
                {
                Status = RPC_S_SERVER_TOO_BUSY;

                // If this is a message transport (i.e. Falcon) then
                // wait around for a while before giving up. The user
                // may not have called RpcServerListen() yet...
                if (Connection->TransportInterface->IsMessageTransport)
                   {
                   for (int i=0; i<100; i++)
                       {
                       if (GlobalRpcServer->IsServerListening())
                          {
                          Status = RPC_S_OK;
                          break;
                          }
                       else
                          {
                          Sleep(100);      // Loop 100 * Sleep 100 = 10 seconds.
                          }
                       }
                   }
                }

            if (Status == RPC_S_OK)
                {
                Status = Interface->IsObjectSupported(&pHeader->ObjectId);
                }

            if (Status == RPC_S_OK &&
                Connection->DidCallbackFail())
                {
                Status = RPC_S_CALL_FAILED_DNE;
                }

            if (Status != RPC_S_OK)
                {
                BOOL fSendReject = !(pHeader->PacketFlags & DG_PF_MAYBE);

                FreePacket(pPacket);
                if (fSendReject)
                    {
                    pSavedPacket->Header.SequenceNumber = SequenceNumber;
                    Connection->pAddress->SendRejectPacket(pSavedPacket, Status, RemoteAddress);
                    }

                Cleanup();
                break;
                }

            //
            // The server is listening and the interface is present.
            // We will increment these counters to declare that a call
            // is in progress.
            //
            CallInProgress = TRUE;

            Connection->pAddress->IncrementActiveCallCount();

            if (Interface->IsAutoListenInterface())
                {
                // The AutoListen and NullManager call counts for the interface
                // will be added on dispatch so we do not need to add it here.
                // Interface->BeginAutoListenCall();
                Connection->pAddress->BeginAutoListenCall();
                }

            SetState(CallBeforeDispatch);

            //
            // No "break" here.
            //
            }

        case CallBeforeDispatch:
        case CallDispatched:
        case CallAfterDispatch:
            {
            if (fReceivedAllFragments)
                {
                pHeader->PacketType = DG_WORKING;
                pHeader->SetPacketBodyLen(0);

                SealAndSendPacket(pHeader);
                FreePacket(pPacket);
                break;
                }

            //
            // If the client sent an oversize fragment, send a FACK-with-body
            // telling him our limit.
            //
            if (pPacket->Flags & DG_PF_PARTIAL)
                {
                SendFackOrNocall(pPacket, DG_FACK);

                FreePacket(pPacket);
                break;
                }

            //
            // Add the fragment to the call's packet list.
            //
            BOOL Added = UpdateReceiveWindow(pPacket);

            if (!Added)
                {
                unsigned Frag = (pPacket->Header.PacketType << 16) | pPacket->GetFragmentNumber();

                LogEvent(SU_SCALL, EV_PKT_IN, this, (void *) '!', Frag);
                }

            //
            // See whether we need to wake up a call to I_RpcReceive.
            //
            if (PipeWaitType == PWT_RECEIVE &&
                (fReceivedAllFragments ||
                 (PipeWaitLength && ConsecutiveDataBytes >= PipeWaitLength)))
                {
                FinishSendOrReceive(FALSE);
                }

            if (KnowClientAddress)
                {
                Connection->SubmitCallbackIfNecessary(this, pPacket, RemoteAddress);
                }

            if (!Added)
                {
                FreePacket(pPacket);
                }

            break;
            }

        case CallSendingResponse:
            {
            SendSomeFragments();
            FreePacket(pPacket);
            break;
            }

        default:
            {
            ASSERT(0 && "invalid call state");
            break;
            }
        }
}


void
DG_SCALL::ProcessRpcCall()
/*++

Routine Description:

    This routine is called when we determine that all the packets for a
    given call have been received.

--*/
{
    BOOL                    ObjectUuidSpecified;
    PNCA_PACKET_HEADER      pHeader = &pReceivedPackets->Header;
    PRPC_DISPATCH_TABLE DispatchTableToUse;

    ASSERT(State == CallBeforeDispatch);

    SetState(CallDispatched);

    //
    // Save the object uuid if necessary.
    //
    if (pHeader->ObjectId.IsNullUuid())
        {
        ObjectUuidSpecified = FALSE;
        }
    else
        {
        ObjectUuidSpecified = TRUE;
        pSavedPacket->Header.ObjectId.CopyUuid(&pHeader->ObjectId);
        }

    RpcRuntimeInfo.Length = sizeof(RPC_RUNTIME_INFO) ;
    RpcMessage.ReservedForRuntime = &RpcRuntimeInfo ;

    RpcMessage.Handle = (RPC_BINDING_HANDLE) this;
    RpcMessage.ProcNum = pHeader->OperationNumber;
    RpcMessage.TransferSyntax = 0;
    RpcMessage.ImportContext = 0;

    RpcMessage.RpcFlags = PacketToRpcFlags(pHeader->PacketFlags);

    unsigned OriginalSequenceNumber = SequenceNumber;
    unsigned long SavedAwayRpcFlags = RpcMessage.RpcFlags;

    RPC_STATUS  Status = RPC_S_OK;

    //
    // For secure RPC, verify packet integrity.
    //
    if (pHeader->AuthProto)
        {
        PDG_PACKET pScan = pReceivedPackets;

        do
            {
            Status = Connection->VerifyRequestPacket(pScan);
            if (Status)
                {
                LogError( SU_SCALL, EV_STATUS, this, UlongToPtr(0x200), Status );
                }
            pScan = pScan->pNext;
            }
        while (pScan && Status == RPC_S_OK);
        }

    //
    // Coalesce packet data.
    //
    if (RPC_S_OK == Status)
        {
        RpcMessage.Buffer = 0;
        RpcMessage.BufferLength = 0;
        Status = AssembleBufferFromPackets(&RpcMessage);
        }

    if (Status != RPC_S_OK)
        {
        InitErrorPacket(pSavedPacket, DG_REJECT, Status);
        SealAndSendPacket(&pSavedPacket->Header);

        Cleanup();
        return;
        }

    DispatchBuffer = RpcMessage.Buffer;

    //
    // The thread context is used by routines like RpcBindingInqAuthClient
    // when the user specifies hBinding == 0.
    //
    RpcpSetThreadContext(this);

    //
    // Make sure the thread is not impersonating.
    //
    ASSERT(0 == QueryThreadSecurityContext());

    TerminateWhenConvenient = FALSE;
    AsyncStatus = RPC_S_OK;

    //
    // Time to deal with the interface security callback. If it is required,
    // the call must be secure.  If we have already made a callback using
    // the current auth context, we can use the cached results; otherwise,
    // we should call back.
    //
    if (Interface->IsSecurityCallbackReqd())
        {
        Status = Connection->MakeApplicationSecurityCallback(Interface, this);
        if (Status)
            {
            LogError( SU_SCALL, EV_STATUS, this, UlongToPtr(0x201), Status );
            }
        }

    if (TerminateWhenConvenient)
        {
        RpcpSetThreadContext(0);
        Cleanup();
        return;
        }

    //
    // If this is a message based transport then we will need the
    // message mutex for call serialization:
    //
    if (Connection->TransportInterface->IsMessageTransport)
        {
        if (!Connection->pMessageMutex)
            {
            Connection->MessageMutexInitialize(&Status);
            }
        }

    //
    // If no errors have occurred, we are ready to dispatch.  Release
    // the call mutex, call the server stub, and grab the mutex again.
    //
    BOOL StubWasCalled = FALSE;

    if (RPC_S_OK == Status)
        {
        ASSERT(Interface);

        //
        // doc:appref
        //
        // SetAsyncHandle adds a reference to the call on behalf of the app,
        // so that the call cannot be deleted even though the manager routine
        // has completed and no Send or Receive calls are pending.
        // That reference should be removed when one of the following occurs:
        //
        //      a) (obsolete)
        //      b) the app sends the last buffer (RPC_BUFFER_PARTIAL not set)
        //      c) a Send() returns something other than OK or SEND_INCOMPLETE
        //      d) the app calls AbortAsyncCall
        //
        IncrementRefCount();

        Connection->Mutex.Clear();

        //
        // If this is a message based call (MQ) then take a mutex for
        // serialization:
        //
        if (Connection->TransportInterface->IsMessageTransport)
           {
           ASSERT(Connection->pMessageMutex);

           Connection->pMessageMutex->Request();

           Connection->TransportInterface->AllowReceives(
                               SourceEndpoint->TransportEndpoint,
                               FALSE,
                               FALSE );
           }
        else
           {
           //
           // Normal, non-message based calls:
           //
           Connection->pAddress->CheckThreadPool();
           }

        StubWasCalled = TRUE;

        RPC_STATUS ExceptionCode = 0;

        DispatchTableToUse = Interface->GetDefaultDispatchTable();
        if ( !ObjectUuidSpecified )
            {
            Status = Interface->DispatchToStub(
                &RpcMessage,                               // msg
                0,                                      // callback flag
                DispatchTableToUse,                     // dispatch table to use for
                                                        // this interface
                &ExceptionCode                          // exception code
                );
            }
        else
            {
            Status = Interface->DispatchToStubWithObject(
                &RpcMessage,                               // msg
                &pSavedPacket->Header.ObjectId,         // object uuid
                0,                                      // callback flag
                DispatchTableToUse,                     // dispatch table to use for
                                                        // this interface
                &ExceptionCode                          // exception code
                );
            }

        //
        // If this is a message based call (MQ) then clear the mutex:
        //
        if (Connection->TransportInterface->IsMessageTransport)
           {
           Connection->pMessageMutex->Clear();

           Connection->TransportInterface->AllowReceives(
                               SourceEndpoint->TransportEndpoint,
                               TRUE,
                               FALSE );

           Connection->pAddress->CheckThreadPool();
           }

        RpcMessage.RpcFlags = SavedAwayRpcFlags;

        if (Status == RPC_S_PROCNUM_OUT_OF_RANGE ||
            Status == RPC_S_UNSUPPORTED_TYPE     ||
            Status == RPC_S_SERVER_TOO_BUSY      ||
            Status == RPC_S_NOT_LISTENING        ||
            Status == RPC_S_UNKNOWN_IF)
            {
            StubWasCalled = FALSE;
            }

        Connection->Mutex.Request();
        DecrementRefCount();

        if (Status == RPC_P_EXCEPTION_OCCURED)
            {
            if (pAsync)
                {
                //
                // Abort any lingering receive.
                //
                FinishSendOrReceive(TRUE);
                DecrementRefCount();

                //
                // Later code will see TerminateWhenConvenient and will not send a fault packet.
                //
                InitErrorPacket(pSavedPacket, DG_FAULT, ExceptionCode);
                SealAndSendPacket(&pSavedPacket->Header);
                }

            Status = ExceptionCode;
            }

        //
        // If the manager routine impersonated the client,
        // restore the thread to its native security context.
        //
        RevertToSelf();
        }

    RpcpSetThreadContext(0);

    //
    // Remember that a sync stub may have called the completion routine,
    // or sent some [out] pipe data.
    //

    //
    // Don't send a response of any sort for a [maybe] call.
    //
    if (RpcMessage.RpcFlags & RPC_NCA_FLAGS_MAYBE)
        {
        if (!Status)
            {
            FreeBuffer(&RpcMessage);
            }
        return;
        }

    //
    // Has the client cancelled the call or another server thread aborted it?
    //
    if (TerminateWhenConvenient)
        {
//        if (!Status)
//            {
//            FreeBuffer(&Message);
//            }
        Cleanup();
        return;
        }

    ASSERT( State == CallDispatched      ||
            State == CallSendingResponse );

    //
    // Ordinary error?
    //
    if (Status != RPC_S_OK)
        {
        if (StubWasCalled)
            {
            InitErrorPacket(pSavedPacket, DG_FAULT, Status);
            }
        else
            {
            InitErrorPacket(pSavedPacket, DG_REJECT, Status);
            }

        SealAndSendPacket(&pSavedPacket->Header);

        Cleanup();
        return;
        }

    //
    // No error; the call is still in progress.
    //
    if (pAsync)
        {
        if (State == CallDispatched)
            {
            ASSERT( fReceivedAllFragments || Interface->IsPipeInterface() );

            SetState(CallAfterDispatch);
            }
        }
    else
        {
        ASSERT( fReceivedAllFragments );

        if (State == CallSendingResponse)
            {
            ASSERT( Interface->IsPipeInterface() );
            }

        SetState(CallSendingResponse);


        //
        // Send the static [out] call parameters; [out] pipes were sent by the stub.
        //
        SetFragmentLengths();

        PushBuffer(&RpcMessage);

        CleanupReceiveWindow();
        }
}

#pragma optimize("", on)


void
DG_SCALL::AddPacketToReceiveList(
    PDG_PACKET  pPacket
    )

/*++

Routine Description:

    Adds a packet to the receive list and lets the caller know whether this
    call is ready to be processed.

Arguments:

    pPacket - the packet to add to the list.

Return Value:



Revision History:

--*/

{
    PNCA_PACKET_HEADER pHeader = &pPacket->Header;

    unsigned Frag = (pPacket->Header.PacketType << 16) | pPacket->GetFragmentNumber();

    BOOL Added = UpdateReceiveWindow(pPacket);

    if (!Added)
        {
        LogEvent(SU_SCALL, EV_PKT_IN, this, (void *) '!', Frag);
        }

    //
    // See whether we need to wake up a call to I_RpcReceive.
    //
    if (fReceivedAllFragments ||
        (PipeWaitLength && ConsecutiveDataBytes >= PipeWaitLength))
        {
        FinishSendOrReceive(FALSE);
        }
}


RPC_STATUS
DG_SCALL::ImpersonateClient()
/*++

Routine Description:

    Force the current thread to impersonate the client of this DG_SCALL.
    Note that the current thread might not be the thread executing the
    server manager routine.

Arguments:

    none

Return Value:

    result of impersonating, or RPC_S_NO_CONTEXT_AVAILABLE if this is
    an insecure call.

--*/
{
    RPC_STATUS Status;

    if (!Connection->ActiveSecurityContext)
        {
        return RPC_S_NO_CONTEXT_AVAILABLE;
        }

    Status = SetThreadSecurityContext(Connection->ActiveSecurityContext);
    if (RPC_S_OK != Status)
        {
        return Status;
        }

    Status = Connection->ActiveSecurityContext->ImpersonateClient();
    if (RPC_S_OK != Status)
        {
        ClearThreadSecurityContext();
        }

    return Status;
}

RPC_STATUS
DG_SCALL::RevertToSelf (
    )
{
    SECURITY_CONTEXT * SecurityContext = ClearThreadSecurityContext();

    if (SecurityContext)
        {
        SecurityContext->RevertToSelf();
        }

    return(RPC_S_OK);
}


RPC_STATUS
DG_SCALL::InquireAuthClient (
    OUT RPC_AUTHZ_HANDLE * Privs,
    OUT RPC_CHAR * * ServerPrincipalName, OPTIONAL
    OUT unsigned long * AuthenticationLevel,
    OUT unsigned long * AuthenticationService,
    OUT unsigned long * pAuthorizationService,
    IN  unsigned long   Flags
    )
{
    RPC_STATUS Status = RPC_S_OK;

    if (0 == Connection->ActiveSecurityContext)
        {
        if ( (Connection->TransportInterface->InquireAuthClient) )
           {
           SID        *pSid;

           Status = Connection->TransportInterface->InquireAuthClient(
                                                      RemoteAddress,
                                                      ServerPrincipalName,
                                                      &pSid,
                                                      AuthenticationLevel,
                                                      AuthenticationService,
                                                      pAuthorizationService );
           if ( (Status == RPC_S_OK)
                && (ARGUMENT_PRESENT(ServerPrincipalName)))
              {
              Status = ConvertSidToUserW(pSid,(RPC_CHAR**)Privs);
              }

           return Status;
           }
        else
           {
           return RPC_S_BINDING_HAS_NO_AUTH;
           }
        }

    if (AuthenticationLevel)
        {
        *AuthenticationLevel = Connection->ActiveSecurityContext->AuthenticationLevel;
        }

    if (AuthenticationService)
        {
        *AuthenticationService = Connection->ActiveSecurityContext->AuthenticationService;
        }

    if (Privs || pAuthorizationService)
        {
        if (!Privileges)
            {
            Status = Connection->ActiveSecurityContext->GetDceInfo(&Privileges, &AuthorizationService);
            }

        if (Privs)
            {
            *Privs = Privileges;
            }

        if (pAuthorizationService)
            {
            *pAuthorizationService = AuthorizationService;
            }

        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    if (ARGUMENT_PRESENT(ServerPrincipalName))
        {
        Status = GlobalRpcServer->InquirePrincipalName(
                                       *AuthenticationService,
                                       ServerPrincipalName
                                       );

        ASSERT(Status == RPC_S_OK           ||
               Status == RPC_S_OUT_OF_MEMORY );

        return Status;
        }

    return(RPC_S_OK);
}


RPC_STATUS
DG_SCALL::GetAssociationContextCollection (
    OUT ContextCollection **CtxCollection
    )
{
    RPC_STATUS Status = Connection->GetAssociationGroup(RemoteAddress);
    if (Status)
        {
        return Status;
        }

    ASSERT( Connection->pAssocGroup );

    Status = Connection->pAssocGroup->GetAssociationContextCollection(CtxCollection);

    return (Status);
}


void
DG_SCALL::InquireObjectUuid (
    OUT RPC_UUID * ObjectUuid
    )
{
    ObjectUuid->CopyUuid(&pSavedPacket->Header.ObjectId);
}


RPC_STATUS
DG_SCALL::ToStringBinding (
    OUT RPC_CHAR * * StringBinding
    )
/*++

Routine Description:

    We need to convert this particular SCALL into a string binding.
    Typically, we get the SCALL in Message structure. An SCall is associated
    with a particular address. We just ask the address to create a string
    binding

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - We do not have enough memory available to
        allocate space for the string binding.

--*/
{
    BINDING_HANDLE * BindingHandle;
    RPC_STATUS Status;

    BindingHandle = Connection->pAddress->InquireBinding();
    if (BindingHandle == 0)
        return(RPC_S_OUT_OF_MEMORY);

    BindingHandle->SetObjectUuid(&pSavedPacket->Header.ObjectId);
    Status = BindingHandle->ToStringBinding(StringBinding);
    BindingHandle->BindingFree();
    return Status;
}


RPC_STATUS
DG_SCALL::ConvertToServerBinding (
    OUT RPC_BINDING_HANDLE * pServerBinding
    )
{
        return CreateReverseBinding(pServerBinding, FALSE);
}


RPC_STATUS
DG_SCALL::CreateReverseBinding (
    OUT RPC_BINDING_HANDLE * pServerBinding,
    BOOL IncludeEndpoint
    )
{
    RPC_STATUS Status;
    RPC_CHAR * ClientAddress;
    RPC_CHAR * ClientEndpoint;
    RPC_CHAR * StringBinding;

    ClientAddress = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) * Connection->TransportInterface->AddressStringSize);
    if (!ClientAddress)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    Status = Connection->TransportInterface->QueryAddress(RemoteAddress, ClientAddress);
    if ( Status != RPC_S_OK )
        {
        return(Status);
        }

    if (IncludeEndpoint)
        {
        ClientEndpoint = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) * Connection->TransportInterface->EndpointStringSize);
        if (!ClientEndpoint)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        Status = Connection->TransportInterface->QueryEndpoint(RemoteAddress, ClientEndpoint);
        if ( Status != RPC_S_OK )
            {
            return(Status);
            }

        Status = RpcStringBindingCompose(0,
                                          Connection->pAddress->InqRpcProtocolSequence(),
                                          ClientAddress,
                                          ClientEndpoint,
                                          0,
                                          &StringBinding
                                          );
        }
    else
        {
        Status = RpcStringBindingCompose(0,
                                          Connection->pAddress->InqRpcProtocolSequence(),
                                          ClientAddress,
                                          0,
                                          0,
                                          &StringBinding
                                          );
        }

    if ( Status != RPC_S_OK )
        {
        return(Status);
        }

    Status = RpcBindingFromStringBinding(StringBinding, pServerBinding);
    if (RPC_S_OK == Status)
        {
        Status = RpcBindingSetObject(*pServerBinding,
                                     (UUID *) &pSavedPacket->Header.ObjectId
                                     );

        RpcStringFree(&StringBinding);
        }

    return(Status);
}


RPC_STATUS
DG_SCALL::ConvertSidToUserW(
    IN  SID       *pSid,
    OUT RPC_CHAR **ppwsPrincipal
    )
{
     // Called by InquireAuthClient to convert the SID passed up by the
     // client to a "Domain\User" string. The DG_SCALL cashes the last
     // SID (pCachedSid). If the new SID to convert matches the cashed
     // SID then just return that one (don't have to hit the domain server).
     //
     #define      MAX_USERNAME_SIZE    256
     #define      MAX_DOMAIN_SIZE      256
     RPC_STATUS   Status = RPC_S_OK;
     WCHAR        wsName[MAX_USERNAME_SIZE];
     WCHAR        wsDomain[MAX_DOMAIN_SIZE];
     DWORD        dwNameSize;
     DWORD        dwDomainSize;
     DWORD        dwSize;
     SID_NAME_USE sidType;


     if (  (pCachedSid) && (pSid)
        && (IsValidSid(pSid)) && (EqualSid(pCachedSid,pSid)) )
        {
        //
        // Great! SIDs match...
        //
        #ifdef DBG
           DbgPrint("DG_SCALL::ConvertSidToUserW(): Cash hit.\n");
        #endif
        *ppwsPrincipal = (RPC_CHAR*)I_RpcAllocate(dwCachedUserNameSize);
        if (*ppwsPrincipal)
           RpcpStringCopy(*ppwsPrincipal,pwsCachedUserName);
        else
           Status = RPC_S_OUT_OF_MEMORY;
        }
     else if ( (pSid) && (IsValidSid(pSid)) )
        {
        dwNameSize = sizeof(wsName);
        dwDomainSize = sizeof(wsDomain);

        if (LookupAccountSidW( NULL,
                               pSid,
                               wsName,
                               &dwNameSize,
                               wsDomain,
                               &dwDomainSize,
                               &sidType) )
           {
           //
           // Got a new SID, remember it for next time.
           //
           *ppwsPrincipal = 0;

           if (pCachedSid)
              {
              I_RpcFree(pCachedSid);
              pCachedSid = 0;
              }

           if (pwsCachedUserName)
              {
              I_RpcFree(pwsCachedUserName);
              pwsCachedUserName = 0;
              }

           dwCachedUserNameSize = 0;

           dwSize = GetLengthSid(pSid);
           pCachedSid = (SID*)I_RpcAllocate(dwSize);
           if (pCachedSid == 0)
              {
              return RPC_S_OUT_OF_MEMORY;
              }

           if (!CopySid(dwSize,pCachedSid,pSid))
              {
              return RPC_S_OUT_OF_MEMORY;
              }

           dwSize = sizeof(RPC_CHAR) * (2 + wcslen(wsName) + wcslen(wsDomain));
           pwsCachedUserName = (RPC_CHAR*)I_RpcAllocate(dwSize);
           if (pwsCachedUserName == 0)
              {
              return RPC_S_OUT_OF_MEMORY;
              }

           RpcpStringCopy(pwsCachedUserName,wsDomain);
           RpcpStringCat(pwsCachedUserName,RPC_CONST_STRING("\\"));
           RpcpStringCat(pwsCachedUserName,wsName);

           *ppwsPrincipal = (RPC_CHAR*)I_RpcAllocate(dwSize);
           if (*ppwsPrincipal)
              {
              RpcpStringCopy(*ppwsPrincipal,pwsCachedUserName);
              dwCachedUserNameSize = dwSize;
              }
           else
              {
              I_RpcFree(pCachedSid);
              pCachedSid = 0;
              dwCachedUserNameSize = 0;
              Status = RPC_S_OUT_OF_MEMORY;
              }
           }
        else
           {
           //
           // LookupAccountSidW() failed. Lookup its error and return.
           //
           Status = GetLastError();
           *ppwsPrincipal = 0;
           }
        }
     else
        {
        #ifdef DBG
           DbgPrint("DG_SCALL::ConvertSidToUserW(): No SID to convert.\n");
        #endif
        *ppwsPrincipal = 0;
        }

     return Status;
}




DG_SCALL *
DG_SCONNECTION::RemoveIdleCalls(
    DG_SCALL *      List,
    BOOL            Aggressive,
    RPC_INTERFACE * Interface
    )
{
    if (TRUE == Mutex.TryRequest())
        {
        if (BlockIdleCallRemoval)
            {
            Mutex.Clear();
            return 0;
            }

        long CurrentTime = GetTickCount();

        PDG_SCALL Node = 0;

        if (CachedCalls)
            {
            for (Node = CachedCalls->Next; Node; Node = Node->Next)
                {
                ASSERT( !Node->InvalidHandle(DG_SCALL_TYPE) );
                ASSERT(Node->TimeStamp != 0x31415926);

                if (CurrentTime - Node->TimeStamp > IDLE_SCALL_LIFETIME)
                    {
                    break;
                    }
                }
            }

        ActiveCalls.RemoveIdleCalls(Aggressive, Interface);

        if (Node)
            {
            PDG_SCALL Next = Node->Next;
            Node->Next = 0;
            Node = Next;
            }

        Mutex.Clear();

        while (Node)
            {
            ASSERT( !Node->InvalidHandle(DG_SCALL_TYPE) );
            ASSERT(Node->TimeStamp != 0x31415926);

            PDG_SCALL Next = Node->Next;

            Node->Next = List;
            List = Node;
            Node = Next;
            }
        }

    return List;
}


BOOL
DG_SCONNECTION::HasExpired()
{
    if (GetTickCount() - TimeStamp > FIVE_MINUTES_IN_MSEC &&
        0 == ReferenceCount)
        {
        CLAIM_MUTEX Lock(Mutex);

        if (GetTickCount() - TimeStamp > FIVE_MINUTES_IN_MSEC &&
            0 == ReferenceCount)
            {
            return TRUE;
            }
        }

    return FALSE;
}


BOOL
DG_SCALL::HasExpired(
    BOOL            Aggressive,
    RPC_INTERFACE * ExpiringInterface
    )
{
    long CurrentTime = CurrentTimeInMsec();

    if (CurrentTime - TimeStamp < 40 * 1000 )
        {
        return FALSE;
        }

    AsyncStatus = RPC_S_CALL_FAILED;

    if (PipeWaitType != PWT_NONE)
        {
#ifdef DEBUGRPC
        DbgPrint("RPC DG: aborting an abandoned pipe operation on %x\n", this);
#endif
        FinishSendOrReceive(TRUE);
        }
    else if (State == CallDispatched    ||
             State == CallAfterDispatch )
        {
#ifdef DEBUGRPC

        DbgPrint("RPC DG: possible blockage: scall %lx has been dispatched for %u seconds\n",
                 this, (CurrentTime - TimeStamp)/1000 );
#endif
        return FALSE;
        }

    return Cleanup();
}


PDG_SCONNECTION
SERVER_ACTIVITY_TABLE::FindOrCreate(
    DG_ADDRESS * Address,
    DG_PACKET *  Packet
    )
/*++

Routine Description:

    Looks for connection matching the packet's activity uuid.  If the activity
    hint is not 0xffff, we search in that hash bucket, otherwise we create
    a hash value and look there.

    If a connection is found or created, its mutex is taken.

Arguments:

    pPacket - data to find call (activity uuid and activity hint)

Return Value:

    the new call, or zero

--*/
{
    unsigned Hash = Packet->Header.ActivityHint;

    if (Hash == 0xffff)
        {
        Hash = MakeHash(&Packet->Header.ActivityId);
        }

    //
    // This can happen only if someone is sending garbage.
    //
    if (Hash >= BUCKET_COUNT)
        {
        return 0;
        }

    RequestHashMutex(Hash);

    PDG_SCONNECTION Connection = 0;
    UUID_HASH_TABLE_NODE * pNode = UUID_HASH_TABLE::Lookup(
                                        &Packet->Header.ActivityId,
                                        Hash
                                        );
    if (pNode)
        {
        Connection = DG_SCONNECTION::FromHashNode(pNode);

        if (FALSE == Connection->Mutex.TryRequest())
            {
            Connection->TimeStamp = GetTickCount();
            ReleaseHashMutex(Hash);

            // If the connection is busy more than five minutes,
            // then the connection will go away and this will crash.
            //
            Connection->Mutex.Request();
            }
        else
            {
            ReleaseHashMutex(Hash);
            }
        }
    else if (Packet->Header.PacketType == DG_REQUEST)
        {
        if ((Packet->Header.PacketFlags  & DG_PF_FORWARDED)       &&
            (Packet->Header.PacketFlags2 & DG_PF2_FORWARDED_2) == 0)
            {
            //
            // This packet doesn't have correct auth info.  We can't
            // instantiate a connection without it.
            //
            }
        else
            {
            Connection = Address->AllocateConnection();
            if (Connection)
                {
                ServerConnections->BeginIdlePruning();
                Connection->Activate(&Packet->Header, (unsigned short) Hash);
                Connection->Mutex.Request();
                UUID_HASH_TABLE::Add(&Connection->ActivityNode, Hash);
                }
            }

        ReleaseHashMutex(Hash);
        }
    else
        {
        ReleaseHashMutex(Hash);
        }

    return Connection;
}


void SERVER_ACTIVITY_TABLE::Prune()

/*++

Routine Description:

    Remove idle connections and calls from the activity table.
    Each call to this fn cleans one bucket.

--*/

{
    unsigned    Bucket;
    long        CurrentTime = GetTickCount();

    //
    // Don't check the whole table too often.
    //
    if (CurrentTime - LastFinishTime < IDLE_SCONNECTION_SWEEP_INTERVAL)
        {
        return;
        }

    Bucket = InterlockedIncrement(&BucketCounter) % BUCKET_COUNT;

    PruneSpecificBucket(Bucket, FALSE, 0);

    if (Bucket == BUCKET_COUNT-1)
        {
        LastFinishTime = CurrentTime;
        }
}

void
SERVER_ACTIVITY_TABLE::BeginIdlePruning()
{
    if (!fPruning)
        {
        if (InterlockedIncrement(&fPruning) > 1)
            {
            InterlockedDecrement(&fPruning);
            return;
            }

        IdleScavengerTimer.Initialize( PruneWhileIdle, 0 );
        DelayedProcedures->Add(&IdleScavengerTimer, IDLE_SCONNECTION_SWEEP_INTERVAL, FALSE);
        }
}

void
SERVER_ACTIVITY_TABLE::PruneWhileIdle( PVOID unused )
{
    if (GetTickCount() - ServerConnections->LastFinishTime > IDLE_SCONNECTION_SWEEP_INTERVAL)
        {
        BOOL fEmpty = ServerConnections->PruneEntireTable( 0 );
        if (fEmpty)
            {
            InterlockedDecrement(&fPruning);
            return;
            }
        }

    DelayedProcedures->Add(&ServerConnections->IdleScavengerTimer, IDLE_SCONNECTION_SWEEP_INTERVAL+5000, FALSE);
}

BOOL
SERVER_ACTIVITY_TABLE::PruneEntireTable(
   RPC_INTERFACE * Interface
   )
{
    BOOL Empty = TRUE;
    unsigned Bucket;

    //
    // Make sure this thread has an associated THREAD.
    // This won't be true for the RpcServerListen thread.
    //
    ThreadSelf();

    for (Bucket = 0; Bucket < BUCKET_COUNT; ++Bucket)
        {
        Empty &= PruneSpecificBucket( Bucket, TRUE, Interface );
        }

    LastFinishTime = GetTickCount();

    return Empty;
}


BOOL
SERVER_ACTIVITY_TABLE::PruneSpecificBucket(
    unsigned        Bucket,
    BOOL            Aggressive,
    RPC_INTERFACE * Interface
    )
{
    if (!Buckets[Bucket])
        {
        return TRUE;
        }

    //
    // Scan the bucket for idle calls and connections.
    // Remove them from the table, but don't delete them.
    //
    DG_SCALL *      IdleCalls = 0;

    UUID_HASH_TABLE_NODE * pNode;
    UUID_HASH_TABLE_NODE * IdleConnections = 0;

    unsigned Inactive = 0;

    RequestHashMutex(Bucket);

    pNode = Buckets[Bucket];
    while (pNode)
        {
        UUID_HASH_TABLE_NODE * pNext = pNode->pNext;

        DG_SCONNECTION * Connection = DG_SCONNECTION::FromHashNode(pNode);

        IdleCalls = Connection->RemoveIdleCalls( IdleCalls, Aggressive, Interface );

        if (Connection->HasExpired())
            {
            UUID_HASH_TABLE::Remove(pNode, Bucket);

            pNode->pNext = IdleConnections;
            IdleConnections = pNode;
            }

        pNode = pNext;
        }

    BOOL Empty = TRUE;

    if (Buckets[Bucket])
        {
        Empty = FALSE;
        }

    ReleaseHashMutex(Bucket);

    //
    // Now delete the idle objects.
    //
    while (IdleCalls)
        {
        ++Inactive;

        DG_SCALL * Call = IdleCalls;
        IdleCalls = Call->Next;

        delete Call;
        }

    while (IdleConnections)
        {
        DG_SCONNECTION * Connection = DG_SCONNECTION::FromHashNode(IdleConnections);

        IdleConnections = IdleConnections->pNext;

        Connection->Deactivate();
        }

    LogEvent(SU_STABLE, EV_PRUNE, IntToPtr(Bucket), 0, Inactive);

    return Empty;
}


ASSOCIATION_GROUP *
ASSOC_GROUP_TABLE::FindOrCreate(
    RPC_UUID * pUuid,
    unsigned short InitialPduSize
    )
/*++

Routine Description:

    Looks for an association group with the given UUID.
    If one is not found then a new one is created.

Arguments:

    pUuid - CAS uuid to find or create

Return Value:

    ptr to the association group if found or created
    zero if not found and a new one could not be created

--*/
{
    ASSOCIATION_GROUP * pGroup;
    unsigned Hash = MakeHash(pUuid);

    RequestHashMutex(Hash);

    UUID_HASH_TABLE_NODE * pNode = UUID_HASH_TABLE::Lookup(pUuid, Hash);
    if (pNode)
        {
        ASSOCIATION_GROUP::ContainingRecord(pNode)->IncrementRefCount();
        }
    else
        {
        RPC_STATUS Status = RPC_S_OK;

        pGroup = new ASSOCIATION_GROUP(pUuid, InitialPduSize, &Status);
        if (!pGroup || Status != RPC_S_OK)
            {
            delete pGroup;
            pGroup = 0;
            }
        else
            {
            pNode = &pGroup->Node;

            UUID_HASH_TABLE::Add(pNode, Hash);
            }
        }

    ReleaseHashMutex(Hash);

    if (pNode)
        {
        return ASSOCIATION_GROUP::ContainingRecord(pNode);
        }
    else
        {
        return 0;
        }
}


void
ASSOC_GROUP_TABLE::DecrementRefCount(
    ASSOCIATION_GROUP * pClient
    )
{
    UUID_HASH_TABLE_NODE * pNode = &pClient->Node;

    unsigned Hash = MakeHash(&pNode->Uuid);

    RequestHashMutex(Hash);

    pClient->RequestMutex();

    if (0 == pClient->DecrementRefCount())
        {
        UUID_HASH_TABLE::Remove(pNode, Hash);
        delete pClient;
        }
    else
        {
        pClient->ClearMutex();
        }

    ReleaseHashMutex(Hash);
}


inline RPC_STATUS
DG_SCONNECTION::CreateCallbackBindingAndReleaseMutex(
    DG_TRANSPORT_ADDRESS RemoteAddress
    )
{
    RPC_STATUS Status;

    RPC_CHAR * StringBinding;
    RPC_CHAR * Address;
    RPC_CHAR * Endpoint;

    unsigned Length;
    unsigned AddressLength;
    unsigned EndpointLength;
    unsigned ProtocolLength;

    Callback.Binding = 0;

    Address  = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) * pAddress->Endpoint.TransportInterface->AddressStringSize);
    Endpoint = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) * pAddress->Endpoint.TransportInterface->EndpointStringSize);

    if (!Address || !Endpoint)
        {
        Mutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }

    Status = pAddress->Endpoint.TransportInterface->QueryAddress(RemoteAddress, Address);
    if ( Status != RPC_S_OK )
        {
        Mutex.Clear();
        return Status;
        }

    Status = pAddress->Endpoint.TransportInterface->QueryEndpoint(RemoteAddress, Endpoint);
    if ( Status != RPC_S_OK )
        {
        Mutex.Clear();
        return Status;
        }

    ProtocolLength = StringLengthWithEscape(pAddress->InqRpcProtocolSequence());
    AddressLength  = StringLengthWithEscape(Address);
    EndpointLength = StringLengthWithEscape(Endpoint);

    StringBinding = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) *
                                        ( ProtocolLength
                                        + 1
                                        + AddressLength
                                        + 1
                                        + EndpointLength
                                        + 1
                                        + 1
                                        ));
    if (!StringBinding)
        {
        Mutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }

    StringCopyEscapeCharacters(StringBinding, pAddress->InqRpcProtocolSequence());

    Length = ProtocolLength;

    StringBinding[Length++] = RPC_CONST_CHAR(':');

    StringCopyEscapeCharacters(StringBinding + Length, Address);

    Length += AddressLength;

    StringBinding[Length++] = RPC_CONST_CHAR('[');

    StringCopyEscapeCharacters(StringBinding + Length, Endpoint);

    Length += EndpointLength;

    StringBinding[Length++] = RPC_CONST_CHAR(']');
    StringBinding[Length]   = 0;

    //
    // We are entering the expensive phase of the callback.  Let's release
    // the call mutex so that other threads can respond to client PINGs etc.
    //
    IncrementRefCount();
    Mutex.Clear();

    pAddress->CheckThreadPool();

    //
    // Create a binding handle to the client endpoint.  It's important to do it
    // outside the call mutex because it causes a lot of memory allocation.
    //
    Status = RpcBindingFromStringBinding(StringBinding, &Callback.Binding);

    return Status;
}


inline void
DG_SCONNECTION::SubmitCallbackIfNecessary(
    PDG_SCALL   Call,
    PDG_PACKET  Packet,
    DG_TRANSPORT_ADDRESS RemoteAddress
    )
/*++

Routine Description:

    doc:callback

    This function determines whether the server should issue a conv callback
    to the client, and submits an async call if so.

    - The first non-idempotent call on a given activity ID requires a callback
      in order to guarantee the call wasn't executed by a prior server
      instance. If the activity stays quiet for 5 minutes and the
      DG_SCONNECTION is thrown away, the next call will force another callback.

    - Each security context requires a callback; this allows the cleint to
      transfer the session key securely to the server.

    In NT 5.0 beta 1:

        This function submits callbacks from the 'msconv' interface because that
        notifies an NT5 or better client that the server supports the
        DG_PF2_UNRELATED bit to overlap calls.

    In NT 5 beta 2:

        The callback request is sent with the DG_PF2_UNRELATED bit set, even
        though it doesn'nt need to be set.  That tells teh client that overlapped
        calls are OK.

    A connection is allowed only a single oustanding callback at a time. This
    should not be a significant restriction.

    The rule is that a thread must hold the connection mutex if it wants to
    change Callback.State from NoCallbackAttempted to any other value. It can
    then release the mutex and party on the other members of Callback, since
    all other instances of this procedure will exit immediately
    if Callback.State != NoCallbackAttempted.

    In a nutshell, this function
    - creates a binding handle to the client,
    - releases the connection mutex,
    - fills Callback.* with the info needed by FinishConvCallback(), and
    - calls an conv or msconv stub

    When the async call is complete (or fails), some thread will call
    ConvNotificationRoutine() which will either submit another async call
    or call FinishConvCallback() to mop up. For a successful secure callback,
    FinishConvCallback() will also call AcceptThirdLeg and then set
    ActiveSeurityContext to be the newly created context. For a failed
    callback, FinishConvCallback will notify the DG_SCALL that started
    all this, so it can send a REJECT to the client.

    A wrinkle is that two objects need access to Packet: the DG_SCALL
    is using it as [in] stub data, and this fn uses it for AcceptFirstTime.
    So future code shuffling needs to make sure the call doesn't die during
    a callback, and that the call doesn't delete the packet until
    AcceptFirstTime is complete.

--*/

{
    RPC_STATUS Status = RPC_S_OK;

    //
    // Has a callback already been attempted?
    //
    if (Callback.State != NoCallbackAttempted)
        {
        return;
        }

    //
    // Is a callback unnecessary?
    //
    DG_SECURITY_TRAILER * Verifier = (DG_SECURITY_TRAILER *)
                (Packet->Header.Data + Packet->GetPacketBodyLen());

    unsigned char KeySequenceNumber = Verifier->key_vers_num;

    if (Packet->Header.AuthProto == 0)
        {
        if (pAssocGroup ||
            (Packet->Header.PacketFlags & DG_PF_IDEMPOTENT))
            {
            return;
            }
        }
    else
        {
        //
        // See if we have already established a security context
        // for this client.
        //
        SECURITY_CONTEXT * CurrentContext = SecurityContextDict.Find(KeySequenceNumber);
        if (CurrentContext)
            {
            return;
            }
        }

    //
    // A callback is needed.
    //
    Callback.State           = SetupInProgress;
    Callback.Call            = Call;
    Callback.Binding         = 0;
    Callback.Credentials     = 0;
    Callback.TokenBuffer     = 0;
    Callback.ResponseBuffer  = 0;
    Callback.SecurityContext = 0;
    Callback.ThirdLegNeeded  = FALSE;
    Callback.DataRep         = 0x00ffffff & (*(unsigned long *) Packet->Header.DataRep);
    Callback.KeySequence     = KeySequenceNumber;

    Callback.Call->IncrementRefCount();

    Status = CreateCallbackBindingAndReleaseMutex( RemoteAddress );

    if (Status)
        {
        FinishConvCallback(Status);
        return;
        }

    Status = RpcAsyncInitializeHandle(&Callback.AsyncState, sizeof(Callback.AsyncState));
    if (Status)
        {
        FinishConvCallback(Status);
        return;
        }

    Callback.AsyncState.NotificationType    = RpcNotificationTypeCallback;
    Callback.AsyncState.u.NotificationRoutine = ConvNotificationRoutine;
    Callback.AsyncState.UserInfo            = this;

    if (Packet->Header.AuthProto)
        {
        unsigned long AuthenticationService = Packet->Header.AuthProto;
        unsigned long AuthenticationLevel   = Verifier->protection_level;

        //
        // OSF clients sometimes send these levels.
        //
        if (AuthenticationLevel == RPC_C_AUTHN_LEVEL_CONNECT ||
            AuthenticationLevel == RPC_C_AUTHN_LEVEL_CALL)
            {
            AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT;
            }

        //
        // Create an empty security context.
        //
        CLIENT_AUTH_INFO    Info;

        Info.AuthenticationService = AuthenticationService;
        Info.AuthenticationLevel   = AuthenticationLevel;
        Info.ServerPrincipalName = 0;
        Info.PacHandle           = 0;
        Info.AuthorizationService= 0;

        Callback.SecurityContext = new SECURITY_CONTEXT(&Info, KeySequenceNumber, TRUE, &Status);

        if (!Callback.SecurityContext)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        CallTestHook( TH_RPC_SECURITY_SERVER_CONTEXT_CREATED, Callback.SecurityContext, this );

        if (Status)
            {
            FinishConvCallback(Status);
            return;
            }

        //
        // Get my security credentials.
        //
        Status = pAddress->Server->AcquireCredentials(
                                      AuthenticationService,
                                      AuthenticationLevel,
                                      &Callback.Credentials
                                      );
        if (Status)
            {
            LogError(SU_SCONN, EV_STATUS, this, (void *) 100, Status );
            FinishConvCallback(Status);
            return;
            }

        //
        // Allocate challenge and response buffers.
        //
        Callback.TokenLength    = Callback.Credentials->MaximumTokenLength();

        Callback.TokenBuffer    = new unsigned char [2 * Callback.TokenLength];
        Callback.ResponseBuffer = Callback.TokenBuffer + Callback.TokenLength;

        if (!Callback.TokenBuffer)
            {
            FinishConvCallback(RPC_S_OUT_OF_MEMORY);
            return;
            }

        //
        // Get a skeletal context and a challenge from the security package.
        //
        DCE_INIT_SECURITY_INFO DceInitSecurityInfo;

        SECURITY_BUFFER_DESCRIPTOR InputBufferDescriptor;
        SECURITY_BUFFER_DESCRIPTOR OutputBufferDescriptor;
        SECURITY_BUFFER InputBuffers[4];
        SECURITY_BUFFER OutputBuffers[4];
        DCE_INIT_SECURITY_INFO InitSecurityInfo;

        InputBufferDescriptor.ulVersion = 0;
        InputBufferDescriptor.cBuffers  = 4;
        InputBufferDescriptor.pBuffers  = InputBuffers;

        InputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[0].pvBuffer   = &Packet->Header;
        InputBuffers[0].cbBuffer   = sizeof(NCA_PACKET_HEADER);

        InputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[1].pvBuffer   = Packet->Header.Data;
        InputBuffers[1].cbBuffer   = Packet->GetPacketBodyLen();

        InputBuffers[2].BufferType = SECBUFFER_TOKEN;
        InputBuffers[2].pvBuffer   = Verifier;
        InputBuffers[2].cbBuffer   = sizeof(DG_SECURITY_TRAILER);

        InputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        InputBuffers[3].pvBuffer   = &DceInitSecurityInfo;
        InputBuffers[3].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);

        OutputBufferDescriptor.ulVersion = 0;
        OutputBufferDescriptor.cBuffers  = 4;
        OutputBufferDescriptor.pBuffers  = OutputBuffers;

        OutputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        OutputBuffers[0].pvBuffer   = 0;
        OutputBuffers[0].cbBuffer   = 0;

        OutputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        OutputBuffers[1].pvBuffer   = 0;
        OutputBuffers[1].cbBuffer   = 0;

        OutputBuffers[2].BufferType = SECBUFFER_TOKEN;
        OutputBuffers[2].pvBuffer   = Callback.TokenBuffer;
        OutputBuffers[2].cbBuffer   = Callback.TokenLength;

        OutputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        OutputBuffers[3].pvBuffer   = &DceInitSecurityInfo;
        OutputBuffers[3].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);

        DceInitSecurityInfo.PacketType           = ~0;
        DceInitSecurityInfo.AuthorizationService = ~0;
        DceInitSecurityInfo.DceSecurityInfo.SendSequenceNumber    = ~0;
        DceInitSecurityInfo.DceSecurityInfo.ReceiveSequenceNumber = KeySequenceNumber;
        DceInitSecurityInfo.DceSecurityInfo.AssociationUuid       = Packet->Header.ActivityId;

        Status = Callback.SecurityContext->AcceptFirstTime(
                                           Callback.Credentials,
                                           &InputBufferDescriptor,
                                           &OutputBufferDescriptor,
                                           AuthenticationLevel,
                                           Callback.DataRep,
                                           FALSE
                                           );
        LogEvent( SU_SCONN, EV_SEC_ACCEPT1, this, IntToPtr(Status), I_RpcGetExtendedError());

        switch (Status)
            {
            case RPC_S_OK:
                {
                break;
                }

            case RPC_P_CONTINUE_NEEDED:
                {
                Callback.ThirdLegNeeded = TRUE;
                break;
                }

            case RPC_P_COMPLETE_NEEDED:
                {
#ifdef DEBUGRPC
                DbgPrint("RPC: dg does not support RPC_P_COMPLETE_NEEDED from AcceptSecurityContext\n");
#endif
                break;
                }

            case RPC_P_COMPLETE_AND_CONTINUE:
                {
                Callback.ThirdLegNeeded = TRUE;
#ifdef DEBUGRPC
                DbgPrint("RPC: dg does not support RPC_P_COMPLETE_AND_CONTINUE from AcceptSecurityContext\n");
#endif
                break;
                }

            default:
                {
                LogError( SU_SCONN, EV_SEC_ACCEPT1, this, IntToPtr(Status), I_RpcGetExtendedError());
                FinishConvCallback(Status);
                return;
                }
            }

        Callback.TokenLength = OutputBuffers[2].cbBuffer;

        Callback.State = ConvWayAuthInProgress;
        Callback.DataIndex = 0;
        Callback.Status = 0;

        _conv_who_are_you_auth(
            &Callback.AsyncState,
            Callback.Binding,
            (UUID *) &ActivityNode.Uuid,
            ProcessStartTime,
            Callback.TokenBuffer,
            Callback.TokenLength,
            Callback.Credentials->MaximumTokenLength(),
            &Callback.ClientSequence,
            &Callback.CasUuid,
            Callback.ResponseBuffer,
            &Callback.ResponseLength,
            &Callback.Status
            );

#ifdef INDUCE_CONV_CALLBACK_RACES
        Sleep(1000);
#endif

        //
        // We have to take the mutex before leaving this fn, regardless of error.
        // Do it here so the check of Callback.State is protected.
        //
        Mutex.Request();

        //
        // If there is an error, see whether it is caused a notification.  If so,
        // ConvCallCompleted() has changed the callback state and this thread should do nothing.
        // If the state is unchanged, this thread must clean up.
        //
        if (Callback.Status && Callback.State == ConvWayAuthInProgress)
            {
            FinishConvCallback(Callback.Status);

            //
            // The mutex was recursively claimed by FinishConvCallback().
            // Get rid of the recursive one.
            //
            Mutex.Clear();
            }
        }
    else
        {
        BlockIdleCallRemoval = FALSE;

        Callback.State = ConvWay2InProgress;
        Callback.Status = 0;

        _conv_who_are_you2(
            &Callback.AsyncState,
            Callback.Binding,
            (UUID *) &ActivityNode.Uuid,
            ProcessStartTime,
            &Callback.ClientSequence,
            &Callback.CasUuid,
            &Callback.Status
            );

#ifdef INDUCE_CONV_CALLBACK_RACES
        Sleep(1000);
#endif

        //
        // We have to take the mutex before leaving this fn, regardless of error.
        // Do it here so the check of Callback.State is protected.
        //
        Mutex.Request();

        //
        // If there is an error, see whether it is caused a notification.  If so,
        // ConvCallCompleted() has changed the callback state and this thread should do nothing.
        // If the state is unchanged, this thread must clean up.
        //
        // If the state advanced past ConvWay2InProgress, then async completion must have
        // already been processed so we should let the other thread do the job.
        //
        if (Callback.Status && Callback.State == ConvWay2InProgress)
            {
            FinishConvCallback(Callback.Status);

            //
            // The mutex was recursively claimed by FinishConvCallback().
            // Get rid of the recursive one.
            //
            Mutex.Clear();
            }
        }

    Mutex.VerifyOwned();
}


RPC_STATUS
DG_SCONNECTION::FinishConvCallback(
    RPC_STATUS Status
    )
{
    BlockIdleCallRemoval = FALSE;

    // Force this function to be idempotent.
    // The sync comple path races with the async complete path.
    // We avoid the race by updating the state of the callback
    // to let the subsequent callers know that it has been adjusted.
    Mutex.Request();
    if (Status != RPC_S_OK)
        {
        // If the function has been called in the past, this is a noop.
        if (Callback.State == NoCallbackAttempted
            || Callback.State == CallbackFailed
            )
            {
            // Do not clear the mutex since the callers expect it
            // to be claimed recursively by FinishConvCallback.
            return Status;
            }

        // If this is the first call, start by marking callback as completed.
        if (RPC_S_SERVER_UNAVAILABLE == Status ||
            RPC_S_CALL_FAILED_DNE    == Status ||
            RPC_S_CALL_FAILED        == Status ||
            RPC_S_PROTOCOL_ERROR     == Status)
            {
            Status = NCA_STATUS_WHO_ARE_YOU_FAILED;
            }

        if (Status == RPC_S_OUT_OF_MEMORY    ||
            Status == RPC_S_OUT_OF_RESOURCES )
            {
            Callback.State = NoCallbackAttempted;
            }
        else
            {
            Callback.State = CallbackFailed;
            }
        }
    Mutex.Clear();

    if (Status == RPC_S_OK && Callback.ThirdLegNeeded )
        {
#ifdef TRY_MSCONV_INTERFACE

        ASSERT( Callback.State ==   ConvWayAuthInProgress ||
                Callback.State == MsConvWayAuthInProgress );

#else

        ASSERT( Callback.State ==   ConvWayAuthInProgress ||
                Callback.State ==   ConvWayAuthMoreInProgress );

#endif
        //
        // Give the challenge response to the security package.
        //
        DCE_INIT_SECURITY_INFO DceInitSecurityInfo;

        SECURITY_BUFFER_DESCRIPTOR InputBufferDescriptor;
        SECURITY_BUFFER_DESCRIPTOR OutputBufferDescriptor;
        SECURITY_BUFFER InputBuffers[4];
        SECURITY_BUFFER OutputBuffers[4];

        InputBufferDescriptor.ulVersion = 0;
        InputBufferDescriptor.cBuffers  = 4;
        InputBufferDescriptor.pBuffers  = InputBuffers;

        InputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[0].pvBuffer   = 0;
        InputBuffers[0].cbBuffer   = 0;

        InputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[1].pvBuffer   = 0;
        InputBuffers[1].cbBuffer   = 0;

        InputBuffers[2].BufferType = SECBUFFER_TOKEN;
        InputBuffers[2].pvBuffer   = Callback.ResponseBuffer;
        InputBuffers[2].cbBuffer   = Callback.DataIndex;

        InputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        InputBuffers[3].pvBuffer   = &DceInitSecurityInfo;
        InputBuffers[3].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);

        DceInitSecurityInfo.PacketType           = ~0;
        DceInitSecurityInfo.AuthorizationService = ~0;
        DceInitSecurityInfo.DceSecurityInfo.SendSequenceNumber    = ~0;
        DceInitSecurityInfo.DceSecurityInfo.ReceiveSequenceNumber = Callback.KeySequence;
        DceInitSecurityInfo.DceSecurityInfo.AssociationUuid       = ActivityNode.Uuid;

        OutputBufferDescriptor.ulVersion = 0;
        OutputBufferDescriptor.cBuffers  = 0;
        OutputBufferDescriptor.pBuffers  = 0;

        Status = Callback.SecurityContext->AcceptThirdLeg(
                          Callback.DataRep,
                          &InputBufferDescriptor,
                          &OutputBufferDescriptor
                          );

        LogEvent( SU_SCONN, EV_SEC_ACCEPT3, this, IntToPtr(Status), I_RpcGetExtendedError());
        }

    if (Callback.Binding)
        {
        RpcBindingFree(&Callback.Binding);
        }

    delete Callback.TokenBuffer;

    if (Callback.Credentials)
        {
        Callback.Credentials->DereferenceCredentials();
        }

    if (RPC_S_OK == Status)
        {
        Mutex.Request();
        DecrementRefCount();

        Callback.Call->DecrementRefCount();

        if (0 == pAssocGroup)
            {
            ASSOCIATION_GROUP * Cas;

            Cas = AssociationGroups->FindOrCreate(&Callback.CasUuid,
                                                  (unsigned short) pAddress->Endpoint.TransportInterface->BasePduSize);
            if (0 == Cas)
                {
                // We want to retry later.
                Callback.State = NoCallbackAttempted;
                delete Callback.SecurityContext;
                return RPC_S_OUT_OF_MEMORY;
                }

            pAssocGroup = Cas;
            }

        if (Callback.SecurityContext)
            {
            SecurityContextDict.Insert(
                Callback.SecurityContext->AuthContextId,
                Callback.SecurityContext
                );

            if (MaxKeySeq <= Callback.KeySequence)
                {
                MaxKeySeq = Callback.KeySequence;
                ActiveSecurityContext = Callback.SecurityContext;
                }
            }
        else
            {
            ASSERT( Callback.State !=   ConvWayAuthInProgress &&
                    Callback.State != MsConvWayAuthInProgress );
            }

        if (Callback.ClientSequence == CurrentCall->GetSequenceNumber())
            {
            Callback.State = CallbackSucceeded;
            }
        else
            {
            Callback.State = CallbackFailed;
            Status         = RPC_S_CALL_FAILED;

            PDG_SCALL Call = Callback.Call;
            do
                {
                PDG_SCALL Next;

                Next = ActiveCalls.Successor(Call);
                Call->ConvCallbackFailed(Status);
                Call = Next;
                }
            while ( Call );
            }
        }
    else
        {
        LogError( SU_SCONN, EV_SEC_ACCEPT3, this, IntToPtr(Status), I_RpcGetExtendedError());

        delete Callback.SecurityContext;

        Mutex.Request();
        DecrementRefCount();

        Callback.Call->DecrementRefCount();

        //
        // Map SSPI errors to access-denied.  SSPI errors are facility code 0009 (see windows.h),
        // therefore all security errors are of the form 0x8009xxxx.  (Again, see wondows.h)
        //
        if (0x80090000UL == (Status & 0xffff0000UL))
            {
#ifdef DEBUGRPC
            if (Status != SEC_E_NO_IMPERSONATION     &&
                Status != SEC_E_UNSUPPORTED_FUNCTION )
                {
                PrintToDebugger("RPC DG: mapping security error %lx to access-denied\n", Status);
                }
#endif
            Status = RPC_S_SEC_PKG_ERROR;
            }

        PDG_SCALL Call = Callback.Call;
        do
            {
            PDG_SCALL Next;

            Next = ActiveCalls.Successor(Call);
            Call->ConvCallbackFailed(Status);
            Call = Next;
            }
        while ( Call );
        }

    return Status;
}


void
ConvCallCompletedWrapper(
                         PVOID Connection
                         )
{
    PDG_SCONNECTION(Connection)->ConvCallCompleted();
}

// it's a static procedure

void RPC_ENTRY
DG_SCONNECTION::ConvNotificationRoutine (
    RPC_ASYNC_STATE * pAsync,
    void *            Reserved,
    RPC_ASYNC_EVENT   Event
    )
{
    //
    // This function is called when the callback completes.  The current thread
    // is holding the connection mutex for the callback, so we can't linger
    // in this procedure.  The PostEvent call will cause all the expensive
    // operations to occur in a separate thread.
    //

    PDG_SCONNECTION Connection = PDG_SCONNECTION(pAsync->UserInfo);

    ASSERT( Event == RpcCallComplete );
    ASSERT( Connection->Callback.AsyncState.UserInfo == Connection );

    Connection->pAddress->Endpoint.TransportInterface->PostEvent( DG_EVENT_CALLBACK_COMPLETE, Connection);
}

void
DG_SCONNECTION::ConvCallCompleted()
{
    RPC_STATUS Status;

    //
    // Ensure a thread is listening for new packets.  We are in an expensive function.
    //
    pAddress->CheckThreadPool();

    do
        {
        Status = RpcAsyncCompleteCall( &Callback.AsyncState, 0 );
        if (RPC_S_INVALID_ASYNC_CALL != Status)
            {
            break;
            }
        Sleep(10);
        }
    while ( 1 );

#ifdef INDUCE_CONV_CALLBACK_RACES
    Callback.Status = 0xbaad;
#endif

    LogEvent(SU_SCONN, EV_STATUS, this, 0, Status);

    ASSERT( Status != RPC_S_INVALID_ASYNC_CALL &&
            Status != RPC_S_INVALID_ASYNC_HANDLE );

    if (!Status)
        {
        if (Callback.Status == ERROR_SHUTDOWN_IN_PROGRESS)
            {
            Callback.Status = RPC_P_CLIENT_SHUTDOWN_IN_PROGRESS;
            }

        Status = Callback.Status;
        LogEvent(SU_SCONN, EV_STATUS, this, 0, Status);
        }

    if (!Status)
        {
        if (Callback.State == ConvWayInProgress)
            {
            Status = UuidCreate((UUID *) &Callback.CasUuid);
            if (Status == RPC_S_UUID_LOCAL_ONLY)
                {
                Status = RPC_S_OK;
                }

            if (Status)
                {
                FinishConvCallback(Status);
                Mutex.Clear();
                return;
                }
            }
        else if (Callback.State == ConvWayAuthInProgress ||
                 Callback.State == ConvWayAuthMoreInProgress )
            {
            Callback.DataIndex += Callback.ResponseLength;
            }

        FinishConvCallback(Status);

        CallDispatchLoop();
        Mutex.Clear();
        }
    else switch (Callback.State)
        {
        case ConvWayAuthInProgress:
        case ConvWayAuthMoreInProgress:
            {
#ifdef INDUCE_CONV_CALLBACK_RACES
            Sleep(2000);
#endif
            if (RPC_S_SERVER_UNAVAILABLE == Status ||
                RPC_S_CALL_FAILED_DNE    == Status ||
                RPC_S_CALL_FAILED        == Status ||
                RPC_S_PROTOCOL_ERROR     == Status)
                {
                Callback.Status = NCA_STATUS_WHO_ARE_YOU_FAILED;
                }

            Callback.DataIndex += Callback.ResponseLength;

            if (NCA_STATUS_PARTIAL_CREDENTIALS == Status)
                {
                Callback.State = ConvWayAuthMoreInProgress;
                Callback.Status = 0;

                Status = RpcAsyncInitializeHandle(&Callback.AsyncState, sizeof(Callback.AsyncState));
                if (Status)
                    {
                    FinishConvCallback(Status);
                    Mutex.Clear();
                    return;
                    }

                if (Callback.Credentials->MaximumTokenLength() <= Callback.DataIndex)
                    {
                    FinishConvCallback(RPC_S_PROTOCOL_ERROR);
                    Mutex.Clear();
                    return;
                    }

                _conv_who_are_you_auth_more(
                    &Callback.AsyncState,
                    Callback.Binding,
                    (UUID *) &ActivityNode.Uuid,
                    ProcessStartTime,
                    Callback.DataIndex,
                    Callback.Credentials->MaximumTokenLength() - Callback.DataIndex,
                    Callback.ResponseBuffer + Callback.DataIndex,
                    &Callback.ResponseLength,
                    &Callback.Status
                    );

                //
                // If there is an error, see whether it is caused a notification.  If so,
                // ConvCallCompleted() has changed the callback state and this thread should do nothing.
                // If the state is unchanged, this thread must clean up.
                //
                if (Callback.Status)
                    {
                    Mutex.Request();

                    if (Callback.State == ConvWayAuthMoreInProgress)
                        {
                        FinishConvCallback(Callback.Status);

                        //
                        // The mutex was recursively claimed by FinishConvCallback().
                        //
                        Mutex.Clear();
                        Mutex.Clear();
                        return;
                        }
                    else
                        {
                        Mutex.Clear();
                        }
                    }

                break;
                }

            FinishConvCallback(Callback.Status);
            Mutex.Clear();
            break;
            }

        case ConvWay2InProgress:
            {
#ifdef INDUCE_CONV_CALLBACK_RACES
            Sleep(2000);
#endif

            //
            // If there is an error, see whether it is caused a notification.  If so,
            // ConvCallCompleted() has changed the callback state and this thread should do nothing.
            // If the state is unchanged, this thread must clean up.
            //
            Mutex.Request();                
            if (Callback.Status)
                {
                FinishConvCallback(Callback.Status);

                // The mutex was recursively claimed by FinishConvCallback().
                Mutex.Clear();
                Mutex.Clear();
                return;
                }
            else
                {
                Callback.State = ConvWayInProgress;
                Callback.Status = 0;
                }
            Mutex.Clear();

            Status = RpcAsyncInitializeHandle(&Callback.AsyncState, sizeof(Callback.AsyncState));
            if (Status)
                {
                FinishConvCallback(Status);
                Mutex.Clear();
                return;
                }

            Callback.AsyncState.NotificationType    = RpcNotificationTypeCallback;
            Callback.AsyncState.u.NotificationRoutine = ConvNotificationRoutine;
            Callback.AsyncState.UserInfo            = this;

            _conv_who_are_you(
                &Callback.AsyncState,
                Callback.Binding,
                (UUID *) &ActivityNode.Uuid,
                ProcessStartTime,
                &Callback.ClientSequence,
                &Callback.Status
                );

            //
            // If there is an error, see whether it is caused a notification.  If so,
            // ConvCallCompleted() has changed the callback state and this thread should do nothing.
            // If the state is unchanged, this thread must clean up.
            //
            if (Callback.Status)
                {
                Mutex.Request();

                if (Callback.State == ConvWayInProgress)
                    {
                    FinishConvCallback(Callback.Status);

                    //
                    // The mutex was recursively claimed by FinishConvCallback().
                    //
                    Mutex.Clear();
                    Mutex.Clear();
                    return;
                    }
                else
                    {
                    Mutex.Clear();
                    }
                }

            break;
            }

        case ConvWayInProgress:
            {
            FinishConvCallback(Callback.Status);
            Mutex.Clear();
            break;
            }

        // The Callback.State will be set to CallbackFailed if 
        // FinishConvCallback has already been called.  This is possible
        // if the callback has failed before the client side of the call 
        // returned from the conv_ routine.  In this case FinishConvCallback
        // will be called in DG_SCONNECTION::SubmitCallbackIfNecessary(), but also
        // a callback completion event will be queued, and we will process it here.
        case CallbackFailed:
            {
            break;
            }

        default:
            {
#ifdef DBG
            DbgPrint("RPC dg: unexpected callback state %x in connection %x\n", Callback.State, this);
            ASSERT( 0 );
            break;
#endif
            }
        }

    Mutex.VerifyNotOwned();
}


RPC_STATUS
DG_SCONNECTION::GetAssociationGroup(
    DG_TRANSPORT_ADDRESS RemoteAddress
    )
{
    if (pAssocGroup)
        {
        return RPC_S_OK;
        }

    Mutex.Request();

    if (pAssocGroup)
        {
        Mutex.Clear();
        return RPC_S_OK;
        }

    if (Callback.State == NoCallbackAttempted)
        {
        //
        // A callback is needed.
        //
        RPC_STATUS Status;

        Callback.State           = SetupInProgress;
        Callback.Binding         = 0;
        Callback.Credentials     = 0;
        Callback.TokenBuffer     = 0;
        Callback.ResponseBuffer  = 0;
        Callback.SecurityContext = 0;
        Callback.ThirdLegNeeded  = FALSE;
        Callback.DataRep         = 0;       // used only by secure c/b
        Callback.KeySequence     = 0;       // used only by secure c/b

        Callback.Call            = (DG_SCALL *) RpcpGetThreadContext();

        if (NULL == Callback.Call)
            {
            Callback.State = CallbackFailed;
            Mutex.Clear();
            return RPC_S_OUT_OF_MEMORY;
            }

        Callback.Call->IncrementRefCount();

        Status = CreateCallbackBindingAndReleaseMutex( RemoteAddress );

        if (Status)
            {
            FinishConvCallback(Status);
            Mutex.Clear();
            return Status;
            }

        Status = RpcAsyncInitializeHandle(&Callback.AsyncState, sizeof(Callback.AsyncState));
        if (Status)
            {
            FinishConvCallback(Status);
            Mutex.Clear();
            return Status;
            }

        Callback.AsyncState.NotificationType    = RpcNotificationTypeCallback;
        Callback.AsyncState.u.NotificationRoutine = ConvNotificationRoutine;
        Callback.AsyncState.UserInfo            = this;

        //
        // If this were a secure connection, we wouldn't get into the
        // unmarshalling routine w/o a callback, and we would be here now.
        // So use conv_who_are_you2.
        //
        Callback.State = ConvWay2InProgress;
        Callback.Status = 0;

        _conv_who_are_you2(
            &Callback.AsyncState,
            Callback.Binding,
            (UUID *) &ActivityNode.Uuid,
            ProcessStartTime,
            &Callback.ClientSequence,
            &Callback.CasUuid,
            &Callback.Status
            );

        //
        // If there is an error, see whether it is caused a notification.  If so,
        // ConvCallCompleted() has changed the callback state and this thread should do nothing.
        // If the state is unchanged, this thread must clean up.
        //
        if (Callback.Status)
            {
            Mutex.Request();

            if (Callback.State == ConvWay2InProgress)
                {
                FinishConvCallback(Callback.Status);

                //
                // The mutex was recursively claimed by FinishConvCallback().
                //
                Mutex.Clear();
                Mutex.Clear();
                return Callback.Status;
                }
            else
                {
                Mutex.Clear();
                }
            }
        }
    else
        {
        Mutex.Clear();
        }

    Mutex.VerifyNotOwned();

    //
    // Wait for the result.  This is not quite as efficient as using event notification,
    // but it's a lot simpler, and that's important at this late stage of the ship process.
    //
    while (Callback.State != CallbackSucceeded &&
           Callback.State != CallbackFailed)
        {
        Sleep(500);
        }

    return Callback.Status;
}



RPC_STATUS
DG_SCONNECTION::MakeApplicationSecurityCallback(
    RPC_INTERFACE * Interface,
    PDG_SCALL Call
    )
{
    RPC_STATUS Status = RPC_S_OK;

    // Check whether security callback is required and security is being used.
    if (!ActiveSecurityContext
        && !Interface->IsAllowingUnsecureCallbacks())
        {
        LogError(SU_SCONN, EV_STATUS, this, (void *) 112, RPC_S_ACCESS_DENIED );
        Status = RPC_S_ACCESS_DENIED;
        }
    // Handle the case when RPC security is being used and we can cache callbacks.
    else if (ActiveSecurityContext)
        {
        unsigned Info = InterfaceCallbackResults.Find(Interface);

        if ((Info & CBI_VALID)         == 0                               ||
            (Info & CBI_CONTEXT_MASK)  != ActiveSecurityContext->AuthContextId  ||
            (Info & CBI_SEQUENCE_MASK) != (Interface->SequenceNumber << CBI_SEQUENCE_SHIFT))
            {
            RPC_STATUS MyStatus;
            MyStatus = Interface->CheckSecurityIfNecessary(Call);

            if (RPC_S_OK == MyStatus)
                {
                LogEvent(SU_SCONN, EV_STATUS, this, (void *) 114, MyStatus );
                Info = CBI_ALLOWED;
                }
            else
                {
                LogError(SU_SCONN, EV_STATUS, this, (void *) 114, MyStatus );
                Info = 0;
                }

            Info |= CBI_VALID;
            Info |= ActiveSecurityContext->AuthContextId;
            Info |= (Interface->SequenceNumber << CBI_SEQUENCE_SHIFT);

            InterfaceCallbackResults.Update(Interface, Info);

            //
            // If the callback routine impersonated the client,
            // restore the thread to its native security context.
            //
            RevertToSelf();
            }
        else
            {
            LogEvent(SU_SCONN, EV_STATUS, this, (void *)115, Info);
            }

        if (0 == (Info & CBI_ALLOWED))
            {
            Status = RPC_S_ACCESS_DENIED;
            LogError(SU_SCONN, EV_STATUS, this, (void *) 113, Status );
            }
        }
    // Handle the case with no security and no caching.
    // This is only possible if the interface has been registered with
    // RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH flag.
    // Every callback is dispatched.
    else
        {
        ASSERT(Interface->IsAllowingUnsecureCallbacks());

        Status = Interface->CheckSecurityIfNecessary(Call);

        if (RPC_S_OK == Status)
            LogEvent(SU_SCONN, EV_STATUS, this, (void *) 114, Status );
        else
            LogError(SU_SCONN, EV_STATUS, this, (void *) 114, Status );

        RevertToSelf();
        }

    return Status;
}


RPC_STATUS
DG_SCONNECTION::SealAndSendPacket(
    IN DG_ENDPOINT *                 SourceEndpoint,
    IN DG_TRANSPORT_ADDRESS          RemoteAddress,
    IN UNALIGNED NCA_PACKET_HEADER  *Header,
    IN unsigned long                 DataOffset
    )
{
    ASSERT( 0 == ActivityNode.CompareUuid(&Header->ActivityId) );

    if (DG_REJECT == Header->PacketType)
        {
        return SendSecurePacket(  SourceEndpoint,
                                  RemoteAddress,
                                  Header,
                                  DataOffset,
                                  0
                                  );
        }
    else
        {
        return SendSecurePacket(  SourceEndpoint,
                                  RemoteAddress,
                                  Header,
                                  DataOffset,
                                  ActiveSecurityContext
                                  );
        }
}


RPC_STATUS
DG_SCALL::Cancel(
    void * ThreadHandle
    )
{
    Connection->Mutex.Request();

    ++Cancelled;
    BasePacketFlags2 |= DG_PF2_CANCEL_PENDING;

    Connection->Mutex.Clear();

    return RPC_S_OK;
}

unsigned
DG_SCALL::TestCancel()
{
    if (!Cancelled)
        {
        return 0;
        }

    unsigned CancelCount;

    Connection->Mutex.Request();

    CancelCount = Cancelled;
    Cancelled = 0;
    BasePacketFlags2 &= ~(DG_PF2_CANCEL_PENDING);

    Connection->Mutex.Clear();

    return CancelCount;
}


RPC_STATUS
DG_SCALL::WaitForPipeEvent()
{
    RPC_STATUS Status = RPC_S_OK;
    unsigned Locus;

    if (!PipeWaitEvent)
        {
        PipeWaitEvent = new EVENT(&Status, FALSE);
        if (!PipeWaitEvent)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }
        else if (Status != RPC_S_OK)
            {
            delete PipeWaitEvent;
            PipeWaitEvent = 0;
            }

        if (Status)
            {
            PipeWaitType = PWT_NONE;
            PipeThreadId = 0;
            return Status;
            }
        }

    IncrementRefCount();
    Connection->Mutex.Clear();

    PipeWaitEvent->Wait();

    Connection->Mutex.Request();
    DecrementRefCount();

    ASSERT(PipeThreadId == GetCurrentThreadId());
    PipeThreadId = 0;

    if (TerminateWhenConvenient)
        {
        Status = RPC_S_CALL_FAILED;
        }

    return Status;
}


BOOL
DG_SCALL::FinishSendOrReceive(
    BOOL Abort
    )
{
    RPC_ASYNC_EVENT Event;

    if (Abort)
        {
        TerminateWhenConvenient = TRUE;
        }

    switch (PipeWaitType)
        {
        case PWT_NONE:    return FALSE;
        case PWT_SEND:    Event = RpcSendComplete; break;
        case PWT_RECEIVE: Event = RpcReceiveComplete; break;
        default:          ASSERT(0 && "bad pipe wait type"); return FALSE;
        }

    ASSERT( PipeThreadId != 0 );

    PipeWaitType = PWT_NONE;

    if (!pAsync)
        {
        PipeWaitEvent->Raise();
        return TRUE;
        }

    if (Event == RpcSendComplete)
        {
        if (FinalSendBufferPresent)
            {
            PipeThreadId = 0;
            return FALSE;
            }
        }

    IssueNotification( Event );
    return TRUE;
}


RPC_STATUS
DG_SCALL::Receive(
    PRPC_MESSAGE Message,
    unsigned     Size
    )
/*++

Routine Description:

    When a server stub calls I_RpcReceive, this fn will be called
    in short order.

    Sync case: the fn waits until the requested buffer bytes are available,
               copies them to Message->Buffer, and returns.

    Async case: the fn returns the data if available now, otherwise
               RPC_S_ASYNC_CALL_PENDING.  The app will be notified when the
               data becomes available.  It can also poll.

    The action depends upon Message->RpcFlags:

        RPC_BUFFER_PARTIAL:

                Data is stored beginning at Message->Buffer[0].

                Wait only until <Message->BufferLength> bytes are available;
                we may resize the buffer if the fragment data exceeds the
                current buffer length.

        RPC_BUFFER_EXTRA:

                Data is stored beginning at Message->Buffer[Message->BufferLength].

Arguments:

    Message - the request.

        Message->Buffer is explicitly allowed to be zero, in which case this
        fn is responsible for allocating it.

Return Value:

    the usual error codes

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    unsigned Locus;

    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
        {
        LogEvent(SU_SCALL, EV_PROC, this, Message, 'A' + (('R' + (('c' + ('v' << 8)) << 8)) << 8));
        }
    else
        {
        LogEvent(SU_SCALL, EV_PROC, this, Message, 'R' + (('e' + (('c' + ('v' << 8)) << 8)) << 8));
        }

    LogEvent(SU_SCALL, EV_BUFFER_IN, this, Message->Buffer, (Message->RpcFlags << 4) | Size);

    Connection->Mutex.Request();

    if (TerminateWhenConvenient)
        {
        FreeBuffer(Message);

        Status = RPC_S_CALL_FAILED;
        if (pAsync)
            {
            //
            // case c) from doc:appref
            //
            DecrementRefCount();
            Cleanup();
            }

        Connection->Mutex.Clear();

        LogError(SU_SCALL, EV_STATUS, this, 0, Status);
        return Status;
        }

    //
    // Determine whether we already have enough data on hand.
    //
    BOOL fEnoughData;
    if (Message->RpcFlags & RPC_BUFFER_PARTIAL)
        {
        ASSERT(Size);

        if (fReceivedAllFragments || ConsecutiveDataBytes >= Size)
            {
            fEnoughData = TRUE;
            }
        else
            {
            fEnoughData = FALSE;
            PipeWaitLength = Size;
            }
        }
    else
        {
        fEnoughData = fReceivedAllFragments;
        PipeWaitLength = 0;
        }

    //
    // Wait for enough data.
    //
    if (!fEnoughData)
        {
        if (Message->RpcFlags & RPC_BUFFER_NONOTIFY)
            {
            Connection->Mutex.Clear();

            LogEvent(SU_SCALL, EV_STATUS, this, 0, RPC_S_ASYNC_CALL_PENDING);
            return RPC_S_ASYNC_CALL_PENDING;
            }

        if (Message->RpcFlags & RPC_BUFFER_ASYNC)
            {
            ASSERT((PWT_NONE    == PipeWaitType && 0 == PipeThreadId) ||
                   (PWT_RECEIVE == PipeWaitType && GetCurrentThreadId() == PipeThreadId));

            PipeWaitType   = PWT_RECEIVE;
            PipeThreadId   = GetCurrentThreadId();

            Connection->Mutex.Clear();

            LogEvent(SU_SCALL, EV_STATUS, this, 0, RPC_S_ASYNC_CALL_PENDING);
            return RPC_S_ASYNC_CALL_PENDING;
            }
        else
            {
            ASSERT(PWT_NONE == PipeWaitType);
            ASSERT(0 == PipeThreadId);

            PipeWaitType   = PWT_RECEIVE;
            PipeThreadId   = GetCurrentThreadId();

            Status = WaitForPipeEvent();
            if (Status)
                {
                //
                // I would like to delete the buffer here, but NDR has already saved Message->Buffer
                // somewhere else and will later ask that it be deleted again.
                //
                //  FreeBuffer(Message);

                if (pAsync)
                    {
                    //
                    // case c) from doc:appref
                    //
                    InitErrorPacket(pSavedPacket, DG_FAULT, Status);
                    SealAndSendPacket(&pSavedPacket->Header);
                    DecrementRefCount();
                    Cleanup();
                    }

                Connection->Mutex.Clear();

                LogError(SU_SCALL, EV_STATUS, this, 0, Status);
                return Status;
                }
            }
        }

    //
    // This is here only for async receive case, but the if() clause
    // would only slow us down.
    //
    ASSERT( PipeWaitType == PWT_NONE );
    PipeThreadId = 0;

    //
    // For secure RPC, verify packet integrity.
    //
    if (Connection->AuthInfo.AuthenticationLevel > RPC_C_AUTHN_LEVEL_NONE)
        {
        PDG_PACKET pScan = pReceivedPackets;

        do
            {
            Status = Connection->VerifyRequestPacket(pScan);
            pScan = pScan->pNext;
            }
        while (pScan && Status == RPC_S_OK);
        }

    if (RPC_S_OK == Status)
        {
        Status = AssembleBufferFromPackets(Message);
        }

    if (Status)
        {
        LogError(SU_SCALL, EV_STATUS, this, 0, Status);
        FreeBuffer(Message);
        }

    Connection->Mutex.Clear();

    LogEvent(SU_SCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);
    return Status;
}


RPC_STATUS
DG_SCALL::Send(
    PRPC_MESSAGE Message
    )
/*++

Routine Description:

    Transfers a pipe data buffer to the client.

Arguments:

    Message - the usual data

Return Value:

    the usual suspects

--*/
{
    RPC_STATUS Status;

    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
        {
        LogEvent(SU_SCALL, EV_PROC, this, Message, 'A' + (('S' + (('n' + ('d' << 8)) << 8)) << 8));
        }
    else
        {
        LogEvent(SU_SCALL, EV_PROC, this, Message, 'S' + (('e' + (('n' + ('d' << 8)) << 8)) << 8));
        }

    LogEvent(SU_SCALL, EV_BUFFER_IN, this, Message->Buffer, (Message->RpcFlags << 4) | Message->BufferLength);

    //
    // No notification occurs on the buffer containing the [out] static args.
    // This is consistent with synchronous pipes.
    //
    if (!(Message->RpcFlags & RPC_BUFFER_PARTIAL))
        {
        FinalSendBufferPresent = TRUE;
        Message->RpcFlags |= RPC_BUFFER_NONOTIFY;
        }

    Connection->Mutex.Request();

    ASSERT(fReceivedAllFragments);

    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
        {
        ASSERT(pAsync);
        }
    else
        {
        ASSERT(State == CallDispatched      ||
               State == CallSendingResponse ||
               State == CallAfterDispatch   );
        }

    if (TerminateWhenConvenient)
        {
        FreeBuffer(Message);

        SetState(CallSendingResponse);
        Status = RPC_S_CALL_FAILED;
        if (pAsync)
            {
            //
            // case c) from doc:appref
            //
            DecrementRefCount();
            Cleanup();
            }

        Connection->Mutex.Clear();

        LogError(SU_SCALL, EV_STATUS, this, (void *) 1 , Status);
        return Status;
        }

    SetFragmentLengths();

    if ((Message->RpcFlags & RPC_BUFFER_PARTIAL) &&
        Message->BufferLength < (ULONG) MaxFragmentSize * SendWindowSize )
        {
        if (pAsync)
            {
            IssueNotification( RpcSendComplete );
            }

        Connection->Mutex.Clear();

        LogEvent(SU_SCALL, EV_STATUS, this, (void *) 2, RPC_S_SEND_INCOMPLETE);
        return RPC_S_SEND_INCOMPLETE;
        }

    if (State != CallSendingResponse)
        {
        SetState(CallSendingResponse);
        CleanupReceiveWindow();
        }

    //
    // Set the message buffer as the current send buffer.
    //
    Status = PushBuffer(Message);

    //
    // Ignore normal send errors - they are usually transient and a retry fixes the problem.
    //
    if (Status == RPC_P_SEND_FAILED)
        {
        Status = 0;
        }

    if (Status)
        {
        FreeBuffer(Message);

        if (pAsync)
            {
            //
            // case c) from doc:appref
            //
            InitErrorPacket(pSavedPacket, DG_FAULT, Status);
            SealAndSendPacket(&pSavedPacket->Header);
            DecrementRefCount();
            Cleanup();
            }

        Connection->Mutex.Clear();

        LogError(SU_SCALL, EV_STATUS, this, (void *) 3, Status);
        return Status;
        }

    PipeWaitType = PWT_SEND;
    PipeThreadId = GetCurrentThreadId();

    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
        {
        }
    else
        {
        Status = WaitForPipeEvent();
        if (Status)
            {
            if (pAsync)
                {
                //
                // case c) from doc:appref
                //
                InitErrorPacket(pSavedPacket, DG_FAULT, Status);
                SealAndSendPacket(&pSavedPacket->Header);
                DecrementRefCount();
                Cleanup();
                }

            Connection->Mutex.Clear();

            LogError(SU_SCALL, EV_STATUS, this, (void *) 4, Status);
            return Status;
            }
        }

    if (pAsync && !(Message->RpcFlags & RPC_BUFFER_PARTIAL))
        {
        //
        // case b) from doc:appref
        // Don't nuke the call, just remove the extra reference
        //
        DecrementRefCount();
        }

    Connection->Mutex.Clear();

    //
    // Be careful looking at member data from here on!
    //

    //
    // if this was a PARTIAL send and the buffer did not occupy an even
    // number of packets, the message buffer and length now reflect
    // the unsent portion.
    //
    if (!Status && Message->BufferLength)
        {
        Status = RPC_S_SEND_INCOMPLETE;
        }

    if (Status)
        {
        LogEvent(SU_SCALL, EV_STATUS, this, 0, Status);
        }

    LogEvent(SU_SCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);

    return Status;
}


RPC_STATUS
DG_SCALL::AsyncSend (
    IN OUT PRPC_MESSAGE Message
    )
{
    return Send(Message);
}


RPC_STATUS
DG_SCALL::AsyncReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
{
    return Receive(Message, Size);
}

RPC_STATUS
DG_SCALL::InqLocalConnAddress (
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    This routine is used by a server application to inquire about the local
    address on which a call is made.

Arguments:

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported for datagrams is RPC_P_ADDR_FORMAT_TCP_IPV4.

Return Values:

    RPC_S_OK - success.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete this
        operation.

    RPC_S_INVALID_BINDING - The supplied client binding is invalid.

    RPC_S_CANNOT_SUPPORT - The local address was inquired for a protocol 
        sequence that doesn't support this type of functionality. Currently
        only ncacn_ip_tcp supports it.

    RPC_S_* or Win32 error for other errors
--*/
{
    if (*BufferSize < sizeof(DWORD))
        {
        *BufferSize = sizeof(DWORD);
        return ERROR_MORE_DATA;
        }

    *AddressFormat = RPC_P_ADDR_FORMAT_TCP_IPV4;
    *(DWORD *)Buffer = LocalAddress;

    return RPC_S_OK;
}


RPC_STATUS
DG_SCALL::SetAsyncHandle (
    IN RPC_ASYNC_STATE * hAsync
    )
{
    THREAD *MyThread = RpcpGetThreadPointer();

    ASSERT(MyThread);
    LogEvent(SU_SCALL, EV_PROC, this, 0, 'S' + (('e' + (('t' + ('H' << 8)) << 8)) << 8));

    MyThread->fAsync = TRUE;
    Connection->Mutex.Request();

    ASSERT( State == CallDispatched );

    ASSERT(0 == pAsync);

    pAsync = hAsync;

    if (Interface->IsAutoListenInterface())
        {
        Interface->BeginAutoListenCall();
        }
    Interface->BeginNullManagerCall();

    IncrementRefCount();

    Connection->Mutex.Clear();
    return RPC_S_OK;
}


RPC_STATUS
DG_SCALL::AbortAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    )
{
    LogEvent(SU_SCALL, EV_PROC, this, 0, 'A' + (('b' + (('t' + ('C' << 8)) << 8)) << 8));

    Connection->Mutex.Request();

    ASSERT( State == CallDispatched    ||
            State == CallAfterDispatch );

    if ( State != CallDispatched    &&
         State != CallAfterDispatch )
        {
        Connection->Mutex.Clear();
        return RPC_S_INVALID_ASYNC_CALL;
        }

    SetState(CallSendingResponse);

    CleanupReceiveWindow();

    // case d) from doc:appref
    //
    InitErrorPacket(pSavedPacket, DG_FAULT, ExceptionCode);
    SealAndSendPacket(&pSavedPacket->Header);
    DecrementRefCount();
    Cleanup();

    Connection->Mutex.Clear();

    return RPC_S_OK;
}


BOOL
DG_SCALL::IssueNotification (
    IN RPC_ASYNC_EVENT Event
    )
{
    LogEvent(SU_SCALL, EV_NOTIFY, this, 0, Event);

    if (Event == RpcSendComplete && !(pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
        {
        return TRUE;
        }

    if (pAsync->NotificationType == RpcNotificationTypeApc)
        {
        IncrementRefCount();
        }

    int i;
    for (i=1; i < 3; ++i)
        {
        if (CALL::IssueNotification(Event))
            {
            return TRUE;
            }

        Sleep(200);
        }

    DecrementRefCount();

    return FALSE;
}


void
DG_SCALL::FreeAPCInfo (
    IN RPC_APC_INFO *pAPCInfo
    )
{
    LogEvent(SU_SCALL, EV_APC, this);

    Connection->Mutex.Request();

    DecrementRefCount();

    BOOL Final = FALSE;

    if (pAPCInfo->Event == RpcSendComplete &&
        !(BufferFlags & RPC_BUFFER_PARTIAL))
        {
        Final = TRUE;
        }

    CALL::FreeAPCInfo(pAPCInfo);

    if (Final)
        {
        Cleanup();
        }

    Connection->Mutex.Clear();
}

void
DG_SCALL::FreePipeBuffer (
    IN PRPC_MESSAGE Message
    )
{
    FreeBuffer(Message);
}

RPC_STATUS
DG_SCALL::ReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    )
{
    LogEvent(SU_SCALL, EV_PROC, this, Message, 'R' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));
    LogEvent(SU_SCALL, EV_BUFFER_IN, this, Message->Buffer, (Message->RpcFlags << 4) | Message->BufferLength);

    Connection->Mutex.Request();

    if (TerminateWhenConvenient)
        {
        Connection->Mutex.Clear();
        LogError(SU_SCALL, EV_STATUS, this, 0, RPC_S_CALL_FAILED);
        return RPC_S_CALL_FAILED;
        }

    RPC_STATUS Status;

    //
    // If we are updating the [in] buffer, we need to inform
    // DispatchToStubWorker of the new [in] buffer.
    //
    void * OldBuffer = Message->Buffer;

    Status = CommonReallocBuffer(Message, NewSize);
    if (Status == RPC_S_OK)
        {
        if (OldBuffer == DispatchBuffer)
            {
            DispatchBuffer = Message->Buffer;
            }

        // The ReservedForRuntime field is a local variable of ProcessRpcCall,
        // so it is valid only during dispatch.
        //
        if (State == CallDispatched)
            {
            PRPC_RUNTIME_INFO Info = (PRPC_RUNTIME_INFO) Message->ReservedForRuntime;
            if (OldBuffer == Info->OldBuffer)
                {
                Info->OldBuffer = Message->Buffer;
                }
            }

#ifdef MONITOR_SERVER_PACKET_COUNT
        if (Message->Buffer != OldBuffer)
            {
            ASSERT( DG_PACKET::FromStubData(Message->Buffer)->pCount == 0 );
            DG_PACKET::FromStubData(Message->Buffer)->pCount = &OutstandingPacketCount;
            InterlockedIncrement( &OutstandingPacketCount );
            LogEvent( SU_SCALL, '(', this, DG_PACKET::FromStubData(Message->Buffer), OutstandingPacketCount );
            }
#endif
        }

    Connection->Mutex.Clear();

    LogEvent(SU_SCALL, EV_BUFFER_OUT, this, Message->Buffer, (Message->RpcFlags << 4) | Message->BufferLength);
    if (Status)
        {
        LogError(SU_SCALL, EV_STATUS, this, 0, Status);
        }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dispatch.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    dispatch.h

Abstract:

Author:

    Michael Montague (mikemon) 11-Jun-1992

Revision History:

--*/

#include <sysinc.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <dispatch.h>


unsigned int
DispatchToStubInCNoAvrf (
    IN RPC_DISPATCH_FUNCTION Stub,
    IN OUT PRPC_MESSAGE Message,
    OUT RPC_STATUS * ExceptionCode
    )
/*++

Routine Description:

    Dispatch a remote procedure call to a stub.  This must be in C
    because cfront does not support try-except on MIPS.

Arguments:

    Stub - Supplies the pointer to the function to dispatch to.

    Message - Supplies the request and returns the response.

    ExceptionCode - Returns the exception code if an exception
        occured.

Return Value:

    A non-zero value will be returned in an exception occured.

--*/
{
    unsigned int ExceptionHappened = 0;

    RpcTryExcept
        {
        (*Stub)(Message);
        }

    // Return "non-fatal" errors to clients.  Catching fatal errors
    // makes it harder to debug.
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        ExceptionHappened = 1;
        *ExceptionCode = RpcExceptionCode();
        ASSERT(*ExceptionCode != RPC_S_OK);
        }
    RpcEndExcept

    return(ExceptionHappened);
}


unsigned int
DispatchToStubInCAvrf (
    IN RPC_DISPATCH_FUNCTION Stub,
    IN OUT PRPC_MESSAGE Message,
    OUT RPC_STATUS * ExceptionCode
    )
/*++

Routine Description:

    Dispatch a remote procedure call to a stub.  This is a wrapper
    around DispatchToStubInCNoAvrf that is called when app verifier is enabled.
    It makes sure that the server routine has not orphaned a critical section.

Arguments:

    Same as for DispatchToStubInCNoAvrf.

Return Value:

    A non-zero value will be returned in an exception occured.

--*/
{
    unsigned int ExceptionHappened;

    ExceptionHappened = DispatchToStubInCNoAvrf (Stub, Message, ExceptionCode);

    // Make sure this is not a callback.
    // A thread dispatching a callback may be legitimately holding a critsec in user code
    // or a connection mutex in the case of DG.
    if (!IsCallbackMessage(Message))
        {
        RtlCheckForOrphanedCriticalSections(NtCurrentThread());
        }

    return(ExceptionHappened);
}

// Initialize the dispatch routine to the default one to be used in the
// absence of app verifier.
DISPATCH_TO_STUB DispatchToStubInC = DispatchToStubInCNoAvrf;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\epmap.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    epmap.h

Abstract:

    This file specifies the interface to the endpoint mapper Dll which
    provides endpoint mapping services to the RPC runtime.

Author:

    Michael Montague (mikemon) 06-Jan-1992

Revision History:

--*/

#ifndef __EPMAP_H__
#define __EPMAP_H__

START_C_EXTERN

// If the user did not specify a call timeout we will wait for the ep mapper
// for 10 minutes.
#define DEFAULT_EPMAP_CALL_TIMEOUT 10*60*1000

typedef struct _ProtseqEndpointPair {
  RPC_CHAR *Protseq;
  RPC_CHAR *Endpoint;
  INT   ProtocolId;
} ProtseqEndpointPair;

RPC_STATUS RPC_ENTRY
EpResolveEndpoint (
    IN UUID PAPI * ObjectUuid, OPTIONAL
    IN RPC_SYNTAX_IDENTIFIER PAPI * IfId,
    IN RPC_SYNTAX_IDENTIFIER PAPI * XferId,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    IN RPC_CHAR PAPI * NetworkAddress,
    IN RPC_CHAR PAPI * NetworkOptions,
    IN OUT void PAPI * PAPI * EpLookupHandle,
    IN unsigned ConnTimeout,
    IN ULONG CallTimeout,
    IN CLIENT_AUTH_INFO *AuthInfo, OPTIONAL
    OUT RPC_CHAR * PAPI * Endpoint
    );

    
RPC_STATUS  RPC_ENTRY
EpGetEpmapperEndpoint(
    IN OUT RPC_CHAR  * PAPI * Endpoint,
    IN RPC_CHAR  PAPI * Protseq
    );

void RPC_ENTRY
EpFreeLookupHandle (
    IN void PAPI * EpLookupHandle
    );

RPC_STATUS RPC_ENTRY
BindToEpMapper(
    OUT RPC_BINDING_HANDLE PAPI * MapperHandle,
    IN RPC_CHAR * NWAddress OPTIONAL,
    IN RPC_CHAR * Protseq OPTIONAL,
    IN RPC_CHAR * Options OPTIONAL,
    IN unsigned ConnTimeout,
    IN ULONG CallTimeout,
    IN CLIENT_AUTH_INFO *AuthInfo OPTIONAL
    );

RPC_STATUS
InitializeEPMapperClient(
    void
    );

END_C_EXTERN

#endif // __EPMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dumpcert.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dumpcert.cxx
//
//--------------------------------------------------------------------------

#include "precomp.hxx"
#include <wincrypt.h>
#include <rpcssl.h>

#if 0

stuff clobbered by Unicode -> ANSI port:

wchar_t -> char
WCHAR   -> char
L""     -> ""
%S      -> %s
W suffix-> A suffix
wcscmp  -> strcmp
wmain   -> main
LPWSTR  -> LPSTR

#endif


#define ByteSwapShort(Value) \
    Value = (  (((Value) & 0x00FF) << 8) \
             | (((Value) & 0xFF00) >> 8))

#define INITIAL_NAME_LENGTH 100

#define     MSSTD_PREFIX_LENGTH 6
const char MSSTD_PREFIX[]    = "msstd:";

#define     FULLPATH_PREFIX_LENGTH 8
const char FULLPATH_PREFIX[] = "fullsic:";

//------------------------------------------------------------------------

void DumpCertInfo( PCERT_INFO Info );
void RecordErrorAndExit( char * Action, unsigned long Error );

extern "C"
{
int __cdecl
main( int argc,
       char * argv[],
       char * envp[]
       );
}



int __cdecl
main(  int argc,
       char * argv[],
       char * envp[]
       )
{
    HCERTSTORE Store;
    PCCERT_CONTEXT Context = 0;
    unsigned Criterion  = CERT_FIND_ANY;
    void *   SearchData = 0;
    char * StoreName = "My";
    int i;
    char * MatchString = 0;
    BOOL fMatch = FALSE;
    BOOL fOutput = FALSE;
    unsigned long OutputFlags = 0;
    DWORD StoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;

    for (i=1; i < argc; ++i)
        {
        if (0 == strcmp(argv[i], "-subject"))
            {
            Criterion = CERT_FIND_SUBJECT_STR_W;
            ++i;
            if (i >= argc)
                {
                printf("-subject must be followed by a subject name or substring\n");
                return 1;
                }

            SearchData = argv[i];
            }
        else if (0 == strcmp(argv[i], "-issuer"))
            {
            Criterion = CERT_FIND_ISSUER_STR_W;
            ++i;
            if (i >= argc)
                {
                printf("-issuer must be followed by an issuer name or substring\n");
                return 1;
                }
            SearchData = argv[i];
            }
        else if (0 == strcmp(argv[i], "-store"))
            {
            ++i;
            if (i >= argc)
                {
                printf("-store must be followed by a store name, such as 'Root' or 'My'\n");
                return 1;
                }
            StoreName = argv[i];
            }
        else if (0 == strcmp(argv[i], "-location"))
            {
            ++i;

            if (i >= argc)
                {
                printf("-location must be followed by 'USER:' or by 'HKLM'\n");
                return 1;
                }

            if (0 == strcmp(argv[i], "USER:"))
                {
                StoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
                }
            else if (0 == strcmp(argv[i], "HKLM"))
                {
                StoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
                }
            else
                {
                printf("-location must be followed by 'USER:' or by 'HKLM'\n");
                return 1;
                }
            }
        else if (0 == strcmp(argv[i], "-output"))
            {
            fOutput = TRUE;
            ++i;

            if(i >= argc)
                {
                printf("-output must be followed by 'msstd' or by 'fullsic'\n");
                return 1;
                }

            if (0 == strcmp(argv[i], "fullsic"))
                {
                OutputFlags = RPC_C_FULL_CERT_CHAIN;
                }
            else if (0 == strcmp(argv[i], "msstd"))
                {
                OutputFlags = 0;
                }
            else
                {
                printf("-output must be followed by 'msstd' or by 'fullsic'\n");
                return 1;
                }
            }
        else if (0 == strcmp(argv[i], "-match"))
            {
            fMatch = TRUE;

            ++i;
            if(i >= argc)
                {
                printf("-match must be followed by '@filename', listing the name of the file containing the match string\n");
                return 1;
                }

            if (argv[i][0] == '@')
                {
                DWORD BytesRead;
                HANDLE hMatchFile;

                hMatchFile = CreateFileA( argv[i]+1,
                                          GENERIC_READ,
                                          FILE_SHARE_READ,
                                          0,                 // no security
                                          OPEN_EXISTING,     // must already exist
                                          FILE_ATTRIBUTE_NORMAL,
                                          NULL               // no template file
                                          );

                if (hMatchFile == ULongToHandle(0xffffffff))
                    {
                    printf("can't open file %s\n", argv[i]+1);
                    return 1;
                    }

                DWORD Size = GetFileSize( hMatchFile, 0);
                if (Size == 0xffffffff)
                    {
                    printf("GetFileSize failed with 0x%x\n", GetLastError());
                    return 1;
                    }

                if (Size % 2)
                    {
                    printf("the match-string file must be in Unicode.\n");
                    return 1;
                    }

                MatchString = new char[ Size/sizeof(char) + sizeof(char) ];
                if (!MatchString)
                    {
                    printf("can't allocate memory\n");
                    return 1;
                    }

                if (!ReadFile( hMatchFile,
                               MatchString,
                               Size,
                               &BytesRead,
                               0            // not overlapped
                               )
                    || BytesRead != Size)
                    {
                    printf("can't read file data: 0x%x\n", GetLastError());
                    return 1;
                    }

                MatchString[ Size/sizeof(char) ] = 0;

                if (MatchString[0] == 0xfeff)
                    {
                    ++MatchString;
                    }
                else if (MatchString[0] == 0xfffe)
                    {
                    char * pc;

                    for (pc = MatchString; *pc; ++pc)
                        {
                        ByteSwapShort(*pc);
                        }

                    ++MatchString;
                    }
                }
            else
                {
                MatchString = argv[i];
                }

            printf("string to match is '%s'\n", MatchString);
            }
        else if (0 == strcmp(argv[i], "-?") ||
                 0 == strcmp(argv[i], "-help"))
            {
            printf("usage:\n"
                   "    dumpcert \n"
                   "        [-subject subject-substring]\n"
                   "        [-issuer issuer-substring]\n"
                   "        [-store store-name]\n"
                   "        [-output ('fullsic' | 'msstd')\n"
                   "        [-location ('HKLM' | 'USER:')\n"
                   "        [-match @filename]\n"
                   );
            return 1;
            }
        else
            {
            printf("unknown option '%s'\n", argv[i]);
            return 1;
            }
        }

    Store = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                           0,
                           0,
                           StoreFlags,
                           StoreName
                           );

    if (!Store)
        {
        RecordErrorAndExit("opening the store", GetLastError());
        }

    for(;;)
        {
        Context = CertFindCertificateInStore( Store,
                                              X509_ASN_ENCODING,
                                              0,
                                              Criterion,
                                              SearchData,
                                              Context
                                              );
        if (!Context)
            {
            break;
            }

        DumpCertInfo( Context->pCertInfo );
        if (fOutput)
            {
            unsigned char * OutputBuffer = 0;
            DWORD Status = RpcCertGeneratePrincipalNameA( Context, OutputFlags, &OutputBuffer );
            if (Status)
                {
                printf("GeneratePrincName returned %d = 0x%x\n", Status, Status);
                }
            else
                {
                printf("    generated name = '%s'\n", OutputBuffer);
                }
            }

        if (fMatch)
            {
            printf("matching is not implemented because RpcCertMatchPrincipalName is not exported\n");
#if 0
            DWORD Status = RpcCertMatchPrincipalName( Context, MatchString );
            if (Status)
                {
                printf("MatchPrincipalName returned %d = 0x%x\n", Status, Status);
                }
            else
                {
                printf("The names matched.\n");
                }
#endif
            }
        }

    if (GetLastError() != CRYPT_E_NOT_FOUND)
        {
        RecordErrorAndExit("getting certificates", GetLastError());
        }

    return 0;
}

void DumpCertInfo( PCERT_INFO Info )
{
    SYSTEMTIME NotBeforeTime;
    SYSTEMTIME NotAfterTime;
    char      SubjectName[1000];
    char      IssuerName[1000];

    if (!FileTimeToSystemTime( &Info->NotBefore, &NotBeforeTime ))
        {
        RecordErrorAndExit("translating not-before time", GetLastError());
        }

    if (!FileTimeToSystemTime( &Info->NotAfter, &NotAfterTime ))
        {
        RecordErrorAndExit("translating not-after time",  GetLastError());
        }

    if (!CertNameToStrA( X509_ASN_ENCODING,
                        &Info->Subject,
                        CERT_X500_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG,
                        SubjectName,
                        sizeof(SubjectName)
                        ))
        {
        RecordErrorAndExit("unpacking subject name", GetLastError());
        }

    if (!CertNameToStrA( X509_ASN_ENCODING,
                        &Info->Issuer,
                        CERT_X500_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG,
                        IssuerName,
                        sizeof(IssuerName)
                        ))
        {
        RecordErrorAndExit("unpacking issuer name", GetLastError());
        }

    printf("----------------------------------------------------\n\n");

    printf("    subject: %s\n", SubjectName);
    printf("    issuer:  %s\n", IssuerName);
    printf("    version %d\n", Info->dwVersion );
    printf("    valid from %02d:%02d:%02d on %d-%02d-%d\n",
           NotBeforeTime.wHour,
           NotBeforeTime.wMinute,
           NotBeforeTime.wSecond,
           NotBeforeTime.wMonth,
           NotBeforeTime.wDay,
           NotBeforeTime.wYear
           );

    printf("          to   %02d:%02d:%02d on %d-%02d-%d\n",
           NotAfterTime.wHour,
           NotAfterTime.wMinute,
           NotAfterTime.wSecond,
           NotAfterTime.wMonth,
           NotAfterTime.wDay,
           NotAfterTime.wYear
           );
}


void RecordErrorAndExit( char * Action, unsigned long Error )
{
    char * lpMsgBuf = "";

    FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                   FORMAT_MESSAGE_FROM_SYSTEM |
                   FORMAT_MESSAGE_IGNORE_INSERTS,
                   NULL,
                   Error,
                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                   (LPSTR) &lpMsgBuf,
                   0,
                   NULL
                   );

    printf("error while %s: %x (%d) \"%s\"", Action, Error, Error, lpMsgBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\epmapper.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    epmapper.cxx

Abstract:

    This routine implements the server side DCE runtime APIs.  The
    routines in this file are used by server applications only.

Author:

    Bharat Shah (barats) 3-5-92

Revision History:

    06-03-96    gopalp      Added code to cleanup stale EP Mapper entries.

--*/

#include <precomp.hxx>
#include <rpcobj.hxx>
#include <epmap.h>
#include <epmp.h>
#include <twrproto.h>
#include <startsvc.h>
#include <hndlsvr.hxx>
#include <CharConv.hxx>


//
// Global EP cleanup context handle. Initially NULL, this will
// be allocated by Endpoint Mapper. As of now, it points to the
// EP entries registered by this process. This way, the Endpoint
// Mapper can cleanup entries of this process as soon as process
// goes away.
//

void * hEpContext = NULL;
MUTEX *EpContextMutex = NULL;


RPC_STATUS
InitializeEPMapperClient(
    void
    )
{
    RPC_STATUS Status = RPC_S_OK;

    if (EpContextMutex == NULL)
        {
        EpContextMutex = new MUTEX(&Status,
                                   TRUE     // pre-allocate semaphore
                                   );

        if (EpContextMutex == NULL)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            delete EpContextMutex;
            EpContextMutex = NULL;
            }
        }

    return Status;
}

inline void RequestEPClientMutex(void)
{
    EpContextMutex->Request();
}

inline void ClearEPClientMutex(void)
{
    EpContextMutex->Clear();
}


RPC_STATUS
BindingAndIfToTower(
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_HANDLE BindingHandle,
    OUT twr_t PAPI * PAPI * Tower
)
/*+

Routine Description:
    Helper routine that returns a Tower from the Interface Spec
    and a bindinh handle

Arguments:

    IfSpec - Client or Server IfSpec structure.

    BindingHandle - A partially bound binding handle

    Tower - Returns a Tower if the Binding Handle had a
        dynamic endpoint, else Tower=NULL. The caller needs
        to free this memory.

Return Value:

    RPC_S_OK - The ansi string was successfully converted into a unicode
        string.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available for the unicode
        string.

    EP_S_CANT_PERFORM_OP - The Binding Handle or IfSpec were in valid.

--*/
{
    RPC_STATUS err          = 0;
    unsigned char *Protseq  = 0;
    unsigned char *NWAddress= 0;
    unsigned char *Binding  = 0;
    unsigned char *Endpoint = 0;
    RPC_CHAR * String       = 0;
    RPC_IF_ID Ifid;
    RPC_TRANSFER_SYNTAX Xferid;
    unsigned int Size;

    *Tower = NULL;
    err = RpcIfInqId(IfSpec, &Ifid);
    if (!err)
        {
        err = I_RpcIfInqTransferSyntaxes(
                    IfSpec,
                    &Xferid,
                    sizeof(Xferid),
                    &Size
                    );
        }

    if (!err)
        {
        err = I_RpcBindingInqDynamicEndpoint(BindingHandle, &String);
        }

    if (err)
        {
        return (err);
        }


    if (!err)
        {
        err = RpcBindingToStringBindingA(BindingHandle, &Binding);
        }

    if (!err)
        {
        if (String != 0)
            {
            // It is a dynamic endpoint
            Endpoint = UnicodeToAnsiString(String, &err);
            if (!err)
                {
                err = RpcStringBindingParseA(
                            Binding,
                            NULL,
                            &Protseq,
                            &NWAddress,
                            NULL,
                            NULL
                            );
                }
            }
        else
            {
            err = RpcStringBindingParseA(
                        Binding,
                        NULL,
                        &Protseq,
                        &NWAddress,
                        &Endpoint,
                        NULL
                        );
            }
        }

    if (!err)
        {
        err = TowerConstruct(
                    &Ifid,
                    &Xferid,
                    (char PAPI*)Protseq,
                    (char PAPI *)Endpoint,
                    (char PAPI *)NWAddress,
                    Tower
                    );
        }

    if (Endpoint)
        RpcStringFreeA(&Endpoint);

    if (String)
        RpcStringFreeA((unsigned char PAPI * PAPI *)&String);

    if (Protseq)
        RpcStringFreeA(&Protseq);

    if (NWAddress)
        RpcStringFreeA(&NWAddress);

    if (Binding)
        RpcStringFreeA(&Binding);

    return(err);
}




RPC_STATUS
RegisterEntries(
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * ObjUuidVector,
    IN unsigned char * Annotation,
    IN unsigned long ReplaceNoReplace
    )
/*++


Routine Description:

    This helper function is called by RpcEpRegister or RpcEpRegisterNoReplace
    Depending on the TypeOp, it tries to Add or replace endpoint entries
    in the EP-database.

Arguments:

    IfSpec - Interface Spec Handle for which the entries are to be registered.

    BindingVector - A Vector of Binding Handles which need to be registered

    ObjUUIDVector - A Vector of Objects

    Annotation - A String representing the Annotation

    TypeOp - A Flag : REGISTER_REPLACE or REGISTER_NO_REPLACE

Return Value:

    RPC_S_OK - Some of the entries specified were successfully registered.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available,

    EP_S_CANT_PERFORM_OP - Misc. local error occured; e.g. could not bind to
        the EpMapper.

--*/
{
    RPC_STATUS err;
    unsigned int i, j, k, Entries, CountBH, CountObj;
    RPC_BINDING_HANDLE EpMapperHandle;
    unsigned char * PStringBinding = NULL;
    twr_p_t Twr;
    ept_entry_t * EpEntries = NULL, *p;
    unsigned long ArgC = 0;
    char *ArgV[1] = { NULL };

    if (BindingVector->Count == 0)
        {
        //
        // PNP
        //
        err = GlobalRpcServer->InterfaceExported(
                                                 (PRPC_SERVER_INTERFACE) IfSpec,
                                                 ObjUuidVector,
                                                 Annotation,
                                                 ReplaceNoReplace);
        return RPC_S_OK;
        }

    if (err = BindToEpMapper(&EpMapperHandle,
        NULL,       // NetworkAddress
        NULL,       // Protseq
        0,          // Options
        RPC_C_BINDING_DEFAULT_TIMEOUT,
        INFINITE,    // CallTimeout
        NULL        // AuthInfo
        ))
        {
        return err;
        }

    CountObj =  (unsigned int)ObjUuidVector->Count;
    CountBH = (unsigned int) BindingVector->Count;

    if ((p = (EpEntries =  (ept_entry_t *)
        I_RpcAllocate(CountBH * sizeof(ept_entry_t)))) == NULL)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    for (i = 0, Entries = 0;  (!err) && (i < CountBH); i++)
        {
        if (BindingVector->BindingH[i] == 0)
            {
            continue;
            }

        if (err = BindingAndIfToTower(IfSpec, BindingVector->BindingH[i], &Twr))
            {
            err = 0;
            continue;
            }

        if (Twr == NULL)
            {
            continue;
            }

        Entries ++;
        p->tower = Twr;
        lstrcpyA((char PAPI *)p->annotation, (char PAPI *)Annotation);
        p++;
        }

    for (j = 0; j < CountObj; j++)
        {
        for (k = 0, p = EpEntries; k < Entries; k++, p++)
            {
            RpcpMemoryCopy(
                (char PAPI *)&p->object,
                (char PAPI *)ObjUuidVector->Uuid[j],
                sizeof(UUID)
                );
            }

        RequestEPClientMutex();
        RpcTryExcept
            {
            ept_insert_ex(
                EpMapperHandle,
                &hEpContext,
                Entries,
                EpEntries,
                ReplaceNoReplace,
                (error_status PAPI *)&err
                );
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            err = RpcExceptionCode();
            }
        RpcEndExcept
        ClearEPClientMutex();

        if (err == RPC_S_SERVER_UNAVAILABLE)
            {
            //
            //Try to start the epmapper and retry
            //

            err = StartServiceIfNecessary();

            if (err == RPC_S_OK)
                {
                RequestEPClientMutex();
                RpcTryExcept
                    {
                    ept_insert_ex(
                        EpMapperHandle,
                        &hEpContext,
                        Entries,
                        EpEntries,
                        ReplaceNoReplace,
                        (error_status PAPI *)&err
                        );
                    }
                RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
                    {
                    RpcpErrorAddRecord(EEInfoGCRuntime,
                        EPT_S_CANT_CREATE,
                        EEInfoDLRegisterEntries10,
                        RpcExceptionCode());
                    err = EPT_S_CANT_CREATE;
                    }
                RpcEndExcept
                ClearEPClientMutex();
                }
            }

        if (err != RPC_S_OK)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                EPT_S_CANT_CREATE,
                EEInfoDLRegisterEntries20,
                err);
            err = EPT_S_CANT_CREATE;
            break;
            }

         // Subsequent Inserts should be (ALWAYS) NOREPLACE
         // ReplaceNoReplace = REGISTER_NOREPLACE;

        }  // for loop over UUID Vectors


    for (i = 0, p = EpEntries; i < Entries; i++,p++)
        I_RpcFree(p->tower);

    if (EpEntries)
        {
        I_RpcFree(EpEntries);
        }

    RpcBindingFree(&EpMapperHandle);

    if (err == RPC_S_OK)
        {
        //
        // We successfully registered our bindings,
        // reflect that in the interface so that if we get a
        // PNP notification, we can update the bindings
        //
        err = GlobalRpcServer->InterfaceExported(
                                                 (PRPC_SERVER_INTERFACE) IfSpec,
                                                 ObjUuidVector,
                                                 Annotation,
                                                 ReplaceNoReplace);
        }

    return(err);
}




RPC_STATUS RPC_ENTRY
RpcEpRegisterNoReplaceA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    )
/*++


Routine Description:

    A server application will call this routine to register
    a series of end points with the local endpoint mapper.

Arguments:


Return Value:


--*/
{
    UUID_VECTOR UuidVectorNull;
    UUID_VECTOR PAPI *PObjUuidVector = &UuidVectorNull;
    UUID NilUuid;
    unsigned char AnnotStr[] = {'\0'};
    THREAD *Thread;

    if (!ARGUMENT_PRESENT(Annotation))
        Annotation = AnnotStr;

    if (strlen((char PAPI *)Annotation) >= ep_max_annotation_size)
        return(EPT_S_INVALID_ENTRY);

    if (!ARGUMENT_PRESENT( BindingVector))
        {
        return(RPC_S_NO_BINDINGS);
        }

    if (ARGUMENT_PRESENT( UuidVector ))
        {
        PObjUuidVector = UuidVector;
        }
    else
        {
        UuidVectorNull.Count = 1;
        RpcpMemorySet(&NilUuid, 0, sizeof(UUID));
        UuidVectorNull.Uuid[0] = &NilUuid;
        }

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    return(RegisterEntries(
            IfSpec,
            BindingVector,
            PObjUuidVector,
            Annotation,
            EP_REGISTER_NOREPLACE
            ));
}





RPC_STATUS RPC_ENTRY
RpcEpRegisterNoReplaceW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned short * Annotation
    )
/*++


Routine Description:

    A server application will call this routine to register [Add]
    a series of end points with the local endpoint mapper
    This is the Unicode version of the API.

Arguments:

    IfSpec  - Server side Interface specification structure generated
        by MIDL, that describes Interface UUId and version

   Binding Vector - A vector of binding handles that the server has registered
        with the runtime.

   UuidVector- A vector of Uuids of objects that the server is supporting

   Annotation - Annotation String

Return Value:


--*/
{
        CHeapAnsi AnsiString;
        USES_CONVERSION;
    RPC_STATUS err;

    if (ARGUMENT_PRESENT(Annotation))
        {
        ATTEMPT_HEAP_W2A(AnsiString, Annotation);
        }

    err = RpcEpRegisterNoReplaceA(
                IfSpec,
                BindingVector,
                UuidVector,
                AnsiString
                );

    return(err);
}





RPC_STATUS RPC_ENTRY
RpcEpRegisterA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    )
/*++


Routine Description:

    A server application will call this routine to register
    a series of end points with the local endpoint mapper, replacing
    existing database entries in the process.

    This is the Ansi version of the API.

Arguments:

    IfSpec  - Server side Interface specification structure generated
        by MIDL, that describes Interface UUId and version

    Binding Vector- A vector of binding handles that the server has registered
        with the runtime.

    UuidVector- A vector of Uuids of objects that the server is supporting

    Annotation - Annotation String

Return Value:


--*/
{
    UUID_VECTOR UuidVectorNull;
    UUID_VECTOR PAPI *PObjUuidVector = &UuidVectorNull;
    UUID NilUuid;
    unsigned char AnnotStr[] = {'\0'};
    THREAD *Thread;

    if (!ARGUMENT_PRESENT(Annotation))
        Annotation = AnnotStr;

    if (strlen((char PAPI *)Annotation) >= ep_max_annotation_size)
        return(EPT_S_INVALID_ENTRY);

    if (!ARGUMENT_PRESENT( BindingVector))
        {
        return(RPC_S_NO_BINDINGS);
        }

    if (ARGUMENT_PRESENT( UuidVector ))
        {
        PObjUuidVector = UuidVector;
        }
    else
        {
        UuidVectorNull.Count = 1;
        RpcpMemorySet(&NilUuid, 0, sizeof(UUID));
        UuidVectorNull.Uuid[0] = &NilUuid;
        }

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    return(RegisterEntries(
                IfSpec,
                BindingVector,
                PObjUuidVector,
                Annotation,
                EP_REGISTER_REPLACE
                ));
}



RPC_STATUS RPC_ENTRY
RpcEpRegisterW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector,
    IN unsigned short * Annotation
    )
/*++


Routine Description:

    A server application will call this routine to register
    a series of end points with the local endpoint mapper, replcaing
    existing entries in the process.
    This is the Unicode version of the API.

Arguments:

    IfSpec  - Server side Interface specification structure generated
        by MIDL, that describes Interface UUId and version

    Binding Vector- A vector of binding handles that the server has registered
        with the runtime.

    UuidVector- A vector of Uuids of objects that the server is supporting

    Annotation - Annotation String

Return Value:


--*/
{
    USES_CONVERSION;
    CHeapAnsi AnsiString;
    RPC_STATUS err;

    if (ARGUMENT_PRESENT(Annotation))
        {
        ATTEMPT_HEAP_W2A(AnsiString, Annotation);
        }

    err = RpcEpRegisterA(
                IfSpec,
                BindingVector,
                UuidVector,
                AnsiString
                );

    return(err);
}





RPC_STATUS RPC_ENTRY
RpcEpUnregister(
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector
    )
/*++


Routine Description:

    A server application will call this routine to unregister
    a series of end points.

Arguments:

    IfSpec - Pointer to Interface Specification generated by MIDL

    BindingVector - A Vector of Binding handles maintained by runtime
        for the server.

    UuidVector - A Vector of UUIDs for objects supported by the the server

Return Value:

    RPC_S_OK -

    RPC_S_OUT_OF_MEMORY - There is no memory available to construct
                          towers

--*/
{
    UUID_VECTOR UuidVectorNull;
    UUID_VECTOR PAPI *PObjUuidVector = &UuidVectorNull;
    UUID NilUuid;
    RPC_STATUS err;
    unsigned int i, j, CountBH, CountObj;
    RPC_BINDING_HANDLE EpMapperHandle;
    ept_entry_t PAPI * EpEntries, * p;
    twr_t PAPI *Twr;

    if (!ARGUMENT_PRESENT( BindingVector))
        {
        return(RPC_S_NO_BINDINGS);
        }

    if (ARGUMENT_PRESENT( UuidVector ))
        {
        PObjUuidVector = UuidVector;
        }
    else
        {
        UuidVectorNull.Count = 1;
        RpcpMemorySet(&NilUuid, 0, sizeof(UUID));
        UuidVectorNull.Uuid[0] = &NilUuid;
        }

    if (err = BindToEpMapper(
        &EpMapperHandle,
        NULL,           // NetworkAddress
        NULL,           // Protseq
        0,              // Options
        RPC_C_BINDING_DEFAULT_TIMEOUT,
        INFINITE,        // CallTimeout
        NULL        // AuthInfo
        ))
        {
        return(err);
        }

    CountObj = (unsigned int)PObjUuidVector->Count;

    if ((EpEntries = (ept_entry_t *)
        I_RpcAllocate(sizeof(ept_entry_t)*CountObj)) == NULL)
        {
        RpcBindingFree(&EpMapperHandle);
        return(RPC_S_OUT_OF_MEMORY);
        }

    RPC_STATUS FinalStatus = EPT_S_CANT_PERFORM_OP;
    CountBH = (unsigned int) BindingVector->Count;

    for (i = 0; i < CountBH; i++)
        {
        if (BindingVector->BindingH[i] == 0)
            {
            continue;
            }

        if (err = BindingAndIfToTower(IfSpec, BindingVector->BindingH[i], &Twr))
            {
            FinalStatus = err;
            break;
            }

        if (Twr == NULL)
            {
            continue;
            }

        for (p=EpEntries,j = 0; j < CountObj; j++,p++)
            {
            RpcpMemoryCopy(
                (char PAPI *)&p->object,
                (char PAPI *)PObjUuidVector->Uuid[j],
                sizeof(UUID)
                );
            p->tower = Twr;
            p->annotation[0] = '\0';
            }

        RequestEPClientMutex();
        RpcTryExcept
            {
            ept_delete_ex(
                EpMapperHandle,
                &hEpContext,
                CountObj,
                EpEntries,
                (error_status PAPI *)&err
                );
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            err = EPT_S_CANT_PERFORM_OP;
            }
        RpcEndExcept
        ClearEPClientMutex();

        I_RpcFree(Twr);

        } // For loop over Binding Handle Vector

    if (FinalStatus != RPC_S_OK)
        {
        FinalStatus = err;
        }

    I_RpcFree(EpEntries);

    RpcBindingFree(&EpMapperHandle);

    return(FinalStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\dispatch.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    dispatch.h

Abstract:

Author:

    Michael Montague (mikemon) 11-Jun-1992

Revision History:

--*/

#ifndef __DISPATCH_H__
#define __DISPATCH_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef
unsigned int
(* DISPATCH_TO_STUB) (
    IN RPC_DISPATCH_FUNCTION Stub,
    IN OUT PRPC_MESSAGE Message,
    OUT RPC_STATUS * ExceptionCode
    );

/*
  This is used to dispatch calls to the stub via an indirect call.
  The call will go eihter through DispatchToStubInCAvrf or AvrfDispatchToStubInCNoAvrf,
  depending on whether app verifier is enabled.
*/
extern DISPATCH_TO_STUB DispatchToStubInC;

unsigned int
DispatchToStubInCNoAvrf (
    IN RPC_DISPATCH_FUNCTION Stub,
    IN OUT PRPC_MESSAGE Message,
    OUT RPC_STATUS * ExceptionCode
    );

unsigned int
DispatchToStubInCAvrf (
    IN RPC_DISPATCH_FUNCTION Stub,
    IN OUT PRPC_MESSAGE Message,
    OUT RPC_STATUS * ExceptionCode
    );

/*
  Used to check for callbacks since DG will hold connection mutex while
  dispatching callbacks and others may hold a user critical section.
  This will cause an app verifier break if we check for held critical sections
  after return from the manager routine.
*/
BOOL
IsCallbackMessage (
    IN PRPC_MESSAGE Message
    );

#ifdef __cplusplus
}
#endif

#endif // __DISPATCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\epmgmt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    epmgmt.c

Abstract:

    We implement the endpoint mapper management routines: RpcMgmtEpEltInqBegin,
    RpcMgmtEpEltInqDone, RpcMgmtEpEltInqNext, and RpcMgmtEpUnregister.

Author:

    Michael Montague (mikemon) 14-Apr-1993

Revision History:

--*/

#include <precomp.hxx>
#include <epmp.h>
#include <twrproto.h>
#include <epmap.h>
#include <charconv.hxx>

#define EP_INQUIRY_CONTEXT_MAGIC_VALUE 0xBAD00DADL

typedef struct _EP_INQUIRY_CONTEXT
{
    unsigned long MagicValue;
    RPC_BINDING_HANDLE BindingHandle;
    ept_lookup_handle_t ContextHandle;
    unsigned long InquiryType;
    RPC_IF_ID IfId;
    unsigned long VersOption;
    UUID ObjectUuid;
} EP_INQUIRY_CONTEXT;

#define NOMOREEPS  0xFFFFFFFEL

#define NOMOREEPS_HANDLE  ((ept_lookup_handle_t)ULongToPtr(NOMOREEPS))
// const ept_lookup_handle_t NOMOREEPS_HANDLE = (ept_lookup_handle_t)ULongToPtr(NOMOREEPS);


RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqBegin (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption OPTIONAL,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    )
/*++

Routine Description:

    This routine is used to create an inquiry context for viewing the elements
    in a local or remote endpoint mapper database.

Arguments:

    EpBinding - Optionally supplies a binding indicating the endpoint mapper on
        which host should be interogated.  The binding must have a nil object
        uuid; otherwise, EPT_S_CANT_PERFORM_OP will be returned.  To specify
        this host (meaning the one the application is running on), specify NULL
        for this argument.  Only the network address and transport type will
        be used from the binding handle.

    InquiryType - Supplies the type of interogation to be performed; this must
        be one of: RPC_C_EP_ALL_ELTS, RPC_C_EP_MATCH_BY_IF,
        RPC_C_EP_MATCH_BY_OBJ, and RPC_C_EP_MATCH_BY_BOTH.

    IfId - Optionally supplies the interface identifier we are interogating
        the endpoint mapper with.  This argument must be supplied when the
        inquiry type is RPC_C_EP_MATCH_BY_IF or RPC_C_EP_MATCH_BY_BOTH;
        otherwise, this argument is ignored and NULL can be supplied.

    VersOption - Optionally supplies a flag specifying how interface versions
        are to be matched.  This argument must be supplied when IfId is
        supplied; otherwise, this argument is ignored.  Valid values for this
        flag are: RPC_C_VERS_ALL, RPC_C_VERS_COMPATIBLE, RPC_C_VERS_EXACT,
        RPC_C_VERS_MAJOR_ONLY, and RPC_C_VERS_UPTO.

    ObjectUuid - Optionally supplies the object uuid find in the endpoint
        mapper database.  This argument must be supplied when the inquiry
        typedef is RPC_C_EP_MATCH_BY_OBJ or RPC_EP_MATCH_BY_BOTH; otherwise,
        this argument is ignored and NULL can be supplied.

    InquiryContext - Returns a context handle which can be passed to
        RpcMgmtEpEltInqNext to obtain the results of the interogation of the
        endpoint mapper database.

Return Value:

    RPC_S_INVALID_ARG
    EPT_S_CANT_PERFORM_OP
    RPC_S_OUT_OF_MEMORY

--*/
{
    RPC_STATUS RpcStatus;
    RPC_CHAR __RPC_FAR * ProtocolSequence;
    RPC_CHAR __RPC_FAR * NetworkAddress;
    RPC_CHAR __RPC_FAR * Options;
    EP_INQUIRY_CONTEXT __RPC_FAR * EpInquiryContext;
    unsigned Timeout;

    switch ( InquiryType )
        {
        case RPC_C_EP_ALL_ELTS :
            IfId = 0;
            ObjectUuid = 0;
            break;

        case RPC_C_EP_MATCH_BY_IF :
            ObjectUuid = 0;
            // no break
        case RPC_C_EP_MATCH_BY_BOTH :
            if ( IfId == 0 )
                {
                return(RPC_S_INVALID_ARG);
                }

            if (   ( VersOption != RPC_C_VERS_ALL )
                && ( VersOption != RPC_C_VERS_COMPATIBLE )
                && ( VersOption != RPC_C_VERS_EXACT )
                && ( VersOption != RPC_C_VERS_MAJOR_ONLY )
                && ( VersOption != RPC_C_VERS_UPTO ) )
                {
                return(RPC_S_INVALID_ARG);
                }

            if (   ( InquiryType == RPC_C_EP_MATCH_BY_BOTH )
                && ( ObjectUuid == 0 ) )
                {
                return(RPC_S_INVALID_ARG);
                }
            break;

        case RPC_C_EP_MATCH_BY_OBJ :
            IfId = 0;
            if ( ObjectUuid == 0 )
                {
                return(RPC_S_INVALID_ARG);
                }
            break;

        default:
            return(RPC_S_INVALID_ARG);
        }

    // At this point, we have validated the InquiryType, IfId, VersOption,
    // and ObjectUuid parameters.

    if ( EpBinding != 0 )
        {
        UUID Uuid;
        int Result;
        RPC_CHAR __RPC_FAR * StringBinding;

        RpcStatus = RpcBindingInqObject(EpBinding, &Uuid);
        if ( RpcStatus != RPC_S_OK )
            {
            return(RpcStatus);
            }
        Result = UuidIsNil(&Uuid, &RpcStatus);
        if ( Result == 0 )
            {
            return(EPT_S_CANT_PERFORM_OP);
            }

        RpcStatus = RpcBindingToStringBinding(EpBinding, &StringBinding);
        if ( RpcStatus != RPC_S_OK )
            {
            return(RpcStatus);
            }

        RpcStatus = RpcStringBindingParse(StringBinding, 0, &ProtocolSequence,
                &NetworkAddress, 0, &Options);
        RpcStringFree(&StringBinding);
        if ( RpcStatus != RPC_S_OK )
            {
            return(RpcStatus);
            }

        RpcStatus = RpcMgmtInqComTimeout(EpBinding, &Timeout);
        if ( RpcStatus != RPC_S_OK )
            {
            RpcStringFree(&ProtocolSequence);
            RpcStringFree(&NetworkAddress);
            RpcStringFree(&Options);
            return(RpcStatus);
            }
        }
    else
        {
        NetworkAddress = 0;
        ProtocolSequence = 0;
        Options = 0;
        Timeout = RPC_C_BINDING_DEFAULT_TIMEOUT;
        }

    // When we reach here, the EpBinding will have been validated, and the
    // network address and protocol sequence to be used to reach the endpoint
    // mapper have been determined.

    // Thus all of the arguments will have been validated.

    EpInquiryContext = (EP_INQUIRY_CONTEXT __RPC_FAR *) I_RpcAllocate(
            sizeof(EP_INQUIRY_CONTEXT));
    if ( EpInquiryContext == 0 )
        {
        if (EpBinding != 0)
            {
            RpcStringFree(&ProtocolSequence);
            RpcStringFree(&NetworkAddress);
            RpcStringFree(&Options);
            }
        return(RPC_S_OUT_OF_MEMORY);
        }

    RpcStatus = BindToEpMapper(&(EpInquiryContext->BindingHandle),
            NetworkAddress, 
            ProtocolSequence, 
            Options, 
            Timeout,
            INFINITE,        // CallTimeout
            NULL            // AuthInfo
            );

    if (EpBinding != 0)
        {
        RpcStringFree(&ProtocolSequence);
        RpcStringFree(&NetworkAddress);
        RpcStringFree(&Options);
        }

    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    EpInquiryContext->MagicValue = EP_INQUIRY_CONTEXT_MAGIC_VALUE;
    EpInquiryContext->ContextHandle = 0;
    EpInquiryContext->InquiryType = InquiryType;
    if ( IfId != 0 )
        {
        EpInquiryContext->IfId = *IfId;
        }
    EpInquiryContext->VersOption = VersOption;
    if ( ObjectUuid != 0 )
        {
        EpInquiryContext->ObjectUuid = *ObjectUuid;
        }

    *InquiryContext = (RPC_EP_INQ_HANDLE)EpInquiryContext;

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqDone (
    IN OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    )
/*++

Routine Description:

    The context handle used to interogate an endpoint mapper database is
    cleaned up in this routine.

Arguments:

    InquiryContext - Supplies the context handle to be deleted; on return,
        it will be set to zero.

Return Value:

    RPC_S_OK - Everything worked out just fine.

    RPC_S_INVALID_ARG - The supplied value supplied for the inquiry context
        is not an endpoint mapper inquiry context.

--*/
{
    EP_INQUIRY_CONTEXT __RPC_FAR * EpInquiryContext =
            (EP_INQUIRY_CONTEXT __RPC_FAR *) *InquiryContext;

    if ( EpInquiryContext->MagicValue != EP_INQUIRY_CONTEXT_MAGIC_VALUE )
        {
        return(RPC_S_INVALID_ARG);
        }

    RpcBindingFree(&(EpInquiryContext->BindingHandle));

    if ( (EpInquiryContext->ContextHandle != 0) &&
         (EpInquiryContext->ContextHandle != NOMOREEPS_HANDLE) )
        {
        RpcSsDestroyClientContext(&(EpInquiryContext->ContextHandle));
        }

    I_RpcFree(EpInquiryContext);
    *InquiryContext = 0;
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqNextW (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    )
/*++

Routine Description:

    This routine is the unicode thunk to RpcMgmtEpEltInqNextA.

--*/
{
    unsigned char * AnsiAnnotation;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcMgmtEpEltInqNextA( InquiryContext,
                                      IfId,
                                      Binding,
                                      ObjectUuid,
                                      Annotation ? &AnsiAnnotation : 0
                                      );

    if ( (RpcStatus == RPC_S_OK) && (Annotation) )
        {
        RpcStatus = A2WAttachHelper((char *)AnsiAnnotation, Annotation);
        I_RpcFree(AnsiAnnotation);
        }

    return RpcStatus;
}


RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqNextA (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    )
/*++

Routine Description:

    An application will use this routine to obtain the results of an
    interogation of the endpoint mapper database.

Arguments:

    InquiryContext - Supplies a context handle for the interogation.

    IfId - Returns the interface identifier of the element which was
        found in the endpoint mapper database.

    Binding - Optionally returns the binding handle contained in the element.

    Annotation - Optionally returns the annotation stored in the element.

Return Value:

    RPC_S_OK - We have successfully returned an element from the endpoint
        mapper database.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        operation.

    RPC_S_INVALID_ARG - The supplied value for the inquiry context is not
        a valid endpoint mapper inquiry context.

    EPT_S_CANT_PERFORM_OP -

    RPC_X_NO_MORE_ENTRIES - No more entries are available.  This will be
        returned after all of the entries have been returned from the
        endpoint mapper.

--*/
{
    EP_INQUIRY_CONTEXT __RPC_FAR * EpInquiryContext =
            (EP_INQUIRY_CONTEXT __RPC_FAR *) InquiryContext;
    unsigned long Returned;
    ept_entry_t EpEntry;
    error_status ErrorStatus;
    RPC_STATUS RpcStatus = RPC_S_OK;
    unsigned char __RPC_FAR * StringBinding;
    unsigned char __RPC_FAR * ProtocolSequence;
    unsigned char __RPC_FAR * Endpoint;
    unsigned char __RPC_FAR * NWAddress = 0;

    if ( EpInquiryContext->MagicValue != EP_INQUIRY_CONTEXT_MAGIC_VALUE )
        {
        return(RPC_S_INVALID_ARG);
        }

    if ( EpInquiryContext->ContextHandle == NOMOREEPS_HANDLE )
        {
        return (RPC_X_NO_MORE_ENTRIES);
        }

    while (1)
        {

        EpEntry.tower = 0;
        RpcTryExcept
            {
            ept_lookup(EpInquiryContext->BindingHandle,
                EpInquiryContext->InquiryType, &(EpInquiryContext->ObjectUuid),
                &(EpInquiryContext->IfId), EpInquiryContext->VersOption,
                &(EpInquiryContext->ContextHandle), 1, &Returned, &EpEntry,
                &ErrorStatus);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            RpcStatus = RpcExceptionCode();
            }
        RpcEndExcept

        if ( RpcStatus == RPC_S_OK )
            {
            if ( ErrorStatus == EP_S_NOT_REGISTERED )
                {
                RpcStatus = RPC_X_NO_MORE_ENTRIES;
                }
            else if ( ErrorStatus != 0 )
                {
                RpcStatus = EPT_S_CANT_PERFORM_OP;
                }
            }

        if (   ( RpcStatus == RPC_S_OK )
            && ( Returned != 1 ) )
            {
            RpcStatus = EPT_S_CANT_PERFORM_OP;
            }

        if (EpInquiryContext->ContextHandle == 0)
            {
            EpInquiryContext->ContextHandle = NOMOREEPS_HANDLE;
            }

        if ( RpcStatus != RPC_S_OK )
            {
            if (RpcStatus == RPC_S_SERVER_UNAVAILABLE)
               {
               RpcStatus = RPC_X_NO_MORE_ENTRIES;
               }

            return(RpcStatus);
            }

        RpcStatus = TowerExplode(EpEntry.tower, IfId, 0,
                (char __RPC_FAR * __RPC_FAR *) &ProtocolSequence,
                (char __RPC_FAR * __RPC_FAR *) &Endpoint,
                (char __RPC_FAR * __RPC_FAR *) &NWAddress
                );

        MIDL_user_free(EpEntry.tower);
        if (RpcStatus != RPC_S_OK)
            {
            if (  (EpInquiryContext->ContextHandle == 0) || (EpInquiryContext->ContextHandle == NOMOREEPS_HANDLE) )
              {
              EpInquiryContext->ContextHandle = NOMOREEPS_HANDLE;
              return(RPC_X_NO_MORE_ENTRIES);
              }
            else
              {
              RpcStatus = RPC_S_OK;
              continue;
              }
            }
        else
            {
            //Tower Explode returned Success
            if ( Binding != 0 )
                {
                if ( RpcStatus != RPC_S_OK )
                    {
                    return(RpcStatus);
                    }

                RpcStatus = RpcStringBindingComposeA(0,
                                                ProtocolSequence, NWAddress,
                                                Endpoint, 0, &StringBinding);
                if ( RpcStatus == RPC_S_OK )
                    {
                    RpcStatus = RpcBindingFromStringBindingA(
                                                StringBinding,
                                                Binding
                                                );
                    RpcStringFreeA(&StringBinding);
                    }
                if ( RpcStatus != RPC_S_OK )
                    {
                    RpcStringFreeA(&ProtocolSequence);
                    RpcStringFreeA(&Endpoint);
                    if (NWAddress != 0)
                       {
                       RpcStringFreeA(&NWAddress);
                       }

                    if ( (EpInquiryContext->ContextHandle == 0) || (EpInquiryContext->ContextHandle == NOMOREEPS_HANDLE) )
                        {
                        EpInquiryContext->ContextHandle = NOMOREEPS_HANDLE;
                        return(RPC_X_NO_MORE_ENTRIES);
                        }
                    else
                        {
                        RpcStatus = RPC_S_OK;
                        continue;
                        }
                    }
                }

            if (ObjectUuid != 0)
               {
               memcpy(ObjectUuid, &EpEntry.object, sizeof(UUID));
               }

            RpcStringFreeA(&ProtocolSequence);
            RpcStringFreeA(&Endpoint);
            if (NWAddress != 0)
               {
               RpcStringFreeA(&NWAddress);
               }
            }

        if ( Annotation != 0 )
            {
            *Annotation = (unsigned char __RPC_FAR *) I_RpcAllocate(
                strlen((LPCSTR) EpEntry.annotation) + 1);
            if ( *Annotation == 0 )
                {
                return(RPC_S_OUT_OF_MEMORY);
                }
            strcpy((LPSTR) *Annotation, (LPCSTR) EpEntry.annotation);
            }

        //MIDL_user_free(EpEntry.tower);
        break;
        }

        if (EpInquiryContext->ContextHandle == 0)
            {
            EpInquiryContext->ContextHandle = NOMOREEPS_HANDLE;
            }

        return(RpcStatus);

}


RPC_STATUS RPC_ENTRY
RpcMgmtEpUnregister (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN RPC_IF_ID __RPC_FAR * IfId,
    IN RPC_BINDING_HANDLE Binding,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL
    )
/*++

Routine Description:

    This routine is used by management applications to remote server address
    information from a local or remote endpoint map.

Arguments:

    EpBinding - Optionally supplies a binding handle specifying which host
        from which to unregister remote server address information.  To
        specify this host, supply zero for this argument.  If a binding
        handle is supplied, then the object uuid in the binding handle must
        be zero.

    IfId - Supplies the interface identifier to be removed from the endpoint
        mapper database.

    Binding - Supplies the binding handle to be removed from the endpoint
        mapper database.

    ObjectUuid - Optionally supplies an object uuid to be removed; a value
        of zero indicates there is no object uuid to be removed.

Return Value:

    RPC_S_OK -

    EPT_S_NOT_REGISTERED -

    EPT_S_CANT_PERFORM_OP -

--*/
{
    UUID Uuid;
    RPC_STATUS RpcStatus;
    int Result;

    RPC_CHAR * ProtocolSequence;
    RPC_CHAR * NetworkAddress;
    RPC_CHAR * Options;
    RPC_CHAR * StringBinding;

    unsigned char __RPC_FAR * AnsiProtocolSequence;
    unsigned char __RPC_FAR * AnsiNetworkAddress;
    unsigned char __RPC_FAR * AnsiEndpoint;
    unsigned char __RPC_FAR * AnsiStringBinding;

    RPC_BINDING_HANDLE EpBindingHandle;
    unsigned long UuidFlag;
    unsigned long ErrorStatus;
    twr_t __RPC_FAR * Tower;
    RPC_TRANSFER_SYNTAX TransferSyntax;
    unsigned Timeout;

    if ( EpBinding != 0 )
        {
        RpcStatus = RpcBindingInqObject(EpBinding, &Uuid);
        if ( RpcStatus != RPC_S_OK )
            {
            return(RpcStatus);
            }
        Result = UuidIsNil(&Uuid, &RpcStatus);
        if ( Result == 0 )
            {
            return(EPT_S_CANT_PERFORM_OP);
            }

        RpcStatus = RpcBindingToStringBinding(EpBinding, &StringBinding);
        if ( RpcStatus != RPC_S_OK )
            {
            return(RpcStatus);
            }

        RpcStatus = RpcStringBindingParse(  StringBinding,
                                            0,
                                            &ProtocolSequence,
                                            &NetworkAddress,
                                            0,
                                            &Options);
        RpcStringFree(&StringBinding);
        if ( RpcStatus != RPC_S_OK )
            {
            return(RpcStatus);
            }

        RpcStatus = RpcMgmtInqComTimeout(EpBinding, &Timeout);
        if ( RpcStatus != RPC_S_OK )
            {
            RpcStringFree(&ProtocolSequence);
            RpcStringFree(&NetworkAddress);
            RpcStringFree(&Options);
            return(RpcStatus);
            }
        }
    else
        {
        NetworkAddress = 0;
        ProtocolSequence = 0;
        Options = 0;
        Timeout = RPC_C_BINDING_DEFAULT_TIMEOUT;
        }

    // When we reach here, the EpBinding will have been validated, and the
    // network address and protocol sequence to be used to reach the endpoint
    // mapper have been determined.

    RpcStatus = BindToEpMapper( &EpBindingHandle,
                                NetworkAddress,
                                ProtocolSequence,
                                Options,
                                Timeout,
                                INFINITE,        // CallTimeout
                                NULL            // AuthInfo
                                );

    RpcStringFree(&ProtocolSequence);
    RpcStringFree(&NetworkAddress);
    RpcStringFree(&Options);

    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    RpcStatus = RpcBindingToStringBindingA(Binding, &AnsiStringBinding);
    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    RpcStatus = RpcStringBindingParseA( AnsiStringBinding,
                                        0,
                                        &AnsiProtocolSequence,
                                        &AnsiNetworkAddress,
                                        &AnsiEndpoint,
                                        0);
    RpcStringFreeA(&AnsiStringBinding);
    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    RpcStatus = TowerConstruct( IfId,
                                &TransferSyntax,
                                (LPSTR) AnsiProtocolSequence,
                                (LPSTR) AnsiEndpoint,
                                (LPSTR) AnsiNetworkAddress,
                                &Tower);

    RpcStringFreeA(&AnsiProtocolSequence);
    RpcStringFreeA(&AnsiNetworkAddress);
    RpcStringFreeA(&AnsiEndpoint);

    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    if ( ObjectUuid != 0 )
        {
        Uuid = *ObjectUuid;
        UuidFlag = 1;
        }
    else
        {
        UuidFlag = 0;
        }

    ASSERT( RpcStatus == RPC_S_OK );

    RpcTryExcept
        {
        ept_mgmt_delete(EpBindingHandle, UuidFlag, &Uuid, Tower, &ErrorStatus);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        RpcStatus = RpcExceptionCode();
        }
    RpcEndExcept

    if ( RpcStatus == RPC_S_OK )
        {
        if ( ErrorStatus != 0 )
            {
            RpcStatus = EPT_S_NOT_REGISTERED;
            }
        }
    else
    if ( RpcStatus == RPC_S_SERVER_UNAVAILABLE )
        {
        RpcStatus = EPT_S_NOT_REGISTERED;
        }

    RpcBindingFree(&EpBindingHandle);
    return(RpcStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\eventwrp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       eventwrp.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File: mutex.cxx

Description:

This file contains the system independent mutex class for NT.

History:

mikemon    ??-??-??    The beginning.
mikemon    12-31-90    Upgraded the comments.

-------------------------------------------------------------------- */

#include <precomp.hxx>


EVENT::EVENT (
    IN OUT RPC_STATUS PAPI * RpcStatus,
    IN int ManualReset,
    IN BOOL fDelayInit
    )
{
    EventHandle = NULL;

    // DelayInit events are auto reset
    ASSERT(ManualReset == FALSE || fDelayInit == FALSE);

    if (!fDelayInit && *RpcStatus == RPC_S_OK )
        {
		EventHandle = CreateEvent(NULL, ManualReset, 0, NULL);
        if ( EventHandle != NULL )
            {
            LogEvent(SU_EVENT, EV_CREATE, EventHandle, 0, 0, 1, 2);
            *RpcStatus = RPC_S_OK;
            }
        else
            {
            *RpcStatus = RPC_S_OUT_OF_MEMORY;
            }
        }	
}


EVENT::~EVENT (
    )
{

    if ( EventHandle )
        {
        LogEvent(SU_EVENT, EV_DELETE, EventHandle, 0, 0, 1, 2);
		
        BOOL bResult;
		bResult = CloseHandle(EventHandle);
		ASSERT(bResult != 0);
        }
}

int
EVENT::Wait (
    long timeout
    )
{
    DWORD result;

    if (NULL == EventHandle)
        {
        InitializeEvent();
        }

    result = WaitForSingleObject(EventHandle, timeout);

    if (result == WAIT_TIMEOUT)
        return(1);
    return(0);
}


void
EVENT::InitializeEvent (
    )
// Used when fDelayInit is TRUE in the c'tor.
{
    if (EventHandle)
        {
        return;
        }


    HANDLE event = CreateEvent(0, FALSE, FALSE, 0);

    if (event)
        {
        if (InterlockedCompareExchangePointer(&EventHandle, event, 0) != 0)
            {
            CloseHandle(event);
            }
        return;
        }

    // Can't allocate an event.
    RpcRaiseException(RPC_S_OUT_OF_RESOURCES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\eeinfo.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    EEInfo.cxx

Abstract:

    Extended Error Info public & private functions

Author:

    Kamen Moutafov    [KamenM]


Revision History:

    KamenM      Mar 2000    Initial version
    KamenM      Oct 2000    Add caching of EEInfo blocks to 
                            solve Exchange perf problems

--*/
#include <precomp.hxx>
#include <EEInfo.h>
#include <EEInfo.hxx>

const int MaxBinaryBlobSize = 4096; // 4K limit

ExtendedErrorInfo *
AllocateExtendedErrorInfoRecord (
    IN int NumberOfParams
    )
/*++

Routine Description:

    Allocates a memory block large enough to hold an
    extended error record with the specified number of
    parameters. It is allocated with MIDL_user_allocate.

Arguments:
    NumberOfParams - number of paramaters to provide space
        for

Return Value:

    The address of the block or NULL if out of memory

--*/
{
    ExtendedErrorInfo *EEInfo;
    THREAD *ThisThread;

    ThisThread = ThreadSelf();
    if (ThisThread)
        {
        EEInfo = ThisThread->GetCachedEEInfoBlock(NumberOfParams);
        }
    else
        EEInfo = NULL;

    if (EEInfo == NULL)
        {
        EEInfo = (ExtendedErrorInfo *) MIDL_user_allocate(sizeof(ExtendedErrorInfo) + 
            (NumberOfParams - 1) * sizeof(ExtendedErrorParam));
        }

    if (EEInfo)
        EEInfo->nLen = (short)NumberOfParams;
    return EEInfo;
}

inline void
FreeEEInfoRecordShallow (
    IN ExtendedErrorInfo *InfoToFree
    )
/*++

Routine Description:

    Frees only the eeinfo record - not any of
    the pointers contained in it.

Arguments:
    InfoToFree - the eeinfo record

Return Value:

    void

--*/
{
    MIDL_user_free(InfoToFree);
}

RPC_STATUS
DuplicatePrivateString (
    IN EEUString *SourceString,
    OUT EEUString *DestString
    )
/*++

Routine Description:

    Takes a EEUString structure and makes a copy
    of it.

Arguments:
    SourceString - the string to copy
    DestString - a placeholder allocated by caller to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    DestString->nLength = SourceString->nLength;
    DestString->pString = (LPWSTR)MIDL_user_allocate(DestString->nLength * sizeof(unsigned short));
    if (DestString->pString != NULL)
        {
        RpcpMemoryCopy(DestString->pString, SourceString->pString, DestString->nLength * sizeof(unsigned short));
        return RPC_S_OK;
        }
    else
        {
        return RPC_S_OUT_OF_MEMORY;
        }
}

RPC_STATUS
DuplicatePrivateString (
    IN EEAString *SourceString,
    OUT EEAString *DestString
    )
/*++

Routine Description:

    Takes a EEAString structure and makes a copy
    of it.

Arguments:
    SourceString - the string to copy
    DestString - a placeholder allocated by caller to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    DestString->nLength = SourceString->nLength;
    DestString->pString = (unsigned char *)MIDL_user_allocate(DestString->nLength);
    if (DestString->pString != NULL)
        {
        RpcpMemoryCopy(DestString->pString, SourceString->pString, DestString->nLength);
        return RPC_S_OK;
        }
    else
        {
        return RPC_S_OUT_OF_MEMORY;
        }
}

RPC_STATUS
DuplicateBlob (
    IN void *SourceBlob,
    IN short Size,
    OUT void **DestBlob)
/*++

Routine Description:

    Takes a blob and makes a copy of it.

Arguments:
    SourceBlob - the blob to copy
    Size - the size of the blob
    DestBlob - a placeholder where a pointer to the copied
        buffer will be put

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    void *CopiedBlob;

    CopiedBlob = MIDL_user_allocate(Size);
    if (CopiedBlob)
        {
        RpcpMemoryCopy(CopiedBlob, SourceBlob, Size);
        *DestBlob = CopiedBlob;
        return RPC_S_OK;
        }
    else
        {
        return RPC_S_OUT_OF_MEMORY;
        }
}

RPC_STATUS 
DuplicatePrivateBlob (
    IN BinaryEEInfo *SourceBlob,
    OUT BinaryEEInfo *DestBlob)
/*++

Routine Description:

    Takes a binary param and makes a copy of it.

Arguments:
    SourceBlob - the blob to copy
    DestBlob - a placeholder allocated by caller to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    RPC_STATUS Status;

    Status = DuplicateBlob(SourceBlob->pBlob, SourceBlob->nSize, (PVOID *)&DestBlob->pBlob);
    if (Status == RPC_S_OK)
        {
        DestBlob->nSize = SourceBlob->nSize;
        }

    return Status;
}

RPC_STATUS 
ConvertPublicStringToPrivateString (
    IN LPWSTR PublicString,
    OUT EEUString *PrivateString)
/*++

Routine Description:

    Takes a LPWSTR string and makes a copy
    of it into a EEUString structure

Arguments:
    PublicString - the string to copy - cannot be NULL
    PrivateString - a placeholder allocated by caller to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    // the StringLength is in bytes
    int StringLength = (wcslen(PublicString) + 1) * 2;
    LPWSTR CopiedString;
    CopiedString = (LPWSTR)MIDL_user_allocate(StringLength);
    if (CopiedString)
        {
        RpcpMemoryCopy(CopiedString, PublicString, StringLength);
        PrivateString->pString = CopiedString;
        PrivateString->nLength = (short)StringLength / 2;
        return RPC_S_OK;
        }
    else
        {
        return RPC_S_OUT_OF_MEMORY;
        }
}

RPC_STATUS 
ConvertPublicStringToPrivateString (
    IN LPSTR PublicString,
    OUT EEAString *PrivateString)
/*++

Routine Description:

    Takes a LPSTR string and makes a copy
    of it into a EEAString structure

Arguments:
    PublicString - the string to copy - cannot be NULL
    PrivateString - a placeholder allocated by caller to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    int StringLength = strlen(PublicString) + 1;
    LPSTR CopiedString;
    CopiedString = (LPSTR)MIDL_user_allocate(StringLength);
    if (CopiedString)
        {
        RpcpMemoryCopy(CopiedString, PublicString, StringLength);
        PrivateString->pString = (unsigned char *)CopiedString;
        PrivateString->nLength = (short)StringLength;
        return RPC_S_OK;
        }
    else
        {
        return RPC_S_OUT_OF_MEMORY;
        }
}

RPC_STATUS 
ConvertPublicBlobToPrivateBlob (
    IN BinaryParam *PublicBlob,
    OUT BinaryEEInfo *PrivateBlob)
/*++

Routine Description:

    Takes a binary param and converts it to private format.

Arguments:
    PublicBlob - the blob to copy - cannot be NULL
    PrivateBlob - a placeholder allocated by caller to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    unsigned char *CopiedBlob;

    if (PublicBlob->Size > MaxBinaryBlobSize)
        {
        return ERROR_INVALID_PARAMETER;
        }

    RPC_STATUS Status;

    Status = DuplicateBlob(PublicBlob->Buffer, PublicBlob->Size, (PVOID *)&PrivateBlob->pBlob);
    if (Status == RPC_S_OK)
        {
        PrivateBlob->nSize = PublicBlob->Size;
        }

    return Status;
}

RPC_STATUS
ConvertPrivateStringToPublicString (
    IN EEUString *PrivateString,
    IN BOOL CopyStrings,
    OUT LPWSTR *PublicString
    )
/*++

Routine Description:

    Takes a EEUString and makes a copy
    of it into a LPWSTR

Arguments:
    PrivateString - the string to copy
    CopyStrings - if non-zero this routine will allocate
        space on the process heap and will copy the string.
        If zero, it will alias the PublicString to the
        pString member of PrivateString
    PublicString - the string to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    LPWSTR ReturnString;
    int StringLength;   // in bytes

    if (CopyStrings)
        {
        StringLength = PrivateString->nLength * 2;
        ReturnString = (LPWSTR)RtlAllocateHeap(RtlProcessHeap(), 0, StringLength);
        if (ReturnString == NULL)
            return RPC_S_OUT_OF_MEMORY;
        RpcpMemoryCopy(ReturnString, PrivateString->pString, StringLength);
        }
    else
        {
        ReturnString = PrivateString->pString;
        }

    *PublicString = ReturnString;
    return RPC_S_OK;
}

RPC_STATUS
ConvertPrivateStringToPublicString (
    IN EEAString *PrivateString,
    IN BOOL CopyStrings,
    OUT LPSTR *PublicString
    )
/*++

Routine Description:

    Takes a EEAString and makes a copy
    of it into a LPSTR

Arguments:
    PrivateString - the string to copy
    CopyStrings - if non-zero this routine will allocate
        space on the process heap and will copy the string.
        If zero, it will alias the PublicString to the
        pString member of PrivateString
    PublicString - the string to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    LPSTR ReturnString;
    if (CopyStrings)
        {
        ReturnString = (LPSTR)RtlAllocateHeap(RtlProcessHeap(), 0, PrivateString->nLength);
        if (ReturnString == NULL)
            return RPC_S_OUT_OF_MEMORY;
        RpcpMemoryCopy(ReturnString, PrivateString->pString, PrivateString->nLength);
        }
    else
        {
        ReturnString = (char *)PrivateString->pString;
        }

    *PublicString = ReturnString;
    return RPC_S_OK;
}

RPC_STATUS
ConvertPrivateBlobToPublicBlob (
    IN BinaryEEInfo *PrivateBlob,
    IN BOOL CopyStrings,
    OUT BinaryParam *PublicBlob
    )
/*++

Routine Description:

    Takes a private blob and makes a copy
    of it into a public blob format

Arguments:
    PrivateBlob - the blob to copy
    CopyStrings - if non-zero this routine will allocate
        space on the process heap and will copy the blob.
        If zero, it will alias the PublicBlob to the
        Blob.pBlob member of PrivateBlob
    PublicBlob - the blob to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    void *ReturnBuffer;
    if (CopyStrings)
        {
        ReturnBuffer = RtlAllocateHeap(RtlProcessHeap(), 0, PrivateBlob->nSize);
        if (ReturnBuffer == NULL)
            return RPC_S_OUT_OF_MEMORY;
        RpcpMemoryCopy(ReturnBuffer, PrivateBlob->pBlob, PrivateBlob->nSize);
        }
    else
        {
        ReturnBuffer = PrivateBlob->pBlob;
        }

    PublicBlob->Buffer = ReturnBuffer;
    PublicBlob->Size = PrivateBlob->nSize;
    return RPC_S_OK;
}

inline void
FreePublicStringIfNecessary (
    OUT LPWSTR PublicString,
    IN BOOL CopyStrings
    )
/*++

Routine Description:

    Deletes the string if necessary

Arguments:
    PublicString - the string to delete. Must be on the
        process heap
    CopyStrings - the value of the CopyStrings parameter
        when RpcErrorGetNextRecord was called. If non-zero
        the string will be freed. Otherwise, the function
        is a no-op

Return Value:

    void

--*/
{
    if (CopyStrings)
        {
        if (PublicString)
            {
            RtlFreeHeap(RtlProcessHeap(), 0, PublicString);
            }
        }
}

RPC_STATUS 
ConvertPublicParamToPrivateParam (
    IN RPC_EE_INFO_PARAM *PublicParam,
    OUT ExtendedErrorParam *PrivateParam
    )
/*++

Routine Description:

    Takes a parameter in format RPC_EE_INFO_PARAM and
    converts it to ExtendedErrorParam.

Arguments:
    PublicParam - the parameter to copy.
    PrivateParam - the parameter to copy to

Return Value:

    RPC_S_OK, RPC_S_INTERNAL_ERROR, RPC_S_OUT_OF_MEMORY

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    PrivateParam->Type = (ExtendedErrorParamTypesInternal)PublicParam->ParameterType;
    switch (PrivateParam->Type)
        {
        case eeptiAnsiString:
            RpcStatus = ConvertPublicStringToPrivateString(PublicParam->u.AnsiString,
                 &PrivateParam->AnsiString);
            break;

        case eeptiUnicodeString:
            RpcStatus = ConvertPublicStringToPrivateString(PublicParam->u.UnicodeString,
                &PrivateParam->UnicodeString);
            break;

        case eeptiLongVal:
            PrivateParam->LVal = PublicParam->u.LVal;
            break;

        case eeptiShortVal:
            PrivateParam->IVal = PublicParam->u.SVal;
            break;

        case eeptiPointerVal:
            PrivateParam->PVal = (ULONGLONG)PublicParam->u.PVal;
            break;

        case eeptiNone:
            break;

        case eeptiBinary:
            RpcStatus = ConvertPublicBlobToPrivateBlob(&PublicParam->u.BVal,
                &PrivateParam->Blob);
            break;

        default:
            ASSERT(FALSE);
            RpcStatus = ERROR_INVALID_PARAMETER;
        }
    return RpcStatus;
}

RPC_STATUS 
ConvertPrivateParamToPublicParam (
    IN ExtendedErrorParam *PrivateParam,
    IN BOOL CopyStrings,
    OUT RPC_EE_INFO_PARAM *PublicParam
    )
/*++

Routine Description:

    Takes a parameter in format ExtendedErrorParam and
    converts it to RPC_EE_INFO_PARAM.

Arguments:
    PrivateParam - the parameter to copy
    CopyStrings - if non-zero, this function will allocate
        space for any strings to be copied on the process
        heap and will copy the strings. If FALSE, it
        will alias the output pointers to RPC internal
        data structures
    PublicParam - the parameter to copy to

Return Value:

    RPC_S_OK, RPC_S_INTERNAL_ERROR, RPC_S_OUT_OF_MEMORY

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    PublicParam->ParameterType = (ExtendedErrorParamTypes)PrivateParam->Type;
    switch (PublicParam->ParameterType)
        {
        case eeptAnsiString:
            RpcStatus = ConvertPrivateStringToPublicString(&PrivateParam->AnsiString,
                CopyStrings,
                &PublicParam->u.AnsiString);
            break;

        case eeptUnicodeString:
            RpcStatus = ConvertPrivateStringToPublicString(&PrivateParam->UnicodeString,
                CopyStrings,
                &PublicParam->u.UnicodeString);
            break;

        case eeptLongVal:
            PublicParam->u.LVal = PrivateParam->LVal;
            break;

        case eeptShortVal:
            PublicParam->u.SVal = PrivateParam->IVal;
            break;

        case eeptPointerVal:
            PublicParam->u.PVal = PrivateParam->PVal;
            break;

        case eeptNone:
            break;

        case eeptBinary:
            RpcStatus = ConvertPrivateBlobToPublicBlob(&PrivateParam->Blob,
                CopyStrings,
                &PublicParam->u.BVal);
            break;

        default:
            ASSERT(FALSE);
            RpcStatus = RPC_S_INTERNAL_ERROR;
        }
    return RpcStatus;    
}

void
InitializePrivateEEInfo (
    IN ExtendedErrorInfo *ErrorInfo
    )
/*++

Routine Description:

    Initializes the common data members of the ExtendedErrorInfo
    structure.

Arguments:
    ErrorInfo - the structure to initialize

Return Value:

    void

--*/
{
    ErrorInfo->Next = NULL;
    ErrorInfo->ComputerName.Type = eecnpNotPresent;
    ErrorInfo->ProcessID = GetCurrentProcessId();
    GetSystemTimeAsFileTime((FILETIME *)&ErrorInfo->TimeStamp);
    ErrorInfo->Flags = 0;
}

RPC_STATUS 
ConvertPublicEEInfoToPrivateEEInfo (
    IN RPC_EXTENDED_ERROR_INFO *PublicEEInfo,
    IN short DetectionLocation,
    OUT ExtendedErrorInfo *PrivateEEInfo
    )
/*++

Routine Description:

    Takes a RPC_EXTENDED_ERROR_INFO record and converts
    it to an ExtendedErrorInfo record.

Arguments:
    PublicEEInfo - the public record to convert
    DetectionLocation - the detection location to use in the
        private record.
    PrivateEEInfo - the private record to copy to

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    int NumberOfParams;
    int i;
    RPC_STATUS RpcStatus = RPC_S_OK;

    ASSERT(PrivateEEInfo != NULL);
    ASSERT(PrivateEEInfo->nLen == PublicEEInfo->NumberOfParameters);

    if (PublicEEInfo->Version != RPC_EEINFO_VERSION)
        return RPC_S_INVALID_LEVEL;

    InitializePrivateEEInfo(PrivateEEInfo);
    // EEInfoGCCOM can come externally. If it's not, set it to
    // EEInfoGCApplication
    if (PublicEEInfo->GeneratingComponent != EEInfoGCCOM)
        {
        PrivateEEInfo->GeneratingComponent = EEInfoGCApplication;
        }
    else
        {
        PrivateEEInfo->GeneratingComponent = EEInfoGCCOM;
        }
    PrivateEEInfo->Status = PublicEEInfo->Status;
    PrivateEEInfo->DetectionLocation = DetectionLocation;
    // the next line should have been executed by the allocating code
    //PrivateEEInfo->nLen = PublicEEInfo->NumberOfParameters;
    NumberOfParams = PrivateEEInfo->nLen;

    for (i = 0; i < NumberOfParams; i ++)
        {
        if ((PublicEEInfo->Parameters[i].ParameterType < eeptAnsiString)
            || (PublicEEInfo->Parameters[i].ParameterType > eeptBinary))
            RpcStatus = ERROR_INVALID_PARAMETER;

        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = ConvertPublicParamToPrivateParam(&PublicEEInfo->Parameters[i],
                &PrivateEEInfo->Params[i]);
            }

        if (RpcStatus != RPC_S_OK)
            {
            // go backward and free all memory
            i --;
            for (; i >= 0; i --)
                {
                FreeEEInfoPrivateParam(&PrivateEEInfo->Params[i]);
                }
            break;
            }
        }

    return RpcStatus;
}

RPC_STATUS 
ConvertPrivateEEInfoToPublicEEInfo (
    IN ExtendedErrorInfo *PrivateEEInfo,
    IN BOOL CopyStrings,
    OUT RPC_EXTENDED_ERROR_INFO *PublicEEInfo
    )
/*++

Routine Description:

    Takes an ExtendedErrorInfo record and converts
    it to a RPC_EXTENDED_ERROR_INFO  record.

Arguments:
    PrivateEEInfo - the private record to convert
    CopyStrings - If non-zero, all strings will be allocated
        space on the process heap and will be copied. Otherwise
        they will be aliased to the privated data structure 
        strings
    PublicEEInfo - the public record to copy to

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    BOOL Result;
    int NumberOfParams;
    int i;
    RPC_STATUS RpcStatus;

    ASSERT (PublicEEInfo != NULL);

    if (PublicEEInfo->Version != RPC_EEINFO_VERSION)
        return RPC_S_INVALID_LEVEL;

    if (PublicEEInfo->NumberOfParameters < PrivateEEInfo->nLen)
        return RPC_S_BUFFER_TOO_SMALL;

    if (PublicEEInfo->Flags & (~EEInfoValidInputFlags))
        return RPC_S_INVALID_LEVEL;

    if (PrivateEEInfo->ComputerName.Type == eecnpNotPresent)
        {
        PublicEEInfo->ComputerName = NULL;
        }
    else
        {
        RpcStatus = ConvertPrivateStringToPublicString(&PrivateEEInfo->ComputerName.Name,
            CopyStrings, &PublicEEInfo->ComputerName);
        if (RpcStatus != RPC_S_OK)
            return RpcStatus;
        }
    PublicEEInfo->ProcessID = PrivateEEInfo->ProcessID;
    if (PublicEEInfo->Flags & EEInfoUseFileTime)
        {
        RpcpMemoryCopy(&PublicEEInfo->u.FileTime, &PrivateEEInfo->TimeStamp, sizeof(FILETIME));
        }
    else
        {
        Result = FileTimeToSystemTime((FILETIME *)&PrivateEEInfo->TimeStamp,
            &PublicEEInfo->u.SystemTime);
        if (Result == 0)
            return GetLastError();
        }
    PublicEEInfo->GeneratingComponent = PrivateEEInfo->GeneratingComponent;
    PublicEEInfo->Status = PrivateEEInfo->Status;
    PublicEEInfo->DetectionLocation = PrivateEEInfo->DetectionLocation;
    PublicEEInfo->Flags = PrivateEEInfo->Flags;
    // restore the consistency of the flags, if necessary
    if (PrivateEEInfo->Next)
        {
        // if there is next record, and its flags indicate that
        // a previous record is missing
        if (PrivateEEInfo->Next->Flags & EEInfoPreviousRecordsMissing)
            PublicEEInfo->Flags |= EEInfoNextRecordsMissing;
        }
    NumberOfParams = PrivateEEInfo->nLen;
    PublicEEInfo->NumberOfParameters = NumberOfParams;

    for (i = 0; i < NumberOfParams; i ++)
        {
        // convert the params
        RpcStatus = ConvertPrivateParamToPublicParam(&PrivateEEInfo->Params[i],
            CopyStrings, &PublicEEInfo->Parameters[i]);
        if (RpcStatus != RPC_S_OK)
            {
            // go back, and free eveyrthing
            FreePublicStringIfNecessary(PublicEEInfo->ComputerName, CopyStrings);
            i --;
            for ( ; i >= 0; i --)
                {
                FreeEEInfoPublicParam(&PublicEEInfo->Parameters[i], CopyStrings);
                }
            return RpcStatus;
            }
        }

    return RPC_S_OK;
}

RPC_STATUS
CloneEEInfoParam (
    IN ExtendedErrorParam *SourceParam,
    OUT ExtendedErrorParam *DestParam
    )
/*++

Routine Description:

    Makes an exact deep copy of an ExtendedErrorParam structure

Arguments:
    SourceParam - the parameter to copy from
    DestParam - the parameter to copy to

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    ASSERT (DestParam != NULL);

    switch (SourceParam->Type)
        {
        case eeptiAnsiString:
            RpcStatus = DuplicatePrivateString(&SourceParam->AnsiString,
                &DestParam->AnsiString);
            break;

        case eeptiUnicodeString:
            RpcStatus = DuplicatePrivateString(&SourceParam->UnicodeString,
                &DestParam->UnicodeString);
            break;

        case eeptiLongVal:
            DestParam->LVal = SourceParam->LVal;
            break;

        case eeptiShortVal:
            DestParam->IVal = SourceParam->IVal;
            break;

        case eeptiPointerVal:
            DestParam->PVal = SourceParam->PVal;
            break;

        case eeptiNone:
            break;

        case eeptiBinary:
            RpcStatus = DuplicatePrivateBlob(&SourceParam->Blob,
                &DestParam->Blob);
            break;

        default:
            ASSERT(0);
            RpcStatus = RPC_S_INTERNAL_ERROR;
        }

    DestParam->Type = SourceParam->Type;

    return RpcStatus;
}

RPC_STATUS
CloneEEInfoRecord (
    IN ExtendedErrorInfo *SourceInfo,
    OUT ExtendedErrorInfo **DestInfo
    )
/*++

Routine Description:

    Makes an exact deep copy of a single ExtendedErrorInfo record

Arguments:
    SourceInfo - the record to copy from
    DestInfo - the record to copy to

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ExtendedErrorInfo *NewInfo;
    int NumberOfParams;
    int i;
    RPC_STATUS RpcStatus;
    EEUString *ComputerNameToFree = NULL;

    *DestInfo = NULL;
    NumberOfParams = SourceInfo->nLen;
    NewInfo = AllocateExtendedErrorInfoRecord(NumberOfParams);
    if (NewInfo == NULL)
        return RPC_S_OUT_OF_MEMORY;

    // shallow copy all the fields. This is good for most fields
    // we will process the ones that need deep copy further down.
    // we copy everything, but the first param, which may require
    // deep copying
    RpcpMemoryCopy(NewInfo, SourceInfo, sizeof(ExtendedErrorInfo) - sizeof(ExtendedErrorParam));
    // N.B. Zero out the next field before any failure paths
    NewInfo->Next = NULL;
    if (SourceInfo->ComputerName.Type == eecnpPresent)
        {
        RpcStatus = DuplicatePrivateString(&SourceInfo->ComputerName.Name,
            &NewInfo->ComputerName.Name);
        if (RpcStatus != RPC_S_OK)
            {
            FreeEEInfoRecordShallow(NewInfo);
            return RpcStatus;
            }

        ComputerNameToFree = &NewInfo->ComputerName.Name;
        }

    for (i = 0; i < NumberOfParams; i ++)
        {
        RpcStatus = CloneEEInfoParam(&SourceInfo->Params[i],
            &NewInfo->Params[i]);
        if (RpcStatus != RPC_S_OK)
            {
            if (ComputerNameToFree)
                MIDL_user_free(ComputerNameToFree->pString);
            i --;
            for ( ; i >= 0; i --)
                {
                FreeEEInfoPrivateParam(&NewInfo->Params[i]);
                }
            FreeEEInfoRecordShallow(NewInfo);

            return RpcStatus;
            }
        }

    *DestInfo = NewInfo;
    return RPC_S_OK;
}

RPC_STATUS
CloneEEInfoChain (
    IN ExtendedErrorInfo *SourceEEInfo,
    OUT ExtendedErrorInfo **DestEEInfo
    )
/*++

Routine Description:

    Makes an exact deep copy of an ExtendedErrorInfo chain

Arguments:
    SourceEEInfo - the head of the chain to copy from
    DestEEInfo - a pointer to the head of the cloned chain.
        The memory for the head of the cloned chain will be
        allocated by this function and the given pointer
        will be set to point to it.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ExtendedErrorInfo *CurrentInfo, *NewInfo, *NewInfoHead = NULL;
    ExtendedErrorInfo *LastNewInfo = NULL;
    RPC_STATUS RpcStatus;

    CurrentInfo = SourceEEInfo;
    while (CurrentInfo != NULL)
        {
        RpcStatus = CloneEEInfoRecord(CurrentInfo, &NewInfo);
        if (RpcStatus != RPC_S_OK)
            {
            if (NewInfoHead != NULL)
                FreeEEInfoChain(NewInfoHead);
            return RpcStatus;
            }
        if (NewInfoHead == NULL)
            NewInfoHead = NewInfo;

        if (LastNewInfo != NULL)
            LastNewInfo->Next = NewInfo;

        // advance both chains
        LastNewInfo = NewInfo;
        CurrentInfo = CurrentInfo->Next;
        }

    *DestEEInfo = NewInfoHead;
    return RPC_S_OK;
}

const ULONG EnumSignatureLive = 0xfcfcfcfc;
const ULONG EnumSignatureDead = 0xfdfdfdfd;

void
InitializeEnumHandleWithEEInfo (
    IN ExtendedErrorInfo *EEInfo,
    IN OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    )
/*++

Routine Description:

    Initializes the common fields of a RPC_ERROR_ENUM_HANDLE
    structure

Arguments:
    EEInfo - the chain we're enumerating from
    EnumHandle - the structure to initialize

Return Value:

    void

--*/
{
    ASSERT(EEInfo != NULL);
    EnumHandle->Signature = EnumSignatureLive;
    EnumHandle->Head = EEInfo;
    EnumHandle->CurrentPos = EEInfo;
}

RPC_STATUS 
RpcpErrorStartEnumerationFromEEInfo (
    IN ExtendedErrorInfo *EEInfo,
    IN OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    )
/*++

Routine Description:

    Starts an eeinfo enumeration using the passed
        EEInfo structure to start the enumeration

Arguments:
    EEInfo - the chain we will enumerate
    EnumHandle - the enumeration handle

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ExtendedErrorInfo *ClonedEEInfo;
    RPC_STATUS RpcStatus;
    
    RpcStatus = CloneEEInfoChain(EEInfo, &ClonedEEInfo);
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    InitializeEnumHandleWithEEInfo(ClonedEEInfo, EnumHandle);

    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorStartEnumeration (
    IN OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    )
/*++

Routine Description:

    Starts an eeinfo enumeration using the eeinfo on 
    the thread

Arguments:
    EnumHandle - the enumeration handle. Allocated by caller

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ExtendedErrorInfo *ClonedEEInfo, *EEInfo;
    RPC_STATUS RpcStatus;
    THREAD *Thread;
    
    // get the EEInfo from the Teb
    Thread = RpcpGetThreadPointer();
    if (Thread == NULL)
        return RPC_S_ENTRY_NOT_FOUND;

    EEInfo = Thread->GetEEInfo();

    if (EEInfo == NULL)
        return RPC_S_ENTRY_NOT_FOUND;

    return RpcpErrorStartEnumerationFromEEInfo(EEInfo, EnumHandle);
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorGetNextRecord (
    IN RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    IN BOOL CopyStrings, 
    OUT RPC_EXTENDED_ERROR_INFO *ErrorInfo
    )
/*++

Routine Description:

    Retrieves the next private record from the enumeration
    and converts it to public format

Arguments:
    EnumHandle - the enumeration handle
    CopyStrings - if non-zero, all strings converted to public
        format will be allocated space for on the process heap
        and will be copied there. If FALSE, the strings in the
        public structures will be aliases to the private structure
    ErrorInfo - the public record that will be filled on output

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    ExtendedErrorInfo *CurrentRecord;

    ASSERT(EnumHandle != NULL);
    ASSERT(EnumHandle->Head != NULL);
    ASSERT(EnumHandle->Signature != EnumSignatureDead);

    if (EnumHandle->Signature != EnumSignatureLive)
        return ERROR_INVALID_PARAMETER;

    if (EnumHandle->CurrentPos == NULL)
        return RPC_S_ENTRY_NOT_FOUND;

    CurrentRecord = (ExtendedErrorInfo *) EnumHandle->CurrentPos;
    RpcStatus = ConvertPrivateEEInfoToPublicEEInfo(CurrentRecord,
        CopyStrings, ErrorInfo);

    if (RpcStatus == RPC_S_OK)
        {
        EnumHandle->CurrentPos = CurrentRecord->Next;
        }

    return RpcStatus;
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorEndEnumeration (
    IN OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    )
/*++

Routine Description:

    Finished the enumeration and frees all resources associated with
    the enumeration

Arguments:
    EnumHandle - the enumeration handle

Return Value:

    RPC_S_OK or RPC_S_* error - can fail only if given invalid parameters

--*/
{
    ExtendedErrorInfo *EEInfoChain;

    ASSERT(EnumHandle != NULL);
    ASSERT(EnumHandle->Head != NULL);
    ASSERT(EnumHandle->Signature != EnumSignatureDead);

    if (EnumHandle->Signature != EnumSignatureLive)
        return ERROR_INVALID_PARAMETER;

    EEInfoChain = (ExtendedErrorInfo *)EnumHandle->Head;
    FreeEEInfoChain(EEInfoChain);
    EnumHandle->Head = NULL;
    EnumHandle->Signature = EnumSignatureDead;

    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorResetEnumeration (
    IN OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    )
/*++

Routine Description:

    Reset the enumeration so that the next call to
        RpcErrorGetNextRecord returns the first record
        again.

Arguments:
    EnumHandle - the enumeration handle

Return Value:

    RPC_S_OK or RPC_S_* error - can fail only if given invalid
        parameters

--*/
{
    ASSERT(EnumHandle != NULL);
    ASSERT(EnumHandle->Head != NULL);
    ASSERT(EnumHandle->Signature != EnumSignatureDead);

    if (EnumHandle->Signature != EnumSignatureLive)
        return ERROR_INVALID_PARAMETER;

    EnumHandle->CurrentPos = EnumHandle->Head;

    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorGetNumberOfRecords (
    IN RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    OUT int *Records
    )
/*++

Routine Description:

    Gets the number of records in the chain that it currently
    enumerated

Arguments:
    EnumHandle - the enumeration handle
    Records - on output will contain the number of records

Return Value:

    RPC_S_OK or RPC_S_* error - the function cannot fail unless
        given invalid parameters

--*/
{
    ExtendedErrorInfo *CurrentRecord;
    int Count;

    ASSERT(EnumHandle != NULL);
    ASSERT(EnumHandle->Head != NULL);
    ASSERT(EnumHandle->Signature != EnumSignatureDead);

    if (EnumHandle->Signature != EnumSignatureLive)
        return ERROR_INVALID_PARAMETER;

    CurrentRecord = (ExtendedErrorInfo *) EnumHandle->Head;
    Count = 0;
    while (CurrentRecord != NULL)
        {
        Count ++;
        CurrentRecord = CurrentRecord->Next;
        }

    *Records = Count;
    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorSaveErrorInfo (
    IN RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    OUT PVOID *ErrorBlob, 
    OUT size_t *BlobSize
    )
/*++

Routine Description:

    Saves the eeinfo in the enumeration to a memory block

Arguments:
    EnumHandle - the enumeration handle
    ErrorBlob - on output the allocated and filled in blob
        containing the eeinfo in binary format
    BlobSize - on output the size of the blob

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ULONG EncodedSize;
    ExtendedErrorInfo *EEInfo;
    handle_t PickleHandle;
    char *TempBuffer;
    RPC_STATUS RpcStatus;
    ExtendedErrorInfoPtr *EEInfoPtr;
    size_t MarshallSize;
    HANDLE ProcessHeap;
    PVOID Buffer;

    ASSERT(EnumHandle != NULL);
    ASSERT(EnumHandle->Head != NULL);
    ASSERT(EnumHandle->Signature != EnumSignatureDead);

    if (EnumHandle->Signature != EnumSignatureLive)
        return ERROR_INVALID_PARAMETER;

    // pickle the eeinfo into a buffer
    RpcStatus = MesEncodeDynBufferHandleCreate(&TempBuffer, &EncodedSize, &PickleHandle);
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    EEInfo = (ExtendedErrorInfo *) EnumHandle->Head;
    EEInfoPtr = &EEInfo;

    // get the estimated size
    MarshallSize = ExtendedErrorInfoPtr_AlignSize(PickleHandle, EEInfoPtr);

    ProcessHeap = RtlProcessHeap();

    Buffer = RtlAllocateHeap(ProcessHeap, 0, MarshallSize);
    if (Buffer == NULL)
        {
        MesHandleFree(PickleHandle);
        return RPC_S_OUT_OF_MEMORY;
        }
    TempBuffer = (char *)Buffer;

    // re-initialize the handle to fixed buffer
    RpcStatus = MesBufferHandleReset(PickleHandle, 
        MES_FIXED_BUFFER_HANDLE, 
        MES_ENCODE, 
        &TempBuffer, 
        MarshallSize, 
        &EncodedSize);

    if (RpcStatus != RPC_S_OK)
        {
        MesHandleFree(PickleHandle);
        RtlFreeHeap(ProcessHeap, 0, Buffer);
        return RpcStatus;
        }

    // do the pickling itself
    RpcTryExcept
        {
        ExtendedErrorInfoPtr_Encode(PickleHandle, EEInfoPtr);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        RpcStatus = RpcExceptionCode();
        }
    RpcEndExcept

    if (RpcStatus != RPC_S_OK)
        {
        MesHandleFree(PickleHandle);
        RtlFreeHeap(ProcessHeap, 0, Buffer);
        return RpcStatus;
        }

    // whack out the rest, to prevent random process data going out on the wire/disk
    RpcpMemorySet((unsigned char *)Buffer + EncodedSize, 0, MarshallSize - EncodedSize);

    MesHandleFree(PickleHandle);
    
    *ErrorBlob = Buffer;
    *BlobSize = EncodedSize;
    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorLoadErrorInfo (
    IN PVOID ErrorBlob, 
    IN size_t BlobSize, 
    OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    )
/*++

Routine Description:

    Creates an enumeration from a blob

Arguments:
    ErrorBlob - the blob as obtained by RpcErrorSaveErrorInfo
    BlobSize - the size of the blob as obtained by RpcErrorSaveErrorInfo
    EnumHandle - the enumeration handle allocated by the caller
        and filled on output

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    ExtendedErrorInfo *EEInfo;

    RpcStatus = UnpickleEEInfo((unsigned char *)ErrorBlob, BlobSize, &EEInfo);
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    InitializeEnumHandleWithEEInfo(EEInfo, EnumHandle);

    return RPC_S_OK;
}

RPC_STATUS
AddPrivateRecord (
    IN ExtendedErrorInfo *ErrorInfo
    )
/*++

Routine Description:

    Adds the supplied record to the top of the chain in the teb

    N.B. There can be no additional failure paths in the callers
    after this function. This is because it will chain this
    record to the teb, and if we bail out later, the teb will
    point to invalid record.

Arguments:
    ErrorInfo - the eeinfo record to add to the chain

Return Value:

    RPC_S_OK or RPC_S_* error - the function cannot fail if the
        RPC per-thread object has already been allocated for this
        thread

--*/
{
    THREAD *Thread;

    Thread = ThreadSelf();
    if (Thread == NULL)
        return RPC_S_OUT_OF_MEMORY;

    ErrorInfo->Next = Thread->GetEEInfo();
    Thread->SetEEInfo(ErrorInfo);

    return RPC_S_OK;
}

inline LPWSTR
ReplaceWithEmptyStringIfNull (
    IN LPWSTR String
    )
{
    return (String ? String : L"");
}

inline LPSTR
ReplaceWithEmptyStringIfNull (
    IN LPSTR String
    )
{
    return (String ? String : "");
}

void
RpcpErrorAddRecord (
    ULONG GeneratingComponent,
    ULONG Status,
    USHORT DetectionLocation,
    int NumberOfParameters,
    ExtendedErrorParam *Params
    )
/*++

Routine Description:

    Adds an extended error info to the thread. The
    following is a description of how fields are set:
    Next - will be set to the next record.
    ComputerName - will be set to not-present (eecnpNotPresent)
    ProcessID - will be set to the process ID
    TimeStamp - will be set to the current time
    GeneratingComponent - set to GeneratingComponent
    Status - set to Status
    DetectionLocation - set to DetectionLocation
    Flags - set to 0.
    nLen - set to NumberOfParameters
    Params will be copied to the parameters array. The caller can
        allocate them off the stack if it wants.

    N.B. The runtime should never directly call this function. If it
    needs to add records, it should call one of the overloaded 
    RpcpErrorAddRecord functions below. If there isn't one suitable,
    add one. All the RpcpErrorAddRecord functions below are just
    syntactic sugar for this function.

Arguments:
    GeneratingComponent - will be set in the record
    Status - will be set in the record
    DetectionLocation - will be set in the record
    NumberOfParameters - the number of parameters in the Params array
    Params - the parameters to add

Return Value:

    void - this is a best effort - no guarantees. Even if we
    return failure, there's little the caller can do about it.

--*/
{
    ExtendedErrorInfo *NewRecord;
    RPC_STATUS RpcStatus;
    int i;

    LogEvent(SU_EEINFO, 
        (char)GeneratingComponent, 
        ULongToPtr(Status), 
        ULongToPtr(DetectionLocation), 
        (NumberOfParameters > 0) ? Params[0].LVal : 0);

    NewRecord = AllocateExtendedErrorInfoRecord(NumberOfParameters);
    if (NewRecord == NULL)
        {
        // If allocation of extended error information has failed
        // we need to free the parameters passed in since there is
        // no way to communicate the failure to the upper layers.
        if (Params != NULL)
            {
            for (i = NumberOfParameters - 1; i >= 0; i--)
                {
                FreeEEInfoPrivateParam(&Params[i]);
                }
            }
        return;
        }

    InitializePrivateEEInfo(NewRecord);
    NewRecord->DetectionLocation = DetectionLocation;
    NewRecord->GeneratingComponent = GeneratingComponent;
    NewRecord->Status = Status;
    
    for (i = 0; i < NumberOfParameters; i ++)
        {
        // all parameter types requiring an allocation have already
        // been copied by our caller - no need to clone - we can just
        // do shallow copy
        RpcpMemoryCopy(&NewRecord->Params[i], &Params[i], sizeof(ExtendedErrorParam));
        }

    RpcStatus = AddPrivateRecord(NewRecord);
    if (RpcStatus != RPC_S_OK)
        {
        FreeEEInfoRecord(NewRecord);
        }
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long,
    IN short Short,
    IN ULONG Long2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[3];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;
    Params[1].Type = eeptiShortVal;
    Params[1].IVal = Short;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long,
    IN short Short,
    IN ULONG Long2,
    IN ULONG Long3
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;
    Params[1].Type = eeptiShortVal;
    Params[1].IVal = Short;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long2;
    Params[3].Type = eeptiLongVal;
    Params[3].LVal = (long)Long3;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        4,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long,
    IN ULONG Long2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[2];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;
    Params[1].Type = eeptiLongVal;
    Params[1].LVal = (long)Long2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        2,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPWSTR String1,
    IN LPWSTR String2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[2];
    RPC_STATUS RpcStatus;
    int i;
    LPWSTR Strings[2];

    Strings[0] = ReplaceWithEmptyStringIfNull(String1);
    Strings[1] = ReplaceWithEmptyStringIfNull(String2);
    for (i = 0; i < 2; i ++)
        {
        RpcStatus = ConvertPublicStringToPrivateString(Strings[i],
            &Params[i].UnicodeString);
        if (RpcStatus == RPC_S_OK)
            {
            Params[i].Type = eeptiUnicodeString;
            }
        else
            {
            Params[i].Type = eeptiNone;
            }
        }

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        2,
        Params);

}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPWSTR String1,
    IN LPWSTR String2,
    IN ULONG Long1,
    IN ULONG Long2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];
    RPC_STATUS RpcStatus;
    int i;
    LPWSTR Strings[2];

    Strings[0] = ReplaceWithEmptyStringIfNull(String1);
    Strings[1] = ReplaceWithEmptyStringIfNull(String2);
    for (i = 0; i < 2; i ++)
        {
        RpcStatus = ConvertPublicStringToPrivateString(Strings[i],
            &Params[i].UnicodeString);
        if (RpcStatus == RPC_S_OK)
            {
            Params[i].Type = eeptiUnicodeString;
            }
        else
            {
            Params[i].Type = eeptiNone;
            }
        }

    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long1;
    Params[3].Type = eeptiLongVal;
    Params[3].LVal = (long)Long2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        4,
        Params);

}


void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPWSTR String1,
    IN LPWSTR String2,
    IN ULONG Long1,
    IN ULONGLONG PVal1
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];
    RPC_STATUS RpcStatus;
    int i;
    LPWSTR Strings[2];

    Strings[0] = ReplaceWithEmptyStringIfNull(String1);
    Strings[1] = ReplaceWithEmptyStringIfNull(String2);
    for (i = 0; i < 2; i ++)
        {
        RpcStatus = ConvertPublicStringToPrivateString(Strings[i],
            &Params[i].UnicodeString);
        if (RpcStatus == RPC_S_OK)
            {
            Params[i].Type = eeptiUnicodeString;
            }
        else
            {
            Params[i].Type = eeptiNone;
            }
        }

    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long1;
    Params[3].Type = eeptiPointerVal;
    Params[3].PVal = (long)PVal1;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        4,
        Params);

}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long1,
    IN ULONG Long2,
    IN LPWSTR String,
    IN ULONG Long3
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];
    RPC_STATUS RpcStatus;

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long1;
    Params[1].Type = eeptiLongVal;
    Params[1].LVal = (long)Long2;
    Params[3].Type = eeptiLongVal;
    Params[3].LVal = (long)Long3;

    RpcStatus = ConvertPublicStringToPrivateString(
        ReplaceWithEmptyStringIfNull(String),
        &Params[2].UnicodeString);
    if (RpcStatus == RPC_S_OK)
        {
        Params[2].Type = eeptiUnicodeString;
        }
    else
        {
        Params[2].Type = eeptiNone;
        }

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        4,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPWSTR String,
    IN ULONG Long
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[2];
    RPC_STATUS RpcStatus;

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;

    RpcStatus = ConvertPublicStringToPrivateString(
        ReplaceWithEmptyStringIfNull(String),
        &Params[1].UnicodeString);
    if (RpcStatus == RPC_S_OK)
        {
        Params[1].Type = eeptiUnicodeString;
        }
    else
        {
        Params[1].Type = eeptiNone;
        }

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        2,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPWSTR String,
    IN ULONG Long1,
    IN ULONG Long2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[3];
    RPC_STATUS RpcStatus;

    Params[1].Type = eeptiLongVal;
    Params[1].LVal = (long)Long1;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long2;

    RpcStatus = ConvertPublicStringToPrivateString(
        ReplaceWithEmptyStringIfNull(String),
        &Params[0].UnicodeString);
    if (RpcStatus == RPC_S_OK)
        {
        Params[0].Type = eeptiUnicodeString;
        }
    else
        {
        Params[0].Type = eeptiNone;
        }

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPWSTR String
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[1];
    RPC_STATUS RpcStatus;

    RpcStatus = ConvertPublicStringToPrivateString(
        ReplaceWithEmptyStringIfNull(String),
        &Params[0].UnicodeString);
    if (RpcStatus == RPC_S_OK)
        {
        Params[0].Type = eeptiUnicodeString;
        }
    else
        {
        Params[0].Type = eeptiNone;
        }

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        1,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPSTR String
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[1];
    RPC_STATUS RpcStatus;

    RpcStatus = ConvertPublicStringToPrivateString(
        ReplaceWithEmptyStringIfNull(String),
        &Params[0].AnsiString);
    if (RpcStatus == RPC_S_OK)
        {
        Params[0].Type = eeptiAnsiString;
        }
    else
        {
        Params[0].Type = eeptiNone;
        }

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        1,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long,
    IN ULONG Long2,
    IN ULONG Long3
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[3];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;
    Params[1].Type = eeptiLongVal;
    Params[1].LVal = (long)Long2;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long3;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONGLONG PVal1,
    IN ULONGLONG PVal2,
    IN ULONG Long
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[3];

    Params[0].Type = eeptiPointerVal;
    Params[0].PVal = PVal1;
    Params[1].Type = eeptiPointerVal;
    Params[1].PVal = PVal2;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONGLONG PVal1,
    IN ULONGLONG PVal2,
    IN ULONG Long1,
    IN ULONG Long2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];

    Params[0].Type = eeptiPointerVal;
    Params[0].PVal = PVal1;
    Params[1].Type = eeptiPointerVal;
    Params[1].PVal = PVal2;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long1;
    Params[3].Type = eeptiLongVal;
    Params[3].LVal = (long)Long2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        4,
        Params);
}


void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONGLONG PVal1,
    IN ULONGLONG PVal2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[2];

    Params[0].Type = eeptiPointerVal;
    Params[0].PVal = PVal1;
    Params[1].Type = eeptiPointerVal;
    Params[1].PVal = PVal2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        2,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONGLONG PVal1,
    IN ULONG LVal1
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[2];

    Params[0].Type = eeptiPointerVal;
    Params[0].PVal = PVal1;
    Params[1].Type = eeptiLongVal;
    Params[1].PVal = LVal1;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        2,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long,
    IN ULONGLONG PVal1
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[2];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = Long;
    Params[1].Type = eeptiPointerVal;
    Params[1].PVal = PVal1;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        2,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long,
    IN ULONGLONG PVal1,
    IN ULONGLONG PVal2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[3];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;
    Params[1].Type = eeptiPointerVal;
    Params[1].PVal = PVal1;
    Params[2].Type = eeptiPointerVal;
    Params[2].PVal = PVal2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[1];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        1,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG LVal1,
    IN ULONGLONG PVal1,
    IN ULONG LVal2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[3];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)LVal1;
    Params[1].Type = eeptiPointerVal;
    Params[1].PVal = PVal1;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal